// https://www.redditstatic.com/desktop2x/ModerationPages.b4d1ca8f5da0ae048485.js
// Retrieved at 7/20/2022, 10:40:05 AM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["ModerationPages", "CollectionCommentsPage~CommentsPage~ProfileComments~ProfileOverview~ProfilePrivate~RpanListingUnit~S~5809214e", "CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81", "PostCreation~Reddit~StandalonePostPage~reddit-components-ClassicPost~reddit-components-CompactPost~r~4c415e24", "Governance~Reddit~Subreddit~reddit-components-ClassicPost~reddit-components-CompactPost~reddit-compo~bd4baca2", "Governance~ModListing~Reddit~ReportFlow~Subreddit", "Governance~Reddit~SubredditForkingCTA", "AuthorHovercard~Reddit"], {
		"./src/chat/controls/Svg/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2Qq40Mz_DMe0iARkTh8cZn",
				component: "_2Qq40Mz_DMe0iARkTh8cZn",
				disable: "_2xw21QiaL_ouF76MONf7hF",
				active: "_2dOhVJ6aPS9cbx0JfiKCW8",
				hover: "_1eWUKX11coBa2dErvWkP1q"
			}
		},
		"./src/chat/controls/Svg/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/chat/controls/Svg/index.m.less"),
				d = n.n(i);
			t.a = a.a.wrapped(e => {
				const t = {
						height: e.height || void 0,
						width: e.width || void 0
					},
					{
						disable: n,
						active: s,
						hover: a
					} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(e.className, {
						[d.a.disable]: n,
						[d.a.active]: s,
						[d.a.hover]: !!a
					}),
					viewBox: e.viewBox,
					style: t,
					onClick: e.onClick
				}, e.children)
			}, "Component", d.a)
		},
		"./src/higherOrderComponents/asModal/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			const r = () => {
					const e = document.getElementById(s.a);
					e && (e.style.filter = "blur(10px)")
				},
				o = () => {
					const e = document.getElementById(s.a);
					e && e.style.removeProperty("filter")
				}
		},
		"./src/higherOrderComponents/asModal/index.m.less": function(e, t, n) {
			e.exports = {
				overlay: "_1DK52RbaamLOWw5UPaht_S",
				mIsVisible: "_1acwN_tUhJ8w-n7oCp-Aw3",
				mIsBlurred: "_3Tq-_9917Q-o0iyzcNAeZn",
				modal: "_2Bejocqb-InO8686E2ehf"
			}
		},
		"./src/higherOrderComponents/asModal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/helpers.ts"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/FocusTrap/index.ts"),
				d = n("./src/lib/portal/index.tsx"),
				c = n("./src/reddit/actions/shortcuts/utils.ts"),
				l = n("./src/reddit/constants/shortcuts.ts"),
				u = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				m = n("./src/higherOrderComponents/asModal/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const h = e => {
				let {
					className: t,
					shouldBlurBackground: n,
					isVisible: s,
					...o
				} = e;
				return r.a.createElement("div", b({
					className: Object(a.a)(p.a.overlay, t, {
						[p.a.mIsVisible]: s,
						[p.a.mIsBlurred]: n
					})
				}, o))
			};

			function f(e) {
				class t extends s.Component {
					constructor(e) {
						super(e), this.getRef = e => this.ref = e, this.onClick = e => e.stopPropagation(), this.onOverlayClick = e => {
							this.props.onOverlayClick && this.props.onOverlayClick(), e.stopPropagation()
						}, this.state = {
							mounted: !1
						}
					}
					componentDidMount() {
						this.props.ignoreDefaultFocus || this.ref && this.ref.focus(), this.setState({
							mounted: !0
						}), Object(u.a)(), this.ref && (this.focusTrap = new i.b(this.ref), this.focusTrap.activate()), this.props.shouldBlurBackground && Object(o.a)()
					}
					componentWillUnmount() {
						this.setState({
							mounted: !1
						}), Object(u.b)(), Object(c.d)(), this.focusTrap && this.focusTrap.deactivate(), this.props.shouldBlurBackground && Object(o.b)()
					}
					render() {
						const {
							props: t
						} = this, {
							className: n,
							ignoreDefaultFocus: s,
							onOverlayClick: o,
							overlayClassName: i,
							overlayCustomStyles: c,
							shouldBlurBackground: u,
							withOverlay: m,
							...b
						} = t, f = b;
						return r.a.createElement(d.a, {
							container: document.getElementById(l.b)
						}, r.a.createElement(h, {
							className: i,
							isVisible: m,
							onClick: this.onOverlayClick,
							shouldBlurBackground: u,
							style: c
						}, r.a.createElement("div", {
							"aria-modal": !0,
							className: Object(a.a)(p.a.modal, n),
							onClick: this.onClick,
							ref: this.getRef,
							role: "dialog",
							tabIndex: -1
						}, r.a.createElement(e, f))))
					}
				}
				return t
			}
		},
		"./src/higherOrderComponents/warnOnChildrenCount/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			n("./src/lib/logs/console.ts");
			t.a = function(e, t) {
				return t => r.a.createElement(e, t)
			}
		},
		"./src/higherOrderComponents/withImageUploads.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/imageUploads.ts"),
				a = n("./src/reddit/models/Image/index.tsx"),
				i = n("./src/reddit/selectors/imageUploads.ts");
			const d = Object(r.c)({
				_imageUploads: i.b
			});

			function c(e, t) {
				return Object(s.b)(d, e => ({
					uploadImage: n => e(t(n)),
					cancelUpload: t => e(Object(o.h)(t))
				}), (function(e, t, n) {
					return {
						...n,
						...t,
						getImageUploadsIfModified: function(t) {
							return function(e, t) {
								const n = [];
								let s = !1;
								for (const r of t)
									if (Object(a.i)(r) || e[r.id])
										if (e[r.id]) {
											const t = e[r.id];
											n.push(t), s = s || t !== r
										} else s = !0;
								else n.push(r);
								return s ? n : null
							}(e._imageUploads, t)
						}
					}
				}))(e)
			}
		},
		"./src/lib/CSSVariableProvider/withTheme.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/CSSVariableProvider/index.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function i(e) {
				const t = t => r.a.createElement(o.b.Consumer, null, n => r.a.createElement(e, a({
					theme: n
				}, t)));
				return t.displayName = `WithTheme(${e.displayName||e.name})`, t
			}
		},
		"./src/lib/FocusTrap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = ['input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", "a[href]", "button:not([disabled])", '[tabindex]:not([tabindex="-1"]):not([disabled])', "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join();
			class r {
				constructor(e) {
					this.active = !1, this.onKeyDown = e => {
						if ("Tab" === e.key || 9 === e.keyCode) {
							const [t, n] = this.getTabbableNodes();
							if (!t || !n) return;
							e.shiftKey && e.target === t ? (e.preventDefault(), this.tryToFocusNode(n)) : e.shiftKey || e.target !== n || (e.preventDefault(), this.tryToFocusNode(t))
						}
					}, this.container = e
				}
				activate() {
					this.active || (this.active = !0, document.addEventListener("keydown", this.onKeyDown, !0))
				}
				deactivate() {
					this.active && (document.removeEventListener("keydown", this.onKeyDown, !0), this.active = !1)
				}
				getTabbableNodes() {
					const e = this.container.querySelectorAll(s);
					return [e[0], e[e.length - 1]]
				}
				tryToFocusNode(e) {
					e !== document.activeElement && e.focus && e.focus()
				}
			}
		},
		"./src/lib/LinkedListMap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			class s {
				constructor(e) {
					this.value = e, this.next = void 0, this.prev = void 0
				}
			}
			class r {
				constructor(e) {
					this.key = e, this.tail = void 0, this.head = void 0, this.length = 0, this.itemsByKey = {}
				}
				static fromArray(e, t) {
					const n = new r(t);
					return e.forEach(e => n.push(e)), n
				}
				first() {
					if (this.tail) return this.tail.value
				}
				firstNode() {
					if (this.tail) return this.tail
				}
				forEach(e) {
					let t = this.tail;
					for (; t;) e(t.value), t = t.next
				}
				get(e) {
					const t = this.getNode(e);
					if (t) return t.value
				}
				getNode(e) {
					return this.itemsByKey[e]
				}
				has(e) {
					return e in this.itemsByKey
				}
				insertAfter(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.prev = r, n.next = r.next, r.next = n, n.next && (n.next.prev = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				insertBefore(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.next = r, n.prev = r.prev, r.prev = n, n.prev && (n.prev.next = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				last() {
					if (this.head) return this.head.value
				}
				lastNode() {
					if (this.head) return this.head
				}
				pop() {
					if (!this.head) return;
					return this.removeNode(this.head).value
				}
				push(e) {
					const t = e instanceof s ? e : new s(e);
					t.prev = this.head, this.head ? this.head.next = t : this.tail = t, this.head = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
				remove(e) {
					const t = this.getNode(e);
					if (t) return this.removeNode(t).value
				}
				removeNode(e) {
					return e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this.tail && (this.tail = e.next), e === this.head && (this.head = e.prev), e.next = void 0, e.prev = void 0, this.itemsByKey[e.value[this.key]] = void 0, this.length--, e
				}
				shift() {
					if (!this.tail) return;
					return this.removeNode(this.tail).value
				}
				toArray() {
					const e = [];
					return this.forEach(t => e.push(t)), e
				}
				unshift(e) {
					const t = e instanceof s ? e : new s(e);
					t.next = this.tail, this.tail ? this.tail.prev = t : this.head = t, this.tail = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
			}
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/ads/session-signals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/localStorageAvailable/index.ts");
			const r = e => {
					let t = 0;
					if (Object(s.a)()) {
						const n = localStorage.getItem(e);
						n && !isNaN(parseInt(n)) && (t = parseInt(n))
					}
					return t
				},
				o = e => {
					Object(s.a)() && localStorage.removeItem(e)
				},
				a = (e, t) => {
					const n = r(e) + t;
					Object(s.a)() && localStorage.setItem(e, n.toString())
				},
				i = () => ({
					numberOfAdsSeen: r("client-session-signals-number-of-ads-seen"),
					numberOfPostsSeen: r("client-session-signals-number-of-posts-seen")
				}),
				d = e => {
					if (!e) return;
					const t = Object.keys(e).length,
						n = Object.values(e).filter(e => e.isSponsored).length;
					(e => {
						a("client-session-signals-number-of-posts-seen", e)
					})(t), (e => {
						a("client-session-signals-number-of-ads-seen", e)
					})(n)
				},
				c = () => {
					o("client-session-signals-number-of-ads-seen"), o("client-session-signals-number-of-posts-seen")
				}
		},
		"./src/lib/assertNever.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				throw new Error(`Unexpected object: ${e}`)
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/bignumber.js/bignumber.js");

			function r(e, t) {
				const n = new s.BigNumber(e),
					r = new s.BigNumber(t),
					o = new s.BigNumber(n.dividedBy(r)),
					a = new s.BigNumber("100").multipliedBy(o);
				return new s.BigNumber(a).toNumber()
			}
		},
		"./src/lib/browser/isIncognito.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts");
			const r = 120 * s.hb;
			t.a = async () => {
				let e = await (async () => await new Promise(e => {
					const t = window.RequestFileSystem || window.webkitRequestFileSystem;
					t ? t(0, 100, () => e(!1), () => e(!0)) : e(void 0)
				}))();
				return e || (e = await (async () => {
					if ("storage" in navigator && "estimate" in navigator.storage) {
						const {
							quota: e
						} = await navigator.storage.estimate();
						return !e || e <= r
					}
				})()), e
			}
		},
		"./src/lib/combineRefs/index.tsx": function(e, t, n) {
			"use strict";
			t.a = function() {
				for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
				return e => {
					t.forEach(t => {
						if (t) return "function" == typeof t ? t(e) : void(t.current = e)
					})
				}
			}
		},
		"./src/lib/constants/icons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rpan: "rpan",
				rpan_fill: "rpan_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_live: "video_live",
				video_live_fill: "video_live_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "custom"
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return e.startsWith("http") ? e.replace(/^http:\/\//i, "https://") : `https://${e}`
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");

			function o(e, t) {
				return e ? e.fields && e.fields.length ? e.fields.map(e => e.msg).join(", ") : e.type && a[e.type] ? a[e.type]() : 401 === t ? s.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : s.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const a = {
				[r.j]: () => s.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.L]: () => s.fbt._("GIF size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.Z / r.hb).toString())], {
					hk: "1zzsdM"
				}),
				[r.R]: () => s.fbt._("Image size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.bb / r.hb).toString())], {
					hk: "3H6bF8"
				}),
				[r.T]: () => s.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.pc]: () => s.fbt._("Video size must be less than {max file size}GB", [s.fbt._param("max file size", (r.fb / r.hb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/getShortenedLink.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Media/index.ts"),
				r = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = n.n(r);
			t.a = function(e) {
				var t;
				const {
					source: n,
					isSponsored: r,
					domainOverride: a,
					callToAction: i
				} = e;
				let d = "";
				if (r) {
					if (n && n.displayText) {
						const e = 36 - (null !== (t = null == i ? void 0 : i.length) && void 0 !== t ? t : 0);
						return n.displayText.length > e ? n.displayText.substring(0, e - 3) + "..." : n.displayText
					}
					d = a || Object(s.D)(e)
				} else d = Object(s.D)(e);
				const c = o.a.parse(d),
					l = c.path || "",
					u = l.length > 7 ? l.substring(0, 7) + "..." : l;
				return (c.hostname ? c.hostname.replace("www.", "") : "") + u
			}
		},
		"./src/lib/hooks/useOnClickOutside.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e, t) {
				const n = Object(s.useCallback)(n => {
					if (!t) return;
					const s = document.getElementById(e);
					s && (s.contains(n.target) || t(n))
				}, [e, t]);
				Object(s.useEffect)(() => {
					if (t) return window.addEventListener("click", n), () => {
						window.removeEventListener("click", n)
					}
				}, [t, n])
			}
		},
		"./src/lib/hooks/usePrevious.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e) {
				const t = Object(s.useRef)();
				return Object(s.useEffect)(() => {
					t.current = e
				}), t.current
			}
		},
		"./src/lib/hooks/useTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./node_modules/react-popper/lib/esm/usePopper.js");
			const a = Object(s.freeze)({
				modifiers: []
			});

			function i(e) {
				let t = "object" == typeof e ? e : a;
				return Array.isArray(t.modifiers) || (t = Object(s.assoc)(t, "modifiers", a.modifiers)), t
			}

			function d(e) {
				const [t, n] = Object(r.useState)(null), [a, d] = Object(r.useState)(null), [c, l] = Object(r.useState)(null), [u, m] = Object(r.useState)(!1), p = Object(r.useCallback)(async () => m(!0), []), b = Object(r.useCallback)(() => m(!1), []), h = Object(r.useCallback)(() => m(!u), [u]), f = Object(r.useMemo)(() => {
					const t = i(e);
					return c ? Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, {
						name: "arrow",
						options: {
							element: c
						}
					})) : t
				}, [c, e]), {
					attributes: g,
					styles: _,
					update: v
				} = Object(o.a)(t, a, f);
				return Object(r.useMemo)(() => ({
					arrowProps: {
						ref: l,
						style: _.arrow,
						...g.arrow
					},
					hide: b,
					popperProps: {
						ref: d,
						style: _.popper,
						...g.popper
					},
					show: p,
					target: {
						element: t,
						ref: n
					},
					toggle: h,
					visible: u,
					update: v
				}), [l, g, d, b, p, _, t, n, h, u, v])
			}
		},
		"./src/lib/humanizeDate/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/intlSupport.ts");

			function a(e) {
				let {
					showDay: t,
					useUtc: n,
					shortMonths: a,
					locale: i = s.DEFAULT_LOCALE
				} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				const d = new Date(e * r.Sb);
				return o.a ? new Intl.DateTimeFormat(i, {
					month: a ? "short" : "long",
					day: t ? "numeric" : void 0,
					year: "numeric",
					timeZone: n ? "UTC" : void 0
				}).format(d) : d.toLocaleString()
			}
		},
		"./src/lib/humanizeUTCDate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js");
			t.a = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.DEFAULT_LOCALE;
				const n = e.toString().length > 10,
					r = new Date(e * (n ? 1 : 1e3));
				return r.toLocaleString(t, {
					weekday: "short",
					month: "short",
					year: "numeric",
					day: "2-digit",
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
					timeZoneName: "short",
					timeZone: "UTC"
				})
			}
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			}));
			var s = n("./node_modules/linkify-it/index.js"),
				r = n.n(s),
				o = n("./node_modules/tlds/index.js"),
				a = n.n(o),
				i = n("./src/lib/linkMatchers/customLinks.ts"),
				d = n("./node_modules/lodash/values.js"),
				c = n.n(d);
			const l = e => c()(i.b).includes(e.substring(1)),
				u = ["//", "ftp:", "http:", "https:", "mailto:"],
				m = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, u),
				p = r()().tlds(a.a).set({
					fuzzyIP: !0
				}),
				b = r()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(i.g.mention.prefix, i.g.mention.config),
				h = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(i.g.subreddit.prefix, i.g.subreddit.config).add(i.g.subredditFull.prefix, i.g.subreddit.config),
				f = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(i.g.profile.prefix, i.g.profile.config).add(i.g.profileFull.prefix, i.g.profile.config),
				g = r()().tlds(a.a).set({
					fuzzyIP: !0
				}).add(i.g.subreddit.prefix, i.g.subreddit.config).add(i.g.subredditFull.prefix, i.g.subreddit.config).add(i.g.profile.prefix, i.g.profile.config).add(i.g.profileFull.prefix, i.g.profile.config).add(i.g.mention.prefix, i.g.mention.config),
				_ = r()().tlds(a.a).set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(i.g.subreddit.prefix, i.g.subredditFullUrl.config).add(i.g.subredditFull.prefix, i.g.subredditFullUrl.config),
				v = p.normalize;
			p.normalize = e => {
				v.call(p, e), !e.schema && e.url.startsWith("http:") && (e.url = `https:${e.url.slice(5)}`)
			};
			const O = (e, t) => {
					return (g.match(e) || []).filter(e => {
						const n = l(e.text);
						return !n || n && t
					})
				},
				x = e => {
					return [...f.match(e) || [], ...b.match(e) || []].map(e => !l(e.text) && e.text.replace(i.a, "")).filter(e => e)
				},
				E = (e, t) => {
					const n = e.match(t);
					if (n && 1 === n.length && 0 === n[0].index && n[0].lastIndex === t.length) return n[0]
				},
				y = e => {
					const t = p.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const n = t[0];
						return n.lastIndex === e.length ? n : ((e, t) => {
							const n = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(n)) return t.lastIndex += n.length, t.url += n, t
						})(e, n)
					}
				}
		},
		"./src/lib/loginHref/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/history/esm/history.js");
			t.a = (e, t, n) => {
				const o = Object(r.e)(e),
					a = encodeURIComponent(`${t}${o}`);
				return `${s.a.accountManagerOrigin}${n||"/login"}?dest=${a}`
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += `--[draftId:${e.draftId}]`), t
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/memoizeByReference/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/lodash/every.js"),
				r = n.n(s);

			function o(e) {
				let t = null,
					n = null;
				return function() {
					for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
					return null !== t && o.length === t.length && r()(o, (e, n) => e === t[n]) || (t = o, n = e(...o)), n
				}
			}
		},
		"./src/lib/notifications/token.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/config.ts"),
				r = n("./src/redditGQL/operations/RegisterWebPushToken.json"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/serviceWorker/index.ts"),
				i = n("./src/lib/timezone/index.ts"),
				d = e => {
					const t = (e + "=".repeat((4 - e.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"),
						n = window.atob(t),
						s = new Uint8Array(n.length);
					for (let r = 0; r < n.length; ++r) s[r] = n.charCodeAt(r);
					return s
				};
			var c;
			! function(e) {
				e[e.Success = 0] = "Success", e[e.FailedGeneric = 1] = "FailedGeneric", e[e.FailedResponse = 2] = "FailedResponse", e[e.FailedGqlReponse = 3] = "FailedGqlReponse", e[e.FailedNoServiceWorker = 4] = "FailedNoServiceWorker", e[e.FailedNoSubscription = 5] = "FailedNoSubscription"
			}(c || (c = {}));
			const l = async e => {
				try {
					const t = await Object(a.a)();
					if (!t) return c.FailedNoServiceWorker;
					let n = await t.pushManager.getSubscription();
					if (!n) {
						const e = {
							userVisibleOnly: !0,
							applicationServerKey: d(s.a.pushNotificationApplicationServerKey)
						};
						n = await t.pushManager.subscribe(e)
					}
					if (!n) return c.FailedNoSubscription;
					const l = await ((e, t) => {
						const n = {
							pushToken: JSON.stringify(t),
							timezoneName: Object(i.b)() || i.a,
							timestamp: (new Date).toISOString(),
							language: "en_us"
						};
						return Object(o.a)(e(), {
							...r,
							variables: n
						})
					})(e, n);
					if (l && !l.ok) return c.FailedResponse;
					const u = null == l ? void 0 : l.body.data.registerWebPushToken;
					return u && !u.ok ? c.FailedGqlReponse : c.Success
				} catch (t) {
					return console.error(t), c.FailedGeneric
				}
			}
		},
		"./src/lib/omitKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (t in e) {
					const {
						[t]: n, ...s
					} = e;
					return s
				}
				return e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/onFocusAndVisibilityChange/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/brcast/dist/brcast.es.js");
			const r = () => "undefined" != typeof document,
				o = () => r() && "visible" === document.visibilityState,
				a = () => ({
					documentInFocus: o()
				}),
				{
					subscribe: i,
					unsubscribe: d,
					setState: c
				} = Object(s.a)(a()),
				l = {
					hidden: "visibilitychange",
					webkitHidden: "webkitvisibilitychange",
					mozHidden: "mozvisibilitychange",
					msHidden: "msvisibilitychange"
				},
				u = () => c(a());
			(() => {
				const e = (() => {
					if (!r()) return;
					const e = Object.keys(l).find(e => e in document);
					return e ? l[e] : void 0
				})();
				e && document.addEventListener(e, u)
			})(), t.a = {
				isDocumentHidden: () => !o(),
				isDocumentVisible: o,
				subscribe: i,
				unsubscribe: d
			}
		},
		"./src/lib/pageTitle/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/@reddit/reddit-country-url-redirects/dist/esm/index.js"),
				a = n("./src/reddit/selectors/countrySites.ts"),
				i = n("./src/reddit/selectors/meta.ts");
			const d = (e, t, n) => {
				const {
					languageCode: d
				} = Object(a.c)(e), c = n || (Object(i.j)(e) || r.DEFAULT_LOCALE), l = Object(s.isPseudoLocale)(c) ? r.DEFAULT_LOCALE : c;
				if (d) {
					const e = Object(o.d)(d, l.substring(0, 2));
					return t + (e ? ` - ${e}` : "")
				}
				return t
			}
		},
		"./src/lib/scroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/domUtils/index.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/components/CommentSort/index.tsx"),
				a = n("./src/reddit/constants/elementIds.ts");
			const i = () => {
					r.a.write(() => {
						const e = document.getElementById(a.e);
						e ? Object(s.c)(e, 0) : Object(s.c)(document, 0)
					})
				},
				d = e => {
					r.a.read(() => {
						const t = e ? document.getElementById(a.e) : window,
							n = document.getElementById(o.a);
						if (t && n) {
							const s = e ? n.offsetTop : n.offsetTop - 50;
							r.a.write(() => t.scrollTo({
								top: s,
								behavior: "smooth"
							}))
						}
					})
				}
		},
		"./src/lib/stringInterpolate/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return e && t ? e.replace(/%\{(\w+)\}/g, (e, n) => {
					const s = t[n];
					return null == s ? n : String(s)
				}) : e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/stripQueryParams/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n.n(s);
			t.a = e => {
				const t = r.a.parse(e);
				return t.search = void 0, t.query = null, r.a.format(t)
			}
		},
		"./src/lib/timeUntil/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			const o = [r.sc, r.pb, r.B, r.Q, r.kb, r.Sb],
				a = {
					[r.Sb]: e => s.fbt._({
						"*": "{number} seconds",
						_1: "1 second"
					}, [s.fbt._plural(e, "number")], {
						hk: "3pTp9Z"
					}),
					[r.kb]: e => s.fbt._({
						"*": "{number} minutes",
						_1: "1 minute"
					}, [s.fbt._plural(e, "number")], {
						hk: "2gB3sf"
					}),
					[r.Q]: e => s.fbt._({
						"*": "{number} hours",
						_1: "1 hour"
					}, [s.fbt._plural(e, "number")], {
						hk: "2w4n8B"
					}),
					[r.B]: e => s.fbt._({
						"*": "{number} days",
						_1: "1 day"
					}, [s.fbt._plural(e, "number")], {
						hk: "3zIGRH"
					}),
					[r.pb]: e => s.fbt._({
						"*": "{number} months",
						_1: "1 month"
					}, [s.fbt._plural(e, "number")], {
						hk: "28DQqD"
					}),
					[r.sc]: e => s.fbt._({
						"*": "{number} years",
						_1: "1 year"
					}, [s.fbt._plural(e, "number")], {
						hk: "Gqzh3"
					})
				},
				i = {
					[r.Sb]: e => s.fbt._("{amount}s", [s.fbt._param("amount", String(e))], {
						hk: "F4qog"
					}),
					[r.kb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "43tM5H"
					}),
					[r.Q]: e => s.fbt._("{amount}h", [s.fbt._param("amount", String(e))], {
						hk: "19NsxU"
					}),
					[r.B]: e => s.fbt._("{amount}d", [s.fbt._param("amount", String(e))], {
						hk: "39MDc9"
					}),
					[r.pb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.sc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					}),
					[r.pb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.sc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					})
				};

			function d(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
					n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const d = Date.now(),
					c = new Date(e).getTime(),
					l = {
						[r.sc]: "",
						[r.pb]: "",
						[r.B]: "",
						[r.Q]: "",
						[r.kb]: "",
						[r.Sb]: ""
					};
				let u = c - d;
				if (u <= 0) return s.fbt._("a moment", null, {
					hk: "3QLaye"
				}).toString();
				for (const s of o) {
					const e = Math.floor(u / s);
					e && (l[s] = (t ? i : a)[s](e).toString()), u -= e * s
				}
				const m = o.map(e => l[e]).filter(Boolean).slice(0, 2).join(" ");
				return t || n ? m : s.fbt._("{amount of time left} left", [s.fbt._param("amount of time left", m)], {
					hk: "7VjAI"
				}).toString()
			}
		},
		"./src/realtime/GQLSubscription/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = Object(s.a)({
				ErrorComponent: () => null,
				LoadingComponent: () => null,
				getComponent: () => Object(r.a)(() => Promise.all([n.e(2), n.e("vendors~ChatPost~RealtimeGQLSubscriptionAsync"), n.e("RealtimeGQLSubscriptionAsync")]).then(n.bind(null, "./src/realtime/GQLSubscription/index.tsx"))).then(e => e.default)
			});
			t.a = o
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				a = "API_REQUEST_STATE__COMPLETED",
				i = "API_REQUEST_STATE__FAILED",
				d = "API_REQUEST_STATE__RELEASED";

			function c(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: e
					}
				}
			}

			function l(e) {
				return {
					type: a,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: e
					}
				}
			}

			function u(e, t) {
				return {
					type: i,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const m = Object(s.a)(d)
		},
		"./src/reddit/actions/appBadgeIndicators/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			const s = "APP_BADGES__PENDING",
				r = "APP_BADGES__LOADED",
				o = "APP_BADGES__UPDATED",
				a = "APP_BADGES__FAILED"
		},
		"./src/reddit/actions/appBadgeIndicators/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/appBadgeIndicators/constants.ts"),
				o = n("./src/reddit/actions/tabBadging.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/BadgeIndicators.json"),
				d = e => Object(a.a)(e, {
					...i
				}),
				c = n("./src/reddit/models/Badge/index.ts");
			const l = Object(s.a)(r.c),
				u = Object(s.a)(r.b),
				m = Object(s.a)(r.d),
				p = Object(s.a)(r.a),
				b = e => {
					let {
						key: t,
						count: n
					} = e;
					return {
						[t]: {
							count: n,
							style: c.b.Numbered
						}
					}
				},
				h = (e, t) => ({
					[c.c.ChatUnreadMessages]: {
						count: e,
						style: c.b.Numbered
					},
					[c.c.ChatHasNewMessages]: {
						isShowing: t,
						style: c.b.Filled
					}
				}),
				f = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					e(l());
					const r = await async function(e) {
						const t = await d(e());
						if (t.ok && t.body) {
							return function(e) {
								var t;
								const n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.badgeIndicators;
								if (n) return {
									...n,
									chatUnreadMessages: {
										count: (Number(n.chatUnreadMessages.count) || 0) + (Number(n.chatUnacceptedInvites.count) || 0) + (Number(n.chatUnreadMentions.count) || 0)
									}
								}
							}(t.body)
						}
					}(s);
					r ? (e(u(r)), e(Object(o.d)())) : e(p())
				};
			const g = () => async e => {
				const t = b({
					key: c.c.MessageTab,
					count: 0
				});
				e(m(t))
			}
		},
		"./src/reddit/actions/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "IN_CONTEXT_AUTHOR_FLAIR_UPDATED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/bulkActions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/bulkActions/constants.ts");
			const o = Object(s.a)(r.c),
				a = Object(s.a)(r.b),
				i = Object(s.a)(r.a)
		},
		"./src/reddit/actions/comment/authoring.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return _e
			})), n.d(t, "r", (function() {
				return xe
			})), n.d(t, "p", (function() {
				return Ee
			})), n.d(t, "t", (function() {
				return Ce
			})), n.d(t, "w", (function() {
				return ke
			})), n.d(t, "q", (function() {
				return Ie
			})), n.d(t, "v", (function() {
				return Te
			})), n.d(t, "o", (function() {
				return Ne
			})), n.d(t, "m", (function() {
				return Re
			})), n.d(t, "b", (function() {
				return Me
			})), n.d(t, "c", (function() {
				return Fe
			})), n.d(t, "s", (function() {
				return Ue
			})), n.d(t, "g", (function() {
				return Be
			})), n.d(t, "h", (function() {
				return Ge
			})), n.d(t, "k", (function() {
				return He
			})), n.d(t, "e", (function() {
				return qe
			})), n.d(t, "d", (function() {
				return Qe
			})), n.d(t, "a", (function() {
				return Je
			})), n.d(t, "j", (function() {
				return Ye
			})), n.d(t, "i", (function() {
				return et
			})), n.d(t, "l", (function() {
				return tt
			})), n.d(t, "u", (function() {
				return nt
			})), n.d(t, "n", (function() {
				return st
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeDraftKey/index.ts"),
				i = n("./src/lib/scroll/index.ts"),
				d = n("./src/reddit/actions/changeUsername.ts"),
				c = n("./src/reddit/actions/emailVerificationTooltip.ts"),
				l = n("./src/reddit/actions/login.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/onboarding/index.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/postCreation/editorContent.ts"),
				h = n("./src/reddit/actions/publicAccessNetwork/automute.ts"),
				f = n("./src/reddit/actions/shortcuts/utils.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/constants/adEvents.ts"),
				v = n("./src/reddit/constants/localStorage.ts"),
				O = n("./src/redditGQL/operations/CommentToxicity.json"),
				x = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/lib/makeGqlRequest/index.ts"),
				y = n("./src/lib/omitHeaders/index.ts"),
				j = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				C = n("./src/reddit/constants/headers.ts"),
				k = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				I = n("./src/reddit/helpers/genericServerError/index.ts"),
				S = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				w = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				T = n("./src/reddit/models/PostCreationForm/index.ts"),
				N = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				P = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				R = n("./src/reddit/helpers/graphql/helpers.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				M = n("./src/redditGQL/operations/CreateComment.json");
			const D = (e, t, n, s) => {
					let r, o;
					if (s === T.i.MARKDOWN) r = n.text, o = null;
					else {
						r = null;
						let e = null;
						n.rteState && (e = j.a.toRichTextJSON(n.rteState).document), o = JSON.stringify({
							document: e
						})
					}
					return Object(E.a)(e, {
						...O,
						variables: {
							subredditName: t,
							markdown: r,
							richText: o
						}
					}).then(e => !e.ok || e.body.data.isValidComment)
				},
				L = async (e, t, n, s) => {
					const o = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					return n.commentMode === T.i.MARKDOWN ? o.text = n.text : (o.text = null, o.richtext_json = s), Object(x.a)(Object(y.a)(e, [C.a]), {
						method: r.jb.POST,
						endpoint: Object(k.a)(Object(N.a)(Object(P.a)(`${e.apiUrl}/api/comment.json`))),
						data: o
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(w.a)(e)
					} : {
						...e,
						body: {
							comment: Object(S.a)(e.body.json.data.things[0].data)
						}
					} : {
						...e,
						body: {
							comment: Object(S.a)(e.body)
						}
					} : {
						...e,
						error: e.error || Object(I.a)()
					})
				}, F = async (e, t, n, s, r) => {
					const o = s.commentMode === T.i.MARKDOWN,
						a = {
							postId: t || null,
							parentId: n || null,
							content: {
								markdown: o ? s.text : null,
								richText: o ? null : r
							}
						};
					return Object(E.a)(e, {
						...M,
						variables: {
							input: a
						}
					}).then(e => {
						if (e.ok) {
							const t = e.body.data.createComment;
							if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
								...e,
								ok: !1,
								error: Object(R.e)(t.fieldErrors)
							};
							if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
								...e,
								ok: !1,
								error: Object(R.f)(t.errors)
							};
							if (t.ok) return {
								...e,
								body: {
									comment: Object(A.a)(t.commentInfo)
								}
							}
						}
						return {
							...e,
							ok: !1,
							error: e.error || Object(I.a)()
						}
					})
				};
			var U = n("./src/redditGQL/operations/UpdateComment.json");
			var B = n("./src/redditGQL/operations/UpdateCommentFollowState.json");
			var G = n("./src/reddit/endpoints/post/index.tsx"),
				H = n("./src/reddit/endpoints/post/convert.ts"),
				W = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				q = n("./src/reddit/featureFlags/index.ts"),
				V = n("./src/reddit/helpers/comment/index.ts"),
				z = n("./src/reddit/helpers/correlationIdTracker.ts"),
				K = n("./src/reddit/helpers/dom/index.ts"),
				Q = n("./src/reddit/helpers/localStorage/index.ts"),
				J = n("./src/reddit/helpers/sessionStorage/index.ts"),
				Y = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				X = n("./src/reddit/models/Comment/index.ts"),
				Z = n("./src/reddit/models/PostDraft/index.ts"),
				$ = n("./src/reddit/models/RichTextJson/index.ts"),
				ee = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				te = n("./src/reddit/models/Toast/index.ts"),
				ne = n("./src/reddit/selectors/chatPost.ts"),
				se = n("./src/reddit/selectors/comments.ts"),
				re = n("./src/reddit/selectors/commentSelector.ts"),
				oe = n("./src/reddit/selectors/experiments/chat.ts"),
				ae = n("./src/reddit/constants/experiments.ts"),
				ie = n("./src/reddit/helpers/chooseVariant/index.ts"),
				de = n("./node_modules/reselect/es/index.js");
			const ce = Object(de.a)(e => Object(ie.c)(e, {
				experimentEligibilitySelector: ie.a,
				experimentName: ae.Ib
			}), e => e === ae.xd);
			var le = n("./src/reddit/selectors/experiments/contributeBeforeSignUp.ts"),
				ue = n("./src/reddit/selectors/experiments/emailEnablement.ts"),
				me = n("./src/reddit/selectors/platform.ts"),
				pe = n("./src/reddit/selectors/posts.ts"),
				be = n("./src/reddit/selectors/user.ts"),
				he = n("./src/reddit/actions/comment/index.ts"),
				fe = n("./src/reddit/actions/comment/constants.ts");
			const ge = Object(o.a)(fe.m),
				_e = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, s) => {
						const r = s();
						if (!!r.features.comments.drafts[n])
							if (Object(be.S)(r) && t) {
								const s = ge({
									hasFocus: t,
									draftKey: n
								});
								e(Object(d.startChangeUsernameFlow)(s))
							} else e(ge({
								hasFocus: t,
								draftKey: n
							}))
					}
				},
				ve = Object(o.a)(fe.K),
				Oe = Object(o.a)(fe.G),
				xe = Object(o.a)(fe.M),
				Ee = Object(o.a)(fe.L),
				ye = Object(o.a)(fe.J),
				je = async (e, t, n, s) => {
					const r = s.ok && s.body,
						o = r && r.comment && r.comment.id;
					await Y.f(e, n, t, o)
				}, Ce = "Toxicity_Warning__Modal", ke = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = Object(me.e)(o);
					let i = "";
					a && (i = a.name);
					const {
						formData: d,
						editorMode: c
					} = e;
					if (q.d.enableToxicityWarning(o)) {
						if (!(await D(r(), i, d, c))) return void t(Object(u.i)(Ce))
					}
					t(Ie(e))
				}, Ie = e => async (t, n) => {
					t(Object(u.g)(Ce));
					const s = n(),
						r = Object(le.a)(s),
						o = Object(le.c)(s);
					if (!s.user.account && r) {
						const n = Object(V.e)(e.formData),
							s = Object(V.c)(e.formData);
						t(Object(u.k)({
							actionSource: u.a.Reply
						})), t(Object(l.openRegisterModal)()), Object(J.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: s
							},
							isSkipOnboarding: o
						})
					} else t(we(e, !1)), Object(ue.a)(s) && t(Object(c.c)("comment"))
				};

			function Se(e, t) {
				return e === T.i.MARKDOWN && ce(t)
			}
			const we = (e, t, n, o) => {
					let {
						postId: a,
						commentsPageKey: d,
						draftKey: c,
						formData: l,
						editorMode: u,
						disableAutofocus: m,
						isLiveStreaming: b
					} = e;
					return async (e, v, O) => {
						let {
							apiContext: x,
							gqlContext: E
						} = O;
						var y;
						const j = v(),
							C = Object(ne.d)(j, {
								postId: a
							}) && Object(oe.f)(j),
							k = C ? Object(V.a)() : c,
							I = Object(re.e)(j, {
								commentId: k
							}),
							S = Object(be.k)(j);
						if (!S) return;
						if (I && !C) return;
						t || e(ve({
							draftKey: k,
							draft: l,
							commentsPageKey: d,
							optimisticComment: C ? Object(V.b)({
								temporalId: k,
								draft: l,
								post: Object(pe.G)(j, {
									postId: a
								}),
								author: S,
								subredditId: (null === (y = Object(me.e)(j)) || void 0 === y ? void 0 : y.id) || ""
							}) : void 0
						}));
						const w = S.displayText,
							N = l.commentMode;
						let P;
						if (b) P = await Object(W.i)(x(), a, l, w), e(Object(h.a)({
							streamId: a,
							level: P.body.automuteLevel
						}));
						else {
							const e = t && n ? n : Object(V.e)(l);
							P = Se(N, j) ? await F(E(), a, null, l, e) : await L(x(), a, l, e)
						}
						if (P.ok) {
							let n;
							if (n = P.body, e(xe({
									...n,
									headCommentId: Object(se.w)(j, {
										commentsPageKey: d
									}),
									commentsPageKey: d,
									draftKey: k
								})), t) {
								const e = Object(me.i)(j);
								Object(i.a)(!!e)
							}
							const s = Object(pe.G)(v(), {
								postId: a
							});
							e(Object(p.z)(s, _.a.CommentSubmitted))
						} else {
							if (P.error && P.error.type === r.Kb) {
								const e = t && o ? o : Object(V.c)(l);
								Y.j(j, e, a)
							}
							const n = P.error && P.error.fields && P.error.fields[0] ? P.error.fields[0].msg : s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							});
							e(ye({
								draftKey: k,
								error: P.error
							})), C || e(Object(g.f)({
								duration: g.a,
								kind: te.b.Error,
								text: n
							}))
						}
						je(v(), d, u, P).then(() => P.ok && u === T.i.RICH_TEXT ? Object(z.b)(z.a.CommentComposer) : void 0), m || Object(f.d)(), t && Object(J.a)()
					}
				},
				Te = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const {
						parentCommentId: o,
						commentsPageKey: a,
						parentCommentDepth: i,
						draftKey: d,
						formData: c,
						editorMode: l
					} = e, m = n(), p = Object(me.e)(m);
					let b = "";
					if (p && (b = p.name), q.d.enableToxicityWarning(m)) {
						if (!(await D(r(), b, c, l))) return void t(Object(u.i)(Ce))
					}
					t(Ne({
						commentsPageKey: a,
						draftKey: d,
						parentCommentDepth: i,
						parentCommentId: o,
						formData: c,
						editorMode: l
					}))
				}, Ne = e => async (t, n) => {
					t(Object(u.g)(Ce));
					const s = n(),
						r = Object(le.a)(s),
						o = Object(le.c)(s);
					if (!s.user.account && r) {
						const n = Object(V.e)(e.formData),
							s = Object(V.c)(e.formData);
						t(Object(u.k)({
							actionSource: u.a.Reply
						})), t(Object(l.openRegisterModal)()), Object(J.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: s
							},
							isSkipOnboarding: o
						})
					} else t(Pe(e, !1))
				}, Pe = (e, t, n, s) => async (o, a, d) => {
					let {
						apiContext: c,
						gqlContext: l
					} = d;
					var u;
					const {
						parentCommentId: m,
						commentsPageKey: p,
						parentCommentDepth: b,
						draftKey: h,
						formData: g,
						editorMode: _
					} = e, v = a(), O = Object(re.b)(v, {
						commentId: m
					}), x = O && Object(ne.d)(v, {
						postId: O.postId
					}) && Object(oe.f)(v), E = x ? Object(V.a)() : h, y = Object(re.e)(v, {
						commentId: E
					}), j = Object(be.k)(v);
					if (!j) return;
					if (y && !x) return;
					t || o(ve({
						draftKey: E,
						draft: g,
						commentsPageKey: p,
						optimisticComment: x && O ? Object(V.b)({
							temporalId: E,
							draft: g,
							post: Object(pe.G)(v, {
								postId: O.postId
							}),
							author: j,
							subredditId: (null === (u = Object(me.e)(v)) || void 0 === u ? void 0 : u.id) || "",
							parentId: O.id
						}) : void 0
					})), o(Me({
						parentCommentId: m,
						commentsPageKey: p
					}));
					const C = g.commentMode,
						k = t && n ? n : Object(V.e)(g);
					let I;
					if ((I = Se(C, v) ? await F(l(), null, m, g, k) : await L(c(), m, g, k)).ok) {
						if (o(Ee({
								...I.body,
								parentCommentId: m,
								commentsPageKey: p,
								draftKey: E,
								depth: b + 1
							})), t) {
							const e = Object(me.i)(v);
							Object(i.a)(!!e)
						}
					} else {
						if (I.error && I.error.type === r.Kb) {
							if (!O) return;
							const e = t && s ? s : Object(V.c)(g);
							Y.j(v, e, O.postId, m)
						}
						o(ye({
							draftKey: E,
							error: I.error
						}))
					}
					je(a(), p, _, I), Object(f.d)(), t && Object(J.a)()
				}, Re = () => async e => {
					const t = Object(J.b)();
					if (t) {
						const {
							comment: {
								parentCommentDepth: n,
								parentCommentId: s,
								postId: r,
								richTextJSONData: o,
								commentBodyText: a
							},
							isSkipOnboarding: i
						} = t;
						i && e(Object(m.skipOnboardingModal)()), r ? await e(we({
							...t.comment,
							postId: r
						}, !0, o, a)) : s && void 0 !== n && await e(Pe({
							...t.comment,
							parentCommentId: s,
							parentCommentDepth: n
						}, !0, o, a))
					}
				}, Ae = Object(o.a)(fe.s), Me = Object(o.a)(fe.r), De = Object(o.a)(fe.n), Le = (Object(o.a)(fe.i), Object(o.a)(fe.o)), Fe = (Object(o.a)(fe.v), (e, t, n) => async (r, o, a) => {
					let {
						apiContext: i
					} = a;
					const d = e === T.i.RICH_TEXT;
					if (!t || "object" == typeof t && Object($.G)(t)) r(Le({
						editorMode: e,
						draftKey: n,
						content: d ? $.i : ""
					})), r(Object(b.c)(e));
					else {
						r(Object(b.b)(n));
						const o = await Object(H.a)(i(), e, d ? t : JSON.stringify(t));
						if (o.ok) {
							const t = o.body.output;
							r(Object(b.a)(n)), r(Le({
								editorMode: e,
								draftKey: n,
								content: t
							})), r(Object(b.c)(e))
						} else r(Object(b.a)(n)), r(Object(g.f)({
							duration: g.a,
							kind: te.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), Ue = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: s
					} = e;
					return async (e, r) => {
						const o = r(),
							i = Object(a.a)(Z.c.replyToComment, n);
						if (!Object(be.Q)(r()) && !Object(le.a)(o)) return e(Object(l.openRegisterModal)()), void e(Object(u.k)({
							actionSource: u.a.Reply,
							redirectUrl: Object(se.m)(r(), {
								commentId: n
							})
						}));
						const c = o.features.comments.replyFormOpen[t],
							m = c && c[n];
						if ((m || c && s) && (Object.keys(c).forEach(n => c[n] && e(Me({
								parentCommentId: n,
								commentsPageKey: t
							}))), m)) return;
						let p = "",
							b = null;
						const h = o.user.prefs.commentMode,
							f = Object(K.d)();
						if (f) {
							const e = f.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (h === T.i.MARKDOWN) p = e.map(e => `> ${e}\n`).join("");
							else {
								const t = e.map(e => ee.s(e, null)).map(e => ee.l([e])),
									n = ee.s("", null),
									s = ee.l([n]);
								b = {
									document: [ee.c(t), s]
								}
							}
						}
						const g = o.features.comments.drafts[i];
						let _;
						if (_ = f ? {
								commentMode: h,
								draftType: Z.c.replyToComment,
								rtJson: b,
								text: `${p}\n`
							} : g || {
								commentMode: h,
								draftType: Z.c.replyToComment,
								rtJson: b,
								text: ""
							}, Object(be.S)(o)) {
							const s = Ae({
								parentCommentId: n,
								commentsPageKey: t,
								draftKey: i,
								formData: _
							});
							e(Object(d.startChangeUsernameFlow)(s))
						} else e(Ae({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: i,
							formData: _
						}))
					}
				}, Be = e => async t => {
					t(Object(he.q)(e)), t(qe(e))
				}, Ge = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(Me({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Ue({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Object(he.q)({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, He = (e, t) => n => n(De({
					draftKey: e,
					formData: t
				})), We = Object(o.a)(fe.u), qe = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: s,
						draftKey: r,
						text: o
					} = e;
					return async (e, a) => {
						const i = a();
						i.user.account && (Y.c(i), e(We({
							commentId: t,
							commentsPageKey: s,
							draftKey: r,
							formData: {
								text: o,
								commentMode: n,
								rteState: null,
								draftType: Z.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Ve = Object(o.a)(fe.E), ze = Object(o.a)(fe.D), Ke = Object(o.a)(fe.F), Qe = Object(o.a)(fe.j), Je = Object(o.a)(fe.f), Ye = e => {
					let {
						id: t,
						commentsPageKey: n,
						draftKey: s,
						formData: o
					} = e;
					return async (e, a, i) => {
						let {
							apiContext: d,
							gqlContext: c
						} = i;
						const l = a();
						if (!l.user.account) return;
						e(Ve({
							draftKey: s
						})), Y.d(l);
						const u = Object(V.e)(o),
							m = o.commentMode;
						let p;
						if ((p = Se(m, l) ? await (async (e, t, n, s, r) => {
								const o = r === T.i.MARKDOWN,
									a = {
										commentId: t,
										content: {
											markdown: o ? n.text : null,
											richText: o ? null : s
										}
									};
								return Object(E.a)(e, {
									...U,
									variables: {
										input: a
									}
								}).then(e => {
									if (e.ok) {
										const t = e.body.data.updateComment;
										if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
											...e,
											ok: !1,
											error: Object(R.e)(t.fieldErrors)
										};
										if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
											...e,
											ok: !1,
											error: Object(R.f)(t.errors)
										};
										if (t.ok) return {
											...e,
											body: {
												comment: {
													...Object(A.b)(t.content)
												}
											}
										}
									}
									return {
										...e,
										ok: !1,
										error: e.error || Object(I.a)()
									}
								})
							})(c(), t, o, u, m) : await (async (e, t, n, s, o) => {
								const a = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								return o === T.i.MARKDOWN ? a.text = n.text : (a.text = null, a.richtext_json = s), Object(x.a)(Object(y.a)(e, [C.a]), {
									endpoint: Object(k.a)(Object(P.a)(Object(N.a)(`${e.apiUrl}/api/editusertext`))),
									method: r.jb.POST,
									data: a
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
									...e,
									ok: !1,
									error: Object(w.a)(e)
								} : {
									...e,
									body: {
										comment: Object(S.a)(e.body.json.data.things[0].data)
									}
								} : {
									...e,
									body: {
										comment: Object(S.a)(e.body)
									}
								} : {
									...e,
									error: e.error || Object(I.a)()
								})
							})(d(), t, o, u, m)).ok) {
							const r = p.body;
							e(Ke({
								commentId: t,
								commentsPageKey: n,
								draftKey: s
							})), e(Object(he.j)({
								[t]: {
									...r.comment
								}
							}))
						} else e(ze({
							draftKey: s,
							error: p.error
						}))
					}
				}, Xe = Object(o.a)(fe.B), Ze = Object(o.a)(fe.A), $e = Object(o.a)(fe.C), et = (e, t) => async (n, s, o) => {
					let {
						apiContext: a
					} = o;
					const i = s();
					n(Xe({
						id: e
					})), Y.a(e, i);
					const d = await ((e, t) => Object(x.a)(Object(y.a)(e, [C.a]), {
						endpoint: Object(k.a)(`${e.apiUrl}/api/del`),
						method: r.jb.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(w.a)(e)
					} : {
						...e,
						body: {}
					} : {
						...e,
						error: e.error || Object(I.a)()
					}))(a(), e);
					d.ok ? n($e({
						id: e,
						postId: t
					})) : n(Ze({
						id: e,
						error: d.error
					}))
				}, tt = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = !n().features.comments.models[e].sendReplies;
					t(Object(he.j)({
						[e]: {
							sendReplies: o
						}
					})), (await Object(G.s)(r(), e, o)).ok || t(Object(he.j)({
						[e]: {
							sendReplies: !o
						}
					}))
				}, nt = (e, t) => async (n, r, o) => {
					let {
						gqlContext: a
					} = o;
					var i, d, l, u, m, p;
					n(Object(he.c)());
					const b = r(),
						h = e => Object(g.f)(Object(g.e)(e, te.b.Error));
					if (((null === (d = null === (i = b.pages) || void 0 === i ? void 0 : i.comments) || void 0 === d ? void 0 : d.followed) || []).length === v.a) n(h(s.fbt._("You've reached your post follow limit", null, {
						hk: "3ebRql"
					})));
					else {
						const o = t === X.a.FOLLOWED,
							i = {
								id: e,
								expiresAt: Date.now() + 6048e5
							};
						if (n(Object(he.o)(i)), (await ((e, t) => Object(E.a)(e, {
								...B,
								variables: {
									input: t
								}
							}))(a(), {
								commentId: e,
								followState: t
							})).ok) {
							Object(Q.vb)(null !== (m = null === (u = null === (l = r().pages) || void 0 === l ? void 0 : l.comments) || void 0 === u ? void 0 : u.followed) && void 0 !== m ? m : [], null === (p = r().user.account) || void 0 === p ? void 0 : p.id);
							const e = o ? s.fbt._("Followed! Youll get updates when theres new activity.", null, {
								hk: "2O1Ou3"
							}) : s.fbt._("Unfollowed. You wont get updates on this comment anymore.", null, {
								hk: "4EAz6O"
							});
							n(Object(g.f)({
								kind: te.b.SuccessCommunityGreen,
								text: e
							})), Object(ue.a)(b) && o && n(Object(c.c)("comment_follow"))
						} else n(Object(he.o)(i)), n(h(s.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "2N0vVk"
						})))
					}
				};

			function st(e) {
				let {
					commentId: t,
					commentsPageKey: n,
					isLivestreaming: s = !1
				} = e;
				return async (e, r) => {
					const o = r(),
						a = Object(re.b)(o, {
							commentId: t
						});
					if (!a) return;
					e(Oe({
						commentId: t,
						commentsPageKey: n
					}));
					const i = {
						commentMode: a.media.rteMode,
						draftType: a.parentId ? Z.c.replyToComment : Z.c.replyToPost,
						rtJson: a.media.richtextContent,
						hasFocus: !0,
						text: ""
					};
					if (a.parentId) {
						const t = Object(re.b)(o, {
								commentId: a.parentId
							}),
							s = Object(se.j)(o, {
								commentId: a.parentId,
								commentLink: void 0,
								commentsPageKey: n
							});
						if (!t || null === s) return;
						await e(Ne({
							commentsPageKey: n,
							draftKey: a.id,
							parentCommentDepth: s,
							parentCommentId: t.id,
							formData: i,
							editorMode: a.media.rteMode
						}))
					} else await e(Ie({
						postId: a.postId,
						commentsPageKey: n,
						draftKey: a.id,
						formData: i,
						editorMode: a.media.rteMode,
						disableAutofocus: !0,
						isLiveStreaming: s
					}))
				}
			}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return N
			})), n.d(t, "n", (function() {
				return P
			})), n.d(t, "f", (function() {
				return M
			})), n.d(t, "i", (function() {
				return D
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "r", (function() {
				return G
			})), n.d(t, "k", (function() {
				return H
			})), n.d(t, "h", (function() {
				return W
			})), n.d(t, "g", (function() {
				return q
			})), n.d(t, "p", (function() {
				return K
			})), n.d(t, "q", (function() {
				return Q
			})), n.d(t, "d", (function() {
				return J
			})), n.d(t, "a", (function() {
				return X
			})), n.d(t, "b", (function() {
				return Z
			})), n.d(t, "o", (function() {
				return $
			})), n.d(t, "c", (function() {
				return ee
			})), n.d(t, "l", (function() {
				return te
			})), n.d(t, "e", (function() {
				return ne
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/telemetry/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/economics/helpers/async.ts"),
				d = n("./src/reddit/actions/economics/powerups/flairs/async.ts"),
				c = n("./src/reddit/actions/login.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				m = n("./src/reddit/actions/shortcuts/utils.ts"),
				p = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/actions/vote.ts"),
				f = n("./src/reddit/endpoints/comment/index.tsx"),
				g = n("./src/reddit/helpers/commentList/index.ts"),
				_ = n("./src/reddit/helpers/trackers/comment.ts"),
				v = n("./src/reddit/models/Comment/index.ts"),
				O = n("./src/reddit/models/Post/index.ts"),
				x = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/models/Vote/index.ts"),
				y = n("./src/reddit/selectors/comments.ts"),
				j = n("./src/reddit/selectors/commentSelector.ts"),
				C = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				k = n("./src/reddit/selectors/moderatingComments.ts"),
				I = n("./src/reddit/selectors/moderatorPermissions.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/reddit/actions/comment/constants.ts");
			const T = {},
				N = Object(a.a)(w.q),
				P = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (!Object(S.Q)(n())) return t(Object(c.openRegisterModal)()), void t(Object(l.k)({
						actionSource: l.a.Save,
						redirectUrl: Object(y.m)(n(), {
							commentId: e
						})
					}));
					const a = n().features.comments.models[e];
					if (!a) return;
					const i = a.isSaved ? f.n : f.j;
					if (t(N({
							[e]: {
								isSaved: !a.isSaved
							}
						})), (await i(o(), e)).ok) {
						const n = a.isSaved ? r.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : r.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							s = r.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(b.f)({
							text: n,
							kind: x.b.Undo,
							buttonText: s,
							buttonAction: P(e)
						}))
					} else t(N({
						[e]: {
							isSaved: a.isSaved
						}
					}))
				}, R = e => `viewing-comment-${e}`, A = s.a.telemetry.commentConsumedThreshold, M = e => async (t, n) => {
					const r = n(),
						a = Object(j.b)(r, {
							commentId: e
						});
					if (!a || Math.random() > s.a.telemetry.commentSampleRate) return;
					_.c({
						state: r,
						commentId: e,
						collapsed: a.collapsed
					}), o.c.start(R(e));
					const i = setTimeout(() => _.a({
						state: r,
						commentId: e,
						collapsed: a.collapsed
					}), A);
					T[e] = i
				}, D = (e, t) => async (n, s) => {
					const r = s(),
						a = R(e);
					if (Object(j.b)(r, {
							commentId: e
						}) && o.c.has(a)) {
						const n = o.c.end(a);
						!t && n < A && (clearTimeout(T[e]), delete T[e])
					}
				}, L = Object(a.a)(w.z), F = Object(a.a)(w.y), U = Object(a.a)(w.x), B = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						c = a.moreComments.models[t],
						l = a.platform.currentPage,
						m = l && l.routeMatch,
						b = m && m.match,
						{
							partialPostId: h
						} = b ? b.params : null;
					if (!h) return;
					const _ = Object(O.u)(h);
					n(L({
						moreCommentsId: c.id
					}));
					const v = await Object(f.g)(o(), _, {
						token: c.token
					}, Object(C.a)(a));
					if (v.ok) {
						const t = v.body,
							r = Object(g.a)(t, _, a);
						n(F({
							key: e,
							moreCommentsItem: c,
							shouldCollapse: r,
							...t
						}));
						const o = a.posts.models[_];
						let l;
						o && "subreddit" === o.belongsTo.type && t.comments && (l = o.belongsTo.id, await n(Object(i.a)({
							commentIds: Object.keys(v.body.comments),
							postIds: [o.id],
							skip: ["communityDetails", "subscription"],
							subredditId: l
						})), Object(I.i)(a, l) && n(Object(p.c)(_, !0, c.token)));
						const m = v.body.comments;
						await n(Object(d.b)(l, m)), Object(I.h)(s(), {
							subredditId: o.belongsTo.id
						}) && n(Object(u.a)({
							commentIds: Object.keys(t.comments)
						}))
					} else n(U({
						moreCommentsItem: c,
						...v.error
					}))
				}, G = Object(h.a)(g.b, E.a.upvoted), H = Object(h.a)(g.b, E.a.downvoted), W = Object(a.a)(w.l), q = Object(a.a)(w.k), V = Object(a.a)(w.g), z = Object(a.a)(w.h), K = (Object(a.a)(w.c), Object(a.a)(w.d), e => {
					let {
						commentId: t,
						commentsPageKey: n,
						scrollToAndRemeasure: s
					} = e;
					return async (e, r) => {
						const o = r(),
							a = Object(v.i)(t),
							i = Object(y.n)(o, {
								commentLink: a,
								commentsPageKey: n
							}),
							d = Object(k.b)(o, {
								commentId: t,
								commentsPageKey: n
							}),
							c = i.depth;
						e(V({
							commentId: t,
							commentsPageKey: n,
							isCollapsed: d
						})), d || 0 !== c || s(t, !0), Object(m.d)()
					}
				}), Q = e => {
					let {
						commentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(z({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, J = e => {
					let {
						commentLink: t,
						commentsPageKey: n,
						lineDepth: s,
						scrollToAndRemeasure: r
					} = e;
					return async (e, o) => {
						const a = o(),
							i = Object(g.e)(n, t, s, a),
							d = Object(k.b)(a, {
								commentId: t.id,
								commentsPageKey: n
							});
						e(V({
							commentId: i,
							commentsPageKey: n,
							isCollapsed: d
						})), 0 === s && r(i, !0), Object(m.d)()
					}
				}, Y = Object(a.a)(w.t), X = e => t => t(Y({
					draftKey: e
				})), Z = Object(a.a)(w.a), $ = Object(a.a)(w.H), ee = Object(a.a)(w.b), te = Object(a.a)(w.w), ne = Object(a.a)(w.e)
		},
		"./src/reddit/actions/comment/moderation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "g", (function() {
				return k
			})), n.d(t, "h", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeCommentsPageKey/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/shortcuts/utils.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/endpoints/comment/index.tsx"),
				m = n("./src/reddit/endpoints/moderator/snoozableReport.ts"),
				p = n("./src/reddit/models/Reportable/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/selectors/commentSelector.ts"),
				f = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				g = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/reddit/actions/comment/index.ts"),
				v = n("./src/reddit/actions/comment/constants.ts");
			const O = Object(o.a)(v.p),
				x = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().features.comments.models[e] && (await Object(u.k)(r(), e)).ok && t((e => async t => {
						t(O({
							commentId: e
						}))
					})(e))
				}, E = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (!Object(g.Q)(n())) return void t(Object(i.i)(l.a.LOGIN_MODAL_ID));
					const a = n().features.comments.models[e];
					if (!a) return;
					const d = a.isLocked ? u.m : u.f;
					t(Object(_.j)({
						[e]: {
							isLocked: !a.isLocked
						}
					})), (await d(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: a.isLocked ? s.fbt._("comment has been unlocked", null, {
							hk: "BYjts"
						}) : s.fbt._("comment has been locked", null, {
							hk: "1pBDQl"
						})
					})) : t(Object(_.j)({
						[e]: {
							isLocked: a.isLocked
						}
					}))
				}, y = Object(o.a)(v.I), j = e => async (t, n, r) => {
					let {
						apiContext: o,
						gqlContext: a
					} = r;
					const i = n(),
						l = i.features.comments.models[e],
						m = i.user.account ? i.user.account.displayText : null;
					l && m && (t(Object(_.j)({
						[e]: {
							isApproved: !0,
							approvedBy: m,
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (Object(f.a)(i) ? await Object(u.a)(a(), e) : await Object(u.b)(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("comment has been approved", null, {
							hk: "4GfKQi"
						})
					})) : t(Object(_.j)({
						[e]: {
							isApproved: l.isApproved,
							approvedBy: null,
							bannedBy: l.bannedBy,
							isRemoved: l.isRemoved,
							isSpam: l.isSpam,
							modNote: l.modNote,
							modReasonBy: l.modReasonBy,
							modRemovalReason: l.modRemovalReason,
							numReports: l.numReports || null
						}
					})), Object(d.d)())
				}, C = (e, t) => async (n, r, o) => {
					let {
						apiContext: a,
						gqlContext: i
					} = o;
					const l = r(),
						m = l.features.comments.models[e],
						p = l.user.account ? l.user.account.displayText : null;
					m && p && (n(Object(_.j)({
						[e]: {
							approvedBy: null,
							bannedBy: p,
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (Object(f.a)(l) ? await Object(u.h)(i(), e, t) : await Object(u.i)(a(), e, t)).ok ? n(Object(c.f)({
						kind: b.b.SuccessMod,
						text: t ? s.fbt._("comment has been marked as spam", null, {
							hk: "4fQaFM"
						}) : s.fbt._("comment has been removed", null, {
							hk: "1qNTrD"
						})
					})) : n(Object(_.j)({
						[e]: {
							approvedBy: m.approvedBy,
							bannedBy: m.bannedBy,
							isApproved: m.isApproved,
							isRemoved: m.isRemoved,
							isSpam: m.isSpam
						}
					})), Object(d.d)())
				}, k = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const a = n().features.comments.models[e];
					if (!a) return;
					const i = a.ignoreReports ? u.l : u.e;
					t(Object(_.j)({
						[e]: {
							ignoreReports: !a.ignoreReports
						}
					})), (await i(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: a.ignoreReports ? s.fbt._("comment has had its reports un-ignored", null, {
							hk: "HcpVV"
						}) : s.fbt._("comment has had its reports ignored", null, {
							hk: "2q4sCp"
						})
					})) : t(Object(_.j)({
						[e]: {
							ignoreReports: a.ignoreReports
						}
					}))
				}, I = (e, t, n) => async (o, a, i) => {
					let {
						gqlContext: d
					} = i;
					const l = Object(h.b)(a(), {
						commentId: e
					});
					if (!l) return;
					const u = n === r.ec.Snoozed,
						f = {
							itemId: e,
							reportText: t,
							isSnoozed: u
						};
					if ((await Object(m.a)(d(), {
							input: f
						})).ok) o(Object(_.j)({
						[e]: {
							userReports: Object(p.a)(l.userReports, t, u)
						}
					}));
					else {
						const e = Object(c.e)(s.fbt._("Sorry, that snooze failed. Try that again", null, {
							hk: "7ToJC"
						}), b.b.Error);
						o(Object(c.f)(e))
					}
				}, S = (e, t, n) => async (s, o, i) => {
					let {
						apiContext: d,
						gqlContext: c
					} = i;
					const l = o(),
						m = l.features.comments.models[e];
					if (!m) return;
					const p = m.postId,
						b = l.postStickiedComments.data[p];
					s(Object(_.j)({
						[e]: {
							distinguishType: t,
							isAdmin: t === r.G.ADMIN,
							isMod: t === r.G.MODERATOR,
							isStickied: !!n
						}
					})), n && b && b !== e && s(Object(_.j)({
						[b]: {
							isStickied: !1
						}
					}));
					const h = Object(u.c)(c(), e, t),
						f = Object(u.d)(c(), e, !!n),
						g = [h];
					(n || !n && e === b) && g.push(f), (await Promise.all(g)).every(e => e.ok) ? n && s(y({
						id: e,
						postId: p,
						commentsPageKey: Object(a.a)(p, null, {
							sort: r.t.CONFIDENCE,
							...l.platform.currentPage.queryParams
						})
					})) : (s(Object(_.j)({
						[e]: {
							distinguishType: m.distinguishType,
							isAdmin: m.isAdmin,
							isMod: m.isMod,
							isStickied: m.isStickied
						}
					})), s(Object(_.j)({
						[b]: {
							isStickied: l.features.comments.models[b].isStickied
						}
					})))
				}
		},
		"./src/reddit/actions/contentControls/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = "CONTENT_CONTROLS_FAILED",
				r = "CONTENT_CONTROLS_LOADED",
				o = "CONTENT_CONTROLS_PENDING",
				a = "CONTENT_CONTROLS_UPDATED"
		},
		"./src/reddit/actions/contentControls/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			})), n.d(t, "b", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/camelCase.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/sentry/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/HatefulContentFilters/index.ts"),
				m = n("./src/redditGQL/operations/FetchContentControls.json");
			const p = e => {
				switch (e) {
					case "LENIENT":
						return u.a.Lenient;
					case "MODERATE":
						return u.a.Moderate;
					case "STRICT":
						return u.a.Strict;
					default:
						return u.a.Off
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var b = n("./node_modules/lodash/isEmpty.js"),
				h = n.n(b),
				f = n("./src/redditGQL/operations/UpdateHatefulContentFilters.json"),
				g = n("./src/redditGQL/operations/UpdatePostRequirements.json"),
				_ = n("./src/reddit/endpoints/subreddit/about.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/contentControls.ts"),
				x = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/actions/contentControls/constants.ts");
			const j = Object(i.a)(y.b),
				C = Object(i.a)(y.c),
				k = Object(i.a)(y.a),
				I = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = {
						subredditName: e.toLowerCase()
					};
					if (Object(O.a)(n(), o)) return;
					t(C(o));
					let i = Object(E.F)(n(), e);
					if (!i) {
						const n = await Object(_.a)(r(), e, !1);
						if (n.ok) {
							i = n.body.data.subreddit.id
						}
						if (!i) {
							const e = n.error || {
								type: a.I.NOT_FOUND_ERROR
							};
							return void t(k({
								...o,
								error: e
							}))
						}
					}
					const c = Object(x.c)(n(), {
						subredditId: i
					});
					let u = null;
					const b = await ((e, t) => Object(l.a)(e, {
						...m,
						variables: t
					}).then(e => {
						var t, n;
						if (e.ok) {
							const s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit;
							return {
								...e,
								body: {
									data: {
										subreddit: {
											hatefulContentFilters: {
												hatefulContentThresholdAbuse: p(null == s ? void 0 : s.hatefulContentThresholdAbuse),
												hatefulContentThresholdIdentity: p(null == s ? void 0 : s.hatefulContentThresholdIdentity),
												wordlist: [],
												wordlistEnabled: !1
											},
											postRequirements: null == s ? void 0 : s.postRequirements
										}
									}
								}
							}
						}
						return e
					}))(r(), {
						subredditId: i,
						includeHatefulFilters: c
					});
					if (b.ok) {
						const e = b.body;
						u = e.data.subreddit && e.data.subreddit
					}
					if (u) t(j({
						...o,
						...u
					}));
					else {
						const n = b.error || {
							type: a.I.UNKNOWN_ERROR
						};
						t(k({
							...o,
							error: n
						})), d.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: b.body,
								responseOk: b.ok
							}), d.c.captureMessage("Missing post requirements data!")
						})
					}
				}, S = Object(i.a)(y.d), w = (e, t) => async (n, r, o) => {
					let {
						gqlContext: a
					} = o;
					const i = e.toLowerCase(),
						d = Object(E.F)(r(), e);
					if (!d) return {
						success: !1
					};
					const u = await ((e, t, n) => {
						const s = [Promise.resolve(null), Promise.resolve(null)];
						if (n.postRequirements && !h()(n.postRequirements)) {
							const r = {
								subredditId: t,
								...n.postRequirements
							};
							s[0] = Object(l.a)(e, {
								...g,
								variables: {
									input: r
								}
							})
						}
						if (n.hatefulContentFilters && !h()(n.hatefulContentFilters)) {
							const r = {
								subredditId: t
							};
							n.hatefulContentFilters.hatefulContentThresholdAbuse && (r.hatefulContentThresholdAbuse = n.hatefulContentFilters.hatefulContentThresholdAbuse), n.hatefulContentFilters.hatefulContentThresholdIdentity && (r.hatefulContentThresholdIdentity = n.hatefulContentFilters.hatefulContentThresholdIdentity), s[1] = Object(l.a)(e, {
								...f,
								variables: {
									input: r
								}
							})
						}
						return Promise.all(s).then(e => {
							let [t, n] = e, s = !0, r = [];
							if (t) {
								const e = t.body,
									n = e.data.updatePostRequirements.fieldErrors;
								s = s && e.data.updatePostRequirements.ok, n && (r = r.concat(n))
							}
							if (n) {
								const e = n.body,
									t = e.data.updateSubredditSettings.fieldErrors;
								s = s && e.data.updateSubredditSettings.ok, t && (r = r.concat(t))
							}
							return {
								ok: s,
								fieldErrors: r.length ? r : null
							}
						})
					})(a(), d, t);
					if (u.ok) return n(S({
						subredditName: i,
						partialUpdates: t
					})), n(Object(c.f)({
						kind: v.b.SuccessCommunity,
						text: s.fbt._("Subreddit content controls updated successfully", null, {
							hk: "1n6QIQ"
						})
					})), {
						success: !0
					}; {
						const r = T(u.fieldErrors);
						return n(Object(c.f)({
							kind: v.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: w(e, t)
						})), {
							success: !1,
							errors: r || void 0
						}
					}
				}, T = e => e && e.map(e => ({
					...e,
					field: o()(e.field)
				}))
		},
		"./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "f", (function() {
				return k
			}));
			var s = n("./node_modules/@sentry/minimal/esm/index.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/GetSubredditCountrySiteSettings.json"),
				i = n("./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json");
			const d = e => ({
				input: {
					subredditId: e.subredditId,
					countryCode: e.countryCode || "",
					languageCode: e.languageCode || ""
				}
			});
			var c = async (e, t) => Object(o.a)(e, {
				...i,
				variables: d(t)
			}), l = n("./node_modules/fbt/lib/FbtPublic.js"), u = n("./src/reddit/models/Toast/index.ts"), m = n("./node_modules/reselect/es/index.js"), p = n("./src/reddit/constants/experiments.ts"), b = n("./src/reddit/helpers/chooseVariant/index.ts"), h = n("./src/reddit/selectors/user.ts");
			const f = Object(m.a)(e => Object(b.c)(e, {
				experimentEligibilitySelector: h.Q,
				experimentName: p.bc
			}), e => e === p.xd);
			var g = n("./src/reddit/actions/toaster.ts");
			const _ = "SUBREDDIT_COUNTRY_SITE__LOADED",
				v = "SUBREDDIT_COUNTRY_SITE__CHANGED",
				O = "SUBREDDIT_COUNTRY_SITE__UPDATE_SUCCESS",
				x = Object(r.a)(_),
				E = Object(r.a)(O),
				y = Object(r.a)(v),
				j = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var i;
					if (!e) return;
					const d = await (async (e, t) => Object(o.a)(e, {
							...a,
							variables: {
								subredditId: t
							}
						}))(r(), e),
						c = d.body;
					d && d.ok && c && t(x({
						subredditId: e,
						subredditCountrySite: null === (i = c.data) || void 0 === i ? void 0 : i.subredditInfoById.countrySiteSettings
					}))
				}, C = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!e) return;
					const a = await c(o(), {
						subredditId: e,
						countryCode: t.countryCode,
						languageCode: t.languageCode
					});
					if (!a.ok) return n(Object(g.f)({
						kind: u.b.Error,
						text: l.fbt._("Something went wrong", null, {
							hk: "2PnKbu"
						}),
						duration: 5e3
					}));
					const i = a.body;
					n(E({
						subredditId: e,
						subredditCountrySite: i.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
					}))
				}, k = (e, t) => async (n, r, o) => {
					let {
						gqlContext: a
					} = o;
					if (!e || !f(r())) return;
					const i = {
							subredditId: e,
							countryCode: "",
							languageCode: t
						},
						d = await c(a(), i);
					if (d.ok) {
						const t = d.body;
						n(E({
							subredditId: e,
							subredditCountrySite: t.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
						}))
					} else s.l(e => {
						e.setExtra("subredditCountryLanginfo", i), s.c(d.error)
					})
				}
		},
		"./src/reddit/actions/creatorStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "CREATOR_STATS_PENDING",
				r = "CREATOR_STATS_LOADED"
		},
		"./src/reddit/actions/crosspostSubredditRec/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/postCreation/general.ts"),
				o = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts");
			var a = n("./src/lib/initializeClient/installReducer.ts");
			var i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER":
						return !0;
					case "CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER":
						return !1;
					default:
						return e
				}
			};
			Object(a.a)({
				features: {
					shouldTryToShowCrosspostModal: i
				}
			});
			const d = Object(s.a)("CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER"),
				c = Object(s.a)("CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER"),
				l = e => async (t, n) => {
					const s = n();
					if (!Object(o.b)(s)) return;
					const a = e.title,
						i = Object(o.d)(e),
						d = Object(o.c)(e);
					t(Object(r.j)(a, i, d, t => {
						const n = e.belongsTo.id === t.id,
							s = "isCrosspostDestination" in t && t.isCrosspostDestination;
						return n || !s
					}))
				}
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			n("./src/lib/constants/index.ts");
			var s = n("./src/lib/makeActionCreator/index.ts");
			n("./src/lib/makeListingKey/index.ts"), n("./src/lib/addQueryParams/index.ts"), n("./src/lib/makeApiRequest/index.ts"), n("./src/lib/omitHeaders/index.ts"), n("./src/lib/stringInterpolate/index.ts"), n("./src/reddit/constants/headers.ts"), n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"), n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var r = n("./src/reddit/selectors/discoveryUnit.ts");
			n("./src/reddit/selectors/listings.ts");
			const o = "DISCOVERY_UNIT__LIST_PENDING",
				a = "DISCOVERY_UNIT__LIST_LOADED",
				i = "DISCOVERY_UNIT__LIST_FAILED",
				d = Object(s.a)(o),
				c = Object(s.a)(a),
				l = Object(s.a)(i),
				u = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						a = Object(r.d)(o),
						i = Object(r.c)(o);
					if (a || i) return;
					e(d());
					const u = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(s());
					if (u.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const n = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[n.id] = n, e
								}, {})
							}
						})(u.body);
						e(c({
							discoveryUnits: t
						}))
					} else e(l({
						error: u.error
					}))
				}, m = "DISCOVERY_UNIT__UNIT_DATA_PENDING", p = "DISCOVERY_UNIT__UNIT_DATA_LOADED", b = "DISCOVERY_UNIT__UNIT_DATA_FAILED";
			Object(s.a)(m), Object(s.a)(p), Object(s.a)(b)
		},
		"./src/reddit/actions/economics/claims/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "ECONOMICS__CLAIMS__CLAIM_PENDING",
				r = "ECONOMICS__CLAIMS__CLAIM_COMPLETED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => async t => {
				const s = await (() => n.e("EconHelperActions").then(n.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(s(e))
			}
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				o = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/powerups/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			}));
			const s = 120,
				r = "ON_CREATE_CUSTOM_EMOJI_SUCCESS",
				o = "ON_DELETE_CUSTOM_EMOJI_SUCCESS",
				a = "POWERUPS__SUBREDDIT_USER_POWERUPS_FLAIRS_LOADED",
				i = "POWERUPS__USER_SUPPORTED_SUBREDDITS_LOADED",
				d = "POWERUPS__SUBREDDIT_USER_POWERUPS_FLAIR_PREFERENCE_UPDATE_REQUESTED",
				c = "POWERUPS__SUBREDDIT_USER_POWERUPS_FLAIR_PREFERENCE_UPDATED",
				l = "POWERUPS__SUBREDDIT_USER_POWERUPS_FLAIR_PREFERENCE_UPDATE_FAILED",
				u = "POWERUPS__SUBREDDIT_USER_POWERUPS_FLAIR_VISIBILITY_UPDATE"
		},
		"./src/reddit/actions/economics/powerups/flairs/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditUserCommentsPowerupsInfoFromCommentCollection)),
				o = Object(s.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditCurrentUserPowerupsFlairsAndSupporterInfo))
		},
		"./src/reddit/actions/economics/powerups/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => (null == e ? void 0 : e.map(e => e.message).join(", ")) || ""
		},
		"./src/reddit/actions/economics/powerups/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return v
			}));
			var s = n("./node_modules/uuid/v4.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/sentry/index.ts"),
				i = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/endpoints/gold/powerups/index.ts"),
				c = n("./src/reddit/helpers/media/index.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/reddit/actions/economics/powerups/constants.ts"),
				m = n("./src/reddit/actions/economics/powerups/helpers.ts");
			const p = Object(o.a)(u.b),
				b = Object(o.a)(u.c),
				h = e => {
					let {
						subredditId: t,
						file: n
					} = e;
					return async (e, s) => {
						var o;
						try {
							const a = s(),
								i = null === (o = Object(l.k)(a)) || void 0 === o ? void 0 : o.id;
							if (!i) throw new Error("Failed to get current user during emoji upload");
							const d = await Object(c.h)(n);
							if (!d) throw new Error("Cannot determine file mimeType");
							const {
								file: m,
								width: p,
								height: b
							} = await Object(c.o)(n, u.a), h = await e(f({
								subredditId: t,
								mimeType: d
							}, {
								userId: i
							})), v = await _({
								file: m,
								s3UploadLease: h
							}, {
								subredditId: t,
								userId: i
							});
							return await e(g({
								subredditId: t,
								mimeType: d,
								url: v,
								x: p,
								y: b,
								nonce: r()()
							}))
						} catch (i) {
							throw a.c.captureException(i), i
						}
					}
				},
				f = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = await Object(d.c)(o(), {
						input: e
					});
					if (a.error || !a.ok) throw new Error(`Failed to get emoji upload lease. subredditId: ${e.subredditId}; userId: ${t.userId}`);
					const {
						ok: i,
						errors: c,
						s3UploadLease: l
					} = a.body.data.generateCustomEmojiUploadLease;
					if (!i || c) throw new Error(`Failed to get emoji upload lease: ${Object(m.a)(c)}. subredditId: ${e.subredditId}; userId: ${t.userId}`);
					return l
				}, g = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(d.a)(r(), {
						input: e
					});
					if (o.error || !o.ok) throw new Error("Failed to create custom emoji");
					const {
						ok: a,
						errors: i,
						emoji: l
					} = o.body.data.createCustomEmoji;
					if (!a || i) throw new Error(`Failed to create custom emoji: ${Object(m.a)(i)}`);
					const u = l.emojiIcon.url;
					await Object(c.n)(u);
					const {
						subredditId: b
					} = e;
					return t(p({
						subredditId: b,
						emoji: l
					})), l
				}, _ = async (e, t) => {
					let {
						file: n,
						s3UploadLease: s
					} = e, {
						subredditId: r,
						userId: o
					} = t;
					const a = await Object(i.a)(n, s);
					if (!a.ok) throw new Error(`Failed to upload custom emoji to S3. subredditId: ${r}; userId: ${o}`);
					const d = a.body.PostResponse;
					return `https://${d.Bucket}.s3.amazonaws.com/${d.Key}`
				}, v = e => {
					let {
						emojiId: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = await Object(d.b)(o(), {
							input: {
								id: t
							}
						});
						if (i.error || !i.ok) {
							const e = new Error("Failed to delete custom emoji");
							throw a.c.captureException(e), e
						}
						const {
							ok: c,
							errors: l
						} = i.body.data.deleteCustomEmoji;
						if (!c || l) {
							const e = new Error(`Failed to delete custom emoji: ${Object(m.a)(l)}`);
							throw a.c.captureException(e), e
						}
						return e(b({
							subredditId: n,
							emojiId: t
						})), c
					}
				}
		},
		"./src/reddit/actions/economics/predictions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return V
			})), n.d(t, "k", (function() {
				return z
			})), n.d(t, "o", (function() {
				return K
			})), n.d(t, "r", (function() {
				return Q
			})), n.d(t, "q", (function() {
				return J
			})), n.d(t, "l", (function() {
				return ee
			})), n.d(t, "m", (function() {
				return te
			})), n.d(t, "n", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "v", (function() {
				return oe
			})), n.d(t, "g", (function() {
				return ae
			})), n.d(t, "a", (function() {
				return ie
			})), n.d(t, "w", (function() {
				return ce
			})), n.d(t, "p", (function() {
				return le
			})), n.d(t, "i", (function() {
				return ue
			})), n.d(t, "j", (function() {
				return me
			})), n.d(t, "s", (function() {
				return pe
			})), n.d(t, "t", (function() {
				return be
			})), n.d(t, "f", (function() {
				return he
			})), n.d(t, "c", (function() {
				return fe
			})), n.d(t, "d", (function() {
				return ge
			})), n.d(t, "h", (function() {
				return _e
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/index.js"),
				o = n.n(r),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/features/predictions/index.ts"),
				d = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/makeRequest/index.ts")),
				c = n("./src/lib/uploadToS3/index.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/redditGQL/operations/CreateMediaUploadLease.json"),
				m = n("./src/redditGQL/operations/SubmitMediaUpload.json");
			var p = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/redditGQL/types.ts");
			const h = new Map([
					["image/png", b.k.Png],
					["image/gif", b.k.Gif],
					["image/jpeg", b.k.Jpeg]
				]),
				f = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = await Object(p.h)(t) || t.type,
						i = h.get(a);
					if (!i) throw new Error("Unacceptable file type");
					const {
						mediaId: b,
						uploadLease: f
					} = await (async (e, t) => {
						const n = await Object(l.a)(e, {
							...u,
							variables: {
								input: t
							}
						});
						if (!Object(d.c)(n) || n.error) throw new Error("Failed to create upload lease");
						return n.body.data.createMediaUploadLease
					})(o(), {
						mimetype: i
					}), g = function(e) {
						let {
							uploadLeaseUrl: t,
							uploadLeaseHeaders: n
						} = e;
						return {
							action: t,
							fields: (null == n ? void 0 : n.map(e => {
								let {
									header: t,
									value: n
								} = e;
								return {
									name: t,
									value: n
								}
							})) || []
						}
					}(f), _ = await Object(c.a)(t, g);
					if (!Object(d.c)(_)) throw new Error("Failed to upload file to S3");
					return await (async (e, t) => {
						const n = await Object(l.a)(e, {
							...m,
							variables: {
								input: t
							}
						});
						if (!Object(d.c)(n) || n.error) throw new Error("Failed to submit media")
					})(o(), {
						mediaId: b,
						redditId: e
					}), {
						mediaId: b,
						mimeType: i
					}
				};
			var g = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/lib/delay/index.ts"),
				O = n("./src/lib/makeActionCreator/index.ts"),
				x = n("./src/reddit/endpoints/economics/predictions.ts");

			function E(e) {
				let {
					topPredictorsRank: t,
					currentRank: n
				} = e;
				return {
					currentRank: n ? y(n) : null,
					topPredictorsRank: t.map(y)
				}
			}

			function y(e) {
				let {
					score: t,
					rank: n,
					redditor: s,
					redditorInfo: r
				} = e;
				var o, a;
				return {
					score: t,
					rank: n,
					redditor: s ? {
						...s,
						icon: null !== (o = s.icon) && void 0 !== o ? o : null,
						profile: null !== (a = s.profile) && void 0 !== a ? a : null
					} : null,
					redditorInfo: r
				}
			}
			var j = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizePredictionTournamentFromGql/index.ts"),
				k = n("./src/reddit/actions/login.ts"),
				I = n("./src/reddit/actions/modal.ts"),
				S = n("./src/reddit/constants/modals.ts"),
				w = n("./src/reddit/selectors/features/predictions/leaderboards/index.ts"),
				T = n("./src/reddit/selectors/subreddit.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/selectors/features/predictions/creation/index.ts"),
				R = n("./src/reddit/selectors/features/predictions/tournaments/index.ts"),
				A = n("./src/reddit/actions/economics/predictions/constants.ts");
			Object(a.a)({
				features: {
					predictions: i.a
				}
			});
			const M = Object(O.a)(A.d),
				D = Object(O.a)(A.c),
				L = Object(O.a)(A.e),
				F = Object(O.a)(A.f),
				U = Object(O.a)(A.i),
				B = Object(O.a)(A.h),
				G = Object(O.a)(A.j),
				H = Object(O.a)(A.q),
				W = Object(O.a)(A.t),
				q = Object(O.a)(A.p),
				V = Object(O.a)(A.b),
				z = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: a
					} = o;
					const i = Object(N.Q)(r());
					if (!Object(w.c)(r(), {
							subredditId: e
						})) {
						s(M({
							subredditId: e
						}));
						try {
							const {
								predictionTournaments: r,
								predictionWinners: o
							} = await Object(x.i)(a(), {
								subredditId: e,
								period: n,
								top: t,
								includeCurrentRank: i
							}), d = E(o);
							s(L({
								subredditId: e,
								leaderboard: d
							})), r && (s(ne(e, r)), null == r || r.forEach(e => {
								let {
									tournamentId: t,
									winners: n
								} = e;
								s(F({
									tournamentId: t,
									leaderboard: E(n)
								}))
							}))
						} catch {
							s(D({
								subredditId: e
							}))
						}
					}
				}, K = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = Object(N.Q)(s());
					if (!Object(w.g)(s(), {
							tournamentId: t
						})) {
						n(U({
							tournamentId: t
						}));
						try {
							const {
								predictionWinners: s
							} = await Object(x.j)(o(), {
								subredditId: e,
								tournamentId: t,
								includeCurrentRank: a
							}), r = E(s);
							n(G({
								tournamentId: t,
								leaderboard: r
							}))
						} catch {
							n(B({
								tournamentId: t
							}))
						}
					}
				}, Q = e => {
					let {
						coinPackageId: t,
						optionId: n,
						postId: s,
						price: r
					} = e;
					return async (e, o, a) => {
						let {
							gqlContext: i
						} = a;
						const d = await Object(x.p)(i(), {
							coinPackageId: t,
							optionId: n,
							postId: s,
							price: r
						});
						return e(H({
							pollId: s,
							prediction: d,
							price: r
						})), d
					}
				}, J = e => {
					let {
						optionId: t,
						postId: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const a = await Object(x.n)(o(), {
								optionId: t,
								postId: n
							}),
							{
								resolvePrediction: i
							} = a.body.data;
						if (!(null == i ? void 0 : i.poll)) throw new Error("Failed to resolve prediction");
						return e(q({
							pollId: n,
							prediction: i.poll
						})), i.poll
					}
				}, Y = Object(O.a)(A.k), X = Object(O.a)(A.m), Z = Object(O.a)(A.l), $ = Object(O.a)(A.o), ee = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = Object(T.F)(o, e);
					if (Object(R.k)(o, {
							subredditId: a
						})) return Object(R.g)(o, {
						subredditId: a
					});
					t(Y({
						subredditId: a
					}));
					const i = await Object(x.k)(r(), {
							subredditName: e,
							isLatestOnly: !0,
							isIncludingPredictions: !0,
							isIncludingParticipants: !0,
							isIncludingCancelledPredictions: !0
						}),
						d = {};
					i.forEach(e => {
						var n;
						if ((null === (n = e.predictionPosts) || void 0 === n ? void 0 : n.length) && e.predictionPosts.forEach(e => {
								e && (d[e.id] = Object(j.f)(e))
							}), e.winners) {
							const n = E(e.winners);
							t(F({
								tournamentId: e.tournamentId,
								leaderboard: n
							}))
						}
					});
					const c = i.map(e => Object(C.a)(e));
					return t(Z({
						subredditId: a,
						tournaments: c
					})), t(X({
						subredditId: a,
						tournaments: c
					})), t($({
						posts: d,
						meta: o.meta
					})), c
				}, te = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = Object(T.F)(o, e),
						i = await Object(x.l)(r(), {
							subredditName: e,
							isLatestOnly: !0
						});
					t(ne(a, i))
				}, ne = (e, t) => n => {
					const s = t.map(e => Object(C.a)(e));
					n(X({
						subredditId: e,
						tournaments: s
					}))
				}, se = Object(O.a)(A.a), re = Object(O.a)(A.r), oe = Object(O.a)(A.s), ae = (e, t, n, s) => async (r, o, a) => {
					let {
						gqlContext: i
					} = a;
					const d = o(),
						c = Object(P.b)(d);
					let l = null;
					if (!c) throw new Error("Failed to create tournament, no prediction drafts attached");
					if (s instanceof File) {
						const {
							mediaId: t,
							mimeType: n
						} = await r(f(`icon_pred_${e}`, s));
						await Object(v.a)(3e3), l = {
							mediaId: t,
							width: 1,
							height: 1,
							mimeType: n.toLowerCase()
						}
					} else s && (l = {
						url: s,
						width: 1,
						height: 1,
						mimeType: ""
					});
					const u = await Object(x.e)(i(), {
							tournamentId: null,
							name: t,
							themeId: n,
							isStartImmediately: !0,
							subredditId: e,
							predictionDrafts: c,
							currency: b.C.Tokens,
							tokenIcon: l
						}),
						m = Object(C.a)(u);
					r(de(m))
				}, ie = (e, t) => async (n, s, r) => {
					let {
						gqlContext: a
					} = r;
					const i = Object(P.b)(s());
					if (!i) throw new Error("Failed to create prediction post, no prediction drafts attached");
					const d = await Object(x.a)(a(), {
							tournamentId: e,
							isStartImmediately: !0,
							iKey: `add-dfts-${o.a.v4()}`,
							subredditId: t,
							predictionDrafts: i
						}),
						c = Object(C.a)(d);
					n(de(c))
				}, de = Object(O.a)(A.g), ce = (e, t, n) => async (t, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = await Object(x.o)(o(), {
							tournamentId: e,
							name: n
						}),
						i = Object(C.a)(a);
					t(de(i))
				}, le = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(x.f)(r(), {
							tournamentId: e
						}),
						{
							endPredictionTournament: a
						} = o.body.data;
					if (!a.tournament) throw new Error("Failed to update prediction name");
					return t(de(a.tournament)), a.tournament
				}, ue = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(x.g)(r(), {
						postId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch prediction chip packages");
					const {
						postInfoById: a
					} = o.body.data;
					if (!a.predictionChipPackages) throw new Error("Failed to fetch prediction chip packages");
					return a.predictionChipPackages
				}, me = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(x.h)(r(), {
						tournamentId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch token balance");
					const {
						identity: a
					} = o.body.data;
					if (!a.hasOwnProperty("predictionTokens")) throw new Error("Failed to fetch token balance");
					return a.predictionTokens
				}, pe = e => {
					let {
						coinPackageId: t,
						selectedOptionId: n,
						price: s,
						pollId: r,
						tournamentId: o,
						tournamentPostId: a
					} = e;
					return async e => {
						const i = await e(Q({
							coinPackageId: t,
							optionId: n,
							postId: r,
							price: s
						}));
						return e(W({
							predictionId: r,
							selectedOptionId: n,
							tournamentId: o,
							tournamentPostId: a
						})), i
					}
				}, be = e => async (t, n) => {
					const s = n();
					Object(N.Q)(s) ? await t(Object(I.h)(S.a.ECON_PREDICTIONS_PREMIUM_UPSELL, {
						feature: e
					})) : await t(Object(k.openLoginModal)())
				}, he = () => Object(I.g)(S.a.ECON_PREDICTIONS_PREMIUM_UPSELL), fe = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					try {
						const n = await Object(x.b)(o(), {
							postId: e
						});
						t(V({
							postId: e,
							prediction: n
						}));
						const r = Object(g.e)(s.fbt._("Prediction has been cancelled", null, {
							hk: "3Bh9Fw"
						}), _.b.SuccessMod);
						t(Object(g.f)(r))
					} catch {
						const e = Object(g.e)(s.fbt._("Unable to cancel prediction", null, {
							hk: "2wkeKy"
						}), _.b.Error);
						t(Object(g.f)(e))
					}
				};

			function ge(e, t) {
				return async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = await Object(x.c)(o(), {
						postId: e,
						...t
					});
					return n(V({
						postId: e,
						prediction: a
					})), a
				}
			}
			const _e = e => async (t, n, s) => {
				let {
					gqlContext: r
				} = s;
				return Object(x.m)(r(), {
					subredditId: e
				})
			}
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			}));
			const s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS"
		},
		"./src/reddit/actions/emoji.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return y
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "o", (function() {
				return F
			})), n.d(t, "n", (function() {
				return B
			})), n.d(t, "k", (function() {
				return G
			})), n.d(t, "l", (function() {
				return H
			})), n.d(t, "i", (function() {
				return W
			})), n.d(t, "j", (function() {
				return q
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "m", (function() {
				return K
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/forEach.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/lib/uploadToS3/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			const u = async (e, t) => Object(i.a)(Object(d.a)(e, [l.a]), {
				endpoint: `${e.apiUrl}/api/v1/${t}/emojis/all`,
				method: a.jb.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const n = o()(e, (e, n) => ("snoomojis" !== n && (t = n), o()(e, (t, n) => {
					e[n] = {
						name: n,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: n[t],
						snoomojis: n.snoomojis
					}
				}
			})(e.body)), e));
			var m = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/reddit/actions/imageUploads.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/helpers/getGenericUploadError.ts"),
				f = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				_ = n("./src/reddit/models/Emoji/index.ts"),
				v = n("./src/reddit/models/Image/index.tsx"),
				O = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/emojis.ts"),
				E = n("./src/reddit/selectors/subreddit.ts");
			const y = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				j = Object(m.a)(y),
				C = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				k = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				I = Object(m.a)(C),
				S = Object(m.a)(k),
				w = "GET_ALL_EMOJIS_PENDING",
				T = "GET_ALL_EMOJIS_LOADED",
				N = "GET_ALL_EMOJIS_FAILED",
				P = Object(m.a)(w),
				R = Object(m.a)(T),
				A = Object(m.a)(N),
				M = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				D = Object(m.a)(M),
				L = e => ({
					text: s.fbt._("Failed to save emoji", null, {
						hk: "3i6FC2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "1XMjgA"
					}),
					buttonAction: B(e)
				}),
				F = e => {
					let {
						imageData: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						const o = s(),
							u = Object(E.U)(o, {
								subredditId: n
							}).name;
						e(Object(p.k)(t));
						const m = t.file,
							b = await Object(g.h)(m),
							h = await (async (e, t, n, s) => Object(i.a)(Object(d.a)(e, [l.a]), {
								endpoint: `${e.apiUrl}/api/v1/${t}/emoji_asset_upload_s3.json`,
								method: a.jb.POST,
								data: {
									filepath: n,
									mimetype: s
								}
							}))(r.apiContext(), u, m.name, b);
						let f = !1;
						if (h.ok) {
							const n = await (async (e, t, n) => Object(c.a)(n, t))(r.apiContext(), h.body.s3UploadLease, m);
							if (n.ok) {
								if (!s().imageUploads[t.id]) return Object(v.d)(t), !1;
								const r = decodeURIComponent(n.body.PostResponse.Location),
									o = h.body.websocketUrl,
									a = Object(v.n)(t, r, o);
								e(Object(p.j)(a)), f = !0
							} else {
								const s = Object(v.k)(t, n.error);
								e(Object(p.i)(s))
							}
						} else {
							const n = Object(v.k)(t, h.error);
							e(Object(p.i)(n))
						}
						return f
					}
				},
				U = (e, t) => async (n, s, r) => {
					const {
						imageData: o,
						subredditId: c,
						emojiName: u,
						settings: m
					} = e, h = Object(f.a)(o.url), g = s(), _ = Object(E.U)(g, {
						subredditId: c
					}).name, O = await (async (e, t, n, s, r) => Object(i.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/emoji.json`,
						method: a.jb.POST,
						data: {
							s3_key: n,
							name: s,
							mod_flair_only: r.modFlairOnly,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed
						}
					}))(r.apiContext(), _, h, u, m);
					if (!O.ok) {
						const s = Object(v.k)(o, O.error);
						n(Object(p.i)(s)), n(Object(b.f)(L(e))), t && t.close()
					}
					return O.ok
				}, B = e => async (t, n, r) => {
					const {
						imageData: o,
						subredditId: a,
						emojiName: i,
						settings: d
					} = e;
					if (t(Object(p.k)(o)), !o.websocketUrl) return t(Object(b.f)({
						text: s.fbt._("Could not upload emoji", null, {
							hk: "29nzfh"
						})
					}));
					let c;
					const l = new WebSocket(o.websocketUrl);
					return l.onopen = async () => {
						c = await U(e, l)(t, n, r)
					}, l.onmessage = n => {
						const s = JSON.parse(n.data);
						if ("success" === s.type) {
							c = !0;
							const e = s.payload.emoji_url,
								n = Object(v.o)(o, e);
							t(Object(p.l)(n));
							const r = Object(_.e)(i, n.url, a, d);
							t(j(r)), t(G(a))
						} else {
							const n = Object(h.a)(i),
								s = Object(v.k)(o, n);
							t(Object(p.i)(s)), t(Object(b.f)(L(e)))
						}
						l.close()
					}, l.onerror = n => {
						c = !1;
						const s = Object(h.a)(i),
							r = Object(v.k)(o, s);
						t(Object(p.i)(r)), t(Object(b.f)(L(e))), l.close()
					}, c
				}, G = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n();
					if (Object(x.a)(o, e)) return;
					const a = Object(E.U)(o, {
						subredditId: e
					}).name;
					t(P(e));
					const i = await u(r(), a);
					if (i.ok) {
						const n = i.body;
						t(R({
							subredditId: e,
							data: n
						}))
					} else t(A({
						subredditId: e,
						error: i.error
					}))
				}, H = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().emojis[e] || await t(G(e))
				}, W = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(E.U)(u, {
							subredditId: t
						}).name,
						p = await (async (e, t, n) => Object(i.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/v1/${n}/emoji/${t}`,
							method: a.jb.DELETE,
							type: "json"
						}))(c(), e, m);
					if (p.ok) {
						n(I({
							emojiName: e,
							subredditId: t
						})), n(b.f({
							kind: O.b.SuccessCommunityGreen,
							text: s.fbt._("Emoji successfully deleted", null, {
								hk: "1zMXEe"
							})
						}))
					} else n(S(p.error)), n(b.f({
						kind: O.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, q = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(E.U)(u, {
							subredditId: e
						}).name;
					if ((await (async (e, t, n) => Object(i.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/enable_emojis_in_sr.json`,
							method: a.jb.POST,
							data: {
								subreddit: t,
								enable: n
							}
						}))(c(), m, t)).ok) {
						n(D({
							subredditId: e,
							emojisEnabled: t
						}))
					} else n(b.f({
						kind: O.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, V = "EMOJI_PERMISSIONS_UPDATED", z = Object(m.a)(V), K = (e, t, n, r) => async (o, c, u) => {
					let {
						apiContext: m
					} = u;
					const p = c(),
						h = Object(E.U)(p, {
							subredditId: r
						}).name;
					(await (async (e, t, n, s) => Object(i.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${n}/emoji_permissions.json`,
						method: a.jb.POST,
						data: {
							name: t,
							post_flair_allowed: s.postFlairAllowed,
							user_flair_allowed: s.userFlairAllowed,
							mod_flair_only: s.modFlairOnly
						}
					}))(m(), e, h, n)).ok ? (o(z({
						emojiName: e,
						isSnoomoji: t,
						settings: n,
						subredditId: r
					})), o(b.f({
						kind: O.b.SuccessCommunityGreen,
						text: s.fbt._("Emoji permissions updated", null, {
							hk: "4b2RIU"
						})
					}))) : o(b.f({
						kind: O.b.Error,
						text: s.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			const s = "MOD_PAGE_EVENT_POSTS_LOADED",
				r = "MOD_PAGE_EVENT_POSTS_FAILED",
				o = "MOD_PAGE_EVENT_POSTS_PENDING",
				a = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				i = "START_EVENT_NOW_SUCCESS",
				d = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/eventPosts/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "fetchEventPostsPending", (function() {
				return O
			})), n.d(t, "fetchEventPostsSuccess", (function() {
				return x
			})), n.d(t, "fetchEventPostsFailure", (function() {
				return E
			})), n.d(t, "fetchMoreEventPostsSuccess", (function() {
				return y
			})), n.d(t, "eventPostsRequested", (function() {
				return j
			})), n.d(t, "startEventNowSuccess", (function() {
				return C
			})), n.d(t, "startEventNowRequested", (function() {
				return k
			})), n.d(t, "editEventTimeSuccess", (function() {
				return I
			})), n.d(t, "editEventTimeRequested", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/eventPosts/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/EventPostsBySubredditName.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var p = (e, t, n, s, o) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/api/event_post_time.json`,
				method: r.jb.POST,
				data: {
					id: t,
					event_start: n,
					event_end: s,
					event_tz: o
				}
			});
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/start_event_post.json`,
					method: r.jb.POST,
					data: {
						id: t
					}
				}),
				h = n("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/eventPosts.ts"),
				_ = n("./src/reddit/selectors/posts.ts");
			const v = () => s.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4onxm1"
				}),
				O = Object(o.a)(a.e),
				x = Object(o.a)(a.c),
				E = Object(o.a)(a.b),
				y = Object(o.a)(a.d),
				j = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s, o = n();
					const a = Object(g.d)(o, {
							subredditName: e
						}),
						l = Object(g.b)(o, {
							subredditName: e
						}),
						u = Object(g.c)(o, {
							subredditName: e
						}),
						m = Object(g.a)(o, {
							subredditName: e
						}),
						p = l && u;
					if (a) return;
					const b = {
						name: e,
						pageSize: 25,
						nonInclusiveCursor: null
					};
					if (p) b.nonInclusiveCursor = m;
					else if (l && !u) return;
					const _ = Object(g.e)(o, {
						subredditName: e
					});
					t(O({
						key: _
					}));
					const j = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), b);
					if (j.ok) {
						const {
							subredditInfoByName: e
						} = j.body.data, {
							eventPosts: s
						} = e, r = Object(h.a)(s);
						let a = [],
							i = {};
						const d = s.pageInfo || {
							hasNextPage: !1,
							endCursor: null,
							hasPreviousPage: !1,
							startCursor: null
						};
						r.length > 0 && (a = r.map(e => e.id), i = r.reduce((e, t) => (e[t.id] = t, e), {})), o = n(), t((p ? y : x)({
							key: _,
							postIds: a,
							meta: o.meta,
							posts: i,
							pageInfo: d
						}))
					} else t(E({
						error: j.error,
						key: _
					})), t(Object(i.f)({
						kind: f.b.Error,
						text: v()
					}))
				}, C = Object(o.a)(a.f), k = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if ((await b(o(), e)).ok) {
						const r = () => s.fbt._("Following event has started successfully: {title}", [s.fbt._param("title", d)], {
							hk: "e9iz9"
						});
						t(C({
							postId: e
						}));
						const o = n(),
							a = Object(_.G)(o, {
								postId: e
							}),
							d = a && a.title || "";
						t(Object(i.f)({
							kind: f.b.SuccessMod,
							text: r()
						}))
					} else t(Object(i.f)({
						kind: f.b.Error,
						text: v()
					}))
				}, I = Object(o.a)(a.a), S = (e, t) => async (n, o, a) => {
					let {
						apiContext: d
					} = a;
					const c = await p(d(), e, t.startDate, t.endDate, t.timezoneName);
					if (c.ok) {
						const t = c.body,
							a = 14400,
							d = Math.round(t.event_start / r.Sb);
						let l = t.event_end;
						const u = {
							eventStart: d,
							eventEnd: l = l && Math.round(l / r.Sb) || d + a,
							eventIsLive: t.event_is_live
						};
						n(I({
							postId: e,
							eventInfo: u
						}));
						const m = o(),
							p = Object(_.G)(m, {
								postId: e
							}),
							b = p && p.title || "",
							h = () => s.fbt._("Following event time is updated successfully: {title}", [s.fbt._param("title", b)], {
								hk: "1m1w1c"
							});
						n(Object(i.f)({
							kind: f.b.SuccessMod,
							text: h()
						}))
					} else n(Object(i.f)({
						kind: f.b.Error,
						text: v()
					}))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return O
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "o", (function() {
				return P
			})), n.d(t, "p", (function() {
				return R
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "n", (function() {
				return B
			})), n.d(t, "e", (function() {
				return G
			})), n.d(t, "f", (function() {
				return H
			})), n.d(t, "d", (function() {
				return W
			})), n.d(t, "m", (function() {
				return K
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var b = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/models/User/index.ts"),
				f = n("./src/reddit/selectors/externalAccount.ts"),
				g = n("./src/reddit/selectors/platform.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/selectors/user.ts");
			const O = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				x = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				y = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				j = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				C = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				k = Object(r.a)(O),
				I = Object(r.a)(x),
				S = Object(r.a)(E),
				w = Object(r.a)(y),
				T = Object(r.a)(j),
				N = Object(r.a)(C),
				P = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(v.k)(o),
						i = e || a && Object(h.e)(a);
					if (!i) return;
					if (Object(f.d)(o, {
							username: i
						})) return;
					t(k(i));
					const b = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/user/${t}.json`),
						traceRequestName: "get_external_accounts",
						method: d.jb.GET
					}))(r(), i);
					if (b.ok) {
						const e = p(b.body);
						t(I({
							username: i,
							accountsData: e
						}))
					} else t(S(b.error))
				}, R = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						o = Object(g.d)(r);
					if (!o) return;
					const a = r.externalAccount.api.subreddit.fetched[o],
						i = r.externalAccount.api.subreddit.pending[o];
					if (a || i) return;
					const b = Object(_.w)(r, {
						subredditName: o
					});
					if (!(b && b.hasExternalAccount)) return;
					e(w(o));
					const h = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/subreddit/${t}.json`),
						method: d.jb.GET
					}))(s(), o);
					if (h.ok) {
						const t = p(h.body);
						e(T({
							subredditName: o,
							accountsData: t
						}))
					} else e(N(h.error))
				}, A = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", M = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", D = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", L = Object(r.a)(A), F = Object(r.a)(M), U = Object(r.a)(D), B = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(L({
						provider: e
					}));
					const o = Object(v.k)(n()),
						a = Object(h.e)(o),
						i = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/disconnect.json`),
							method: d.jb.POST
						}))(r(), e);
					i.ok ? t(F({
						provider: e,
						username: a
					})) : t(U({
						provider: e,
						error: i.error
					}))
				}, G = "OAUTH_FLOW_URL_PENDING", H = "OAUTH_FLOW_URL_SUCCESS", W = "OAUTH_FLOW_URL_FAILED", q = Object(r.a)(G), V = Object(r.a)(H), z = Object(r.a)(W), K = e => async (t, n, r) => {
					let {
						apiContext: p
					} = r;
					t(q({
						provider: e
					}));
					const h = Object(o.a)(window.location.href, {
							[i.b]: e
						}),
						f = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/connect.json`),
							method: d.jb.POST,
							data: {
								redirect_url: n
							}
						}))(p(), e, h);
					if (f.ok) {
						const {
							redirect_url: n
						} = f.body;
						t(V({
							provider: e
						})), window.location.href = n
					} else t(z({
						provider: e,
						error: f.error
					})), t(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/gold/communityAwards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = e => () => n.e("CommunityAwards").then(n.bind(null, "./src/reddit/actions/gold/communityAwards/communityAwards.ts")).then(t => t[e]),
				o = Object(s.a)(r("awardSheetInfoRequested")),
				a = Object(s.a)(r("manageableAwardsRequested")),
				i = Object(s.a)(r("createCommunityAward")),
				d = Object(s.a)(r("createGlobalAward")),
				c = Object(s.a)(r("createModAward")),
				l = Object(s.a)(r("createAwardFailed")),
				u = Object(s.a)(r("createAwardSuccessful")),
				m = Object(s.a)(r("removeCommunityAward")),
				p = Object(s.a)(r("disableAwardinCommunity")),
				b = Object(s.a)(r("enableAwardinCommunity"))
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "f", (function() {
				return j
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/postParentMessage/index.ts"),
				o = n("./src/reddit/helpers/isPost.ts"),
				a = n("./src/reddit/constants/modals.ts"),
				i = n("./src/reddit/selectors/gild.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/selectors/communityAwards.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				b = n("./src/telemetry/index.ts"),
				h = n("./src/reddit/actions/gold/constants.ts");
			const f = Object(s.a)(h.K),
				g = Object(s.a)(h.f),
				_ = () => async (e, t) => {
					const s = t();
					e(g()), Object(d.b)(d.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(b.a)(r()(s))
				}, v = Object(s.a)(h.J), O = e => {
					let {
						awardId: t,
						correlationId: n,
						thingId: s
					} = e;
					return async (e, r) => {
						const i = r(),
							d = t ? Object(u.a)(i, t) : void 0;
						e(v({
							award: d && d.isEnabled ? d : void 0,
							thingId: s,
							correlationId: n
						})), e(Object(l.h)(a.a.GOLD_GILD_MODAL));
						const b = Object(p.K)(i, {
							thingId: s
						});
						let h = null;
						if (b) h = b.id;
						else if (Object(o.a)(s)) {
							const e = Object(m.G)(i, {
								postId: s
							});
							e && (h = e.belongsTo.id)
						}
						h && Object(c.a)(h, s)
					}
				}, x = Object(s.a)(h.e), E = Object(s.a)(h.I), y = () => async (e, t) => {
					const s = t(),
						o = Object(i.d)(s);
					if (Object(i.g)(s)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(x()), e(Object(l.g)(a.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: c
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(b.a)(c(o)(s)), Object(d.b)(d.a.GildingFlow)
				}, j = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/gold/powerups.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return v
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "h", (function() {
				return G
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "g", (function() {
				return W
			})), n.d(t, "f", (function() {
				return q
			})), n.d(t, "e", (function() {
				return V
			})), n.d(t, "d", (function() {
				return z
			})), n.d(t, "k", (function() {
				return Q
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				a = n("./src/telemetry/index.ts"),
				i = n("./src/reddit/actions/login.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/endpoints/gold/powerups/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/gold/powerups/index.ts"),
				b = n("./src/reddit/selectors/gold/powerups/benefitSettings.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				f = n("./src/reddit/helpers/trackers/powerups.ts"),
				g = n("./src/reddit/actions/economics/powerups/flairs/async.ts"),
				_ = n("./src/reddit/actions/gold/constants.ts");
			const v = e => async (t, n, r) => {
				let {
					gqlContext: a
				} = r;
				if (!!n().user.powerups.fetched && !e) return;
				t(O());
				const i = s.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const e = await Object(u.h)(a());
					if (e.ok) {
						const n = e.body;
						if (n.errors && n.errors.length) return void(await t(y(i)));
						if (!n.data.identity) return void(await t(E(i)));
						await t(x({
							powerups: n.data.identity.powerups
						}))
					}
				} catch (d) {
					o.c.captureException(d), await t(y(i))
				}
			}, O = Object(r.a)(_.yb), x = Object(r.a)(_.xb), E = Object(r.a)(_.wb), y = e => async (t, n) => {
				await t(E(e)), t(Object(c.f)({
					kind: m.b.Error,
					duration: c.a,
					text: e
				}))
			}, j = (e, t) => async (e, n, r) => {
				let {
					gqlContext: a
				} = r;
				var i;
				if (!!n().users.powerups.fetched) return;
				e(C());
				const d = s.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const n = await Object(u.e)(a(), t);
					if (n.ok) {
						const s = n.body;
						if (s.errors && s.errors.length) return void(await e(S(d)));
						if (!s.data.redditorInfoById) return void(await e(I(d)));
						const r = (null === (i = s.data.redditorInfoById.powerups) || void 0 === i ? void 0 : i.supportedSubreddits) || [];
						await e(k({
							supportedSubreddits: r,
							userId: t
						}))
					}
				} catch (c) {
					o.c.captureException(c), await e(S(d))
				}
			}, C = Object(r.a)(_.eb), k = Object(r.a)(_.db), I = Object(r.a)(_.cb), S = e => async (t, n) => {
				await t(I(e)), t(Object(c.f)({
					kind: m.b.Error,
					duration: c.a,
					text: e
				}))
			}, w = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				return async (n, r, a) => {
					let {
						gqlContext: i
					} = a;
					var d;
					const c = r();
					if (Object(p.i)(c, {
							subredditId: e
						}) && Object(b.a)(c, {
							subredditId: e
						}) && (!t.fullData || Object(p.k)(c, {
							subredditId: e
						})) && !t.forceLoad) return;
					n(P());
					const l = t.fullData ? u.g : u.f;
					try {
						const s = await l(i(), e, !!t.includeIdentity);
						if (s.ok) {
							const r = s.body;
							if (null === (d = r.errors) || void 0 === d ? void 0 : d.length) return void(await n(D(r.errors[0].message)));
							if (t.fullData) {
								const {
									data: t
								} = r, s = T(t.subredditInfoById, t.identity);
								N(n, e, s)
							} else {
								const {
									powerups: t = null,
									powerupsSettings: s = null
								} = r.data.subredditInfoById || {};
								await n(R({
									powerups: t,
									subredditId: e,
									benefitStatuses: null == s ? void 0 : s.benefitStatuses
								}))
							}
						}
					} catch (m) {
						o.c.captureException(m), await n(D(s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})))
					}
				}
			}, T = (e, t) => {
				var n, s, r;
				const {
					powerups: o = null,
					powerupsSettings: a = null,
					supporters: i = null,
					productOffers: d = null,
					subredditAchievementFlairs: c
				} = e || {}, l = null == t ? void 0 : t.powerups;
				return {
					powerups: o,
					benefitStatuses: null == a ? void 0 : a.benefitStatuses,
					productOffers: null !== (n = null == d ? void 0 : d.offers) && void 0 !== n ? n : [],
					recentSupporters: null !== (s = null == i ? void 0 : i.recentSupporters) && void 0 !== s ? s : [],
					topSupporters: null !== (r = null == i ? void 0 : i.topSupporters) && void 0 !== r ? r : [],
					userPowerups: l,
					subredditAchievementFlairs: null != c ? c : []
				}
			}, N = (e, t, n) => e(A({
				subredditId: t,
				...n
			})), P = Object(r.a)(_.ob), R = Object(r.a)(_.nb), A = Object(r.a)(_.mb), M = Object(r.a)(_.lb), D = e => async (t, n) => {
				await t(M(e)), t(Object(c.f)({
					kind: m.b.Error,
					duration: c.a,
					text: e
				}))
			}, L = Object(r.a)(_.R), F = Object(r.a)(_.S), U = Object(r.a)(_.T), B = e => async (t, n) => {
				await t(L(e)), t(Object(c.f)({
					kind: m.b.Error,
					duration: c.a,
					text: e
				}))
			}, G = (e, t, n, r) => async (a, i, p) => {
				let {
					gqlContext: b
				} = p;
				a(F({
					subredditId: e,
					powerupsCount: t,
					isAnonymous: n,
					allocatedAt: r
				}));
				try {
					const o = {
							subredditId: e,
							powerupsCount: t,
							isAnonymous: n
						},
						p = await Object(u.d)(b(), {
							input: o
						});
					let f = !1,
						_ = null;
					if (p.ok) {
						const e = p.body;
						f = e.data.reallocatePowerups.ok, _ = e.data.reallocatePowerups.errors
					}
					const O = Object(h.k)(i());
					if (f && O) await a((e => async (t, n) => {
						t(U(e)), await t(w(e.subredditId, {
							forceLoad: !0,
							fullData: !1
						})), t(v(!0)), t(Object(g.a)(e.subredditId, !0)), e.powerupsCount && (t(Object(d.g)(l.a.ECON_POWERUPS_PURCHASE)), e.powerupsCount > 0 ? t(Object(d.h)(l.a.ECON_POWERUPS_SUCCESS)) : t(Object(c.f)({
							kind: m.b.SuccessCommunityGreen,
							duration: c.a,
							text: s.fbt._("Your Powerup subscription has been canceled.", null, {
								hk: "z7ZJZ"
							})
						})))
					})({
						subredditId: e,
						powerupsCount: t,
						isAnonymous: n,
						user: O,
						allocatedAt: r
					}));
					else {
						const e = _ && _[0] && _[0].message || s.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
						await a(B(e))
					}
				} catch (f) {
					o.c.captureException(f);
					const e = f,
						t = e && e.message || s.fbt._("An unknown error occurred", null, {
							hk: "2oAbwZ"
						});
					await a(B(t))
				}
			}, H = Object(r.a)(_.E), W = Object(r.a)(_.Q), q = e => Object(d.h)(l.a.ECON_SUPPORTERS_LIST, {
				subredditId: e
			}), V = (e, t) => async (n, s) => {
				const r = s();
				return Object(h.k)(r) ? (Object(a.a)(Object(f.f)(e)(r)), n(Object(d.h)(l.a.ECON_POWERUPS_MARKETING, {
					subredditId: t
				}))) : n(Object(i.openLoginModal)())
			}, z = () => async (e, t) => {
				const n = t();
				return Object(h.k)(n) ? e(Object(d.h)(l.a.ACHIEVEMENT_FLAIR)) : e(Object(i.openLoginModal)())
			}, K = Object(r.a)(_.M), Q = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const a = await Object(u.i)(o(), e, (e => Object.keys(e).map(t => ({
					benefit: t,
					isEnabled: e[t]
				})))(t));
				if (a.ok) {
					const t = a.body.data.updatePowerupsSettings.powerupsSettings.benefitStatuses;
					return n(K({
						subredditId: e,
						benefitStatuses: t
					})), !0
				}
				return !1
			}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "p", (function() {
				return _
			})), n.d(t, "q", (function() {
				return v
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "s", (function() {
				return x
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "v", (function() {
				return j
			})), n.d(t, "w", (function() {
				return C
			})), n.d(t, "x", (function() {
				return k
			}));
			const s = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				o = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				a = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				i = "POLL_VOTE_SUCCESS",
				d = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				c = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				u = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				m = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				b = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				h = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				g = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				_ = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				v = "GOVERNANCE__TRANSFER_FAILURE",
				O = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				x = "GOVERNANCE__TRANSFER_PENDING",
				E = "GOVERNANCE__TRANSFER_SUCCESS",
				y = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				j = "GOVERNANCE__WALLETS_FETCH_PENDING",
				C = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				k = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/actions/toaster.ts"),
				r = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				o = n("./src/reddit/models/Toast/index.ts");

			function a(e, t) {
				e(Object(s.f)({
					duration: 5e3,
					kind: o.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "d", (function() {
				return M
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "h", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/config.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/Poll/index.ts"),
				m = n("./src/redditGQL/operations/PollVote.json"),
				p = n("./src/reddit/endpoints/governance/requester.ts");
			var b = n("./src/reddit/endpoints/governance/wallet.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/Vote/index.ts"),
				g = n("./src/reddit/selectors/crypto/points.ts"),
				_ = n("./src/reddit/actions/governance/constants.ts"),
				v = n("./src/reddit/actions/governance/errorToast.ts");
			const O = Object(r.a)(_.b),
				x = Object(r.a)(_.c),
				E = Object(r.a)(_.e),
				y = (Object(r.a)(_.f), Object(r.a)(_.g), Object(r.a)(_.h)),
				j = Object(r.a)(_.i),
				C = Object(r.a)(_.j),
				k = Object(r.a)(_.k),
				I = Object(r.a)(_.q),
				S = Object(r.a)(_.r),
				w = Object(r.a)(_.s),
				T = Object(r.a)(_.t),
				N = Object(r.a)(_.u),
				P = Object(r.a)(_.v),
				R = Object(r.a)(_.w),
				A = Object(r.a)(_.x),
				M = (e, t) => async (n, s, r) => {
					let o, {
							apiContext: a,
							gqlContext: d
						} = r,
						b = s().polls.models[e];
					if (n(C({
							pollId: e
						})), (o = b.type === u.a.GA ? await ((e, t, n) => Object(l.a)(e, {
								...m,
								variables: {
									input: {
										postId: t,
										optionId: n
									}
								}
							}))(d(), e, t) : await
							function(e, t, n, s) {
								return Object(p.a)(e, {
									method: "put",
									endpoint: `${c.a.metaUrl}/polls/${t}/${n}/votes/me/${s}`
								})
							}(a(), b.subredditId, e, t)).ok) {
						if (b.type === u.a.GA) {
							const {
								options: e
							} = o.body.data.updatePostPollVoteState.poll;
							n(E({
								pollId: b.id,
								optionId: t,
								options: e
							}))
						} else n(k(o.body));
						const r = s();
						if ((b = r.polls.models[e]) && Object(u.d)(b)) {
							const {
								postId: e
							} = b, t = r.posts.models[e];
							t && t.voteState === f.a.notVoted && n(Object(i.kb)(e))
						}
					} else n(j({
						pollId: e,
						error: o.error || o.errors[0].message
					})), Object(v.a)(n, o.error || o.errors[0].messsage)
				}, D = (e, t) => async (n, r, i) => {
					let {
						apiContext: l
					} = i;
					var u;
					n(w());
					const m = r().transfers.communityPoints.contentId || void 0,
						b = await
					function(e, t) {
						return Object(p.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: `${c.a.metaUrl}/wallets/me/${t.subredditId}/transfers`,
							method: "post"
						})
					}(l(), {
						...e,
						contentId: m
					});
					b.ok ? (n(T({
						...b.body,
						subredditId: e.subredditId
					})), n(Object(d.f)({
						kind: h.b.SuccessCommunity,
						text: s.fbt._("Success! You just transferred {amount} {tokenName} to {recipient}", [s.fbt._param("amount", Object(o.a)(e.amount)), s.fbt._param("tokenName", (null === (u = Object(g.b)(r(), e.subredditId)) || void 0 === u ? void 0 : u.name) || ""), s.fbt._param("recipient", e.recipient)], {
							hk: "3klrhq"
						})
					})), t && n(Object(a.f)())) : (n(I({
						error: b.error
					})), Object(v.a)(n, b.error))
				}, L = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(P());
					const o = await Object(b.a)(r(), e);
					o.ok ? t(R(o.body)) : t(N({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "l", (function() {
				return a
			})), n.d(t, "k", (function() {
				return i
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			const s = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				a = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				d = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				c = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				m = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "d", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/SubredditFlairedRedditorByName.json"),
				i = n("./src/redditGQL/operations/SubredditFlairedRedditors.json");
			var d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var m = e => {
				const {
					subreddit: t,
					redditorInfoByName: n
				} = e.data, {
					id: s,
					flairedRedditorByName: r
				} = t, o = {};
				let a = null;
				if (!n) return {
					subredditId: s,
					searchResult: a,
					flairedUsers: o
				};
				const {
					name: i
				} = n;
				if (a = i, r) {
					const {
						flair: e,
						redditor: t
					} = r, {
						name: n
					} = t;
					e && (o[n] = Object(u.a)(e)[0])
				}
				return {
					subredditId: s,
					searchResult: a,
					flairedUsers: o
				}
			};
			var p = e => {
					const {
						subreddit: t
					} = e.data, {
						id: n,
						flairedRedditors: s
					} = t, {
						pageInfo: r,
						edges: o
					} = s, a = [], i = {};
					return o.forEach(e => {
						const {
							node: t
						} = e, {
							flair: n,
							redditor: {
								name: s
							}
						} = t;
						if (a.push(s), n) {
							const e = Object(u.a)(n)[0];
							i[s] = e
						}
					}), {
						subredditId: n,
						flairedUsers: i,
						userOrder: a,
						pageInfo: r
					}
				},
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/User/index.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/actions/grantUserFlair/constants.ts");
			const v = Object(r.a)(_.i),
				O = Object(r.a)(_.g),
				x = Object(r.a)(_.f),
				E = (e, t) => async (n, r, a) => {
					let {
						gqlContext: d
					} = a;
					const l = t && t.after || "",
						u = t && t.before || "",
						m = Object(g.F)(r(), e),
						f = Object(b.e)(m, l, u);
					if (!!r().pages.modHub.flairedUsers.userOrder[f]) return;
					n(v());
					const _ = await ((e, t, n) => Object(o.a)(e, {
						...i,
						variables: {
							subredditName: t,
							...n
						}
					}))(d(), e, t);
					if (_.ok) {
						const e = {
							...p(_.body),
							key: f
						};
						n(O(e))
					} else {
						const e = _.error;
						n(x(e)), n(Object(c.f)({
							kind: h.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})
						}))
					}
				}, y = Object(r.a)(_.l), j = Object(r.a)(_.k), C = Object(r.a)(_.j), k = (e, t) => async (n, r, i) => {
					let {
						gqlContext: d
					} = i;
					const l = Object(g.U)(r(), {
						subredditId: e
					}).name;
					n(y());
					const u = await ((e, t, n) => Object(o.a)(e, {
						...a,
						variables: {
							subredditName: t,
							name: n
						}
					}))(d(), l, t);
					if (u.ok) {
						const e = m(u.body);
						n(j(e))
					} else n(C(u.error)), n(Object(c.f)({
						kind: h.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})
					}))
				}, I = Object(r.a)(_.e), S = Object(r.a)(_.c), w = Object(r.a)(_.d), T = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r(),
						l = Object(g.U)(i, {
							subredditId: t
						}).name;
					n(I());
					const u = await Object(d.a)(a(), e, l);
					if (u.ok) {
						n(S({
							userName: e,
							subredditId: t
						}));
						const r = Object(c.e)(s.fbt._("User flair cleared", null, {
							hk: "4yyH00"
						}), h.b.SuccessMod);
						n(Object(c.f)(r))
					} else {
						n(w());
						const r = Object(c.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "uG2KO"
						}), h.b.Error, s.fbt._("Retry", null, {
							hk: "3oiY99"
						}), T(e, t));
						n(Object(c.f)(r))
					}
					return u.ok || u.error
				}, N = Object(r.a)(_.h), P = Object(r.a)(_.b), R = Object(r.a)(_.a), A = (e, t, n) => async (r, o, a) => {
					let {
						apiContext: i
					} = a;
					const u = o(),
						m = u.pages.modHub.flairedUsers.search.result === e && !u.pages.modHub.flairedUsers.models[e],
						p = {
							userName: e,
							subredditId: t,
							applied: n
						},
						b = n && n.templateId,
						_ = Object(g.U)(u, {
							subredditId: t
						}),
						v = n && Object(l.g)(n),
						O = n ? n.cssClass : void 0,
						x = await Object(d.g)(i(), e, _.name, b, v, O);
					if (x.ok) {
						if (m) {
							let e;
							Object.keys(u.pages.modHub.flairedUsers.userOrder).forEach(t => {
								!1 === u.pages.modHub.flairedUsers.pageInfo[t].hasNextPage && u.pages.modHub.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = {
								...p,
								key: e
							};
							r(R(t))
						}
						e === (u.user.account && Object(f.e)(u.user.account)) ? r(N(p)) : m || r(P(p))
					} else {
						const e = Object(c.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4hXQvr"
						}), h.b.Error);
						r(Object(c.f)(e))
					}
					return x.ok || x.error
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				o = "INCONTEXT__MUTED",
				a = Object(s.a)(r),
				i = Object(s.a)(o)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "i", (function() {
				return x
			})), n.d(t, "j", (function() {
				return E
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				l = n("./src/reddit/selectors/user.ts");
			const u = "META__GEO_CHANGED",
				m = Object(o.a)(u),
				p = "META__META_RECEIVED",
				b = (Object(o.a)(p), "META__SET_LOCALE"),
				h = Object(o.a)(b),
				f = e => async (t, n, o) => {
					let {
						apiContext: u
					} = o;
					if (!e) return;
					const m = n(),
						p = u();
					let b;
					if (t(h(e)), Object(s.isPseudoLocale)(e) ? (Object(l.N)(m) || Object(c.b)(m)) && (b = e) : b = Object(s.isoLocaleToR2Language)(e), !b) return;
					const f = new URL(window.location.href);
					Object(l.Q)(m) ? Object(s.isPseudoLocale)(b) ? f.searchParams.set("locale", b) : (await Object(a.a)(Object(i.a)(p, [d.a]), {
						data: {
							lang: b
						},
						endpoint: `${p.apiUrl}/api/v1/me/prefs`,
						method: r.jb.PATCH,
						type: "json"
					}), f.searchParams.delete("locale")) : f.searchParams.delete("locale"), window.location.href = f.toString()
				}, g = "META__SET_POPULAR_GEO_FILTER", _ = Object(o.a)(g), v = "META__PWA_ENTERED", O = "META__PWA_LEFT", x = Object(o.a)(v), E = Object(o.a)(O)
		},
		"./src/reddit/actions/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return X
			})), n.d(t, "d", (function() {
				return ee
			})), n.d(t, "f", (function() {
				return re
			})), n.d(t, "a", (function() {
				return oe
			})), n.d(t, "b", (function() {
				return ae
			})), n.d(t, "c", (function() {
				return ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/bulkActions/index.ts"),
				i = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				d = n("./src/reddit/actions/removalReasons/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/modQueue/index.ts"),
				u = n("./src/reddit/endpoints/user/index.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/flair.ts"),
				b = n("./node_modules/Base64/base64.js"),
				h = n("./src/reddit/components/ModQueueList/PostSortDropdown.tsx"),
				f = n("./src/reddit/helpers/isPost.ts"),
				g = n("./src/reddit/selectors/commentSelector.ts"),
				_ = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/redditGQL/types.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const y = {
					[r.rb.Edited]: v.t.Edited,
					[r.rb.Modqueue]: v.t.Mod,
					[r.rb.Reports]: v.t.Reported,
					[r.rb.Spam]: v.t.Removed,
					[r.rb.Unmoderated]: v.t.Unmoderated
				},
				j = {
					comments: v.r.Comment,
					links: v.r.Post,
					chat_comments: v.r.ChatComment
				};

			function C(e) {
				let {
					getState: t,
					queueType: n,
					options: s
				} = e;
				const r = t();
				let o;
				s.only && (o = j[s.only]);
				const a = {};
				s.after && (a[s.sort === h.a.OldestFirst ? "before" : "after"] = function(e, t) {
					const n = Object(f.a)(t) ? Object(_.G)(e, {
						postId: t
					}) : Object(g.b)(e, {
						commentId: t
					});
					if (n) return Object(b.btoa)(`${n.id}|${n.created}`)
				}(r, s.after));
				const i = {};
				return s.sort === h.a.OldestFirst ? i.last = 25 : i.first = 25, {
					queueType: y[n],
					...i,
					...!!o && {
						itemTypes: o
					},
					...!!s.subreddit && {
						subredditIds: [s.subreddit]
					},
					...!!s.profile && {
						subredditIds: [s.profile]
					},
					sort: s.sort === h.a.MostReportedFirst ? v.s.SortReports : v.s.SortDate,
					...a
				}
			}
			var k;
			! function(e) {
				e.Comment = "ModQueueItemComment", e.Post = "ModQueueItemPost", e.ChatComment = "ModQueueItemChatComment"
			}(k || (k = {}));
			var I = n("./src/reddit/models/ModQueue/index.ts"),
				S = n("./src/reddit/models/Toast/index.ts"),
				w = n("./src/reddit/selectors/modQueue.ts"),
				T = n("./src/reddit/selectors/subreddit.ts"),
				N = n("./src/reddit/selectors/telemetry.ts"),
				P = n("./src/telemetry/index.ts"),
				R = n("./src/lib/initializeClient/installReducer.ts"),
				A = n("./src/reddit/reducers/pages/modHub/index.ts"),
				M = n("./src/reddit/actions/modQueue/constants.ts");
			Object(R.a)({
				pages: {
					modHub: A.a
				}
			});
			const D = Object(o.a)(M.j),
				L = Object(o.a)(M.i),
				F = Object(o.a)(M.h),
				U = Object(o.a)(M.g),
				B = Object(o.a)(M.f),
				G = Object(o.a)(M.e),
				H = Object(o.a)(M.n),
				W = Object(o.a)(M.m),
				q = Object(o.a)(M.l),
				V = Object(o.a)(M.q),
				z = Object(o.a)(M.p),
				K = Object(o.a)(M.o),
				Q = Object(o.a)(M.w),
				J = Object(o.a)(M.v),
				Y = Object(o.a)(M.u),
				X = (e, t, n) => async (o, a, d) => {
					let {
						apiContext: m,
						gqlContext: p
					} = d;
					var b, h;
					let f, g, _;
					switch (t) {
						case r.rb.Edited:
							f = U, g = G, _ = B;
							break;
						case r.rb.Modqueue:
							f = D, g = F, _ = L;
							break;
						case r.rb.Reports:
							f = H, g = q, _ = W;
							break;
						case r.rb.Spam:
							f = V, g = K, _ = z;
							break;
						case r.rb.Unmoderated:
							f = Q, g = Y, _ = J;
							break;
						default:
							throw new Error("Invalid modqueue requested")
					}
					o(f());
					const v = await Object(l.c)(m(), t, n);
					if (v.ok) {
						const r = v.body,
							d = {
								...n
							};
						if (d.subreddit) {
							const e = null === (b = Object.values(r.subreddits).find(e => {
								let {
									name: t
								} = e;
								return t === n.subreddit
							})) || void 0 === b ? void 0 : b.id;
							d.subreddit = e
						}
						if (d.profile) {
							const e = null === (h = (await Object(u.b)(m(), d.profile)).body[d.profile]) || void 0 === h ? void 0 : h.profileId;
							d.profile = e
						}
						const f = C({
								getState: a,
								queueType: t,
								options: d
							}),
							y = await Object(l.b)(p(), f);
						if (!y.ok) return o(g(y.error)), void o(Object(c.f)({
							kind: S.b.Error,
							text: s.fbt._("Oh no! Something went wrong!", null, {
								hk: "16O2Sk"
							})
						}));
						const j = function(e) {
							let {
								modQueueItems: t
							} = e;
							const n = {
								posts: {},
								comments: {},
								reports: {},
								modqueue: [],
								authorFlair: {},
								listingOrder: []
							};
							return t && t.edges ? (t.edges.forEach(e => {
								var t, s;
								if (!e) return;
								const {
									node: r
								} = e;
								if (!r) return;
								const {
									__typename: o,
									subredditInfo: a
								} = r;
								if (!a) return;
								const {
									id: i
								} = a;
								if (o === k.Comment || o === k.ChatComment) {
									const {
										commentInfo: e
									} = r;
									if (!e) return;
									const s = Object(O.a)(e);
									n.comments[s.id] = s, n.listingOrder.push({
										id: s.id,
										type: "comment"
									}), n.modqueue.push(s.id);
									const {
										authorInfo: o,
										authorFlair: a
									} = e, d = a ? null === (t = Object(x.a)(a)) || void 0 === t ? void 0 : t[0] : null;
									n.authorFlair[i] = {
										...n.authorFlair[i],
										...(null == o ? void 0 : o.name) ? {
											[null == o ? void 0 : o.name]: d
										} : {}
									};
									const c = [];
									s.modReports.forEach(e => {
										c.push({
											type: "moderator",
											reason: e[0],
											reporter: e[1]
										})
									}), s.userReports.forEach(e => {
										c.push({
											type: "user",
											reason: e[0]
										})
									}), n.reports[s.id] = c
								}
								if (o === k.Post) {
									const {
										postInfo: e
									} = r;
									if (!e) return;
									const t = Object(E.f)(e);
									n.posts[t.id] = t, n.listingOrder.push({
										id: t.id,
										type: "post"
									}), n.modqueue.push(t.id);
									const {
										authorInfo: o,
										authorFlair: a
									} = e, d = a ? null === (s = Object(x.a)(a)) || void 0 === s ? void 0 : s[0] : null;
									n.authorFlair[i] = {
										...n.authorFlair[i],
										...(null == o ? void 0 : o.name) ? {
											[null == o ? void 0 : o.name]: d
										} : {}
									};
									const c = [];
									t.modReports.forEach(e => {
										c.push({
											type: "moderator",
											reason: e[0],
											reporter: e[1]
										})
									}), t.userReports.forEach(e => {
										c.push({
											type: "user",
											reason: e[0]
										})
									}), n.reports[t.id] = c
								}
							}), n) : n
						}(y.body.data);
						o(_({
							listingKey: e,
							page: `${n.page||I.b}`,
							response: {
								...r,
								...j
							}
						})), o(Object(i.a)({
							postIds: r.posts ? Object.keys(r.posts) : void 0,
							commentIds: r.comments ? Object.keys(r.comments) : void 0
						}))
					} else o(g(v.error)), o(Object(c.f)({
						kind: S.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}))
				}, Z = Object(o.a)(M.k), $ = Object(o.a)(M.b), ee = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const a = n(),
						i = a.pages.modHub.modQueue.moderatedCommunitiesOrder.after,
						d = a.pages.modHub.modQueue.moderatedCommunitiesOrder.pending,
						u = a.pages.modHub.modQueue.moderatedCommunitiesOrder.loaded,
						{
							pageName: m
						} = a.platform.currentPage.urlParams,
						p = m;
					if (e && d || u || !i) return;
					const b = await Object(l.c)(o(), p, {
						moderated_after: i
					});
					if (b.ok) {
						const e = b.body;
						t(Z(e)), e.moderatedAfter ? t(ee()) : t($())
					} else t(Object(c.f)({
						kind: S.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}))
				}, te = Object(o.a)(M.t), ne = Object(o.a)(M.s), se = Object(o.a)(M.r), re = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: u
					} = i;
					r(Object(a.c)());
					const b = o(),
						h = Object(w.g)(b),
						g = b.user.account && b.user.account.displayText;
					Object(m.d)(m.a.ModQueue);
					const _ = Object(m.c)(m.a.ModQueue);
					Object(P.a)({
						source: "bulk_mod_action_menu",
						action: "click",
						noun: e,
						...N.n(b),
						actionInfo: N.d(b, {
							count: h.length,
							paneName: b.platform.currentPage ? b.platform.currentPage.urlParams.pageName : void 0
						}),
						screen: N.Z(b),
						correlationId: _
					});
					for (let t = 0; t < h.length; t++) {
						const n = h[t];
						let s = e;
						[I.a.Approve, I.a.Remove, I.a.Spam].includes(e) && (Object(f.a)(n) ? s += "_link" : s += "_comment"), Object(P.a)({
							source: "bulk_mod_action",
							action: "click",
							noun: s,
							...N.n(b),
							actionInfo: N.d(b, {
								count: h.length,
								paneName: b.platform.currentPage ? b.platform.currentPage.urlParams.pageName : void 0
							}),
							comment: N.h(b, n),
							post: N.I(b, n),
							profile: N.T(b, n),
							screen: N.Z(b),
							subreddit: N.kb(b, n),
							correlationId: _
						})
					}
					Object(m.b)(m.a.ModQueue);
					const v = {
						ids: h
					};
					t && (v.text = Object(p.g)(t) || "", v.flairTemplateId = ""), n && (v.cssClass = n, v.flairTemplateId = n);
					const O = await Object(l.a)(u(), e, v);
					if (O.ok) {
						r(Object(a.b)({
							...O.body,
							operation: e,
							ids: h,
							username: g,
							options: {
								flair: t
							}
						}));
						const n = function(e, t) {
							switch (e) {
								case I.a.Approve:
									return s.fbt._({
										"*": "{number} posts/comments have been approved",
										_1: "1 post/comment has been approved"
									}, [s.fbt._plural(t, "number")], {
										hk: "2kKhSf"
									});
								case I.a.Flair:
									return s.fbt._({
										"*": "{number} posts/comments have had flair applied",
										_1: "1 post/comment has had flair applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "3syB5O"
									});
								case I.a.IgnoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports ignored",
										_1: "1 post/comment has had their reports ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "2WfE4g"
									});
								case I.a.Lock:
									return s.fbt._({
										"*": "{number} posts/comments have been locked",
										_1: "1 post/comment has been locked"
									}, [s.fbt._plural(t, "number")], {
										hk: "45oMbv"
									});
								case I.a.MarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been marked NSFW",
										_1: "1 post/comment has been marked NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "oPsQr"
									});
								case I.a.RemovalReason:
									return s.fbt._({
										"*": "{number} posts/comments have had removal reasons applied",
										_1: "1 post/comment has had removal reasons applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "35Tosn"
									});
								case I.a.Remove:
									return s.fbt._({
										"*": "{number} posts/comments have been removed",
										_1: "1 post/comment has been removed"
									}, [s.fbt._plural(t, "number")], {
										hk: "B1ZbE"
									});
								case I.a.Spam:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spam",
										_1: "1 post/comment has been marked as spam"
									}, [s.fbt._plural(t, "number")], {
										hk: "3OoNfp"
									});
								case I.a.Spoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spoilers",
										_1: "1 post/comment has been marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "1DFW5M"
									});
								case I.a.UnignoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports un-ignored",
										_1: "1 post/comment has had their reports un-ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "303Hpb"
									});
								case I.a.Unlock:
									return s.fbt._({
										"*": "{number} posts/comments have been unlocked",
										_1: "1 post/comment has been unlocked"
									}, [s.fbt._plural(t, "number")], {
										hk: "5gUht"
									});
								case I.a.UnmarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as NSFW",
										_1: "1 post/comment has been un-marked as NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "3oSSST"
									});
								case I.a.Unspoiler:
								case I.a.Unspoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as spoilers",
										_1: "1 post/comment has been un-marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "3lHoNI"
									})
							}
						}(e, h.length);
						if (e !== I.a.Approve && e !== I.a.Flair) {
							let t, o;
							const i = b.platform.currentPage && b.platform.currentPage.queryParams && b.platform.currentPage.queryParams.subreddit,
								u = i && Object(T.F)(b, i);
							e === I.a.Remove && u && h.length > 1 && (t = s.fbt._("Add a removal reason", null, {
								hk: "3gGDCl"
							}), o = Object(d.fetchReasonsAndOpenModal)(u, h));
							const m = Object(c.e)(n, S.b.Undo, s.fbt._("UNDO", null, {
								hk: "49SEAI"
							}), (() => async (e, t, n) => {
								let {
									apiContext: r
								} = n;
								e(te());
								const o = t(),
									i = Object.keys(o.pages.modHub.modQueue.bulkAction.undoLastAction)[0],
									d = o.pages.modHub.modQueue.bulkAction.undoLastAction[i],
									u = o.user.account && o.user.account.displayText;
								e(Object(a.c)());
								const m = await Object(l.a)(r(), i, {
									ids: d
								});
								m.ok ? e(ne({
									...m.body,
									operation: i,
									ids: d,
									username: u
								})) : (e(se(m.error)), e(Object(c.f)({
									kind: S.b.Error,
									text: s.fbt._("Oh no! Something went wrong!", null, {
										hk: "16O2Sk"
									})
								})))
							})(), t, o);
							r(Object(c.f)(m))
						} else {
							const e = Object(c.e)(n, S.b.SuccessMod);
							r(Object(c.f)(e))
						}
					} else {
						r(Object(a.a)(O.error));
						const e = Object(c.e)(s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						}), S.b.Error);
						r(Object(c.f)(e))
					}
				}, oe = Object(o.a)(M.a), ae = Object(o.a)(M.c), ie = Object(o.a)(M.d)
		},
		"./src/reddit/actions/modQueueTriggers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/actions/comment/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/ModQueueTriggers.json");
			const i = e => {
				let {
					commentIds: t = [],
					postIds: n = []
				} = e;
				return async (e, i, d) => {
					let {
						gqlContext: c
					} = d;
					var l, u;
					if (!t.length && !n.length) return;
					const m = await ((e, t) => Object(o.a)(e, {
						...a,
						variables: t
					}))(c(), {
						commentIds: t,
						postIds: n
					});
					if (m.ok) {
						const t = m.body;
						if (t.data.commentsByIds) {
							const n = Object.fromEntries(null === (l = t.data.commentsByIds) || void 0 === l ? void 0 : l.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(s.j)(n))
						}
						if (t.data.postsInfoByIds) {
							const n = Object.fromEntries(null === (u = t.data.postsInfoByIds) || void 0 === u ? void 0 : u.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(r.S)(n))
						}
					}
				}
			}
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/profile/index.ts"),
				o = (n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"), n("./src/reddit/models/User/index.ts")),
				a = n("./src/reddit/selectors/user.ts");
			const i = "MOD_PERMS__REQUEST_LOADED",
				d = (Object(s.a)("MOD_PERMS__REQUEST_PENDING"), Object(s.a)(i), Object(s.a)("MOD_PERMS__REQUEST_FAILED"), () => async (e, t) => {
					const n = Object(a.k)(t());
					if (n) {
						const t = Object(o.e)(n);
						await e(Object(r.b)(t))
					}
				})
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED"
		},
		"./src/reddit/actions/notificationSettingsLayout/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			}));
			const s = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__FAILED",
				r = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__LOADED",
				o = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__PENDING",
				a = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__FAILED",
				i = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__LOADED",
				d = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__PENDING",
				c = "NOTIFICATION_SETTINGS_LAYOUT_UPDATED",
				l = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_FAILED",
				u = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_LOADED",
				m = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_PENDING",
				p = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_UPDATED"
		},
		"./src/reddit/actions/notificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/notificationSettingsLayout/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/UserSubredditsNotificationsLevel.json");
			var l = n("./src/reddit/models/NotificationSettingsLayout/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(o.c),
				p = Object(r.a)(o.b),
				b = Object(r.a)(o.a),
				h = Object(r.a)(o.f),
				f = Object(r.a)(o.e),
				g = Object(r.a)(o.d),
				_ = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					e === l.a.Push ? t(h()) : t(m()), await async function(e, t, n) {
						const s = await Object(i.a)(e(), {
							channel: t
						});
						if (s.ok && s.body) {
							const e = function(e) {
								const t = e && e.data,
									n = t && t.notificationSettingsLayoutByChannel,
									s = n && n.sections;
								if (s) return function(e) {
									const t = {},
										n = [];
									let s = {},
										r = [];
									const o = e => {
										const {
											rowIds: o,
											rowsCollection: a
										} = function(e) {
											const t = [],
												n = {};
											if (e.rows)
												for (let s = 0; s < e.rows.length; s++) {
													const r = e.rows[s],
														o = r.messageType;
													t.push(o), n[o] = r
												}
											return {
												rowsCollection: n,
												rowIds: t
											}
										}(e);
										s = {
											...s,
											...a
										}, r = [...r, ...o];
										const i = e.id;
										n.push(i), t[i] = {
											...e,
											rows: o
										}
									};
									for (let a = 0; a < e.length; a++) o(e[a]);
									return {
										sections: {
											byId: t,
											allIds: n
										},
										rows: {
											byId: s,
											allIds: r
										}
									}
								}(s)
							}(s.body);
							t === l.a.Push ? n(f(e)) : n(p(e))
						} else t === l.a.Push ? n(g({
							error: s.error
						})) : n(b({
							error: s.error
						}))
					}(r, e, t)
				};
			const v = Object(r.a)(o.g),
				O = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					(await Object(i.b)(o(), e)).ok ? (x(t, e), function(e) {
						e(Object(a.f)({
							kind: u.b.SuccessCommunity,
							text: s.fbt._("Changes saved", null, {
								hk: "UBoVR"
							})
						}))
					}(t)) : function(e) {
						e(Object(a.f)({
							kind: u.b.Error,
							text: s.fbt._("We had some issues saving your changes. Please try again.", null, {
								hk: "1OvQi6"
							})
						}))
					}(t)
				};

			function x(e, t) {
				e(v({
					isEnabled: t.isEnabled,
					messageType: t.messageType
				}))
			}
			const E = Object(r.a)(o.j),
				y = Object(r.a)(o.i),
				j = Object(r.a)(o.k),
				C = Object(r.a)(o.h),
				k = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, i;
					t(E());
					const l = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), e);
					if (null === (i = null === (o = l.error) || void 0 === o ? void 0 : o.fields) || void 0 === i ? void 0 : i.length) return t(C({
						error: l.error
					})), void t(Object(a.d)());
					if (l.ok && l.body) {
						const e = l.body,
							n = e && e.data,
							s = n && n.identity && n.identity.subscribedSubreddits,
							r = s && s.pageInfo,
							o = (s && s.edges).map(e => e.node);
						t(y({
							nodes: o,
							pageInfo: r
						}))
					}
				}
		},
		"./src/reddit/actions/notifications/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "initializeServiceWorkerChannel", (function() {
				return w
			})), n.d(t, "requestNotificationsPermissions", (function() {
				return N
			})), n.d(t, "subscribeForPNs", (function() {
				return P
			})), n.d(t, "unsubscribeFromPNs", (function() {
				return R
			})), n.d(t, "requestBrowserNotificationPermissionPromptByUser", (function() {
				return A
			})), n.d(t, "subscribeToPermissionsChange", (function() {
				return M
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/omit.js"),
				o = n.n(r),
				a = n("./src/lib/browser/isIncognito.ts"),
				i = n("./src/lib/notifications/token.ts"),
				d = n("./src/lib/notifications/index.ts"),
				c = n("./src/lib/notifications/constants.ts"),
				l = n("./src/lib/serviceWorker/index.ts"),
				u = n("./src/reddit/actions/chat/toggle.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/notifications/utils.ts"),
				b = n("./src/reddit/actions/tabBadging.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/constants/modals.ts"),
				g = n("./src/reddit/helpers/parseUrl.ts"),
				_ = n("./src/reddit/helpers/tabBadging/index.ts"),
				v = n("./src/reddit/helpers/trackers/notifications.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/activeModal.ts"),
				E = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				y = n("./src/reddit/constants/experiments.ts"),
				j = n("./src/reddit/helpers/chooseVariant/index.ts");
			const C = e => Object(j.c)(e, {
				experimentName: y.fc,
				experimentEligibilitySelector: j.a
			}) === y.xd;
			var k = n("./src/reddit/selectors/meta.ts"),
				I = n("./src/reddit/selectors/user.ts");
			let S = !1;
			const w = async (e, t) => {
				const n = Object(I.P)(e);
				if (S) return;
				if (S = !0, Object(p.a)(e) !== c.c.NotificationsSupported) return;
				await Object(l.a)();
				navigator.serviceWorker.addEventListener("message", s => {
					const r = s.data,
						a = r.command || r.type;
					if ("registerWithServiceWorker" === a) T(e);
					else if (a === _.a && n) {
						const e = o()(r, ["command"]);
						t(Object(b.f)(e))
					} else if ("navigate.chat" === a) {
						const e = Object(g.a)(r.data.href);
						e && e.pathname && t(Object(u.c)(e.pathname))
					}
				}), T(e)
			}, T = e => {
				navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
					command: "registerClient",
					v2EventBoilerPlate: v.c(e)
				})
			}, N = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : () => {};
				return async (s, r, o) => {
					const i = r(),
						l = Object(k.f)(i),
						u = C(i),
						m = Object(E.e)(i),
						p = Object(x.c)(f.a.NSFW_BLOCKING_MODAL_V2)(i);
					if (m || p) return;
					if (await Object(a.a)() || l) return;
					await w(i, s);
					v.l(i), await Object(d.b)(e, t, () => {
						u || s(Object(c.o)()), s(Object(c.n)()), v.j(i)
					}, (e, t) => {
						s(Object(c.l)()), s(R(t ? c.a.Denied : c.a.Closed)), e && (t ? v.e(i) : v.f(i))
					}, e => {
						s(Object(c.m)()), s(P()), e && v.d(i)
					}, () => {
						s(Object(c.k)()), n()
					})
				}
			}, P = e => async (t, n, r) => {
				const o = n();
				try {
					switch (await Object(i.b)(r.gqlContext)) {
						case i.a.Success:
							Object(p.b)(c.a.Granted), v.m(o), e && t(Object(h.f)({
								kind: O.b.SuccessCommunity,
								text: s.fbt._("Changes saved", null, {
									hk: "wGH5U"
								})
							}));
							break;
						case i.a.FailedResponse:
							v.k(o, "registration_failed_generally");
							break;
						case i.a.FailedGqlReponse:
							v.k(o, "registration_failed_in_gql")
					}
				} catch (a) {
					v.k(o, "registration_failed_uncaught_exception"), console.error(a)
				}
			}, R = (e, t) => async n => {
				try {
					Object(p.b)(e);
					const r = await Object(l.a)();
					if (r) {
						const e = await r.pushManager.getSubscription();
						e && (e.unsubscribe(), t && n(Object(h.f)({
							kind: O.b.SuccessCommunity,
							text: s.fbt._("Changes saved", null, {
								hk: "wGH5U"
							})
						})))
					}
				} catch (r) {}
			}, A = e => async (t, n) => {
				const s = n();
				if (Object(p.a)(s) === c.c.NotificationsSupported) switch (Object(d.a)()) {
					case c.a.Default:
					case c.a.Closed:
						await t(N(!0, !0));
						break;
					case c.a.Denied:
						t(Object(m.h)(e))
				}
			}, M = () => async (e, t) => {
				var n;
				if (!(null === (n = null === navigator || void 0 === navigator ? void 0 : navigator.permissions) || void 0 === n ? void 0 : n.query)) return;
				const s = t();
				if (Object(p.a)(s) !== c.c.NotificationsSupported) return;
				const r = await navigator.permissions.query({
					name: "notifications"
				});
				r.onchange = () => (t => {
					switch (t) {
						case c.a.Denied:
							e(R(c.a.Denied)), v.e(s);
							break;
						case c.a.Granted:
							e(P()), v.d(s);
							break;
						default:
							e(R(c.a.Default))
					}
				})(r.state)
			}
		},
		"./src/reddit/actions/notifications/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/notifications/index.ts"),
				r = n("./src/lib/notifications/constants.ts"),
				o = n("./src/lib/notifications/featureFlags.ts"),
				a = n("./src/reddit/featureFlags/index.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts");
			const d = e => a.d.pushNotificationsBrowserSupported(e) ? Object(o.a)() : r.c.BrowserUnsupported,
				c = e => {
					switch (e) {
						case r.a.Denied:
							i.nb(!1), Object(s.c)();
							break;
						case r.a.Default:
						case r.a.Granted:
							i.nb(!0), Object(s.c)();
							break;
						case r.a.Closed:
							i.nb(!0)
					}
				}
		},
		"./src/reddit/actions/nsfwBlocking/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => n.e("NsfwBlockingActions").then(n.bind(null, "./src/reddit/actions/nsfwBlocking/index.ts")).then(e => e.default))
		},
		"./src/reddit/actions/onboarding/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "RESET_GENDER_UPDATE_STATE",
				r = "SUBREDDIT_INTEREST_TOPICS",
				o = "SKIP_ONBOARDING_MODAL"
		},
		"./src/reddit/actions/onboarding/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "openReonboardingModalIfNeeded", (function() {
				return u
			})), n.d(t, "resetGenderUpdateState", (function() {
				return m
			})), n.d(t, "subredditInterestTopicsLoaded", (function() {
				return p
			})), n.d(t, "skipOnboardingModal", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/login.ts"),
				o = n("./src/reddit/actions/onboarding/constants.ts"),
				a = n("./src/reddit/helpers/counters/onboarding.ts"),
				i = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				d = n("./src/reddit/models/Onboarding/index.ts"),
				c = n("./src/reddit/selectors/experiments/onboarding.ts"),
				l = n("./src/reddit/selectors/onboarding.ts");
			const u = () => async (e, t) => {
				const n = t(),
					s = n.platform.currentPage;
				if (Object(l.e)(n, {
						pageLayer: s
					})) {
					e(Object(r.openD2xOnboardingModal)({
						type: d.d.REONBOARDING,
						selectedInterests: {}
					})), Object(i.d)();
					const t = Object(c.c)(n);
					Object(a.b)(d.f.FirstPopover, t)
				}
			}, m = Object(s.a)(o.a), p = Object(s.a)(o.c), b = Object(s.a)(o.b);
			t.default = () => async (e, t) => {
				const n = t();
				Object(l.d)(n) && e(Object(r.openD2xOnboardingModal)())
			}
		},
		"./src/reddit/actions/pages/chatSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "f", (function() {
				return P
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/difference.js"),
				o = n.n(r),
				a = n("./src/telemetry/index.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/sentry/index.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/redditGQL/operations/GetSubredditChatSettings.json"),
				m = n("./src/lib/makeGqlRequest/index.ts");
			var p = (e, t) => Object(m.a)(e, {
					...u,
					variables: t
				}),
				b = n("./src/redditGQL/operations/UpdateSubredditChatSettings.json");
			var h = (e, t) => Object(m.a)(e, {
					...b,
					variables: t
				}),
				f = n("./src/reddit/selectors/telemetry.ts"),
				g = n("./src/telemetry/models/Event.ts");
			var _ = n("./src/reddit/models/ChatSettingsPage/index.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/chat.ts"),
				x = n("./src/reddit/selectors/chatSettingsPage.ts");
			const E = "FETCH_CHAT_SETTINGS__LOADED",
				y = "FETCH_CHAT_SETTINGS__FAILED",
				j = "FETCH_CHAT_SETTINGS__PENDING",
				C = "UPDATE_CHAT_SETTINGS__LOADED",
				k = Object(d.a)(E),
				I = Object(d.a)(y),
				S = Object(d.a)(j),
				w = Object(d.a)(C),
				T = e => async (t, n) => {
					const s = {
						subredditId: e
					};
					return !!Object(x.b)(n(), s) || (t(S(s)), !1)
				}, N = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = {
						subredditId: e
					};
					if (await t(T(e))) return;
					let a = null;
					const d = await p(r(), o);
					if (d.ok) {
						const t = d.body || {},
							s = t.data && t.data.subredditInfoById,
							r = s && s.chatSettings,
							i = !Object(O.a)(n(), o),
							c = Object(_.c)(r, e, i);
						a = {
							...o,
							chatSettings: c
						}
					}
					if (a) t(k(a));
					else {
						const n = d.error || {
							type: i.I.UNKNOWN_ERROR
						};
						t(I({
							...o,
							error: n
						})), c.c.withScope(t => {
							t.setExtra("info", {
								subredditId: e,
								responseBody: d.body,
								responseOk: d.ok
							}), c.c.captureMessage("Missing subreddit chat settings!")
						})
					}
				}, P = (e, t, n) => async (r, a, d) => {
					let {
						gqlContext: c
					} = d;
					if (await r(T(e))) return [];
					let u, m = !1;
					const p = o()(n, t),
						b = Object(_.b)(p);
					if (b && b.length) {
						const t = {
								subredditId: e,
								subredditChatSettings: b
							},
							n = await h(c(), {
								input: t
							});
						if (n.ok) {
							const e = (n.body || {}).data.updateSubredditChatSettings;
							m = !!e && e.ok
						} else u = n && n.error || {
							type: i.I.UNKNOWN_ERROR
						}
					}
					return m ? (r(w({
						subredditId: e,
						chatSettings: n
					})), r(A(t, p)), n) : (u && r(I({
						subredditId: e,
						error: u
					})), r(w({
						subredditId: e,
						chatSettings: t
					})), r(Object(l.f)({
						duration: l.a,
						id: "CHAT_SETTING_UPDATE_ERROR",
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "3HpR6h"
						})
					})), t)
				}, R = {
					start_chatting_opt_out: (e, t, n) => ({
						source: g.b.Chat,
						action: g.a.OptOut,
						noun: "down_to_chat_subreddit",
						subreddit: Object(f.hb)(e),
						setting: {
							oldValue: t,
							value: n
						},
						...Object(f.n)(e)
					})
				}, A = (e, t) => async (n, s) => {
					t.forEach(t => {
						if (t && t.settingId) {
							const n = R[t.settingId],
								r = e.find(e => e.settingId === t.settingId);
							if (n && r) {
								const e = n(s(), r.state, t.state);
								Object(a.a)(e)
							}
						}
					})
				}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return b
			}));
			const s = "PAGE__MOD_LISTING_PAGE_PENDING",
				r = "PAGE__MOD_LISTING_PAGE_LOADED",
				o = "PAGE__MOD_LISTING_PAGE_FAILED",
				a = "MOD_LISTING_MORE_POSTS_PENDING",
				i = "MOD_LISTING_MORE_POSTS_LOADED",
				d = "MOD_LISTING_MORE_POSTS_FAILED",
				c = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				l = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				u = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				m = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/moderationPages/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "moderationPageRequested", (function() {
				return Oe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/assertNever.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				l = n("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				u = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				m = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				p = n("./src/reddit/helpers/trackers/screenview.ts"),
				b = n("./src/reddit/actions/contentControls/index.ts"),
				h = n("./src/reddit/actions/emoji.ts"),
				f = n("./src/reddit/actions/eventPosts/index.ts"),
				g = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				_ = n("./src/reddit/actions/gold/powerups.ts"),
				v = n("./src/reddit/actions/grantUserFlair/index.ts"),
				O = n("./src/lib/makeActionCreator/index.ts"),
				x = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				y = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/actions/moderationLog/constants.ts");
			const k = Object(O.a)(C.b),
				I = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = await Object(x.a)(o(), e, t);
					if (a.body) {
						const t = a.body.data.subreddit.moderation;
						if (t && t.actions) {
							const r = s(),
								o = Object(E.b)(t.actions),
								a = Object(j.F)(r, e),
								{
									hasNextPage: i,
									hasPreviousPage: d,
									endCursor: c,
									startCursor: l
								} = t.actions.pageInfo,
								u = Object(y.a)(a, c, l),
								m = [];
							o.forEach(e => {
								m.push(e.id)
							}), n(k({
								hasNextPage: i,
								hasPreviousPage: d,
								endCursor: c,
								key: u,
								startCursor: l,
								normalizedModerationLog: o,
								actionIds: m,
								subredditId: a
							}))
						}
					}
				};
			var S = n("./src/reddit/actions/modQueue/index.ts"),
				w = n("./src/reddit/actions/pages/chatSettings.ts"),
				T = n("./src/reddit/actions/pages/subreddit.ts"),
				N = n("./src/reddit/actions/pages/subredditWiki/index.ts"),
				P = n("./src/reddit/actions/platform.ts"),
				R = n("./src/reddit/actions/profile/index.ts"),
				A = n("./src/reddit/actions/removalReasons/index.ts"),
				M = n("./src/reddit/actions/streaming/modSettings.ts"),
				D = n("./src/reddit/actions/subreddit.ts"),
				L = n("./src/reddit/actions/subreddit/questions.ts"),
				F = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				U = n("./src/reddit/actions/subredditModeration/index.ts"),
				B = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				G = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				H = n("./src/reddit/actions/subredditModeration/ban.ts"),
				W = n("./src/reddit/actions/subredditModeration/mute.ts"),
				q = n("./src/reddit/actions/subredditSettings.ts"),
				V = n("./src/reddit/actions/tags/index.ts"),
				z = n("./node_modules/fbt/lib/FbtPublic.js"),
				K = n("./src/reddit/actions/toaster.ts"),
				Q = n("./src/reddit/actions/trafficStats/constants.ts"),
				J = n("./src/lib/makeGqlRequest/index.ts"),
				Y = n("./src/redditGQL/operations/FetchSubredditTrafficStats.json");
			var X = n("./node_modules/lodash/forEach.js"),
				Z = n.n(X),
				$ = n("./src/reddit/helpers/graphql/helpers.ts"),
				ee = n("./src/reddit/models/TrafficStats/index.ts");
			const te = e => ({
					desktop: new Array(e).fill(0),
					oldReddit: new Array(e).fill(0),
					mWeb: new Array(e).fill(0),
					apps: new Array(e).fill(0),
					total: new Array(e).fill(0)
				}),
				ne = (e, t) => {
					return Object($.g)(e.startsAt) > Object($.g)(t.startsAt) ? 1 : -1
				},
				se = (e, t, n) => {
					const s = {
							pageViews: te(t),
							uniqueUsers: te(t)
						},
						r = Object($.g)(e[0].startsAt);
					return e.map(e => {
						const o = Object($.g)(e.startsAt),
							a = new Date(o),
							i = t === ee.c ? a.getMonth() : Math.round((o - r) / n) % t,
							d = ee.d[e.client];
						s.pageViews[d][i] += e.pageViews, s.uniqueUsers[d][i] += e.uniqueUsers
					}), s
				};
			var re = n("./src/reddit/models/Toast/index.ts");
			const oe = Object(O.a)(Q.b),
				ae = Object(O.a)(Q.c),
				ie = Object(O.a)(Q.a),
				de = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const a = Object(j.U)(n(), {
						subredditId: e
					}).name;
					t(ae({
						subredditId: e
					}));
					const i = await ((e, t) => Object(J.a)(e, {
						...Y,
						variables: t
					}))(r(), {
						subredditName: a
					});
					if (i.ok) {
						const n = i.body.data.subreddit.moderation;
						if (n && n.trafficStats) {
							const s = (e => {
								const t = Z()(e, (e, t) => e.sort(ne)),
									n = t.subscriptionData,
									s = n.map(e => e.subscribers),
									r = n.map(e => e.unsubscribers),
									a = se(t.hourStats, ee.b, o.Q),
									i = se(t.dayStats, ee.a, o.B),
									d = se(t.monthStats, ee.c, o.pb);
								return {
									pageViews: {
										byHour: a.pageViews,
										byDay: i.pageViews,
										byMonth: d.pageViews
									},
									uniqueUsers: {
										byHour: a.uniqueUsers,
										byDay: i.uniqueUsers,
										byMonth: d.uniqueUsers
									},
									subscribers: s,
									unsubscribers: r
								}
							})(n.trafficStats);
							t(oe({
								subredditId: e,
								trafficStats: s
							}))
						}
					} else t(ie({
						subredditId: e
					})), t(K.f({
						id: "error-block-trafficStats",
						kind: re.b.Error,
						text: z.fbt._("Try again later", null, {
							hk: "41Goel"
						})
					}))
				};
			var ce = n("./src/reddit/models/ModQueue/index.ts"),
				le = n("./src/reddit/models/ScheduledPost/index.ts"),
				ue = n("./src/reddit/reducers/pages/modHub/index.ts"),
				me = n("./src/reddit/selectors/experiments/econ/index.ts"),
				pe = n("./src/reddit/selectors/moderatorPermissions.ts"),
				be = n("./src/reddit/selectors/modQueue.ts"),
				he = n("./src/reddit/selectors/platform.ts"),
				fe = n("./src/reddit/selectors/postCreations.ts"),
				ge = n("./src/reddit/selectors/profile.ts"),
				_e = n("./src/reddit/selectors/streamingModSettings.ts"),
				ve = n("./src/reddit/selectors/user.ts");
			Object(a.a)({
				pages: {
					modHub: ue.a
				}
			});
			const Oe = e => async (t, n, a) => {
				const {
					params: O
				} = e, {
					pageName: x,
					profileName: E,
					subredditName: y
				} = O;
				if (x === o.gc.Wiki) {
					if (await t(Object(N.handleWikiRedirects)(e))) return
				}
				if (x === o.gc.SubredditContent) return void t(Object(s.c)(le.s));
				const C = e.queryParams,
					k = C.page || ce.b,
					z = n();
				if (y) {
					const e = Object(i.a)(y, o.W.HOT),
						n = z.listings.postOrder.ids[e],
						s = z.listings.postOrder.api.error[e],
						r = z.listings.postOrder.api.pending[e];
					if (s) return;
					r || n && !s || await t(Object(T.subredditDataRequested)(e, y, {}))
				} else E && await t(Object(R.e)(E));
				if (!Object(ve.Q)(n()) && x !== o.gc.SubredditRules && x !== o.gc.Contributors) return void Object(u.a)(t, n());
				if (Object(p.i)(n(), !0, y, E), !x) return;
				let K, Q, J, Y, X, Z, $, ee, te, ne, se = !1;
				switch (x) {
					case o.gc.Awards:
						K = g.i;
						break;
					case o.gc.Powerups:
						K = _.j;
						break;
					case o.gc.Muted:
						K = W.b;
						break;
					case o.gc.Contributors:
						K = B.b;
						break;
					case o.gc.Banned:
						K = H.c;
						break;
					case o.gc.Moderators:
						J = !0;
						break;
					case o.gc.Removal:
						K = A.removalReasonsRequested;
						break;
					case o.gc.ContentControls:
						K = b.a, Z = !0;
						break;
					case o.gc.ChatSettings:
						se = !0;
						break;
					case o.gc.CommunitySettings:
						K = q.h, $ = !0;
						break;
					case o.gc.Flair:
						K = v.c, X = !0;
						break;
					case o.gc.UserFlair:
					case o.gc.PostFlair:
						K = void 0;
						break;
					case o.gc.Emojis:
						K = h.k;
						break;
					case o.gc.Badges:
					case o.gc.Emotes:
					case o.gc.SubredditRules:
						K = void 0;
						break;
					case o.gc.Traffic:
						K = de;
						break;
					case o.gc.Modlog:
						K = I, Y = !0;
						break;
					case o.gc.Streaming:
						K = M.g;
						break;
					case o.gc.Modqueue:
					case o.gc.Reports:
					case o.gc.Spam:
					case o.gc.Edited:
					case o.gc.Unmoderated:
						Q = x;
						break;
					case o.gc.Wiki:
					case o.gc.WikiContributors:
					case o.gc.WikiBanned:
						await t(Object(N.subredditWikDataRequested)(O, C, !0));
						break;
					case o.gc.ScheduledPostContent:
						ee = !0, K = d.i;
						break;
					case o.gc.EventPostContent:
						te = !0;
						break;
					case o.gc.Predictions:
						break;
					case o.gc.TalkHosts:
						ne = !0;
						break;
					default:
						return Object(r.a)(x)
				}
				const re = n(),
					oe = !!y && Object(fe.jb)(re),
					ae = Object(ve.N)(re),
					ie = y ? Object(j.X)(re, {
						subredditName: y.toLowerCase()
					}) : Object(ge.q)(re, {
						profileName: E.toLowerCase()
					}),
					ue = y && Object(j.F)(re, y),
					Oe = E && Object(ge.m)(re, E),
					xe = ue || Oe;
				ue && !Object(_e.b)(z, ue) && await t(Object(M.g)(ue));
				const Ee = !!ue && Object(_e.c)(re, ue),
					ye = Object(me.s)(z),
					je = Object(pe.n)(re, {
						subredditId: xe
					}),
					Ce = y && Object(j.w)(re, {
						subredditName: y
					}),
					ke = !(!Ce || !Ce.userIsContributor),
					Ie = Object(j.Z)(re, {
						subredditId: xe
					});
				if (Object(c.a)({
						canCreateScheduledPosts: oe,
						isContributor: ke,
						isEmployee: ae,
						isStreamingEnabled: Ee,
						isTalkHostsEnabled: ye,
						moderatorPermissions: je,
						pageName: x,
						subredditType: Ie
					})) {
					if (Q && y) {
						const e = Object(l.a)({
								onlyOfType: C.only,
								sort: C.sort,
								subreddit: y
							}),
							s = !!Object(be.d)(z, {
								pageName: Q,
								page: `${k}`,
								subredditName: y,
								queryParams: C
							}),
							r = z.pages.modHub.modQueue[Q].api.error;
						if (Object(be.c)(z, {
								pageName: Q
							}) || s && !r) return;
						if (!Object(he.p)(z)) {
							const s = Object(S.e)(e, Q, {
								...C,
								subreddit: y
							});
							await s(t, n, a)
						}
					} else if (J && ue) {
						if (await Object(U.g)(ue, C)(t, n, a), z.moderatingSubreddits[ue]) {
							await Object(U.e)(ue, C)(t, n, a), z.pages.modHub.moderators.invitedModerators.userOrder[ue] || await Object(U.f)(ue)(t, n, a)
						}
					} else ne && ue ? await Object(G.b)({
						subredditId: ue
					})(t, n, a) : Z && y ? await K(y)(t, n, a) : se && ue ? await Object(w.e)(ue)(t, n, a) : $ && ue ? await Promise.all([K(y, ue)(t, n, a), Object(V.g)(ue, m.a.communitySettings)(t, n, a), Object(L.b)(ue)(t, n, a), Object(F.d)(ue)(t, n, a)]) : Y || X ? await K(y, C)(t, n, a) : ee && ue ? await Object(d.i)({
						subredditId: ue
					})(t, n, a) : te && y ? await Object(f.eventPostsRequested)(y)(t, n, a) : K && await K(xe, C)(t, n, a);
					y && ue && !z.subreddits.rules[ue] && await D.o(y)(t, n, a), t(P.m({
						title: ie
					}))
				}
			}
		},
		"./src/reddit/actions/pages/multireddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__MULTIREDDIT_FEED_PENDING",
				r = "PAGE__MULTIREDDIT_FEED_LOADED",
				o = "PAGE__MULTIREDDIT_FEED_FAILED"
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return A
			})), n.d(t, "PAGE_LOADED", (function() {
				return M
			})), n.d(t, "PAGE_FAILED", (function() {
				return D
			})), n.d(t, "pagePending", (function() {
				return L
			})), n.d(t, "pageLoaded", (function() {
				return F
			})), n.d(t, "pageFailed", (function() {
				return U
			})), n.d(t, "postCreationPageDataRequested", (function() {
				return G
			})), n.d(t, "postCreationPageRequested", (function() {
				return H
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/filterQueryParams/index.ts"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makePostCreationPageKey/index.ts"),
				d = n("./src/lib/pageTitle/index.ts"),
				c = n("./src/reddit/actions/contentControls/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/externalAccount.ts"),
				m = n("./src/reddit/actions/gold/powerups.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/actions/postCreation/general.ts"),
				f = n("./src/reddit/actions/profile/index.ts"),
				g = n("./src/reddit/actions/subreddit.ts"),
				_ = n("./src/reddit/actions/subredditDuplicates.ts"),
				v = n("./src/config.ts"),
				O = n("./src/lib/constants/index.ts"),
				x = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				y = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				j = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				C = n("./src/reddit/models/User/index.ts"),
				k = n("./src/reddit/selectors/contentControls.ts"),
				I = n("./src/reddit/selectors/postCollection.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				w = n("./src/reddit/selectors/posts.ts"),
				T = n("./src/reddit/selectors/profile.ts"),
				N = n("./src/reddit/selectors/subreddit.ts"),
				P = n("./src/reddit/selectors/user.ts");
			const R = e => {
					const t = e.platform.currentPage;
					let n = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: s
						} = t.urlParams, r = Object(N.z)(e, {
							subredditName: s
						});
						r && (n = r.name)
					}
					return Object(d.m)(n)
				},
				A = "POST_CREATION__PAGE_PENDING",
				M = "POST_CREATION__PAGE_LOADED",
				D = "POST_CREATION__PAGE_FAILED",
				L = Object(a.a)(A),
				F = Object(a.a)(M),
				U = Object(a.a)(D),
				B = () => async (e, t) => {
					const n = t(),
						s = Object(S.a)(n);
					s !== Object(S.mb)(n) && e(Object(h.g)({
						submissionType: s
					}))
				}, G = e => async (t, n, s) => {
					const {
						collectionId: r,
						profileName: a,
						subredditName: d
					} = e, l = Object(i.a)(e), p = n(), b = p.creations.api.page.pending[l], h = p.creations.api.page.fetched[l], _ = p.creations.api.page.error[l];
					if (b) return;
					if (h && !_) return void t(B());
					const y = [];
					t(L({
						key: l
					}));
					let I = d;
					!d && a && (I = `u_${a}`), y.push(((e, t) => Object(x.a)(e, {
						method: O.jb.GET,
						endpoint: Object(E.a)(`${v.a.gatewayUrl}/desktopapi/v1/submitpage`),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(s.apiContext(), {
						subredditName: I,
						collectionId: r
					})), a && (y.push(t(f.d(a))), y.push(t(f.b(a))));
					const [S] = await Object(j.a)("postCreation", () => Promise.all(y));
					if (S.ok) {
						const e = S.body,
							{
								posts: s = {},
								subredditAboutInfo: r
							} = e;
						if (t(F({
								key: l,
								meta: p.meta,
								...e,
								posts: s
							})), !Object(P.Q)(n())) return;
						if (r) {
							const e = Object.keys(r)[0];
							await t(Object(m.j)(e, {
								fullData: !0,
								includeIdentity: !1
							}))
						}
						t(B());
						const a = [];
						a.push(t(u.o()));
						const i = Object(P.k)(n());
						if (i && i.hasUserProfile && a.push(t(f.d(Object(C.e)(i)))), d && !Object(o.a)(d)) {
							a.push(t(g.o(d))), !!Object(k.b)(n(), {
								subredditName: d
							}) || a.push(t(Object(c.a)(d)))
						}
						await Promise.all(a)
					} else t(U({
						error: S.error,
						key: l
					}))
				}, H = e => async (t, n) => {
					const {
						subredditName: o,
						profileName: a
					} = e.params, i = e.queryParams, d = i.collection;
					if (await t(G({
							collectionId: d,
							profileName: a,
							subredditName: o
						})), !Object(P.Q)(n())) return void Object(y.a)(t, n());
					let c;
					if (o ? (c = Object(N.z)(n(), {
							subredditName: o
						}), await t(Object(l.a)({
							subredditName: o
						}))) : a && (c = Object(T.j)(n(), {
							profileName: a
						})), i.source_id) await t(((e, t) => async (n, s) => {
						const {
							subredditName: r,
							profileName: o
						} = e, a = [];
						let i;
						r ? i = Object(N.F)(s(), r) : o && (i = Object(P.mb)(s(), {
							userName: o
						})), i && a.push(n(Object(_.b)(i, t))), a.push(n(Object(b.R)(t))), await Promise.all(a);
						const d = Object(w.f)(s(), {
							postId: t
						});
						n(Object(h.m)({
							postId: t,
							postTitle: d ? d.title : ""
						}))
					})(e.params, i.source_id));
					else if (d) {
						const o = Object(I.q)(n(), {
							collectionId: d
						});
						c && o && o.subredditId === c.id || t(Object(s.c)(Object(r.a)(e.url, ["collection"])))
					}
					t(p.m({
						title: R(n())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return p
			})), n.d(t, "PAGE_LOADED", (function() {
				return b
			})), n.d(t, "PAGE_FAILED", (function() {
				return h
			})), n.d(t, "pagePending", (function() {
				return f
			})), n.d(t, "pageLoaded", (function() {
				return g
			})), n.d(t, "pageFailed", (function() {
				return _
			})), n.d(t, "postDraftPageDataRequested", (function() {
				return v
			})), n.d(t, "postDraftRequested", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				a = n("./src/config.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				m = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_PENDING",
				b = "POST_DRAFT__PAGE_LOADED",
				h = "POST_DRAFT__PAGE_FAILED",
				f = Object(s.a)(p),
				g = Object(s.a)(b),
				_ = Object(s.a)(h),
				v = e => async (t, n, s) => {
					const {
						draftId: p,
						profileName: b
					} = e, h = Object(r.a)(e), f = n(), v = f.creations.api.page.pending[h], O = f.creations.api.page.fetched[h], x = f.creations.api.page.error[h];
					if (v || O && !x || !p) return;
					t(o.d(b));
					const E = await Object(m.a)("postDraft", () => ((e, t, n) => Object(d.a)(e, {
						endpoint: Object(c.a)(Object(l.a)(`${a.a.gatewayUrl}/desktopapi/v1/draftpreviewpage/${n}/${t}`)),
						method: i.jb.GET
					}))(s.apiContext(), p, b));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(u.b)(e.drafts[p].kind), t(g({
							...e,
							key: h
						}))
					} else t(_({
						error: E.error,
						key: h
					}))
				}, O = e => async (t, n, s) => {
					await t(v(e.params))
				}
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PROFILE_POSTS_PENDING", (function() {
				return N
			})), n.d(t, "PROFILE_POSTS_LOADED", (function() {
				return P
			})), n.d(t, "PROFILE_POSTS_FAILED", (function() {
				return R
			})), n.d(t, "profilePostsPending", (function() {
				return A
			})), n.d(t, "profilePostsLoaded", (function() {
				return M
			})), n.d(t, "profilePostsFailed", (function() {
				return D
			})), n.d(t, "profilePostsRequested", (function() {
				return L
			})), n.d(t, "MORE_POSTS_PENDING", (function() {
				return F
			})), n.d(t, "MORE_POSTS_LOADED", (function() {
				return U
			})), n.d(t, "MORE_POSTS_FAILED", (function() {
				return B
			})), n.d(t, "morePostsPending", (function() {
				return G
			})), n.d(t, "morePostsLoaded", (function() {
				return H
			})), n.d(t, "morePostsFailed", (function() {
				return W
			})), n.d(t, "morePostsRequested", (function() {
				return q
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				i = n("./src/lib/safeGet/index.ts"),
				d = n("./src/reddit/actions/contentGate.ts"),
				c = n("./src/reddit/actions/externalAccount.ts"),
				l = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/pages/profileShared.ts"),
				m = n("./src/reddit/actions/pinnedPost.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/profile/index.ts"),
				h = n("./src/reddit/actions/subreddit.ts"),
				f = n("./src/reddit/constants/errors.ts"),
				g = n("./src/reddit/constants/parameters.ts"),
				_ = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/config.ts"),
				O = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				x = n("./src/lib/constants/index.ts"),
				E = n("./src/lib/makeApiRequest/index.ts"),
				y = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				j = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const C = (e, t, n) => Object(E.a)(e, {
				data: n,
				endpoint: Object(y.a)(Object(O.a)(Object(j.a)(`${v.a.gatewayUrl}/desktopapi/v1/user/${t}/posts`))),
				method: x.jb.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? {
				...e,
				body: {
					...e.body,
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				}
			} : e);
			var k = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				I = n("./src/reddit/helpers/post/index.ts"),
				S = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				w = n("./src/reddit/selectors/listings.ts"),
				T = n("./src/reddit/selectors/profile.ts");
			const N = "PAGE__PROFILE_POSTS_PENDING",
				P = "PAGE__PROFILE_POSTS_LOADED",
				R = "PAGE__PROFILE_POSTS_FAILED",
				A = Object(o.a)(N),
				M = Object(o.a)(P),
				D = Object(o.a)(R),
				L = e => async (t, n, s) => {
					const {
						queryParams: o,
						params: v
					} = e, {
						sort: O,
						t: x
					} = Object(u.b)(o), {
						profileName: E
					} = v, y = Object(a.a)(`u_${E}`, O, o), j = n(), N = Object(i.a)(j.listings.postOrder.ids, y), P = Object(w.c)(j, {
						listingKey: y
					}), R = Object(w.d)(j, {
						listingKey: y
					});
					if (await t(b.d(E)), R || N && !P) {
						if (N) {
							const e = Object(T.q)(n(), {
								profileName: E
							});
							t(p.m({
								title: e
							}))
						}
						return
					}
					const L = {
						...r()(e.queryParams, [...g.k, ...g.j, g.g]),
						layout: Object(_.S)(j, {}).toLowerCase(),
						sort: O,
						t: Object(k.a)(O, x)
					};
					t(A({
						key: y
					}));
					const F = await Object(S.a)("profilePosts", () => C(s.apiContext(), E, L));
					if (!F.ok) return t(D({
						account: F.body.data ? F.body.data.account : null,
						error: F.body.reason ? {
							type: F.body.reason
						} : F.error,
						key: y
					})), F.body.reason === f.a.DeletedProfile && t(Object(d.s)({
						profileName: E
					})), void t(p.n(F.status));
					const U = F.body;
					await Object(I.a)(s.gqlContext, U.posts).then(e => U.posts = e), t(M({
						key: y,
						meta: n().meta,
						...U
					}));
					const B = Object(T.m)(n(), E),
						{
							pinned: G
						} = U;
					t(Object(m.h)({
						profileId: B,
						pinned: G
					})), await Promise.all([t(Object(u.c)(E)), t(Object(h.q)()), t(Object(l.b)()), t(c.o(E))])
				}, F = "PROFILE_POSTS__MORE_POSTS_PENDING", U = "PROFILE_POSTS__MORE_POSTS_LOADED", B = "PROFILE_POSTS__MORE_POSTS_FAILED", G = Object(o.a)(F), H = Object(o.a)(U), W = Object(o.a)(B), q = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: o
					} = n;
					const i = t(),
						{
							currentPage: d
						} = i.platform;
					if (!d || !d.routeMatch) return;
					const {
						queryParams: c,
						params: l
					} = d.routeMatch.match, {
						sort: m,
						t: p
					} = Object(u.b)(c), {
						profileName: b
					} = l, h = Object(a.a)(`u_${b}`, m, c), f = Object(w.g)(i, {
						listingKey: h
					});
					if (!f) return;
					const v = Object(w.d)(i, {
							listingKey: h
						}),
						O = Object(w.e)(i, {
							listingKey: h,
							token: f.token
						});
					if (v || O) return;
					e(G({
						key: h,
						fetchedToken: f.token
					}));
					const x = {
							after: f.token,
							dist: f.dist,
							sort: m,
							t: p,
							...r()(c, g.k),
							layout: Object(_.S)(i, {}).toLowerCase()
						},
						E = await C(s(), b, x),
						y = E.body,
						j = i.listings.postOrder.ids[h],
						k = y.postIds || [];
					await Object(I.a)(o, y.posts).then(e => y.posts = e);
					const S = {
						...y,
						postIds: k.filter(e => !j || !j.includes(e))
					};
					E.ok ? (e(H({
						fetchedToken: f.token,
						key: h,
						meta: i.meta,
						...S
					})), await e(Object(u.c)(b))) : e(W({
						account: E.body.data ? E.body.data.account : null,
						error: E.error,
						fetchedToken: f.token,
						key: h
					}))
				}
		},
		"./src/reddit/actions/pages/shared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				r = n("./src/reddit/helpers/routeKey/index.ts"),
				o = n("./src/reddit/helpers/trackers/screenview.ts"),
				a = n("./src/telemetry/index.ts"),
				i = n("./src/telemetry/models/Timer.ts");
			const d = () => async (e, t) => {
				const n = t(),
					{
						currentPage: d
					} = n.platform;
				if (!d) return;
				const c = d.routeMatch,
					l = Object(s.a)(n),
					u = Object(r.b)(c, n, l);
				u && a.c.has(u) && Object(o.k)(c, n, i.TimerType.InApp, a.c.end(u))
			}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "isGQLSubredditPageExtra", (function() {
				return tt
			})), n.d(t, "handleSubredditPageApiError", (function() {
				return nt
			})), n.d(t, "SUBREDDIT_PENDING", (function() {
				return st
			})), n.d(t, "SUBREDDIT_LOADED", (function() {
				return rt
			})), n.d(t, "SUBREDDIT_FAILED", (function() {
				return ot
			})), n.d(t, "subredditPending", (function() {
				return at
			})), n.d(t, "subredditLoaded", (function() {
				return it
			})), n.d(t, "subredditFailed", (function() {
				return dt
			})), n.d(t, "subredditDataRequested", (function() {
				return ct
			})), n.d(t, "subredditDataFirstChunkRequested", (function() {
				return lt
			})), n.d(t, "makeSubredditPageKey", (function() {
				return mt
			})), n.d(t, "subredditRequested", (function() {
				return pt
			})), n.d(t, "SUBREDDIT_INVALIDATE_LISTING", (function() {
				return bt
			})), n.d(t, "subredditInvalidateListing", (function() {
				return ht
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./node_modules/lodash/find.js"),
				a = n.n(o),
				i = n("./node_modules/lodash/pick.js"),
				d = n.n(i),
				c = n("./node_modules/query-string/index.js"),
				l = n("./node_modules/react-router-redux/es/index.js"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/countrySites/index.ts"),
				p = n("./src/lib/isAdHocMultireddit/index.ts"),
				b = n("./src/lib/isFakeSubreddit/index.ts"),
				h = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/lib/makeListingKey/index.ts"),
				g = n("./src/lib/makeSearchKey/index.ts"),
				_ = n("./src/lib/pageTitle/index.ts"),
				v = n("./src/lib/pageTitle/helpers.ts"),
				O = n("./src/lib/performanceTimings/index.tsx"),
				x = n("./src/lib/safeGet/index.ts"),
				E = n("./src/reddit/actions/ads/index.ts"),
				y = n("./src/reddit/actions/communityFlairs/index.ts"),
				j = n("./src/reddit/actions/contentGate.ts"),
				C = n("./src/reddit/actions/discoveryUnit.ts"),
				k = n("./src/reddit/actions/economics/helpers/async.ts"),
				I = n("./src/reddit/actions/economics/predictions/index.ts"),
				S = n("./src/reddit/actions/externalAccount.ts"),
				w = n("./src/reddit/actions/gold/powerups.ts"),
				T = n("./src/reddit/actions/grantUserFlair/index.ts"),
				N = n("./src/reddit/actions/meta.ts"),
				P = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				R = n("./src/reddit/actions/nsfwBlocking/async.tsx"),
				A = n("./src/reddit/actions/onboarding/index.ts"),
				M = n("./src/reddit/actions/pages/search/index.ts"),
				D = n("./src/reddit/actions/platform.ts"),
				L = n("./src/reddit/actions/publicAccessNetwork/api.ts"),
				F = n("./src/reddit/actions/seo/linksModule.ts"),
				U = n("./src/reddit/actions/seo/topicLinks.ts"),
				B = n("./src/lib/makeGqlRequest/index.ts"),
				G = (n("./src/redditGQL/operations/SubredditInfo.json"), n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts")),
				H = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				W = (n("./src/reddit/selectors/seo/linksModule.ts"), n("./src/reddit/selectors/seo/topicLinks.ts"), n("./src/reddit/selectors/subreddit.ts")),
				q = n("./src/reddit/selectors/widgets.ts");
			const V = (e, t) => async (n, s) => {
				const r = s(),
					o = Object(W.U)(r, {
						subredditId: e
					}),
					a = Object(q.j)(r, {
						subredditId: e
					});
				o.isNSFW || (null == a ? void 0 : a.length) > 0 && a.some(e => "community-list" === e) || n(Object(F.e)({
					id: e,
					data: t
				}))
			}, z = (e, t) => async n => {
				t && n(Object(U.b)({
					id: e,
					data: t
				}))
			};
			var K = n("./src/reddit/actions/structuredStyles/index.ts"),
				Q = n("./src/reddit/actions/subreddit.ts"),
				J = n("./src/reddit/actions/toaster.ts"),
				Y = n("./src/reddit/helpers/localStorage/index.ts"),
				X = n("./src/reddit/models/Subreddit/index.ts"),
				Z = n("./src/reddit/models/Toast/index.ts"),
				$ = n("./src/reddit/routes/postCreation/constants.ts"),
				ee = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				te = n("./src/reddit/selectors/platform.ts"),
				ne = n("./src/reddit/selectors/user.ts");
			const se = () => async (e, t, n) => {
				const s = t(),
					r = Object(te.e)(s);
				if (!r || r.type !== X.f.Public) return;
				const o = r.name,
					a = Object(te.m)(s),
					i = Object(W.w)(s, {
						subredditName: o
					});
				if (!i) return;
				const {
					activity7Day: d
				} = i, c = !!d && d >= 51 && d <= 100, u = !o || Object(b.a)(o), m = a && a.urlParams.subredditName === o, p = Object(ne.Q)(s), h = Object(ee.c)(s, {
					subredditId: Object(W.F)(s, o)
				});
				if (u || m || Object(Y.D)() || !c || !p || h) return;
				const f = Object(q.d)(t(), {
					subredditName: o
				});
				if (!f || !f.currentlyViewingCount) return;
				const g = (24 * f.currentlyViewingCount * 7).toString(),
					_ = g[0].padEnd(g.length, "0");
				e(Object(J.f)({
					buttonAction: async () => e(Object(l.b)(`/r/${o}${$.b}`)),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: Z.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(Y.Fb)(),
					secondButtonText: "Dismiss",
					text: `There have been over ${_} visits to r/${o} in the past week. Create a new post and start the next conversation.`
				}))
			};
			var re = n("./src/reddit/actions/subreddit/questions.ts"),
				oe = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				ae = n("./src/reddit/actions/subredditSettings.ts"),
				ie = n("./src/reddit/actions/tags/index.ts"),
				de = n("./src/reddit/actions/userFlair/userFlair.ts"),
				ce = n("./src/reddit/constants/history.ts"),
				le = n("./src/reddit/constants/page.ts"),
				ue = n("./src/reddit/constants/parameters.ts"),
				me = n("./src/reddit/constants/postLayout.ts"),
				pe = n("./src/reddit/contexts/PageLayer/index.tsx"),
				be = n("./src/reddit/endpoints/gold/topAwarded.ts"),
				he = n("./src/reddit/endpoints/governance/posts.ts"),
				fe = n("./src/reddit/endpoints/page/subredditPage.ts"),
				ge = n("./src/lib/ads/session-signals.ts"),
				_e = n("./src/lib/base64/index.ts"),
				ve = n("./src/reddit/constants/experiments.ts"),
				Oe = n("./src/reddit/constants/graphql.ts"),
				xe = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				Ee = n("./src/reddit/selectors/experiments/onboarding.ts"),
				ye = n("./src/redditGQL/operations/SubredditPageExtra.json");
			var je = n("./src/reddit/endpoints/profile/info.ts"),
				Ce = n("./src/reddit/helpers/canonicalUrls.ts"),
				ke = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				Ie = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				Se = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts");

			function we(e) {
				let {
					econLeaderboards: t,
					identity: n,
					trendingSubreddits: s
				} = e;
				const r = t.topAwardedPosts.map(e => e.post).filter(e => !e.removedBy && !e.isNsfw);
				return Object(Se.b)(r, s, n)
			}
			var Te = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				Ne = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				Pe = n("./src/reddit/helpers/post/index.ts"),
				Re = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				Ae = n("./src/reddit/helpers/trackers/feed.ts"),
				Me = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				De = n("./src/reddit/models/RichTextJson/index.ts"),
				Le = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Fe = n("./src/reddit/selectors/communityFlairs.ts"),
				Ue = n("./src/reddit/selectors/experiments/countrySites.ts"),
				Be = n("./src/reddit/selectors/experiments/econ/powerupsAward.ts"),
				Ge = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				He = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				We = n("./src/reddit/selectors/experiments/topPosts.ts"),
				qe = n("./src/reddit/selectors/gold/powerups/index.ts"),
				Ve = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				ze = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Ke = n("./src/reddit/selectors/multireddit.ts"),
				Qe = n("./src/reddit/selectors/posts.ts"),
				Je = n("./src/lib/initializeClient/installReducer.ts"),
				Ye = n("./src/reddit/reducers/features/modUserNotes/index.ts"),
				Xe = n("./node_modules/uuid/v4.js"),
				Ze = n.n(Xe),
				$e = n("./src/reddit/helpers/locales.ts"),
				et = n("./src/reddit/selectors/meta.ts");

			function tt(e) {
				return Boolean(e && e.subredditInfoByName)
			}
			Object(Je.a)({
				features: {
					modUserNotes: Ye.a
				}
			});
			const nt = (e, t) => async n => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: s,
							reason: r
						}
					} = e, o = s ? s.account : void 0, a = s && s.features || void 0, i = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (r === X.e.NotFoundSubreddit) n(j.r({
							account: o,
							features: a,
							subredditName: i
						}));
						else if (r === X.e.BannedSubreddit) {
						const e = s ? s.banMessage || s.ban_message : void 0;
						n(j.p({
							banMessage: e,
							account: o,
							features: a,
							subredditName: i
						}))
					}
					if (451 === e.status && n(j.q({
							account: o,
							features: a,
							subredditName: i
						})), 403 === e.status)
						if (r === X.e.GoldSubreddit) n(j.u({
							account: o,
							features: a,
							subredditName: i
						}));
						else if (r === X.e.PrivateSubreddit) n(j.v({
						account: o,
						features: a,
						subredditDescription: s.description || "",
						subredditName: i,
						isContributorRequestsDisabled: !!s.isContributorRequestsDisabled,
						isContributorRequestTimestamp: s.isContributorRequestTimestamp ? parseInt(s.isContributorRequestTimestamp, 10) : void 0,
						subredditId: s.id
					}));
					else if (r === X.e.QuarantinedSubreddit) {
						const e = !s || void 0 === s.quarantineRequiresEmailOptin || s.quarantineRequiresEmailOptin;
						n(j.x({
							account: o,
							features: a,
							subredditName: i,
							quarantineRequiresEmail: e,
							quarantineMessage: s.quarantineMessage,
							quarantineMessageHtml: s.quarantineMessageHtml || "",
							quarantineMessageRTJson: s.quarantineMessageRTJson || De.i
						}))
					} else if (r === X.e.GatedSubreddit) {
						const {
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: r
						} = s;
						n(j.t({
							account: o,
							features: a,
							subredditName: i,
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: r
						}))
					}
				}
			}, st = "PAGE__SUBREDDIT_PENDING", rt = "PAGE__SUBREDDIT_LOADED", ot = "PAGE__SUBREDDIT_FAILED", at = Object(h.a)(st), it = Object(h.a)(rt), dt = Object(h.a)(ot), ct = (e, t, n, o) => async (i, d, c) => {
				var l, m, p, h, f, g, _, v, j, C, R, M, L, F, U, q, K, Y, X, $, ee, se, le, ue, Ce;
				const ke = d(),
					Ie = Object(ne.P)(ke) || Object(ne.Q)(ke);
				if (Object(x.a)(ke.listings.postOrder.api.pending, e)) return;
				const Se = null === (m = null === (l = Object(te.b)(ke)) || void 0 === l ? void 0 : l.routeMatch) || void 0 === m ? void 0 : m.route.chunk,
					{
						currentPage: Me
					} = ke.platform,
					{
						countryCode: De,
						languageCode: Fe
					} = (null == Me ? void 0 : Me.urlParams) || {},
					He = Object(b.a)(t, {
						countryCode: De,
						languageCode: Fe
					}),
					We = Object(b.c)(t, {
						countryCode: De,
						languageCode: Fe
					}),
					ze = (Object(b.b)(t, {
						countryCode: De,
						languageCode: Fe
					}) || We) && ke.posts.recent.length ? {
						...n,
						recentPostIds: ke.posts.recent
					} : n;
				ze.layout = me.e[Object(pe.S)(ke, {})], We && (ze.forceGeopopular = !0), i(at({
					key: e
				}));
				const Ke = !He && Object(te.l)(ke) && Object(Ge.b)(ke);
				let Qe;
				if (n.sort === u.W.AWARDED && We) Qe = Object(be.a)(c.gqlContext(), {
					top: 0,
					includeListingMetadata: !0
				}).then(e => {
					const t = e.body;
					return {
						...e,
						body: we(t.data)
					}
				});
				else {
					const e = Ke ? () => Object(fe.b)(c.gqlContext(), Object(fe.c)(ke, t, ze, !0), Ie) : () => Object(fe.a)(c.apiContext(), t, ze);
					Qe = Object(O.i)(e, {
						name: Ke ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: Se,
						isLoggedIn: Ie
					})
				}
				const Je = Object(W.T)(d(), {
						subredditId: Object(W.F)(d(), t)
					}).length > 0,
					Ye = Object(O.i)(() => (async function(e, t) {
						return Object(B.a)(e, {
							...ye,
							variables: t
						})
					})(c.gqlContext(), ((e, t) => {
						let {
							after: n,
							isMobile: s,
							subredditName: r,
							isFake: o,
							isLoggedIn: a,
							layout: i,
							limit: d,
							hasRules: c,
							sort: l,
							t: u
						} = t;
						var m, p;
						const b = Object(Ee.c)(e),
							h = !!b && !Object(ve.Tf)(b) && (o || b === ve.ub.Community),
							{
								numberOfAdsSeen: f,
								numberOfPostsSeen: g
							} = Object(ge.a)(),
							_ = {
								subredditName: r,
								isFake: o,
								sort: l,
								adContext: {
									layout: i ? i.toUpperCase() : Oe.a.Card,
									reddaid: e.user.reddaid,
									clientSignalSessionData: {
										adsSeenCount: f,
										totalPostsSeenCount: g
									}
								},
								includeIdentity: a,
								includeInterestTopics: h,
								includePowerups: !o,
								includeQuestions: a && !o,
								includeRules: !o && !c,
								includeRedditorKarma: a && !(null === (p = null === (m = e.user.account) || void 0 === m ? void 0 : m.karma) || void 0 === p ? void 0 : p.total),
								includeSubredditLinks: !a,
								includeTopicLinks: !a
							};
						return l && (_.sort = l.toUpperCase()), u && (_.range = u.toUpperCase()), s ? _.pageSize = Object(xe.a)(i) : d && (_.pageSize = d), n && (_.after = Object(_e.a)(n)), _
					})(ke, {
						after: n.after,
						isLoggedIn: Ie,
						subredditName: t,
						hasRules: Je,
						isFake: He,
						isMobile: n.isMobile,
						layout: n.layout,
						limit: n.limit,
						sort: n.sort,
						t: n.t
					})), {
						name: "fetchSubredditPageExtra",
						page: Se,
						isLoggedIn: Ie
					}),
					Xe = Ze()();
				let st, rt;
				Ke ? st = await Qe : [st, rt] = await Promise.all([Qe, Ye]);
				const ot = rt && Object(r.c)(rt) ? rt.body.data : null,
					lt = st.body,
					ut = (null == lt ? void 0 : lt.subreddits) ? ((e, t) => {
						var n;
						return null === (n = a()(e, e => (null == e ? void 0 : e.name.toLowerCase()) === t.toLowerCase())) || void 0 === n ? void 0 : n.id
					})(lt.subreddits, t) : null;
				lt && !Ke && await Object(Pe.a)(c.gqlContext, lt.posts).then(e => lt.posts = e), i(D.n(st.status));
				const mt = `error-${e}`,
					pt = He || ut;
				if (st.ok && pt) {
					if (!He && ut) {
						let e;
						e = Ke ? lt.powerups : Object(w.c)(null == ot ? void 0 : ot.subredditInfoByName, null == ot ? void 0 : ot.identity);
						const t = (null === (h = null === (p = null == lt ? void 0 : lt.subredditAboutInfo) || void 0 === p ? void 0 : p[ut]) || void 0 === h ? void 0 : h.detectedLanguage) || (null === (f = null == ot ? void 0 : ot.subredditInfoByName) || void 0 === f ? void 0 : f.detectedLanguage);
						Object(et.d)(ke) && t && Object(Ue.f)(ke) && await Object($e.a)(t, i), lt.subredditAboutInfo[ut].detectedLanguage = t, Object(w.a)(i, ut, e), Ke ? i(Object(I.n)(ut, lt.predictionTournaments || [])) : (null == ot ? void 0 : ot.subredditInfoByName) && i(Object(I.n)(ut, ot.subredditInfoByName.predictionTournaments || [])), Object(qe.f)(d(), {
							subredditId: ut
						}) && Object(Be.a)(d())
					}
					let s;
					lt.geoFilter && i(Object(N.k)(lt.geoFilter));
					const r = lt.postIds.filter(e => !!lt.posts[e].isMeta);
					if (r.length && ut) {
						const e = Object(O.i)(() => Object(he.a)(c.apiContext(), ut, r), {
								name: "getGovernanceData",
								page: Se,
								isLoggedIn: Ie
							}),
							t = await e;
						t.ok && (s = t.body)
					}
					if (ut) {
						const e = (null === (_ = null === (g = null == lt ? void 0 : lt.subredditAboutInfo) || void 0 === g ? void 0 : g[ut]) || void 0 === _ ? void 0 : _.isEligibleForContentBlocking) || (null === (v = null == ot ? void 0 : ot.subredditInfoByName) || void 0 === v ? void 0 : v.isEligibleForContentBlocking);
						lt.subredditAboutInfo[ut].isEligibleForContentBlocking = e;
						const t = (null === (C = null === (j = null == lt ? void 0 : lt.subredditAboutInfo) || void 0 === j ? void 0 : j[ut]) || void 0 === C ? void 0 : C.isMediaInCommentsSettingShown) || (null === (R = null == ot ? void 0 : ot.subredditInfoByName) || void 0 === R ? void 0 : R.isMediaInCommentsSettingShown);
						lt.subredditAboutInfo[ut].isMediaInCommentsSettingShown = t
					}
					if (ot) {
						const e = null === (L = null === (M = ot.identity) || void 0 === M ? void 0 : M.redditor) || void 0 === L ? void 0 : L.karma,
							t = {
								karma: {
									...(null === (F = ke.user.account) || void 0 === F ? void 0 : F.karma) || je.a,
									...e
								}
							};
						lt.account && Object.assign(lt.account, t)
					}
					if (ut) {
						let e;
						Ke ? e = null === (U = lt.subredditAboutInfo[ut]) || void 0 === U ? void 0 : U.notificationLevel : tt(ot) && (e = null === (q = ot.subredditInfoByName) || void 0 === q ? void 0 : q.notificationLevel), lt.subredditAboutInfo[ut].notificationLevel = e
					}
					const a = null === (K = lt.subredditPermissions) || void 0 === K ? void 0 : K.posts;
					!Ke && a && i(Object(P.a)({
						postIds: lt.postIds
					}));
					let l = null == lt ? void 0 : lt.interestTopicRecommendations;
					if (!l && (null == ot ? void 0 : ot.interestTopics)) {
						const e = Object(Te.a)(ot.interestTopics);
						e.topics.length && (l = {
							interests: e,
							index: 5
						})
					}
					l && i(Object(A.subredditInterestTopicsLoaded)({
						interestTopicRecommendations: l
					})), i(it({
						key: e,
						meta: ke.meta,
						governance: s,
						correlationId: Xe,
						...lt,
						postIds: lt.postIds
					}));
					const u = null === (X = null === (Y = Object(te.b)(ke)) || void 0 === Y ? void 0 : Y.locationState) || void 0 === X ? void 0 : X[ce.b.FeedLoadReason];
					if (Object(Ae.b)(n.isRefresh ? ce.a.UserRefresh : null != u ? u : ce.a.InitialLoad)(d()), !He) {
						const e = Object(W.F)(d(), t);
						Ke && lt.subredditRules ? i(Q.t({
							rules: {
								rules: lt.subredditRules
							},
							subredditId: e
						})) : (null === ($ = null == ot ? void 0 : ot.subreddit) || void 0 === $ ? void 0 : $.rules) && i(Q.t({
							rules: Object(Ne.a)(ot.subreddit.rules),
							subredditId: e
						}));
						const n = Object(y.c)(lt.posts, e),
							s = Object(y.b)(lt.structuredStyles),
							r = (s ? Object(y.d)(s) : []).concat(n);
						i(Object(y.a)(r, e))
					}
					if (o && i(J.g(mt)), i(Object(E.b)(Le.a.SUBREDDIT)), i(Object(S.p)()), ut) {
						let e, n, s;
						if (Ke ? (e = lt.questions, n = lt.subredditLinks, s = lt.subredditTopicLinks) : (e = null == ot ? void 0 : ot.subredditInfoByName, n = Object(G.a)({
								data: {
									subredditInfoById: null == ot ? void 0 : ot.subredditInfoByName
								}
							}), s = Object(H.a)({
								data: {
									subredditInfoById: null == ot ? void 0 : ot.subredditInfoByName
								}
							})), Object(re.a)(i, ut, e), i(V(ut, n)), i(z(ut, s)), !Ke && (null === (se = null === (ee = null == ot ? void 0 : ot.subredditInfoByName) || void 0 === ee ? void 0 : ee.elements) || void 0 === se ? void 0 : se.edges)) {
							const e = (null === (ue = null === (le = null == ot ? void 0 : ot.subredditInfoByName) || void 0 === le ? void 0 : le.elements) || void 0 === ue ? void 0 : ue.edges).map(e => {
								var t, n;
								return null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote
							});
							i(Object(oe.e)({
								subredditId: ut,
								nodes: e
							}))
						} else if (Ke && (null == lt ? void 0 : lt.postIds)) {
							const e = lt.postIds.map(e => null == lt ? void 0 : lt.posts[e].lastAuthorModNote);
							e && i(Object(oe.e)({
								subredditId: ut,
								nodes: e
							}))
						}
						if (Ke && lt.appliedFlair) {
							const e = lt.appliedFlair;
							if ((null === (Ce = ke.user.account) || void 0 === Ce ? void 0 : Ce.displayName) && e.flair && (i(Object(T.b)({
									subredditId: ut,
									applied: e.flair,
									userName: ke.user.account.displayName
								})), i(Object(de.userFlairSaveTemplateSuccess)({
									subredditId: ut,
									template: e.flair
								}))), e.displaySettings) {
								const t = e.displaySettings;
								i(Object(de.userFlairAllowAssignOwnSettingSuccess)({
									subredditId: ut,
									canAssignOwn: t.isSelfAssignable
								})), i(Object(de.userFlairMutated)({
									subredditId: ut,
									displaySettings: t
								}))
							}
						}
						const r = [Object(O.i)(() => i(Object(k.a)({
							subredditId: ut,
							postIds: lt.postIds,
							skip: ["subscription"]
						})), {
							name: "fetchAllEconomicsData",
							page: Se,
							isLoggedIn: Ie
						})];
						if (Object(Ve.a)(d(), {
								subredditId: ut
							})) {
							const e = Object(O.i)(() => i(Object(ae.h)(t, ut)), {
									name: "subredditSettingsRequested",
									isLoggedIn: Ie,
									page: Se
								}),
								n = Object(O.i)(() => i(Object(ie.g)(ut, Re.a.idCard)), {
									name: "subredditTagsRequested",
									isLoggedIn: Ie,
									page: Se
								});
							r.push(e, n)
						}
						await Promise.all(r)
					}
				} else {
					const r = st.ok ? void 0 : st.error;
					if (Object(Ae.a)(r ? `${st.status||"000"}: ${r.type}` : "000: UNKNOWN_ERROR")(d()), 403 === st.status || 404 === st.status || 451 === st.status) return void i(nt(st, t));
					i(dt({
						error: !st.ok && st.error || {
							type: u.I.NOT_FOUND_ERROR
						},
						key: e,
						...lt
					})), o && i(J.f({
						id: mt,
						kind: Z.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: ct(e, t, n, o)
					}))
				}
			}, lt = (e, t, n) => async (s, r) => {
				const o = r(),
					a = Object(f.a)(e, t.sort, t);
				Object(Qe.z)(o, {
					listingKey: a
				}).length > 0 || await s(ct(a, e, t, n))
			}, ut = (e, t, n, s) => {
				const r = Object(Ue.b)(e);
				if (Object(b.a)(t, {
						countryCode: n,
						languageCode: s
					})) {
					if (Object(p.a)(t)) {
						return Object(Ke.a)(e, {
							listingName: t
						}).displayText
					}
					if (r) return Object(v.a)(e, Object(_.f)(t.toLowerCase()));
					switch (t.toLowerCase()) {
						case le.d.Popular:
							return "r/popular";
						case le.d.All:
							return "r/all"
					}
				}
				const o = Object(W.X)(e, {
					subredditName: t
				});
				if (r) {
					const n = Object(W.w)(e, {
							subredditName: t
						}),
						s = n && n.detectedLanguage;
					return Object(v.a)(e, o, s)
				}
				return o
			}, mt = (e, t, n, s) => s ? Object(g.b)(e.subredditName, void 0, s) : Object(f.a)(e.subredditName, t, n), pt = (e, t) => async (n, s) => {
				var r, o, a;
				const {
					countryCode: i,
					languageCode: p
				} = e.params, h = Object(m.e)(e.params), {
					styling: _
				} = e.queryParams, v = s(), j = v.meta.popularGeoFilter, k = Object(ke.a)(e.params, v);
				if ("popular" === h.toLowerCase() && j && !e.queryParams.geo_filter) {
					const t = `r/popular?${Object(c.stringify)({...e.queryParams,geo_filter:j})}`;
					return void n(Object(l.c)(e.url.replace(/r\/popular/i, t)))
				}
				if ("Popular" === h) return void n(Object(l.c)(e.url.replace("r/Popular", "r/popular")));
				if ("All" === h) return void n(Object(l.c)(e.url.replace("r/All", "r/all")));
				const I = Object(g.d)(e.queryParams, Object(ne.kb)(v)),
					w = mt({
						subredditName: h,
						countryCode: i,
						languageCode: p
					}, k, e.queryParams, I),
					T = k,
					N = Object(x.a)(v.listings.postOrder.api.error, w),
					P = Object(x.a)(v.listings.postOrder.api.pending, w);
				let A = !!Object(x.a)(v.listings.postOrder.ids, w);
				const F = Object(x.a)(v.listings.postOrder.listingSort, w);
				F && F.hasChanged && (A = !1);
				let U = Object(W.F)(v, h);
				const B = (e, t) => "true" === _ && ((e, t) => Object(ze.b)(Me.c.config)(e, {
						subredditId: t
					}) || Object(ze.b)(Me.c.flair)(e, {
						subredditId: t
					}))(e, t),
					G = ue.C in e.queryParams && e.queryParams[ue.C].toUpperCase() || "",
					H = G in u.ic && u.ic[G];
				if (P || A && !N && !t) {
					if (B(v, U) && n(K.i(U)), A) {
						const t = ut(s(), h, i, p);
						n(D.m({
							title: t
						})), (null === (r = v.listings.postOrder.correlationIds) || void 0 === r ? void 0 : r[w]) && n(D.o({
							correlationId: v.listings.postOrder.correlationIds[w]
						})), Object(Ce.g)(s(), n, e), window.addEventListener("load", () => {
							n(Object(S.p)())
						}), v.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							n(Object(E.b)(Le.a.SUBREDDIT))
						}), n(se())
					}
					return void(Object(He.e)(s()) && n(Object(R.a)()))
				}
				n(C.g());
				const q = null === (a = null === (o = Object(te.b)(v)) || void 0 === o ? void 0 : o.routeMatch) || void 0 === a ? void 0 : a.route.chunk,
					V = Object(ne.Q)(s()),
					z = Object(O.i)(() => n(Object(L.c)(`r/${h}`)), {
						name: "rpanConfigRequested",
						isLoggedIn: V,
						page: q
					});
				if (I) {
					const e = Object(O.i)(() => n(Object(M.d)(w, I, h)), {
						name: "searchDataRequested",
						isLoggedIn: V,
						page: q
					});
					await e
				} else {
					const t = {
						...d()(e.queryParams, [...ue.k, ...ue.j, ue.g]),
						sort: T,
						t: Object(Ie.a)(T, H)
					};
					await n(ct(w, h, t, !0))
				}
				const Q = v.platform.currentPage,
					J = Object(We.d)(v, {
						pageLayer: Q
					});
				if (Object(We.a)(J) || Object(We.b)(J) || Object(We.c)(J)) {
					const e = Object(f.a)(h, u.W.TOP, {
							t: u.ic.WEEK
						}),
						t = {
							sort: u.W.TOP,
							t: u.ic.WEEK
						};
					await n(ct(e, h, t, !1))
				}
				if (Object(He.e)(s()) && n(Object(R.a)()), U = U || Object(W.F)(s(), h), !Object(Fe.a)(v, U) && !Object(b.a)(h, {
						countryCode: i,
						languageCode: p
					})) {
					const e = Object(O.i)(() => n(Object(y.e)(h)), {
						name: "getTopCommunityFlair",
						page: q,
						isLoggedIn: V
					});
					await e
				}
				B(s(), U) && n(K.i(U)), Object(Ce.g)(s(), n, e);
				const Y = ut(s(), h);
				n(D.m({
					title: Y
				})), n(se()), await z
			}, bt = "PAGE__SUBREDDIT_INVALIDATE_LISTING", ht = Object(h.a)(bt)
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				r = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				o = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/subredditWiki/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "subredditWikiDataPending", (function() {
				return qe
			})), n.d(t, "subredditWikiDataLoaded", (function() {
				return Ve
			})), n.d(t, "subredditWikiDataFailed", (function() {
				return ze
			})), n.d(t, "fetchSubredditWikiData", (function() {
				return Je
			})), n.d(t, "handleWikiRedirects", (function() {
				return Xe
			})), n.d(t, "subredditWikDataRequested", (function() {
				return Ze
			})), n.d(t, "subredditWikiPageRequested", (function() {
				return $e
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/isEmpty.js"),
				o = n.n(r),
				a = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/config.ts"),
				u = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/helpers/path/index.ts");
			var p = n("./src/reddit/actions/ads/index.ts"),
				b = n("./src/reddit/actions/pages/subreddit.ts"),
				h = n("./src/reddit/actions/pages/subredditWiki/constants.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				_ = n("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				v = n("./src/lib/makeGqlRequest/index.ts"),
				O = n("./src/reddit/helpers/wiki/wikiRevision.ts"),
				x = n("./src/redditGQL/operations/WikiComparisonDiff.json");
			var E = n("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				y = n("./src/reddit/selectors/subredditWiki.ts");
			const j = Object(d.a)("WIKI_DIFF_PENDING"),
				C = Object(d.a)("WIKI_DIFF_LOADED"),
				k = Object(d.a)("WIKI_DIFF_FAILED"),
				I = e => async (t, n, s) => {
					const r = n(),
						o = Object(E.a)(e),
						a = Object(y.i)(r, {
							key: o
						});
					if (a && (a.pending || !a.error)) return !0;
					const d = {
						key: o
					};
					t(j(d));
					const c = await ((e, t) => Object(v.a)(e, {
						...x,
						variables: {
							...t,
							comparisonRevisionId: Object(O.b)(t.comparisonRevisionId),
							revisionId: Object(O.b)(t.revisionId)
						}
					}))(s.gqlContext(), e);
					let l = null,
						u = "";
					if (c.ok) {
						const e = c.body,
							t = e.data.subreddit && e.data.subreddit.wiki,
							n = t && t.page && t.page.revisionComparisonDiffHtml;
						n ? u = n : l = {
							type: i.I.NOT_FOUND_ERROR
						}
					} else l = c.error || {
						type: i.I.UNKNOWN_ERROR
					};
					return t(l ? k({
						...d,
						error: l
					}) : C({
						...d,
						htmlDiff: u
					})), !l
				};
			var S = n("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				w = n("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				T = n("./src/reddit/constants/parameters.ts"),
				N = n("./src/reddit/constants/wiki.ts"),
				P = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				R = n("./src/reddit/helpers/brandSafety/index.ts"),
				A = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				M = n("./src/reddit/models/Toast/index.ts"),
				D = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				L = n("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				F = n("./src/reddit/selectors/subreddit.ts"),
				U = n("./src/lib/initializeClient/installReducer.ts"),
				B = n("./node_modules/redux/es/redux.js");
			const G = {};
			var H = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "WIKI_DIFF_LOADED": {
						const {
							key: n,
							htmlDiff: s
						} = t.payload;
						return {
							...e,
							[n]: {
								htmlDiff: s
							}
						}
					}
					case "WIKI_DIFF_PENDING": {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !0
							}
						}
					}
					case "WIKI_DIFF_FAILED": {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !1,
								error: s
							}
						}
					}
					default:
						return e
				}
			};
			const W = {};
			var q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : W,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case h.b:
							const n = t.payload,
								{
									subredditWiki: s,
									options: r
								} = n,
								o = s && s.directory;
							if (!o) return e;
							const {
								subredditName: a
							} = r;
							return {
								...e, [a.toLowerCase()]: o
							};
						default:
							return e
					}
				},
				V = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const z = {};
			var K = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case h.b: {
							const {
								subredditWiki: n,
								pageKey: s
							} = t.payload, {
								page: r
							} = n;
							return s && r ? {
								...e,
								[s]: r
							} : e
						}
						case V.a: {
							const {
								pageKey: n,
								page: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Q = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const J = {};
			var Y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : J,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Q.c: {
							const {
								settings: n,
								pageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: n
							} : e
						}
						case Q.d: {
							const {
								isVisible: n,
								editPermissions: s,
								pageKey: r
							} = t.payload, o = e[r];
							return o ? {
								...e,
								[r]: {
									...o,
									isVisible: n,
									editPermissions: s
								}
							} : e
						}
						case Q.b: {
							const {
								editorsInfo: n,
								afterToken: s,
								pageKey: r
							} = t.payload, o = e[r];
							if (!o) return e;
							const a = [...o.editorsInfo, ...n];
							return {
								...e,
								[r]: {
									...o,
									editorsInfo: a,
									afterToken: s
								}
							}
						}
						case Q.a: {
							const {
								username: n,
								pageKey: s
							} = t.payload, r = e[s];
							if (!r) return e;
							const o = r.editorsInfo.filter(e => e.username !== n);
							return {
								...e,
								[s]: {
									...r,
									editorsInfo: o
								}
							}
						}
						default:
							return e
					}
				},
				X = n("./src/lib/omitKey/index.ts");
			const Z = {};
			var $ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case V.b: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case V.d:
					case V.c: {
						const {
							key: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const ee = {};
			var te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ee,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case V.d:
						case V.b:
						case V.c: {
							const {
								key: n
							} = t.payload, s = t.type === V.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				ne = Object(B.c)({
					error: $,
					pending: te
				}),
				se = n("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const re = {};
			var oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : re,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case V.c: {
						const {
							key: n,
							options: s,
							pageInfo: r,
							revisionsIds: o
						} = t.payload, a = e[n], i = s.after && a ? [...a.ids, ...o] : o;
						return {
							...e,
							[n]: {
								ids: i,
								pageInfo: r
							}
						}
					}
					case V.a: {
						const {
							page: {
								revision: n
							},
							pageRevisionsListingKey: s,
							recentRevisionsListingKey: r
						} = t.payload, o = e[s];
						return o && n ? {
							...Object(X.a)(e, r),
							[s]: {
								...o,
								ids: [n.id, ...o.ids]
							}
						} : e
					}
					case se.a: {
						const {
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: s
						} = t.payload, r = {
							...e
						};
						return delete r[n], delete r[s], r
					}
					default:
						return e
				}
			};
			const ae = {};
			var ie = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ae,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case h.b: {
							const {
								subredditWiki: {
									page: n
								}
							} = t.payload, s = n && n.revision;
							return s && !e[s.id] ? {
								...e,
								[s.id]: s
							} : e
						}
						case V.c: {
							const {
								revisions: n
							} = t.payload;
							return {
								...e,
								...n
							}
						}
						case V.a: {
							const {
								page: n
							} = t.payload, s = n.revision;
							return s ? {
								...e,
								[s.id]: s
							} : e
						}
						case V.e: {
							const {
								revisionId: n,
								isHidden: s
							} = t.payload, r = e[n];
							return r ? {
								...e,
								[n]: {
									...r,
									isHidden: s
								}
							} : e
						}
						default:
							return e
					}
				},
				de = Object(B.c)({
					api: ne,
					listings: oe,
					models: ie
				}),
				ce = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const le = {};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : le,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case ce.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case ce.d:
					case ce.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const be = {};
			var he = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : be,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.d:
						case ce.c:
						case ce.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === ce.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				fe = Object(B.c)({
					error: pe,
					pending: he
				});
			const ge = {};
			var _e = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ge,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								bannedContributors: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload, r = Object(X.a)(e[n], s);
							return {
								...e,
								[n]: r
							}
						}
						default:
							return e
					}
				},
				ve = n("./node_modules/lodash/uniq.js"),
				Oe = n.n(ve);
			const xe = {};
			var Ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Oe()([...e[n] || [], ...s])
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Oe()([...s, ...e[n] || []])
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				ye = Object(B.c)({
					afterToken: ue,
					api: fe,
					models: _e,
					userOrder: Ee
				});
			const je = {};
			var Ce = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : je,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.g: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				ke = Object(B.c)({
					listing: ye,
					search: Ce
				}),
				Ie = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const Se = {};
			var we = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.c:
					case Ie.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const Te = {};
			var Ne = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Te,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case Ie.d:
					case Ie.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const Pe = {};
			var Re = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.d:
						case Ie.c:
						case Ie.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === Ie.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Ae = Object(B.c)({
					error: Ne,
					pending: Re
				});
			const Me = {};
			var De = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.c:
					case Ie.a: {
						const {
							subredditName: n,
							contributors: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case Ie.e: {
						const {
							subredditName: n,
							contributor: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case Ie.f: {
						const {
							subredditName: n,
							userId: s
						} = t.payload, r = Object(X.a)(e[n], s);
						return {
							...e,
							newState: r
						}
					}
					default:
						return e
				}
			};
			const Le = {};
			var Fe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.c:
						case Ie.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: Oe()([...e[n] || [], ...s])
							}
						}
						case Ie.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: [...s, ...e[n] || []]
							}
						}
						case Ie.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				Ue = Object(B.c)({
					afterToken: we,
					api: Ae,
					models: De,
					userOrder: Fe
				});
			const Be = {};
			var Ge = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Be,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.g: {
							const {
								subredditName: n,
								contributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				He = Object(B.c)({
					listing: Ue,
					search: Ge
				}),
				We = Object(B.c)({
					diff: H,
					directory: q,
					pages: K,
					pageSettings: Y,
					revisions: de,
					wikiBannedContributors: ke,
					wikiContributors: He
				});
			Object(U.a)({
				pages: {
					subredditWiki: We
				}
			});
			const qe = Object(d.a)(h.c),
				Ve = Object(d.a)(h.b),
				ze = Object(d.a)(h.a),
				Ke = (e, t, n, s) => {
					return n === N.j ? Qe(e, t) : !!Object(y.c)(e, {
						subredditName: t,
						wikiPageName: n,
						revisionId: s
					})
				},
				Qe = (e, t) => !!Object(y.b)(e, {
					subredditName: t
				}),
				Je = e => async (t, n, r) => {
					const {
						canShowFailToast: a,
						wikiPageName: d
					} = e, c = d === N.j, l = {
						...e,
						includePageData: e.includePageData && !c
					}, u = d ? Object(A.a)({
						...e,
						wikiPageName: d
					}) : void 0;
					t(qe({
						options: l,
						pageKey: u
					}));
					const m = await Object(P.a)(r.gqlContext(), l),
						p = m.body,
						b = m.ok ? p.data && p.data.subreddit && p.data.subreddit.wiki : null;
					return m.ok && b ? t(Ve({
						options: l,
						pageKey: u,
						subredditWiki: b
					})) : (t(ze({
						options: l,
						pageKey: u,
						error: m.error || {
							type: i.I.NOT_FOUND_ERROR
						}
					})), a && t(Object(f.f)({
						id: "SUBREDDIT_WIKI_DATA_ERROR_TOAST",
						kind: M.b.Error,
						text: s.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "wZxm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "mgOpG"
						}),
						buttonAction: Je(e)
					}))), !(!m.ok || !o()(p.data.subreddit)) || !(!m.ok || !b)
				}, Ye = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s) => {
						const r = s(),
							o = {
								sort: i.W.HOT
							},
							a = Object(c.a)(e, o.sort),
							d = r.listings.postOrder.api.error[a],
							l = r.listings.postOrder.api.pending[a],
							u = !!r.listings.postOrder.ids[a];
						return !!(l || u && !d) || (await n(Object(b.subredditDataRequested)(a, e, o, t)), !s().listings.postOrder.api.error[a])
					}
				}, Xe = e => async (t, n) => {
					const {
						params: s,
						url: r
					} = e, {
						wikiPageName: o
					} = s, i = Object(L.a)(r, s);
					let d = !1;
					return N.l.includes(o || "") ? (await (async (e, t) => {
						const n = `${l.a.oldRedditUrl}${Object(m.b)(e)}`;
						window.location.href = n
					})(e.url), d = !0) : r !== i && (await t(Object(a.c)(i)), d = !0), d
				}, Ze = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, a) => {
						const {
							subredditName: d = N.e,
							wikiPageName: c,
							wikiSubRoute: l
						} = e, u = t[T.G], m = t[T.H], p = u ? Object(O.a)(u) : void 0, b = m ? Object(O.a)(m) : void 0, h = c === N.j, v = l === N.m.Revisions;
						let x = !1,
							E = !1;
						if (n) {
							const {
								pageName: t
							} = e;
							x = t === i.gc.WikiContributors, E = t === i.gc.WikiBanned
						}
						const y = o(),
							j = (h || n) && !Qe(y, d),
							C = !!c && !Ke(y, d, c, p),
							k = [];
						k.push(r(Ye(d))), (j || C) && k.push(r(Je({
							includeDirectory: j,
							includePageData: C,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), l === N.m.Settings && c && k.push(r(Object(S.c)(d, c))), c && p && b && k.push(r(I({
							comparisonRevisionId: b,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), v && k.push(r(Object(w.c)({
							isRecent: !c,
							wikiPageName: c,
							subredditName: d
						}))), x && k.push(r(Object(_.e)(d))), E && k.push(r(Object(g.e)(d))), (await Promise.all(k)).every(Boolean) || r(Object(f.f)({
							kind: M.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "3UWos1"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "mgOpG"
							}),
							buttonAction: Ze(e, t, n)
						}))
					}
				}, $e = e => async (t, n) => {
					if (await t(Xe(e))) return;
					const {
						params: s,
						queryParams: r
					} = e, o = s.subredditName || N.e;
					t(u.m({
						title: s.wikiPageName ? `${s.wikiPageName} - ${o}` : `wiki - ${o}`
					})), await t(Ze(s, r));
					const a = Object(F.z)(n(), {
							subredditName: o
						}),
						i = n();
					a && (i.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						t(Object(p.b)(D.a.SUBREDDIT))
					}), t(Object(p.d)({
						isViewSafe: Object(R.a)([], [a])
					})))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "i", (function() {
				return R
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/constants/modals.ts"),
				c = n("./src/reddit/endpoints/post/index.tsx"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/profile.ts");
			const b = "PINNEDPOST__PINNED_POSTS_LOADED",
				h = Object(o.a)(b),
				f = "PINNEDPOST__PIN_POST_SUCCESS",
				g = "PINNEDPOST__UNPIN_POST_SUCCESS",
				_ = Object(o.a)(f),
				v = Object(o.a)(g),
				O = "PINNEDPOST__PIN_POST_PENDING",
				x = "PINNEDPOST__UNPIN_POST_PENDING",
				E = Object(o.a)(O),
				y = Object(o.a)(x),
				j = "PINNEDPOST__PIN_POST_FAILURE",
				C = "PINNEDPOST__UNPIN_POST_FAILURE",
				k = Object(o.a)(j),
				I = Object(o.a)(C),
				S = e => Object(i.f)({
					buttonAction: R(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: l.b.SuccessMod,
					text: s.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				w = (e, t) => Object(i.f)({
					buttonAction: R(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: l.b.SuccessMod,
					text: t ? s.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : s.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				T = () => Object(i.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				N = () => Object(i.f)({
					kind: l.b.Error,
					text: s.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				P = () => Object(i.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				R = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, o) => {
						let {
							apiContext: i,
							gqlContext: l
						} = o;
						const b = s(),
							h = b.posts.models[e];
						if (!h) return;
						const f = !Object(m.s)(b, {
							postId: e
						});
						if (f && h.isRemoved) return n(N());
						const g = h.author,
							O = Object(p.m)(b, g),
							[x, j, C, R, A] = f ? [E, _, k, S, T] : [y, v, I, w, P];
						if (f) {
							if (Object(m.P)(b, {
									profileName: g
								}).length >= r.cb) return void n(Object(a.i)(d.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const M = Object(m.p)(b, e, g),
							D = !f && M;
						n(x({
							postId: e,
							profileId: O
						})), (Object(u.c)(b) ? await Object(c.j)(l(), e, f, !0) : await Object(c.v)(i(), e, f, !0)).ok ? (n(j({
							postId: e,
							profileId: O
						})), t || n(R(e, D))) : (n(C({
							postId: e,
							profileId: O
						})), n(A()))
					}
				}
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "t", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "q", (function() {
				return x
			})), n.d(t, "o", (function() {
				return E
			}));
			const s = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				o = "CREATE_COLLECTION_FAILED",
				a = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				i = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				d = "ADD_POST_TO_COLLECTION_SUCCESS",
				c = "UPDATE_POST_WITH_COLLECTION_ID",
				l = "DELETE_COLLECTION_SUCCESS",
				u = "UPDATE_COLLECTION_PENDING",
				m = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				b = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				h = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				f = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				g = "REORDER_COLLECTION_PENDING",
				_ = "REORDER_COLLECTION_SUCCESS",
				v = "REORDER_COLLECTION_FAILED",
				O = "UPDATE_COLLECTION_LAYOUT_PENDING",
				x = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				E = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCollection/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "a", (function() {
				return H
			})), n.d(t, "c", (function() {
				return q
			})), n.d(t, "h", (function() {
				return Q
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return oe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/lib/filterQueryParams/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/postCollection/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/history.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var h = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/add_post_to_collection.json`,
				method: u.jb.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var f = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/create_collection.json`,
				method: u.jb.POST,
				data: {
					title: t,
					sr_fullname: n
				}
			});
			var g = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/delete_collection.json`,
					method: u.jb.POST,
					data: {
						collection_id: t
					}
				}),
				_ = n("./src/config.ts");
			var v = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${_.a.gatewayUrl}/desktopapi/v1/subreddit_collections/${t}`,
				method: u.jb.GET
			});
			var O = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/remove_post_in_collection.json`,
				method: u.jb.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var x = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_title.json`,
				method: u.jb.POST,
				data: {
					collection_id: t,
					title: n
				}
			});
			var E = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/reorder_collection.json`,
				method: u.jb.POST,
				data: {
					collection_id: t,
					link_ids: n.join(",")
				}
			});
			var y = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_description.json`,
				method: u.jb.POST,
				data: {
					collection_id: t,
					description: n
				}
			});
			var j = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/update_collection_display_layout.json`,
					method: u.jb.POST,
					data: {
						collection_id: t,
						display_layout: n
					}
				}),
				C = n("./src/reddit/helpers/overlay/index.ts"),
				k = n("./src/reddit/helpers/path/index.ts"),
				I = n("./src/reddit/models/Toast/index.ts"),
				S = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				w = n("./src/reddit/selectors/postCollection.ts"),
				T = n("./src/reddit/selectors/posts.ts"),
				N = n("./src/reddit/selectors/subreddit.ts");
			const P = Object(a.a)(d.c),
				R = Object(a.a)(d.b),
				A = Object(a.a)(d.d),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(P());
					const a = await f(o(), e, t);
					let i;
					if (a.ok) {
						const e = s().meta,
							t = (e => ({
								author: e.author_name || void 0,
								createdAtUTC: e.created_at_utc,
								description: e.description,
								displayLayout: e.display_layout,
								id: e.collection_id,
								lastUpdateUTC: e.last_update_utc,
								permalink: e.permalink,
								postIds: e.link_ids,
								primaryPostId: e.primary_link_id || void 0,
								subredditId: e.subreddit_id,
								title: e.title
							}))(a.body);
						n(A({
							collection: t,
							meta: e
						})), i = t
					} else {
						const e = a.error;
						n(R(e))
					}
					return i
				}, D = Object(a.a)(d.f), L = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const a = n().postCollection.subredditToIds || {};
					if (Object.keys(a).length > 0) return;
					const i = await v(o(), e);
					i.ok ? t(D(i.body)) : t(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, F = Object(a.a)(d.g), U = (e, t, n) => async (r, o, a) => {
					let {
						apiContext: i
					} = a;
					if ((await O(i(), e, t)).ok) {
						const a = o(),
							i = Object(T.G)(a, {
								postId: t
							}),
							d = i && i.title || "",
							l = Object(w.q)(a, {
								collectionId: e
							}),
							u = (l && l.postIds && l.postIds.indexOf(t) || -1) - 1;
						if (r(F({
								collectionId: e,
								postId: t
							})), n && u >= 0) {
							const t = o(),
								n = Object(w.q)(t, {
									collectionId: e
								}),
								s = n && n.postIds && n.postIds[u] || "",
								a = Object(T.G)(t, {
									postId: s
								});
							a && a.permalink && r(Object(C.a)(a.permalink))
						}
						r(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Following post removed from collection successfully: {postTitle}", [s.fbt._param("postTitle", d)], {
								hk: "8e1lV"
							}),
							buttonText: s.fbt._("UNDO", null, {
								hk: "3KPLib"
							}),
							buttonAction: H(e, t)
						}))
					} else r(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, B = Object(a.a)(d.a), G = Object(a.a)(d.t), H = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r();
					if ((await h(a(), e, t)).ok) {
						n(B({
							collectionId: e,
							postId: t
						})), n(G({
							collectionId: e,
							postId: t
						}));
						const r = Object(T.G)(i, {
								postId: t
							}),
							o = Object(w.q)(i, {
								collectionId: e
							}),
							a = o && o.title || "";
						n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Success! You added a post to the collection: {title}", [s.fbt._param("title", a)], {
								hk: "3KNJWi"
							}),
							buttonText: s.fbt._("VIEW", null, {
								hk: "1SSkgL"
							}),
							buttonAction: Object(C.a)(r.permalink)
						}))
					} else n(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, W = Object(a.a)(d.e), q = (e, t) => async (n, a, i) => {
					let {
						apiContext: d
					} = i;
					const l = a();
					if ((await g(d(), e)).ok) {
						const {
							url: a
						} = l.platform.currentPage, i = Object(w.q)(l, {
							collectionId: e
						}), d = i && i.title || "", u = i && i.subredditId, m = u ? Object(N.c)(l, u) : "/";
						n(W({
							collectionId: e,
							collection: i
						})), n(t ? Object(r.c)(Object(o.a)(a, ["collection"])) : Object(r.b)(m)), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection deleted successfully: {title}", [s.fbt._param("title", d)], {
								hk: "4tcOKB"
							})
						}))
					} else n(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, V = Object(a.a)(d.r), z = Object(a.a)(d.n), K = Object(a.a)(d.s), Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					n(V());
					const i = await x(a(), e, t);
					let d = !1;
					if (i.ok) n(K({
						collectionId: e,
						newTitle: t
					})), n(Object(c.f)({
						kind: I.b.SuccessMod,
						text: s.fbt._("Collection title updated successfully", null, {
							hk: "2hKzKl"
						})
					})), d = !0;
					else {
						const e = i.error;
						n(z(e)), n(Object(c.f)({
							kind: I.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))
					}
					return d
				}, J = Object(a.a)(d.l), Y = Object(a.a)(d.m), X = Object(a.a)(d.k), Z = e => async (t, n) => {
					const s = n();
					if (Object(S.b)(s) || Object(S.c)(s)) return void t(Object(i.bb)(Object(k.b)(e.permalink), e.id));
					const o = s.platform.currentPage.locationState;
					t(!(!o || !o[l.b.IsOverlay]) ? Object(C.a)(e.permalink) : Object(r.b)(Object(k.b)(e.permalink)))
				}, $ = Object(a.a)(d.i), ee = Object(a.a)(d.j), te = Object(a.a)(d.h), ne = Object(a.a)(d.p), se = Object(a.a)(d.o), re = Object(a.a)(d.q), oe = e => async t => {
					const n = [],
						{
							collectionId: r,
							description: o,
							displayLayout: a,
							postIds: i,
							title: d
						} = e;
					i && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: a
						} = o;
						n($());
						const i = await E(a(), e, t);
						let d = !1;
						return i.ok ? (n(ee({
							collectionId: e,
							postIds: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection order updated successfully", null, {
								hk: "4ccHEL"
							})
						})), d = !0) : (n(te({
							error: i.error
						})), n(Object(c.f)({
							kind: I.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))), d
					})(r, i))), d && n.push(t(Q(r, d))), void 0 !== o && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: a
						} = o;
						n(J());
						const i = await y(a(), e, t);
						let d = !1;
						if (i.ok) n(Y({
							collectionId: e,
							newDescription: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection description updated successfully", null, {
								hk: "1rIDCC"
							})
						})), d = !0;
						else {
							const e = i.error;
							n(X(e)), n(Object(c.f)({
								kind: I.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, o))), a && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: a
						} = o;
						n(ne());
						const i = await j(a(), e, t);
						let d = !1;
						if (i.ok) n(re({
							collectionId: e,
							newLayout: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection layout updated successfully", null, {
								hk: "1Rs19j"
							})
						})), d = !0;
						else {
							const e = i.error;
							n(se(e)), n(Object(c.f)({
								kind: I.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, a)));
					let l = !0;
					return await Promise.all(n).then(e => {
						e.forEach(e => {
							e || (l = !1)
						})
					}), l
				}
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "K", (function() {
				return s
			})), n.d(t, "L", (function() {
				return r
			})), n.d(t, "l", (function() {
				return o
			})), n.d(t, "m", (function() {
				return a
			})), n.d(t, "x", (function() {
				return i
			})), n.d(t, "H", (function() {
				return d
			})), n.d(t, "I", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "G", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "Q", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "D", (function() {
				return h
			})), n.d(t, "s", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "q", (function() {
				return k
			})), n.d(t, "S", (function() {
				return I
			})), n.d(t, "R", (function() {
				return S
			})), n.d(t, "T", (function() {
				return w
			})), n.d(t, "U", (function() {
				return T
			})), n.d(t, "V", (function() {
				return N
			})), n.d(t, "W", (function() {
				return P
			})), n.d(t, "X", (function() {
				return R
			})), n.d(t, "Y", (function() {
				return A
			})), n.d(t, "Z", (function() {
				return M
			})), n.d(t, "r", (function() {
				return D
			})), n.d(t, "E", (function() {
				return L
			})), n.d(t, "u", (function() {
				return F
			})), n.d(t, "v", (function() {
				return U
			})), n.d(t, "t", (function() {
				return B
			})), n.d(t, "w", (function() {
				return G
			})), n.d(t, "P", (function() {
				return H
			})), n.d(t, "o", (function() {
				return W
			})), n.d(t, "y", (function() {
				return q
			})), n.d(t, "db", (function() {
				return V
			})), n.d(t, "J", (function() {
				return z
			})), n.d(t, "a", (function() {
				return K
			})), n.d(t, "F", (function() {
				return Q
			})), n.d(t, "N", (function() {
				return J
			})), n.d(t, "O", (function() {
				return Y
			})), n.d(t, "M", (function() {
				return X
			})), n.d(t, "ab", (function() {
				return Z
			})), n.d(t, "C", (function() {
				return $
			})), n.d(t, "B", (function() {
				return ee
			})), n.d(t, "z", (function() {
				return te
			})), n.d(t, "A", (function() {
				return ne
			})), n.d(t, "cb", (function() {
				return se
			})), n.d(t, "bb", (function() {
				return re
			}));
			const s = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				r = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				o = "POST_CREATION_EDIT_COMPLETE",
				a = "POST_CREATION_EDIT_FAILED",
				i = "POST_CREATION_PENDING_EDIT",
				d = "POST_CREATION_START_EDITING_POST",
				c = "POST_CREATION_STOP_EDITING_POST",
				l = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				u = "STARTED_CONVERTING_EDITOR_CONTENT",
				m = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				b = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				h = "POST_TITLE_FETCHED",
				f = "INITIALIZE_EDITOR_MODE",
				g = "POST_CREATION__CHANGE_FLAIR",
				_ = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				v = "POST_CREATION__CHANGE_LINK_BODY",
				O = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				x = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_RECAPTCHA",
				y = "POST_CREATION__CHANGE_RTE_STATE",
				j = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				C = "POST_CREATION__CHANGE_TITLE",
				k = "POST_CREATION__GOV_TYPE_CHANGED",
				I = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				S = "POST_CREATION__TOGGLE_IS_CHANGED",
				w = "POST_CREATION__TOGGLE_IS_GOV",
				T = "POST_CREATION__TOGGLE_IS_NSFW",
				N = "POST_CREATION__TOGGLE_IS_OC",
				P = "POST_CREATION__TOGGLE_IS_POLL",
				R = "POST_CREATION__TOGGLE_IS_SPOILER",
				A = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				M = "POST_CREATION__TOGGLE_SEND_REPLIES",
				D = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				L = "POST_CREATION__RESET_FORM",
				F = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				U = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				B = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				G = "POST_CREATION__PENDING",
				H = "POST_CREATION__SUCCEEDED",
				W = "POST_CREATION__FAILED",
				q = "POST_CREATION__POLL_FAILED",
				V = "POST_CREATION__VALIDATION_FAILED",
				z = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				K = "POST_CREATION__CAPTCHA_REQUIRED",
				Q = "POST_CREATION__SET_SUBMIT_MODE",
				J = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				Y = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				X = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED",
				Z = "POST_CREATION__UPDATE_SCHEDULED_POST_ADVANCED_SETTINGS",
				$ = "POST_CREATION__SUBREDDIT_RECOMMENDATION_PENDING",
				ee = "POST_CREATION__SUBREDDIT_RECOMMENDATION_LOADED",
				te = "POST_CREATION__SUBREDDIT_RECOMMENDATION_FAILED",
				ne = "POST_CREATION__SUB_REC_IS_INPUT_CHANGED",
				se = "POST_CREATION__UPDATE_TOURNAMENT",
				re = "POST_CREATION__UPDATE_TALK"
		},
		"./src/reddit/actions/postCreation/editing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "c", (function() {
				return D
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				m = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				p = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const b = e => !(!e.document || !e.document.length),
				h = e => ({
					text: null,
					richtext_json: JSON.stringify({
						document: e.document
					})
				}),
				f = e => ({
					text: e.markdown,
					return_rtjson: !0
				}),
				g = e => ({
					api_type: "json",
					show_error_list: !0,
					thing_id: e.post.id,
					validate_on_submit: !0,
					...b(e) ? h(e) : f(e)
				});
			var _ = (e, t) => Object(d.a)(Object(c.a)(e, [l.a]), {
					endpoint: Object(p.a)(Object(u.a)(`${e.apiUrl}/api/editusertext`)),
					method: i.jb.POST,
					data: g(t)
				}).then(m.b),
				v = n("./src/reddit/helpers/overlay/index.ts"),
				O = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				x = n("./src/reddit/helpers/trackers/lightbox.ts"),
				E = n("./src/reddit/helpers/trackers/post.ts"),
				y = n("./src/reddit/helpers/trackers/postComposer.ts"),
				j = n("./src/reddit/models/Media/index.ts"),
				C = n("./src/reddit/models/PostCreationForm/index.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/actions/postCreation/constants.ts"),
				w = n("./src/reddit/actions/postCreation/general.ts");
			const T = Object(r.a)(S.l),
				N = Object(r.a)(S.m),
				P = Object(r.a)(S.x),
				R = Object(r.a)(S.H),
				A = Object(r.a)(S.I),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(I.G)(a, {
							postId: e
						});
					t ? (n(Object(v.a)(i.permalink)), Object(x.e)(e, "edit")(a)) : Object(E.e)(e, "edit")(a);
					const {
						media: d
					} = i;
					if (!d) return;
					let c, l = C.i.RICH_TEXT,
						u = "";
					d.type === j.o.TEXT ? (l = C.i.MARKDOWN, u = d.content) : d.type === j.o.RTJSON && (u = (l = d.rteMode || C.i.RICH_TEXT) === C.i.MARKDOWN ? d.markdownContent : d.richtextContent, c = d.mediaMetadata || void 0), n(R({
						editorMode: l,
						mediaMetadata: c,
						postContent: u,
						postId: e
					}))
				}, D = e => async (t, n, r) => {
					let {
						apiContext: i
					} = r;
					const {
						post: d
					} = e, c = !d.media || "rtjson" !== d.media.type && "text" !== d.media.type ? "" : d.media.rteMode;
					y.E(n(), Object(w.o)(c)), t(P(d.id));
					const l = await _(i(), e),
						u = !1 === l.body.success;
					if (t(T(d.id)), l.ok && !u) {
						t(Object(a.f)({
							kind: k.b.SuccessCommunity,
							text: s.fbt._("Post successfully edited", null, {
								hk: "xej5K"
							})
						})), t(A(d.id));
						const e = Object(O.a)(l.body);
						t(Object(o.S)({
							[d.id]: e
						}))
					} else t(N(l.error))
				}
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/post/convert.ts"),
				i = n("./src/reddit/helpers/localStorage/index.ts"),
				d = n("./src/reddit/helpers/trackers/postComposer.ts"),
				c = n("./src/reddit/models/PostCreationForm/index.ts"),
				l = n("./src/reddit/models/RichTextJson/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(m.G),
				b = Object(r.a)(m.p),
				h = Object(r.a)(m.Q),
				f = (e, t, n) => async (r, i, f) => {
					let {
						apiContext: _
					} = f;
					d.m(i(), t);
					const v = t === c.i.MARKDOWN,
						O = t === c.i.RICH_TEXT,
						x = m.k;
					if (v && Object(l.G)(n)) return r(h({
						editorKey: e,
						editorMode: c.i.MARKDOWN,
						content: ""
					})), void r(g(t));
					if (O && !n) return r(h({
						editorKey: e,
						editorMode: c.i.RICH_TEXT,
						content: l.i
					})), void r(g(t));
					r(p(x));
					const E = await Object(a.a)(_(), t, v ? JSON.stringify(n) : n);
					E.ok ? (r(b(x)), r(h({
						editorKey: e,
						editorMode: t,
						content: E.body.output
					})), r(g(t))) : (r(b(x)), r(Object(o.f)({
						duration: o.a,
						kind: u.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, g = e => async (t, n) => {
					const r = Object(i.l)();
					if (r >= 3) return;
					const a = n().user.prefs.useMarkdown ? c.i.MARKDOWN : c.i.RICH_TEXT;
					if (e === a) return;
					const d = e === c.i.MARKDOWN ? s.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : s.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(o.f)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: s.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: u.b.SuccessCommunity,
						text: d
					})), Object(i.sb)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return I
			})), n.d(t, "o", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "f", (function() {
				return M
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "g", (function() {
				return L
			})), n.d(t, "h", (function() {
				return F
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "u", (function() {
				return B
			})), n.d(t, "t", (function() {
				return G
			})), n.d(t, "v", (function() {
				return H
			})), n.d(t, "w", (function() {
				return W
			})), n.d(t, "x", (function() {
				return q
			})), n.d(t, "y", (function() {
				return V
			})), n.d(t, "A", (function() {
				return z
			})), n.d(t, "B", (function() {
				return K
			})), n.d(t, "E", (function() {
				return Q
			})), n.d(t, "D", (function() {
				return J
			})), n.d(t, "C", (function() {
				return Y
			})), n.d(t, "m", (function() {
				return X
			})), n.d(t, "r", (function() {
				return $
			})), n.d(t, "s", (function() {
				return ee
			})), n.d(t, "q", (function() {
				return te
			})), n.d(t, "z", (function() {
				return ne
			})), n.d(t, "p", (function() {
				return se
			})), n.d(t, "n", (function() {
				return re
			})), n.d(t, "k", (function() {
				return le
			})), n.d(t, "j", (function() {
				return pe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/debounce.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-redux/es/index.js"),
				a = n("./src/lib/isUrl/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/endpoints/post/index.tsx"),
				u = n("./src/redditGQL/operations/WhereToPostSubRec.json"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/redditGQL/operations/OpenAISubRecWithDetail.json");
			var b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				g = n("./src/reddit/helpers/trackers/postComposer.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				v = n("./src/reddit/models/Subreddit/index.ts"),
				O = n("./src/reddit/routes/postCreation/constants.ts"),
				x = n("./src/reddit/selectors/activeModalId.ts"),
				E = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				y = n("./src/reddit/selectors/postCollection.ts"),
				j = n("./src/reddit/selectors/postCreations.ts"),
				C = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				k = n("./src/reddit/actions/postCreation/constants.ts");
			const I = Object(i.a)(k.n),
				S = Object(i.a)(k.D),
				w = (Object(i.a)(k.s), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				T = Object(i.a)(k.b),
				N = Object(i.a)(k.c),
				P = Object(i.a)(k.d),
				R = Object(i.a)(k.e),
				A = Object(i.a)(k.f),
				M = Object(i.a)(k.g),
				D = Object(i.a)(k.h),
				L = Object(i.a)(k.i),
				F = Object(i.a)(k.j),
				U = Object(i.a)(k.q),
				B = Object(i.a)(k.S),
				G = Object(i.a)(k.R),
				H = (Object(i.a)(k.T), Object(i.a)(k.U)),
				W = Object(i.a)(k.V),
				q = Object(i.a)(k.W),
				V = Object(i.a)(k.X),
				z = Object(i.a)(k.Y),
				K = Object(i.a)(k.Z),
				Q = Object(i.a)(k.cb),
				J = Object(i.a)(k.bb),
				Y = Object(i.a)(k.ab),
				X = Object(i.a)(k.r),
				Z = r()((e, t) => {
					Object(a.a)(t) && e((e => async (t, n, s) => {
						let {
							apiContext: r
						} = s;
						const o = await Object(l.f)(r(), e);
						o.ok && o.body && o.body.json && o.body.json.data && t(S(o.body.json.data))
					})(t))
				}, 500),
				$ = e => async t => {
					t(P(e)), Z(t, e)
				}, ee = Object(i.a)(k.E), te = (e, t) => async (n, s) => {
					n(ee()), n(e ? Object(o.b)(O.b) : Object(o.b)(Object(j.cb)(s(), {
						pageLayer: t
					})))
				}, ne = e => async t => {
					t(d.i(e))
				}, se = e => async (t, n) => {
					const s = n(),
						r = Object(c.G)(e),
						o = Object(j.H)(s);
					if (r && o) {
						Object(x.a)(s) !== _.d && t(ne(_.d))
					} else t(te(!1, e))
				}, re = e => async (t, n) => {
					const s = n();
					Object(y.m)(s, {
						subredditId: e
					}) ? t(d.i(_.a)) : t(d.i(_.c))
				}, oe = Object(i.a)(k.B), ae = Object(i.a)(k.C), ie = Object(i.a)(k.z), de = Object(i.a)(k.A), ce = e => async (t, n) => {
					Object(C.e)(n()) !== e && t(de({
						isChanged: e
					}))
				}, le = () => async (e, t) => {
					const n = t();
					if (Object(C.g)(n))
						if (Object(C.h)(n)) {
							const t = n.creations.formData.title,
								s = Object(C.l)(n),
								r = Object(C.k)(n),
								o = Object(C.b)(n);
							e(pe(t, s, r, void 0, o))
						} else Object(C.j)(n) && !Object(C.d)(n) && e(be())
				}, ue = ["torrents", "IsolatedVocals"], me = ["askreddit", "teenagers"], pe = (e, t, n, s, r) => async (o, a, i) => {
					let {
						apiContext: d,
						gqlContext: c
					} = i;
					const l = a();
					if (Object(C.i)(l)) return;
					o(ae());
					const u = Object(b.c)(b.a.PostComposer),
						_ = await ((e, t, n, s, r, o) => Object(m.a)(e, {
							...p,
							variables: {
								title: t,
								body: n,
								link: s,
								correlationId: r,
								confidenceWeight: o
							}
						}))(c(), e, t, n, u, r),
						O = {};
					let x = {};
					const y = {},
						j = {},
						k = [];
					if (!_.body || !_.ok) return o(ce(!1)), void o(ie()); {
						const {
							data: e
						} = _.body, {
							subredditSuggestions: t
						} = e.openaiSubredditSuggestionsDetailed;
						let n = t.map(e => {
							const {
								subredditInfo: t,
								cVal: n,
								sVal: s
							} = e, r = t.name;
							return r && (j[r] = {
								confidence: n,
								succRate: s
							}), t
						}).filter(e => !ue.includes(e.name));
						const r = (n = s ? n.filter(e => !s(e)) : n).slice(0, C.a),
							i = r.map(e => {
								const t = e.name;
								return k.push(t), t
							});
						if (Object(E.b)(l) && (e => {
								const t = e.map(e => e.toLowerCase());
								let n = !1;
								return me.forEach(e => {
									t.includes(e) && (n = !0)
								}), n
							})(i)) return o(ce(!1)), o(oe({
							subreddits: {},
							subredditsAboutInfo: {},
							unavailableSubreddits: {},
							recSubsDict: {},
							recSubsOrder: []
						})), Object(g.G)(a()), void o(ie());
						r.forEach(e => {
							if (Object(v.j)(e)) {
								const t = Object(f.f)(e);
								y[t.id] = t
							} else if (e && Object.keys(e).length > 0) {
								const t = Object(f.a)(e),
									n = Object(h.a)(e);
								O[t.id] = t, x = {
									...x,
									...n
								}
							}
						})
					}
					o(ce(!1)), o(oe({
						subreddits: O,
						subredditsAboutInfo: x,
						unavailableSubreddits: y,
						recSubsDict: j,
						recSubsOrder: k
					})), 0 === Object(C.c)(a()).length && o(ie())
				}, be = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: r
					} = n;
					const o = t();
					if (Object(C.i)(o)) return;
					e(ae());
					const a = {};
					let i = {};
					const d = {},
						c = {},
						l = [],
						p = await (e => Object(m.a)(e, {
							...u,
							variables: {
								recentSubreddits: []
							}
						}))(r());
					if (!p.ok || !p.body) return e(ie()), void e(ce(!1)); {
						const {
							data: e
						} = p.body;
						(e.whereToPostSuggestions.edges || []).forEach((e, t) => {
							if (t >= C.a) return;
							const n = e.node.subredditInfo;
							if (Object(v.j)(n)) {
								const e = Object(f.f)(n);
								d[e.id] = e
							} else if (n && Object.keys(n).length > 0) {
								const e = Object(f.a)(n),
									t = Object(h.a)(n);
								c[n.name] = {}, l.push(n.name), a[e.id] = e, i = {
									...i,
									...t
								}
							}
						})
					}
					e(ce(!1)), e(oe({
						subreddits: a,
						subredditsAboutInfo: i,
						unavailableSubreddits: d,
						recSubsDict: c,
						recSubsOrder: l
					})), 0 === Object(C.c)(t()).length && e(ie())
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return R
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "e", (function() {
				return U
			})), n.d(t, "d", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/v4.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/formatApiError/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/actions/upload.ts"),
				u = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var h = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/imagePreview/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				_ = n("./src/reddit/models/Upload/index.ts"),
				v = n("./src/reddit/selectors/telemetry.ts"),
				O = n("./src/telemetry/index.ts");
			const x = e => ({
				...v.n(e),
				screen: v.Z(e),
				profile: v.R(e),
				subreddit: v.hb(e)
			});
			var E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/models/Gold/Powerups/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				C = n("./src/reddit/models/Toast/index.ts"),
				k = n("./src/reddit/selectors/gold/powerups/index.ts"),
				I = n("./src/reddit/selectors/postCreations.ts"),
				S = n("./src/reddit/actions/postCreation/constants.ts"),
				w = n("./src/reddit/actions/postCreation/general.ts");
			const T = Object(d.a)(S.u),
				N = Object(d.a)(S.v),
				P = Object(d.a)(S.t),
				R = e => async (t, n) => {
					t(T());
					const s = e.map(e => {
						let {
							url: n,
							uploadKey: s
						} = e;
						const r = Object(g.b)(Object(g.d)(n), "poster.png");
						return t(L(r, s))
					});
					await Promise.all(s);
					const r = n().uploads,
						o = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return r[t]
						}).find(e => e.status !== _.a.SUCCESS);
					t(o ? P(o.error) : N())
				}, A = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const M = "RTE",
				D = "GALLERY",
				L = (e, t, n, r) => async (o, i, d) => {
					let {
						apiContext: c
					} = d;
					const u = Object(I.h)(i()),
						j = Date.now();
					let C = null,
						S = !1,
						w = !1,
						T = !1;
					const N = e => {
						if (!T && n && S) {
							T = !0;
							const s = i(),
								r = Date.now() - j,
								o = Object(h.c)(h.a.PostComposer);
							w ? (async e => {
								let {
									state: t,
									uploadKey: n,
									assetId: s,
									isCanceled: r,
									fileSource: o,
									uploadDuration: a,
									correlationId: i
								} = e;
								const d = t.uploads[n],
									c = r || d.status === _.a.CANCELED,
									{
										file: l,
										url: u,
										metadata: m,
										error: p
									} = d,
									b = m.mimetype || l.type,
									h = b.startsWith("video/"),
									f = d.status === _.a.SUCCESS;
								let g = "";
								p ? g = JSON.stringify(p) : c && (g = "canceled");
								const E = {
									width: m.width,
									height: m.height,
									duration: m.videoDuration && Math.round(1e3 * m.videoDuration)
								};
								Object(O.a)({
									source: "post_composer",
									action: "upload",
									correlationId: i,
									noun: h ? "video" : "image",
									...x(t),
									actionInfo: {
										...v.d(t),
										success: f,
										...g ? {
											reason: g
										} : {}
									},
									media: {
										mimetype: b,
										uploadDuration: a,
										source: o,
										fileName: l.name,
										size: l.size,
										type: h ? "video" : "image",
										...s ? {
											id: s
										} : {},
										...u ? {
											url: u
										} : {},
										...E
									}
								})
							})({
								state: s,
								uploadKey: t,
								assetId: C,
								isCanceled: e,
								fileSource: n,
								uploadDuration: r,
								correlationId: o
							}) : E.D(s, t)
						}
					};
					return await o(Object(l.l)(e, t, async d => {
						S = !0, Object(l.k)(d.id, () => {
							N(!0)
						});
						const {
							error: h,
							metadata: _
						} = await async function(e, t, n) {
							const r = n && n.allowedPostTypes,
								o = n && n.name,
								i = await Object(g.h)(t) || t.type,
								d = Object(g.c)(t) || void 0;
							if (!d) return A("UNSUPPORTED_BROWSER");
							const c = {
								localUrl: d,
								mimetype: i
							};
							if (!i || !Object(g.j)(i)) return {
								error: {
									type: a.T
								}
							};
							if (i.startsWith("image/")) {
								if (r && !r.images) {
									const e = s.fbt._("Images are not allowed in r/{subredditName}", [s.fbt._param("subredditName", o)], {
										hk: "3C2E7Q"
									});
									return A(a.T, e)
								}
								if ("image/gif" === i) {
									if (t.size > a.Z) return A(a.L)
								} else if (t.size > a.bb) return A(a.R);
								const e = await Object(f.a)(d);
								c.width = e.width, c.height = e.height
							} else if (i.startsWith("video/")) {
								const i = !(null == n || !n.id) && Object(k.n)(e, {
										subredditId: n.id,
										benefit: y.a.HdVideo
									}),
									u = i ? 2 * a.fb : a.fb;
								if (t.size > u) return A(a.pc);
								let m;
								try {
									m = await Object(g.i)(d, !0)
								} catch (l) {
									return A(a.T)
								}
								if (r) {
									const {
										videos: e,
										images: t
									} = r;
									if (t && !e && m.duration > a.gb) {
										const e = s.fbt._("Sorry, r/{subredditName} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF.", [s.fbt._param("subredditName", o)], {
											hk: "46ULiz"
										});
										return A(a.T, e)
									}
									if (!t && !e) {
										const e = s.fbt._("Videos are not allowed in r/{subredditName}", [s.fbt._param("subredditName", o)], {
											hk: "4uTUZb"
										});
										return A(a.T, e)
									}
								}
								const p = i ? 2 * a.eb : a.eb;
								if (m.duration > p) {
									const e = s.fbt._("Video is too long. Maximum video length is {duration} minutes.", [s.fbt._param("duration", (p / 60).toString())], {
										hk: "20nB6Q"
									});
									return A(a.T, e)
								}
								if (m.duration < a.mb) {
									const e = s.fbt._("Video is too short. Minimum video length is {duration} seconds.", [s.fbt._param("duration", a.mb.toString())], {
										hk: "49PSW8"
									});
									return A(a.T, e)
								}
								if (0 === m.height || 0 === m.width) {
									const e = s.fbt._("Your browser does not support the video codec used for this video. Please try using a different video codec.", null, {
										hk: "1AC0mg"
									});
									return A(a.T, e)
								}
								if (m.height < a.nb || m.width < a.ob) {
									const e = s.fbt._("Videos must be {min_video_width}x{min_video_height} pixels or larger.", [s.fbt._param("min_video_width", a.ob.toString()), s.fbt._param("min_video_height", a.nb.toString())], {
										hk: "2HSUGl"
									});
									return A(a.T, e)
								}
								if (t.size / m.duration < a.lb) {
									const e = s.fbt._("Videos must have a bitrate of {min_bitrate}KB/s or larger.", [s.fbt._param("min_bitrate", (a.lb / a.U).toString())], {
										hk: "1ehgDE"
									});
									return A(a.T, e)
								}
								c.height = m.height, c.width = m.width, c.videoDuration = m.duration, c.videoFirstFrameUrl = m.firstFrame.dataUrl
							}
							return {
								metadata: c
							}
						}(i(), e, u);
						if (h || !_) return {
							error: h
						};
						o(Object(l.m)({
							key: t,
							metadata: {
								fileSource: n,
								..._
							}
						})), w = !0, r && r();
						const v = e.name,
							O = await (async (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
								endpoint: `${e.apiUrl}/api/media/asset.json`,
								method: a.jb.POST,
								data: {
									filepath: t,
									mimetype: n
								}
							}))(c(), v, _.mimetype);
						return O.ok ? (C = O.body.asset.asset_id, {
							uploadLease: O.body.args
						}) : {
							error: O.error || void 0
						}
					}, !0)), N(!1), i().uploads[t] || null
				}, F = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().uploads[e];
					o && !Object(_.c)(o) && await t(L(o.file, o.key, o.metadata.fileSource, void 0))
				}, U = (e, t, n) => async (r, a) => {
					const d = e.map((e, s) => new Promise(async s => {
							const a = Object(_.d)(n, o()().slice(-6));
							await r(L(e, a, t, () => s({
								uploadKey: a,
								isValid: !0
							}))), s({
								uploadKey: a,
								isValid: !1
							})
						})),
						l = await Promise.all(d),
						u = l.map(e => e.uploadKey);
					return r(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
						return async (n, r) => {
							const {
								uploads: o
							} = r(), a = e.map(e => o[e]).filter(e => e.status === _.a.FAILED && !e.metadata.mimetype).map(e => e.error), d = a.length > t ? t - 1 : a.length, l = a.length - d;
							a.slice(0, d).forEach(e => n(Object(c.f)({
								duration: c.a,
								kind: C.b.Error,
								text: Object(i.a)(e)
							}))), l > 0 && n(Object(c.f)({
								duration: c.a,
								kind: C.b.Error,
								text: s.fbt._({
									"*": "Couldn't add {number} more files",
									_1: "Couldn't add 1 more file"
								}, [s.fbt._plural(l, "number")], {
									hk: "2fQwvl"
								})
							}))
						}
					}(u)), l.filter(e => e.isValid).map(e => e.uploadKey)
				}, B = (e, t) => async (n, r) => {
					const o = r(),
						a = Object(I.W)(o),
						{
							items: i
						} = a,
						d = !i.length && 1 === e.length,
						m = Object(I.N)(o) && !d;
					let p = !1,
						b = e;
					if (m) {
						if (Object(j.x)(a)) return void n(Object(c.f)({
							kind: C.b.Error,
							text: s.fbt._("Please remove the existing video first. Videos aren't supported within galleries yet.", null, {
								hk: "3lGxp4"
							})
						}));
						b.some(e => Object(g.m)(e.type)) && n(Object(c.f)({
							duration: c.a,
							kind: C.b.Error,
							text: s.fbt._("Videos arent supported within galleries...yet", null, {
								hk: "9Cl20"
							})
						})), b = b.filter(e => Object(g.l)(e.type));
						const e = Math.max(0, u.b - i.length);
						b.length > e && (n(Object(c.f)({
							kind: C.b.Error,
							text: s.fbt._("You have hit the limit of {images_limit} images", [s.fbt._param("images_limit", `${u.b}`)], {
								hk: "6M4kX"
							})
						})), b = b.slice(0, e))
					} else b = b.slice(0, 1), p = !0, n(Object(l.j)(D, !0));
					const h = await n(U(b, t, D));
					if (!h.length) return;
					const f = h.map(e => ({
							uploadKey: e,
							caption: "",
							url: ""
						})),
						_ = 0 === i.length;
					n(Object(w.d)({
						...a,
						items: p ? f : [...i, ...f],
						selectedKey: _ ? h[0] : h[h.length - 1]
					}))
				}
		},
		"./src/reddit/actions/postCreation/submit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return H
			})), n.d(t, "a", (function() {
				return Q
			})), n.d(t, "b", (function() {
				return X
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/telemetry/index.ts"),
				a = n("./src/reddit/actions/crosspostSubredditRec/index.ts"),
				i = n("./src/reddit/actions/governance/index.ts"),
				d = n("./src/reddit/actions/pages/subreddit.ts"),
				c = n("./src/reddit/actions/postDraft.ts"),
				l = n("./src/reddit/actions/scheduledPosts/index.ts"),
				u = n("./src/reddit/actions/urlRequested.ts"),
				m = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				p = n("./src/config.ts"),
				b = n("./src/lib/convertToCamelCase/index.ts"),
				h = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/reddit/endpoints/post/create.ts");
			var g = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				_ = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				v = n("./src/reddit/featureFlags/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				x = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				j = n("./src/reddit/models/Poll/index.ts"),
				C = n("./src/reddit/models/PostCreationForm/index.ts"),
				k = n("./src/reddit/models/User/index.ts"),
				I = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				w = n("./src/reddit/selectors/postDraft.ts"),
				T = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/models/Post/index.ts"),
				R = n("./src/reddit/models/ScheduledPost/index.ts"),
				A = n("./src/reddit/actions/postCreation/constants.ts"),
				M = n("./src/reddit/actions/postCreation/general.ts"),
				D = n("./src/reddit/actions/postCreation/mediaUpload.ts");
			const L = Object(r.a)(A.w),
				F = Object(r.a)(A.P),
				U = Object(r.a)(A.o),
				B = Object(r.a)(A.y),
				G = Object(r.a)(A.db),
				H = Object(r.a)(A.J),
				W = Object(r.a)(A.a),
				q = Object(r.a)(A.F),
				V = e => `/r/${e}/about/${R.s}`,
				z = (e, t) => {
					const n = e || {
							duration: s.B,
							options: []
						},
						{
							govType: r,
							newSubreddit: o,
							newTopMod: a
						} = Object(S.u)(t),
						i = {
							...n
						};
					return r && (i.type = r), i.type === j.a.ReplaceTopMod ? (i.params = {
						userName: a
					}, i.options = j.f[j.a.ReplaceTopMod]()) : i.type === j.a.Spinoff ? (i.params = {
						subreddit: o
					}, i.options = j.f[j.a.Spinoff](o)) : i.options = i.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text), i
				},
				K = e => {
					const t = e.uploads,
						n = Object(S.W)(e),
						r = Object(S.a)(e),
						o = Object(S.gb)(e);
					if (r === s.Wb.POST) return m.a.getPendingThumbnailUploads(o, t);
					if (r === s.Wb.MEDIA && n && n.items.length) {
						const {
							video: e
						} = n.items[0];
						if (e && e.thumbnail && !t[C.n]) return [{
							...e.thumbnail,
							uploadKey: C.n
						}]
					}
				},
				Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o, i = r();
					const {
						pending: d
					} = i.creations.api.post.submit, l = Object(w.g)(i);
					if (d || l) return;
					n(q(e)), i = r();
					const u = Object(S.a)(i),
						m = v.d.rteVideoPoster(i),
						p = K(i),
						b = u === s.Wb.MEDIA;
					p && (m || b) && (await n(D.f(p)), K(r())) || (e === C.r.Draft ? await n(Object(c.r)(t.draftId)) : e === C.r.ScheduledPost && Object(T.r)(i) ? await n(J(t)) : e === C.r.ScheduledPost ? await n(Y(t)) : await n(X(t)))
				}, J = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const a = n(),
						i = Object(S.db)(a),
						d = Object(S.eb)(a, e),
						c = Object(S.h)(a),
						m = Object(T.r)(a);
					if (!(d && c.id && i && Object(x.f)(m))) return;
					const p = c.id,
						b = Object(T.a)(a, {
							subredditId: p,
							scheduledPostId: m
						});
					if (b && Object(o.a)(Object(y.r)(b)(a)), t(L(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					const {
						isPoll: h,
						polls: f
					} = Object(S.u)(a), v = z(f, a), O = {
						...Object(g.e)({
							poll: h ? v : void 0,
							submission: d,
							schedule: i,
							subredditId: c.id,
							scheduledPostId: m
						})
					}, E = await Object(_.a)(r(), O);
					if (E.ok) return t(Object(l.e)({
						subredditId: c.id
					})), void t(Object(u.a)(V(c.name), !1));
					const j = E.error;
					t(U(j))
				}, Y = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const a = n(),
						i = Object(S.db)(a),
						d = Object(S.eb)(a, e),
						c = Object(S.h)(a),
						m = Object(T.b)(a);
					if (!d || !c.id || !i) return;
					if (t(L(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					const {
						isPoll: p,
						polls: b
					} = Object(S.u)(a), h = z(b, a), f = {
						duration: h.duration,
						options: h.options
					}, _ = {
						...Object(g.d)({
							poll: p ? f : void 0,
							submission: d,
							schedule: i,
							subredditId: c.id
						}),
						creationToken: m
					}, v = await Object(g.a)(r(), _);
					if (v.ok) {
						t(Object(l.e)({
							subredditId: c.id
						}));
						const e = v.body.data.createScheduledPost.scheduledPost;
						return e && Object(o.a)(Object(y.o)(Object(O.d)(e))(a)), void t(Object(u.a)(V(c.name), !1))
					}
					const x = v.error;
					t(U(x))
				}, X = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const c = n(),
						l = Object(S.eb)(c, e),
						{
							isPoll: m,
							polls: g
						} = Object(S.u)(c),
						_ = z(g, c);
					if (!l) return;
					if (t(L(l)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					let O;
					const x = m && v.d.spPolls(c);
					if ((O = x ? await
							function(e, t, n) {
								const r = t.destSubreddit.id;
								return Object(h.a)(e, {
									method: s.jb.POST,
									endpoint: `${p.a.metaUrl}/polls/${r}`,
									type: "json",
									data: {
										poll: n,
										subredditId: r,
										...Object(b.a)(Object(f.d)(t))
									}
								}).then(async e => {
									const n = e.ok ? {
											...e,
											body: {
												json: {
													data: e.body
												}
											}
										} : e,
										s = await Object(f.e)(n, t);
									if (s.ok) {
										return {
											body: {
												...s.body,
												poll: e.body.poll
											},
											ok: !0,
											status: e.status
										}
									}
									return {
										error: s.body,
										ok: !1,
										status: e.status
									}
								})
							}(o(), l, _) : m ? await Object(f.b)(o(), {
								...l,
								kind: C.p.POLL,
								poll: _
							}) : l.kind === C.p.GALLERY ? await Object(f.a)(o(), l) : await Object(f.c)(o(), l)).ok) {
						const e = Object(N.k)(c),
							n = O.body;
						t(F({
							draftId: l.draftId,
							response: n
						})), x && t(Object(i.c)({
							poll: n.poll
						}));
						const s = Object(I.b)(c);
						l.kind !== C.p.LINK && l.kind !== C.p.RICH_TEXT && l.kind !== C.p.MARKDOWN || m || !s || t(Object(a.c)());
						const r = (n.path || `/user/${Object(k.e)(e)}/posts`).replace(/^\/r\/u_/, "/user/");
						t(Object(d.subredditInvalidateListing)(l.destSubreddit.name)), t(Object(u.a)(r, !1))
					} else {
						if (m) {
							const e = O.error;
							t(B(e))
						}
						const e = O.error;
						e.type === s.I.BAD_CAPTCHA_ERROR ? t(W()) : e.type === s.I.VALIDATION_ERROR ? t(G(e)) : e.type === s.I.SUBMIT_VALIDATION_ERROR ? t(H(e)) : t(U(e))
					}
					const y = Object(M.o)(l.kind),
						j = O.ok && O.body && O.body.id && Object(P.u)(O.body.id),
						w = n();
					E.B(w, y, j, e.correlationId)
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "c", (function() {
				return k
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/filterQueryParams/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/pages/postCreation.ts"),
				l = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = n("./src/reddit/helpers/name/index.ts"),
				m = n("./src/reddit/models/PostCreationForm/index.ts"),
				p = n("./src/reddit/routes/postCreation/index.ts"),
				b = n("./src/reddit/routes/postCreation/constants.ts"),
				h = n("./src/reddit/selectors/postCreations.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/actions/postCreation/constants.ts"),
				v = n("./src/reddit/actions/postCreation/general.ts");
			const O = Object(i.a)(_.N),
				x = Object(i.a)(_.O),
				E = Object(i.a)(_.M),
				y = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r, i = s();
					const {
						name: p,
						isProfile: b
					} = e, _ = Object(f.e)(i), v = _ && !b && Object(u.a)(_.name, p), x = i.creations.api.subreddit.change.pending;
					if (v || x) return;
					const E = Object(l.w)(t);
					if (!p) return void n(j(e, E));
					n(O(e));
					const y = b ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await n(Object(c.postCreationPageDataRequested)(y)), b || !Object(h.C)(i)) return n(j(e, E));
					const C = e.allowedPostTypes || Object(g.y)(s(), {
						subredditName: p
					});
					if (!C) return void n(j(e, E));
					let k;
					i = s();
					const I = Object(h.mb)(i),
						S = Object(h.C)(i);
					if (I === o.Wb.MEDIA && S) {
						const e = Object(h.W)(i),
							t = Object(m.x)(e),
							n = Object(h.N)(i) && e.items.length > 1,
							s = !t && !n;
						if (n && !C.galleries) k = m.q.GalleryWillBeRemovedGalleryNotAllowed;
						else if (s && !C.images) k = m.q.ImageWillBeRemoved;
						else if (t && !C.videos) {
							const t = i.uploads[e.items[0].uploadKey],
								n = t && t.metadata.videoDuration || 0;
							C.images ? n > o.gb && (k = m.q.VideoWillBeRemovedTooLongForGif) : k = m.q.VideoWillBeRemovedMediaNotAllowed
						}
					}
					n(k ? Object(d.i)(k) : j({
						...e,
						allowedPostTypes: C
					}, E))
				}, j = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, a) => {
						const {
							name: i,
							isProfile: d
						} = e, c = a().platform.currentPage, l = c.queryParams, u = d ? p.b : p.c;
						let m = "";
						m = i ? u(i) : b.b, m = Object(r.a)(m, {
							...l,
							draft: t || l.draft
						}), (t || c.url.toLowerCase() !== m.toLowerCase()) && (o(x(e)), n && o(Object(v.t)(!0)), o(Object(v.i)()), o(Object(s.c)(m)))
					}
				}, C = e => async (t, n) => {
					const o = n().platform.currentPage,
						a = o.queryParams,
						i = Object(r.a)(o.url, {
							...a,
							collection: e
						});
					t(Object(s.c)(i))
				}, k = () => async (e, t) => {
					const n = t().platform.currentPage,
						r = Object(a.a)(n.url, ["collection"]);
					e(Object(s.c)(r))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "p", (function() {
				return D
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "i", (function() {
				return U
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "k", (function() {
				return G
			})), n.d(t, "h", (function() {
				return H
			})), n.d(t, "n", (function() {
				return W
			})), n.d(t, "s", (function() {
				return Y
			})), n.d(t, "r", (function() {
				return X
			})), n.d(t, "g", (function() {
				return Z
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "o", (function() {
				return ie
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				i = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/models/StructuredStyles/index.ts");
			var p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/name/index.ts"),
				h = n("./src/reddit/models/PostDraft/index.ts"),
				f = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				g = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				_ = n("./src/reddit/models/Subreddit/index.ts");
			const v = e => {
				let t = e.drafts.reduce((e, t) => {
					const n = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: h.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: h.b.Markdown,
							body: e.body || void 0
						} : {
							kind: h.b.RichText,
							body: e.body || void 0
						}, {
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || "",
							...t
						}
					})(t);
					return e.postDraftIds.push(n.id), e.postDrafts[n.id] = n, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === _.f.User) {
						const n = Object(f.a)(t, Object(b.h)(t.display_name_prefixed));
						e.profiles[n.id] = n
					} else {
						const n = Object(g.a)(t);
						e.subreddits[n.id] = n
					}
					return e
				}, t)
			};
			var O = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				x = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/models/Toast/index.ts"),
				j = n("./src/reddit/models/User/index.ts"),
				C = n("./src/reddit/selectors/postCreations.ts"),
				k = n("./src/reddit/selectors/postDraft.ts"),
				I = n("./src/reddit/selectors/profile.ts"),
				S = n("./src/reddit/selectors/subreddit.ts"),
				w = n("./src/reddit/selectors/user.ts");
			const T = "POST_DRAFT__LIST_PENDING",
				N = "POST_DRAFT__LIST_LOADED",
				P = "POST_DRAFT__LIST_FAILED",
				R = Object(o.a)(T),
				A = Object(o.a)(N),
				M = Object(o.a)(P),
				D = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t();
					if (!Object(w.k)(o) || Object(k.b)(o)) return;
					e(R());
					const a = await (e => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/drafts.json`,
						method: s.jb.GET
					}))(r());
					a.ok ? e(A(v(a.body))) : e(M(a.error))
				}, L = "POST_DRAFT__SAVE_DRAFT_PENDING", F = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", U = "POST_DRAFT__SAVE_DRAFT_FAILED", B = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", G = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", H = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", W = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", q = Object(o.a)(L), V = Object(o.a)(F), z = Object(o.a)(U), K = Object(o.a)(B), Q = Object(o.a)(G), J = Object(o.a)(H), Y = Object(o.a)(W), X = e => async (t, n, o) => {
					let {
						apiContext: a
					} = o;
					const c = n(),
						m = Object(k.g)(c),
						b = Object(C.bb)(c);
					if (m || b) return;
					const h = Object(k.h)(c, e);
					if (!h) return;
					t(q(h)), E.g(c, h);
					const f = await ((e, t, n) => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/draft`,
						method: n ? s.jb.PUT : s.jb.POST,
						data: Object(O.a)(t)
					}).then(e => e.body.fields && Object(x.w)(e.body.fields[0]) ? {
						...e,
						body: {},
						error: {
							type: s.I.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					} : e))(a(), h, e);
					if (f.ok) {
						const {
							id: n,
							draftsCount: s
						} = Object(O.c)(f.body);
						t(V({
							draftId: n,
							draftsCount: s
						})), e || t(Object(i.a)(h.destSubreddit, n, !1))
					} else {
						const e = f.error;
						e.type === s.I.BAD_CAPTCHA_ERROR ? t(J()) : e.type === s.I.VALIDATION_ERROR ? t(K(e)) : e.type === s.I.SUBMIT_VALIDATION_ERROR ? t(Q(e)) : t(z(e)), t(Object(d.f)({
							duration: d.a,
							kind: y.b.Error,
							text: Object(r.a)(e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(o.a)(Z), ee = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t($(e));
					let o = x.f;
					const a = n();
					if (e.subredditId) {
						const t = Object(S.U)(a, {
								subredditId: e.subredditId
							}),
							n = Object(I.p)(a, {
								profileId: e.subredditId
							}),
							s = Object(w.k)(a);
						t ? o = {
							isProfile: !1,
							name: t.name
						} : n && s && (o = {
							isProfile: !0,
							name: Object(j.e)(s)
						})
					}
					await t(Object(i.a)(o, e.id, !1));
					const d = Object(k.h)(n(), e.id);
					d && E.j(n(), d)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", ne = "POST_DELETE_DRAFT_FAILED", se = "POST_DELETE_DRAFT_PENDING", re = Object(o.a)(te), oe = Object(o.a)(ne), ae = Object(o.a)(se), ie = (e, t) => async (n, o, i) => {
					let {
						apiContext: p
					} = i;
					const b = o();
					if (Object(k.a)(b, e)) return;
					const h = Object(k.d)(b, {
						draftId: e
					});
					h && E.h(b, h), n(ae({
						draftId: e
					}));
					const f = await (async (e, t) => Object(l.a)(Object(u.a)(e, [m.g]), {
						endpoint: `${e.apiUrl}/api/v1/draft?draft_id=${t}`,
						method: s.jb.DELETE
					}))(p(), e);
					if (f.ok) {
						const {
							draftsCount: s
						} = Object(O.c)(f.body);
						n(re({
							draftId: e,
							draftsCount: s
						}));
						const r = Object(c.w)(t);
						e === r && n(Object(a.q)(!0, t))
					} else {
						const t = f.error;
						n(oe({
							draftId: e,
							apiError: t
						})), n(Object(d.f)({
							duration: d.a,
							kind: y.b.Error,
							text: Object(r.a)(t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "d", (function() {
				return N
			})), n.d(t, "l", (function() {
				return M
			})), n.d(t, "k", (function() {
				return D
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "i", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				a = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/models/Flair/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/postFlair.ts"),
				p = n("./src/reddit/selectors/subreddit.ts");
			const b = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				h = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				f = Object(r.a)(b),
				g = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				_ = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				v = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				O = Object(r.a)(_),
				x = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				y = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				j = Object(r.a)(E),
				C = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				k = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				S = Object(r.a)(k),
				w = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				T = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				N = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				P = Object(r.a)(T),
				R = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				A = Object(r.a)(N),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(p.U)(a, {
							subredditId: e
						}).name;
					n(h());
					const c = await Object(d.k)(o(), i, t);
					if (c.ok) {
						n(f({
							subredditId: e,
							isEnabled: t
						}))
					} else n(g());
					return c.ok
				}, D = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(p.U)(a, {
							subredditId: e
						}).name;
					n(v());
					const c = await Object(d.j)(o(), t, l.d.LinkFlair, i);
					if (c.ok) {
						n(O({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(x());
					return c.ok
				}, L = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const m = r(),
						b = Object(p.U)(m, {
							subredditId: t
						}).name;
					n(y());
					const h = await Object(d.f)(c(), e, b, l.d.LinkFlair);
					let f = h.ok && !(h.body && !1 === h.body.success);
					if (f) {
						const s = h.body;
						if (n(j({
								subredditId: t,
								template: s
							})), s.id) {
							const r = e.styleTemplate,
								o = m.structuredStyles.flairTemplate.models[s.id];
							r ? f = await n(Object(a.d)(t, s.id, r)) : o && (f = await n(Object(a.c)(t, s.id)))
						}
					}
					if (f) {
						const e = Object(i.e)(s.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), u.b.SuccessMod);
						n(Object(i.f)(e))
					} else {
						n(C());
						const r = Object(i.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), L(e, t));
						n(Object(i.f)(r))
					}
					return f
				}, F = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = r(),
						l = Object(p.U)(c, {
							subredditId: t
						}).name;
					if (n(I()), (await Object(d.b)(a(), e, l)).ok) {
						n(S({
							subredditId: t,
							templateId: e
						}));
						const r = Object(i.e)(s.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), u.b.SuccessMod);
						n(Object(i.f)(r))
					} else {
						n(w());
						const r = Object(i.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), F(e, t));
						n(Object(i.f)(r))
					}
				}, U = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const c = r(),
						b = Object(m.d)(c, {
							subredditId: t
						}).templateIds,
						h = Object(p.U)(c, {
							subredditId: t
						}).name;
					if (n(P({
							subredditId: t,
							templateIds: e
						})), (await Object(d.e)(a(), h, l.d.LinkFlair, e)).ok) {
						n(R());
						const e = Object(i.e)(s.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), u.b.SuccessMod);
						n(Object(i.f)(e))
					} else {
						n(A({
							subredditId: t,
							templateIds: b
						}));
						const r = Object(i.e)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), U(e, t));
						n(Object(i.f)(r))
					}
				}, B = e => {
					let {
						post: t,
						previewFlair: n,
						selectedTemplateId: s
					} = e;
					return async (e, r, a) => {
						let {
							apiContext: i
						} = a;
						const l = t.flair.filter(e => !Object(c.q)(e.type));
						if (n && l.unshift(n), e(Object(o.S)({
								[t.id]: {
									flair: l
								}
							})), n) {
							const e = Object(c.g)(n);
							Object(d.h)(i(), t.id, s, e)
						} else Object(d.h)(i(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "c", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/forEach.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/isEqual.js"),
				a = n.n(o),
				i = n("./node_modules/lodash/values.js"),
				d = n.n(i),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/actions/imageUploads.ts"),
				u = n("./src/reddit/helpers/media/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts");
			var f = n("./src/reddit/helpers/trackers/blade.ts"),
				g = n("./src/reddit/models/Image/index.tsx"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/telemetry/index.ts");
			const O = e => {
					let {
						subredditId: t,
						flairId: n,
						imageKey: s,
						imageData: r
					} = e;
					return async (e, o, a) => {
						const i = o(),
							d = Object(_.U)(i, {
								subredditId: t
							});
						if (!d) return !1;
						e(Object(l.k)(r));
						const c = await (async (e, t, n, s, r, o) => Object(p.a)(Object(b.a)(e, [h.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_style_asset_upload_s3/${n}`,
							method: m.jb.POST,
							data: {
								filepath: s,
								imagetype: r,
								mimetype: o
							}
						}))(a.apiContext(), d.name, n, r.file.name, s, await Object(u.h)(r.file));
						let f = !1;
						try {
							const t = await Object(l.g)(o(), c, r, g.a.FlairTemplates);
							t && e(Object(l.j)(t)), f = !0
						} catch (v) {
							if (v instanceof Error) throw v;
							e(Object(l.i)(v))
						}
						return f
					}
				},
				x = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				E = Object(c.a)(x),
				y = (e, t, n) => async (s, o, i) => {
					const {
						apiContext: c
					} = i;
					let u = o();
					const {
						pendingImages: x,
						...y
					} = n;
					let j = y;
					const C = Object(_.U)(u, {
						subredditId: e
					});
					if (!C) return !1;
					const k = u.structuredStyles.flairTemplate.models[t];
					if (k && a()(k, j)) return !0;
					if (x) {
						const n = [];
						if (r()(x, (r, o) => {
								r && n.push(s(O({
									flairId: t,
									imageData: Object(g.m)(r),
									imageKey: o,
									subredditId: e
								})))
							}), !(await Promise.all(n)).every(e => e)) return !1;
						j = ((e, t, n) => {
							const s = {
								...e
							};
							return r()(t, (e, t) => {
								const r = e && n.imageUploads[e.id];
								r && r.kind === g.b.TempUploaded && (s[t] = r.url)
							}), s
						})(j, x, o())
					}
					u = o();
					let I = null,
						S = null;
					const w = [];
					try {
						(I = await Object(l.f)(u, g.a.FlairTemplates)) && (S = Object(l.m)(I)(s, o, i), w.push(...d()(I.imagesByKey)))
					} catch (R) {
						return !1
					}
					const T = await (async (e, t, n, s) => Object(p.a)(Object(b.a)(e, [h.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.jb.PUT,
							data: s
						}))(c(), C.name, t, j),
						N = k ? "edit_post_flair_template" : "save_post_flair_template",
						P = Object(f.e)(u, N);
					if (T.ok) {
						let e;
						if (S) try {
							await S, e = ((e, t, n) => {
								const s = {
									...e
								};
								return t.forEach(e => {
									const t = n.imageUploads[e.id];
									t && t.kind === g.b.Uploaded && (e.url === s.postBackgroundImage ? s.postBackgroundImage = t.url : e.url === s.postPlaceholderImage && (s.postPlaceholderImage = t.url))
								}), s
							})(j, w, o())
						} catch (R) {
							e = null
						} else e = j;
						s(E({
							flairId: t,
							template: e || j
						}))
					} else I && I.websocket.close();
					return Object(v.a)({
						...P,
						actionInfo: {
							...P.actionInfo,
							success: T.ok
						}
					}), T.ok
				}, j = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", C = Object(c.a)(j), k = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(_.U)(a, {
							subredditId: e
						});
					if (!i) return !1;
					const d = await (async (e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.jb.DELETE
						}))(o(), i.name, t),
						c = Object(f.e)(a, "delete_flair_template");
					return d.ok && n(C({
						flairId: t
					})), Object(v.a)({
						...c,
						actionInfo: {
							...c.actionInfo,
							success: d.ok
						}
					}), d.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return x
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				a = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				i = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				d = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const c = Object(s.a)(o.w),
				l = Object(s.a)(o.x),
				u = Object(s.a)(o.G),
				m = (Object(s.a)(o.H), Object(s.a)(o.I)),
				p = Object(s.a)(o.T),
				b = e => async (t, n) => {
					if (Object(i.a)(n())) return t(h(e))
				}, h = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(d.k)(n()),
						i = Object(d.m)(n(), {
							subreddit: e
						}),
						p = i && i.lastUpdated || 0,
						b = 1e3 * o.global.rpan_config_refresh_rate;
					if (o.isPending || o.isPermanentlyCanceled || Date.now() < p + b) return;
					t(u());
					const h = await Object(a.c)(r(), e);
					if (!h.ok) return void t(m());
					const f = h.body;
					t(c({
						...f.global,
						lastUpdated: Date.now()
					})), t(l({
						name: e,
						config: {
							...f.listing_info,
							lastUpdated: Date.now()
						}
					}))
				}, f = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					t(p()), await Object(a.h)(r(), e)
				}, g = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					n().posts.models[e] || await t(Object(r.M)(e))
				}, _ = Object(s.a)(o.v), v = Object(s.a)(o.J), O = Object(s.a)(o.K), x = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (Object(d.h)(r)) return;
					e(v());
					const o = await Object(a.d)(s());
					o.ok && o.body && o.body.data ? e(_({
						subreddits: o.body.data
					})) : e(O({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/automute.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const a = Object(s.a)(o.r),
				i = Object(s.a)(o.F),
				d = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const d = await Object(r.a)(o(), e);
					d && d.ok ? t(a({
						streamId: e,
						level: d.body.data.auto_mute_status.level
					})) : t(i(e))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/streams.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "f", (function() {
				return j
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/query-string/index.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				d = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				c = n("./src/reddit/selectors/PublicAccessNetwork/api.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const u = new Set(["home", "r/popular"]),
				m = e => {
					const t = location && location.search || "",
						n = r.a.parse(t);
					u.has(e) && (n.related = e);
					const s = r.a.stringify(n);
					return s ? `?${s}` : ""
				},
				p = Object(o.a)(a.N),
				b = Object(o.a)(a.y),
				h = Object(o.a)(a.O),
				f = Object(o.a)(a.z),
				g = Object(o.a)(a.M),
				_ = Object(o.a)(a.L),
				v = Object(o.a)(a.t),
				O = Object(o.a)(a.u),
				x = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(d.g)(e),
						a = n();
					if (Object(c.d)(a, o)) return;
					t(p(o));
					const l = await Object(i.e)(r(), o),
						u = Date.now();
					if (l.ok && l.body && l.body.data) {
						const e = l.body.data;
						t(b({
							model: e,
							utcTimeStamp: u
						}))
					} else t(k({
						streamId: o,
						error: l.error,
						utcTimeStamp: u
					}))
				}, E = (e, t) => async (n, s) => n(y(e, t)), y = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = s();
					if (Object(c.f)(a)) return;
					n(h());
					const d = await Object(i.f)(o(), e, t),
						l = Date.now();
					if (d.ok && d.body && d.body.data) {
						const t = d.body.data;
						n(f({
							listingName: e,
							models: t,
							utcTimeStamp: l
						}))
					} else n(I({
						error: d.error,
						utcTimeStamp: l
					}))
				}, j = (e, t) => async (n, s) => n(C(e, t)), C = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = s();
					if (Object(c.f)(a)) return;
					n(h());
					const d = Date.now(),
						u = e.replace("r/", ""),
						m = Object(l.F)(a, u),
						p = await Object(i.b)(o(), {
							subredditId: m,
							options: t
						}),
						b = p.body;
					p.ok && b && b.data || n(I({
						error: p.error,
						utcTimeStamp: d
					}));
					const g = b.data.liveVideoFeed.posts.edges.map(e => (async (e, t) => {
							const n = await Object(i.e)(e, t),
								s = Date.now(),
								r = n.body;
							return r && r.data ? r.data : void k({
								streamId: t,
								error: n.error,
								utcTimeStamp: s
							})
						})(o(), e.node.id)),
						_ = (await Promise.all(g)).filter(e => void 0 !== typeof e);
					n(f({
						listingName: e,
						models: _,
						utcTimeStamp: d
					}))
				}, k = e => async t => {
					t(g(e))
				}, I = e => async t => {
					t(_(e))
				}
		},
		"./src/reddit/actions/recentSubreddits/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			const s = "SET_RECENT_SUBREDDITS",
				r = "SUBREDDIT_VISITED",
				o = "SUBREDDIT_SAVED",
				a = "COPY_SAVED_SUBREDDITS",
				i = "COPY_SAVED_ID_SUBREDDITS",
				d = 10
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tabBadging.ts"),
				a = n("./src/reddit/endpoints/me/index.ts"),
				i = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				d = n("./src/reddit/helpers/trackers/screenview.ts");
			const c = "REDDIT_EMBED_LOADED",
				l = "REDDIT_EMBED_FAILED",
				u = Object(r.a)("REDDIT_EMBED_PENDING"),
				m = Object(r.a)(c),
				p = Object(r.a)(l),
				b = (e, t) => async (e, n, s) => {
					let {
						apiContext: r
					} = s;
					const d = n();
					e(u());
					const c = await Object(a.a)(r());
					c.ok && c.body ? !t || c.body.account ? (e(m(c.body)), e(Object(o.d)()), h(d)) : Object(i.a)(e, d) : e(p(c.error))
				}, h = e => {
					e.platform.currentPage && e.platform.currentPage.routeMatch && e.platform.currentPage.routeMatch.route && e.platform.currentPage.routeMatch.route.meta && e.platform.currentPage.routeMatch.route.meta.name && e.platform.currentPage.routeMatch.route.meta.name === s.Nb.INBOX_PAGES && Object(d.g)(e)
				}
		},
		"./src/reddit/actions/removalReasons/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "removalReasonsPending", (function() {
				return Z
			})), n.d(t, "removalReasonsLoaded", (function() {
				return $
			})), n.d(t, "removalReasonsFailed", (function() {
				return ee
			})), n.d(t, "removalReasonsRequested", (function() {
				return te
			})), n.d(t, "removalReasonAddedPending", (function() {
				return ne
			})), n.d(t, "removalReasonAddedSuccess", (function() {
				return se
			})), n.d(t, "removalReasonAddedFailed", (function() {
				return re
			})), n.d(t, "addRemovalReason", (function() {
				return oe
			})), n.d(t, "editRemovalReasonPending", (function() {
				return ae
			})), n.d(t, "editRemovalReasonSuccess", (function() {
				return ie
			})), n.d(t, "editRemovalReasonFailed", (function() {
				return de
			})), n.d(t, "editRemovalReason", (function() {
				return ce
			})), n.d(t, "deleteRemovalReasonPending", (function() {
				return le
			})), n.d(t, "deleteRemovalReasonSuccess", (function() {
				return ue
			})), n.d(t, "deleteRemovalReasonFailed", (function() {
				return me
			})), n.d(t, "deleteRemovalReason", (function() {
				return pe
			})), n.d(t, "removedItemsSelected", (function() {
				return be
			})), n.d(t, "fetchReasonsAndOpenModal", (function() {
				return he
			})), n.d(t, "removalReasonSubmittedPending", (function() {
				return fe
			})), n.d(t, "removalReasonSubmittedSuccess", (function() {
				return ge
			})), n.d(t, "removalReasonSubmittedFailed", (function() {
				return _e
			})), n.d(t, "removalReasonMessagePending", (function() {
				return ve
			})), n.d(t, "removalReasonPrivateMessageSuccess", (function() {
				return Oe
			})), n.d(t, "removalReasonPublicMessageSuccess", (function() {
				return xe
			})), n.d(t, "removalReasonMessageFailed", (function() {
				return Ee
			})), n.d(t, "submitRemovalReason", (function() {
				return ye
			})), n.d(t, "submitBulkRemovalReason", (function() {
				return je
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./node_modules/redux/es/redux.js");
			const a = "REMOVALREASONS__LOAD_SUCCESS",
				i = "REMOVALREASONS__ADD_PENDING",
				d = "REMOVALREASONS__ADD_SUCCESS",
				c = "REMOVALREASONS__ADD_FAILED",
				l = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				m = "REMOVALREASONS__EDIT_FAILED",
				p = "REMOVALREASONS__DELETE_PENDING",
				b = "REMOVALREASONS__DELETE_SUCCESS",
				h = "REMOVALREASONS__DELETE_FAILED";
			var f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REMOVALREASONS__LOAD_PENDING":
					case a:
					case i:
					case d:
					case l:
					case u:
					case p:
					case b:
						return null;
					case "REMOVALREASONS__LOAD_FAILED":
					case c:
					case m:
					case h:
						return t.payload;
					default:
						return e
				}
			};
			var g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__LOAD_PENDING":
						case i:
						case l:
						case p:
							return !0;
						case a:
						case "REMOVALREASONS__LOAD_FAILED":
						case d:
						case c:
						case u:
						case m:
						case b:
						case h:
							return !1;
						default:
							return e
					}
				},
				_ = Object(o.c)({
					error: f,
					pending: g
				});
			const v = {};
			var O = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a: {
						const {
							response: n
						} = t.payload, {
							data: s
						} = n;
						return {
							...e,
							...s
						}
					}
					case d:
					case u: {
						const {
							reason: n
						} = t.payload;
						return {
							...e,
							[n.id]: n
						}
					}
					case b: {
						const {
							reasonId: n
						} = t.payload, {
							[n]: s,
							...r
						} = e;
						return r
					}
					default:
						return e
				}
			};
			const x = {};
			var E = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							order: r
						} = s;
						return {
							...e,
							[n]: r
						}
					}
					case d: {
						const {
							subredditId: n,
							reason: s
						} = t.payload;
						return {
							...e,
							[n]: [...e[n], s.id]
						}
					}
					case b: {
						const {
							subredditId: n,
							reasonId: s
						} = t.payload, r = [...e[n]].filter(e => e !== s);
						return {
							...e,
							[n]: r
						}
					}
					default:
						return e
				}
			};
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__REMOVEDITEMS_SELECTED": {
							const {
								subredditId: e,
								itemIds: n
							} = t.payload;
							return {
								itemIds: n,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				j = Object(o.c)({
					api: _,
					models: O,
					reasonOrder: E,
					removedItemIds: y
				}),
				C = n("./src/lib/constants/index.ts"),
				k = n("./src/lib/makeActionCreator/index.ts"),
				I = n("./src/lib/makeCommentsPageKey/index.ts"),
				S = n("./src/lib/makeDraftKey/index.ts"),
				w = n("./src/reddit/actions/bulkActions/index.ts"),
				T = n("./src/reddit/actions/comment/index.ts"),
				N = n("./src/reddit/actions/comment/authoring.ts"),
				P = n("./src/reddit/actions/comment/moderation.ts"),
				R = n("./src/reddit/actions/modal.ts"),
				A = n("./src/reddit/actions/post.ts"),
				M = n("./src/reddit/actions/toaster.ts"),
				D = n("./src/reddit/constants/modals.ts"),
				L = n("./src/lib/makeApiRequest/index.ts"),
				F = n("./src/lib/omitHeaders/index.ts"),
				U = n("./src/reddit/constants/headers.ts"),
				B = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const G = (e, t) => Object(L.a)(Object(F.a)(e, [U.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/removal_reasons/`,
					method: C.jb.POST,
					type: "json",
					data: {
						item_ids: t.itemIds,
						reason_id: t.reasonId,
						mod_note: t.modNote
					}
				}),
				H = (e, t, n) => Object(L.a)(Object(F.a)(e, [U.a]), {
					endpoint: Object(B.a)(`${e.apiUrl}/api/v1/modactions/removal_${n}_message/`),
					method: C.jb.POST,
					type: "json",
					data: t
				});
			var W = n("./src/reddit/helpers/isPost.ts"),
				q = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				V = n("./src/reddit/helpers/routeKey/index.ts"),
				z = n("./src/reddit/models/ModQueue/index.ts"),
				K = n("./src/reddit/models/PostDraft/index.ts"),
				Q = n("./src/reddit/models/RemovalReason/index.ts"),
				J = n("./src/reddit/models/Toast/index.ts"),
				Y = n("./src/reddit/selectors/comments.ts"),
				X = n("./src/reddit/selectors/platform.ts");
			Object(r.a)({
				features: {
					removalReasons: j
				}
			});
			const Z = Object(k.a)("REMOVALREASONS__LOAD_PENDING"),
				$ = Object(k.a)(a),
				ee = Object(k.a)("REMOVALREASONS__LOAD_FAILED"),
				te = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().subreddits.models[e].name;
					t(Z());
					const a = await ((e, t) => Object(L.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons.json`,
						method: C.jb.GET
					}))(r(), o);
					a.ok ? t($({
						subredditId: e,
						response: a.body
					})) : t(ee(a.error))
				}, ne = Object(k.a)(i), se = Object(k.a)(d), re = Object(k.a)(c), oe = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r().subreddits.models[e].name;
					n(ne());
					const d = await ((e, t, n) => Object(L.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons`,
						method: C.jb.POST,
						data: n
					}))(a(), i, t);
					if (d.ok) {
						const {
							id: r
						} = d.body, o = {
							...t,
							id: r
						};
						n(se({
							subredditId: e,
							reason: o
						})), n(Object(M.f)({
							kind: J.b.SuccessMod,
							text: s.fbt._("Removal reason added!", null, {
								hk: "2WSh8N"
							})
						}))
					} else n(re(d.error))
				}, ae = Object(k.a)(l), ie = Object(k.a)(u), de = Object(k.a)(m), ce = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r().subreddits.models[e].name;
					n(ae());
					const d = await ((e, t, n) => Object(L.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons/${n.id}`,
						method: C.jb.PUT,
						data: {
							message: n.message,
							title: n.title
						}
					}))(a(), i, t);
					d.ok ? (n(ie({
						subredditId: e,
						reason: t
					})), n(Object(M.f)({
						kind: J.b.SuccessMod,
						text: s.fbt._("Removal reason saved", null, {
							hk: "28ScuL"
						})
					}))) : n(de(d.error))
				}, le = Object(k.a)(p), ue = Object(k.a)(b), me = Object(k.a)(h), pe = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r().subreddits.models[e].name;
					n(le());
					const d = await ((e, t, n) => Object(L.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons/${n}`,
						method: C.jb.DELETE
					}))(a(), i, t);
					d.ok ? (n(ue({
						subredditId: e,
						reasonId: t
					})), n(Object(M.f)({
						kind: J.b.SuccessMod,
						text: s.fbt._("Removal reason deleted", null, {
							hk: "4xzgsa"
						})
					}))) : n(me(d.error))
				}, be = Object(k.a)("REMOVALREASONS__REMOVEDITEMS_SELECTED"), he = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s();
					a.features.removalReasons.reasonOrder[e] && a.features.removalReasons.reasonOrder[e].length > 0 || n(te(e)), n(be({
						subredditId: e,
						itemIds: t
					})), n(Object(R.i)(D.a.ADD_REMOVAL_REASON))
				}, fe = Object(k.a)("REMOVALREASONS__SUBMIT_PENDING"), ge = Object(k.a)("REMOVALREASONS__SUBMIT_SUCCESS"), _e = Object(k.a)("REMOVALREASONS__SUBMIT_FAILED"), ve = Object(k.a)("REMOVALREASONS__MESSAGE_PENDING"), Oe = Object(k.a)("REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS"), xe = Object(k.a)("REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS"), Ee = Object(k.a)("REMOVALREASONS__MESSAGE_FAILED"), ye = (e, t, n, s, r) => async (o, a, i) => {
					let {
						apiContext: d
					} = i;
					const c = a(),
						l = c.user.account && c.user.account.displayText,
						u = e[0],
						m = Object(W.a)(u) ? Q.e.Post : Q.e.Comment,
						p = m === Q.e.Post ? c.posts.models[u] : c.features.comments.models[u],
						b = m === Q.e.Post ? A.S : T.j;
					if (!p || !l) return !1;
					o(fe()), o(b({
						[u]: {
							modNote: r,
							modRemovalReason: t && t.title,
							modReasonBy: l
						}
					}));
					const h = {
							itemIds: e,
							modNote: r,
							reasonId: t ? t.id : null
						},
						f = await G(d(), h);
					if (f.ok) {
						if (o(ge()), t) {
							o(ve());
							const r = {
									itemId: e,
									message: n,
									title: t.title,
									type: s
								},
								a = await H(d(), Object(Q.h)(r, m), m);
							if (a.ok) {
								if ([Q.f.Public, Q.f.PublicSubreddit].includes(s)) {
									if (o(xe()), a.body) {
										const e = Object(q.a)(a.body),
											t = {
												comment: e,
												parentId: u
											},
											n = Object(X.f)(c),
											s = c.platform.currentPage && c.platform.currentPage.routeMatch;
										let r = n && s && Object(V.a)(s, c, c.posts.models[e.postId]);
										if (r || (r = Object(I.a)(e.postId, null, {
												sort: C.u,
												hasSortParam: !0
											})), m === Q.e.Post) {
											const n = Object(S.a)(K.c.replyToPost, u);
											o(Object(N.r)({
												...t,
												headCommentId: Object(Y.w)(c, {
													commentsPageKey: r
												}),
												commentsPageKey: r,
												draftKey: n
											}));
											const s = c.postStickiedComments.data[u];
											o(Object(P.f)({
												id: e.id,
												postId: e.postId,
												commentsPageKey: r
											})), s && s !== e.id && o(Object(T.j)({
												[s]: {
													isStickied: !1
												}
											}))
										} else if (m === Q.e.Comment) {
											const e = Object(S.a)(K.c.replyToComment, p.id),
												n = Object(Y.j)(c, {
													commentId: u,
													commentsPageKey: r
												});
											o(Object(N.p)({
												...t,
												parentCommentId: u,
												commentsPageKey: r,
												draftKey: e,
												depth: n + 1
											}))
										}
									}
								} else o(Oe());
								return !0
							}
							return o(Ee(a.error)), !1
						}
					} else o(_e(f.error)), o(b({
						[u]: {
							modNote: p.modNote,
							modRemovalReason: p.modRemovalReason,
							modReasonBy: p.modReasonBy
						}
					}));
					return !1
				}, je = (e, t, n, r, o) => async (a, i, d) => {
					let {
						apiContext: c
					} = d;
					const l = i(),
						u = l.user.account && l.user.account.displayText;
					if (!u) return;
					a(fe());
					const m = Object(M.f)({
							kind: J.b.SuccessMod,
							text: s.fbt._({
								"*": "Added removal reason for {number} posts/comments",
								_1: "Added removal reason for 1 post/comment"
							}, [s.fbt._plural(e.length, "number")], {
								hk: "3Gipsf"
							})
						}),
						p = {
							itemIds: e,
							modNote: o,
							reasonId: t ? t.id : null
						},
						b = await G(c(), p);
					if (b.ok) {
						const s = {
							ids: e,
							operation: z.a.RemovalReason,
							username: u,
							options: {
								modNote: o,
								removalReason: t && t.title
							}
						};
						if (a(Object(w.b)(s)), t) {
							const s = {
									itemId: e,
									message: n,
									title: t.title,
									type: r
								},
								o = await H(c(), Object(Q.h)(s, Q.e.Bulk), Q.e.Bulk);
							o.ok ? (a(Oe()), a(m)) : a(Ee(o.error))
						} else a(m)
					} else a(_e(b.error))
				}
		},
		"./src/reddit/actions/reportFlow/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.postOrCommentReported)),
				o = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowOpened)),
				a = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowClosed))
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "m", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "u", (function() {
				return O
			})), n.d(t, "p", (function() {
				return x
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "v", (function() {
				return y
			})), n.d(t, "s", (function() {
				return j
			})), n.d(t, "x", (function() {
				return C
			})), n.d(t, "w", (function() {
				return k
			})), n.d(t, "t", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				o = "SCHEDULED_POSTS_LOADED",
				a = "STANDALONE_SCHEDULED_POSTS_LOADED",
				i = "RECURRING_SCHEDULED_POSTS_LOADED",
				d = "SCHEDULED_POSTS_FAILED",
				c = "SCHEDULED_POST_CREATION_SUCCEEDED",
				l = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				u = "SCHEDULED_POST_MUTATE_REQUESTED",
				m = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				b = "RECURRING_POST_MUTATE_SUCCESS",
				h = "RECURRING_POST__EDIT_MODAL_LOAD",
				f = "RECURRING_POST__EDIT_LOAD",
				g = "STANDALONE_POST__EDIT_LOAD",
				_ = "SCHEDULED_POST__DELETE_SUCCESS",
				v = () => s.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				O = () => s.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				x = () => s.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				E = () => s.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				y = () => s.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				j = () => s.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				C = () => s.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				k = () => s.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				I = () => s.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/scheduledPosts/delete.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/DeleteScheduledPost.json");
			var d = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				c = n("./src/reddit/models/ScheduledPost/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				m = n("./src/telemetry/index.ts");
			const p = Object(s.a)(r.i),
				b = (e, t) => async (n, s, b) => {
					let {
						gqlContext: h
					} = b;
					const f = Object(u.a)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					f && Object(c.q)(f) && Object(m.a)(Object(d.s)()(s(), f)), f ? (await ((e, t) => Object(a.a)(e, {
						...i,
						variables: t
					}))(h(), {
						input: {
							id: f.id
						}
					})).ok ? (n(Object(o.f)(Object(o.e)(r.q(), l.b.SuccessCommunity))), n(p({
						subredditId: e,
						scheduledPostId: t
					}))) : n(Object(o.f)(Object(o.e)(r.p(), l.b.Error))) : n(Object(o.f)(Object(o.e)(r.u(), l.b.Error)))
				}
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/telemetry/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/scheduledPosts/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				m = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				p = n("./src/reddit/models/ScheduledPost/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/routes/postCreation/index.ts"),
				f = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const g = Object(a.a)(d.n),
				_ = Object(a.a)(d.b),
				v = (e, t) => async (n, s, o) => {
					const a = Object(f.a)(s(), {
						scheduledPostId: t,
						subredditId: e
					});
					a && (await n(Object(r.b)(Object(h.c)(a.subreddit.name, a.collectionId))), n((Object(p.q)(a) ? _ : g)(a)))
				}, O = (e, t) => {
					Object(p.q)(t) ? e(Object(i.d)({
						scheduledPost: t
					})) : e(Object(i.h)({
						scheduledPost: t
					}))
				}, x = (e, t, n) => async (r, a, h) => {
					let {
						gqlContext: g
					} = h;
					r(Object(i.g)());
					const _ = Object(f.a)(a(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (_ && Object(p.q)(_) && Object(o.a)(Object(m.u)()(a(), _)), !_) return void r(Object(i.f)({
						message: s.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(n).length) return void O(r, _);
					const v = await Object(l.a)(g(), {
							...n,
							id: t
						}),
						E = v.body;
					if (!(v.ok && E && E.data && E.data.updateScheduledPost && E.data.updateScheduledPost.ok && E.data.updateScheduledPost.scheduledPost)) return r(Object(i.f)({
						message: v.error && v.error.fields && v.error.fields.length && v.error.fields[0].msg || s.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void r(Object(c.f)(Object(c.e)(d.t(), b.b.Error, d.s(), x(e, t, n))));
					r(Object(c.f)(Object(c.e)(d.w(), b.b.SuccessCommunity))), O(r, Object(u.d)(E.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return _
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return P
			}));
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				a = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				l = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				b = n("./src/telemetry/index.ts");
			const h = 25,
				f = 1e4,
				g = Object(r.a)(o.g),
				_ = Object(r.a)(o.k),
				v = Object(r.a)(o.j),
				O = Object(r.a)(o.o),
				x = Object(r.a)(o.d),
				E = Object(r.a)(o.f),
				y = Object(r.a)(o.m),
				j = Object(r.a)(o.a),
				C = Object(r.a)(o.c),
				k = Object(r.a)(o.e),
				I = Object(r.a)(o.h),
				S = (e, t) => {
					e(k()), e(Object(i.f)(Object(i.e)(o.r(), m.b.Error, o.s(), w(t))))
				},
				w = e => {
					let {
						subredditId: t,
						includeStandalone: n = {
							standaloneFirst: h
						},
						includeRecurring: s = {
							recurringFirst: f
						},
						...r
					} = e;
					return async (e, o, a) => {
						let {
							gqlContext: i
						} = a;
						if (Object(p.h)(o(), {
								subredditId: t
							})) return;
						e(g());
						const l = {
								subredditId: t,
								includeRecurring: s,
								includeStandalone: n,
								...r
							},
							u = await Object(d.b)(i(), l);
						Object(d.f)(u, l) ? N(e, Object(c.e)(u.body.data), l) : S(e, l)
					}
				},
				T = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (!Object(p.h)(o, {
							subredditId: e
						})) return t(w({
						subredditId: e
					}));
					if (!Object(p.g)(o, {
							subredditId: e,
							type: u.g.standalonePosts
						})) return;
					const a = Object(p.c)(o, {
						subredditId: e,
						type: u.g.standalonePosts
					});
					if (!a) return;
					t(g());
					const i = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: h,
								standaloneAfter: a
							}
						},
						l = await Object(d.b)(r(), i);
					l.ok ? N(t, Object(c.e)(l.body.data), i) : t(k())
				}, N = (e, t, n) => {
					Object(c.b)(t) ? e(E(t)) : Object(c.a)(t) ? e(j(t)) : Object(c.c)(t) ? e(y(t)) : S(e, n)
				}, P = (e, t) => async (n, r, o) => {
					const i = {},
						d = r();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isContestMode":
						case "isPostAsMetaMod":
						case "isSpoiler":
							i[e] = !t[e];
							break;
						case "isSticky":
							const n = !!t.sticky && "NONE" !== t.sticky;
							i.sticky = n ? "NONE" : "SECOND";
							break;
						default:
							return Object(s.a)(e)
					}
					Object(b.a)(Object(l.t)(e, i[e], Object(u.q)(t))(d)), n(Object(a.a)(t.subreddit.id, t.id, i))
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/goodContent/index.ts");
			const o = "FRONTPAGE_LINKS__REQUEST_LOADED",
				a = "SUBREDDIT_LINKS_LOADED",
				i = 10,
				d = Object(s.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				c = Object(s.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				l = Object(s.a)(o),
				u = Object(s.a)(a),
				m = () => async e => {
					e(d());
					const t = await Object(r.a)();
					e(t ? l(t) : c())
				}
		},
		"./src/reddit/actions/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "SUBREDDIT_TOPIC_LINKS_LOADED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/shortcuts.ts"),
				r = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = n("./src/reddit/helpers/routeKey/index.ts");
			const a = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const n = t.routeMatch,
						s = Object(r.a)(e);
					return Object(o.b)(n, e, s)
				},
				i = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				d = e => {
					const t = document.getElementById(e),
						n = window.scrollX,
						s = window.scrollY;
					t && (t.focus(), window.scrollTo(n, s))
				},
				c = () => {
					d(s.b)
				}
		},
		"./src/reddit/actions/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return O
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				a = n("./src/config.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			var u = n("./src/reddit/reducers/features/avatar/index.ts"),
				m = n("./src/reddit/selectors/avatar.ts"),
				p = n("./src/reddit/actions/users.ts");
			Object(s.a)({
				features: {
					avatar: u.a
				}
			});
			const b = "SET_AVATAR_USER",
				h = Object(r.a)(b),
				f = "RANDOM_AVATAR_LOADED",
				g = Object(r.a)(f),
				_ = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: u
					} = o;
					var b, h, f, g;
					const _ = Object(m.b)(r()),
						v = await (async (e, t, n, s, r) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${a.a.snoovatarUrl}/api/snoovatar?skip_telemetry=true`,
							method: i.jb.POST,
							headers: {
								"Content-Type": "application/json ",
								"X-CSRF-Token": r || ""
							},
							data: {
								accessory_ids: t,
								styles: n,
								...s
							}
						}))(u(), e, t, n, _);
					if (!v.ok) throw new Error("User avatar failed to save");
					return s(Object(p.A)(v.body)), {
						accountIcon: null === (h = null === (b = v.body) || void 0 === b ? void 0 : b.avatar) || void 0 === h ? void 0 : h.headshot_image_url,
						fullBodySnoovatar: null === (g = null === (f = v.body) || void 0 === f ? void 0 : f.avatar) || void 0 === g ? void 0 : g.image_url
					}
				}, v = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${a.a.snoovatarUrl}/api/account`,
							method: i.jb.GET
						}))(s());
						t.ok && e(h(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}, O = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${a.a.snoovatarUrl}/api/snoovatars/random:byId`,
							method: i.jb.GET
						}))(s());
						t.ok && e(g(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}
		},
		"./src/reddit/actions/snoovatarModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/reddit/actions/login.ts"),
				r = n("./src/reddit/actions/modal.ts"),
				o = n("./src/reddit/actions/users.ts"),
				a = n("./src/reddit/constants/modals.ts"),
				i = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				c = n("./src/telemetry/index.ts");
			const l = () => async (e, t) => {
				const n = t();
				Object(c.a)(Object(i.l)(n)), e(Object(o.t)({
					forceFetch: !0
				})), await e(Object(r.g)(a.a.SNOOVATAR_MODAL))
			};

			function u() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return async (t, n) => {
					const {
						clickSource: o,
						share: l,
						source: u,
						activeTab: m,
						activeMeSubpage: p,
						activeDetails: b,
						shopTabState: h
					} = e, f = n();
					o && Object(c.a)(Object(i.g)(o)(f)), Object(d.Q)(f) ? await t(Object(r.h)(a.a.SNOOVATAR_MODAL, {
						share: l,
						source: u,
						activeTab: m,
						activeMeSubpage: p,
						activeDetails: b,
						shopTabState: h
					})) : await t(Object(s.openLoginModal)())
				}
			}
		},
		"./src/reddit/actions/streaming/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "SUBREDDIT__STREAMING_MOD_SETTINGS_LOADED"
		},
		"./src/reddit/actions/streaming/modSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/streaming/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/FetchSubredditStreamingModSettings.json"),
				c = n("./src/redditGQL/operations/UpdateSubredditStreamingModSettings.json"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = Object(r.a)(o.a),
				p = "STREAMING_MOD_SETTINGS__UPDATE_PENDING",
				b = "STREAMING_MOD_SETTINGS__UPDATE_LOADED",
				h = "STREAMING_MOD_SETTINGS__UPDATE_FAILED",
				f = Object(r.a)(p),
				g = Object(r.a)(b),
				_ = Object(r.a)(h),
				v = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const c = Object(u.U)(n(), {
						subredditId: e
					});
					if (void 0 === c) {
						const e = s.fbt._("Invalid subreddit", null, {
								hk: "2iUXvs"
							}),
							n = Object(a.e)(e, l.b.Error);
						return await t(Object(a.f)({
							...n,
							duration: a.a
						})), {
							reason: e
						}
					}
					const p = await ((e, t) => Object(i.a)(e, {
						...d,
						variables: {
							subredditId: t
						}
					}))(o(), e);
					if (!p.ok) {
						const e = s.fbt._("Could not fetch settings for {subredditName}", [s.fbt._param("subredditName", c.name)], {
								hk: "2G8rnU"
							}),
							n = Object(a.e)(e, l.b.Error);
						return await t(Object(a.f)({
							...n,
							duration: a.a
						})), {
							reason: e
						}
					}
					const b = p.body.data.subredditInfoById;
					return await t(m({
						subredditId: e,
						modSettings: b.liveStreamingInfo
					})), {}
				}, O = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					await n(x(t, e, o())), n(v(t))
				}, x = (e, t, n) => async (n, r, o) => {
					let {
						gqlContext: d
					} = o;
					n(f({
						subredditId: e
					}));
					const u = await ((e, t) => Object(i.a)(e, {
						...c,
						variables: t
					}))(d(), {
						input: {
							subredditId: e,
							liveStreamingModeratorSettings: t
						}
					});
					if (!u.ok || !u.body.data.updateSubredditLiveStreamingModeratorSettings.ok) {
						const t = u.error && u.error.fields ? u.error.fields[0].msg : s.fbt._("Could not update community broadcasting settings", null, {
								hk: "3Uw7zu"
							}),
							r = Object(a.e)(t, l.b.Error);
						await n(Object(a.f)({
							...r,
							duration: a.a
						})), n(_({
							subredditId: e
						}))
					}
					const m = s.fbt._("Community broadcasting settings saved", null, {
							hk: "GTwrg"
						}),
						p = Object(a.e)(m, l.b.SuccessCommunity);
					await n(Object(a.f)({
						...p,
						duration: a.a
					})), n(g({
						subredditId: e
					}))
				}, E = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: a
					} = o;
					const i = [...n.whitelistedUsers.map(e => ({
						redditorName: e.name
					})), {
						redditorName: t
					}];
					await s(x(e, {
						whitelistedRedditors: i
					}, a())), await s(v(e))
				}, y = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: a
					} = o;
					const i = n.whitelistedUsers.filter(e => e.name !== t).map(e => ({
						redditorName: e.name
					}));
					await s(x(e, {
						whitelistedRedditors: i
					}, a())), await s(v(e))
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return s
			})), n.d(t, "k", (function() {
				return r
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "m", (function() {
				return f
			}));
			const s = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				a = "SUBREDDIT__STYLES_PENDING",
				i = "SUBREDDIT__STYLES_LOADED",
				d = "SUBREDDIT__STYLES_FAILED",
				c = "STRUCTURED_STYLES__DRAFT_REPLACED",
				l = "STRUCTURED_STYLES__DRAFT_UPDATED",
				u = "STRUCTURED_STYLES__EDITING_STOPPED",
				m = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				b = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				h = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				f = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return F
			})), n.d(t, "k", (function() {
				return G
			})), n.d(t, "j", (function() {
				return V
			})), n.d(t, "e", (function() {
				return K
			})), n.d(t, "d", (function() {
				return J
			})), n.d(t, "g", (function() {
				return X
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "f", (function() {
				return te
			})), n.d(t, "b", (function() {
				return ne
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "a", (function() {
				return re
			})), n.d(t, "h", (function() {
				return oe
			})), n.d(t, "i", (function() {
				return ae
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				a = n.n(o),
				i = n("./node_modules/react-router-redux/es/index.js"),
				d = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/apiRequestState.ts"),
				m = n("./src/reddit/actions/imageUploads.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				f = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const v = Object(l.a)(_.c),
				O = Object(l.a)(_.b),
				x = Object(l.a)(_.a);
			var E = n("./src/reddit/actions/toaster.ts"),
				y = n("./src/reddit/actions/widgets/index.ts"),
				j = n("./src/reddit/constants/modals.ts"),
				C = n("./src/reddit/helpers/getGenericUploadError.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				I = n("./src/reddit/helpers/media/index.ts"),
				S = n("./src/reddit/models/Image/index.tsx"),
				w = n("./src/reddit/models/StructuredStyles/index.ts"),
				T = n("./src/reddit/models/Toast/index.ts"),
				N = n("./src/reddit/selectors/activeModalId.ts"),
				P = n("./src/reddit/selectors/platform.ts"),
				R = n("./src/reddit/selectors/structuredStyles.ts"),
				A = n("./src/reddit/selectors/user.ts"),
				M = n("./src/reddit/helpers/trackers/blade.ts"),
				D = n("./src/telemetry/index.ts"),
				L = n("./src/reddit/actions/structuredStyles/constants.ts");
			const F = Object(l.a)(L.m),
				U = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				B = e => {
					const t = {
						...e
					};
					return Object.keys(e).forEach(n => {
						U[n] && !e[n] && U[n].forEach(e => t[e] = null)
					}), t
				},
				G = (e, t, n, s) => async (r, o, a) => {
					const {
						apiContext: i
					} = a, d = o(), l = B(t), p = d.structuredStyles.models[e];
					let h;
					for (const e in l)
						if (l[e] !== p[e]) {
							h = !0;
							break
						} if (!h) return;
					r(Object(u.h)(s));
					const f = Object(M.i)(n)(d);
					let _ = null,
						v = null;
					try {
						(_ = await Object(m.f)(o(), S.a.StructuredStyles)) && (v = Object(m.m)(_)(r, o, a))
					} catch (j) {
						const e = Object(C.a)("webSocket");
						return void r(Object(u.f)(s, e))
					}
					const O = Object(g.U)(d, {
							subredditId: e
						}).name,
						x = await b.e(i(), O, l),
						y = {};
					if (x.ok) {
						if (v) try {
							await v
						} catch (j) {}
						const n = Object(R.f)(o(), {
							apiRequestId: s
						});
						for (const e in n)
							if (e in t) {
								const t = Object(R.g)(o(), {
									name: e
								});
								t && Object(S.j)(t) && (y[e] = n[e])
							} Object.keys(y).length && r(Q(y)), r(Object(u.e)(s)), r(F({
							subredditId: e,
							styles: {
								...l,
								...y
							}
						}))
					} else _ && _.websocket.close(), r(Object(u.f)(s, x.error)), x.body && r(E.f({
						kind: T.b.Error,
						text: Object(c.a)(x.error, x.status)
					}));
					Object(D.a)({
						...f,
						actionInfo: {
							...f.actionInfo,
							success: x.ok
						}
					})
				}, H = Object(l.a)(L.l), W = Object(l.a)(L.k), q = Object(l.a)(L.j), V = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(H({
						subredditId: e
					}));
					const o = Object(g.U)(n(), {
							subredditId: e
						}).name,
						a = await b.f(r(), o);
					if (a.ok) {
						const s = n().structuredStyles.models[e],
							r = s ? s.mobileKeyColor : null;
						t(W({
							subredditId: e,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else t(q({
						subredditId: e,
						...a.error
					}))
				}, z = Object(l.a)(L.d), K = e => async (t, n, s) => {
					const r = n(),
						o = r.structuredStyles.models[e] || {},
						a = Object(A.db)(r);
					t(z({
						isNightmodeOn: a,
						styles: o,
						subredditId: e
					})), le(e, !1)(t, n, s), (e => async (t, n, s) => {
						let {
							gqlContext: r
						} = s;
						const o = n(),
							a = Object(g.U)(o, {
								subredditId: e
							});
						if (!a) return;
						const i = Object(f.d)(o, {
								subredditId: e
							}),
							d = i && i.templateIds;
						if (!d || !d.length) return;
						t(v({
							subredditId: e
						}));
						const c = await Object(b.a)(r(), a.name, d);
						if (c.ok) {
							const n = {};
							if (c.body) {
								const {
									data: e
								} = c.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) n[t.id] = Object(h.a)(t)
							}
							t(O({
								subredditId: e,
								templates: n
							}))
						} else t(x({
							subredditId: e,
							error: c.error
						}))
					})(e)(t, n, s), Object(y.g)(e, !1)(t, n, s)
				}, Q = Object(l.a)(L.c), J = e => async (t, n, s) => {
					const r = B(e),
						o = n();
					for (const e in r)
						if (Object(w.l)(e))
							if (r[e]) {
								if ("string" != typeof r[e]) {
									const o = r[e],
										a = await Object(S.e)(o);
									X(e, a)(t, n, s), r[e] = ""
								}
							} else {
								const n = Object(R.g)(o, {
									name: e
								});
								n && t(Object(m.h)(n))
							} t(Q(r))
				}, Y = Object(l.a)(L.f), X = (e, t, n) => async (s, r, o) => {
					const a = r(),
						i = n || a.structuredStyles.isEditing,
						d = Object(g.U)(a, {
							subredditId: i
						}).name;
					s(Y({
						imageKey: e,
						uploadId: t.id
					})), s(Object(m.k)(t));
					const c = await b.d(o.apiContext(), d, t.file.name, e, await Object(I.h)(t.file));
					try {
						const n = await Object(m.g)(r(), c, t, S.a.StructuredStyles);
						if (n) {
							const t = n.url;
							s(Object(m.j)(n)), s(Q({
								[e]: t
							}))
						}
					} catch (l) {
						if (l instanceof Error) throw l;
						s(Object(m.i)(l))
					}
				}, Z = Object(l.a)(L.b), $ = (e, t, n) => async (s, o, i) => {
					const d = o(),
						c = d.structuredStyles.models[e] || {},
						l = d.structuredStyles.draft,
						u = Object(M.h)(t)(d);
					if (n) {
						const t = a()(c, n),
							o = {
								...r()(l, n),
								...t
							};
						s(Z({
							subredditId: e,
							styles: o
						}))
					} else {
						s(Z({
							subredditId: e,
							styles: c
						}))
					}
					Object(D.a)(u)
				}, ee = Object(l.a)(L.e), te = () => async (e, t, n) => {
					const s = t(),
						r = Object(A.eb)(s),
						o = !!Object(P.a)(s);
					if (e(ee({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: a
					} = s.platform.currentPage;
					a && e(Object(i.c)(Object(d.a)(a, ["styling", "route"])))
				}, ne = Object(l.a)(L.a), se = Object(l.a)(L.n), re = () => async e => e(te()), oe = e => async (t, n) => {
					const s = n(),
						r = Object(R.i)(s);
					!Object(N.b)(j.a.BLADE_UNSAVED_CHANGES)(s) && r && (Object(R.a)(s, {
						subredditId: e
					}) ? t(Object(p.i)(j.a.BLADE_UNSAVED_CHANGES)) : t(re()))
				}, ae = e => async (t, n) => {
					const s = n();
					Object(R.i)(s) || t(Object(A.db)(s) ? Object(p.i)(j.a.BLADE_NIGHTMODE) : K(e))
				}, ie = Object(l.a)(L.i), de = Object(l.a)(L.h), ce = Object(l.a)(L.g), le = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o,
						apiContext: a
					} = r;
					n(ie({
						subredditId: e
					}));
					const i = Object(g.U)(s(), {
						subredditId: e
					});
					if (!i) return;
					if (!t) {
						const s = await b.c(a(), i.name, t);
						if (s.ok) {
							const t = s.body,
								r = t.data ? t.data.style : {};
							n(de({
								subredditId: e,
								styles: r
							}))
						} else n(ce({
							subredditId: e,
							...s.error
						}));
						return
					}
					const d = await b.b(o(), i.name);
					if (d.ok) {
						let t = {};
						if (d.body) {
							const {
								data: e
							} = d.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(k.a)(e.subreddit.styles))
						}
						n(de({
							subredditId: e,
							styles: t
						}))
					} else n(ce({
						subredditId: e,
						...d.error
					}))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return z
			})), n.d(t, "l", (function() {
				return K
			})), n.d(t, "k", (function() {
				return Q
			})), n.d(t, "j", (function() {
				return J
			})), n.d(t, "i", (function() {
				return Y
			})), n.d(t, "h", (function() {
				return X
			})), n.d(t, "d", (function() {
				return Z
			})), n.d(t, "p", (function() {
				return ne
			})), n.d(t, "t", (function() {
				return se
			})), n.d(t, "o", (function() {
				return ae
			})), n.d(t, "r", (function() {
				return ce
			})), n.d(t, "g", (function() {
				return le
			})), n.d(t, "f", (function() {
				return ue
			})), n.d(t, "e", (function() {
				return me
			})), n.d(t, "q", (function() {
				return fe
			})), n.d(t, "b", (function() {
				return ge
			})), n.d(t, "c", (function() {
				return _e
			})), n.d(t, "a", (function() {
				return ve
			})), n.d(t, "u", (function() {
				return ye
			})), n.d(t, "n", (function() {
				return je
			})), n.d(t, "s", (function() {
				return Ce
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/listingSort/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = n("./src/reddit/actions/pages/subreddit.ts"),
				b = n("./src/reddit/actions/preferences.ts"),
				h = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				f = n("./src/reddit/actions/subredditRules/constants.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/constants/history.ts"),
				v = n("./src/reddit/constants/modals.ts"),
				O = n("./src/reddit/constants/page.ts"),
				x = n("./src/reddit/constants/parameters.ts"),
				E = n("./src/reddit/constants/postLayout.ts"),
				y = n("./src/reddit/contexts/PageLayer/index.tsx"),
				j = n("./src/reddit/endpoints/governance/posts.ts"),
				C = n("./src/reddit/endpoints/messages/index.ts"),
				k = n("./src/reddit/endpoints/modQueue/index.ts"),
				I = n("./src/reddit/endpoints/page/subredditPage.ts"),
				S = n("./src/reddit/endpoints/subreddit/about.ts"),
				w = n("./src/reddit/endpoints/subreddit/rules.ts"),
				T = n("./src/reddit/endpoints/user/preferences.ts"),
				N = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				P = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				R = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				M = n("./src/reddit/helpers/trackers/feed.ts"),
				D = n("./src/reddit/models/Subreddit/index.ts"),
				L = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				F = n("./src/reddit/models/Toast/index.ts"),
				U = n("./src/reddit/models/User/index.ts"),
				B = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				G = n("./src/reddit/selectors/moderatorPermissions.ts"),
				H = n("./src/reddit/selectors/profile.ts"),
				W = n("./src/reddit/selectors/subreddit.ts"),
				q = n("./src/reddit/selectors/user.ts");
			const V = {},
				z = "SUBREDDIT__MODEL_SUCCEEDED",
				K = "SUBREDDIT__MODEL_PENDING",
				Q = "SUBREDDIT__MODEL_FAILED",
				J = "SUBREDDIT__MORE_POSTS_PENDING",
				Y = "SUBREDDIT__MORE_POSTS_LOADED",
				X = "SUBREDDIT__MORE_POSTS_FAILED",
				Z = "SUBREDDIT__META_FILTER_TOGGLED",
				$ = Object(d.a)(J),
				ee = Object(d.a)(Y),
				te = Object(d.a)(X),
				ne = Object(d.a)(Z),
				se = Object(d.a)(f.b),
				re = Object(d.a)(f.c),
				oe = Object(d.a)(f.a),
				ae = (e, t) => async (n, s) => {
					await (t === D.f.User ? n(ie(e)) : n(de(e)))
				}, ie = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(H.m)(n(), e),
						a = await Object(w.c)(r(), e);
					if (a.ok) {
						const e = a.body;
						t(se({
							rules: e,
							subredditId: o
						}))
					}
				}, de = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const a = Object(W.F)(n(), e);
					t(re());
					const i = await Object(w.b)(o(), e);
					if (i.ok) {
						const e = i.body;
						t(se({
							rules: e,
							subredditId: a
						}))
					} else {
						t(oe());
						const n = `error-block-${e}`;
						t(g.f({
							id: n,
							kind: F.b.Error,
							text: s.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, ce = e => async (t, n, s) => {
					let {
						apiContext: r,
						gqlContext: d
					} = s;
					const {
						subredditName: u
					} = e;
					let p = e.t;
					const b = n(),
						f = Object(P.a)(e, b),
						g = b.platform.currentPage ? b.platform.currentPage.queryParams : {},
						v = Object(c.a)(u, f, {
							t: p,
							...g
						}),
						C = b.listings.postOrder.loadMore[v],
						k = b.listings.postOrder.listingSort[v];
					let S = f;
					if (k && !S) {
						const e = Object(i.d)(k.sort);
						S = e.sort, p = e.timeSort
					}
					const w = b.listings.postOrder.api.pending[v],
						{
							fetchedTokens: T
						} = b.listings.postOrder,
						R = !(!T[v] || !T[v][C.token]);
					if (w || R) return;
					if (S === a.W.AWARDED && u === O.g) return;
					t($({
						key: v,
						fetchedToken: C.token
					}));
					const A = {
							after: C.token,
							dist: C.dist,
							forceGeopopular: u === O.d.Popular,
							layout: E.e[Object(y.S)(b, {})],
							sort: S,
							t: p,
							...o()(g, [...x.k, x.g])
						},
						D = Object(B.a)(b),
						L = D ? () => Object(I.b)(d(), Object(I.c)(b, u, {
							...A,
							limit: E.a
						}), Object(q.Z)(b)) : () => Object(I.a)(r(), u, A),
						F = await L(),
						U = {
							...F.body,
							...Object(N.a)(b, v, F.body)
						};
					if (F.ok) {
						let e;
						const s = U.postIds.filter(e => !!U.posts[e].isMeta),
							o = Object(W.F)(n(), u);
						if (s.length) {
							const t = await Object(j.a)(r(), o, s);
							t.ok && (e = t.body)
						}
						const a = Object(G.h)(b, {
							subredditId: Object(W.F)(b, u)
						});
						if (!D && a && t(Object(m.a)({
								postIds: U.postIds
							})), t(ee({
								fetchedToken: C.token,
								key: v,
								meta: b.meta,
								governance: e,
								...U
							})), Object(G.i)(b, o)) {
							let e;
							D || (e = await Object(I.b)(d(), Object(I.c)(b, u, {
								...A,
								limit: E.a
							}), Object(q.Z)(b)));
							const n = D ? U : e.body;
							if (D ? n : e.ok) {
								const e = n.postIds.map(e => n.posts[e].lastAuthorModNote);
								t(Object(h.e)({
									subredditId: o,
									nodes: e
								}))
							}
						}
						await t(Object(l.a)({
							subredditId: o,
							postIds: U.postIds,
							skip: ["communityDetails", "subscription"]
						})), Object(M.b)(_.a.NextPageLoad)(n())
					} else {
						t(te({
							error: F.error,
							fetchedToken: C.token,
							key: v,
							...U
						}));
						const e = F.error;
						Object(M.a)(e ? `${F.status||"000"}: ${e.type}` : "000: UNKNOWN_ERROR")(n())
					}
				}, le = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", ue = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", me = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", pe = Object(d.a)(le), be = Object(d.a)(ue), he = Object(d.a)(me), fe = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subreddits.moderated.api.fetched) return;
					e(pe());
					const o = await Object(k.c)(s(), a.rb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					o.ok ? e(be(o.body)) : e(he({
						error: o.error
					}))
				}, ge = "SUBREDDIT__ABOUT_PENDING", _e = "SUBREDDIT__ABOUT_SUCCEEDED", ve = "SUBREDDIT__ABOUT_FAILED", Oe = Object(d.a)(ge), xe = Object(d.a)(_e), Ee = Object(d.a)(ve), ye = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (Object(W.w)(o, {
							subredditName: e
						}) || o.subreddits.api.about.error[e.toLowerCase()] || o.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(Oe({
						subredditName: e
					}));
					const a = !Object(W.F)(o, e),
						i = await Object(S.a)(r(), e, a);
					if (i.ok) {
						const n = i.body.data.subreddit,
							s = Object(R.a)(n),
							r = a ? Object(A.a)(n) : void 0;
						t(xe({
							subredditName: e,
							subreddits: r ? {
								[r.id]: r
							} : void 0,
							data: s
						}))
					} else t(Ee({
						subredditName: e,
						error: i.error
					}))
				}, je = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: a
					} = o;
					var i;
					const d = e.substring(2),
						c = n === L.e.View ? null === (i = Object(q.f)(r(), d)) || void 0 === i ? void 0 : i.subredditId : Object(W.F)(r(), d),
						l = Object(q.k)(r());
					if (l && c) {
						const e = ((e, t, n, s) => {
							return {
								to: `/r/${e}`,
								subject: `[join] I would like to join ${e}`,
								text: n + "\n\n   *To approve this user*, visit [the approved users page for r/" + e + "](https://www.reddit.com/r/" + e + "/about/contributors?user=" + t + ') and click "ADD USER".\n    Approving this user gives them permission to ' + s + ". You can change these community restrictions from the [community settings](/r/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + t + "](/u/" + t + ") or reply to this message to start a conversation."
							}
						})(d, Object(U.e)(l), t, n);
						if ((await Object(C.b)(a(), e)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							s(Object(b.F)({
								subredditId: c,
								prefs: t
							})), Object(T.j)(c, t, a()), n !== L.e.View && s(Object(u.i)(v.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, Ce = e => async (t, n) => {
					const s = n(),
						{
							subredditName: r
						} = e,
						o = e.t,
						a = Object(P.a)(e, s),
						i = s.platform.currentPage ? s.platform.currentPage.queryParams : V,
						d = Object(c.a)(r, a, {
							t: o,
							...i
						}),
						l = {
							t: o,
							sort: a,
							isRefresh: !0,
							...i
						};
					await t(Object(p.subredditDataRequested)(d, r, l, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "r", (function() {
				return d
			})), n.d(t, "q", (function() {
				return c
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "k", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "x", (function() {
				return x
			})), n.d(t, "y", (function() {
				return E
			})), n.d(t, "z", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "t", (function() {
				return k
			})), n.d(t, "u", (function() {
				return I
			})), n.d(t, "s", (function() {
				return S
			}));
			const s = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				a = "SUBREDDIT__POSTS_LOADED",
				i = "SUBREDDIT__POSTS_SET_FAILED",
				d = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				l = "SUBREDDIT__RANKINGS_PENDING",
				u = "SUBREDDIT__RANKINGS_LOADED",
				m = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				b = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				h = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				f = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				_ = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				v = "SUBREDDIT__EDIT_REQUESTED",
				O = "SUBREDDIT__EDIT_FAILED",
				x = "SUBREDDIT__EDIT_SUCCESS",
				E = "SUBREDDIT_QUESTIONS_LOADED",
				y = "SUBREDDIT_SURVEY_ANSWERED",
				j = "SUBREDDIT_SURVEY_DISMISSED",
				C = "SUBREDDIT_SURVEY_DISMISS",
				k = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				I = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				S = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED"
		},
		"./src/reddit/actions/subreddit/questions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/GetSubredditQuestions.json"),
				o = n("./src/reddit/actions/subreddit/constants.ts");
			const a = e => async (t, n, o) => {
				let {
					gqlContext: a
				} = o;
				var d;
				const c = (await ((e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}))(a(), {
					id: e
				})).body;
				i(t, e, null === (d = c.data) || void 0 === d ? void 0 : d.subredditInfoById)
			};

			function i(e, t, n) {
				const s = null == n ? void 0 : n.answerableQuestions,
					r = null == n ? void 0 : n.contentRatingSurvey,
					a = null == n ? void 0 : n.communityProgressModule;
				(s || r || a) && e({
					type: o.y,
					payload: {
						id: t,
						questions: s,
						survey: r,
						progressModule: a
					}
				})
			}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return T
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			})), n.d(t, "i", (function() {
				return G
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/postCreation/general.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/postCreation/submit.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ModWelcomeTooltip/index.tsx"),
				u = n("./src/reddit/components/SubredditForkingCTA/index.tsx"),
				m = n("./src/reddit/constants/experiments.ts"),
				p = n("./src/reddit/constants/modals.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				h = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts"),
				g = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const _ = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(","),
				primary_tag: e.primaryTagId
			});
			var v = n("./src/lib/makeGqlRequest/index.ts"),
				O = n("./src/redditGQL/operations/ValidateCreateSubreddit.json");
			var x = n("./src/reddit/helpers/correlationIdTracker.ts"),
				E = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				y = n("./src/reddit/selectors/experiments/newCommunityProgressV3.ts"),
				j = n("./src/reddit/selectors/meta.ts"),
				C = n("./src/reddit/selectors/posts.ts"),
				k = n("./src/reddit/selectors/subreddit.ts"),
				I = n("./src/reddit/selectors/user.ts"),
				S = n("./src/telemetry/index.ts"),
				w = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts");
			const T = "SUBREDDIT__CREATE_SET_INITIAL_CROSSPOST",
				N = "SUBREDDIT__CREATE_PENDING",
				P = "SUBREDDIT__CREATE_SUCCEEDED",
				R = "SUBREDDIT__CREATE_FAILED",
				A = "SUBREDDIT__CREATE_CLEARED",
				M = Object(o.a)(N),
				D = Object(o.a)(P),
				L = Object(o.a)(R),
				F = Object(o.a)(A),
				U = Object(o.a)(T),
				B = e => async (t, n, o) => {
					let {
						apiContext: v
					} = o;
					var O;
					const T = n(),
						{
							name: N,
							type: P,
							crosspostId: R
						} = e;
					if (Object(k.j)(T)) return;
					t(M({
						subredditName: N
					}));
					const A = await ((e, t) => Object(b.a)(Object(h.a)(e, [f.a]), {
						endpoint: Object(g.a)(`${e.apiUrl}/api/v1/subreddit/create_subreddit`),
						method: r.jb.POST,
						data: _(t)
					}))(v(), e);
					if (A.ok) {
						const n = A.body,
							o = n.fullname;
						Object(S.a)(Object(E.d)(P, e, o)(T)), t(D({
							subredditName: N
						}));
						const b = await Object(y.b)(T);
						if (R) {
							const e = Object(C.G)(T, {
								postId: R
							});
							t(Object(a.h)(e.title)), t(Object(a.g)({
								submissionType: r.Wb.CROSSPOST
							})), await t(Object(d.b)({
								destSubreddit: {
									...n,
									isProfile: !1
								},
								sourcePostId: R,
								postFieldValidationPending: Promise.resolve()
							})), Object(u.b)(R)
						}
						await t(Object(s.b)(`${n.path}`)), b ? b === m.ye.NewModule && t(Object(c.h)({
							tooltipId: l.MOD_WELCOME_TOOLTIP_ID
						})) : (t(Object(i.h)(p.a.POST_FLOW_UPSELL_MODAL_ID)), Object(S.a)(Object(E.g)()(T))), Object(x.b)(x.a.SubredditCreation), t(Object(w.f)(o, null !== (O = Object(I.bb)(T)) && void 0 !== O ? O : Object(j.j)(T)))
					} else A.error && Object(S.a)(Object(E.h)(A.error.type, N)(T)), t(L({
						subredditName: N,
						error: A.error
					}))
				}, G = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						a = {
							name: e
						},
						i = await ((e, t) => Object(v.a)(e, {
							...O,
							variables: t
						}))(r(), {
							input: a
						});
					let d = null;
					if (i.ok) {
						d = i.body.data.validateCreateSubredditInput.fieldErrors
					}
					if (d) {
						const n = {
							fields: [{
								field: d[0].field,
								msg: d[0].message
							}],
							type: d[0].code
						};
						t(L({
							subredditName: e,
							error: n
						})), n && Object(S.a)(Object(E.h)(n.type, e)(o))
					} else await t(F())
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/config.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/reddit/models/Post/index.ts");
			var d = n("./src/reddit/models/Duplicates/index.ts"),
				c = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/selectors/profile.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(s.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(s.a)(m)),
				b = (e, t) => async (n, s, m) => {
					let {
						apiContext: b
					} = m;
					const h = Object(u.U)(s(), {
						subredditId: e
					}) || Object(l.p)(s(), {
						profileId: e
					});
					if (!h) return;
					const f = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(c.h)(h) ? r.kc + h.name : h.name
						},
						g = await ((e, t, n) => Object(a.a)(e, {
							data: n,
							endpoint: `${o.a.gatewayUrl}/desktopapi/v1/duplicates/${Object(i.w)(t)}`,
							method: r.jb.GET
						}))(b(), t, f);
					if (g.ok) {
						const s = g.body;
						n(p({
							distinguishKey: Object(d.a)(t, f),
							postIds: s.postIds,
							posts: s.posts,
							profiles: s.profiles,
							subreddits: s.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedSubmitters.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "d", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: Object(m.a)(`${e.apiUrl}/api/v1/${t}/contributors`),
				method: d.jb.GET,
				data: n
			});
			var b = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				h = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/actions/subredditModeration/constants.ts");
			const _ = Object(a.a)(g.g),
				v = Object(a.a)(g.f),
				O = Object(a.a)(g.e),
				x = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							i = t.after || "",
							d = Object(h.e)(e, i),
							c = a.pages.modHub.approvedSubmitters.fetchedTokens[d];
						if (a.pages.modHub.approvedSubmitters.api.pending[d] || c) return;
						n(_({
							subredditId: e,
							fetchedToken: i
						}));
						const l = a.subreddits.models[e].name,
							u = await p(o(), l, t);
						u.ok ? n(v({
							...u.body,
							fetchedToken: i
						})) : n(O({
							subredditId: e,
							fetchedToken: i
						}))
					}
				},
				E = Object(a.a)(g.j),
				y = Object(a.a)(g.i),
				j = Object(a.a)(g.h),
				C = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						i = {
							username: Object(b.a)(t)
						};
					n(E());
					const d = await p(o(), a, i);
					d.ok ? n(y(d.body)) : n(j(d.error))
				}, k = Object(a.a)(g.d), I = Object(a.a)(g.k), S = (e, t) => async (n, r, a) => {
					let {
						apiContext: m
					} = a;
					const h = r(),
						g = h.subreddits.models[e].url,
						_ = h.subreddits.models[e].name;
					t = Object(b.a)(t);
					const v = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: d.jb.POST,
						data: {
							api_type: "json",
							name: n,
							type: "contributor"
						}
					}))(m(), g, t);
					if (v.ok) {
						const e = {
							username: t
						};
						n(Object(i.f)({
							kind: f.b.SuccessMod,
							text: s.fbt._("Successfully added an approved submitter", null, {
								hk: "4gruK7"
							})
						}));
						const r = await p(m(), _, e);
						r.ok && n(k(r.body))
					} else {
						const e = o()(v, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(i.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, w = (e, t) => async (n, r, a) => {
					let {
						apiContext: m
					} = a;
					const p = r().subreddits.models[e].url,
						b = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: d.jb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "contributor"
							}
						}))(m(), p, t);
					if (b.ok) n(I({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(b, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(i.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedTalkHosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "c", (function() {
				return x
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/actions/subredditModeration/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/AddApprovedTalkHost.json"),
				c = n("./src/redditGQL/operations/RedditorIdByName.json"),
				l = n("./src/redditGQL/operations/RemoveApprovedTalkHost.json"),
				u = n("./src/redditGQL/operations/SubredditApprovedTalkHosts.json");
			var m = n("./src/reddit/models/SubredditModeration/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts");
			const {
				fbt: b
			} = n("./node_modules/fbt/lib/FbtPublic.js"), h = Object(s.a)(o.n), f = Object(s.a)(o.m), g = Object(s.a)(o.l), _ = Object(s.a)(o.o), v = e => async (t, n, s) => {
				let {
					gqlContext: o
				} = s;
				var d;
				const c = n(),
					{
						subredditId: l,
						before: _,
						forceRefresh: v
					} = e,
					O = Object(m.f)(l, _),
					x = c.pages.modHub.approvedTalkHosts.fetchedTokens[O];
				if (!(c.pages.modHub.approvedTalkHosts.api.pending[O] || x && !v)) {
					t(h({
						subredditId: l,
						fetchedToken: _
					}));
					try {
						const e = await ((e, t) => Object(i.a)(e, {
							...u,
							variables: {
								...t,
								last: 20
							}
						}))(o(), {
							subredditId: l,
							before: _
						});
						if (e.ok) {
							const {
								data: {
									subredditInfoById: n
								}
							} = e.body;
							if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (d = null == n ? void 0 : n.talkApprovedHostMembers) || void 0 === d ? void 0 : d.edges)) {
								const {
									edges: e,
									pageInfo: s
								} = n.talkApprovedHostMembers, r = [];
								e.forEach(e => {
									e && e.node && r.push(e.node)
								}), t(f({
									subredditId: l,
									approvedTalkHosts: r,
									fetchedToken: _,
									loadMoreToken: s.hasNextPage ? s.endCursor : null,
									forceRefresh: v
								}))
							}
							const {
								errors: s
							} = e.body;
							s && s.length && r.c.captureException(s)
						} else t(g({
							subredditId: l,
							fetchedToken: _
						})), t(Object(a.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					} catch (E) {
						r.c.captureException(E), t(Object(a.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					}
				}
			}, O = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				var l;
				let u = "";
				const m = await ((e, t) => Object(i.a)(e, {
					...c,
					variables: t
				}))(o(), {
					name: t
				});
				if (m.ok) {
					u = null === (l = m.body.data.redditorInfoByName) || void 0 === l ? void 0 : l.id
				}
				if (!m.ok || !u) return void n(Object(a.f)({
					kind: p.b.Error,
					text: b._("{username} doesnt exist. Double-check your spelling.", [b._param("username", t)], {
						hk: "1sikIN"
					}),
					duration: 3e3
				}));
				const h = {
						subredditId: e,
						userId: u
					},
					f = await ((e, t) => Object(i.a)(e, {
						...d,
						variables: t
					}))(o(), h);
				if (f.ok) {
					if (!f.body) return void n(Object(a.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "28RRuF"
						}),
						duration: 3e3
					}));
					n(v({
						subredditId: e,
						forceRefresh: !0
					})), n(Object(a.f)({
						kind: p.b.SuccessMod,
						text: b._("User approved!", null, {
							hk: "PeRM2"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = f.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(a.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}, x = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const d = {
						subredditId: e,
						userId: t
					},
					c = await ((e, t) => Object(i.a)(e, {
						...l,
						variables: t
					}))(o(), d);
				if (c.ok) {
					if (!c.body) return void n(Object(a.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "1o9j5I"
						}),
						duration: 3e3
					}));
					n(_({
						subredditId: e,
						userId: t
					})), n(Object(a.f)({
						kind: p.b.SuccessMod,
						text: b._("User removed from approved hosts list", null, {
							hk: "1RWvrp"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = c.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(a.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}
		},
		"./src/reddit/actions/subredditModeration/ban.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return $
			})), n.d(t, "d", (function() {
				return se
			})), n.d(t, "b", (function() {
				return ae
			})), n.d(t, "e", (function() {
				return ie
			})), n.d(t, "a", (function() {
				return de
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/apiRequestState.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/subreddit.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/modals.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				f = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				g = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const _ = (e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
				endpoint: Object(f.a)(Object(g.a)(`${e.apiUrl}/api/v1/${t}/banned`)),
				method: m.jb.GET,
				data: n
			});
			var v = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				O = n("./src/reddit/models/SubredditModeration/index.ts"),
				x = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/reddit/selectors/bannedUser.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/selectors/user.ts"),
				k = n("./src/reddit/actions/subredditModeration/constants.ts"),
				I = n("./src/lib/initializeClient/installReducer.ts"),
				S = n("./node_modules/redux/es/redux.js");
			var w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.s:
					case k.r:
						return null;
					case k.q:
						return t.payload;
					default:
						return e
				}
			};
			const T = {};
			var N = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.s: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(O.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case k.r:
						case k.q: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(O.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				P = Object(S.c)({
					error: w,
					pending: N
				});
			const R = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(O.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				M = n("./src/reddit/actions/inContextModeration.ts");
			var D = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case M.a:
						return t.payload;
					default:
						return e
				}
			};
			const L = {};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : L,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				U = n("./node_modules/icepick/icepick.js");
			const B = {};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : B,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.p:
					case k.r: {
						const {
							subredditId: n,
							bannedUsers: s
						} = t.payload;
						return Object(U.merge)(e, {
							[n]: s
						})
					}
					case k.w: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(U.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var H = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.v:
					case k.u:
						return null;
					case k.t:
						return t.payload;
					default:
						return e
				}
			};
			var W = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.v:
							return !0;
						case k.u:
						case k.t:
							return !1;
						default:
							return e
					}
				},
				q = Object(S.c)({
					error: H,
					pending: W
				});
			var V = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.v:
						case k.t:
							return null;
						case k.u: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				z = Object(S.c)({
					api: q,
					result: V
				});
			const K = {};
			var Q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : K,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case k.w: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case k.p: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				J = Object(S.c)({
					api: P,
					fetchedTokens: A,
					inContext: D,
					loadMore: F,
					models: G,
					search: z,
					userOrder: Q
				});
			Object(I.a)({
				features: {
					banned: J
				}
			});
			const Y = Object(a.a)(k.s),
				X = Object(a.a)(k.r),
				Z = Object(a.a)(k.q),
				$ = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							i = t.after || "",
							d = Object(O.e)(e, i),
							c = a.features.banned.fetchedTokens[d];
						if (a.features.banned.api.pending[d] || c) return;
						n(Y({
							subredditId: e,
							fetchedToken: i
						}));
						const l = a.subreddits.models[e].name,
							u = await _(o(), l, t);
						u.ok ? n(X({
							...u.body,
							fetchedToken: i
						})) : n(Z({
							subredditId: e,
							fetchedToken: i
						}))
					}
				},
				ee = Object(a.a)(k.v),
				te = Object(a.a)(k.u),
				ne = Object(a.a)(k.t),
				se = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						i = {
							username: Object(v.a)(t)
						};
					n(ee());
					const d = await _(o(), a, i);
					d.ok ? n(te(d.body)) : n(ne(d.error))
				}, re = Object(a.a)(k.p), oe = Object(a.a)(k.w), ae = (e, t, n) => async (r, a, d) => {
					let {
						apiContext: c
					} = d;
					const u = a(),
						f = u.subreddits.models[e].url,
						g = u.subreddits.models[e].name;
					t.username = Object(v.a)(t.username), r(Object(i.h)(n));
					const O = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: m.jb.POST,
						data: {
							api_type: "json",
							ban_reason: n.reason,
							ban_message: n.banMessage,
							duration: n.duration,
							name: n.username,
							note: n.modNote,
							ban_context: n.contextId,
							type: "banned"
						}
					}))(c(), f, t);
					if (O.ok) {
						r(Object(i.e)(n));
						const e = {
							username: t.username
						};
						r(Object(l.f)({
							kind: x.b.SuccessMod,
							text: s.fbt._("Successfully banned a user", null, {
								hk: "1kORpS"
							})
						}));
						const o = await _(c(), g, e);
						o.ok && r(re(o.body))
					} else {
						r(Object(i.f)(n, O.error));
						const e = o()(O, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(l.f)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, ie = (e, t) => async (n, r, a) => {
					let {
						apiContext: i
					} = a;
					const d = r().subreddits.models[e].url,
						c = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: m.jb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "banned"
							}
						}))(i(), d, t);
					if (c.ok) n(oe({
						subredditId: e,
						userId: t
					})), n(Object(l.f)({
						kind: x.b.SuccessMod,
						text: s.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = o()(c, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(l.f)({
							kind: x.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, de = (e, t) => async (n, s) => {
					const r = s();
					await Promise.all([(async () => {
						if (!Object(E.b)(u.a.BAN_USER)(r) && !Object(j.R)(r, {
								subredditId: e
							})) {
							const t = Object(j.U)(r, {
								subredditId: e
							});
							await n(Object(c.o)(t.name))
						}
					})(), (async () => {
						const s = Object(C.Ab)(r, {
							userName: t
						});
						if (!s) return;
						const o = Object(y.h)(r, {
							subredditId: e
						});
						o && o[s.id] || await n($(e, {
							username: t
						}))
					})()]), n(Object(d.i)(u.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditModeration/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "b", (function() {
				return F
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				a = n("./src/reddit/actions/subredditModeration/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json"),
				l = n("./src/redditGQL/operations/CreateModUserNote.json"),
				u = n("./src/redditGQL/operations/DeleteModUserNote.json"),
				m = n("./src/redditGQL/operations/GetModUserNotes.json"),
				p = n("./src/redditGQL/operations/GetTotalModNoteCount.json");
			var b = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				h = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/selectors/moderatorPermissions.ts"),
				_ = n("./src/reddit/selectors/modUserNotes.ts"),
				v = n("./src/reddit/helpers/trackers/modNote.ts"),
				O = n("./src/telemetry/index.ts"),
				x = n("./src/redditGQL/types.ts"),
				E = n("./src/lib/initializeClient/installReducer.ts"),
				y = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			const {
				fbt: j
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			Object(E.a)({
				features: {
					modUserNotes: y.a
				}
			});
			const C = Object(r.a)(a.U),
				k = Object(r.a)(a.T),
				I = Object(r.a)(a.S),
				S = Object(r.a)(a.R),
				w = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var a;
					const c = n(),
						{
							subredditId: l,
							userId: u,
							before: p,
							filter: b
						} = e,
						g = Object(h.d)(l, u, b, p),
						_ = c.features.modUserNotes.fetchedTokens[g];
					if (!c.features.modUserNotes.api.pending[g] && !_) {
						t(C({
							subredditId: l,
							userId: u,
							filter: b,
							fetchedToken: p
						}));
						try {
							const e = await ((e, t) => Object(d.a)(e, {
								...m,
								variables: {
									...t,
									last: 25
								}
							}))(r(), {
								subredditId: l,
								userId: u,
								filter: b,
								before: p
							});
							if (e.ok) {
								const {
									data: {
										subredditInfoById: n
									}
								} = e.body;
								if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (a = null == n ? void 0 : n.modNotes) || void 0 === a ? void 0 : a.edges)) {
									const {
										edges: e,
										pageInfo: s
									} = n.modNotes, r = [];
									e.forEach(e => {
										e && e.node && r.push(e.node)
									}), t(k({
										notes: r,
										subredditId: l,
										userId: u,
										filter: b,
										fetchedToken: p,
										loadMoreToken: s.hasNextPage ? s.endCursor : null
									}))
								}
								const {
									errors: s
								} = e.body;
								s && s.length && o.c.captureException(s)
							} else t(I({
								subredditId: l,
								userId: u,
								filter: b,
								fetchedToken: p
							})), t(Object(i.f)({
								kind: f.b.Error,
								text: j._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						} catch (v) {
							o.c.captureException(v), t(Object(i.f)({
								kind: f.b.Error,
								text: j._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						}
					}
				}, T = Object(r.a)(a.H), N = Object(r.a)(a.G), P = e => {
					let {
						subredditId: t,
						nodes: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const a = [],
							i = [];
						n.map(e => {
							const t = null == e ? void 0 : e.user.id;
							t && !i.includes(t) && e && (a.push(e), i.push(t))
						}), e(N({
							subredditId: t,
							lastAuthorModNotes: a
						}))
					}
				}, R = (e, t, n) => async (r, o, a) => {
					let {
						gqlContext: i
					} = a;
					var l, u, m, p, h, f, g;
					const {
						hasSortParam: _,
						sortToUse: v
					} = Object(b.a)(o(), e), O = s.Jb[v], E = {
						postId: e,
						requestPostModerationInfo: !t,
						..._ && O && {
							sortType: x.e[O]
						},
						...n && {
							after: n
						}
					}, y = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: {
							...t
						}
					}))(i(), E);
					if (y.ok) {
						const e = null === (l = y.body) || void 0 === l ? void 0 : l.data,
							t = null === (m = null === (u = null == e ? void 0 : e.postInfoById) || void 0 === u ? void 0 : u.subreddit) || void 0 === m ? void 0 : m.id,
							n = null === (h = null === (p = null == e ? void 0 : e.postInfoById) || void 0 === p ? void 0 : p.moderationInfo) || void 0 === h ? void 0 : h.lastAuthorModNote,
							s = null === (g = null === (f = null == e ? void 0 : e.postInfoById) || void 0 === f ? void 0 : f.commentForest) || void 0 === g ? void 0 : g.trees;
						n && r(T({
							subredditId: t,
							lastAuthorModNote: n
						})), s && r((e => {
							let {
								subredditId: t,
								commentTrees: n
							} = e;
							return async (e, s, r) => {
								let {
									gqlContext: o
								} = r;
								const a = [],
									i = [];
								n.map(e => {
									var t, n;
									if (!(null == e ? void 0 : e.node)) return;
									const s = null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote,
										r = null == s ? void 0 : s.user.id;
									r && !i.includes(r) && s && (a.push(s), i.push(r))
								}), e(N({
									subredditId: t,
									lastAuthorModNotes: a
								}))
							}
						})({
							subredditId: t,
							commentTrees: s
						}))
					}
				}, A = Object(r.a)(a.Q), M = (e, t, n, s, r, o) => async (a, c, u) => {
					let {
						gqlContext: m
					} = u;
					var p, b;
					const h = {
							subredditId: e,
							userId: t,
							label: r,
							note: n,
							redditId: o
						},
						g = await ((e, t) => Object(d.a)(e, {
							...l,
							variables: {
								input: t
							}
						}))(m(), h);
					if (g.ok) {
						const n = null === (b = null === (p = g.body) || void 0 === p ? void 0 : p.data) || void 0 === b ? void 0 : b.createModUserNote.createdNote;
						if (!n) return void a(Object(i.f)({
							kind: f.b.Error,
							text: j._("Something went wrong", null, {
								hk: "zYMeg"
							}),
							duration: 3e3
						}));
						a(A({
							subredditId: e,
							newModNote: n,
							filter: s
						})), Object(O.a)(Object(v.v)({
							userId: t,
							subredditId: e,
							filteredType: s,
							modNote: n
						})(c())), a(Object(i.f)({
							kind: f.b.SuccessMod,
							text: j._("Successfully created mod note", null, {
								hk: "10Vu91"
							}),
							duration: 3e3
						}))
					} else {
						const {
							errors: e
						} = g.body, t = e[0] ? e[0].message : j._("Something went wrong", null, {
							hk: "2uu095"
						});
						a(Object(i.f)({
							kind: f.b.Error,
							text: t,
							duration: 3e3
						}))
					}
				}, D = Object(r.a)(a.lb), L = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var a, i;
					const c = s();
					if (!Object(g.i)(c, e)) return;
					const l = {
						subredditId: e,
						userId: t
					};
					if (Object(_.g)(c, t, e)) return;
					const u = await ((e, t) => Object(d.a)(e, {
						...p,
						variables: {
							...t
						}
					}))(o(), l);
					if (u.ok) {
						const s = null === (a = u.body) || void 0 === a ? void 0 : a.data;
						if ("Subreddit" === (null === (i = null == s ? void 0 : s.subredditInfoById) || void 0 === i ? void 0 : i.__typename)) {
							const r = null == s ? void 0 : s.subredditInfoById;
							r && n(D({
								subredditId: e,
								userId: t,
								totalCounts: r
							}))
						}
					}
				}, F = (e, t, n, s) => async (r, o, a) => {
					let {
						gqlContext: c
					} = a;
					const l = {
						subredditId: e,
						userId: t,
						noteId: n,
						noteType: s
					};
					(await ((e, t) => Object(d.a)(e, {
						...u,
						variables: {
							input: t
						}
					}))(c(), l)).ok ? (r(S({
						subredditId: e,
						userId: t,
						noteId: n
					})), r(Object(i.f)({
						kind: f.b.SuccessMod,
						text: j._("Mod Note sucessfully deleted!", null, {
							hk: "17NyFK"
						})
					}))) : r(Object(i.f)({
						kind: f.b.Error,
						text: j._("Could not delete note. Try again later.", null, {
							hk: "1XczhA"
						})
					}))
				}
		},
		"./src/reddit/actions/subredditModeration/mute.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/get.js"),
				a = n.n(o),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const m = (e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
				endpoint: Object(u.a)(`${e.apiUrl}/api/v1/${t}/muted`),
				method: i.jb.GET,
				data: n
			});
			var p = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/subredditModeration/constants.ts");
			const _ = Object(r.a)(g.Y),
				v = Object(r.a)(g.W),
				O = Object(r.a)(g.V),
				x = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const a = s(),
							i = t.after || "",
							d = Object(b.e)(e, i),
							c = a.pages.modHub.muted.fetchedTokens[d];
						if (a.pages.modHub.muted.api.pending[d] || c) return;
						n(_({
							subredditId: e,
							fetchedToken: i
						}));
						const l = a.subreddits.models[e].name,
							u = await m(o(), l, t);
						u.ok ? n(v({
							...u.body,
							fetchedToken: i
						})) : n(O({
							subredditId: e,
							fetchedToken: i
						}))
					}
				},
				E = Object(r.a)(g.bb),
				y = Object(r.a)(g.ab),
				j = Object(r.a)(g.Z),
				C = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s().subreddits.models[e].name,
						i = {
							username: Object(p.a)(t)
						};
					n(E());
					const d = await m(o(), a, i);
					d.ok ? n(y(d.body)) : n(j(d.error))
				}, k = Object(r.a)(g.X), I = Object(r.a)(g.cb), S = (e, t) => async (n, r, o) => {
					let {
						apiContext: u
					} = o;
					const m = r().subreddits.models[e].url,
						p = await ((e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: i.jb.POST,
							data: {
								api_type: "json",
								id: n,
								type: "muted"
							}
						}))(u(), m, t);
					if (p.ok) n(I({
						subredditId: e,
						userId: t
					}));
					else {
						const e = a()(p, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(f.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, w = (e, t, n) => async (r, o, u) => {
					let {
						apiContext: b
					} = u;
					const g = o(),
						_ = g.subreddits.models[e].url,
						v = g.subreddits.models[e].name;
					t = Object(p.a)(t);
					const O = await ((e, t, n, s) => Object(d.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: i.jb.POST,
						data: {
							api_type: "json",
							name: n,
							note: s,
							type: "muted"
						}
					}))(b(), _, t, n);
					if (O.ok) {
						const e = {
							username: t
						};
						r(Object(f.f)({
							kind: h.b.SuccessMod,
							text: s.fbt._("Successfully muted a user", null, {
								hk: "2ypyuL"
							})
						}));
						const n = await m(b(), v, e);
						n.ok && r(k(n.body))
					} else {
						const e = a()(O, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(f.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			const s = "SUBREDDIT__RULES_LOADED",
				r = "SUBREDDIT__RULES_PENDING",
				o = "SUBREDDIT__RULES_FAILED",
				a = "SUBREDDIT__RULE_ADDED",
				i = "SUBREDDIT__RULE_EDITED",
				d = "SUBREDDIT__RULE_REMOVED",
				c = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "j", (function() {
				return D
			})), n.d(t, "i", (function() {
				return L
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/xor.js"),
				i = n.n(a),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/endpoints/subreddit/settings.ts"),
				u = n("./src/telemetry/index.ts"),
				m = n("./src/reddit/actions/toaster.ts"),
				p = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				h = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				g = n("./src/reddit/models/User/index.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/selectors/subredditSettings.ts"),
				O = n("./src/reddit/selectors/user.ts"),
				x = n("./src/reddit/selectors/widgets.ts");
			const E = "SUBREDDIT_SETTINGS_LOADED",
				y = Object(c.a)(E),
				j = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				C = Object(c.a)(j),
				k = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				I = Object(c.a)(k),
				S = (e, t) => async (n, s, r) => {
					let {
						apiContext: o,
						gqlContext: a
					} = r;
					if (!t || !Object(_.W)(s(), t)) {
						const t = await Object(l.b)(o(), e);
						t && t.ok && n(y(t.body))
					}
					if (t && !Object(v.b)(s(), {
							subredditId: t
						})) {
						const e = await Object(p.a)(a(), t);
						if (e && e.ok) {
							const t = e.body,
								s = Object(b.e)(t.data);
							n(C(s))
						}
					}
				}, w = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = Object(O.k)(t());
					r && await e(S(d.kc + Object(g.e)(r)))
				}, T = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", N = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", P = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", R = Object(c.a)(T), A = Object(c.a)(N), M = Object(c.a)(P), D = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (a, d, c) => {
						let {
							apiContext: b,
							gqlContext: g
						} = c;
						a(R());
						const O = d(),
							E = o()(Object(_.W)(O, e), ...Object.keys(t)),
							y = o()(Object(v.b)(O, {
								subredditId: e
							}), ...Object.keys(n)),
							j = await Object(l.f)(b(), e, t),
							C = Object.keys(n).length > 0;
						let k = !0;
						if (C) {
							k = (await Object(p.b)(g(), e, n)).ok
						}
						if (!j.ok || C && !k) a(M()), a(Object(m.f)({
							kind: f.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: D(e, t, y, void 0)
						})), r && Object(u.a)(Object(h.c)(O, "BE returned an error:"));
						else {
							const o = Object(l.c)(j.body);
							a(A({
								settings: {
									...o,
									subredditId: e
								},
								idCardWidgetId: Object(x.c)(O, {
									subredditId: e
								})
							})), C && a(I({
								notificationSettings: n,
								subredditId: e
							}));
							const d = {};
							r && 0 === i()(Object.keys(t), Object.keys(E)).length && (d.buttonText = s.fbt._("Undo", null, {
								hk: "1Gskii"
							}), d.buttonAction = D(e, E, y, r)), a(Object(m.f)({
								kind: f.b.SuccessCommunity,
								text: s.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								}),
								...d
							}))
						}
					}
				}, L = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					(await Object(l.d)(a(), e, t)).ok ? n(Object(m.f)({
						kind: f.b.SuccessCommunity,
						text: s.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : n(Object(m.f)({
						kind: f.b.Error,
						text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			}));
			const s = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				o = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				a = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				i = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				d = "SUBSCRIPTION__ORDER_LOADED",
				c = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return R
			})), n.d(t, "d", (function() {
				return M
			})), n.d(t, "c", (function() {
				return L
			})), n.d(t, "a", (function() {
				return U
			})), n.d(t, "b", (function() {
				return G
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/linkMatchers/customLinks.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/emailVerificationTooltip.ts"),
				d = n("./src/reddit/actions/login.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/subscription/constants.ts"),
				u = n("./src/reddit/actions/toaster.ts"),
				m = n("./src/reddit/constants/posts.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts");
			var f = n("./src/reddit/endpoints/subreddit/subscriptions.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				v = n("./src/reddit/models/GqlTopLevelField.ts"),
				O = n("./src/reddit/models/User/index.ts");

			function x(e) {
				const t = [],
					n = [],
					s = {},
					r = {},
					{
						followedRedditorsInfo: o
					} = e.identity;
				for (const i of o.edges) {
					if (i.node.__typename !== O.c.AvailableRedditor || !i.node.profile) continue;
					const e = Object(g.a)(i.node.profile);
					s[e.id] = e;
					const {
						isFavorite: n
					} = i.node.profile;
					n && t.push(e.id)
				}
				const {
					subscribedSubreddits: a
				} = e.identity;
				for (const i of a.edges) {
					if (i.node.__typename !== v.a.Subreddit) continue;
					const e = Object(_.a)(i.node);
					r[e.id] = e;
					const {
						isFavorite: t
					} = i.node;
					t && n.push(e.id)
				}
				return {
					favoriteProfileIds: t,
					favoriteSubredditIds: n,
					profiles: s,
					subreddits: r
				}
			}
			var E = n("./src/reddit/models/Toast/index.ts"),
				y = n("./src/reddit/selectors/experiments/emailEnablement.ts"),
				j = n("./src/reddit/selectors/profile.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/selectors/subscriptions.ts"),
				I = n("./src/reddit/selectors/user.ts");
			const S = () => s.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				w = Object(a.a)(l.c),
				T = Object(a.a)(l.b),
				N = Object(a.a)(l.a),
				P = Object(a.a)(l.h),
				R = (Object(a.a)(l.i), Object(a.a)(l.g), () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subscriptions.api.fetched) return;
					e(T());
					const o = await Object(f.a)(s());
					if (o.ok) {
						const t = x(o.body.data);
						e(w(t))
					} else e(N({
						error: o.error
					}))
				}),
				A = (e, t) => t.type === m.a.PROFILE && e.displayText === t.name.replace("u_", ""),
				M = (e, t, n) => async (a, l, p) => {
					let {
						apiContext: b
					} = p, h = e.map(e => e.type === m.a.SUBREDDIT ? {
						id: Object(C.F)(l(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(j.m)(l(), e.name),
						name: `${r.kc}${e.name}`,
						type: e.type
					});
					if (!Object(I.Q)(l())) return a(Object(c.k)({
						actionSource: c.a.Subscribe
					})), void a(Object(d.openRegisterModal)());
					const g = Object(I.k)(l());
					if (g) {
						const t = h.length,
							n = e.length;
						if (h = h.filter(e => !A(g, e)), (e = e.filter(e => !A(g, e))).length !== n || h.length !== t) {
							const e = s.fbt._("You cannot follow yourself!", null, {
								hk: "3tfSaq"
							});
							a(Object(u.f)(Object(u.e)(e, E.b.Error)))
						}
						if (!e.length && !h.length) return
					}
					a(P({
						identifiers: h,
						nameIdentifiers: e,
						profileModels: l().profiles.models,
						subredditModels: l().subreddits.models,
						subscriptionsCount: Object(k.b)(l()),
						userIsSubscriber: t,
						widgetId: n
					}));
					const _ = await Object(f.c)(b(), {
						subredditNames: h.map(e => {
							let {
								name: t
							} = e;
							return t
						}),
						subscribe: t
					});
					if (_.ok) {
						const n = 1 === e.length ? `${"subreddit"===e[0].type?o.d.subreddit:o.d.profile}${e[0].name}` : s.fbt._({
								"*": "{communities} communities",
								_1: "1 community"
							}, [s.fbt._plural(e.length, "communities")], {
								hk: "IgDzJ"
							}),
							r = s.fbt._("Successfully followed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "23Snyg"
							}),
							i = s.fbt._("Successfully unfollowed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "jfC0S"
							}),
							d = s.fbt._("Successfully joined {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1W9UY3"
							}),
							c = s.fbt._("Successfully left {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1saMW"
							});
						a(Object(u.f)({
							text: 1 === e.length && "profile" === e[0].type ? t ? r : i : t ? d : c
						}))
					} else {
						a(P({
							identifiers: h,
							nameIdentifiers: e,
							profileModels: l().profiles.models,
							subredditModels: l().subreddits.models,
							subscriptionsCount: Object(k.b)(l()),
							userIsSubscriber: !t,
							widgetId: n
						}));
						const r = s.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						a(Object(u.f)(Object(u.e)(r, E.b.Error)))
					}
					return t && Object(y.a)(l()) && (1 === e.length && "profile" === e[0].type ? a(Object(i.c)("user_follow")) : a(Object(i.c)("join"))), _.ok
				}, D = Object(a.a)(l.f), L = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						a = Object(C.M)(o, {
							identifier: e
						});
					if (!a) throw new Error(`actions.subscription -- No subreddit or profile found with id ${e.id}`);
					const i = e.type === m.a.SUBREDDIT ? a.name : `u_${a.name}`,
						d = o.subscriptions.favoriteSubredditOrder || [],
						c = o.subscriptions.favoriteProfileOrder || [],
						l = d.indexOf(e.id),
						p = c.indexOf(e.id),
						b = -1 === l && -1 === p,
						h = o.subreddits.models,
						g = o.profiles.models,
						_ = {
							type: e.type,
							name: a.name
						},
						v = () => Object(C.gb)(n(), {
							identifier: _
						});
					(v() || (await t(M([_], !0)), v())) && (t(D({
						makeFavorite: b,
						identifier: e,
						subredditModels: h,
						profileModels: g
					})), (await Object(f.b)(r(), i, b)).ok || (t(D({
						makeFavorite: !b,
						identifier: e,
						subredditModels: h,
						profileModels: g
					})), t(Object(u.f)({
						text: S(),
						kind: E.b.Error
					}))))
				}, F = Object(a.a)(l.d), U = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const a = n().multireddits.models,
						i = () => {
							t(Object(u.f)({
								text: S(),
								kind: E.b.Error
							}))
						},
						d = a[e];
					if (!d) return void i();
					const c = !d.isFavorited;
					t(F({
						makeFavorite: c,
						multiredditPath: e,
						multiredditsModelsState: a
					})), (await ((e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
						method: r.jb.POST,
						endpoint: `${e.apiUrl}/api/multi/favorite`,
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(o(), e, c)).ok || (t(F({
						makeFavorite: !c,
						multiredditPath: e,
						multiredditsModelsState: a
					})), i())
				}, B = Object(a.a)(l.e), G = e => async (t, n, o) => {
					let {
						apiContext: a
					} = o;
					const i = n(),
						d = i.multireddits.models;
					if (!Object(I.Q)(i)) return;
					const c = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(u.f)({
								text: s.fbt._("Sorry, failed to {followAction}", [s.fbt._param("followAction", e ? s.fbt._("follow", null, {
									hk: "3YMYJK"
								}) : s.fbt._("unfollow", null, {
									hk: "24IYxj"
								}))], {
									hk: "1ufRSl"
								}),
								kind: E.b.Error
							}))
						},
						l = d[e];
					if (!l) return void c();
					const m = !l.isFollowed;
					t(B({
						follow: m,
						multiredditPath: e,
						multiredditsModelsState: d
					})), (await ((e, t, n) => Object(p.a)(Object(b.a)(e, [h.a]), {
						method: r.jb.POST,
						endpoint: `${e.apiUrl}/api/multi/subscribe`,
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(a(), e, m)).ok || (t(B({
						follow: !m,
						multiredditPath: e,
						multiredditsModelsState: d
					})), c(m))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				i = n("./src/reddit/helpers/tabBadging/index.ts"),
				d = n("./src/reddit/models/Badge/index.ts"),
				c = n("./src/reddit/selectors/appBadges.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/reddit/actions/appBadgeIndicators/index.ts");
			const m = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				p = Object(o.a)(m),
				b = (e, t) => {
					e <= 0 ? r.a.write(() => {
						Object(i.b)(!1), window.document.title = t
					}) : r.a.write(() => {
						Object(i.b)(), window.document.title = `(${e}) ${t}`
					})
				},
				h = Object(s.c)({
					basicChannelCount: c.e,
					subredditChannelCount: c.d,
					subredditMentionCount: c.c
				}),
				f = () => async (e, t) => {
					const n = t(),
						s = Object(a.g)(n, {});
					if (!(Object(l.P)(n) || Object(l.Q)(n)) || !s) return;
					const r = Object(c.i)(n);
					b(r, s), e(p({
						hasUnreadMessages: !!r
					}))
				}, g = () => async (e, t) => {
					{
						e(f());
						const n = (e => ({
							inboxCount: Object(c.h)(e),
							basicChannelCount: Object(c.e)(e)
						}))(t());
						Object(i.c)(n)
					}
				}, _ = e => async (t, n) => {
					const s = n(),
						r = Object(c.e)(s),
						o = Object(c.h)(s),
						{
							basicChannelCount: a,
							inboxCount: i
						} = e;
					if (r !== a) {
						const e = Object(u.e)({
							count: a,
							key: d.c.ChatTab
						});
						t(Object(u.a)(e))
					}
					if (i && i !== o) {
						const e = Object(u.e)({
							count: i,
							key: d.c.MessageTab
						});
						t(Object(u.a)(e))
					}(r !== a || i && i !== o) && t(f())
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "t", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "r", (function() {
				return o
			})), n.d(t, "q", (function() {
				return a
			})), n.d(t, "s", (function() {
				return i
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "v", (function() {
				return b
			})), n.d(t, "w", (function() {
				return h
			})), n.d(t, "u", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "A", (function() {
				return O
			})), n.d(t, "z", (function() {
				return x
			})), n.d(t, "D", (function() {
				return E
			})), n.d(t, "y", (function() {
				return y
			})), n.d(t, "C", (function() {
				return j
			})), n.d(t, "x", (function() {
				return C
			})), n.d(t, "B", (function() {
				return k
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "i", (function() {
				return P
			}));
			const s = "TAGS__REQUESTED",
				r = "TAGS__AVAILABLE_LOADED",
				o = "TAGS__LOADED",
				a = "TAGS__FAILURE",
				i = "TAGS__RELEVANCE_LOADED",
				d = "TAGS__CREATE_REQUESTED",
				c = "TAGS__CREATE_SUCCESS",
				l = "TAGS__CREATE_FAILURE",
				u = "TAGS__DELETE_REQUESTED",
				m = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				b = "TAGS__UPDATE_STATE_REQUESTED",
				h = "TAGS__UPDATE_STATE_SUCCESS",
				f = "TAGS__UPDATE_STATE_FAILURE",
				g = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				_ = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				v = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				O = "TAGS__OPTIONS_CANCELLED",
				x = "TAGS__OPTION_SELECTED",
				E = "TAGS__SUGGESTED_OPTION_SELECTED",
				y = "TAGS__OPTION_DESELECTED",
				j = "TAGS__SUGGESTED_OPTION_DESELECTED",
				C = "TAGS__INPUT_CHANGED",
				k = "TAGS__SUGGESTED_INPUT_CHANGED",
				I = "GLOBAL__TAGS__LOADED",
				S = "CREATION__TAGS_INPUT_CHANGED",
				w = "CREATION__TAGS_OPTION_SELECTED",
				T = "CREATION__TAGS_OPTION_DESELECTED",
				N = "CREATION__PRIMARY_TAG_SELECTED",
				P = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return D
			})), n.d(t, "m", (function() {
				return L
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			})), n.d(t, "k", (function() {
				return G
			})), n.d(t, "a", (function() {
				return V
			})), n.d(t, "f", (function() {
				return z
			})), n.d(t, "g", (function() {
				return Q
			})), n.d(t, "e", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return $
			})), n.d(t, "b", (function() {
				return ee
			})), n.d(t, "n", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ne
			})), n.d(t, "o", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tags/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts");
			const i = e => {
				const {
					subredditInfoById: t
				} = e, n = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: n
					} = t;
					return e[n.subreddit && n.subreddit.id || "global"][n.id] = n, e
				}, n);
				const s = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, s);
				const r = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, r), {
					primaryTag: t.primaryTag,
					globalSubredditTags: n.global,
					subredditScopedTags: {
						[t.id]: n[t.id]
					},
					subredditId: t.id,
					itemTags: s,
					suggestedItemTags: r,
					geoPlace: t.geoPlace
				}
			};
			var d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CreateSubredditTags.json");
			const l = 1050;
			n("./src/redditGQL/operations/FetchGlobalTags.json");
			var u = n("./src/redditGQL/operations/FetchSubredditTags.json");
			const m = (e, t) => {
				let {
					subredditId: n,
					pageSize: s = l,
					after: r,
					includeAvailableTags: o
				} = t;
				return Object(d.a)(e, {
					...u,
					variables: {
						subredditId: n,
						pageSize: s,
						after: r,
						includeAvailableTags: o
					}
				})
			};
			var p = n("./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const b = (e, t) => Object(d.a)(e, {
				...p,
				variables: {
					...t,
					deleteTags: 0 !== t.deleteTagsInput.length,
					pageSize: l
				}
			});
			var h = n("./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json");
			const f = (e, t) => Object(d.a)(e, {
				...h,
				variables: t
			});
			var g = n("./src/redditGQL/operations/UpdateSubredditPrimaryTag.json");
			const _ = e => {
					const {
						secondaryTags: t,
						id: n,
						primaryTag: s
					} = e.updateSubredditTagStates.subreddit, r = t && t.edges || [];
					return {
						subredditId: n,
						primaryTagId: s && s.tag.id || null,
						secondaryTags: r.reduce((e, t) => {
							let {
								node: n
							} = t;
							return e[n.tag.id] = n, e
						}, {})
					}
				},
				v = (e, t) => Object(d.a)(e, {
					...g,
					variables: t
				});
			var O = n("./src/reddit/helpers/tags/index.ts"),
				x = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				E = n("./src/reddit/models/Tags/index.ts"),
				y = n("./src/reddit/models/Toast/index.ts"),
				j = n("./src/reddit/reducers/tags/selected/index.ts"),
				C = n("./src/reddit/selectors/tags.ts");
			Object(r.a)(o.e);
			const k = Object(r.a)(o.t),
				I = Object(r.a)(o.r),
				S = Object(r.a)(o.s),
				w = Object(r.a)(o.q),
				T = Object(r.a)(o.l),
				N = Object(r.a)(o.m),
				P = Object(r.a)(o.k),
				R = Object(r.a)(o.v),
				A = Object(r.a)(o.w),
				M = Object(r.a)(o.u),
				D = Object(r.a)(o.z),
				L = Object(r.a)(o.D),
				F = Object(r.a)(o.y),
				U = Object(r.a)(o.C),
				B = Object(r.a)(o.x),
				G = Object(r.a)(o.B),
				H = (Object(r.a)(o.d), Object(r.a)(o.c), Object(r.a)(o.b), Object(r.a)(o.g)),
				W = Object(r.a)(o.h),
				q = Object(r.a)(o.f),
				V = Object(r.a)(o.a),
				z = Object(r.a)(o.i),
				K = Object(r.a)(o.A),
				Q = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, d) => {
						let {
							gqlContext: c
						} = d;
						const l = o();
						r(k());
						const u = await m(c(), {
								subredditId: e
							}),
							p = u.body;
						if (u.ok && p.data.subredditInfoById.secondaryTags && p.data.subredditInfoById.availableTags && p.data.subredditInfoById.suggestedTags) r(I(i(p.data))), n && x.h(o(), e, {
							context: t
						});
						else {
							r(w());
							const o = n ? "topics_save" : "topics_load";
							x.g(l, e, o, {
								context: t
							}), r(Object(a.f)(Object(a.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), y.b.Error, s.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), Q(e, t, n))))
						}
					}
				},
				J = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					t(k());
					const d = await m(o(), {
						subredditId: e
					});
					if (d.ok) {
						const e = d.body;
						t(S(i(e.data)))
					} else t(w()), t(Object(a.f)(Object(a.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), y.b.Error, s.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), S(e))))
				}, Y = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!t.length) return null;
					n(T());
					const a = t.map(t => ({
							subredditId: e,
							...t
						})),
						i = await ((e, t) => Object(d.a)(e, {
							...c,
							variables: t
						}))(o(), {
							input: a
						}),
						l = i.body && i.body.data || null;
					return i.ok && l && l.createSubredditTags && l.createSubredditTags.ok ? (n(N()), l.createSubredditTags.createdTags || []) : (n(P()), null)
				}, X = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (s, r, o) => {
						let {
							gqlContext: a
						} = o;
						if (!t.length && !n.length) return;
						s(R());
						const d = r(),
							c = Object(C.d)(d, {
								subredditId: e
							}),
							l = Object(C.o)(d, {
								itemId: e
							}),
							u = Object(C.z)(d, {
								itemId: e
							}),
							m = new Set;
						for (const e of t)
							if (e.state === E.d.NONE && c[e.tagId] && !u[e.tagId]) {
								!!n.find(t => t.state === E.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} for (const e of n)
							if (e.state === E.d.NONE && c[e.tagId] && !l[e.tagId]) {
								!!t.find(t => t.state === E.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} const p = await b(a(), {
								deleteTagsInput: [...m].map(t => ({
									tagId: t,
									subredditId: e
								})),
								updateTagStatesInput: {
									subredditId: e,
									suggestedTagStates: n,
									tagStates: t
								}
							}),
							h = p.body && p.body.data || null;
						p.ok && h && h.updateSubredditTagStates && h.updateSubredditTagStates.ok && h.updateSubredditTagStates.subreddit ? s(A(i({
							subredditInfoById: h.updateSubredditTagStates.subreddit
						}))) : s(M())
					}
				}, Z = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, i) => {
						const d = o(),
							c = Object(C.q)(d, {
								subredditId: e
							}),
							l = Object(C.C)(d, {
								subredditId: e
							});
						let u = c.filter(e => !!e.id && !!e.action).map(e => ({
							tagId: e.id,
							state: e.action === j.a.ADD ? E.d.TAGGED : E.d.NONE
						}));
						if (l.length > 0) {
							const t = await Y(e, l)(r, o, i);
							u = u.concat((t || []).map(e => ({
								tagId: e.id,
								state: E.d.TAGGED
							})))
						}
						await X(e, u)(r, o, i), Object(C.A)(o()) ? r(Object(a.f)(Object(a.e)(s.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), Z(e, t, n)))) : n && r(Object(a.f)(Object(a.e)(s.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), y.b.SuccessCommunity)))
					}
				}, $ = (e, t, n) => async (n, r, o) => {
					const i = {
						state: E.d.TAGGED
					};
					if (Object(O.b)(t)) {
						const s = await Y(e, [{
							text: t.displayText,
							type: E.c.CLASSIFICATION
						}])(n, r, o);
						s && 1 === s.length && (i.tagId = s[0].id)
					} else {
						if (!t.id) return void n(Object(a.f)(Object(a.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), y.b.Error)));
						i.tagId = t.id
					}(e => !!e.tagId && !!e.state)(i) ? await X(e, [], [i])(n, r, o): n(Object(a.f)(Object(a.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), y.b.Error)))
				}, ee = (e, t, n) => async (s, r, o) => {
					t.id ? await X(e, [], [{
						state: E.d.NONE,
						tagId: t.id
					}])(s, r, o) : s(Q(e, n, !1))
				}, te = function(e, t, n, r) {
					let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (i, d, c) => {
						let {
							gqlContext: l
						} = c;
						if (!(await f(l(), {
								input: {
									tagStatesRelevance: t,
									suggestedTagStatesRelevance: n
								}
							})).ok) return i(Object(a.f)(Object(a.e)(s.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), te(e, t, n, r, o)))), void i(J(e));
						if (o)
							for (const e of n) x.f(d(), e, {
								context: r
							});
						i(Object(a.f)(Object(a.e)(s.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), y.b.SuccessCommunity, s.fbt._("Undo", null, {
							hk: "34apPL"
						}), te(e, t.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), n.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), r, o)))), i(J(e))
					}
				}, ne = e => async (t, n) => {
					t(K({
						itemTagsState: {
							[e]: Object(C.o)(n(), {
								itemId: e
							})
						}
					}))
				}, se = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (r, o, i) => {
						let {
							gqlContext: d
						} = i;
						const c = Object(C.x)(o(), {
							subredditId: e
						});
						if ((null == c ? void 0 : c.id) === t.tagId && t.state === E.d.TAGGED) return;
						r(H());
						const l = await v(d(), {
								input: {
									subredditId: e,
									primaryTagState: t
								}
							}),
							u = l.body && l.body.data || null;
						l.ok && u && u.updateSubredditTagStates && u.updateSubredditTagStates.ok ? (r(W(_(u))), n && r(Object(a.f)(Object(a.e)(s.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), y.b.SuccessCommunity)))) : (r(q()), r(Object(a.f)(Object(a.e)(s.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), se(e, t)))))
					}
				}
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				r = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				o = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "l", (function() {
				return w
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "j", (function() {
				return N
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/get.js"),
				r = n.n(s),
				o = n("./node_modules/uuid/v4.js"),
				a = n.n(o),
				i = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/uploadToS3/index.ts"),
				c = n("./src/reddit/models/Upload/index.ts");
			const l = "UPLOAD_PENDING",
				u = "UPLOAD_UPLOADING",
				m = "UPLOAD_METADATA_CHANGED",
				p = "UPLOAD_PROGRESS",
				b = "UPLOAD_SUCCESS",
				h = "UPLOAD_FAILED",
				f = "UPLOAD_CANCELED",
				g = "UPLOAD_REMOVED",
				_ = Object(i.a)(l),
				v = Object(i.a)(u),
				O = Object(i.a)(m),
				x = Object(i.a)(p),
				E = Object(i.a)(b),
				y = Object(i.a)(h),
				j = Object(i.a)(f),
				C = Object(i.a)(g),
				k = new Map,
				I = (e, t) => {
					const n = k.get(e) || [];
					n.push(t), k.set(e, n)
				},
				S = (e, t) => {
					const n = k.get(e);
					n && n.forEach(n => n(e, t)), k.delete(e)
				},
				w = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (o, i, l) => {
						let {
							apiContext: u
						} = l;
						const m = t;
						if (i().uploads[m] && Object(c.c)(i().uploads[m])) return;
						const p = a()(),
							b = () => {
								const e = i().uploads[m];
								return !e || e.id !== p || e.status === c.a.CANCELED
							};
						o(_({
							key: m,
							id: p,
							file: e
						}));
						const {
							uploadLease: h,
							error: f
						} = await n(i().uploads[m]);
						if (b()) return;
						if (f || !h) return void o(y({
							key: m,
							error: f
						}));
						let g;
						I(p, () => {
							g && g.abort()
						}), o(v({
							key: m
						}));
						const O = await Object(d.a)(e, h, e => (g = e, s && e.on("progress", e => {
							if (!b() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								o(x({
									key: m,
									progress: t
								}))
							}
						}), e));
						if (g = null, !b())
							if (O.ok) {
								const e = decodeURIComponent(O.body.PostResponse.Location);
								o(E({
									key: m,
									url: e
								}))
							} else {
								const e = r()(O, "body.Error.Message.0"),
									t = {
										type: "ERROR",
										...e ? {
											fields: [{
												field: "0",
												msg: e
											}]
										} : {}
									};
								o(y({
									key: m,
									error: t
								}))
							}
					}
				},
				T = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						const r = s().uploads[e];
						r && (S(r.id, t), n(t ? C({
							key: e
						}) : j({
							key: e
						})))
					}
				},
				N = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						Object.keys(s().uploads).forEach(s => {
							s.startsWith(e) && n(T(s, t))
						})
					}
				}
		},
		"./src/reddit/actions/urlRequested.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/matchRoute/index.ts"),
				r = n("./src/lib/opener/index.ts"),
				o = n("./node_modules/react-router-redux/es/index.js");
			const a = function(e) {
				let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
				return async (n, a, i) => {
					let {
						routes: d
					} = i;
					const c = a();
					Object(s.a)(e, d, c) ? n(Object(o.b)(e)) : t ? Object(r.e)(e, "_blank") : window.location.assign(e)
				}
			}
		},
		"./src/reddit/actions/userFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "i", (function() {
				return o
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "p", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "m", (function() {
				return g
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "k", (function() {
				return O
			}));
			const s = "USER_FLAIR_DATA__MUTATED",
				r = "AUTHOR_FLAIR_DATA__MUTATED",
				o = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING",
				a = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				i = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED",
				d = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING",
				c = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				l = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED",
				u = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING",
				m = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				p = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED",
				b = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING",
				h = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				f = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED",
				g = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				_ = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS",
				v = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				O = "USERFLAIR_FETCH_SUCCESS"
		},
		"./src/reddit/actions/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairChanged)),
				o = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleUserFlairInSubreddit)),
				a = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleAssignOwnFlairPermission)),
				i = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.saveUserFlairTemplate)),
				d = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.deleteUserFlairTemplate)),
				c = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.reorderUserFlairTemplates)),
				l = Object(s.a)(() => Promise.resolve().then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairLoadedAndModalOpened))
		},
		"./src/reddit/actions/userFlair/userFlair.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "userFlairEnabledSettingPending", (function() {
				return v
			})), n.d(t, "userFlairEnabledSettingSuccess", (function() {
				return O
			})), n.d(t, "userFlairEnabledSettingFailed", (function() {
				return x
			})), n.d(t, "userFlairAllowAssingOwnSettingPending", (function() {
				return E
			})), n.d(t, "userFlairAllowAssignOwnSettingSuccess", (function() {
				return y
			})), n.d(t, "userFlairAllowAssingOwnSettingFailed", (function() {
				return j
			})), n.d(t, "userFlairSaveTemplatePending", (function() {
				return C
			})), n.d(t, "userFlairSaveTemplateSuccess", (function() {
				return k
			})), n.d(t, "userFlairSaveTemplateFailed", (function() {
				return I
			})), n.d(t, "userFlairDeleteTemplatePending", (function() {
				return S
			})), n.d(t, "userFlairDeleteTemplateSuccess", (function() {
				return w
			})), n.d(t, "userFlairDeleteTemplateFailed", (function() {
				return T
			})), n.d(t, "userFlairReorderTemplatesPending", (function() {
				return N
			})), n.d(t, "userFlairReorderTemplatesSuccess", (function() {
				return P
			})), n.d(t, "userFlairReorderTemplatesFailed", (function() {
				return R
			})), n.d(t, "userFlairFetchSuccess", (function() {
				return A
			})), n.d(t, "userFlairMutated", (function() {
				return M
			})), n.d(t, "authorFlairMutated", (function() {
				return D
			})), n.d(t, "userFlairChanged", (function() {
				return L
			})), n.d(t, "toggleUserFlairInSubreddit", (function() {
				return F
			})), n.d(t, "toggleAssignOwnFlairPermission", (function() {
				return U
			})), n.d(t, "saveUserFlairTemplate", (function() {
				return B
			})), n.d(t, "deleteUserFlairTemplate", (function() {
				return G
			})), n.d(t, "reorderUserFlairTemplates", (function() {
				return H
			})), n.d(t, "userFlairLoadedAndModalOpened", (function() {
				return W
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/isEmpty.js"),
				a = n.n(o),
				i = n("./src/reddit/actions/authorFlair.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/flair/index.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/models/User/index.ts"),
				b = n("./src/reddit/selectors/subreddit.ts"),
				h = n("./src/reddit/selectors/userFlair.ts"),
				f = n("./src/lib/initializeClient/installReducer.ts"),
				g = n("./src/reddit/reducers/features/userFlair/index.ts"),
				_ = n("./src/reddit/actions/userFlair/constants.ts");
			Object(f.a)({
				features: {
					userFlair: g.a
				}
			});
			const v = Object(r.a)(_.i),
				O = Object(r.a)(_.j),
				x = Object(r.a)(_.h),
				E = Object(r.a)(_.c),
				y = Object(r.a)(_.d),
				j = Object(r.a)(_.b),
				C = Object(r.a)(_.p),
				k = Object(r.a)(_.q),
				I = Object(r.a)(_.o),
				S = Object(r.a)(_.f),
				w = Object(r.a)(_.g),
				T = Object(r.a)(_.e),
				N = Object(r.a)(_.m),
				P = Object(r.a)(_.n),
				R = Object(r.a)(_.l),
				A = Object(r.a)(_.k),
				M = Object(r.a)(_.r),
				D = Object(r.a)(_.a),
				L = (e, t, n, s, r) => async (o, a, i) => {
					let {
						apiContext: d
					} = i;
					const u = a(),
						m = u.user.account,
						f = m ? Object(p.e)(m) : void 0,
						g = {
							...Object(h.d)(u, {
								subredditId: r
							}).displaySettings,
							isUserEnabled: n
						},
						_ = {
							userName: s,
							subredditId: r,
							applied: e,
							displaySettings: g
						};
					o(s === f ? M(_) : D(_));
					const v = Object(b.U)(u, {
							subredditId: r
						}),
						O = t && e ? Object(l.g)(e) : void 0;
					Object(c.g)(d(), s, v.name, t, O), s === f && Object(c.i)(d(), n, v.name)
				}, F = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(b.U)(a, {
							subredditId: e
						}).name;
					n(v());
					const d = await Object(c.l)(o(), i, t);
					if (d.ok) {
						n(O({
							subredditId: e,
							isEnabled: t
						}))
					} else n(x());
					return d.ok
				}, U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = s(),
						i = Object(b.U)(a, {
							subredditId: e
						}).name;
					n(E());
					const d = await Object(c.j)(o(), t, u.d.UserFlair, i);
					if (d.ok) {
						n(y({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(j());
					return d.ok
				}, B = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r(),
						l = Object(b.U)(i, {
							subredditId: t
						}).name;
					n(C());
					const p = await Object(c.f)(a(), e, l, u.d.UserFlair),
						h = p.ok && !(p.body && !1 === p.body.success);
					if (h) {
						const e = {
							subredditId: t,
							template: p.body
						};
						n(k(e));
						const r = Object(d.e)(s.fbt._("Flair saved!", null, {
							hk: "354KI0"
						}), m.b.SuccessMod);
						n(Object(d.f)(r))
					} else {
						n(I());
						const r = Object(d.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4tkRNl"
						}), m.b.Error, s.fbt._("Retry", null, {
							hk: "4zNHTm"
						}), B(e, t));
						n(Object(d.f)(r))
					}
					return h
				}, G = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r(),
						l = Object(b.U)(i, {
							subredditId: t
						}).name;
					if (n(S()), (await Object(c.b)(a(), e, l)).ok) {
						n(w({
							subredditId: t,
							templateId: e
						}));
						const r = Object(d.e)(s.fbt._("Flair deleted!", null, {
							hk: "1mNdn0"
						}), m.b.SuccessMod);
						n(Object(d.f)(r))
					} else {
						n(T());
						const r = Object(d.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "2QrdJr"
						}), m.b.Error, s.fbt._("Retry", null, {
							hk: "1buF3Y"
						}), G(e, t));
						n(Object(d.f)(r))
					}
				}, H = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = r(),
						l = Object(b.U)(i, {
							subredditId: t
						}).name,
						p = Object(h.d)(i, {
							subredditId: t
						}).templateIds;
					if (n(N({
							subredditId: t,
							templateIds: e
						})), (await Object(c.e)(a(), l, u.d.UserFlair, e)).ok) {
						n(P());
						const e = Object(d.e)(s.fbt._("Flair reorder saved.", null, {
							hk: "1zrDON"
						}), m.b.SuccessMod);
						n(Object(d.f)(e))
					} else {
						n(R({
							subredditId: t,
							templateIds: p
						}));
						const r = Object(d.e)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "3gAbwk"
						}), m.b.Error, s.fbt._("Retry", null, {
							hk: "2nPnNw"
						}), H(e, t));
						n(Object(d.f)(r))
					}
				}, W = (e, t) => async (n, r, o) => {
					let {
						apiContext: l
					} = o;
					var u;
					const p = r(),
						h = null === (u = p.features) || void 0 === u ? void 0 : u.userFlair;
					if (h && h[e] && h[e].displaySettings.isEnabled && a()(h[e].templateIds)) {
						const r = Object(b.U)(p, {
								subredditId: e
							}).name,
							o = await Object(c.d)(l(), r);
						if (o.ok) n(A(o.body)), n(Object(i.b)({
							username: t,
							subredditId: e
						}));
						else {
							const e = Object(d.e)(s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							}), m.b.Error);
							n(Object(d.f)(e))
						}
					} else n(Object(i.b)({
						username: t,
						subredditId: e
					}))
				}
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return s
			})), n.d(t, "i", (function() {
				return r
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			const s = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				a = "WIDGETS_SORTED",
				i = "WIDGETS__STARTED_EDITING_WIDGET",
				d = "WIDGETS__LOADED",
				c = "SUBREDDIT__WIDGETS_PENDING",
				l = "SUBREDDIT__WIDGETS_LOADED",
				u = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "f", (function() {
				return A
			})), n.d(t, "g", (function() {
				return F
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/apiRequestState.ts"),
				a = n("./src/reddit/actions/imageUploads.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			const m = async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: `${e.apiUrl}/r/${t}/api/widgets`,
				method: d.jb.GET,
				type: "json",
				data: {
					progressive_images: n
				}
			});
			var p = n("./src/reddit/helpers/getGenericUploadError.ts"),
				b = n("./src/reddit/helpers/media/index.ts"),
				h = n("./src/lib/assertNever.ts"),
				f = n("./src/reddit/models/Widgets/index.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/helpers/widgets/index.tsx"),
				v = n("./src/reddit/models/Image/index.tsx"),
				O = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				E = n("./src/reddit/actions/widgets/constants.ts");
			const y = Object(r.a)(E.g),
				j = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: h
					} = b;
					r(Object(o.h)(n));
					const f = m(),
						E = Object(g.U)(f, {
							subredditId: e
						}).name,
						j = Object(x.e)(f),
						C = Object(_.e)(t);
					let k = null,
						I = null;
					try {
						(k = await Object(a.f)(f, v.a.Widgets)) && (I = Object(a.m)(k)(r, m, b))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					if (j && I) try {
						await I
					} catch (w) {}
					const S = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget`,
						method: d.jb.POST,
						type: "json",
						data: n
					}))(h(), E, C);
					if (S.ok) {
						let a = S.body;
						const d = a.id;
						if ("calendar" === t.kind && r(Object(i.f)({
								kind: O.b.SuccessMod,
								text: s.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), k) {
							if (!j) try {
								await I
							} catch (w) {}
							a = await r(U(e, d)) || a
						}
						r(y({
							subredditId: e,
							widget: a,
							widgetId: d
						})), r(Object(o.e)(n))
					} else k && k.websocket.close(), r(Object(o.f)(n, S.error))
				}, C = Object(r.a)(E.i), k = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: E
					} = b;
					r(Object(o.h)(n));
					const y = t.id,
						j = m(),
						k = Object(g.U)(j, {
							subredditId: e
						}).name,
						I = Object(x.e)(j),
						S = Object(_.e)(t);
					let w = null,
						T = null;
					try {
						(w = await Object(a.f)(j, v.a.Widgets)) && (T = Object(a.m)(w)(r, m, b))
					} catch (P) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					if (I && T) try {
						await T
					} catch (P) {}
					const N = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
						method: d.jb.PUT,
						type: "json",
						data: n
					}))(E(), k, S);
					if (N.ok) {
						let a = function(e, t, n) {
							switch (e.kind) {
								case f.i.Calendar:
								case f.i.IdCard:
								case f.i.SubredditRules:
									return {
										...e, ...t
									};
								case f.i.CommunityList: {
									const s = {};
									for (const t of e.data) s[t.name] = t;
									return {
										...t,
										data: t.data.map(e => {
											if (!("subscribers" in s[e])) {
												const t = {
														subredditName: e
													},
													s = Object(g.z)(n, t),
													r = Object(g.w)(n, t);
												return {
													name: s.name,
													subscribers: s ? s.subscribers : void 0,
													iconUrl: s ? s.communityIcon : void 0,
													isNSFW: s ? s.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return s[e]
										})
									}
								}
								case f.i.Button:
								case f.i.Custom:
								case f.i.Image:
								case f.j.Menu:
								case f.i.Moderators:
								case f.i.Textarea:
								case f.i.PostFlair:
									return t;
								default:
									return Object(h.a)(e)
							}
						}(t, N.body, j);
						if (T) {
							if (!I) try {
								await T
							} catch (P) {}
							a = await r(U(e, y)) || a
						}
						r(C({
							subredditId: e,
							widgetId: y,
							widget: a
						})), "calendar" === t.kind && r(Object(i.f)({
							kind: O.b.SuccessMod,
							text: s.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(n))
					} else w && w.websocket.close(), r(Object(o.f)(n, N.error))
				}, I = Object(r.a)(E.h), S = (e, t, n) => async (s, r, a) => {
					let {
						apiContext: i
					} = a;
					s(Object(o.h)(n));
					const m = t.id,
						p = Object(g.U)(r(), {
							subredditId: e
						}).name,
						b = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
							method: d.jb.DELETE,
							type: "json"
						}))(i(), p, t);
					b.ok ? (s(Object(o.e)(n)), s(I({
						subredditId: e,
						widgetId: m
					}))) : s(Object(o.f)(n, b.error))
				}, w = Object(r.a)(E.f), T = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = Object(g.U)(s(), {
						subredditId: e
					}).name;
					(await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget_order/sidebar`,
						method: d.jb.PATCH,
						type: "json",
						data: n
					}))(o(), a, t)).ok && n(w({
						subredditId: e,
						widgetIds: t
					}))
				}, N = e => {
					let {
						imageData: t
					} = e;
					return async (e, n, s) => {
						const r = n(),
							o = r.structuredStyles.isEditing,
							i = Object(g.U)(r, {
								subredditId: o
							}).name;
						e(Object(a.k)(t));
						const m = await (async (e, t, n, s) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget_image_upload_s3`,
							method: d.jb.POST,
							data: {
								filepath: n,
								mimetype: s
							}
						}))(s.apiContext(), i, t.file.name, await Object(b.h)(t.file));
						let p = !1;
						try {
							const s = await Object(a.g)(n(), m, t, v.a.Widgets);
							s && (e(Object(a.j)(s)), p = !0)
						} catch (h) {
							if (h instanceof Error) throw h;
							e(Object(a.i)(h))
						}
						return p
					}
				}, P = Object(r.a)(E.d), R = Object(r.a)(E.e), A = (e, t) => async (n, s, r) => {
					let {
						apiContext: a
					} = r;
					n(Object(o.h)(t));
					const i = Object(g.U)(s(), {
							subredditId: e
						}).name,
						d = await m(a(), i);
					if (d.ok) {
						const s = d.body;
						n(R({
							subredditId: e,
							widgets: s
						})), n(Object(o.e)(t))
					} else n(Object(o.f)(t, d.error))
				}, M = Object(r.a)(E.c), D = Object(r.a)(E.b), L = Object(r.a)(E.a), F = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(M({
						subredditId: e
					}));
					const a = Object(g.U)(s(), {
							subredditId: e
						}).name,
						i = await m(o(), a, t);
					if (i.ok) {
						const t = i.body;
						n(D({
							subredditId: e,
							widgets: t
						}))
					} else n(L({
						subredditId: e,
						error: i.error
					}))
				}, U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const a = Object(g.U)(s(), {
							subredditId: e
						}).name,
						i = await m(o(), a, !0);
					if (i.ok) return i.body.items[t]
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				r = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				o = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				a = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				i = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				d = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				c = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "d", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiBannedContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						bannedMembersInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n,
							editWikiBanInfo: s
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t,
							daysRemaining: s.daysRemaining,
							note: s.note
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						bannedContributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const f = Object(o.a)(h.d),
				g = Object(o.a)(h.c),
				_ = Object(o.a)(h.b),
				v = e => async (t, n, s) => {
					t(f({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						a = await m(s.gqlContext(), o);
					if (a.ok) {
						const n = a.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(g({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = a.error || {
							type: r.I.UNKNOWN_ERROR
						};
						t(_({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return a.ok
				}, O = Object(o.a)(h.a), x = (e, t) => async (n, r, o) => {
					const i = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(O({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2EIEjY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: x(e, t)
					}));
					return d.ok
				}, E = Object(o.a)(h.e), y = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(i.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.jb.POST,
						data: {
							api_type: "json",
							name: n.username,
							type: "wikibanned",
							duration: n.duration,
							ban_reason: n.banReason,
							note: n.note
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(a.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("Successfully banned user", null, {
								hk: "1VcdP9"
							})
						}));
						const r = {
								subredditName: e,
								username: t.username
							},
							o = (await m(d.gqlContext(), r)).body;
						if (o.data.subreddit.wiki) {
							const t = p(o.data.subreddit.wiki);
							n(E({
								bannedContributor: t.bannedContributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						u.error.type === r.I.USER_DOESNT_EXIST && (e = s.fbt._("That user doesn't exist", null, {
							hk: "1AFgzG"
						})), n(Object(a.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "14O55Y"
							})
						}))
					}
					return u.ok
				}, j = Object(o.a)(h.f), C = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(i.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.jb.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikibanned"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(a.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "381leB"
						})
					})), n(j({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "4lHXgg"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: C(e, t)
					})), u.ok
				}, k = Object(o.a)(h.g), I = (e, t) => async (n, r, o) => {
					const i = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.bannedContributors)[0];
							n(k({
								subredditName: e.toLowerCase(),
								bannedContributor: s.bannedContributors[r]
							}))
						}
					} else n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2iRQ4u"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_CONTRIBUTORS_PENDING",
				r = "WIKI_CONTRIBUTORS_LOADED",
				o = "WIKI_CONTRIBUTORS_FAILED",
				a = "MORE_WIKI_CONTRIBUTORS_LOADED",
				i = "WIKI_CONTRIBUTOR_ADDED",
				d = "WIKI_CONTRIBUTOR_REMOVED",
				c = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "d", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						contributorsInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						contributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const f = Object(o.a)(h.d),
				g = Object(o.a)(h.c),
				_ = Object(o.a)(h.b),
				v = e => async (t, n, s) => {
					t(f({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						a = await m(s.gqlContext(), o);
					if (a.ok) {
						const n = a.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(g({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = a.error || {
							type: r.I.UNKNOWN_ERROR
						};
						t(_({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return a.ok
				}, O = Object(o.a)(h.a), x = (e, t) => async (n, r, o) => {
					const i = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(O({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: x(e, t)
					}));
					return d.ok
				}, E = Object(o.a)(h.e), y = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(i.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.jb.POST,
						data: {
							api_type: "json",
							name: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(a.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("User has been successfully added", null, {
								hk: "3mt5Vr"
							})
						}));
						const r = {
								subredditName: e,
								username: t
							},
							i = (await m(d.gqlContext(), r)).body;
						if (i.data.subreddit.wiki) {
							const t = p(i.data.subreddit.wiki),
								s = Object.keys(t.contributors)[0];
							!!o().pages.subredditWiki.wikiContributors.listing.models[e.toLowerCase()][s] || n(E({
								contributor: t.contributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						const t = u.error.type;
						t === r.I.USER_DOESNT_EXIST ? e = s.fbt._("That user doesn't exist", null, {
							hk: "1OHcCX"
						}) : t === r.I.BANNED_FROM_SUBREDDIT && (e = s.fbt._("That user is banned from the subreddit", null, {
							hk: "4eZcXp"
						})), n(Object(a.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "3VCQr6"
							})
						}))
					}
					return u.ok
				}, j = Object(o.a)(h.f), C = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(i.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.jb.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(a.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "2OevWA"
						})
					})), n(j({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1zUdz2"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: C(e, t)
					})), u.ok
				}, k = Object(o.a)(h.g), I = (e, t) => async (n, r, o) => {
					const i = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), i);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.contributors)[0];
							n(k({
								subredditName: e.toLowerCase(),
								contributor: s.contributors[r]
							}))
						}
					} else n(Object(a.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2s4L9n"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				r = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				o = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				a = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "d", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/subredditSettings.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/models/SubredditWikiPage/index.ts"),
				p = n("./src/redditGQL/operations/SubredditWikiPageSettings.json");
			const b = (e, t) => Object(c.a)(e, {
					...p,
					variables: t
				}),
				h = {
					[m.a.Inherit]: "0",
					[m.a.Contributors]: "1",
					[m.a.Mods]: "2"
				};
			var f = e => {
					const {
						editPermissions: t,
						editorsInfo: n,
						isVisible: s
					} = e, {
						edges: r,
						pageInfo: o
					} = n, a = [];
					return r.forEach(e => {
						e.node.name && e.node.icon && a.push({
							username: e.node.name,
							iconUrl: e.node.icon.url
						})
					}), {
						editPermissions: t,
						editorsInfo: a,
						isVisible: s,
						afterToken: o.hasNextPage ? o.endCursor : null
					}
				},
				g = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const x = Object(o.a)(O.c),
				E = (e, t) => async (n, s, r) => {
					const o = {
							subredditName: e,
							wikiPageName: t
						},
						i = await b(r.gqlContext(), o),
						d = Object(v.F)(s(), e);
					if (Object(v.W)(s(), d) || await n(Object(a.h)(e, d)), i.ok) {
						const e = i.body,
							t = e.data.subreddit && e.data.subreddit.wiki;
						if (t && t.page) {
							const e = f(t.page.settings);
							n(x({
								pageKey: Object(g.a)(o),
								settings: e
							}))
						}
					}
					return i.ok
				}, y = Object(o.a)(O.b), j = (e, t, n) => async (r, o, a) => {
					const d = {
							subredditName: e,
							wikiPageName: t,
							after: n
						},
						c = await b(a.gqlContext(), d);
					if (c.ok) {
						const n = c.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s && s.page) {
							const n = f(s.page.settings),
								{
									editorsInfo: o,
									afterToken: a
								} = n;
							r(y({
								editorsInfo: o,
								afterToken: a,
								pageKey: Object(g.a)({
									wikiPageName: t,
									subredditName: e
								})
							}))
						}
					} else r(Object(i.f)({
						kind: _.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: j(e, t, n)
					}));
					return c.ok
				}, C = Object(o.a)(O.d), k = e => {
					let {
						editPermissions: t,
						isVisible: n,
						wikiPageName: s,
						subredditName: o
					} = e;
					return async (e, a, i) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/wiki/settings/${e.wikiPageName}`,
							method: r.jb.POST,
							data: {
								permlevel: h[e.editPermissions],
								listed: e.isVisible ? "on" : void 0
							}
						}))({
							context: i.apiContext(),
							editPermissions: t,
							isVisible: n,
							wikiPageName: s,
							subredditName: o
						});
						return c.ok && e(C({
							editPermissions: t,
							isVisible: n,
							pageKey: Object(g.a)({
								wikiPageName: s,
								subredditName: o
							})
						})), c.ok
					}
				}, I = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: o
					} = e;
					return async (e, a, c) => {
						const m = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/add`,
							method: r.jb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: c.apiContext(),
							wikiPageName: o,
							subredditName: t,
							username: n
						});
						if (m.ok) e(Object(i.f)({
							kind: _.b.SuccessCommunity,
							text: "User successfully added"
						})), await e(E(t, o));
						else if (m.error) {
							const t = m.error.type;
							let n = s.fbt._("Something went wrong", null, {
								hk: "8AkV3"
							});
							t === r.I.NOT_FOUND_ERROR && (n = s.fbt._("That user does not exist", null, {
								hk: "XDM7X"
							})), e(Object(i.f)({
								kind: _.b.Error,
								text: n
							}))
						}
						return m.ok
					}
				}, S = Object(o.a)(O.a), w = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: s
					} = e;
					return async (e, o, a) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/del`,
							method: r.jb.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: a.apiContext(),
							wikiPageName: s,
							subredditName: t,
							username: n
						});
						return c.ok && (e(Object(i.f)({
							kind: _.b.SuccessCommunity,
							text: "User has been successfully removed"
						})), e(S({
							username: n,
							pageKey: Object(g.a)({
								wikiPageName: s,
								subredditName: t
							})
						}))), c.ok
					}
				}
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			}));
			const s = "WIKI_REVISIONS_PENDING",
				r = "WIKI_REVISIONS_LOADED",
				o = "WIKI_REVISIONS_FAILED",
				a = "WIKI_PAGE_REVERT_SUCCESS",
				i = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/actions/wiki/wikiRevisions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return C
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "b", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/WikiRevisions.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/wiki/wikiRevision.ts");
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/hide`,
				method: r.jb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var h = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/revert`,
				method: r.jb.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var f = e => {
					const t = e.subreddit && e.subreddit.wiki || {},
						n = t.pageRevisions && t.pageRevisions.revisions || t.recentRevisions;
					if (!n) throw new Error("Invalid response");
					return (e => {
						const t = {},
							n = [];
						return e.edges.forEach(e => {
							const s = e.node;
							t[s.id] = s, n.push(s.id)
						}), {
							pageInfo: e.pageInfo,
							revisions: t,
							revisionsIds: n
						}
					})(n)
				},
				g = n("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				_ = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/subredditWiki.ts"),
				x = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const E = Object(o.a)(x.d),
				y = Object(o.a)(x.c),
				j = Object(o.a)(x.b),
				C = e => async (t, n, o) => {
					const {
						canLoadMore: i = !1,
						canShowFailToast: l = !1,
						isRecent: u,
						subredditName: m,
						wikiPageName: p
					} = e, b = n(), h = Object(g.a)(e), _ = Object(O.p)(b, {
						listingKey: h
					});
					if (!i && !!_) return !0;
					const x = _ && _.pageInfo.endCursor || void 0;
					if (!(!_ || _.pageInfo.hasNextPage)) return !0;
					const k = {
							after: x,
							isRecent: u,
							subredditName: m,
							wikiPageName: p
						},
						I = {
							key: h,
							options: k
						};
					t(E(I));
					const S = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(o.gqlContext(), k);
					if (S.ok) {
						const e = S.body;
						if (e.data.subreddit) {
							const n = f(e.data);
							t(y({
								...I,
								...n
							}))
						}
					} else {
						const n = S.error || {
							type: r.I.UNKNOWN_ERROR
						};
						t(j({
							...I,
							error: n
						})), l && t(Object(a.f)({
							kind: v.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1e4Swa"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: C(e)
						}))
					}
					return S.ok
				}, k = Object(o.a)(x.a), I = e => async (t, n, r) => {
					const {
						subredditName: o,
						wikiPageName: d
					} = e, c = Object(_.a)({
						...e,
						revisionId: void 0
					}), l = Object(g.a)({
						...e,
						isRecent: !1
					}), u = Object(g.a)({
						...e,
						isRecent: !0
					}), m = Object(O.p)(n(), {
						listingKey: l
					}), p = m && m.ids[0];
					if ((await h(r.apiContext(), e)).ok) {
						const e = (await Object(i.a)(r.gqlContext(), {
								includePageData: !0,
								subredditName: o,
								wikiPageName: d
							})).body,
							n = e.data.subreddit && e.data.subreddit.wiki,
							m = n && n.page;
						if (!m || !m.revision) return;
						if (m.revision.id === p) return void t(Object(a.f)({
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Wiki page is already at selected revision!", null, {
								hk: "46i9jx"
							})
						}));
						t(k({
							page: m,
							pageKey: c,
							pageRevisionsListingKey: l,
							recentRevisionsListingKey: u,
							subredditName: o,
							wikiPageName: d
						}))
					} else t(Object(a.f)({
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2L5ytY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: I(e)
					}))
				}, S = Object(o.a)(x.e), w = e => async (t, n, r) => {
					const o = await b(r.apiContext(), e);
					if (o.ok) {
						const n = o.body.status;
						t(S({
							revisionId: e.revisionId,
							isHidden: n
						}))
					} else t(Object(a.f)({
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2gGq8w"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: I(e)
					}))
				}
		},
		"./src/reddit/components/AdLinkWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				AdLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				adLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				ctaExperiment: "_3JgLF82C_0NM3uN8pOyJTu",
				borders: "_3LUqJuEsn44ivYFDMegLQG",
				borderTop: "_2n1stnecLcYB2e1RjBwSq_",
				borderBottom: "_2EVJbBkxJortsXpkuVWaPA"
			}
		},
		"./src/reddit/components/AdLinkWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/AdLinkWrapper/index.m.less"),
				i = n.n(a);

			function d(e) {
				const {
					className: t,
					ctaExperimentDesign: n,
					children: s
				} = e, a = Object(o.a)(i.a.adLinkWrapper, t, {
					[i.a.ctaExperiment]: !!n,
					[i.a.borders]: "classic" === n,
					[i.a.borderTop]: "compact" === n || "conversation" === n,
					[i.a.borderBottom]: "card" === n
				});
				return r.a.createElement("div", {
					className: a
				}, s)
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.m.less": function(e, t, n) {
			e.exports = {
				displayUrl: "Nd1oMnpI7mh5Ewfm9VQxq",
				ctaExperimentLink: "a3FqJA6bjuoLKqPBEp52R",
				leftSideContent: "_1oCxYg3Tu1IIcDUUOu9gIA",
				ctaExperimentNoPadding: "_2pWpf_lwFeF9qkMKAgnF1j",
				ctaExperimentPadded: "_3xECPPLU5gHGEwtMV_um7R",
				caption: "_2LmxORnqxzKG1lDeTP_w6R"
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/CallToActionButton/index.tsx"),
				d = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				c = n("./src/reddit/components/AdLinkWrapperContent/index.m.less"),
				l = n.n(c);
			t.a = e => {
				const {
					adLinkContent: t,
					post: n,
					isCompact: r
				} = e, {
					source: c,
					callToAction: u,
					caption: m
				} = t;
				if (!c || !c.url) return null;
				let p = c.displayText;
				c.displayText.length >= 40 && (p = c.displayText.slice(0, 40 - "...".length) + "...");
				const b = Object(a.a)(l.a.leftSideContent, {
						[l.a.ctaExperimentNoPadding]: e.ctaExperimentDesign && "card" !== e.ctaExperimentDesign,
						[l.a.ctaExperimentPadded]: "card" === e.ctaExperimentDesign
					}),
					h = Object(a.a)(l.a.displayUrl, {
						[l.a.ctaExperimentLink]: !!e.ctaExperimentDesign
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: b
				}, m && !r && o.a.createElement("span", {
					className: l.a.caption,
					title: m
				}, m), o.a.createElement(d.a, {
					href: c.url.replace(s.a.redditUrl, ""),
					isSponsored: n.isSponsored,
					postId: n.id,
					source: c,
					className: h
				}, p)), u && o.a.createElement(i.a, {
					className: l.a.callToAction,
					href: c.url,
					isSponsored: n.isSponsored,
					postId: n.id,
					source: c,
					showCTAExperiment: !!e.ctaExperimentDesign
				}, u))
			}
		},
		"./src/reddit/components/AdViewability/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/ads/store.ts"),
				u = n("./src/lib/onFocusAndVisibilityChange/index.ts"),
				m = n("./src/reddit/connectors/PostViewable/index.ts"),
				p = n("./src/reddit/constants/adEvents.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/selectors/media.ts"),
				f = n("./src/reddit/selectors/video.ts");
			const g = [{
					event: p.a.ViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.m
				}, {
					event: p.a.Impression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.GalleryItemImpression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.VendorFullyInView,
					threshold: c.b,
					viewabilityMinimum: c.f
				}, {
					event: p.a.GroupMViewable,
					threshold: c.b,
					viewabilityMinimum: c.m
				}, {
					event: p.a.VendorFullyInViewSeconds5,
					threshold: c.l,
					viewabilityMinimum: c.h,
					remainingTime: c.h,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}, {
					event: p.a.VendorFullyInViewSeconds15,
					threshold: c.l,
					viewabilityMinimum: c.g,
					remainingTime: c.g,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				_ = [{
					event: p.a.VideoViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.k,
					remainingTime: c.k,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoFullyViewableImpression,
					threshold: c.a,
					viewabilityMinimum: c.i,
					remainingTime: c.i,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoGroupMViewable,
					threshold: void 0,
					viewabilityMinimum: c.k,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0,
					checkAudible: !0
				}, {
					event: p.a.VideoVendorFullyViewable50,
					threshold: c.a,
					viewabilityMinimum: void 0,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				v = e => e.map(e => {
					let {
						event: t,
						cumulative: n = !1,
						cumulativeElapsedTime: s,
						remainingTime: r,
						threshold: o = null,
						viewabilityMinimum: a,
						checkAudible: i = !1,
						timeViewingInterrupted: d
					} = e;
					return {
						event: t,
						cumulative: n,
						checkAudible: i,
						timer: null,
						fired: !1,
						threshold: o,
						remainingTime: r,
						cumulativeElapsedTime: 0,
						viewabilityMinimum: a,
						timeViewingInitialized: 0,
						timeViewingInterrupted: d
					}
				}),
				O = () => v(g),
				x = () => v(_),
				E = [c.c, c.e, c.l, c.j, c.a, c.b],
				y = [c.c, c.l, c.j, c.a],
				j = [c.c, c.e, c.l, c.b],
				C = e => "boolean" == typeof e.cumulative && e.cumulative,
				k = Object(i.c)({
					continuousViewingStartedAt: (e, t) => {
						let {
							post: n
						} = t;
						return Object(f.b)(e, {
							postId: n.id
						})
					},
					videoDuration: (e, t) => {
						let {
							post: n
						} = t;
						const s = Object(f.h)(e, {
							postId: n.id
						});
						if (s) return s.length
					},
					isAudible: e => Object(h.a)(e),
					isPlaying: (e, t) => {
						let {
							post: n
						} = t;
						return Object(f.d)(e, {
							postId: n.id
						})
					},
					isFullScreen: (e, t) => {
						let {
							post: n
						} = t;
						return Object(f.e)(e, {
							postId: n.id
						})
					}
				}),
				I = Object(m.a)(k);
			class S extends o.Component {
				constructor(e) {
					super(e), this.viewabilityStats = O(), this.videoStats = x(), this.pageInFocus = !0, this.inViewStats = [], this.outOfViewStats = [], this.handleViewabilityChange = e => {
						this.props.trackDisplay && this.handleThresholds(e, c.r), this.props.trackVideo && this.handleThresholds(e, c.p, !0), this.checkViewabilityByType(e)
					}, this.checkViewabilityByType = e => {
						if (r()(this.state.event, e) || this.setState({
								event: e
							}), this.props.trackDisplay) {
							const t = this.props.post.media && Object(b.E)(this.props.post.media);
							this.viewabilityStats.forEach(n => {
								(n.event !== p.a.GalleryItemImpression || t) && this.checkViewability(e, n)
							})
						}
						this.props.isPlaying && this.props.trackVideo && this.videoStats.forEach(t => {
							t.checkAudible && !this.props.isAudible || this.checkViewability(e, t)
						})
					}, this.state = {
						event: null,
						currentContinuousViewingStartedAt: e.continuousViewingStartedAt
					}
				}
				componentDidMount() {
					this.visibilityChangeSubscriptionId = u.a.subscribe(e => {
						this.pageInFocus = e.documentInFocus, this.state.event && this.handleViewabilityChange(this.state.event)
					})
				}
				componentWillUnmount() {
					const {
						post: e,
						trackDisplay: t,
						trackVideo: n
					} = this.props;
					this.visibilityChangeSubscriptionId && u.a.unsubscribe(this.visibilityChangeSubscriptionId), t && (l.d(e.id, c.r, !1), this.viewabilityStats.forEach(e => {
						C(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), n && (l.d(e.id, c.p, !0), this.videoStats.forEach(e => {
						C(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), this.outOfViewStats = [], this.inViewStats = []
				}
				componentDidUpdate() {
					this.props.trackVideo && (this.state.currentContinuousViewingStartedAt === this.props.continuousViewingStartedAt ? (this.handleThresholds(this.state.event, c.p, !0), this.videoStats.forEach(e => {
						!this.props.isPlaying || e.checkAudible && !this.props.isAudible ? e.cumulative ? this.pauseCumulativeStats(e) : this.pauseViewableStats(e) : this.checkViewability(this.state.event, e)
					})) : this.resetTimers())
				}
				resetTimers() {
					this.videoStats.forEach(e => {
						e.cumulative || this.resetTimer(e)
					}), this.setState({
						currentContinuousViewingStartedAt: this.props.continuousViewingStartedAt
					})
				}
				resetTimer(e) {
					this.clearTimer(e), e.timeViewingInitialized = 0, void 0 !== e.viewabilityMinimum && (e.remainingTime = e.viewabilityMinimum)
				}
				pauseViewableStats(e) {
					let t;
					if (!e.timer || e.fired) return;
					e.timeViewingInterrupted = Date.now();
					const n = e.timeViewingInterrupted - e.timeViewingInitialized;
					t = (e.viewabilityMinimum || 0) - n, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e)
				}
				pauseCumulativeStats(e) {
					let t;
					e.timer && !e.fired && (e.timeViewingInterrupted = Date.now(), e.cumulativeElapsedTime += e.timeViewingInterrupted - e.timeViewingInitialized, t = (e.viewabilityMinimum || 0) - e.cumulativeElapsedTime, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e))
				}
				meetsViewabilityRequirements(e, t) {
					let n, s = !1,
						r = !1;
					return "object" == typeof t ? (n = t.threshold, s = !!t.playing, r = !!t.withSound) : n = t, this.isAdequatelyInView(e, n) && (!s || this.props.isPlaying) && (!r || this.props.isAudible)
				}
				handleThresholds(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						post: s
					} = this.props, o = t.filter(t => this.meetsViewabilityRequirements(e, t));
					!r()(o, this.inViewStats) && o.length > 0 && l.b(s.id, o, n);
					const a = t.filter(t => !this.meetsViewabilityRequirements(e, t));
					!r()(a, this.outOfViewStats) && a.length > 0 && l.d(s.id, a, n), this.outOfViewStats = a, this.inViewStats = o
				}
				isAdequatelyInView(e, t) {
					return !!this.props.isFullScreen || !!e && e.intersectionRatio >= t && this.pageInFocus
				}
				addDurationBasedViewabilityMinimum(e) {
					this.props.videoDuration ? e.viewabilityMinimum = Math.min(.5 * this.props.videoDuration, c.g) : e.viewabilityMinimum = c.g, e.remainingTime = e.viewabilityMinimum
				}
				adjustThreshold(e, t) {
					const {
						height: n,
						width: s
					} = e.boundingClientRect;
					return !t.threshold && t.event === p.a.VideoGroupMViewable && this.props.videoDuration && (t.threshold = s * n < 3e5 ? c.a : c.j, t.viewabilityMinimum = .5 * this.props.videoDuration), t.event === p.a.GroupMViewable && s * n > 242500 && (t.threshold = c.l), t
				}
				checkViewability(e, t) {
					if (C(t) && t.event === p.a.VideoVendorFullyViewable50 && this.addDurationBasedViewabilityMinimum(t), e && e.target && this.adjustThreshold(e, t), t.threshold && void 0 !== t.viewabilityMinimum) {
						if (this.isAdequatelyInView(e, t.threshold) && !t.fired) {
							if (t.timer) return;
							const e = this.getLengthForTimer(t);
							return e > 0 ? this.initTimer(t, e) : this.fireStat(t), void(t.timeViewingInitialized = Date.now())
						}
						C(t) && t.cumulative && this.pauseCumulativeStats(t), this.clearTimer(t)
					}
				}
				clearTimer(e) {
					e.timer && (clearTimeout(e.timer), e.timer = null)
				}
				getLengthForTimer(e) {
					return void 0 !== e.remainingTime ? e.remainingTime : e.viewabilityMinimum || 0
				}
				fireStat(e) {
					setTimeout(() => this.props.onPostViewable(this.props.post, e.event), 0), e.fired = !0
				}
				initTimer(e, t) {
					this.clearTimer(e), e.timer = window.setTimeout(() => {
						this.fireStat(e)
					}, t)
				}
				render() {
					const {
						trackDisplay: e,
						trackVideo: t
					} = this.props;
					let n = E;
					return e && !t ? n = j : !e && t && (n = y), a.a.createElement(d.a, {
						threshold: n,
						onChange: this.handleViewabilityChange
					}, this.props.children)
				}
			}
			t.a = I(S)
		},
		"./src/reddit/components/Admin/index.m.less": function(e, t, n) {
			e.exports = {
				admin: "_2xNNl6uDn-la14kNSY-HlG",
				adminIcon: "_39nUIeq_tsYlKJUODkYXBu"
			}
		},
		"./src/reddit/components/Admin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/components/Admin/index.m.less"),
				d = n.n(i),
				c = n("./src/lib/constants/icons.ts"),
				l = n("./src/reddit/icons/fonts/index.tsx"),
				u = n("./src/reddit/constants/experiments.ts"),
				m = n("./src/reddit/helpers/chooseVariant/index.ts");
			const p = e => Object(m.c)(e, {
				experimentEligibilitySelector: m.a,
				experimentName: u.a
			});
			t.a = () => {
				return Object(a.e)(p) ? o.a.createElement("span", {
					className: d.a.admin
				}, s.fbt._("Admin", null, {
					hk: "3MyAnD"
				})) : o.a.createElement(l.a, {
					name: c.a.admin,
					isFilled: !0,
					className: d.a.adminIcon,
					title: s.fbt._("Reddit admin", null, {
						hk: "goUUb"
					})
				})
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_2MgVqpGJKTGicaQowt_R9h",
				primaryButton: "_2MgVqpGJKTGicaQowt_R9h"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/controls/TextButton/index.tsx"),
				m = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				p = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				b = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less"),
				h = n.n(b);
			const f = i.a.wrapped(l.l, "PrimaryButton", h.a);
			class g extends o.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						e.onAddSubmitter(e.subredditId, t.username), e.sendEventWithName("add")(), e.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				componentDidMount() {
					this.setState({
						username: this.props.username || ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(d.e, null, o.a.createElement(d.i, null, o.a.createElement(p.a, null, o.a.createElement(d.q, null, s.fbt._("Add approved user", null, {
						hk: "rVlIL"
					})), o.a.createElement(u.a, {
						onClick: e.toggleModal
					}, o.a.createElement(d.b, null)))), o.a.createElement(d.l, null, o.a.createElement(c.d, {
						placeholder: s.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), o.a.createElement(d.g, null, o.a.createElement(d.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(f, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !Object(m.a)(t.username)
					}, s.fbt._("Add user", null, {
						hk: "23A7cj"
					}))))
				}
			}
			t.a = Object(a.a)(g)
		},
		"./src/reddit/components/ApprovedSubmitterList/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				pencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				noPermissions: "_2LSmyOf3zXlFqKumLW0h7B"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				h = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/Scroller/Simple.tsx"),
				v = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				x = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/SubredditModeration/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/lib/objectSelector/index.ts"),
				I = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const S = Object(k.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				const s = e.pages.modHub.approvedSubmitters.userOrder[n];
				return s ? s.map(t => e.pages.modHub.approvedSubmitters.models[n][t]) : I.a
			});
			var w = n("./src/reddit/selectors/user.ts"),
				T = n("./src/reddit/contexts/PageLayer/index.tsx"),
				N = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				P = n("./src/reddit/components/ApprovedSubmitterList/index.m.less"),
				R = n.n(P);
			const A = 24,
				M = Object(T.u)({
					username: e => Object(T.X)(e).user
				}),
				D = Object(d.c)({
					approvedSubmitters: S,
					approvedSubmittersListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(j.e)(n);
						return !!e.pages.modHub.approvedSubmitters.api.pending[s]
					},
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(C.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(C.a)(e),
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedSubmitters.loadMore[n]
					},
					searchPending: e => !!e.pages.modHub.approvedSubmitters.search.api.pending,
					searchResult: e => e.pages.modHub.approvedSubmitters.search.result,
					currentUser: w.k
				}),
				L = Object(i.b)(D, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addSubmitter: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)(n, {
							after: t
						})),
						removeSubmitter: (t, n) => e(Object(m.d)(t, n)),
						searchForSubmitter: (t, n) => e(Object(m.c)(t, n)),
						toggleRemoveUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class F extends a.a.Component {
				constructor(e) {
					super(e), this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveUserModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeSubmitter(this.props.subredditId, this.state.userId)
					}, this.onSearch = e => {
						this.props.searchForSubmitter(this.props.subredditId, e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveSubmitter = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddUserModal()
					}, this.renderUser = e => {
						var t, n;
						return a.a.createElement(x.b, {
							timeAgo: a.a.createElement(b.d, {
								seconds: e.approvedAtUTC
							}),
							pageName: l.gc.Contributors,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.id ? a.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.username}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, a.a.createElement(E.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? a.a.createElement(E.r, {
								onClick: () => this.handleRemoveToggled(e.id, e.username)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: e.accountIcon,
							username: e.username
						})
					}, this.renderAddUserModal = () => a.a.createElement(N.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.props.addSubmitter,
						sendEventWithName: this.props.sendEventWithName,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: this.props.username,
						withOverlay: !0
					}), this.state = j.a
				}
				componentDidMount() {
					this.props.username && this.approveSubmitter()
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedSubmitters.length ? t.approvedSubmitters[t.approvedSubmitters.length - 1].id : void 0, i = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return t.approvedSubmitters.length ? a.a.createElement(a.a.Fragment, null, i && a.a.createElement(g.c, null, a.a.createElement(E.l, {
						onClick: this.approveSubmitter
					}, r.fbt._("Approve user", null, {
						hk: "2v6FxN"
					}))), a.a.createElement(g.a, {
						className: Object(c.a)(!i && R.a.noPermissions)
					}, a.a.createElement(g.b, null, r.fbt._("Approved users", null, {
						hk: "1alMeD"
					}), a.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), a.a.createElement(O.b, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), n.searchTerm ? a.a.createElement(v.a, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !t.searchResult,
						searchPending: t.searchPending,
						searchTerm: n.searchTerm
					}, t.searchResult && this.renderUser(t.searchResult)) : a.a.createElement(_.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedSubmitters.map((e, t) => ({
						estHeight: A,
						id: e.id,
						render: () => this.renderUser(e)
					})))), t.isAddUserModalOpen && this.renderAddUserModal(), t.isConfirmModalOpen && n.userId && n.username && a.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved user?", [r.fbt._param("username", n.username)], {
							hk: "4ELjHt"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveUserModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					})) : a.a.createElement(a.a.Fragment, null, i && a.a.createElement(g.c, null, a.a.createElement(E.l, {
						onClick: this.approveSubmitter
					}, r.fbt._("Approve user", null, {
						hk: "1qX1LT"
					}))), a.a.createElement(g.a, {
						className: Object(c.a)(!i && R.a.noPermissions)
					}, a.a.createElement(g.b, null, r.fbt._("Approved users", null, {
						hk: "pxkv2"
					}), a.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), t.approvedSubmittersListPending ? a.a.createElement(x.a, null) : a.a.createElement(h.c, {
						text: r.fbt._("No approved users in {subredditName}", [r.fbt._param("subredditName", t.subreddit.displayText)], {
							hk: "1VEG1v"
						})
					}, a.a.createElement(y.a, {
						name: "edit",
						className: R.a.PencilIcon
					}))), t.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			t.a = M(L(F))
		},
		"./src/reddit/components/BadgeCounter/index.m.less": function(e, t, n) {
			e.exports = {
				badgeCounter: "_1-nIsCaWhGBFN-L4ZHnbGp",
				mEmpty: "_3FX9lCQKNdKXkfBiSWCjSb"
			}
		},
		"./src/reddit/components/BadgeCounter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/components/BadgeCounter/index.m.less"),
				d = n.n(i);
			t.a = e => {
				let {
					className: t,
					isActive: n,
					showEmpty: s,
					unreadCount: i
				} = e;
				return n ? r.a.createElement("span", {
					className: Object(o.a)(t, d.a.badgeCounter, {
						[d.a.mEmpty]: s || i < 1
					})
				}, s || i < 1 ? "" : Object(a.b)(i)) : null
			}
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("BannedUserModal").then(n.bind(null, "./src/reddit/components/BannedUserList/AddBannedUserModal/_AddBannedUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/BannedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				UnthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				unthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				BanReason: "SrZ1u3sJDzvdTgFW_XYZl",
				banReason: "SrZ1u3sJDzvdTgFW_XYZl",
				ExpandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				expandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				ModNote: "_3hA381rnksvJreaBfQTIC3",
				modNote: "_3hA381rnksvJreaBfQTIC3",
				ModNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				modNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				SectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				sectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				ContextContainer: "_1pqL5T1jpl-iWaJcvRftmU",
				contextContainer: "_1pqL5T1jpl-iWaJcvRftmU"
			}
		},
		"./src/reddit/components/BannedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				BanIcon: "_1c2rKv1iuQylye8ejI6-1v",
				banIcon: "_1c2rKv1iuQylye8ejI6-1v"
			}
		},
		"./src/reddit/components/BannedUserList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return K
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditModeration/ban.ts"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				p = n("./src/reddit/components/HumanDate/index.tsx"),
				b = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/Scroller/Simple.tsx"),
				_ = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				x = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				j = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/bannedUser.ts"),
				k = n("./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx"),
				I = n("./src/lib/lessComponent.tsx"),
				S = n("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				w = n("./src/reddit/components/CompactPost/index.tsx"),
				T = n("./src/reddit/contexts/PageLayer/index.tsx"),
				N = n("./src/reddit/components/BannedUserList/ExpandedComponent.m.less"),
				P = n.n(N);
			const {
				fbt: R
			} = n("./node_modules/fbt/lib/FbtPublic.js"), A = Object(T.u)({
				currentProfileName: T.i,
				isCommentsPage: T.x,
				isCommentPermalink: T.w,
				isProfilePostListing: T.L,
				pageLayer: e => e
			}), M = I.a.wrapped(S.c, "UnthreadedComment", P.a), D = I.a.div("BanReason", P.a), L = I.a.div("ExpandedComponentContainer", P.a), F = I.a.div("ModNote", P.a), U = I.a.div("ModNoteContainer", P.a), B = I.a.div("SectionTitle", P.a), G = I.a.div("ContextContainer", P.a), H = e => () => {};
			var W = A(e => {
					const {
						currentProfileName: t,
						isCommentPermalink: n,
						isCommentsPage: s,
						isProfilePostListing: r,
						pageLayer: o,
						user: i
					} = e;
					return a.a.createElement(L, null, i.modNote && a.a.createElement(U, null, a.a.createElement(B, null, R._("Mod note:", null, {
						hk: "2LBtSw"
					})), a.a.createElement(F, null, i.modNote)), a.a.createElement("div", null, a.a.createElement(B, null, R._("Banned For:", null, {
						hk: "3UbXsX"
					})), a.a.createElement(D, null, i.reason), (i.postId || i.commentId) && a.a.createElement(G, null, i.postId && a.a.createElement(w.default, {
						currentProfileName: t,
						isCommentsPage: s,
						isCommentPermalink: n,
						isProfilePostListing: r,
						pageLayer: o,
						last: !0,
						postId: i.postId,
						hideModTools: !0,
						inSubredditOrProfile: !0
					}), i.commentId && a.a.createElement(M, {
						commentId: i.commentId,
						highlight: !1,
						trackClick: H
					}))))
				}),
				q = n("./src/reddit/components/BannedUserList/index.m.less"),
				V = n.n(q);
			const z = 48,
				K = e => null == e ? r.fbt._("Permanent", null, {
					hk: "3pNDzS"
				}) : r.fbt._({
					"*": "{number} days left",
					_1: "1 day left"
				}, [r.fbt._plural(e, "number")], {
					hk: "3VM32a"
				}),
				Q = Object(d.c)({
					bannedUsers: C.h,
					bannedUsersList: C.d,
					bannedUsersListPending: C.c,
					loadMoreToken: C.e,
					isBanUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(j.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--BanUserConfirmation" === Object(j.a)(e),
					searchPending: C.f,
					searchResult: C.g
				}),
				J = Object(i.b)(Q, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(u.c)(n, {
							after: t
						})),
						onUnbanUser: t => () => e(Object(u.e)(n, t)),
						searchForBannedUser: t => e(Object(u.d)(n, t)),
						toggleBanUserModal: () => e(Object(l.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class Y extends a.a.Component {
				constructor(e) {
					super(e), this.handleBanUserToggled = e => {
						if (e) {
							const {
								id: t,
								username: n
							} = e;
							this.setState({
								userId: t,
								username: n
							})
						} else this.setState({
							...y.a,
							searchTerm: this.state.searchTerm
						});
						this.props.isBanUserModalOpen || this.props.sendEventWithName(e ? "edit_user" : "ban_dialog_banpage")(), this.props.toggleBanUserModal()
					}, this.addBannedUser = () => this.handleBanUserToggled(null), this.onSearch = e => {
						this.props.searchForBannedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.renderBannedUser = e => {
						const t = this.props.bannedUsers[e] || this.props.searchResult,
							n = K(t.duration);
						return t ? a.a.createElement(O.b, {
							description: t.reason,
							expandedComponent: a.a.createElement(W, {
								user: t
							}),
							pageName: c.gc.Banned,
							primaryButton: a.a.createElement(x.r, {
								onClick: () => this.handleBanUserToggled(t),
								"data-redditstyle": !0
							}, r.fbt._("Edit", null, {
								hk: "1nftDt"
							})),
							subredditId: this.props.subredditId,
							timeAgo: a.a.createElement(a.a.Fragment, null, a.a.createElement(p.d, {
								seconds: t.bannedAtUTC
							}), " (", n, ")"),
							userIcon: t.accountIcon,
							username: t.username
						}) : a.a.createElement("div", null)
					}, this.renderAddBannedUserModal = () => a.a.createElement(k.a, {
						ignoreDefaultFocus: !0,
						onUnbanUser: this.state.userId ? this.props.onUnbanUser(this.state.userId) : void 0,
						subredditId: this.props.subredditId,
						toggleModal: () => this.handleBanUserToggled(null),
						trackAddEvent: this.props.sendEventWithName("add_banpage"),
						trackEventWithName: this.props.sendEventWithName,
						user: this.state.userId ? this.state.searchTerm ? this.props.searchResult || null : this.props.bannedUsers[this.state.userId] : null,
						withOverlay: !0
					}), this.state = y.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = e.bannedUsersList.length ? e.bannedUsersList[e.bannedUsersList.length - 1].id : void 0;
					return e.bannedUsersList.length ? a.a.createElement(a.a.Fragment, null, a.a.createElement(f.c, null, a.a.createElement(x.l, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, r.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), a.a.createElement(f.a, null, a.a.createElement(f.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), a.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), a.a.createElement(v.b, {
						onSearch: this.onSearch,
						activeSearchQuery: this.state.searchTerm
					}), t.searchTerm ? a.a.createElement(_.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderBannedUser(e.searchResult.id)) : a.a.createElement(g.b, {
						loadMoreToken: n,
						onLoadMore: this.onLoadMore
					}, e.bannedUsersList.map(e => ({
						estHeight: z,
						id: e.id,
						render: () => this.renderBannedUser(e.id)
					})))), e.isBanUserModalOpen && this.renderAddBannedUserModal(), e.isConfirmModalOpen && t.userId && t.username && a.a.createElement(m.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to ban {username}?", [r.fbt._param("username", t.username)], {
							hk: "4f7Mkp"
						}),
						onConfirm: () => {},
						toggleModal: e.toggleBanUserModal,
						trackClick: e.sendEventWithName("remove")
					})) : a.a.createElement(a.a.Fragment, null, a.a.createElement(f.c, null, a.a.createElement(x.l, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, " ", r.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), a.a.createElement(f.a, null, a.a.createElement(f.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), a.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.bannedUsersListPending ? a.a.createElement(O.a, null) : a.a.createElement(b.c, {
						text: r.fbt._("No banned users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1nOcbC"
						})
					}, a.a.createElement(E.a, {
						name: "ban",
						className: V.a.BanIcon
					}))), e.isBanUserModalOpen && this.renderAddBannedUserModal())
				}
			}
			t.a = J(Y)
		},
		"./src/reddit/components/BlockNavigation/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				i = n("./src/reddit/actions/modal.ts");
			const d = "non-empty-string-to-block-navigation";
			class c extends r.a.Component {
				constructor() {
					super(...arguments), this.onBeforeUnload = e => {
						if (this.props.enabled) return e.preventDefault(), e.returnValue = "", ""
					}, this.message = (e, t) => {
						return !0 === (this.props.confirmNavigate || this.defaultConfirmNavigate)(e, t) || d
					}, this.defaultConfirmNavigate = (e, t) => {
						const {
							ignoreCurrentLocation: n = !0,
							location: s,
							showModal: r,
							dialogId: o
						} = this.props;
						return !(!n || e.pathname !== s.pathname) || (o && r(), !1)
					}
				}
				componentDidMount() {
					this.props.blockOnBeforeUnload && window.addEventListener("beforeunload", this.onBeforeUnload)
				}
				componentWillUnmount() {
					this.props.blockOnBeforeUnload && window.removeEventListener("beforeunload", this.onBeforeUnload)
				}
				render() {
					const {
						enabled: e = !0
					} = this.props;
					return r.a.createElement(a.b, {
						message: this.message,
						when: e
					})
				}
			}
			t.a = Object(o.b)(null, (e, t) => ({
				showModal: () => e(Object(i.h)(t.dialogId))
			}))(Object(a.i)(c))
		},
		"./src/reddit/components/CallToActionButton/index.m.less": function(e, t, n) {
			e.exports = {
				CallToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				callToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				ctaExperiment: "O3tUaKrd54EXILNilEqF_",
				Icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				isLeft: "p8bIdnQ5pQUQRETAyCoa5",
				isRight: "_36ucS75syCWwJ_ee7IieXZ",
				active: "NPw0Z_HL-yJPXnZ3mpWEA",
				redditStyle: "OGOshepc50ul-kJHrocIO",
				mNotCardView: "_33VrFkg3gJpkL8AlPfcHUE"
			}
		},
		"./src/reddit/components/CallToActionButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/components/CallToActionButton/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					showCTAExperiment: n,
					...s
				} = e;
				return r.a.createElement(a.b, c({
					className: Object(o.a)(d.a.CallToActionButton, t, {
						[d.a.mNotCardView]: s.isNotCardView,
						[d.a.ctaExperiment]: !!n
					})
				}, s))
			}
		},
		"./src/reddit/components/CharacterCountdown/index.m.less": function(e, t, n) {
			e.exports = {
				container: "s5ap8yh1b4ZfwxvHizW3f",
				mOverflow: "_19JhaP1slDQqu2XgT3vVS0"
			}
		},
		"./src/reddit/components/CharacterCountdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				i = n("./src/reddit/components/CharacterCountdown/index.m.less"),
				d = n.n(i);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => r.a.createElement(a.b, {
				className: Object(o.a)(e.className, d.a.container, e.text.length >= e.maxChars ? d.a.mOverflow : null)
			}, c._({
				"*": "{characters} Characters remaining",
				_1: "1 Character remaining"
			}, [c._plural(e.maxChars - e.text.length, "characters")], {
				hk: "V22sW"
			}))
		},
		"./src/reddit/components/ChatButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/actions/chat/toggle.ts"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/trackers/authorHovercard.ts");
			! function(e) {
				e.awardNotification = "AWARD_NOTIFICATION"
			}(s || (s = {}));
			const u = e => {
				let {
					onStartChat: t,
					text: n,
					className: r,
					sendEvent: a,
					contextId: i,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					eventSource: b,
					onClick: h,
					onAddUserToQuickReplyList: f,
					children: g,
					style: _
				} = e;
				return o.a.createElement(c.t, {
					onClick: e => {
						if (h && h(e), t(), b === s.awardNotification) return f();
						a(Object(l.b)(i))
					},
					className: r,
					text: n,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					style: _
				}, g)
			};
			u.displayName = "ChatButton";
			const m = Object(a.b)(null, (e, t) => {
				let {
					contextId: n,
					userId: s
				} = t;
				return {
					onStartChat: () => {
						e(Object(i.b)(s, n))
					},
					onAddUserToQuickReplyList: () => {
						e(Object(i.a)(s))
					}
				}
			});
			t.b = m(Object(d.c)(u))
		},
		"./src/reddit/components/ClassicPost/Thumbnail.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Thumbnail/index.tsx"),
				i = n("./src/reddit/components/ClassicPost/index.m.less"),
				d = n.n(i);
			t.a = e => {
				let {
					className: t,
					classNameInnerThumbnail: n,
					crosspost: s,
					forceShowNSFW: i,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					thumbnailContainerClassName: b,
					url: h,
					usePreview: f
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(d.a.thumbnailContainer, t)
				}, r.a.createElement(a.a, {
					className: Object(o.a)(d.a.thumbnail, n),
					containerClassName: b,
					crosspost: s,
					forceShowNSFW: i,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					url: m ? void 0 : h,
					usePreview: f
				}))
			}
		},
		"./src/reddit/components/ClassicPost/index.m.less": function(e, t, n) {
			e.exports = {
				adLinkWrapper: "_2c-0jMA2BuDIlKjWFiOUOt",
				ctaExperiment: "_17HI1sHAGvXEekFXNNcehn",
				classicThumbnail: "nL7Q54U2LLg9rkVdSxxLe",
				content: "_1Y6dfr4zLlrygH-FLmr8x-",
				showBulkActionCheckbox: "W-Z7cDkcZIo1dPic9COiN",
				flatlistContainer: "_36kpXQ-z7Hr61j8878uRkP",
				creatorStatsContainer: "_2I70Qhfz-GbGzP54PWXR3P",
				crosspostMediaWrapper: "_1qc1-Anfrhr6APGcBKFk8M",
				expandoContainer: "_3r40yytzBnldjGGOrs2mCw",
				flatlist: "ssgs3QQidkqeycI33hlBa",
				flatlistSeparator: "_1wDt70OnYnqsrm0XIsNn8v",
				horizontalVotes: "_3ytybPoFoY12sGn375PMy1",
				leftExpando: "_35zWJjb5RJMIMkexZ2Prus",
				mainBody: "_2XDITKxlj4y3M99thqyCsO",
				rightExpando: "_2Ddj1d6vOe9NlJqkdothNe",
				spacer: "iRkLLvxarfGu_2c7HxhW0",
				titleWithPoll: "_2FcpdQwjwRwk7X_NiZub8x",
				thumbnail: "_2e9Lv1I3dOmICVO9fg3uTG",
				thumbnailContainer: "_38EcSQ9jzVrdtzkXO1cydX",
				eventMeta: "rmPDRyja27ULjwD3rW14H",
				postContainer: "D3IyhBGwXo9jPwz-Ka0Ve",
				shouldShowOverflow: "_3FOlcZoWAvyAWZYSVd8-WD",
				shouldUseRoundedBorder: "_2g8Jz2obQVOELSfntlgVsJ",
				promotedMainBody: "_1LAkIKOirJP5Hor0NamqyY",
				mFirst: "_23tSz_ar8phNRBBW1afkYr"
			}
		},
		"./src/reddit/components/ClassicPost/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/ads/index.ts"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/getShortenedLink.ts"),
				c = n("./src/lib/hooks/usePrevious.ts"),
				l = n("./src/reddit/hooks/useTracking.ts"),
				u = n("./src/reddit/components/AdLinkWrapper/index.tsx"),
				m = n("./src/reddit/components/AdLinkWrapperContent/index.tsx"),
				p = n("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				b = n("./src/reddit/components/CreatorStats/loader.tsx"),
				h = n("./src/config.ts"),
				f = n("./node_modules/react-redux/es/index.js"),
				g = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/reddit/components/Econ/Audio/index.m.less"),
				v = n.n(_),
				O = n("./src/reddit/components/Econ/Audio/MuteIcon.tsx"),
				x = n("./src/reddit/components/Econ/Audio/SpeakerRings.tsx");
			const {
				fbt: E
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var y = e => {
					let {
						post: t
					} = e;
					const {
						audioRoom: n
					} = t, o = () => Math.floor(10 * Math.random() + 1), i = Object(f.e)(g.db), [d, c] = Object(s.useState)(!1), [l, u] = Object(s.useState)(o());
					return Object(s.useEffect)(() => {
						const e = setInterval(() => {
							c(!0), setTimeout(() => c(!1), 3500), u(o())
						}, 6e3);
						return () => clearInterval(e)
					}, []), (null == n ? void 0 : n.isLive) ? r.a.createElement("a", {
						href: `https://www.reddit.com/talk/${n.roomId}`,
						target: "_blank",
						rel: "noopener noreferrer",
						className: v.a.liveClassicContainer,
						"data-testid": "audioroom-classic-live"
					}, r.a.createElement("div", {
						className: v.a.classicSpeaker
					}, d && r.a.createElement(x.a, {
						className: Object(a.a)(v.a.speakerRings, {
							[v.a.nightMode]: i
						})
					}), r.a.createElement("img", {
						key: `audioPostAvatar--${l}`,
						className: v.a.snoovatar,
						src: `${h.a.assetPath}/img/talk/avatars/${l}.png`,
						alt: E._("Reddit Talk", null, {
							hk: "XNl4V"
						})
					}), !d && r.a.createElement("div", {
						className: v.a.muteContainer
					}, r.a.createElement(O.a, {
						className: v.a.muteIcon
					})))) : r.a.createElement("div", {
						className: v.a.endedClassicContainer
					}, r.a.createElement(O.a, {
						className: v.a.muteIcon
					}))
				},
				j = n("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				C = n("./src/reddit/components/ExpandoButton/index.tsx"),
				k = n("./src/reddit/components/Flatlist/index.tsx"),
				I = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				S = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				w = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				T = n("./src/reddit/components/ModModeReports/index.tsx"),
				N = n("./src/reddit/components/ModModeReports/helpers.ts"),
				P = n("./src/reddit/components/OneFeed/PostRecommendationContext.tsx"),
				R = n("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				A = n("./src/reddit/components/PostContainer/index.tsx"),
				M = n("./src/reddit/components/PostMeta/index.tsx"),
				D = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				L = n("./src/reddit/components/PostRailAndVotes/index.tsx"),
				F = n("./src/reddit/components/PostTitle/index.tsx"),
				U = n("./src/reddit/components/PostTopMeta/index.tsx"),
				B = n("./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx"),
				G = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				H = n("./src/reddit/models/Audio/index.ts"),
				W = n("./src/reddit/models/Media/index.ts"),
				q = n("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				V = n("./src/reddit/connectors/ClassicPost/index.tsx"),
				z = n("./src/reddit/constants/postLayout.ts"),
				K = n("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				Q = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				J = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				Y = n("./src/reddit/helpers/localStorage/index.ts"),
				X = n("./src/reddit/helpers/search/renderMedia.tsx"),
				Z = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				$ = n("./src/reddit/helpers/trackers/creatorStats.ts"),
				ee = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				te = n.n(ee),
				ne = n("./src/reddit/components/ClassicPost/index.m.less"),
				se = n.n(ne);

			function re() {
				return (re = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const oe = Object(i.a)(e => {
				const {
					className: t,
					crosspost: n,
					currentUser: i,
					handleVote: h,
					isExpanded: f,
					inSubredditOrProfile: g,
					eventFactory: _,
					first: v,
					flairStyleTemplate: O,
					formatTitle: x,
					hostPostData: E,
					isCheckboxSelected: V,
					isCurrentUserProfilePost: ee,
					isFrontpage: ne,
					isGalleryTileLayoutDefault: oe,
					isLoggedIn: ae,
					isOverlay: ie,
					imageGalleryCurrentItem: de,
					moderatorPermissions: ce,
					modModeEnabled: le,
					onClickPost: ue,
					onIgnoreReports: me,
					onOpenReportsDropdown: pe,
					onSizeChanged: be,
					poll: he,
					post: fe,
					postId: ge,
					redditStyle: _e,
					scrollerItemRef: ve,
					showBulkActionCheckbox: Oe,
					showEditFlair: xe,
					showMedia: Ee,
					shouldShowInsightsButton: ye,
					subredditOrProfile: je,
					toggleCheckbox: Ce,
					userIsOp: ke,
					shouldShowGalleryTileOption: Ie,
					showPromotedCTA: Se,
					showCTAExperimentDesign: we
				} = e, Te = Object(l.a)(), Ne = Object(c.a)(f);
				Object(s.useEffect)(() => {
					be && Ne !== f && be(fe.id)
				}, [f, be, fe.id, Ne]);
				const Pe = _e ? void 0 : O,
					Re = n || void 0,
					Ae = Object(J.a)(ce),
					Me = Object(K.a)(ce),
					De = Object(Q.a)(ce),
					Le = le && J.a,
					Fe = Object(w.a)(fe),
					Ue = Object(N.c)(fe),
					Be = !!fe.media && fe.media.type === W.o.RTJSON,
					Ge = ke && Be,
					He = g && !Ee,
					We = !!fe.media && Object(W.H)(fe.media),
					qe = !!fe.recommendationContext,
					Ve = {
						flairStyleTemplate: Pe,
						post: fe,
						inSubredditOrProfile: g,
						isCurrentUserProfilePost: ee,
						isOverlay: ie,
						shouldShowSubscribeButton: !(ne && ae) || qe && ae,
						subredditOrProfile: je
					},
					ze = Object(o.t)(fe, de),
					{
						source: Ke
					} = ze,
					[Qe, Je] = Object(s.useState)(!1),
					Ye = Object(s.useCallback)(() => {
						Je(!Qe), Object(Y.Mb)(), Te(Object($.d)(ge))
					}, [Qe, ge, Te]);
				let Xe = r.a.createElement(q.a, {
					className: se.a.classicThumbnail,
					crosspost: Re && fe,
					isMeta: fe.isMeta,
					post: Re || fe,
					redditStyle: _e,
					templatePlaceholderImage: Pe && Pe.postPlaceholderImage,
					removeLink: We
				});
				Object(H.b)(fe) && (Xe = r.a.createElement(y, {
					post: fe
				}));
				const Ze = r.a.createElement(A.a, {
					className: Object(a.a)(te.a.classicPostStyles, se.a.postContainer, Object(Z.a)(e), {
						[se.a.mFirst]: v,
						[se.a.shouldShowOverflow]: ye
					}, t),
					isOverlay: ie,
					style: {
						...Object(Z.d)(e),
						...Object(Z.b)(Pe)
					},
					post: fe,
					onClick: ue,
					eventFactory: _
				}, r.a.createElement(L.a, {
					model: fe,
					handleVote: h,
					showBulkActionCheckbox: Oe,
					isCheckboxSelected: V,
					toggleCheckbox: Ce,
					flairStyleTemplate: Pe,
					redditStyle: _e,
					postId: ge
				}), r.a.createElement(R.a, {
					className: ye ? se.a.shouldUseRoundedBorder : void 0,
					"data-click-id": "background",
					flairStyleTemplate: Pe
				}, r.a.createElement(j.a, {
					className: se.a.eventMeta,
					post: fe
				}), r.a.createElement("div", {
					className: se.a.mainBody
				}, r.a.createElement("div", {
					className: He ? se.a.expandoContainer : se.a.thumbnailContainer
				}, !He && Xe, r.a.createElement(C.a, {
					crosspost: Re,
					className: se.a.rightExpando,
					isExpanded: !!f,
					post: fe,
					useMediaIcons: !1
				})), r.a.createElement("div", {
					className: Object(a.a)(se.a.content, {
						[se.a.showBulkActionCheckbox]: Oe
					}),
					"data-click-id": "body"
				}, !!fe.recommendationContext && r.a.createElement(P.a, {
					content: fe.recommendationContext.content,
					layout: z.g.Classic,
					post: fe
				}), r.a.createElement(F.c, {
					className: he ? se.a.titleWithPoll : void 0,
					format: x,
					poll: he,
					post: fe,
					redditStyle: _e,
					size: F.b.Medium,
					titleColor: Pe && Pe.postTitleColor,
					isOverlay: ie
				}, fe.source && !Re && !fe.isSurveyAd && r.a.createElement(G.a, {
					href: fe.source.url,
					isSponsored: fe.isSponsored,
					postId: fe.id,
					source: fe.source
				}, Object(d.a)(fe))), r.a.createElement(M.a, re({
					key: "PostMeta"
				}, Ve)), le && Ae && Fe && r.a.createElement(S.a, {
					thing: fe
				}), le && Ae && Ue && r.a.createElement(T.a, {
					onIgnoreReports: me,
					reportable: fe
				}), Se && Ke && Ke.url && !fe.isSurveyAd && r.a.createElement(u.a, {
					ctaExperimentDesign: we && "classic",
					className: Object(a.a)(se.a.adLinkWrapper, {
						[se.a.ctaExperiment]: we
					})
				}, r.a.createElement(m.a, {
					post: fe,
					adLinkContent: ze,
					ctaExperimentDesign: we && "classic"
				})), r.a.createElement("div", {
					className: se.a.flatlistContainer
				}, r.a.createElement(C.a, {
					className: se.a.leftExpando,
					crosspost: Re,
					isExpanded: !!f,
					post: fe,
					useMediaIcons: !1
				}), r.a.createElement(p.a, {
					className: se.a.horizontalVotes,
					compact: !1,
					flairStyleTemplate: Pe,
					model: fe,
					onVoteClick: h
				}), r.a.createElement(k.a, {
					className: se.a.flatlistSeparator
				}), !fe.isSurveyAd && r.a.createElement(k.c, {
					className: se.a.flatlist,
					currentUser: i,
					hasModFlairPerms: Me,
					hasModPostPerms: Ae,
					hasModFullPerms: De,
					hostPostData: E,
					isOverlay: !!ie,
					modModeEnabled: le,
					onClickInsightsButton: Ye,
					onIgnoreReports: me,
					onOpenReportsDropdown: pe,
					post: fe,
					shouldShowInsightsButton: ye,
					showEditPost: Ge,
					showEditFlair: xe,
					tooltipType: ie ? U.c.Lightbox : void 0,
					useFlatlistBreakpoints: Object(D.b)({
						editPost: !Le,
						hide: !Le,
						report: !Le
					})
				})), r.a.createElement(I.d, null))), Object(X.a)(fe, se.a, ve, f, Ie, oe), je && Qe && r.a.createElement(b.a, {
					className: se.a.creatorStatsContainer,
					post: fe,
					subreddit: je,
					isOwnProfileStats: !0
				})));
				return r.a.createElement(B.b, null, Ze)
			});
			t.default = Object(V.a)(oe)
		},
		"./src/reddit/components/CommentSort/CommentSort.m.less": function(e, t, n) {
			e.exports = {
				container: "_2ulKn_zs7Y3LWsOqoFLHPo",
				mHasOtherDiscussions: "_3iO3U_i4YUx-2qahK_BTu1",
				HighlightPicker: "_1n6gZPmNQU56UBglU718cx",
				highlightPicker: "_1n6gZPmNQU56UBglU718cx",
				Row: "zW82EsY6Pakxpq4WWvsUG",
				row: "zW82EsY6Pakxpq4WWvsUG",
				SortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				sortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				containerRow: "_1avwNy0RnwlEwVEW-fwKCI",
				DropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				dropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				ContestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				contestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				SortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				sortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				ToggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				toggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				DropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				dropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				hideCommentSort: "uAIheeoxWlq57lu5ghv43",
				HighlightWrapper: "_201SpO3todaXvcWUHaLymN",
				highlightWrapper: "_201SpO3todaXvcWUHaLymN",
				Info: "_1urK6AxAk9Sl76RgLUHOqh",
				info: "_1urK6AxAk9Sl76RgLUHOqh",
				SetSort: "_1Pn7_008tGFVitpaAxNI9b",
				setSort: "_1Pn7_008tGFVitpaAxNI9b",
				SingleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				singleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				SortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				sortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				Title: "_1MfL8RlT7Bsr76qYvR-nqM",
				title: "_1MfL8RlT7Bsr76qYvR-nqM",
				Tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				ViewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				viewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				ViewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				viewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q"
			}
		},
		"./src/reddit/components/CommentSort/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return J
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/actions/comment/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				g = n("./src/reddit/constants/headers.ts"),
				_ = n("./src/reddit/models/Toast/index.ts");
			const v = (e, t) => async (n, r, o) => {
				let {
					apiContext: a
				} = o;
				const i = await (async (e, t, n) => Object(h.a)(Object(f.a)(e, [g.a]), {
						endpoint: `${e.apiUrl}/api/set_suggested_sort/`,
						method: c.jb.POST,
						data: {
							api_type: "json",
							id: t,
							sort: n
						}
					}))(a(), e, t),
					d = `error-block-${t}`,
					l = `success-block-${t}`;
				if (i.ok) {
					n(Object(p.S)({
						[e]: {
							suggestedSort: t
						}
					}));
					const r = t ? s.fbt._("Suggested sort is on.", null, {
						hk: "tW1Rb"
					}) : s.fbt._("Suggested sort is off.", null, {
						hk: "4fwvgj"
					});
					n(b.f({
						id: l,
						kind: _.b.SuccessCommunityGreen,
						text: r
					}))
				} else n(b.f({
					id: d,
					kind: _.b.Error,
					text: s.fbt._("Try again later", null, {
						hk: "1Lqlj2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "44HF9e"
					}),
					buttonAction: v(e, t)
				}))
			};
			var O = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				x = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				E = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				y = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				j = n("./src/reddit/components/TrackingHelper/index.tsx"),
				C = n("./src/reddit/controls/Dropdown/index.tsx"),
				k = n("./src/reddit/controls/Dropdown/Row.tsx"),
				I = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				S = n("./src/reddit/helpers/path/index.ts"),
				w = n("./src/reddit/selectors/telemetry.ts");
			n("./src/telemetry/models/Event.ts");
			const T = (e, t, n, s, r) => o => ({
					source: "comment_sort",
					action: "click",
					noun: e,
					actionInfo: {
						pageType: t ? "post_detail" : "home"
					},
					listing: Object(w.y)(o, void 0, {
						oldSort: n,
						sort: s,
						source: r
					}),
					userSubreddit: Object(w.rb)(o)
				}),
				N = (e, t) => n => ({
					source: "comment_highlighting",
					action: t,
					noun: e
				}),
				P = e => ({
					subreddit: Object(w.hb)(e),
					userSubreddit: Object(w.rb)(e)
				}),
				R = e => t => ({
					source: "contest_mode",
					action: "click",
					noun: e ? "enable" : "disable",
					...P
				});
			var A = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				M = n("./src/reddit/icons/svgs/Info/index.tsx"),
				D = n("./src/reddit/selectors/activeModalId.ts"),
				L = n("./src/reddit/selectors/comments.ts"),
				F = n("./src/reddit/selectors/moderatorPermissions.ts"),
				U = n("./src/reddit/selectors/posts.ts"),
				B = n("./src/reddit/selectors/tooltip.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				H = n("./src/reddit/components/CommentSort/CommentSort.m.less"),
				W = n.n(H),
				q = n("./src/reddit/reducers/features/comments/visitHighlightingFilter/index.ts");
			const V = Object(y.a)(C.a),
				z = e => e === q.a.First ? s.fbt._("First Visit", null, {
					hk: "HdDSr"
				}) : e === q.a.Last ? s.fbt._("Last Visit", null, {
					hk: "3ubIq3"
				}) : s.fbt._("None", null, {
					hk: "4jwXNg"
				});
			class K extends o.a.Component {
				constructor() {
					super(...arguments), this.track = () => {
						const {
							trackHighlight: e,
							selectedSort: t
						} = this.props;
						if (t !== q.a.None) {
							e(t === q.a.Last ? "since_last_visit" : "since_first_visit", "view")
						}
					}, this.onDropdownClick = (e, t) => {
						this.props.trackHighlight(e, "click"), this.props.changeHighlightSort(t)
					}, this.onDropdownClickFirst = () => {
						this.onDropdownClick("since_first_visit", q.a.First)
					}, this.onDropdownClickLast = () => {
						this.onDropdownClick("since_last_visit", q.a.Last)
					}, this.onDropdownClickNone = () => {
						this.onDropdownClick("do_not_highlight", q.a.None)
					}
				}
				componentDidMount() {
					this.track()
				}
				componentDidUpdate(e) {
					e.selectedSort !== this.props.selectedSort && this.track()
				}
				render() {
					const {
						highlightIsOpen: e,
						id: t,
						onOpen: n,
						selectedSort: r
					} = this.props;
					return o.a.createElement("div", {
						className: W.a.HighlightWrapper
					}, o.a.createElement(k.b, {
						className: Object(d.a)(W.a.HighlightPicker, W.a.Row),
						textClassName: W.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Highlight",null,{hk:"2ZiUE8"})}: ${z(r)}`,
						id: t,
						noHover: !0,
						onClick: n
					}), o.a.createElement(A.b, {
						className: W.a.DropdownTriangle,
						onClick: n
					}), o.a.createElement(V, {
						isOpen: e,
						renderContentsHidden: !0,
						tooltipId: t
					}, o.a.createElement(k.b, {
						displayText: z(q.a.First),
						isSelected: r === q.a.First,
						onClick: this.onDropdownClickFirst
					}), o.a.createElement(k.b, {
						displayText: z(q.a.Last),
						isSelected: r === q.a.Last,
						onClick: this.onDropdownClickLast
					}), o.a.createElement(k.b, {
						displayText: z(q.a.None),
						isSelected: r === q.a.None,
						onClick: this.onDropdownClickNone
					})))
				}
			}
			var Q = K;
			const J = "CommentSort--SortPicker",
				Y = "CommentSort--HighlightPicker",
				X = "CommentSort--Tooltip",
				Z = Object(y.a)(C.a),
				$ = Object(i.c)({
					commentPermalink: (e, t) => {
						let {
							commentId: n
						} = t;
						return n && Object(L.m)(e, {
							commentId: n
						})
					},
					contestModeModalIsOpen: Object(D.b)("CommentSort--ContestMode--Modal"),
					dropdownIsOpen: Object(B.b)(J),
					highlightIsOpen: Object(B.b)(Y),
					hasModeratorPostPermissions: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(F.m)(e, {
							postId: n
						});
						return !!s && s.posts
					},
					post: U.G,
					postPermalink: U.F,
					showCommentHighlighter: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(G.v)(e),
							r = !!Object(F.m)(e, {
								postId: n
							}),
							o = Object(U.G)(e, {
								postId: n
							});
						return (r || s) && !!o && !!o.previousVisits && o.previousVisits.length > 0
					},
					selectedHighlightSort: L.p
				}),
				ee = Object(a.b)($, (e, t) => {
					let {
						postId: n
					} = t;
					return {
						changeHighlightSort: t => e(Object(u.b)({
							sort: t
						})),
						onOpenDropdown: () => e(Object(l.h)({
							tooltipId: J
						})),
						onOpenHighlightDropdown: t => {
							e(Object(l.h)({
								tooltipId: Y
							})), t()
						},
						onSetSuggestedSort: t => e(v(n, t)),
						hideTooltip: () => e(Object(l.i)()),
						setContestMode: t => e(Object(p.X)(t, n)),
						showTooltip: () => e(Object(l.h)({
							tooltipId: X
						})),
						toggleContestModeModal: () => e(Object(m.i)("CommentSort--ContestMode--Modal"))
					}
				});
			class te extends o.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.sendCommentSortEvent = (e, t, n, s) => this.props.sendEvent(T(e, this.props.isOverlay, t, n, s)), this.onOpenDropdownClick = () => {
						this.props.onOpenDropdown(), this.sendCommentSortEvent("sorting", void 0, this.props.sort, "post_detail")
					}, this.onSortOptionClick = e => this.sendCommentSortEvent("sort_by", this.props.sort, e, "post_detail"), this.clearSortOnClick = () => {
						this.props.onSetSuggestedSort(null), this.sendCommentSortEvent("clear_suggested_sort", this.props.sort)
					}, this.setSortOnClick = () => {
						const e = this.props.suggestedSort || void 0;
						this.props.onSetSuggestedSort(this.props.sort), this.sendCommentSortEvent("set_suggested_sort", e, this.props.sort)
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onOpenHighlightSelector = () => {
						this.props.onOpenHighlightDropdown(N("dropdown", "click"))
					}, this.setContestMode = () => {
						this.props.sendEvent(R(!this.props.post.contestMode)), this.props.setContestMode(!this.props.post.contestMode)
					}
				}
				addSuggestedLabel(e) {
					return s.fbt._("{sort name} (suggested)", [s.fbt._param("sort name", e)], {
						hk: "3pDfQ9"
					})
				}
				render() {
					const {
						changeHighlightSort: e,
						className: t,
						commentPermalink: n,
						contestModeModalIsOpen: r,
						dropdownIsOpen: a,
						elementRef: i,
						hideTooltip: l,
						highlightIsOpen: u,
						hasModeratorPostPermissions: m,
						isOverlay: p,
						location: b,
						post: h,
						postPermalink: f,
						selectedHighlightSort: g,
						showCommentHighlighter: _,
						sort: v,
						suggestedSort: y,
						showTooltip: j,
						toggleContestModeModal: C
					} = this.props, w = h.contestMode, T = !b.search.includes(c.t.CONFIDENCE), P = v === c.t.CONFIDENCE && T, R = m && !P, D = c.v[v], L = D ? D() : "", F = y && v === y && !P ? this.addSuggestedLabel(L) : L, U = w ? s.fbt._("End contest mode?", null, {
						hk: "2AkJRZ"
					}) : s.fbt._("Start contest?", null, {
						hk: "2PQPOu"
					}), B = w ? s.fbt._("End", null, {
						hk: "1Q8KqM"
					}) : s.fbt._("Start", null, {
						hk: "Mjvpj"
					}), G = w ? s.fbt._("Ending contest mode will make comment vote scores visible and disable random comment ordering.", null, {
						hk: "3PXrGq"
					}) : s.fbt._("Starting a contest will hide comment vote scores and randomize the order of the comments for non-mods.", null, {
						hk: "EDqlf"
					}), H = w && !m;
					return o.a.createElement("div", {
						className: Object(d.a)(t, W.a.container, {
							[W.a.hideCommentSort]: !_ && H
						}),
						ref: i
					}, o.a.createElement("div", {
						className: W.a.containerRow
					}, !H && o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: W.a.DropdownContainer
					}, o.a.createElement(k.b, {
						className: Object(d.a)(W.a.SortPicker, W.a.Row),
						textClassName: W.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Sort by",null,{hk:"E6T9r"})}: ${F}`,
						id: J,
						noHover: !0,
						skipRoleAttr: !0,
						onClick: this.onOpenDropdownClick
					}), o.a.createElement(A.b, {
						className: W.a.DropdownTriangle,
						onClick: this.onOpenDropdownClick
					})), o.a.createElement(Z, {
						isOpen: a,
						tooltipId: J
					}, [c.t.CONFIDENCE, c.t.TOP, c.t.NEW, c.t.CONTROVERSIAL, c.t.OLD, c.t.QA].map(e => {
						const t = n || f,
							s = Object(S.b)(t),
							r = c.v[e],
							a = r ? r() : "";
						return o.a.createElement(E.a, {
							className: W.a.ViewFullLinkOrOverlayLink,
							isOverlay: p,
							key: e,
							onClick: () => this.onSortOptionClick(e),
							role: "menuitem",
							tabIndex: -1,
							to: `${s}?sort=${e}`
						}, o.a.createElement(k.b, {
							displayText: a,
							isSelected: v === e,
							skipRoleAttr: !0
						}))
					}))), R && !H && (y ? o.a.createElement("button", {
						className: W.a.SortLink,
						onClick: v !== y ? this.setSortOnClick : this.clearSortOnClick
					}, v !== y ? s.fbt._("Set new suggested sort", null, {
						hk: "13BpoB"
					}) : s.fbt._("Clear suggested sort", null, {
						hk: "3WWQBy"
					})) : o.a.createElement("button", {
						className: W.a.SetSort
					}, o.a.createElement("button", {
						className: W.a.SortLink,
						onClick: this.setSortOnClick
					}, s.fbt._("Set as suggested sort", null, {
						hk: "3qLzxp"
					})), o.a.createElement("span", {
						id: X,
						onMouseEnter: j,
						onMouseLeave: l
					}, o.a.createElement(x.c, {
						className: W.a.Tooltip,
						text: s.fbt._("Suggested sort defaults Redditors to a specific way of sorting comments within this post", null, {
							hk: "3KM0ma"
						}),
						tooltipId: X
					}), o.a.createElement(M.a, {
						className: W.a.Info
					})))), m && o.a.createElement("button", {
						className: W.a.ContestMode,
						onClick: this.props.toggleContestModeModal
					}, s.fbt._("Contest", null, {
						hk: "1KrhdJ"
					}), o.a.createElement(I.a, {
						className: W.a.ToggleSwitch,
						on: w
					}))), _ && o.a.createElement("div", {
						className: W.a.containerRow
					}, o.a.createElement(Q, {
						changeHighlightSort: e,
						highlightIsOpen: u,
						id: Y,
						onOpen: this.onOpenHighlightSelector,
						selectedSort: g,
						trackHighlight: N
					})), r && o.a.createElement(O.a, {
						actionText: B,
						headerText: U,
						modalText: G,
						onConfirm: this.setContestMode,
						toggleModal: C,
						withOverlay: !0
					}))
				}
			}
			t.b = ee(Object(j.c)(te))
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				o = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				a = n.n(o);
			const i = s.a.wrapped(r.c, "RestrictedButton", a.a);
			t.a = i
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				RestrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				restrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				Show: "YoaDbMbI8PpFFWQbD_Uwq",
				show: "YoaDbMbI8PpFFWQbD_Uwq",
				CommentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk",
				commentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk"
			}
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/reddit/actions/comment/moderation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/ModModeReports/helpers.ts"),
				b = n("./src/reddit/components/TrackingHelper/index.tsx"),
				h = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/helpers/trackers/modTools.ts"),
				g = n("./src/reddit/selectors/moderatingComments.ts"),
				_ = n("./src/reddit/selectors/moderatorPermissions.ts"),
				v = n("./src/reddit/selectors/tooltip.ts"),
				O = n("./src/reddit/selectors/user.ts"),
				x = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				E = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				y = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				j = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				C = n("./src/reddit/icons/svgs/Show/index.tsx"),
				k = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				I = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				S = n.n(I);
			const w = Object(h.u)(),
				T = e => `Distinguish--Dropdown--${e}`,
				N = Object(i.c)({
					currentUser: O.k,
					collapsedBecauseCrowdControl: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(g.a)(e, {
							commentId: n.id
						})
					},
					isDistinguishDropdownOpen: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(v.b)(T(n.id))(e)
					},
					moderatorPermissions: (e, t) => {
						const {
							comment: n
						} = t;
						return Object(h.h)(e, t) || Object(_.n)(e, {
							subredditId: n.subredditId
						})
					},
					modModeEnabled: h.U
				}),
				P = Object(a.b)(N, (e, t) => {
					let {
						comment: n
					} = t;
					return {
						onApproveComment: () => e(Object(u.a)(n.id)),
						onDistinguishComment: (t, s) => e(Object(u.b)(n.id, t, s)),
						onLockComment: () => e(Object(u.c)(n.id)),
						onRemoveComment: () => e(Object(u.e)(n.id, !1)),
						onSpamComment: () => e(Object(u.e)(n.id, !0)),
						onShowComment: () => e(Object(u.d)(n.id)),
						onToggleDistinguishDropdown: () => e(Object(m.h)({
							tooltipId: T(n.id)
						}))
					}
				});
			t.a = w(P(l.a.wrapped(Object(b.c)(e => {
				let {
					className: t,
					comment: n,
					currentUser: r,
					isCommentAuthor: a,
					collapsedBecauseCrowdControl: i,
					moderatorPermissions: l,
					modModeEnabled: u,
					onApproveComment: m,
					onDistinguishComment: b,
					onLockComment: h,
					onRemoveComment: g,
					onShowComment: _,
					onSpamComment: v,
					onToggleDistinguishDropdown: O,
					sendEvent: I,
					pageLayer: w,
					...T
				} = e;
				const N = Object(p.b)(n),
					P = n.isApproved && N,
					R = !n.isRemoved || n.bannedBy === c.k,
					A = i,
					M = e => I(Object(f.b)(e, n.id)),
					D = "chat_comments" === (null == w ? void 0 : w.queryParams.only);
				return o.a.createElement("div", {
					className: t
				}, (n.bannedBy || N) && o.a.createElement(k.a, {
					text: P ? s.fbt._("Reapprove", null, {
						hk: "1XngBU"
					}) : s.fbt._("Approve", null, {
						hk: "2219Nh"
					}),
					onClick: () => {
						m(), D && I(Object(f.a)("approve", n.id)), M("approve")
					}
				}, o.a.createElement(x.a, {
					className: S.a.icon
				})), R && o.a.createElement(o.a.Fragment, null, o.a.createElement(k.a, {
					text: n.bannedBy === c.k ? s.fbt._("Confirm Removal", null, {
						hk: "3JozXJ"
					}) : s.fbt._("Remove", null, {
						hk: "3tYl0U"
					}),
					onClick: () => {
						g(), D && I(Object(f.a)("remove", n.id)), n.bannedBy === c.k ? M("confirm_remove") : M("remove")
					}
				}, o.a.createElement(y.a, {
					className: S.a.icon
				})), o.a.createElement(k.a, {
					text: s.fbt._("Spam", null, {
						hk: "1jEVwZ"
					}),
					onClick: () => {
						v(), M("spam")
					}
				}, o.a.createElement(j.a, {
					className: S.a.icon
				}))), o.a.createElement(k.a, {
					text: n.isLocked ? s.fbt._("Unlock", null, {
						hk: "KGYeO"
					}) : s.fbt._("Lock", null, {
						hk: "3rDzwU"
					}),
					onClick: () => {
						h(), M(n.isLocked ? "unlock" : "lock")
					}
				}, o.a.createElement(E.a, {
					className: S.a.icon
				})), A && o.a.createElement(k.a, {
					text: s.fbt._("Show Comment", null, {
						hk: "2ki02n"
					}),
					onClick: () => {
						_()
					}
				}, o.a.createElement(C.a, {
					className: Object(d.a)(S.a.icon, S.a.Show)
				})))
			}), "CommentModToolsFlatlist", S.a)))
		},
		"./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less": function(e, t, n) {
			e.exports = {
				author: "DjcdNGtVXPcxG0yiFXIoZ",
				authorLine: "_1a_HxF03jCyxnx706hQmJR",
				headerLine: "_2nobNdIwmDrXK7NZps5zUO",
				flair: "cFNx42ceihnMpvAsovOTi",
				baselineItem: "_3QEK34iVL1BjyHAVleVVNQ",
				container: "-Xcv3XBXmgiY2X5RqaPbO",
				cryptoPoints: "_2bfuNFXt4pN8991xPpimzy",
				role: "_3AgEmWP1qkCB8nds7LhzEB",
				achievementFlair: "_2a_XgY10KOzM0PRvywwDuY",
				cakeDay: "TNzy9Y4Ql8v80YssZ59GR",
				metaText: "_3yx4Dn0W3Yunucf5sVJeFU",
				separator: "_8b8fUdBRxCYj9MkNpFvvv",
				userBadges: "_3AXw8D3tzlqTRxjQdd5ve7",
				userFlairLine: "_3w527zTLhXkd08MyacMV9H",
				LastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy",
				lastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Role.m.less": function(e, t, n) {
			e.exports = {
				role: "LWgI-A6rN9Wajn1VLxu2A",
				modAchievement: "_2am63Mu1vtyM2MwmCJoxJp"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/author.m.less": function(e, t, n) {
			e.exports = {
				authorHoverCard: "sMaSljeAO1a-nAhrURxdj",
				container: "NL6v1uLnaxK0IHIJdUdel"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less": function(e, t, n) {
			e.exports = {
				cakedayIcon: "_12wHSVQW6wUCbn56VnIfI-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less": function(e, t, n) {
			e.exports = {
				commentAuthorLink: "wM6scouPXXsFDSZmZPHRo"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less": function(e, t, n) {
			e.exports = {
				crowdControlText: "_3UBJEBi_CJ8y1i9Up_67Hb"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/edited.m.less": function(e, t, n) {
			e.exports = {
				editedText: "_18WUrfxbke5CjwIjhXu6C-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.m.less": function(e, t, n) {
			e.exports = {
				iconStyles: "S8WH2aCfP030wVxp0iR_o",
				AdminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				adminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				AdminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				adminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				ContractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				contractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				ModeratorIcon: "rZkjnStRKzlmtr__ixhKy",
				moderatorIcon: "rZkjnStRKzlmtr__ixhKy",
				OpIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				opIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				RightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				rightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				MetaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				metaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				publicPoints: "_2LXcsgibmlCEsBPk8MLy7e",
				NftAuthor: "kDnKKJWz2PJGoalLInCW1",
				nftAuthor: "kDnKKJWz2PJGoalLInCW1",
				MetaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				metaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				DeletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				deletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				container: "_3ezOJqKdLbgkHsXcfvS5SA",
				collapsed: "_2k27lgIDltx9kOzVGXt48i",
				hasBadges: "_1KMFaeLEhRikeFEOlWE9Ti",
				liveStreaming: "_1iUed95f0HTc84gBtoOxdc",
				authorRole: "_3uDFtRr_CTErFPJQBtzECl",
				metaText: "_3_GZIIN1xcMEC5AVuv4kfa",
				separator: "_1PuBpmbH2FA5sozYR7EuCs",
				userBadges: "_3Ofd-Ek86mwX500i92F84q",
				cakeDay: "UG2sa-VYMzrn7D1iNXtfR"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/AwardBadges/index.tsx"),
				u = n("./src/reddit/components/AuthorLink/index.tsx"),
				m = n("./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less"),
				p = n.n(m);
			const b = e => {
				const {
					className: t,
					collapsed: n,
					comment: r,
					isAuthorDeleted: a,
					isCommentAuthorBlocked: i,
					isLivestreaming: c,
					isStrong: l,
					onClick: m,
					style: b
				} = e;
				return n && i ? o.a.createElement("p", {
					className: Object(d.a)(p.a.commentAuthorLink, t)
				}, s.fbt._("Blocked account", null, {
					hk: "2KVMxM"
				})) : o.a.createElement(u.a, {
					author: r.author,
					className: Object(d.a)(p.a.commentAuthorLink, t),
					isAuthorDeleted: a,
					isCommentAuthorBlocked: i,
					isLivestreaming: c,
					isStrong: l,
					linkProps: {
						"data-testid": "comment_author_link"
					},
					onClick: m,
					style: b
				}, r.author)
			};
			var h = n("./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts"),
				f = n("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				g = n("./src/reddit/components/Flair/index.tsx"),
				_ = n("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				v = n("./src/reddit/components/LastAuthorModNoteIcon/index.tsx"),
				O = n("./src/reddit/components/PostTopMeta/index.tsx"),
				x = n("./src/reddit/controls/MetaData/index.tsx"),
				E = n("./src/reddit/helpers/flair.ts"),
				y = n("./src/reddit/helpers/trackers/features/powerupsFlair.ts"),
				j = n("./src/reddit/hooks/useTracking.ts"),
				C = n("./src/reddit/models/Comment/index.ts"),
				k = n("./src/reddit/selectors/gold/powerups/index.ts"),
				I = n("./src/lib/constants/index.ts"),
				S = n("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				w = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				T = n("./src/reddit/components/Comments/Comment/TopMeta/author.m.less"),
				N = n.n(T);
			const P = e => {
				let {
					authorClassName: t,
					className: n,
					comment: s,
					collapsed: r,
					isLivestreaming: a,
					isStrong: i,
					onClick: c,
					renderedInOverlay: l
				} = e;
				const u = Object(C.f)(s),
					m = o.a.createElement(S.b, {
						ignore: u || !!s.distinguishType && s.distinguishType !== I.G.NONE,
						subredditId: s.subredditId,
						userId: s.authorId
					}, o.a.createElement(b, {
						className: t,
						collapsed: r,
						comment: s,
						isAuthorDeleted: Object(C.f)(s),
						isCommentAuthorBlocked: Object(C.g)(s),
						isLivestreaming: a,
						isStrong: i,
						onClick: c
					}));
				return u ? m : o.a.createElement(w.b, {
					className: Object(d.a)(N.a.authorHoverCard, n),
					collapsed: r,
					isCommentAuthorBlocked: Object(C.g)(s),
					postOrComment: s,
					tooltipType: l ? O.c.Lightbox : void 0
				}, m)
			};
			var R = n("./src/config.ts"),
				A = n("./src/reddit/actions/tooltip.ts"),
				M = n("./src/reddit/components/InfoTextTooltip/index.tsx");
			const D = function(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				return `${e}${t}${n?"inOverlay":""}`
			};
			var L = n("./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less"),
				F = n.n(L);
			const U = e => {
				let {
					className: t,
					commentId: n,
					renderedInOverlay: r
				} = e;
				const i = Object(a.d)(),
					c = () => i(Object(A.h)({
						tooltipId: l
					})),
					l = D("CommentTopMeta--cakeday--", n, r),
					u = s.fbt._("Cake day", null, {
						hk: "1xptSi"
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("img", {
					className: Object(d.a)(F.a.cakedayIcon, t),
					src: `${R.a.assetPath}/img/powerups/flair_cakeday.png`,
					alt: u,
					id: l,
					onMouseEnter: c,
					onMouseLeave: c,
					"data-testid": "cakeday-icon"
				}), o.a.createElement(M.c, {
					tooltipId: l,
					text: u
				}))
			};
			var B = n("./src/lib/addQueryParams/index.ts"),
				G = n("./src/reddit/actions/comment/index.ts"),
				H = n("./src/reddit/actions/post.ts"),
				W = n("./src/reddit/components/HumanDate/index.tsx"),
				q = n("./src/reddit/helpers/path/index.ts");
			const V = e => {
					const {
						className: t,
						comment: n,
						compact: s,
						onClick: r,
						permalink: i,
						renderedInOverlay: d,
						isBlockingInterstitialEnabled: c
					} = e, l = Object(a.d)(), u = D("CommentTopMeta--Created--", n.id, d), m = () => l(Object(A.h)({
						tooltipId: u
					}));
					return o.a.createElement("a", {
						className: t,
						"data-testid": "comment_timestamp",
						href: Object(B.a)(i, {
							utm_source: "reddit",
							utm_medium: "web2x",
							context: 3
						}),
						id: u,
						onClick: e => {
							null == r || r(e), z(l, n.id), c && (e.preventDefault(), l(Object(H.Z)(Object(q.b)(i), n.postId)))
						},
						onMouseEnter: m,
						onMouseLeave: m,
						target: "_blank",
						rel: "nofollow noopener noreferrer"
					}, o.a.createElement(W.d, {
						seconds: n.created,
						shortenedUnit: s
					}), o.a.createElement(M.c, {
						tooltipId: u
					}, o.a.createElement(W.b, {
						seconds: n.created
					})))
				},
				z = (e, t) => {
					window.addEventListener("focus", (function n() {
						K(e, t, n)
					}))
				},
				K = (e, t, n) => {
					window.removeEventListener("focus", n), e(Object(G.h)({
						commentListNodeId: t
					})), window.setTimeout(() => e(Object(G.h)({
						commentListNodeId: t
					})), 5e3)
				};
			var Q = n("./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less"),
				J = n.n(Q);
			const {
				fbt: Y
			} = n("./node_modules/fbt/lib/FbtPublic.js"), X = () => o.a.createElement(x.a, {
				className: J.a.crowdControlText
			}, Y._("Crowd Control", null, {
				hk: "4WgEW"
			}));
			var Z = n("./src/reddit/components/Comments/Comment/TopMeta/edited.m.less"),
				$ = n.n(Z);
			const {
				fbt: ee
			} = n("./node_modules/fbt/lib/FbtPublic.js"), te = e => {
				let {
					compact: t,
					editedAt: n
				} = e;
				return o.a.createElement(x.a, {
					className: $.a.editedText
				}, ee._("edited {time}", [ee._param("time", o.a.createElement(W.d, {
					seconds: n,
					shortenedUnit: t
				}))], {
					hk: "1tiB0u"
				}))
			};
			var ne = n("./src/reddit/helpers/isRemoved.ts"),
				se = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				re = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				oe = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				ae = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				ie = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				de = n("./src/reddit/icons/fonts/Report/index.tsx"),
				ce = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				le = n("./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less"),
				ue = n.n(le);
			const me = e => {
				let {
					comment: t,
					ignoreLock: r,
					renderedInOverlay: i,
					isAdmin: d
				} = e;
				const c = Object(a.d)(),
					l = e => () => c(Object(A.f)({
						tooltipId: e
					})),
					u = () => c(Object(A.i)()),
					m = e => D(e, t.id, i),
					p = m("CommentTopMeta--Approve--"),
					b = m("CommentTopMeta--Remove--"),
					h = m("CommentTopMeta--Report--"),
					f = m("CommentTopMeta--Spam--"),
					g = l(b);
				return o.a.createElement(o.a.Fragment, null, (t.approvedBy || t.isApproved) && o.a.createElement(o.a.Fragment, null, o.a.createElement(oe.a, {
					className: ue.a.approveIcon,
					desc: Object(se.a)(t),
					id: p,
					onMouseEnter: l(p),
					onMouseLeave: u,
					isFilled: !0
				}), o.a.createElement(M.c, {
					tooltipId: p,
					text: Object(se.a)(t)
				})), Object(ne.a)(t) && o.a.createElement(o.a.Fragment, null, o.a.createElement(ie.a, {
					className: ue.a.removeIcon,
					desc: Object(se.b)(t),
					id: b,
					onMouseEnter: g,
					onMouseLeave: u,
					isFilled: !0
				}), o.a.createElement(M.c, {
					tooltipId: b,
					text: Object(se.b)(t)
				})), Object(ne.a)(t) && t.isRemoved && !t.modNote && !t.modRemovalReason && o.a.createElement("a", {
					className: ue.a.removalReason,
					onClick: () => {
						n.e("removalReasonActions").then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(e => c(e.fetchReasonsAndOpenModal(t.subredditId, [t.id])))
					}
				}, s.fbt._("Add a removal reason", null, {
					hk: "L6yrL"
				})), Object(ne.a)(t) && !(t.isRemoved && !t.modNote && !t.modRemovalReason) && o.a.createElement("a", {
					className: ue.a.removalReason,
					onMouseEnter: g,
					onMouseLeave: u
				}, s.fbt._("Removal reason", null, {
					hk: "20NRw8"
				})), t.isLocked && !r && o.a.createElement(ae.a, {
					className: ue.a.lockIcon,
					desc: s.fbt._("Locked", null, {
						hk: "40Ju3g"
					}),
					isFilled: !0
				}), t.bannedBy && t.isSpam && o.a.createElement(o.a.Fragment, null, o.a.createElement(ce.a, {
					className: ue.a.spamIcon,
					desc: Object(se.d)(t),
					id: f,
					onMouseEnter: l(f),
					onMouseLeave: u,
					isFilled: !0
				}), o.a.createElement(M.c, {
					tooltipId: f,
					text: Object(se.d)(t)
				})), Object(re.a)(t) && o.a.createElement(o.a.Fragment, null, o.a.createElement(de.a, {
					className: ue.a.reportIcon,
					desc: Object(se.c)(t.numReports),
					id: h,
					onMouseEnter: l(h),
					onMouseLeave: u,
					isFilled: !0
				}), o.a.createElement(M.c, {
					tooltipId: h,
					text: Object(se.c)(t.numReports)
				})), t.isDeleted && d && o.a.createElement(o.a.Fragment, null, o.a.createElement(ie.a, {
					className: ue.a.removeIcon,
					isFilled: !0
				}), o.a.createElement("span", {
					className: ue.a.userDeletion
				}, s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}))))
			};
			var pe, be = n("./src/lib/colors/constants.ts");
			! function(e) {
				e.Op = "op", e.Mod = "mod", e.Admin = "admin", e.AlumniAdmin = "alumniAdmin", e.Contractor = "contractor"
			}(pe || (pe = {}));
			var he = n("./src/reddit/components/Comments/Comment/TopMeta/Role.m.less"),
				fe = n.n(he);
			const ge = {
					[pe.Admin]: {
						color: be.c,
						getLabel: () => s.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--Admin--",
						tooltipTemplate: () => s.fbt._("Reddit admin, speaking officially", null, {
							hk: "3vg8wE"
						})
					},
					[pe.Mod]: {
						color: be.d,
						getLabel: () => s.fbt._("Mod", null, {
							hk: "1b6Q1p"
						}),
						tooltipPrefix: "CommentTopMeta--Mod--",
						tooltipTemplate: e => (e => s.fbt._("Moderator of {subredditDisplayText}, speaking officially", [s.fbt._param("subredditDisplayText", e)], {
							hk: "3pHm3n"
						}))(e.subredditDisplayText)
					},
					[pe.Op]: {
						color: be.a,
						getLabel: () => s.fbt._("Op", null, {
							hk: "ERTp9"
						}),
						tooltipPrefix: "CommentTopMeta--OP--",
						tooltipTemplate: () => s.fbt._("Original Poster", null, {
							hk: "3DqK8z"
						})
					},
					[pe.AlumniAdmin]: {
						color: be.c,
						getLabel: () => s.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--AdEm--",
						tooltipTemplate: () => s.fbt._("Reddit admin emeritus", null, {
							hk: "1Md5AV"
						})
					},
					[pe.Contractor]: {
						color: be.a,
						getLabel: () => s.fbt._("Contractor", null, {
							hk: "2nhaY6"
						}),
						tooltipPrefix: "CommentTopMeta--Contractor--",
						tooltipTemplate: () => s.fbt._("Reddit contractor", null, {
							hk: "3APwEh"
						})
					}
				},
				_e = e => {
					const t = Object(a.d)(),
						n = function(e) {
							return e.isAdmin ? pe.Admin : e.isMod ? pe.Mod : e.isOp ? pe.Op : e.distinguishType === I.G.ALUMNI_ADMIN ? pe.AlumniAdmin : e.authorIsContractor ? pe.Contractor : null
						}(e.comment);
					if (!n) return null;
					if (n === pe.Contractor && !e.renderContractorBadge) return null;
					const {
						tooltipPrefix: s,
						color: r,
						getLabel: i,
						tooltipTemplate: c
					} = ge[n], l = i(), u = D(s, e.comment.id, e.renderedInOverlay), m = c(e), p = () => t(Object(A.h)({
						tooltipId: u
					}));
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
						className: Object(d.a)(fe.a.role, e.className),
						style: {
							color: r
						},
						id: u,
						onMouseEnter: p,
						onMouseLeave: p
					}, o.a.createElement("span", null, l), n === pe.Mod && o.a.createElement(ve, null)), o.a.createElement(M.c, {
						tooltipId: u,
						text: m
					}))
				},
				ve = () => o.a.createElement("img", {
					alt: s.fbt._("Moderator Achievement", null, {
						hk: "20RhJI"
					}),
					className: fe.a.modAchievement,
					src: `${R.a.assetPath}/img/powerups/moderator-achievement.svg`
				});
			var Oe = n("./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less"),
				xe = n.n(Oe);
			const {
				fbt: Ee
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ye = () => o.a.createElement(x.a, {
				className: xe.a.stickiedText
			}, Ee._("Stickied comment", null, {
				hk: "XUSav"
			}));
			var je = n("./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less"),
				Ce = n.n(je);
			const ke = e => {
				const {
					className: t,
					collapsed: n,
					collapsedBecauseCrowdControl: r,
					comment: i,
					flair: c,
					ignoreLock: u,
					isModWithUserNotesPermissions: m,
					isLivestreaming: p,
					onCommentAuthorClick: b,
					onCommentTimestampClick: I,
					permalink: S,
					renderContractorBadge: w,
					renderedInOverlay: T,
					subredditDisplayText: N,
					isAdmin: R
				} = e, A = Object(j.a)(), M = i.subredditId, D = Object(a.e)(e => Object(k.f)(e, {
					subredditId: M
				}));
				if (i.isDeleted && !R) return o.a.createElement("div", {
					className: Object(d.a)(Ce.a.container, t),
					"data-testid": "post-comment-header-deleted"
				}, o.a.createElement("span", {
					className: Ce.a.authorLine
				}, o.a.createElement("span", {
					className: Ce.a.metaText
				}, i.deletedBy === C.c.User ? s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}) : s.fbt._("Comment removed by moderator", null, {
					hk: "E1t49"
				})), o.a.createElement(x.c, {
					className: Ce.a.separator
				}), o.a.createElement(V, {
					key: "Created",
					className: Ce.a.metaText,
					comment: i,
					compact: !0,
					permalink: S,
					renderedInOverlay: T
				})));
				return o.a.createElement("div", {
					className: Object(d.a)(Ce.a.container, t),
					"data-testid": "post-comment-header"
				}, o.a.createElement("span", {
					className: Ce.a.authorLine
				}, !Object(C.f)(i) && o.a.createElement(f.b, {
					className: Ce.a.userBadges,
					badgeSize: 20,
					showAddCustom: !0,
					subredditId: i.subredditId,
					userId: i.authorId,
					uniqueIdentifier: i.id
				}), o.a.createElement("div", {
					className: Ce.a.baselineItem
				}, o.a.createElement(P, {
					authorClassName: Ce.a.author,
					collapsed: n,
					comment: i,
					isLivestreaming: p,
					onClick: b,
					renderedInOverlay: T
				})), !Object(C.f)(i) && m && o.a.createElement(v.a, {
					postOrComment: i,
					className: Ce.a.LastAuthorModNoteIcon
				}), r && o.a.createElement(X, null), o.a.createElement(_e, {
					className: Ce.a.role,
					comment: i,
					subredditDisplayText: N,
					renderContractorBadge: w,
					renderedInOverlay: T
				}), i.isAuthorCakeday ? o.a.createElement(U, {
					className: Ce.a.cakeDay,
					commentId: i.id,
					renderedInOverlay: T
				}) : !Object(C.f)(i) && D && o.a.createElement(h.a, {
					className: Ce.a.achievementFlair,
					subredditId: i.subredditId,
					userId: i.authorId,
					onHover: () => {
						A(Object(y.b)(i.id, i.subredditId, i.authorId))
					},
					showPopupOnHover: !0
				}), o.a.createElement(_.a, {
					className: Ce.a.cryptoPoints,
					contentId: i.id,
					subredditId: i.subredditId,
					userId: i.authorId,
					username: i.author
				}), o.a.createElement(x.c, {
					className: Ce.a.separator
				}), o.a.createElement(V, {
					key: "Created",
					className: Ce.a.metaText,
					comment: i,
					compact: !0,
					onClick: I,
					permalink: S,
					renderedInOverlay: T
				}), i.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: Ce.a.separator
				}), o.a.createElement(ye, null)), i.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: Ce.a.separator
				}), o.a.createElement(te, {
					compact: !0,
					editedAt: i.editedAt
				})), o.a.createElement(me, {
					comment: i,
					ignoreLock: u,
					renderedInOverlay: T,
					isAdmin: R
				}), o.a.createElement(l.a, {
					thing: i,
					tooltipType: T ? O.c.Lightbox : void 0
				})), c && !Object(E.o)(c) && o.a.createElement("span", {
					className: Ce.a.userFlairLine
				}, o.a.createElement(g.b, {
					className: Ce.a.flair,
					flair: c,
					forceSmallEmojis: !0
				})))
			};
			var Ie = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				Se = n("./src/reddit/selectors/economics.ts"),
				we = n("./src/reddit/models/Flair/index.ts"),
				Te = n("./src/reddit/selectors/comments.ts"),
				Ne = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				Pe = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Re = n("./src/reddit/selectors/subreddit.ts"),
				Ae = n("./src/reddit/selectors/userFlair.ts"),
				Me = n("./src/reddit/components/Comments/Comment/TopMeta/index.m.less"),
				De = n.n(Me);

			function Le() {
				return (Le = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Fe = c.a.wrapped(g.b, "RightPositionedAuthorFlair", De.a),
				Ue = c.a.span("DeletedText", De.a),
				Be = c.a.wrapped(x.a, "MetaSeparator", De.a),
				Ge = Object(a.b)(() => Object(i.c)({
					hasBadges: (e, t) => {
						let {
							comment: n
						} = t;
						return !!Object(Se.q)(e, n.subredditId, n.authorId).length
					},
					subredditDisplayText: (e, t) => {
						const n = Object(Re.J)(e, {
							commentId: t.comment.id
						});
						return n ? n.displayText : ""
					},
					flairPosition: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(Ae.e)(e, {
							subredditId: n.subredditId
						})
					},
					commentPermalink: (e, t) => Object(Te.m)(e, {
						commentId: t.comment.id
					}),
					isBlockingInterstitialEnabled: Ne.b,
					isBlockingInterstitialV2Enabled: Ne.c,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(Pe.i)(e, n.subredditId)
					}
				}));
			t.a = Ge(e => {
				const {
					children: t,
					className: n,
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: a,
					commentPermalink: i,
					commentsPageKey: c,
					compact: u,
					flair: m,
					flairPosition: p,
					hasBadges: b,
					hideAwards: h = !1,
					ignoreFlairPosition: v,
					ignoreLock: E,
					isAdmin: y,
					isBlockingInterstitialEnabled: j,
					isBlockingInterstitialV2Enabled: k,
					isModWithUserNotesPermissions: I,
					isLivestreaming: S,
					isPostComment: w,
					onCommentAuthorClick: T,
					onCommentTimestampClick: N,
					renderContractorBadge: R,
					renderedInOverlay: A,
					subredditDisplayText: M,
					userHasNft: D
				} = e, L = o.a.createElement(o.a.Fragment, null, o.a.createElement(Ie.b, {
					commentId: a.id
				}), o.a.createElement(Ie.a, {
					commentId: a.id,
					commentsPageKey: c
				}));
				if (w) return o.a.createElement(o.a.Fragment, null, o.a.createElement(ke, {
					className: Object(d.a)(n, {
						[De.a.collapsed]: s
					}),
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: a,
					flair: m || null,
					ignoreLock: E,
					isAdmin: y,
					isModWithUserNotesPermissions: I,
					isLivestreaming: S,
					onCommentAuthorClick: T,
					onCommentTimestampClick: N,
					permalink: i,
					renderContractorBadge: !!R,
					renderedInOverlay: A,
					subredditDisplayText: M
				}), L);
				if (a.isDeleted) return o.a.createElement(He, Le({}, e, {
					className: Object(d.a)(n, De.a.container, {
						[De.a.collapsed]: s
					})
				}));
				if (s) return o.a.createElement(We, Le({}, e, {
					className: Object(d.a)(n, De.a.container, {
						[De.a.collapsed]: s
					})
				}));
				const F = !v && p === we.b.Left;
				return o.a.createElement("div", {
					className: Object(d.a)(n, De.a.container, {
						[De.a.collapsed]: s,
						[De.a.hasBadges]: b,
						[De.a.liveStreaming]: S
					}),
					"data-testid": "comment-top-meta"
				}, m && F && o.a.createElement(g.b, {
					flair: m,
					forceSmallEmojis: u
				}), !Object(C.f)(a) && o.a.createElement(f.b, {
					className: De.a.userBadges,
					showAddCustom: !0,
					subredditId: a.subredditId,
					userId: a.authorId,
					uniqueIdentifier: a.id
				}), t && t, o.a.createElement(P, {
					authorClassName: D ? De.a.NftAuthor : void 0,
					collapsed: s,
					comment: a,
					isLivestreaming: S,
					isStrong: !!u,
					onClick: T,
					renderedInOverlay: A
				}), r && o.a.createElement(X, null), r && o.a.createElement(x.c, {
					className: De.a.metaText,
					key: "crowdControlSeparator"
				}), m && !F && o.a.createElement(Fe, {
					flair: m,
					forceSmallEmojis: u
				}), !u && o.a.createElement(_.a, {
					className: De.a.publicPoints,
					contentId: a.id,
					metaSeparator: o.a.createElement(x.c, {
						className: De.a.metaText
					}),
					subredditId: a.subredditId,
					userId: a.authorId,
					username: a.author
				}), L, o.a.createElement(_e, {
					className: De.a.authorRole,
					comment: a,
					subredditDisplayText: M,
					renderContractorBadge: !!R,
					renderedInOverlay: A
				}), !u && o.a.createElement(o.a.Fragment, null, !a.isDeleted && !w && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.b, {
					className: De.a.metaText,
					isScoreHidden: a.isScoreHidden,
					score: a.score
				}), o.a.createElement(x.c, {
					className: De.a.metaText,
					key: "scoreCreatedSeparator"
				})), o.a.createElement(V, {
					key: "Created",
					className: De.a.MetaLink,
					comment: a,
					permalink: i,
					renderedInOverlay: A,
					isBlockingInterstitialEnabled: j || k
				}), a.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: De.a.separator
				}), o.a.createElement(ye, null)), a.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(x.c, {
					className: De.a.separator
				}), o.a.createElement(te, {
					editedAt: a.editedAt
				}))), o.a.createElement(me, {
					comment: a,
					ignoreLock: E,
					renderedInOverlay: A
				}), !h && o.a.createElement(l.a, {
					thing: a,
					tooltipType: A ? O.c.Lightbox : void 0
				}))
			});
			const He = e => {
					const {
						childrenInfo: t,
						collapsed: n,
						className: r,
						comment: a,
						commentPermalink: i,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c,
						renderedInOverlay: l
					} = e;
					return o.a.createElement("div", {
						className: r
					}, o.a.createElement(Ue, null, a.deletedBy === C.c.User ? s.fbt._("Comment deleted by user", null, {
						hk: "1Rtt4V"
					}) : s.fbt._("Comment removed by moderator", null, {
						hk: "E1t49"
					})), o.a.createElement(V, {
						key: "Created",
						className: De.a.MetaLink,
						comment: a,
						permalink: i,
						renderedInOverlay: l,
						isBlockingInterstitialEnabled: d || c
					}), n && qe({
						childrenInfo: t
					}))
				},
				We = e => {
					const {
						comment: t,
						className: n,
						childrenInfo: s,
						renderedInOverlay: r,
						collapsed: a,
						commentPermalink: i,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c
					} = e;
					return o.a.createElement("div", {
						className: n
					}, o.a.createElement("div", null, o.a.createElement(b, {
						comment: t,
						isAuthorDeleted: Object(C.f)(t),
						collapsed: a
					})), o.a.createElement(x.b, {
						className: De.a.metaText,
						isScoreHidden: t.isScoreHidden,
						score: t.score
					}), o.a.createElement(x.c, {
						className: De.a.metaText,
						key: "scoreCreatedSeparator"
					}), o.a.createElement(V, {
						key: "Created",
						className: De.a.MetaLink,
						comment: t,
						permalink: i,
						renderedInOverlay: r,
						isBlockingInterstitialEnabled: d || c
					}), qe({
						childrenInfo: s
					}))
				},
				qe = e => {
					const {
						hasContinueThread: t,
						numChildren: n
					} = e.childrenInfo || {
						hasContinueThread: !1,
						numChildren: 0
					};
					return o.a.createElement(Be, {
						className: De.a.metaText
					}, t ? s.fbt._({
						"*": "More than {number} children",
						_1: "More than 1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "13XC7a"
					}) : s.fbt._({
						"*": "{number} children",
						_1: "1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "dhX9w"
					}))
				}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less": function(e, t, n) {
			e.exports = {
				approveIcon: "_3Jlybj1GmQS_PfZVxE6yR1",
				automoderatorIcon: "_2EBjdWEqs2dwPePq0_1vJn",
				lockIcon: "YjyVr4SnBmO7WorLVMXq5",
				removeIcon: "_3M_jIwyB1POxBFR2jnGIp_",
				reportIcon: "_3hI84iVaolaHi85h6liPyp",
				spamIcon: "MufLXlXcv1oes9OlakuXr",
				removed: "_2LQnjoTNHDUWKBOoq2gTlm",
				removalReason: "EM8fL_jC3oe9bruIOZt2U",
				userDeletion: "_1KVzcRpEm0U5vCgrZbgiyN"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less": function(e, t, n) {
			e.exports = {
				stickiedText: "_2wd-K5Djdc9TGPRGDgmkpX"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.m.less": function(e, t, n) {
			e.exports = {
				VoteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				voteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				ContentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				contentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				CommentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				commentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				CommentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				commentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				CommentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				commentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				ParentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				parentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				Component: "_29-oldqrqqPwwjRRH0aLqU",
				component: "_29-oldqrqqPwwjRRH0aLqU"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return P
			})), n.d(t, "b", (function() {
				return M
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/objectSelector/index.ts"),
				d = n("./src/reddit/actions/comment/index.ts"),
				c = n("./src/reddit/actions/comment/moderation.ts"),
				l = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				u = n("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				m = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				p = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				b = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				h = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				f = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				g = n("./src/reddit/components/ModModeReports/index.tsx"),
				_ = n("./src/reddit/components/PostRailAndVotes/index.tsx"),
				v = n("./src/reddit/components/RichTextJson/index.tsx"),
				O = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				x = n("./src/reddit/models/Vote/index.ts"),
				E = n("./src/reddit/selectors/comments.ts"),
				y = n("./src/reddit/selectors/commentSelector.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/components/Comments/UnthreadedComment/index.m.less"),
				k = n.n(C),
				I = n("./src/lib/lessComponent.tsx");
			const S = I.a.div("VoteSpacer", k.a),
				w = I.a.div("ContentWrapper", k.a),
				T = I.a.div("CommentContentWrapper", k.a),
				N = I.a.div("CommentBody", k.a),
				P = I.a.div("ParentPostTitle", k.a),
				R = I.a.div("CommentParentWrapper", k.a),
				A = Object(a.c)({
					comment: (e, t) => Object(y.b)(e, t),
					commentPermalink: E.m,
					flair: E.e,
					subreddit: j.J
				}),
				M = Object(o.b)(A, (e, t) => {
					let {
						commentId: n,
						trackClick: s
					} = t;
					return {
						onIgnoreReports: () => e(Object(c.g)(n)),
						onVoteClick: t => {
							const [r, o] = t === x.a.upvoted ? [Object(d.r)(n), "upvote_comment"] : [Object(d.k)(n), "downvote_comment"];
							s(o)(), e(r)
						}
					}
				}),
				D = Object(i.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			t.c = M(I.a.wrapped(e => {
				const {
					className: t,
					comment: n,
					commentPermalink: s,
					flair: o,
					hasReports: a,
					isCheckboxSelected: i = !1,
					onIgnoreReports: d,
					onVoteClick: c,
					showModTools: x,
					subreddit: E,
					showBulkActionCheckbox: y,
					toggleCheckbox: j
				} = e, C = Object(f.a)(n);
				return r.a.createElement(u.a, {
					className: t,
					clickTrackingId: n.id,
					permalink: s
				}, r.a.createElement(_.a, {
					model: n,
					handleVote: c,
					showBulkActionCheckbox: y,
					isCheckboxSelected: i,
					toggleCheckbox: j
				}), r.a.createElement(S, null, r.a.createElement(w, null, r.a.createElement(R, null, n.postTitle && r.a.createElement(P, null, n.postTitle), n.postAuthor && r.a.createElement(b.a, {
					comment: n
				})), r.a.createElement(T, null, r.a.createElement(m.a, {
					comment: n
				}, r.a.createElement(N, null, r.a.createElement(v.b, {
					content: Object(O.a)(n),
					mediaMetadata: n.media && n.media.mediaMetadata,
					rtJsonElementProps: D(e)
				})), r.a.createElement(p.a, {
					comment: n,
					flair: o,
					subredditName: E ? E.displayText : null
				}), C && r.a.createElement(h.a, {
					thing: n
				}), a && r.a.createElement(g.a, {
					onIgnoreReports: d,
					reportable: n
				}), x && !n.isDeleted && r.a.createElement(l.a, {
					comment: n
				}))))))
			}, "Component", k.a))
		},
		"./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				d = n("./src/reddit/helpers/overlay/index.ts");
			const c = Object(o.b)(null, e => ({
				openLightbox: t => e(Object(d.a)(t))
			}));
			class l extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						permalink: t,
						openLightbox: n,
						...s
					} = this.props, o = s => e(() => s.metaKey || s.ctrlKey || 1 === s.button ? window.open(Object(a.a)(t, {
						context: 3
					})) : n(Object(a.a)(t, {
						context: 3
					})))(s);
					return r.a.createElement("div", {
						className: s.className,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3)), 1 === e.button && o(e)
						},
						onClick: e => {
							!this.cancelClick && 0 === e.button && o(e)
						}
					}, s.children)
				}
			}
			t.a = c(Object(i.a)(l))
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				DashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u",
				dashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less"),
				i = n.n(a);
			const d = o.a.div("DashWrapper", i.a);
			t.a = e => null === e.comment.parentId ? r.a.createElement(d, null, e.children) : r.a.createElement(d, null, r.a.createElement(d, null, e.children))
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				subredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				TopMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				topMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				Inline: "meK3ndVOmnvQt6wVaAg5W",
				inline: "meK3ndVOmnvQt6wVaAg5W",
				PostedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				postedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				TextContainer: "iV3Hb5JWIQSpA3WhioY-N",
				textContainer: "iV3Hb5JWIQSpA3WhioY-N"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/reddit/components/Comments/Comment/TopMeta/index.tsx"),
				i = n("./src/reddit/layout/row/Inline/index.tsx"),
				d = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less"),
				c = n.n(d),
				l = n("./src/lib/lessComponent.tsx");
			const u = l.a.wrapped(i.a, "Inline", c.a),
				m = l.a.wrapped(i.a, "PostedInfo", c.a),
				p = l.a.wrapped(i.a, "SubredditWrapper", c.a),
				b = l.a.div("TextContainer", c.a),
				h = l.a.wrapped(a.a, "TopMeta", c.a);
			t.a = e => o.a.createElement(u, {
				className: e.className
			}, e.subredditName && o.a.createElement(p, null, e.subredditName && o.a.createElement(b, null, e.subredditName)), o.a.createElement(m, null, o.a.createElement(b, null, `${s.fbt._("Commented by",null,{hk:"4Dveap"})}`), o.a.createElement(h, {
				collapsedBecauseCrowdControl: e.comment.collapsedBecauseCrowdControl,
				collapsed: !1,
				comment: e.comment,
				flair: e.flair,
				renderedInOverlay: !1
			})))
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				AuthorLink: "_2jljMb6FK7HnIb15zmm1of",
				authorLink: "_2jljMb6FK7HnIb15zmm1of",
				SubredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				subredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				TextContainer: "_2in6k_0-sFgKVz16hifq03",
				textContainer: "_2in6k_0-sFgKVz16hifq03",
				SubredditIcon: "uCjYZbKNai0INWGwHjoUh",
				subredditIcon: "uCjYZbKNai0INWGwHjoUh",
				Inline: "_2VWXAfRlnHG_4nydI7J4l3",
				inline: "_2VWXAfRlnHG_4nydI7J4l3"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/AuthorLink/index.tsx"),
				a = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				i = n("./src/reddit/components/SubredditIcon/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				c = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less"),
				l = n.n(c),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/lessComponent.tsx");
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = m.a.wrapped(o.a, "AuthorLink", l.a), h = m.a.wrapped(d.a, "Inline", l.a), f = m.a.wrapped(d.a, "SubredditWrapper", l.a), g = m.a.div("TextContainer", l.a), _ = m.a.wrapped(i.b, "SubredditIcon", l.a);
			t.a = e => r.a.createElement(h, null, e.subredditOrProfile && r.a.createElement(f, null, e.subredditOrProfile && r.a.createElement(_, {
				subredditOrProfile: e.subredditOrProfile
			}), e.subredditOrProfile && r.a.createElement(g, null, e.subredditOrProfile.displayText)), p._("posted by", null, {
				hk: "1EuRc2"
			}), e.comment.postAuthor && r.a.createElement(a.b, {
				postOrComment: e.comment,
				author: e.comment.postAuthor
			}, r.a.createElement(b, {
				author: e.comment.postAuthor,
				isUnstyled: !0,
				isAuthorDeleted: e.comment.postAuthor === u.E
			}, `u/${e.comment.postAuthor}`)))
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				IconText: "_6cNM5NdF82ASM5hiBVNN5",
				iconText: "_6cNM5NdF82ASM5hiBVNN5",
				Animate: "_3j98tX1WZapEArV-4rmJe5",
				animate: "_3j98tX1WZapEArV-4rmJe5",
				top: "_3Dr1MoYY5Yv4YhbQFFcks0",
				bottom: "_1GRYNQhMsR-00cWDJcE3UJ",
				bigCircle: "_85rqvRijdIsn3s0j-gUaw",
				midCircle: "RS1g6Gd_W67wwWKSteEB1",
				smallCircle: "lRlGcfTzZ7njZnIUyvhGH",
				play: "_3Kxa8oHGuT_QpP4zIN5jrV",
				blinker: "_20WvB_9deo7bJVi4af1dSS"
			}
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/selectors/chatPost.ts"),
				l = n("./src/reddit/components/CommentsChat/LiveIcon/index.m.less"),
				u = n.n(l);
			const m = e => {
				let {
					className: t,
					postId: n
				} = e;
				const [o, l] = a.a.useState(!1), m = Object(i.e)(e => Object(c.d)(e, {
					postId: n
				})), p = m && o;
				return m ? a.a.createElement(s.a, {
					rootMargin: "20px 0px 20px 0px",
					threshold: .1,
					onChange: e => {
						e.isIntersecting && e.intersectionRatio >= .1 ? o || l(!0) : o && l(!1)
					}
				}, a.a.createElement("div", {
					className: Object(d.a)(u.a.Icon, t)
				}, a.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.top, {
						[u.a.play]: p
					})
				}, a.a.createElement("span", {
					className: u.a.bigCircle
				}), a.a.createElement("span", {
					className: u.a.midCircle
				}), a.a.createElement("span", {
					className: u.a.smallCircle
				})), a.a.createElement("p", {
					className: u.a.IconText
				}, r.fbt._("Live Chat", null, {
					hk: "gyqAe"
				})), a.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.bottom, {
						[u.a.play]: p
					})
				}, a.a.createElement("span", {
					className: u.a.bigCircle
				}), a.a.createElement("span", {
					className: u.a.midCircle
				}), a.a.createElement("span", {
					className: u.a.smallCircle
				})))) : null
			}
		},
		"./src/reddit/components/CommentsLink/index.m.less": function(e, t, n) {
			e.exports = {
				commentsLink: "_1UoeAeSRhOKSNdY_h3iS1O",
				commentIcon: "_3DVrpDrMM9NLT6TlsTUMxC",
				defaultCursorWrapper: "_3m17ICJgx45k_z-t82iVuO",
				link: "_1Hw7tY9pMr-T1F4P1C-xNU",
				text: "FHCV02u6Cp2zYL0fhQPsO",
				commentsText: "_25BV1fTi10_HqCnD195T85"
			}
		},
		"./src/reddit/components/CommentsLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./node_modules/fbt/lib/FbtPublic.js"),
				m = n("./src/lib/prettyPrintNumber/index.ts"),
				p = n("./src/reddit/components/CountAnimation/index.tsx"),
				b = n("./src/reddit/constants/postLayout.ts"),
				h = n("./src/reddit/icons/fonts/Comment/index.tsx"),
				f = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				g = n("./src/reddit/components/CommentsLink/index.m.less"),
				_ = n.n(g);
			const v = () => 0,
				O = e => {
					let t, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: a,
						isChatPost: i,
						isCommentCountAnimation: c,
						modModeEnabled: g,
						numComments: O,
						postId: x,
						shouldShowIcon: E,
						shouldShowText: y,
						text: j,
						type: C
					} = e;
					const k = c && O < f.a,
						I = i ? u.fbt._({
							"*": "{number} messages",
							_1: "1 message"
						}, [u.fbt._plural(O, "number", Object(m.b)(O))], {
							hk: "2wEqSc"
						}) : u.fbt._({
							"*": "{number} comments",
							_1: "1 comment"
						}, [u.fbt._plural(O, "number", Object(m.b)(O))], {
							hk: "1QeOde"
						}),
						S = i ? u.fbt._({
							"*": "messages",
							_1: "message"
						}, [u.fbt._plural(O)], {
							hk: "1mMKLS"
						}) : u.fbt._({
							"*": "comments",
							_1: "comment"
						}, [u.fbt._plural(O)], {
							hk: "2fJpkn"
						});
					t = j || (C === b.g.Compact || g && n ? Object(m.b)(O) : I);
					const w = Object(o.d)(),
						T = Object(s.useCallback)(e => {
							const {
								commentCountChange: t
							} = e.subscribe.data;
							0 !== t && w(Object(l.H)({
								postId: x,
								delta: t
							}))
						}, [w, x]),
						N = Object(s.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "COMMENT_COUNT_UPDATE",
									postID: x
								}
							}
						});
					return r.a.createElement(r.a.Fragment, null, E && r.a.createElement(h.a, {
						className: _.a.commentIcon,
						role: "presentation"
					}), y && r.a.createElement(r.a.Fragment, null, r.a.createElement("span", {
						className: _.a.text
					}, (k || a) && r.a.createElement(p.b, {
						countToUpperBound: O,
						incrementDelta: v,
						initialDelay: v,
						initialDisplayCount: O,
						postId: x,
						shouldDisjointAnimation: !0,
						subsequentRecurringDelay: v,
						featureName: p.a.Comment,
						queryKey: "postCommentCount",
						queryVariables: N.current,
						onDataCB: T,
						isLoadTestOnly: Boolean(a) && !k
					}), !k && t), (!g || !n) && k && r.a.createElement("span", {
						className: Object(d.a)(_.a.text, _.a.commentsText)
					}, S)))
				};
			var x = n("./src/reddit/constants/componentTestIds.ts"),
				E = n("./src/reddit/helpers/path/index.ts"),
				y = n("./src/reddit/hooks/useClickSourceData.ts"),
				j = n("./src/reddit/selectors/chatPost.ts"),
				C = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				k = n("./src/reddit/selectors/experiments/postSeo.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/selectors/user.ts");
			const w = Object(o.b)(() => Object(i.c)({
				isChatPost: j.d,
				isPostSEOEligible: k.e,
				postPermalink: I.F,
				shouldOpenPostInNewTab: S.jb,
				isBlockingInterstitialEnabled: C.b,
				isBlockingInterstitialV2Enabled: C.c
			}));
			t.a = w(e => {
				let {
					className: t,
					hasModPostPerms: n,
					forceOpenInNewTab: s,
					isChatPost: i,
					isCommentPermalink: u,
					isCommentsPage: m,
					isOverlay: p,
					isPostSEOEligible: b,
					modModeEnabled: h,
					numComments: f,
					onClick: g,
					postPermalink: v,
					shouldOpenPostInNewTab: j,
					shouldShowIcon: C = !0,
					shouldShowText: k = !0,
					text: I,
					type: S,
					postId: w,
					isCommentCountAnimation: T,
					isCountAnimShadowTestEnabled: N,
					isBlockingInterstitialEnabled: P,
					isBlockingInterstitialV2Enabled: R
				} = e;
				const A = Object(o.d)(),
					M = m && !u && !b,
					D = u && !p,
					L = Object(y.a)(),
					F = r.a.createElement(O, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: !!N,
						isChatPost: i,
						isCommentCountAnimation: !!T,
						modModeEnabled: h,
						numComments: f,
						postId: w,
						shouldShowIcon: C,
						shouldShowText: k,
						text: I,
						type: S
					});
				return M ? r.a.createElement("div", {
					className: Object(d.a)(_.a.commentsLink, _.a.defaultCursorWrapper, t),
					onClick: g
				}, F) : r.a.createElement(a.a, {
					rel: "nofollow",
					"data-click-id": "comments",
					"data-test-id": x.a,
					className: Object(d.a)(_.a.commentsLink, _.a.link, t),
					target: s || j ? "_blank" : void 0,
					to: D ? Object(E.b)(v) : Object(c.a)(v, !0, L),
					onClick: e => {
						(P || R) && (e.preventDefault(), A(Object(l.Z)(Object(E.b)(v), w))), g && g()
					}
				}, F)
			})
		},
		"./src/reddit/components/CommonAutocompleteDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				autocompleteLabel: "_39qccdns_RvOZZlRIIVGoK",
				locked: "_2WupD4z680kgaOvurMIh3K",
				labelIcon: "_3dK0j9mvmwPub-EQjQEF-f",
				lockIcon: "m15TxfKz9KwlKtTpuUOGU",
				autocompleteInput: "_2DhRYyE3X6UOdxywO4xoas",
				autocompleteInput__no_icon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInputNoIcon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInput__disabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputDisabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputContainer: "_3G7m5yzFmzVctZTxy3ZUkf",
				autocompleteDropdown: "nUeCIjmjHU-llTCBuUdnn",
				autocompleteDropdownItem: "_3eWYFOsdnA9K-Jw8qXFbfH",
				autocompleteDropdownItem__rtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItemRtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItem__icon: "_1x6PJuPScW1xzB8k-WzEN",
				autocompleteDropdownItemIcon: "_1x6PJuPScW1xzB8k-WzEN",
				highlight: "_2cIM3xprCSzGFYnQGsdVSL",
				selected: "_1EEVp702_ABu8mple5Dpfk"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardRow/index.m.less": function(e, t, n) {
			e.exports = {
				row: "_1SJYzo3UAyKEOF7dfuB9mj",
				awardName: "KMxVBNnYo_dcBwZGB9Y7a",
				unfilledAward: "_3s20dmDQOAFnj9VBvMb_K9",
				awardDetail: "_2NA5kHSdCz8PTAq-oiC2lE",
				awardExpiresDetail: "_23IvuOow0OJsmKnkmU_FEX",
				headerRow: "_1NbiD8qa7KncC2IlK9RoSb",
				awardIconImage: "_3sB_KQUJdYFc6cPgCjizd4",
				deleteIcon: "_1Aox5T2z7StzW_M0WfnDTe",
				rightAlign: "_3MpqTEDv3tS3-u-1uNAt6Y",
				createButton: "_3pXwHsShRJ0s12b9e-_gCX",
				emptyIcon: "yy-p6aZDVdPVBPBYMhbEy",
				emptyDetails: "LUZArpcpRdOTEPUDrjKVR",
				awardLoadingContainer: "_2WNYZIJMYIXJIS_IJIIiTe"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less": function(e, t, n) {
			e.exports = {
				awardToggleContainer: "_2E_k43b0N9nhGQKfSvT_c_",
				emptyToggleContainer: "_1lQVQi-D8yElpWeJLbrix0",
				emptyToggleContainerLabel: "_2Porr9EjtYqQt8OhMaCU3h",
				optionalAwardInfo: "ZViyY3IDk7c6MplUKuCKa",
				awardToggleItem: "XwXRf6eWep27jKV1kkNDN",
				awardToggleLabelItem: "_2d9jt8apy5IwNRPdrC_RtG",
				awardIconWrapper: "_3DGDvlViP1uosxrUobijCu",
				awardIcon: "_10ar4v6qlEgLvqEhxk_wyP",
				awardInfoWrapper: "_2LxUe9vOie60H44Rkl5YYd",
				awardToggleItemDisabled: "_1touzuLFgoSGqEcDiLDD00",
				awardTitle: "_1fG-NkjOvo6khgB4qJmizu",
				awardDescription: "_2VABiA5W4pgqWyCK_oV4Hg"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_27C02100EX-RnLoDyL_PYT",
				gildIcon: "_3f4YbBVVbX4YXols-8AmgC",
				infoIcon: "_1HPeb_FxEOzicQ4BuIVonK",
				pageInfo: "_2bEhfADeSjJE-8zKoxjbGy",
				awardToDelete: "dzAx082Iu3F9M7xS-PL80",
				awardToDeleteIcon: "_11ikfBu3qqa0paYAJLQINO"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/constants/gold.ts"),
				m = n("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				p = n("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				h = n("./src/reddit/helpers/trackers/communityAwards.ts"),
				f = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/makeAsync.tsx")),
				g = n("./src/lib/loadWithRetries/index.ts");
			var _ = Object(f.a)({
					getComponent: () => Object(g.a)(() => Promise.all([n.e("AwardCreationModal").then(n.bind(null, "./src/reddit/components/AwardCreationModal/index.tsx"))])).then(e => e[0].default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				v = n("./src/reddit/models/Gold/Award.ts"),
				O = n("./src/reddit/components/ConfirmModal/index.tsx"),
				x = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				E = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				y = n("./src/reddit/components/TrackingHelper/index.tsx"),
				j = n("./src/reddit/icons/fonts/index.tsx"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./node_modules/lodash/times.js"),
				I = n.n(k),
				S = n("./src/lib/classNames/index.ts"),
				w = n("./src/reddit/controls/Button/index.tsx"),
				T = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				N = n("./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts"),
				P = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				R = n("./src/reddit/components/CommunityAwardList/AwardRow/index.m.less"),
				A = n.n(R);
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), D = () => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: A.a.awardName
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyIcon
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			}))), L = e => o.a.createElement("div", {
				className: Object(S.a)(e.className, A.a.awardLoadingContainer)
			}, I()(10, e => o.a.createElement(D, {
				key: e
			}))), F = e => {
				let {
					subredditId: t
				} = e;
				return o.a.createElement("div", {
					className: A.a.headerRow
				}, o.a.createElement("div", {
					className: A.a.awardName
				}, M._("Name", null, {
					hk: "2rgEdc"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Icon", null, {
					hk: "zWzOj"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Coins", null, {
					hk: "2uhz31"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Type", null, {
					hk: "1rYgKO"
				})), Object(N.a)(t) && o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Starts", null, {
					hk: "HW61W"
				})), Object(N.a)(t) && o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Expires", null, {
					hk: "3hS2VX"
				})))
			}, U = e => {
				let {
					date: t
				} = e;
				return o.a.createElement("div", {
					className: A.a.awardExpiresDetail
				}, t && t.toLocaleString())
			}, B = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._({
				"*": "Create up to {quantity} more {coin-price} Coin Awards",
				_1: "Create up to {quantity} more {coin-price} Coin Award"
			}, [M._param("quantity", e.quantity), M._param("coin-price", e.coinPrice), M._plural(e.quantity)], {
				hk: "4nSQI7"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			})))), G = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._("Create a Moderator-Only Award", null, {
				hk: "3aMmTo"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			})))), H = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._("Create an Award", null, {
				hk: "1zGxjw"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			}))));
			class W extends o.a.Component {
				constructor() {
					super(...arguments), this.onDelete = e => {
						e.preventDefault(), this.props.onDelete(this.props.award.id)
					}
				}
				render() {
					const {
						award: e,
						canDelete: t,
						iconUrl: n,
						subredditId: s
					} = this.props, r = Object(N.a)(s), a = e.startsAt ? new Date(e.startsAt) : void 0, i = e.endsAt ? new Date(e.endsAt) : void 0;
					return o.a.createElement("div", {
						className: A.a.row
					}, o.a.createElement("div", {
						className: A.a.awardName
					}, e.name), o.a.createElement("div", {
						className: A.a.awardDetail
					}, o.a.createElement("img", {
						className: A.a.awardIconImage,
						src: n,
						title: e.name
					})), o.a.createElement("div", {
						className: A.a.awardDetail
					}, e.coinPrice || 0), o.a.createElement("div", {
						className: A.a.awardDetail
					}, e.awardType === v.f.Moderator ? M._("Mod only", null, {
						hk: "UxkP0"
					}) : M._("All", null, {
						hk: "2J55F0"
					})), r && [o.a.createElement(U, {
						key: "startDate",
						date: a
					}), o.a.createElement(U, {
						key: "endDate",
						date: i
					})], o.a.createElement(P.a, {
						className: A.a.rightAlign
					}, t && o.a.createElement("a", {
						href: ".",
						onClick: this.onDelete
					}, o.a.createElement(T.b, {
						className: A.a.deleteIcon
					}))))
				}
			}
			var q = W,
				V = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				z = n("./src/reddit/hooks/useTracking.ts"),
				K = n("./src/reddit/selectors/communityAwards.ts"),
				Q = n("./src/reddit/selectors/gold/awardIcon.ts"),
				J = n("./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less"),
				Y = n.n(J);
			const {
				fbt: X
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Z = e => {
				let {
					award: t,
					iconUrl: n
				} = e;
				return o.a.createElement("div", {
					className: Y.a.awardToggleLabelItem
				}, o.a.createElement("div", {
					className: Y.a.awardIconWrapper
				}, o.a.createElement("img", {
					className: Y.a.awardIcon,
					src: n
				})), o.a.createElement("div", {
					className: Y.a.awardInfoWrapper
				}, o.a.createElement("div", {
					className: Y.a.awardTitle
				}, t.name), o.a.createElement("div", {
					className: Y.a.awardDescription
				}, t.description)))
			};
			var $ = e => {
					let {
						subredditOrProfile: t,
						subredditOrProfileId: n,
						moderatorPermissions: s
					} = e;
					const r = Object(a.d)(),
						i = Object(z.a)(),
						c = Object(a.e)(e => Object(K.f)(e, {
							subredditOrProfileId: n
						})),
						l = Object(a.e)(e => Object(K.d)(e, {
							subredditOrProfileId: n
						})),
						u = Object(a.e)(e => Object(Q.b)(e, {
							awards: c,
							minSize: 64
						}));
					if (!c.length) return o.a.createElement("div", {
						className: Y.a.emptyToggleContainer
					}, o.a.createElement("div", {
						className: Y.a.emptyToggleContainerLabel
					}, l ? X._("Pending", null, {
						hk: "1heuFt"
					}) : X._("No Awards currently available for configuration. Please try again later.", null, {
						hk: "3BsFsT"
					})));
					const m = s && s.all;
					return o.a.createElement("div", {
						className: Y.a.awardToggleContainer
					}, o.a.createElement("div", {
						className: Y.a.optionalAwardInfo
					}, X._("Toggle whether these awards are available in your community. If disabled, they cannot be given on any posts or comments.", null, {
						hk: "4e1OPL"
					})), o.a.createElement("div", null, c.map(e => o.a.createElement(V.p, {
						key: e.id,
						on: e.isEnabled,
						forceOn: e.isEnabled,
						className: Object(S.a)(Y.a.awardToggleItem, {
							[Y.a.awardToggleItemDisabled]: !e.isEnabled
						}),
						label: o.a.createElement(Z, {
							award: e,
							iconUrl: u[e.id]
						}),
						onClick: () => (e => {
							const s = e.isEnabled ? d.g : d.h,
								o = e.isEnabled ? h.h : h.i;
							i(o(e, n)), m && r(s(t, e))
						})(e),
						disabled: !m
					}))))
				},
				ee = n("./src/reddit/components/CommunityAwardList/index.m.less"),
				te = n.n(ee);
			const ne = Object(i.c)({
					awardIcons: (e, t) => {
						let {
							subredditOrProfileId: n
						} = t;
						const s = Object(K.e)(e, {
							subredditOrProfileId: n
						});
						return Object(Q.b)(e, {
							awards: s,
							minSize: 32
						})
					},
					awards: K.e,
					awardsPending: K.d,
					communityAwardsDisabled: K.b,
					isAddAwardModalOpen: e => Object(C.a)(e) === u.a,
					isConfirmModalOpen: e => Object(C.a)(e) === u.b
				}),
				se = Object(a.b)(ne, (e, t) => {
					let {
						subredditOrProfileId: n
					} = t;
					return {
						deleteAward: t => e(Object(d.j)(n, t)),
						toggleAddAwardModal: () => e(Object(c.i)(u.a)),
						toggleConfirmModal: () => e(Object(c.i)(u.b)),
						toggleTooltip: t => e(Object(l.h)({
							tooltipId: t
						}))
					}
				}),
				re = {
					awardId: null,
					selectedCoinPrice: void 0,
					selectedModOnly: void 0
				};
			class oe extends o.a.Component {
				constructor(e) {
					super(e), this.openAddAwardModal = (e, t) => {
						Object(b.d)(b.a.AwardCreationFlow), this.props.sendEvent(Object(h.e)()), this.setState({
							selectedCoinPrice: e,
							selectedModOnly: t
						}, this.props.toggleAddAwardModal)
					}, this.openDeleteAwardModal = e => {
						Object(b.d)(b.a.AwardDeletionFlow), this.props.toggleConfirmModal(), this.setState({
							awardId: e
						})
					}, this.confirmDeleteAward = () => {
						const {
							awardId: e
						} = this.state, {
							awards: t
						} = this.props;
						if (this.props.toggleConfirmModal(), e) {
							const n = t.filter(t => t.id === e)[0];
							n && this.props.sendEvent(Object(h.g)(n)), this.props.deleteAward(e), Object(b.b)(b.a.AwardDeletionFlow)
						}
					}, this.renderAwardSlotRow = e => {
						const {
							awardIcons: t,
							awards: n,
							moderatorPermissions: s,
							subredditOrProfileId: r
						} = this.props, a = !(!s || !s.all);
						if (!e.filled && n.length < u.d) return o.a.createElement(B, {
							coinPrice: e.price,
							key: e.price,
							onCreate: () => this.openAddAwardModal(e.price),
							quantity: e.quantity
						});
						if (!e.filled) return null;
						const {
							award: i
						} = e, d = t[i.id];
						return o.a.createElement(q, {
							key: i.id,
							award: i,
							canDelete: a,
							onDelete: this.openDeleteAwardModal,
							iconUrl: d,
							subredditId: r
						})
					}, this.renderAwardToDelete = () => {
						const {
							awards: e
						} = this.props, {
							awardId: t
						} = this.state;
						if (!t) return null;
						const n = e.filter(e => e.id === t)[0];
						return n ? o.a.createElement("div", {
							className: te.a.awardToDelete
						}, o.a.createElement("span", null, s.fbt._("Remove:", null, {
							hk: "1Y4r4o"
						})), o.a.createElement("img", {
							src: n.icon.url,
							className: te.a.awardToDeleteIcon
						}), o.a.createElement("span", null, n.name)) : null
					}, this.renderInfo = () => o.a.createElement("div", {
						className: te.a.pageInfo
					}, o.a.createElement(j.a, {
						name: "info",
						className: te.a.infoIcon
					}), o.a.createElement("p", null, s.fbt._("Community Awards are unique to each community, and members can give them to each other. Moderators can design and name the Awards however they want.", null, {
						hk: "1mzX5Y"
					})), o.a.createElement("p", null, s.fbt._("A portion of Coins from Community Award purchases will be deposited to the communitys Coin balance. Moderators can use Coins from that balance to reward members with Mod Awards. The Coin balance is shown only to moderators in the communitys sidebar", null, {
						hk: "2TVMDb"
					}))), this.state = re
				}
				renderAwardsList() {
					const {
						awards: e,
						awardsPending: t,
						moderatorPermissions: n,
						subredditOrProfileId: s
					} = this.props;
					if (t) return o.a.createElement(L, null);
					const r = Object(p.a)(s),
						a = n && n.all,
						i = this.getAwardSlots().filter(e => a && !r || e.filled),
						d = e.filter(e => e.awardType === v.f.Moderator),
						c = e.length < u.d && d.length < u.e && a && !r;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(F, {
						subredditId: s
					}), r && o.a.createElement(H, {
						onCreate: () => this.openAddAwardModal()
					}), i.map(this.renderAwardSlotRow), c && o.a.createElement(G, {
						onCreate: () => this.openAddAwardModal(void 0, !0)
					}), this.renderInfo())
				}
				getAwardSlots() {
					const {
						awards: e
					} = this.props, t = Object(v.l)(e), n = e => e.filled && e.award.awardType === v.f.Moderator;
					return t.sort((e, t) => n(e) && !n(t) ? 1 : n(t) && !n(e) ? -1 : e.price !== t.price ? e.price - t.price : e.filled && !t.filled ? -1 : (t.filled && e.filled, 1))
				}
				render() {
					const {
						communityAwardsDisabled: e,
						isAddAwardModalOpen: t,
						isConfirmModalOpen: n,
						moderatorPermissions: r,
						subredditOrProfile: a,
						subredditOrProfileId: i,
						toggleAddAwardModal: d,
						toggleConfirmModal: c
					} = this.props, {
						awardId: l,
						selectedCoinPrice: u,
						selectedModOnly: p
					} = this.state, h = a.isNSFW || e;
					return o.a.createElement(o.a.Fragment, null, Object(m.a)(a) && o.a.createElement(E.a, {
						className: te.a.contentContainer
					}, o.a.createElement(E.b, null, s.fbt._("Community Awards", null, {
						hk: "lraSi"
					})), h ? this.renderBlacklistedView() : this.renderAwardsList()), o.a.createElement(E.a, {
						className: te.a.contentContainer
					}, o.a.createElement(E.b, null, s.fbt._("Enable/Disable Awards", null, {
						hk: "1IRmfG"
					})), o.a.createElement($, {
						subredditOrProfile: a,
						subredditOrProfileId: i,
						moderatorPermissions: r
					})), t && o.a.createElement(_, {
						defaultCoinPrice: u,
						defaultModOnly: p,
						subredditId: i,
						toggleModal: () => {
							d(), Object(b.b)(b.a.AwardCreationFlow)
						}
					}), n && l && o.a.createElement(O.a, {
						acceptText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						cancelText: s.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: s.fbt._("Delete Award", null, {
							hk: "7q2D7"
						}),
						message: s.fbt._("Deleting an Award will remove the option for members of your community to give the Award. Existing Awards will remain on the posts and comments that have received them.", null, {
							hk: "3tX5sQ"
						}),
						onAccept: this.confirmDeleteAward,
						onCancel: c,
						onClose: c,
						onOverlayClick: c,
						withOverlay: !0
					}, this.renderAwardToDelete()))
				}
				renderBlacklistedView() {
					return o.a.createElement(x.c, {
						text: s.fbt._("Community Awards have been disabled for this community.", null, {
							hk: "2g21s6"
						})
					}, o.a.createElement(j.a, {
						name: "award",
						className: te.a.gildIcon
					}))
				}
			}
			t.a = se(Object(y.c)(oe))
		},
		"./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less": function(e, t, n) {
			e.exports = {
				countrySiteForm: "_3EwDpZ19gPFB461uuy7iGL",
				dropdownContainer: "_3XPnIpveWFDgMhBmnMyd9e",
				innerFlexboxContainer: "_1tHvQJ3zvN2gjV9HDwzxRj"
			}
		},
		"./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-CommunitySettings-ModPnSettings",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-CommunitySettings-ModPnSettings").then(n.bind(null, "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CommunitySettings/components.m.less": function(e, t, n) {
			e.exports = {
				InputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				inputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				FormContainer: "_37sNfY6fNJVPqyQXOHlg3K",
				formContainer: "_37sNfY6fNJVPqyQXOHlg3K"
			}
		},
		"./src/reddit/components/CommunitySettings/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "l", (function() {
				return c
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = 500,
				o = 100,
				a = 5e3,
				i = 0,
				d = 1440,
				c = 36600,
				l = 1e9,
				u = {
					disabled: s.fbt._("Disabled", null, {
						hk: "1KaunG"
					}).toString(),
					modonly: s.fbt._("Mods only", null, {
						hk: "2yA6R8"
					}).toString(),
					anyone: s.fbt._("Anyone", null, {
						hk: "4gPsEy"
					}).toString()
				},
				m = [s.fbt._("Wiki is disabled for all users except mods", null, {
					hk: "2loUiE"
				}).toString(), s.fbt._("Only mods, approved wiki contributors, or those on a page's edit list may edit", null, {
					hk: "1WUeVN"
				}).toString(), s.fbt._("Anyone who can submit to the community may edit", null, {
					hk: "3hxotT"
				}).toString()],
				p = {
					any: s.fbt._("Any", null, {
						hk: "hVUT8"
					}),
					link: s.fbt._("Links only", null, {
						hk: "3upkyk"
					}),
					self: s.fbt._("Text posts only", null, {
						hk: "1VZn8Y"
					})
				},
				b = [s.fbt._("Any post type is allowed", null, {
					hk: "1rOxtJ"
				}), s.fbt._("Only links to external sites are allowed", null, {
					hk: "OJQdj"
				}), s.fbt._("Only text posts are allowed", null, {
					hk: "3q3v14"
				})],
				h = {
					mods: s.fbt._("Moderators", null, {
						hk: "2rrkiT"
					}),
					anyone: s.fbt._("Anyone", null, {
						hk: "Xp8Fs"
					})
				},
				f = {
					low: s.fbt._("Low", null, {
						hk: "4k3iTe"
					}),
					high: s.fbt._("High (default)", null, {
						hk: "2GOHsH"
					}),
					all: s.fbt._("All", null, {
						hk: "gl6gc"
					})
				},
				g = {
					low: s.fbt._("Low (default)", null, {
						hk: "2tqJd7"
					}),
					high: s.fbt._("High", null, {
						hk: "ABfkc"
					}),
					all: s.fbt._("All", null, {
						hk: "3bPDOM"
					})
				},
				_ = {
					nullValue: s.fbt._("none (recommended)", null, {
						hk: "2FMwQH"
					}),
					confidence: s.fbt._("best", null, {
						hk: "13cLYH"
					}),
					old: s.fbt._("old", null, {
						hk: "3V0QN8"
					}),
					top: s.fbt._("top", null, {
						hk: "40R5FY"
					}),
					qa: s.fbt._("q&a", null, {
						hk: "3cm6YL"
					}),
					live: s.fbt._("live (beta)", null, {
						hk: "2EVYAd"
					}),
					controversial: s.fbt._("controversial", null, {
						hk: "1uFV5F"
					}),
					new: s.fbt._("new", null, {
						hk: "39TZi6"
					})
				}
		},
		"./src/reddit/components/CommunitySettings/index.m.less": function(e, t, n) {
			e.exports = {
				pageTitle: "_1YwfovPToau7hk7kk7VjvV",
				communityTopicsHelpLink: "_2Tzl9XrmQzUn94gYHRUYMI",
				welcomeMessageHelpLink: "_3-XV8EhlxRlIzoFKUI6gmQ",
				fullWidthTextContainer: "_2SnK_8NMPSqmFfF-es2GGa",
				subtextContainer: "_2sWG233wmE9wNycTEyRHRN",
				sectionHeadingFollowedBySubtext: "_2znhaJWCK6NY6bIPtrS2sx",
				sectionSubtext: "_2gZA-d4bPf-v-QStyl39CP",
				subtextLink: "_3m7YXm3a55mNltI6wwKkal",
				numCommunityTopicsSelected: "Ty_datAAaSbn2GX5-1O58",
				welcomeMessageEnabled: "_21a0DjKnRl3i1ItjJ8cSyf",
				geoForm: "_1QCMnCbDgm4T-QmBwOFkQ7",
				geoText: "lhgqy5yEx-4vqJhuaRIW_",
				geoInput: "_20j3hiEorqFwMLxftPVQG1",
				contentTag: "_26M_DkGPAeiqHaMshbczhg",
				contentTagColumn: "_2lbeaHzGFIYy6MK6YfLqrd",
				ratingAudience: "_3HR2r8RW7cFhNSKPiAT6VO",
				ratingDescription: "_3Wy4OBl1ksNXzpoeV4dvli",
				ratingReason: "_254fRg3JX4apEtqVAAXfbm",
				promptText: "RqDOw50ARYjx_TliwJR0l",
				surveyButton: "_7aZGYzh7hj5VihV4LcNzP",
				previewButton: "_2OmdANJm2jP7a_6G2-JCqg",
				disabled: "_3DyIlr3eqm1Pq3T9Jx0Kgx",
				rangeSetting: "_3BfcidCIw4ZNn2i2jR7fKT",
				noMarginHeading: "kt9ucKpVrHFhY-_xvYiLF",
				flexSpacer: "_2urERRC5ZgXlBwG8augYFu",
				labelWithNewTag: "_2tw6jmSgf4-SvF7sT8DIwT",
				labelNewTag: "_1W9XvmIuDMXygCmP-t8uxn"
			}
		},
		"./src/reddit/components/CommunitySettings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/pages/shared.ts"),
				u = n("./src/reddit/actions/subredditSettings.ts"),
				m = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/lib/makeGqlRequest/index.ts"),
				b = (n("./src/redditGQL/operations/GetSubredditWelcomeMessage.json"), n("./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json"));
			const h = e => {
				if (e) return {
					...e
				}
			};
			const f = (e, t, n) => async (s, r, o) => {
				let {
					gqlContext: a
				} = o;
				const i = {
						subredditId: e,
						isWelcomeMessageEnabled: t,
						welcomeMessage: {
							markdown: n
						}
					},
					d = await ((e, t) => Object(p.a)(e, {
						...b,
						variables: t
					}))(a(), {
						input: i
					});
				if (d.ok) {
					const t = (e => {
						var t, n;
						const s = null === (n = null === (t = null == e ? void 0 : e.data.updateSubredditSettings) || void 0 === t ? void 0 : t.subreddit) || void 0 === n ? void 0 : n.welcomeMessage;
						return h(s)
					})(d.body);
					t && s(g({
						subredditId: e,
						welcomeMessage: t
					}))
				}
			}, g = Object(m.a)("SUBREDDIT_WELCOME_MESSAGE__LOADED");
			var _ = n("./src/reddit/actions/tags/index.ts"),
				v = n("./src/lib/lessComponent.tsx"),
				O = n("./src/reddit/controls/FormFields/index.tsx"),
				x = n("./src/reddit/components/CommunitySettings/components.m.less"),
				E = n.n(x);
			const y = v.a.wrapped(O.b, "InputField", E.a),
				j = v.a.div("FormContainer", E.a);
			var C = n("./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx"),
				k = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				I = n("./src/reddit/components/TrackingHelper/index.tsx"),
				S = n("./src/reddit/controls/Button/index.tsx"),
				w = n("./src/reddit/featureFlags/index.ts"),
				T = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				N = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				P = n("./src/reddit/models/Tags/index.ts"),
				R = n("./src/reddit/selectors/chatPost.ts"),
				A = n("./src/reddit/selectors/streamingModSettings.ts"),
				M = n("./src/reddit/selectors/subreddit.ts");
			var D = n("./src/reddit/selectors/subredditSettings.ts"),
				L = n("./src/reddit/selectors/tags.ts"),
				F = n("./src/reddit/selectors/user.ts"),
				U = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				B = n("./src/reddit/selectors/experiments/countrySites.ts"),
				G = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				H = n("./node_modules/fbt/lib/FbtPublic.js"),
				W = n("./src/lib/classNames/index.ts"),
				q = n("./src/reddit/components/CommunityTopics/index.tsx"),
				V = n("./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx"),
				z = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx"),
				K = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx"),
				Q = n("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				J = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				Y = n("./src/reddit/components/SubredditCreationModal/index.tsx"),
				X = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				Z = n("./src/reddit/controls/RadioInput/index.tsx"),
				$ = n("./src/reddit/models/Flair/index.ts"),
				ee = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				te = n("./src/reddit/components/CommunitySettings/helpers.ts"),
				ne = n("./src/reddit/actions/toaster.ts"),
				se = n("./src/reddit/components/GeoForm/GeoForm.tsx"),
				re = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				oe = n("./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts"),
				ae = n("./src/reddit/helpers/localStorage/index.ts"),
				ie = n("./src/reddit/hooks/useGqlContext.ts"),
				de = n("./src/reddit/models/Toast/index.ts"),
				ce = [{
					value: "Global",
					countryCode: "*",
					icon: ""
				}, {
					value: "United States",
					countryCode: "US",
					icon: ""
				}, {
					value: "Argentina",
					countryCode: "AR",
					icon: ""
				}, {
					value: "Australia",
					countryCode: "AU",
					icon: ""
				}, {
					value: "Austria",
					countryCode: "AT",
					icon: ""
				}, {
					value: "Belgium",
					countryCode: "BE",
					icon: ""
				}, {
					value: "Brazil",
					countryCode: "BR",
					icon: ""
				}, {
					value: "Canada",
					countryCode: "CA",
					icon: ""
				}, {
					value: "Chile",
					countryCode: "CL",
					icon: ""
				}, {
					value: "Colombia",
					countryCode: "CO",
					icon: ""
				}, {
					value: "Czech Republic",
					countryCode: "CZ",
					icon: ""
				}, {
					value: "Denmark",
					countryCode: "DK",
					icon: ""
				}, {
					value: "Egypt",
					countryCode: "EG",
					icon: ""
				}, {
					value: "Finland",
					countryCode: "FI",
					icon: ""
				}, {
					value: "France",
					countryCode: "FR",
					icon: ""
				}, {
					value: "Germany",
					countryCode: "DE",
					icon: ""
				}, {
					value: "Greece",
					countryCode: "GR",
					icon: ""
				}, {
					value: "Hungary",
					countryCode: "HU",
					icon: ""
				}, {
					value: "India",
					countryCode: "IN",
					icon: ""
				}, {
					value: "Indonesia",
					countryCode: "ID",
					icon: ""
				}, {
					value: "Ireland",
					countryCode: "IE",
					icon: ""
				}, {
					value: "Italy",
					countryCode: "IT",
					icon: ""
				}, {
					value: "Japan",
					countryCode: "JP",
					icon: ""
				}, {
					value: "Korea, Republic of",
					countryCode: "KR",
					icon: ""
				}, {
					value: "Malaysia",
					countryCode: "MY",
					icon: ""
				}, {
					value: "Mexico",
					countryCode: "MX",
					icon: ""
				}, {
					value: "Netherlands",
					countryCode: "NL",
					icon: ""
				}, {
					value: "New Zealand",
					countryCode: "NZ",
					icon: ""
				}, {
					value: "Nigeria",
					countryCode: "NG",
					icon: ""
				}, {
					value: "Norway",
					countryCode: "NO",
					icon: ""
				}, {
					value: "Peru",
					countryCode: "PE",
					icon: ""
				}, {
					value: "Philippines",
					countryCode: "PH",
					icon: ""
				}, {
					value: "Poland",
					countryCode: "PL",
					icon: ""
				}, {
					value: "Portugal",
					countryCode: "PT",
					icon: ""
				}, {
					value: "Romania",
					countryCode: "RO",
					icon: ""
				}, {
					value: "Russia",
					countryCode: "RU",
					icon: ""
				}, {
					value: "Saudi Arabia",
					countryCode: "SA",
					icon: ""
				}, {
					value: "Singapore",
					countryCode: "SG",
					icon: ""
				}, {
					value: "South Africa",
					countryCode: "ZA",
					icon: ""
				}, {
					value: "Spain",
					countryCode: "ES",
					icon: ""
				}, {
					value: "Sweden",
					countryCode: "SE",
					icon: ""
				}, {
					value: "Switzerland",
					countryCode: "CH",
					icon: ""
				}, {
					value: "Thailand",
					countryCode: "TH",
					icon: ""
				}, {
					value: "Turkey",
					countryCode: "TR",
					icon: ""
				}, {
					value: "United Arab Emirates",
					countryCode: "AE",
					icon: ""
				}, {
					value: "United Kingdom",
					countryCode: "UK",
					icon: ""
				}, {
					value: "Vietnam",
					countryCode: "VN",
					icon: ""
				}];
			var le = [Object.freeze({
					isoCode: "",
					displayName: "Other",
					englishName: "Other",
					rtl: !1
				}), Object.freeze({
					isoCode: "af",
					displayName: "Afrikaans",
					englishName: "Afrikaans",
					rtl: !1
				}), Object.freeze({
					isoCode: "az",
					displayName: "Azrbaycan",
					englishName: "Azerbaijani",
					rtl: !1
				}), Object.freeze({
					isoCode: "id",
					displayName: "Bahasa Indonesia",
					englishName: "Indonesian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ms",
					displayName: "Bahasa Melayu",
					englishName: "Malay",
					rtl: !1
				}), Object.freeze({
					isoCode: "bs",
					displayName: "Bosanski",
					englishName: "Bosnian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ca",
					displayName: "Catal",
					englishName: "Catalan",
					rtl: !1
				}), Object.freeze({
					isoCode: "cs",
					displayName: "etina",
					englishName: "Czech",
					rtl: !1
				}), Object.freeze({
					isoCode: "da",
					displayName: "Dansk",
					englishName: "Danish",
					rtl: !1
				}), Object.freeze({
					isoCode: "de",
					displayName: "Deutsch",
					englishName: "German",
					rtl: !1
				}), Object.freeze({
					isoCode: "et",
					displayName: "Eesti",
					englishName: "Estonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "en",
					displayName: "English",
					englishName: "English",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-IN",
					displayName: "English (India)",
					englishName: "English (India)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-GB",
					displayName: "English (UK)",
					englishName: "English (UK)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-US",
					displayName: "English (US)",
					englishName: "English (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-ES",
					displayName: "Espaol (Espaa)",
					englishName: "Spanish (Spain)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es",
					displayName: "Espaol (Latinoamrica)",
					englishName: "Spanish (Latam)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-US",
					displayName: "Espaol (US)",
					englishName: "Spanish (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "eu",
					displayName: "Euskara",
					englishName: "Basque",
					rtl: !1
				}), Object.freeze({
					isoCode: "tl",
					displayName: "Filipino",
					englishName: "Filipino",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr",
					displayName: "Franais",
					englishName: "French",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr-CA",
					displayName: "Franais (Canada)",
					englishName: "French Canada",
					rtl: !1
				}), Object.freeze({
					isoCode: "gl",
					displayName: "Galego",
					englishName: "Galician",
					rtl: !1
				}), Object.freeze({
					isoCode: "hr",
					displayName: "Hrvatski",
					englishName: "Croatian",
					rtl: !1
				}), Object.freeze({
					isoCode: "zu",
					displayName: "IsiZulu",
					englishName: "Zulu",
					rtl: !1
				}), Object.freeze({
					isoCode: "is",
					displayName: "slenska",
					englishName: "Icelandic",
					rtl: !1
				}), Object.freeze({
					isoCode: "it",
					displayName: "Italiano",
					englishName: "Italian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sw",
					displayName: "Kiswahili",
					englishName: "Swahili",
					rtl: !1
				}), Object.freeze({
					isoCode: "lv",
					displayName: "Latvieu",
					englishName: "Latvian",
					rtl: !1
				}), Object.freeze({
					isoCode: "lt",
					displayName: "Lietuvi",
					englishName: "Lithuanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hu",
					displayName: "Magyar",
					englishName: "Hungarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "nl",
					displayName: "Nederlands",
					englishName: "Dutch",
					rtl: !1
				}), Object.freeze({
					isoCode: "no",
					displayName: "Norsk",
					englishName: "Norwegian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uz",
					displayName: "Ozbek",
					englishName: "Uzbek",
					rtl: !1
				}), Object.freeze({
					isoCode: "pl",
					displayName: "Polski",
					englishName: "Polish",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt",
					displayName: "Portugus",
					englishName: "Portugues",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt-BR",
					displayName: "Portugus (Brasil)",
					englishName: "Portugues (Brazil)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ro",
					displayName: "Romn",
					englishName: "Romanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sq",
					displayName: "Shqip",
					englishName: "Sango",
					rtl: !1
				}), Object.freeze({
					isoCode: "sk",
					displayName: "Slovenina",
					englishName: "Slovak",
					rtl: !1
				}), Object.freeze({
					isoCode: "sl",
					displayName: "Slovenina",
					englishName: "Slovenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "Srpski",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "fi",
					displayName: "Suomi",
					englishName: "Finnish",
					rtl: !1
				}), Object.freeze({
					isoCode: "sv",
					displayName: "Svenska",
					englishName: "Swedish",
					rtl: !1
				}), Object.freeze({
					isoCode: "vi",
					displayName: "Ting Vit",
					englishName: "Vietnamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "tr",
					displayName: "Trke",
					englishName: "Turkish",
					rtl: !1
				}), Object.freeze({
					isoCode: "el",
					displayName: "",
					englishName: "Greek, Modern",
					rtl: !1
				}), Object.freeze({
					isoCode: "be",
					displayName: "",
					englishName: "Belarusian",
					rtl: !1
				}), Object.freeze({
					isoCode: "bg",
					displayName: "",
					englishName: "Bulgarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ky",
					displayName: "",
					englishName: "Kirghiz",
					rtl: !1
				}), Object.freeze({
					isoCode: "kk",
					displayName: " ",
					englishName: "Kazakh",
					rtl: !1
				}), Object.freeze({
					isoCode: "mk",
					displayName: "",
					englishName: "Macedonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "mn",
					displayName: "",
					englishName: "Mongolian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ru",
					displayName: "",
					englishName: "Russian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uk",
					displayName: "",
					englishName: "Ukrainian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ka",
					displayName: "",
					englishName: "Georgian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hy",
					displayName: "",
					englishName: "Armenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "he",
					displayName: "",
					englishName: "Hebrew",
					rtl: !0
				}), Object.freeze({
					isoCode: "ur",
					displayName: "",
					englishName: "Urdu",
					rtl: !0
				}), Object.freeze({
					isoCode: "ar",
					displayName: "",
					englishName: "Arabic",
					rtl: !0
				}), Object.freeze({
					isoCode: "fa",
					displayName: "",
					englishName: "Persian",
					rtl: !0
				}), Object.freeze({
					isoCode: "am",
					displayName: "",
					englishName: "Amharic",
					rtl: !1
				}), Object.freeze({
					isoCode: "ne",
					displayName: "",
					englishName: "Nepali",
					rtl: !1
				}), Object.freeze({
					isoCode: "mr",
					displayName: "",
					englishName: "Marathi",
					rtl: !1
				}), Object.freeze({
					isoCode: "hi",
					displayName: "",
					englishName: "Hindi",
					rtl: !1
				}), Object.freeze({
					isoCode: "as",
					displayName: "",
					englishName: "Assamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "bn",
					displayName: "",
					englishName: "Bengali",
					rtl: !1
				}), Object.freeze({
					isoCode: "pa",
					displayName: "",
					englishName: "Punjabi",
					rtl: !1
				}), Object.freeze({
					isoCode: "gu",
					displayName: "",
					englishName: "Gujarati",
					rtl: !1
				}), Object.freeze({
					isoCode: "or",
					displayName: "",
					englishName: "Oriya",
					rtl: !1
				}), Object.freeze({
					isoCode: "ta",
					displayName: "",
					englishName: "Tamil",
					rtl: !1
				}), Object.freeze({
					isoCode: "te",
					displayName: "",
					englishName: "Telugu",
					rtl: !1
				}), Object.freeze({
					isoCode: "kn",
					displayName: "",
					englishName: "Kannada",
					rtl: !1
				}), Object.freeze({
					isoCode: "ml",
					displayName: "",
					englishName: "Malayalam",
					rtl: !1
				}), Object.freeze({
					isoCode: "si",
					displayName: "",
					englishName: "Sinhala",
					rtl: !1
				}), Object.freeze({
					isoCode: "th",
					displayName: "",
					englishName: "Thai",
					rtl: !1
				}), Object.freeze({
					isoCode: "lo",
					displayName: "",
					englishName: "Lao",
					rtl: !1
				}), Object.freeze({
					isoCode: "my",
					displayName: "",
					englishName: "Burmese",
					rtl: !1
				}), Object.freeze({
					isoCode: "km",
					displayName: "",
					englishName: "Central Khmer",
					rtl: !1
				}), Object.freeze({
					isoCode: "ko",
					displayName: "",
					englishName: "Korean",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-CN",
					displayName: " ()",
					englishName: "Chinese (Simplified)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh",
					displayName: " ()",
					englishName: "Chinese (Traditional)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-HK",
					displayName: " ()",
					englishName: "Chinese (Hong Kong)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ja",
					displayName: "",
					englishName: "Japanese",
					rtl: !1
				})],
				ue = n("./node_modules/uuid/v4.js"),
				me = n.n(ue),
				pe = n("./src/lib/humanizeDate/index.ts"),
				be = n("./src/reddit/constants/keycodes.ts"),
				he = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				fe = n("./src/reddit/components/CommonAutocompleteDropdown/index.m.less"),
				ge = n.n(fe);

			function _e(e) {
				const {
					icons: t = !0,
					id: n,
					items: s,
					currentIndex: r,
					selectValue: i
				} = e, d = Object(o.useRef)(null);
				return Object(o.useEffect)(() => {
					var e;
					let t = 30 * r;
					r > 10 && (t += 120), d && (null === (e = d.current) || void 0 === e || e.scrollTo({
						top: t
					}))
				}, [r]), a.a.createElement("ul", {
					className: ge.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${n}`,
					"data-testid": `autocomplete-dropdown-${n}`,
					ref: d
				}, s.map((e, n) => a.a.createElement("li", {
					onClick: () => i(n),
					key: `${n}`,
					className: Object(W.a)({
						[ge.a.highlight]: n === r
					}, ge.a.autocompleteDropdownItem, {
						[ge.a.autocompleteDropdownItem__rtl]: e.rtl
					})
				}, t && e.icon && a.a.createElement("span", {
					role: "img",
					"aria-label": e.value,
					className: ge.a.autocompleteDropdownItem__icon
				}, e.icon), e.value)))
			}
			const ve = (e, t) => t.filter(t => 0 === t.value.toLowerCase().indexOf(e.toLocaleLowerCase()));

			function Oe(e) {
				var t, n;
				const {
					className: s,
					customClickEvent: r,
					disabled: i,
					defaultIcon: d,
					icons: c = !1,
					initialItemIndex: l,
					listItems: u,
					locked: m = !1,
					placeholderText: p,
					sessionId: b,
					setSelectedParent: h
				} = e, [f, g] = Object(o.useState)(l), [_, v] = Object(o.useState)(u), [O, x] = Object(o.useState)(!0), [E, y] = Object(o.useState)((null === (t = u[l]) || void 0 === t ? void 0 : t.value) || ""), j = `autocomplete-input-${b}`, C = Object(o.useRef)(), k = (e, t) => {
					m || (x(!0), !t && e > -1 && (e = u.findIndex(t => _[e].key === t.key)), g(e), y(e > -1 && u[e].value || ""), h(e), v(u))
				};
				return Object(o.useEffect)(() => {
					var e;
					const t = function(e) {
						if (C && C.current) {
							C.current.contains(e.target) || x(!0)
						}
					};
					return g(l), y((null === (e = u[l]) || void 0 === e ? void 0 : e.value) || ""), document.addEventListener("click", t), () => document.removeEventListener("click", t)
				}, [l, u]), a.a.createElement("div", {
					className: ge.a.autocompleteInputContainer,
					ref: C
				}, c && a.a.createElement("label", {
					className: ge.a.autocompleteLabel,
					htmlFor: j
				}, (null === (n = _[f]) || void 0 === n ? void 0 : n.icon) || d), i ? a.a.createElement("span", {
					className: Object(W.a)(ge.a.autocompleteInput, ge.a.autocompleteInput__disabled, s)
				}, -1 !== l && u[l].value) : a.a.createElement("input", {
					id: `autocomplete-input-${b}`,
					"data-testid": `autocomplete-input-${b}`,
					className: Object(W.a)(ge.a.autocompleteInput, s, !c && ge.a.autocompleteInput__no_icon),
					name: j,
					value: E,
					placeholder: p,
					onChange: e => {
						m || (-1 !== f && (g(-1), h(-1)), y(e.currentTarget.value), v(ve(e.currentTarget.value, u)))
					},
					onKeyDown: e => {
						if (m) return;
						let t = -1;
						const n = _.length > 0;
						x(!1), n && e.key === be.b.ArrowDown ? (t = Math.min(f + 1, _.length - 1), g(t), h(-1), t > -1 && t < _.length && y(_[t].value)) : n && e.key === be.b.ArrowUp ? (t = Math.max(f - 1, -1), g(t), h(-1), t > -1 && t < _.length ? y(_[t].value) : y("")) : n && e.key === be.b.Enter ? (e.preventDefault(), f > -1 && f < _.length ? k(f, !1) : 1 === _.length && k(0, !1)) : e.key === be.b.Backspace ? h(-1) : e.key === be.b.Escape ? (x(!0), l > -1 && ("" !== E && k(l, !0), "" === E && k(-1, !0))) : e.key === be.b.Tab && (x(!0), -1 !== f ? k(f, !1) : ("" !== E && k(l, !0), "" === E && k(-1, !0)))
					},
					onClick: () => {
						x(!1), r()
					},
					onFocus: () => {
						x(!1)
					}
				}), m && a.a.createElement("span", {
					className: ge.a.locked
				}, a.a.createElement(he.a, {
					className: ge.a.lockIcon
				})), m || i || O || !_.length ? null : a.a.createElement(_e, {
					id: b,
					items: _,
					currentIndex: f,
					selectValue: e => (e => {
						k(e, !1)
					})(e)
				}))
			}
			var xe, Ee = n("./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less"),
				ye = n.n(Ee);
			! function(e) {
				e[e.CountryForm = 0] = "CountryForm", e[e.LanguageForm = 1] = "LanguageForm"
			}(xe || (xe = {}));
			var je = Object(I.c)((function(e) {
					const {
						defaultIcon: t = "",
						formType: n,
						icons: s = !0,
						initialSubredditCountrySite: r,
						inputClassName: d,
						placeholderText: c,
						subredditId: l,
						listItems: u
					} = e, m = n === xe.CountryForm, p = m ? "countryCode" : "languageCode", b = Object(i.d)();
					let h = r && r[p] || "";
					m && (h = h.toUpperCase());
					const [f] = Object(o.useState)(() => me()()), g = r && !(null == r ? void 0 : r.isCountrySiteEditable) || !1, _ = m ? "country" : "language", v = r && m ? r.countryCode : (null == r ? void 0 : r.languageCode) || "";
					return a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
						className: ye.a.countrySiteForm
					}, a.a.createElement("div", {
						className: ye.a.dropdownContainer
					}, a.a.createElement(Oe, {
						className: d,
						defaultIcon: t,
						disabled: g,
						icons: s,
						initialItemIndex: (() => h ? u.findIndex(e => h.toUpperCase() === e.key.toUpperCase()) : -1)(),
						listItems: u,
						locked: g,
						placeholderText: c,
						sessionId: f,
						setSelectedParent: e => (e => {
							if (-1 !== e) {
								let t = u[e].code,
									n = r && r.languageCode || "";
								m || (t = r && r.countryCode || "", n = u[e].code), b(Object(U.g)({
									subredditId: l,
									subredditCountrySite: {
										countryCode: t,
										languageCode: n,
										isCountrySiteEditable: (null == r ? void 0 : r.isCountrySiteEditable) || !0,
										modMigrationAt: (null == r ? void 0 : r.modMigrationAt) || void 0
									}
								}))
							}
						})(e),
						customClickEvent: () => e.sendEvent(Object(T.a)(_, v))
					})), g && r && a.a.createElement(J.n, null, H.fbt._("This setting was saved by a mod on {modMigrationDate} and cant be changed", [H.fbt._param("modMigrationDate", (e => {
						if (!e || !e.modMigrationAt) return "";
						const t = Date.parse(e.modMigrationAt);
						return Object(pe.a)(t / 1e3, {
							showDay: !0
						})
					})(r))], {
						hk: "3OWLnm"
					}))))
				})),
				Ce = n("./src/reddit/components/CommunitySettings/index.m.less"),
				ke = n.n(Ce);

			function Ie(e) {
				var t;
				const {
					initialPlace: n,
					initialSubredditCountrySite: s,
					subredditId: r,
					subredditCountryEditEnabled: d = !1,
					subredditLanguageEditEnabled: c = !1,
					update: l
				} = e, u = Object(ie.a)(), m = Object(i.d)(), [p, b] = Object(o.useState)(n), [h, f] = Object(o.useState)(!1), [g, _] = Object(o.useState)(!0);
				return Object(o.useEffect)(() => {
					_(Object(ae.F)("location")), Object(ae.Hb)("location")
				}, []), a.a.createElement(a.a.Fragment, null, a.a.createElement(Q.a, {
					className: ke.a.noMarginHeading
				}, H.fbt._("Community Location and main language", null, {
					hk: "3qWqzm"
				})), a.a.createElement(J.n, null, H.fbt._("Adding a location helps your community show up in seach results and recommendations and helps local redditors find it easier.", null, {
					hk: "3EuMyx"
				})), a.a.createElement("div", {
					className: ke.a.flexSpacer
				}), c && a.a.createElement(J.l, {
					label: a.a.createElement(a.a.Fragment, null, H.fbt._("Language", null, {
						hk: "4iQFeH"
					}), !g && a.a.createElement(re.a, null)),
					textContainerClassName: Object(W.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, a.a.createElement(je, {
					defaultIcon: "",
					icons: !1,
					formType: xe.LanguageForm,
					initialSubredditCountrySite: s,
					inputClassName: ke.a.autocompleteInput,
					listItems: Array.from(le, e => ({
						code: e.isoCode,
						key: e.isoCode,
						icon: "",
						value: e.displayName,
						rtl: e.rtl
					})),
					placeholderText: H.fbt._("Type to search for a language", null, {
						hk: "4dZ6Zv"
					}),
					subredditId: r
				})), d && a.a.createElement(J.l, {
					label: a.a.createElement(a.a.Fragment, null, H.fbt._("Country", null, {
						hk: "1tNtsz"
					}), !g && a.a.createElement(re.a, null)),
					textContainerClassName: Object(W.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, a.a.createElement(je, {
					formType: xe.CountryForm,
					initialSubredditCountrySite: s,
					inputClassName: ke.a.autocompleteInput,
					listItems: Array.from(ce, e => ({
						code: e.countryCode || "",
						key: e.countryCode || "",
						icon: e.icon,
						value: e.value
					})),
					placeholderText: H.fbt._("Type to search for a country", null, {
						hk: "51VKS"
					}),
					subredditId: r
				})), a.a.createElement(J.l, {
					label: a.a.createElement(a.a.Fragment, null, H.fbt._("Region", null, {
						hk: "scpaL"
					}), !g && a.a.createElement(re.a, null)),
					textContainerClassName: Object(W.a)(ke.a.fullWidthTextContainer, ke.a.geoText)
				}, a.a.createElement(se.a, {
					initialValue: null !== (t = null == n ? void 0 : n.name) && void 0 !== t ? t : "",
					initialPlace: p,
					onPlace: e => l(e, "place"),
					onSubmit: async function(e) {
						let {
							place: t,
							sessionId: n
						} = e;
						if ((null == t ? void 0 : t.id) === (null == p ? void 0 : p.id)) return;
						f(!0);
						const s = await Object(oe.a)(u(), {
							subredditId: r,
							placeId: t.id,
							source: t.source,
							sessionId: n
						});
						if (f(!1), !s.ok) return m(Object(ne.f)({
							kind: de.b.Error,
							text: H.fbt._("Something went wrong", null, {
								hk: "2PnKbu"
							}),
							duration: 5e3
						}));
						b(t), m(Object(ne.f)({
							kind: de.b.SuccessCommunity,
							text: H.fbt._("Successfully updated community location", null, {
								hk: "3aGk2e"
							}),
							duration: 5e3
						}))
					},
					disabled: h,
					className: ke.a.geoForm,
					inputClassName: ke.a.geoInput
				})))
			}
			const Se = {
				[ee.e.Post]: {
					short: () => H.fbt._("Post only (default)", null, {
						hk: "2XJHW4"
					}),
					long: () => H.fbt._("Only approved users can post. Anyone can comment.", null, {
						hk: "3frgit"
					})
				},
				[ee.e.Comment]: {
					short: () => H.fbt._("Comment only", null, {
						hk: "2OhQB5"
					}),
					long: () => H.fbt._("Only approved users can comment. Anyone can post.", null, {
						hk: "2F24kr"
					})
				},
				[ee.e.PostAndComment]: {
					short: () => H.fbt._("Post & Comment", null, {
						hk: "1lWCl2"
					}),
					long: () => H.fbt._("Only approved users can post and comment.", null, {
						hk: "4GkEs6"
					})
				}
			};

			function we(e) {
				const {
					isEmployee: t,
					restrictions: n,
					settings: s,
					subredditId: r,
					subredditName: o,
					testWelcomeMessage: i,
					update: d,
					geoPlace: l,
					onFocusWelcomeMessageInput: u,
					subredditCountrySite: m,
					subredditCountryEditEnabled: p,
					subredditLanguageEditEnabled: b
				} = e, {
					disableContributorRequests: h,
					over18: f,
					publicDescription: g,
					restrictCommenting: _,
					restrictPosting: v,
					subredditType: O,
					title: x,
					welcomeMessageEnabled: E,
					welcomeMessageText: y
				} = s, C = [], I = [];
				for (const a of Object.keys(Se)) I.push(Se[a].short()), C.push(Se[a].long());
				const w = !y || 0 === (null == y ? void 0 : y.length);
				return a.a.createElement(k.a, null, a.a.createElement(j, null, a.a.createElement(k.b, null, H.fbt._("Community settings", null, {
					hk: "3mvH70"
				})), a.a.createElement(Q.a, null, H.fbt._("Community Profile", null, {
					hk: "91aEK"
				})), a.a.createElement(J.e, {
					label: H.fbt._("Community name", null, {
						hk: "260EEx"
					}),
					maxChars: te.e,
					onChange: e => d(e.currentTarget.value, "title"),
					textContainerClassName: ke.a.fullWidthTextContainer,
					value: x || ""
				}), a.a.createElement(J.l, {
					label: H.fbt._("Community topics", null, {
						hk: "49aoGo"
					}),
					textContainerClassName: ke.a.fullWidthTextContainer,
					subtext: a.a.createElement("span", {
						className: ke.a.subtextContainer
					}, H.fbt._("This will help Reddit recommend your community to relevant users and other discovery experiences.", null, {
						hk: "3WYTu5"
					}), "", a.a.createElement(X.a, {
						className: ke.a.communityTopicsHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360024518712",
						rel: "noopener noreferrer",
						target: "_blank"
					}, H.fbt._("Learn more.", null, {
						hk: "1y3kXY"
					})), " ", "", a.a.createElement("span", {
						className: ke.a.numCommunityTopicsSelected
					}, a.a.createElement(V.a, {
						subredditId: r
					}))),
					direction: "column"
				}, a.a.createElement(z.b, {
					subredditId: r,
					onPrimarySelect: e.onPrimarySelect
				}), (!!e.selectedPrimaryTag || e.hasSecondaryTags) && a.a.createElement(q.b, {
					context: N.a.communitySettings,
					subredditId: r
				}), a.a.createElement(K.a, {
					context: N.a.communitySettings,
					subredditId: r
				})), a.a.createElement(J.h, {
					label: H.fbt._("Community description", null, {
						hk: "1XBKXj"
					}),
					onChange: e => d(e.currentTarget.value, "publicDescription", !1),
					maxChars: te.d,
					rows: 2,
					subtext: H.fbt._("This is how new members come to understand your community.", null, {
						hk: "llaA4"
					}),
					value: g || ""
				}), a.a.createElement(J.p, {
					className: E ? ke.a.welcomeMessageEnabled : void 0,
					on: E,
					onClick: () => d(!E, "welcomeMessageEnabled"),
					label: H.fbt._("Send welcome message to new members", null, {
						hk: "4euZSE"
					}),
					subtext: a.a.createElement("span", null, H.fbt._("Create a custom welcome message to greet people the instant they join your community. New community members will see this in a direct message 1 hour after joining.", null, {
						hk: "1D5tM8"
					}), "", a.a.createElement(X.a, {
						className: ke.a.welcomeMessageHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002551551-Welcoming-new-members",
						rel: "noopener noreferrer",
						target: "_blank"
					}, H.fbt._("Learn more.", null, {
						hk: "NkFhF"
					})))
				}), E && a.a.createElement(a.a.Fragment, null, a.a.createElement(J.h, {
					actionLink: a.a.createElement(S.t, {
						priority: S.c.PlainLink,
						className: Object(W.a)(ke.a.previewButton, {
							[ke.a.disabled]: w
						}),
						disabled: !y || 0 === (null == y ? void 0 : y.length),
						onClick: () => i(o, y)
					}, H.fbt._("Send me a test message", null, {
						hk: "4iE1go"
					})),
					label: null,
					onChange: e => {
						d(e.currentTarget.value, "welcomeMessageText")
					},
					onFocus: u,
					placeholder: H.fbt._("Welcome to our community! Were here to discuss our passion for all things related to grated cheese. (Heads upwere a text-only community, so sorry no image posts.) Get started by introducing yourself in our post for newbies, then check out our rules to learn more and dive in.", null, {
						hk: "AnOYs"
					}),
					maxChars: te.f,
					rows: 5,
					value: y || ""
				})), a.a.createElement(Ie, {
					subredditId: r,
					update: d,
					initialPlace: l,
					initialSubredditCountrySite: m,
					subredditCountryEditEnabled: !!p,
					subredditLanguageEditEnabled: !!b
				}), a.a.createElement(Q.a, null, H.fbt._("community type", null, {
					hk: "3T2OkK"
				})), a.a.createElement(J.l, {
					label: H.fbt._("Type of Community", null, {
						hk: "2PReGw"
					}),
					direction: "column"
				}, a.a.createElement(Z.a, {
					value: O,
					name: "type",
					onChange: e => d(e, "subredditType")
				}, Object(Y.radioOptions)(t, n))), a.a.createElement(J.p, {
					on: f,
					onClick: () => d(!f, "over18"),
					label: a.a.createElement("span", null, H.fbt._("18+ year old community", null, {
						hk: "3VzYZp"
					}), a.a.createElement(J.m, {
						flair: $.f.Nsfw
					})),
					subtext: H.fbt._("When your community is marked as an 18+ community, users must be flagged as 18+ in their user settings", null, {
						hk: "2h28m0"
					})
				}), "restricted" === O && a.a.createElement(a.a.Fragment, null, a.a.createElement(Q.a, null, H.fbt._("Restricted Community Settings", null, {
					hk: "1HiDiC"
				})), a.a.createElement(J.d, {
					label: H.fbt._("Approved users have the ability to", null, {
						hk: "2pduhW"
					}),
					items: I,
					selected: (() => {
						let e = ee.e.Post;
						return _ && v ? e = ee.e.PostAndComment : _ && (e = ee.e.Comment), Se[e].short()
					})(),
					onClick: e => {
						e === Se[ee.e.PostAndComment].short() ? (d(!0, ee.f.Comment), d(!0, ee.f.Post)) : e === Se[ee.e.Comment].short() ? (d(!1, ee.f.Post), d(!0, ee.f.Comment)) : e === Se[ee.e.Post].short() && (d(!0, ee.f.Post), d(!1, ee.f.Comment))
					},
					id: "restrictionOptions",
					descriptions: C
				}), a.a.createElement(J.p, {
					on: !h,
					onClick: () => d(!h, "disableContributorRequests"),
					label: H.fbt._("Accepting new requests to post", null, {
						hk: "bTpYB"
					})
				})), "private" === O && a.a.createElement(a.a.Fragment, null, a.a.createElement(Q.a, null, H.fbt._("Private Community Settings", null, {
					hk: "2JjNXE"
				})), a.a.createElement(J.p, {
					on: !h,
					onClick: () => d(!h, "disableContributorRequests"),
					label: H.fbt._("Accepting requests to join", null, {
						hk: "1l1acS"
					}),
					subtext: H.fbt._("Display a button on your private subreddit that allows users to request to join. Users may still send your subreddit modmail whether this is on or off.", null, {
						hk: "1bkLxN"
					})
				})), a.a.createElement(Q.a, null, H.fbt._("Advanced Settings", null, {
					hk: "1e5Esr"
				})), a.a.createElement(J.g, {
					label: H.fbt._("Settings for old site", null, {
						hk: "4wmYj3"
					}),
					subtext: H.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "gYPuP"
					}),
					link: `${G.a.oldRedditUrl}/r/${o}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.hc.Posts)),
					openInNewTab: !0,
					last: !0
				})))
			}
			var Te = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				Ne = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				Pe = n.n(Ne),
				Re = n("./src/reddit/components/ContentSurvey/RatingCard.tsx"),
				Ae = n("./src/reddit/components/ContentSurvey/SurveyModal.tsx"),
				Me = n("./src/reddit/helpers/trackers/contentTag.ts"),
				De = n("./src/reddit/hooks/useTracking.ts");
			const {
				fbt: Le
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function Fe(e) {
				const {
					subreddit: t
				} = e, n = Object(i.e)(e => e.subreddits.survey[t.id]), s = Object(De.a)();
				Object(o.useEffect)(() => s(Object(Me.k)()), [s]);
				const [r, d] = Object(o.useState)(!1);

				function c() {
					s(Object(Me.o)()), d(!0)
				}
				const l = !(null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible),
					u = (null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible);
				return a.a.createElement("div", {
					className: Object(W.a)(Pe.a.ContentContainer, ke.a.contentTag)
				}, a.a.createElement("h2", null, Le._("Content Tag", null, {
					hk: "1AhgrD"
				})), a.a.createElement("p", null, Le._("Your content tag is based on a moderator survey about community posts and discussions. {=Learn More}", [Le._param("=Learn More", a.a.createElement("a", {
					href: "https://www.reddithelp.com/hc/en-us/articles/360048185132",
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: () => s(Object(Me.d)())
				}, Le._("Learn More", null, {
					hk: "2gJ4PL"
				})))], {
					hk: "2xoqeD"
				})), a.a.createElement("div", {
					className: ke.a.contentTagColumn
				}, a.a.createElement(Re.a, {
					subredditId: t.id,
					ratingResponse: null == n ? void 0 : n.response
				}, (null == n ? void 0 : n.response) ? a.a.createElement(a.a.Fragment, null, a.a.createElement("p", {
					className: ke.a.ratingAudience
				}, Le._("Tagged as {ratingName} due to:", [Le._param("ratingName", n.response.rating.name)], {
					hk: "3VVnt5"
				})), a.a.createElement("ul", null, n.response.ratingReasons.map(e => a.a.createElement("li", {
					key: e.id,
					className: ke.a.ratingReason
				}, e.contentRatingReasonText)))) : a.a.createElement(a.a.Fragment, null, a.a.createElement("p", {
					className: ke.a.ratingAudience
				}, Le._("Set up your tag", null, {
					hk: "2Fb5bg"
				})), a.a.createElement("p", {
					className: ke.a.ratingDescription
				}, Le._("Take a quick survey to help people know what to expect when they visit this community", null, {
					hk: "VvmPr"
				})))), l && a.a.createElement(S.t, {
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: c
				}, Le._("Start Survey", null, {
					hk: "myDPK"
				})), u && a.a.createElement(a.a.Fragment, null, a.a.createElement("p", {
					className: ke.a.promptText
				}, Le._("Does this content tag look wrong to you?", null, {
					hk: "72VuM"
				})), a.a.createElement(S.t, {
					priority: S.c.Secondary,
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: c
				}, Le._("Take the Survey", null, {
					hk: "W30wE"
				})), a.a.createElement(Te.a, {
					to: "/r/modsupport/submit"
				}, a.a.createElement(S.t, {
					priority: S.c.Tertiary,
					redditStyle: !0,
					className: ke.a.surveyButton,
					onClick: () => s(Object(Me.f)())
				}, "Message r/modsupport")))), r && n && a.a.createElement(Ae.a, {
					withOverlay: !0,
					subredditId: t.id,
					survey: n,
					onClose: () => d(!1)
				}))
			}
			var Ue = n("./src/reddit/selectors/experiments/mediaInComments.ts");
			var Be = n("./src/reddit/selectors/experiments/chat.ts"),
				Ge = n("./src/redditGQL/types.ts");
			var He = e => {
					const {
						settings: t,
						subredditName: n,
						update: s,
						isChatPostsCreationEnabled: r,
						subredditId: d
					} = e, {
						archivePostsEnabled: l,
						allowChatPostCreation: u,
						allowGalleries: m,
						allowImages: p,
						allowPolls: b,
						allowPostCrossposts: h,
						allowPredictionsTournament: f,
						commentContributionSettings: g,
						collapseDeletedComments: _,
						commentScoreHideMins: v,
						contentOptions: O,
						spamComments: x,
						spamLinks: E,
						spamSelfposts: C,
						spoilersEnabled: I,
						suggestedCommentSort: S
					} = t, w = Object(i.e)(Ue.b), N = Object(i.e)(e => ((e, t) => {
						const n = t && e.subreddits.about[t];
						return Boolean(n && n.isMediaInCommentsSettingShown)
					})(e, d)), P = Object(i.e)(Be.e), R = w && N, A = (null == g ? void 0 : g.allowedMediaTypes) || [], M = null === S ? "nullValue" : S, D = Object(o.useCallback)(() => s(!l, "archivePostsEnabled"), [l, s]);
					return a.a.createElement(k.a, null, a.a.createElement(j, null, a.a.createElement(k.b, null, H.fbt._("Post and Comment settings", null, {
						hk: "14OI7p"
					})), a.a.createElement(Q.a, null, H.fbt._("Posts", null, {
						hk: "2i2G4r"
					})), a.a.createElement(J.d, {
						label: H.fbt._("Post type options", null, {
							hk: "M9AdT"
						}),
						items: Object.keys(te.i),
						displayItems: Object.values(te.i),
						displayTitle: te.i[O],
						selected: O,
						onClick: e => s(e, "contentOptions"),
						id: "contentOptions",
						descriptions: te.h
					}), a.a.createElement(J.p, {
						on: h,
						onClick: () => s(!h, "allowPostCrossposts"),
						label: H.fbt._("Allow crossposting of posts.", null, {
							hk: "19EiBT"
						})
					}), a.a.createElement(J.p, {
						on: l,
						onClick: D,
						label: H.fbt._("Archive posts", null, {
							hk: "3FdbDg"
						}),
						subtext: H.fbt._("Dont allow commenting or voting on posts older than 6 months", null, {
							hk: "4tIS0"
						})
					}), r && P && a.a.createElement(J.d, {
						label: H.fbt._("Live Chat Creators", null, {
							hk: "2Yd8cb"
						}),
						selected: u ? te.a.anyone : te.a.mods,
						items: Object.values(te.a),
						onClick: e => s(e === te.a.anyone, "allowChatPostCreation"),
						id: "chatPostOptions",
						subtext: H.fbt._("Choose who can start live chat posts in your community", null, {
							hk: "3F7D5k"
						})
					}), r && !P && a.a.createElement(J.p, {
						on: u,
						onClick: () => s(!u, "allowChatPostCreation"),
						label: H.fbt._("Allow chat posts creation by users.", null, {
							hk: "4zwoUf"
						})
					}), a.a.createElement(J.p, {
						on: I,
						onClick: () => s(!I, "spoilersEnabled"),
						label: a.a.createElement("span", null, H.fbt._("Enable spoiler tag", null, {
							hk: "2CtBpB"
						}), a.a.createElement(J.m, {
							flair: $.f.Spoiler
						})),
						subtext: H.fbt._("Media on posts with the spoiler tag are blurred", null, {
							hk: "4rVOs6"
						})
					}), a.a.createElement(J.p, {
						on: p,
						onClick: () => {
							s(!p, "allowImages"), s(!p, "allowGalleries")
						},
						label: H.fbt._("Allow image uploads and links to image hosting sites", null, {
							hk: "20ETVO"
						})
					}), p && a.a.createElement(J.p, {
						"data-testid": "allow-images-community-setting",
						on: m,
						onClick: () => s(!m, "allowGalleries"),
						label: H.fbt._("Allow multiple images per post", null, {
							hk: "Pcjq5"
						})
					}), a.a.createElement(J.p, {
						on: b,
						onClick: () => s(!b, "allowPolls"),
						label: H.fbt._("Allow polls", null, {
							hk: "15LXRO"
						})
					}), a.a.createElement(J.p, {
						on: f,
						onClick: () => s(!f, "allowPredictionsTournament"),
						label: H.fbt._("Allow predictions", null, {
							hk: "rcdMx"
						}),
						subtext: H.fbt._("Allow predictions by mods in your community (only for public, SFW communities with 10k or more members)", null, {
							hk: "40loX3"
						})
					}), a.a.createElement(J.l, {
						label: H.fbt._("Spam filter strength", null, {
							hk: "4C4qar"
						}),
						subtext: H.fbt._("'HIGH' is the standard filter, 'LOW' disables most filtering, 'ALL' will filter every post initially and they will need to be approved manually to be visible", null, {
							hk: "mdxeP"
						})
					}), a.a.createElement(J.d, {
						label: H.fbt._("Posts", null, {
							hk: "1SdpTj"
						}),
						items: Object.keys(te.k),
						displayItems: Object.values(te.k),
						displayTitle: te.k[C],
						id: "spamSelfposts",
						selected: C,
						onClick: e => s(e, "spamSelfposts"),
						indent: !0
					}), a.a.createElement(J.d, {
						label: H.fbt._("Links", null, {
							hk: "Ia7TU"
						}),
						items: Object.keys(te.k),
						displayItems: Object.values(te.k),
						displayTitle: te.k[E],
						id: "spamLinks",
						selected: E,
						onClick: e => s(e, "spamLinks"),
						indent: !0
					}), a.a.createElement(J.d, {
						label: H.fbt._("Comments", null, {
							hk: "1X5Fv2"
						}),
						items: Object.keys(te.c),
						displayItems: Object.values(te.c),
						displayTitle: te.c[x],
						selected: x,
						onClick: e => s(e, "spamComments"),
						indent: !0,
						id: "spamComments"
					}), a.a.createElement(Q.a, null, H.fbt._("Comments", null, {
						hk: "4sAqsA"
					})), a.a.createElement(J.d, {
						label: H.fbt._("Suggested sort", null, {
							hk: "4Af3Lr"
						}),
						subtext: H.fbt._("All comment feeds in community will default to this sort setting", null, {
							hk: "4grj1W"
						}),
						items: Object.keys(te.j),
						displayItems: Object.values(te.j),
						displayTitle: te.j[M],
						selected: M,
						onClick: e => s("nullValue" === e ? null : e, "suggestedCommentSort"),
						id: "suggestedCommentSort"
					}), a.a.createElement(J.p, {
						on: _,
						onClick: () => s(!_, "collapseDeletedComments"),
						label: H.fbt._("Collapse deleted and removed comments", null, {
							hk: "Iw8kU"
						})
					}), a.a.createElement(J.l, {
						label: H.fbt._("Minutes to hide comment scores", null, {
							hk: "1DJhj0"
						}),
						direction: "column"
					}, a.a.createElement(y, {
						onChange: e => s(e.currentTarget.value, "commentScoreHideMins"),
						isInvalid: !(v >= te.g && v <= te.b),
						min: te.g,
						max: te.b,
						type: "number",
						value: v
					})), R && a.a.createElement(a.a.Fragment, null, a.a.createElement(J.l, {
						label: H.fbt._("Media in comments", null, {
							hk: "25YOda"
						}),
						subtext: H.fbt._("Allow users to insert GIFs from Giphy directly into their comments. Coming soon, a setting to allow users to upload and attach images from their device into comments.", null, {
							hk: "44aVKk"
						})
					}), a.a.createElement(J.p, {
						on: A.includes(Ge.d.Giphy),
						onClick: () => s(function(e, t) {
							const n = (null == t ? void 0 : t.allowedMediaTypes) || [],
								s = n.includes(e) ? n.filter(t => t !== e) : [...n, e];
							return {
								...t,
								allowedMediaTypes: s
							}
						}(Ge.d.Giphy, g), "commentContributionSettings"),
						label: H.fbt._("GIFs", null, {
							hk: "2vQkCj"
						})
					})), a.a.createElement(Q.a, null, H.fbt._("Advanced Settings", null, {
						hk: "53xlS"
					})), a.a.createElement(J.g, {
						label: H.fbt._("Settings for old site", null, {
							hk: "2jzUi8"
						}),
						subtext: H.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "4DHBV2"
						}),
						link: `${G.a.oldRedditUrl}/r/${n}/about/edit`,
						onClick: () => e.sendEvent(Object(T.d)(c.hc.Posts)),
						openInNewTab: !0,
						last: !0
					})))
				},
				We = n("./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx");
			const qe = {
					0: {
						text: H.fbt._("Off", null, {
							hk: "30Jfc7"
						}),
						color: "#787C7E"
					},
					1: {
						text: H.fbt._("Lenient", null, {
							hk: "2TWZ21"
						}),
						color: "#46D160"
					},
					2: {
						text: H.fbt._("Moderate", null, {
							hk: "2s7qbB"
						}),
						color: "#FFB000"
					},
					3: {
						text: H.fbt._("Strict", null, {
							hk: "4s6ECM"
						}),
						color: "#EA0027"
					}
				},
				Ve = {
					0: H.fbt._("Use Crowd Control to automatically collapse comments from users youre not sure about.", null, {
						hk: "n75Tc"
					}),
					1: H.fbt._("Comments from users who have negative karma in your community are automatically collapsed.", null, {
						hk: "37Keyu"
					}),
					2: H.fbt._("Comments from new users and users with negative karma in your community are automatically collapsed.", null, {
						hk: "v6NNK"
					}),
					3: H.fbt._("Comments from users who havent joined your community, new users, and users with negative karma in your community are automatically collapsed.", null, {
						hk: "4NqwJ"
					})
				},
				ze = {
					0: H.fbt._("Use Crowd Control to automatically filter posts from users youre not sure about.", null, {
						hk: "RFsOk"
					}),
					1: H.fbt._("Posts from users who have negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "2cFJqC"
					}),
					2: H.fbt._("Posts from new users and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "1TwCdK"
					}),
					3: H.fbt._("Posts from users who havent joined your community, new users, and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "Syn69"
					})
				},
				Ke = {
					0: H.fbt._("No content posted from accounts suspected of ban evasion will automatically be held for review.", null, {
						hk: "ziWwq"
					}),
					1: H.fbt._("Content posted from accounts suspected of ban evasion within the past few weeks will automatically be held for review.", null, {
						hk: "2MWoA6"
					}),
					2: H.fbt._("Content posted from accounts suspected of ban evasion within the past few months will automatically be held for review.", null, {
						hk: "3YPzrf"
					}),
					3: H.fbt._("Content posted from accounts suspected of ban evasion will automatically be held for review.", null, {
						hk: "3CLgTG"
					})
				};

			function Qe(e) {
				const {
					banEvasionProtectionEnabled: t,
					isChatPostsCreationEnabled: n,
					isBroadcastingEnabled: s,
					settings: r,
					subredditName: o,
					subreddit: i,
					update: d
				} = e, {
					allowDiscovery: l,
					banEvasionThreshold: u,
					contentVisible: m,
					crowdControlFilter: p,
					crowdControlLevel: b,
					crowdControlChatLevel: h,
					crowdControlPostLevel: f,
					excludeBannedModqueue: g,
					toxicityThresholdChatLevel: _
				} = r, {
					showCrowdControlCampaign: v
				} = Object(We.b)(), O = Math.max(u - 1, 0), x = n || s;
				return a.a.createElement(k.a, null, a.a.createElement(j, null, a.a.createElement(k.b, {
					className: ke.a.pageTitle
				}, H.fbt._("Safety & privacy settings", null, {
					hk: "34ghQV"
				})), a.a.createElement(J.p, {
					on: g,
					onClick: () => d(!g, "excludeBannedModqueue"),
					label: H.fbt._("Exclude posts by site-wide banned users", null, {
						hk: "Kmfy0"
					}),
					subtext: H.fbt._("Posts are excluded from modqueue/unmoderated", null, {
						hk: "2P2pfc"
					})
				}), x && a.a.createElement(J.p, {
					on: !!Number(_),
					onClick: () => {
						d(Number(_) ? "0" : "1", "toxicityThresholdChatLevel")
					},
					label: H.fbt._("Collapse Toxic Messages in Chat Post", null, {
						hk: "1Pk3G5"
					}),
					subtext: H.fbt._("Comments that our model scores as toxic will be automatically collapsed.", null, {
						hk: "Rohtu"
					})
				}), t && a.a.createElement(J.j, {
					className: ke.a.rangeSetting,
					ticks: qe,
					min: 0,
					max: Object.keys(qe).length - 1,
					step: 1,
					value: O,
					onChange: e => d((e => `${Math.min(parseInt(e,10)+1,4)}`)(e.target.value), "banEvasionThreshold"),
					label: H.fbt._("Ban Evasion Protection", null, {
						hk: "1TrdWv"
					}),
					subtext: Ke[O]
				}), a.a.createElement(Q.a, {
					className: ke.a.sectionHeadingFollowedBySubtext
				}, H.fbt._("Crowd Control", null, {
					hk: "1HF3IV"
				})), a.a.createElement(J.n, {
					className: ke.a.sectionSubtext
				}, H.fbt._("Automatically collapse or filter content from people who aren't trusted users within your community yet.", null, {
					hk: "3U7kZS"
				})), a.a.createElement(J.j, {
					className: ke.a.rangeSetting,
					ticks: qe,
					min: 0,
					max: Object.keys(qe).length - 1,
					step: 1,
					value: b,
					onChange: e => d(e.target.value, "crowdControlLevel"),
					label: H.fbt._("Comments", null, {
						hk: "1vRuWQ"
					}),
					subtext: Ve[b]
				}), a.a.createElement(J.p, {
					indent: !0,
					on: p,
					labelClassname: v ? ke.a.labelWithNewTag : void 0,
					onClick: () => d(!p, "crowdControlFilter"),
					label: a.a.createElement(a.a.Fragment, null, H.fbt._("Hold Crowd Controlled comments for review", null, {
						hk: "43fG1u"
					}), v && a.a.createElement(re.a, {
						className: ke.a.labelNewTag
					})),
					subtext: H.fbt._("Instead of collapsing crowd controlled comments will be held for review in mod queue.", null, {
						hk: "1QBJUP"
					})
				}), a.a.createElement(J.j, {
					className: ke.a.rangeSetting,
					ticks: qe,
					min: 0,
					max: Object.keys(qe).length - 1,
					step: 1,
					value: f,
					onChange: e => d(e.target.value, "crowdControlPostLevel"),
					labelClassname: v ? ke.a.labelWithNewTag : void 0,
					label: a.a.createElement(a.a.Fragment, null, H.fbt._("Posts", null, {
						hk: "nW9yu"
					}), v && a.a.createElement(re.a, {
						className: ke.a.labelNewTag
					})),
					subtext: ze[f]
				}), x && a.a.createElement(J.j, {
					ticks: qe,
					min: 0,
					max: Object.keys(qe).length - 1,
					step: 1,
					value: h,
					onChange: e => d(e.target.value, "crowdControlChatLevel"),
					label: H.fbt._("Chat Posts", null, {
						hk: "eTeih"
					}),
					subtext: Ve[h]
				}), a.a.createElement(Q.a, {
					className: ke.a.sectionHeadingFollowedBySubtext
				}, H.fbt._("Discover", null, {
					hk: "1I53SY"
				})), a.a.createElement(J.n, {
					className: ke.a.sectionSubtext
				}, H.fbt._("Show your community to the general Reddit population or just to people who have similar interests, by adjusting how people can find it. Not sure what's best for you? {=Learn More.}", [H.fbt._param("=Learn More.", a.a.createElement("a", {
					className: ke.a.subtextLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: "https://mods.reddithelp.com/hc/en-us/sections/360000685771-General-Common-Questions"
				}, H.fbt._("Learn More.", null, {
					hk: "KAZVL"
				})))], {
					hk: "38WrgR"
				})), !i.isQuarantined && a.a.createElement(a.a.Fragment, null, a.a.createElement(J.p, {
					on: m,
					onClick: () => d(!m, "contentVisible"),
					label: H.fbt._("Show up in high-traffic feeds", null, {
						hk: "3l7KBc"
					}),
					subtext: H.fbt._("Allow your community to be in r/all, r/popular, and trending lists where it can be seen by the general Reddit population.", null, {
						hk: "iH0lY"
					})
				}), a.a.createElement(J.p, {
					on: l,
					onClick: () => d(!l, "allowDiscovery"),
					label: H.fbt._("Get recommended to individual redditors", null, {
						hk: "4wmaiH"
					}),
					subtext: H.fbt._("Let Reddit recommend your community to people who have similar interests.", null, {
						hk: "487MMM"
					})
				})), a.a.createElement(Q.a, null, H.fbt._("Advanced Settings", null, {
					hk: "3TL9Or"
				})), a.a.createElement(J.g, {
					link: `${G.a.oldRedditUrl}/r/${o}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.hc.Safety)),
					openInNewTab: !0,
					last: !0,
					label: H.fbt._("Settings for old site", null, {
						hk: "1WHvCJ"
					}),
					subtext: H.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "2wPmwa"
					})
				})))
			}

			function Je(e) {
				const {
					settings: t,
					subredditName: n,
					update: s
				} = e, {
					wikiEditAge: r,
					wikiEditKarma: o,
					wikimode: i
				} = t;
				return a.a.createElement(k.a, null, a.a.createElement(j, null, a.a.createElement(k.b, null, H.fbt._("Wiki settings", null, {
					hk: "1gmluS"
				})), a.a.createElement(Q.a, null, H.fbt._("Community wiki pages", null, {
					hk: "1LwxaS"
				})), a.a.createElement(J.d, {
					label: H.fbt._("Wikis can be edited by", null, {
						hk: "3brAqG"
					}),
					displayItems: Object.values(te.o),
					displayTitle: te.o[i],
					items: Object.keys(te.o),
					selected: i,
					onClick: e => s(e, "wikimode"),
					id: "wikimode",
					descriptions: te.n
				}), a.a.createElement(J.l, {
					label: H.fbt._("Karma required to edit and create wiki pages", null, {
						hk: "3OgR7v"
					}),
					direction: "column"
				}, a.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditKarma"),
					isInvalid: !(o >= te.g && o <= te.m),
					min: te.g,
					max: te.m,
					type: "number",
					value: o
				})), a.a.createElement(J.l, {
					label: H.fbt._("Age of Reddit account required to edit and create wiki pages", null, {
						hk: "3UE6cD"
					}),
					direction: "column"
				}, a.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditAge"),
					isInvalid: !(r >= te.g && r <= te.l),
					min: te.g,
					max: te.l,
					type: "number",
					value: r
				})), a.a.createElement(Q.a, null, H.fbt._("Advanced Settings", null, {
					hk: "4drMhK"
				})), a.a.createElement(J.g, {
					label: H.fbt._("Settings for old site", null, {
						hk: "2YU3sQ"
					}),
					subtext: H.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "1ihkVe"
					}),
					link: `${G.a.oldRedditUrl}/r/${n}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.hc.Wikis)),
					openInNewTab: !0,
					last: !0
				})))
			}
			const {
				fbt: Ye
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Xe = Object(d.c)({
				allowChatPostCreation: (e, t) => Object(R.b)(e, t.subredditId),
				banEvasionProtectionEnabled: w.d.banEvasionProtectionEnabled,
				isBroadcastingEnabled: (e, t) => Object(A.c)(e, t.subredditId),
				isChatPostsCreationEnabled: (e, t) => Object(R.c)(e, t.subredditId),
				isEmployee: F.N,
				notificationSettings: D.b,
				restrictions: M.o,
				settings: (e, t) => Object(M.W)(e, t.subredditId),
				subreddit: M.U,
				selectedPrimaryTag: L.s,
				hasSecondaryTags: L.m,
				geoPlace: (e, t) => e.tags.models.geoPlaces[t.subredditId],
				subredditCountrySite: (e, t) => ((e, t) => e.subreddits.countrySiteSettings[t])(e, t.subredditId),
				subredditCountryEditEnabled: (e, t) => Object(B.g)(e),
				subredditLanguageEditEnabled: (e, t) => Object(B.h)(e)
			}), Ze = Object(i.b)(Xe, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					onViewPageEvent: () => e(Object(l.a)()),
					testWelcomeMessage: (t, n) => e(Object(u.i)(t, n)),
					save: (t, n) => e(Object(u.j)(n, t, void 0)),
					saveCommunityTopics: t => e(Object(_.e)(t, N.a.communitySettings)),
					onPrimarySelect: t => e(Object(_.f)({
						primaryTagId: t,
						subredditId: n
					})),
					savePrimaryTopic: t => {
						t && e(Object(_.o)(n, {
							tagId: t.id,
							state: P.d.TAGGED
						}, !1))
					},
					updateSubredditWelcomeMessage: (t, n, s) => e(f(t, n, s)),
					saveSubredditCountrysite: (t, n) => {
						if (n) return e(Object(U.e)(t, n))
					}
				}
			});
			class $e extends a.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.saveSettings = () => {
						var e, t, n, s;
						this.props.save(this.state.changed, this.props.subredditId);
						const o = this.props.subredditCountryEditEnabled,
							a = this.props.subredditLanguageEditEnabled;
						(o || a) && this.props.subpageName === c.hc.Community && (this.props.saveSubredditCountrysite(this.props.subredditId, this.props.subredditCountrySite), o && this.props.sendEvent(Object(T.c)("country", null === (e = this.props.subredditCountrySite) || void 0 === e ? void 0 : e.countryCode, null === (t = this.state.subredditCountrySite) || void 0 === t ? void 0 : t.countryCode)), a && this.props.sendEvent(Object(T.c)("language", null === (n = this.props.subredditCountrySite) || void 0 === n ? void 0 : n.languageCode, null === (s = this.state.subredditCountrySite) || void 0 === s ? void 0 : s.languageCode)), this.props.subredditCountrySite && !r()(this.state.subredditCountrySite, this.props.subredditCountrySite) && this.setState({
							subredditCountrySite: this.props.subredditCountrySite
						})), this.props.saveCommunityTopics(this.props.subredditId), this.props.savePrimaryTopic(this.props.selectedPrimaryTag);
						for (const r in this.state.changed) this.props.sendEvent(Object(T.e)(r, this.state.changed[r], this.props.settings[r]));
						this.setState({
							settings: this.state.settings,
							changed: {}
						})
					}, this.update = function(e, n) {
						let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						s && t.props.sendEvent(Object(T.f)(n, e, t.state.settings[n])), t.setState(t => ({
							changed: {
								...t.changed,
								[n]: e
							},
							settings: {
								...t.settings,
								[n]: e
							}
						}))
					}, this.onFocusWelcomeMessageInput = () => this.props.sendEvent(Object(T.g)("click", "welcome_message_edit")), this.renderSubpage = () => {
						const e = {
							...this.props,
							settings: this.state.settings,
							update: this.update,
							onFocusWelcomeMessageInput: this.onFocusWelcomeMessageInput
						};
						if (!this.state.settings) return null;
						switch (this.props.subpageName) {
							case c.hc.Safety:
								return a.a.createElement(Qe, e);
							case c.hc.Notifications:
								return a.a.createElement(k.a, null, a.a.createElement(j, null, a.a.createElement(C.a, {
									subredditId: e.subredditId,
									subredditName: e.subredditName
								})));
							case c.hc.Posts:
								return a.a.createElement(He, e);
							case c.hc.Wikis:
								return a.a.createElement(Je, e);
							case c.hc.ContentTag:
								return a.a.createElement(Fe, {
									subreddit: e.subreddit
								});
							default:
								return a.a.createElement(we, e)
						}
					}, this.state = {
						settings: e.settings,
						changed: {},
						subredditCountrySite: e.subredditCountrySite
					}
				}
				componentDidMount() {
					this.props.onViewPageEvent()
				}
				componentDidUpdate(e) {
					!this.props.settings || r()(e.settings, this.props.settings) || r()(this.state.settings, this.props.settings) || this.setState({
						settings: this.props.settings
					}), !this.props.subredditCountrySite || this.state.subredditCountrySite || r()(this.state.subredditCountrySite, this.props.subredditCountrySite) || this.setState({
						subredditCountrySite: this.props.subredditCountrySite
					})
				}
				render() {
					return a.a.createElement(a.a.Fragment, null, this.props.subpageName !== c.hc.ContentTag && a.a.createElement(k.c, null, a.a.createElement(S.l, {
						onClick: this.saveSettings,
						"data-redditstyle": !0
					}, Ye._("Save changes", null, {
						hk: "8mSp0"
					}))), this.renderSubpage())
				}
			}
			t.a = Ze(Object(I.c)($e))
		},
		"./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/models/Tags/index.ts"),
				d = n("./src/reddit/selectors/tags.ts");
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = Object(a.c)({
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(d.r)(e, {
						subredditId: n
					})
				}
			});
			t.a = Object(o.b)(l)(e => r.a.createElement(r.a.Fragment, null, e.selectedOptions.length, "/", i.a))
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less": function(e, t, n) {
			e.exports = {
				menuItemsWrapper: "_1OISxDncG3tn4CibwqeC4e",
				tooltip: "UNHdPZIwwyCehEV-NfEY7"
			}
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return R
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ContentTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/helpers/localStorage/index.ts"),
				b = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				h = n("./src/reddit/components/InlineSubredditEditing/index.m.less"),
				f = n.n(h);
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class _ extends o.a.Component {
				componentDidMount() {
					this.props.sendEvent(b.e), this.props.onViewTooltip()
				}
				render() {
					const {
						translatedTitle: e,
						translatedDesc: t,
						translatedButtonText: n
					} = this.props;
					return o.a.createElement("div", {
						className: f.a.tooltipContent,
						onClick: e => {
							e.preventDefault(), e.stopPropagation()
						}
					}, o.a.createElement("span", {
						className: f.a.topRow
					}, o.a.createElement("h3", {
						className: f.a.title
					}, e)), o.a.createElement("p", {
						className: f.a.tooltipBody
					}, t), o.a.createElement(m.l, {
						className: f.a.gotIt,
						onClick: this.props.onDismissTooltip
					}, n || g._("Got it", null, {
						hk: "4CoCjQ"
					})))
				}
			}
			var v = Object(a.b)(void 0, e => ({
				onDismissTooltip: () => {
					e(Object(c.i)()), Object(p.zb)()
				},
				onViewTooltip: () => {
					Object(p.Vb)()
				}
			}))(Object(u.c)(_));
			const O = "editable-primary-topic-idcard";
			var x = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				E = n("./src/reddit/models/Tags/index.ts"),
				y = n("./src/reddit/selectors/tags.ts"),
				j = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less"),
				C = n.n(j);
			const k = e => {
					let {
						hasPrimaryTag: t,
						hasSecondaryTags: n
					} = e;
					if (t) return null;
					let r = s.fbt._("Add Community Topics", null, {
							hk: "2wd4kg"
						}),
						a = s.fbt._("Tell us what topics are relevant to your community so we can surface it to the right users", null, {
							hk: "24NCiQ"
						});
					return n && (r = s.fbt._("Add a Primary Topic", null, {
						hk: "41x5Gv"
					}), a = s.fbt._("Oops we dont have a primary topic yet. Add one so we can surface your community to the right users", null, {
						hk: "XayPA"
					})), o.a.createElement(l.a, {
						className: C.a.tooltip,
						tooltipId: O,
						defaultTooltipPosition: "left",
						tooltipSizeEstimate: {
							height: 150,
							width: 320
						}
					}, o.a.createElement(v, {
						translatedTitle: r,
						translatedDesc: a
					}))
				},
				I = {
					availablePrimaryTags: y.p
				},
				S = Object(i.c)({
					...I,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(y.s)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(y.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: y.D
				}),
				w = Object(i.c)({
					...I,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(y.x)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(y.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: y.D
				}),
				T = Object(i.c)({
					...I,
					selectedPrimaryTag: y.v,
					hasSecondaryTags: () => !1,
					isSaving: e => Object(y.D)(e)
				}),
				N = (e, t) => {
					let {
						subredditId: n,
						onPrimarySelect: s
					} = t;
					return {
						onPrimaryTopicSelected: t => {
							t.isSelected || !s ? t.isSelected || (e(Object(d.f)({
								primaryTagId: t.value,
								subredditId: n
							})), e(Object(d.o)(n, {
								tagId: t.value,
								state: E.d.TAGGED
							}))) : s(t.value)
						},
						onShowTooltip: () => {
							e(Object(c.f)({
								tooltipId: O
							}))
						}
					}
				};
			class P extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						tooltipDismissed: !0
					}
				}
				componentDidMount() {
					const e = this.props.onShowTooltip;
					this.setState({
						tooltipDismissed: Object(p.r)()
					}, () => {
						this.isTooltipEnabled() && e && e()
					})
				}
				isTooltipEnabled() {
					const {
						shouldShowTooltip: e = !1,
						selectedPrimaryTag: t
					} = this.props;
					return !this.state.tooltipDismissed && !t && e
				}
				render() {
					const {
						availablePrimaryTags: e,
						className: t,
						hasSecondaryTags: n,
						isSaving: r,
						onPrimaryTopicSelected: a,
						selectedPrimaryTag: i
					} = this.props, d = i && i.text;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(x.b, {
						id: this.isTooltipEnabled() ? O : void 0,
						className: t,
						isTopicsStyle: !0,
						displayText: d || s.fbt._("Add a Primary Topic", null, {
							hk: "1HgVte"
						}),
						options: e.map(e => ({
							displayText: e.text,
							value: e.id,
							isSelected: !!i && i.id === e.id
						})),
						onSelect: a,
						menuItemsClassName: C.a.menuItemsWrapper,
						showSelectedCheckmark: !0,
						isSaving: r
					}), this.isTooltipEnabled() && o.a.createElement(k, {
						hasPrimaryTag: !!i,
						hasSecondaryTags: n
					}))
				}
			}
			Object(a.b)(T, e => ({
				onPrimaryTopicSelected: t => {
					e(Object(d.a)({
						primaryTagId: t.value
					}))
				}
			}))(P);
			const R = Object(a.b)(w, N)(P),
				A = Object(a.b)(S, N);
			t.b = A(P)
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less": function(e, t, n) {
			e.exports = {
				suggestedTopicsContainer: "_3qCTJNZ-iSCZa0wyVfs6my",
				relatedText: "_389N9jvZJu60U3E7vIF00n",
				closeIcon: "M40GQ3RaivlkCl8WQ-pXo",
				plusIcon: "_2OYvdU1reofcbKMJ0wvC_x",
				suggestedTopic: "_1RmiLhJpOUx_hgduPf3F5O",
				closeIconContainer: "sHLJV3zATRod0k1f_m71I",
				suggestedTopicText: "_1-rmQV4Wee08Dt-h2GyW-o"
			}
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tags/index.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/icons/svgs/Close/index.tsx"),
				m = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				p = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less"),
				b = n.n(p);
			var h = e => o.a.createElement("span", {
					className: b.a.suggestedTopic,
					onClick: () => e.onSuggestedTopicSelected(e.suggestedTopic)
				}, o.a.createElement(m.a, {
					className: b.a.plusIcon
				}), o.a.createElement("span", {
					className: b.a.suggestedTopicText
				}, e.suggestedTopic.displayText), o.a.createElement("span", {
					className: b.a.closeIconContainer,
					onClick: t => {
						t.preventDefault(), t.stopPropagation(), e.onSuggestedTopicDismissed(e.suggestedTopic)
					}
				}, o.a.createElement(u.a, {
					className: b.a.closeIcon
				}))),
				f = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				g = n("./src/reddit/models/Tags/index.ts"),
				_ = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/selectors/tags.ts");
			const O = Object(i.c)({
					suggestedOptions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(v.y)(e, {
								itemId: n
							}),
							r = Object(v.r)(e, {
								subredditId: n
							}),
							o = Object(v.w)(e, {
								subredditId: n
							});
						return s.filter(e => !!e.id && o !== e.id && !r.find(t => !!t.id && t.id === e.id))
					}
				}),
				x = Object(a.b)(O, (e, t) => {
					let {
						subredditId: n,
						onOptionSelected: r,
						context: o
					} = t;
					return {
						onSuggestedOptionDismissed: t => {
							e(Object(c.n)(n, [], [{
								subredditId: n,
								tagId: t.id,
								isRelevant: !1
							}], o, !0))
						},
						onSuggestedOptionSelected: t => {
							e((e, a) => {
								const i = a();
								Object(v.r)(i, {
									subredditId: n
								}).length >= g.a ? e(Object(l.f)({
									...Object(l.e)(s.fbt._("You can only add up to {max number of topics} community topics", [s.fbt._param("max number of topics", g.a.toString())], {
										hk: "1OySAh"
									}), _.b.Error),
									duration: l.a
								})) : (e(Object(c.j)({
									subredditId: n,
									option: t
								})), Object(f.c)(a(), n, t, {
									context: o
								}), r && r(t))
							})
						}
					}
				});
			t.a = x(e => e.suggestedOptions.length ? o.a.createElement("div", {
				className: Object(d.a)(b.a.suggestedTopicsContainer, e.className)
			}, e.children || o.a.createElement("span", {
				className: b.a.relatedText
			}, s.fbt._("Related:", null, {
				hk: "1qt7CO"
			})), e.suggestedOptions.map(t => o.a.createElement(h, {
				key: t.id,
				suggestedTopic: t,
				onSuggestedTopicSelected: e.onSuggestedOptionSelected,
				onSuggestedTopicDismissed: e.onSuggestedOptionDismissed
			}))) : null)
		},
		"./src/reddit/components/CommunityTopics/index.m.less": function(e, t, n) {
			e.exports = {
				communityTopicsContainer: "wsNyCIZw7veQPURlfXwXb"
			}
		},
		"./src/reddit/components/CommunityTopics/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/components/MultiOptionSelect/index.tsx"),
				u = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				m = n("./src/reddit/models/Tags/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/tags.ts"),
				h = n("./src/reddit/components/CommunityTopics/index.m.less"),
				f = n.n(h);
			const g = Object(i.c)({
				availableSubredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.d)(e, {
						subredditId: n
					})
				},
				subredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.o)(e, {
						itemId: n
					})
				},
				availableGlobalOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.a)(e, {
						thingId: n
					})
				},
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.r)(e, {
						subredditId: n
					})
				},
				isLoading: e => Object(b.B)(e),
				currentInput: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.i)(e, {
						subredditId: n
					})
				}
			});
			class _ extends o.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							n = e.filter(e => !e.selected);
						this.onOptionsSelected(t), n.forEach(e => this.onOptionDeselected(e))
					}, this.onFocus = () => {
						this.props.onSearchBarFocused(), this.props.onFocus && this.props.onFocus()
					}
				}
				onOptionsSelected(e) {
					const t = m.a - this.props.selectedOptions.length,
						n = e.filter(e => !!e.displayText.trim()),
						s = n.slice(0, t);
					s.forEach(e => {
						if (!e.id) {
							const t = Object(b.c)(e.displayText, this.props.availableSubredditTags);
							t && (e = Object(m.f)(t, !0))
						}
						this.props.optionSelected({
							...e,
							displayText: e.displayText.trim()
						})
					}), s.length !== n.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(e)
				}
				render() {
					return o.a.createElement("div", {
						className: f.a.communityTopicsContainer
					}, o.a.createElement(l.a, {
						readOnlyMode: this.props.readOnlyMode,
						addText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						childClassNames: this.props.childClassNames,
						dropdownHeaderText: s.fbt._("Suggested topics", null, {
							hk: "1RASWg"
						}),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > m.a,
						isLoading: this.props.isLoading,
						maxOptionLength: m.b,
						maxOptionsToDisplay: this.props.maxTopicsToDisplay,
						onSearchBarFocus: this.onFocus,
						onSearchBarBlur: this.props.onBlur,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: !0
					}, this.props.children))
				}
			}
			t.b = Object(a.b)(g, (e, t) => {
				let {
					subredditId: n,
					context: r
				} = t;
				return {
					optionSelected: t => {
						e(Object(d.j)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.e(s(), n, t, {
								context: r
							})
						})
					},
					optionDeselected: t => {
						e(Object(d.i)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.d(s(), n, t, {
								context: r
							})
						})
					},
					onInputChanged: t => e(Object(d.h)({
						subredditId: n,
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {
						u.b(t(), n, {
							context: r
						})
					}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(c.f)({
							...Object(c.e)(s.fbt._({
								"*": "You can only add up to max {number} community topics",
								_1: "You can only add up to max 1 community topic"
							}, [s.fbt._plural(m.a, "number")], {
								hk: "s07I1"
							}), p.b.Error),
							duration: c.a
						}))
					})
				}
			})(_)
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				horizontalVotes: "_2oM1YqCxIwkvwyeZamWwhW",
				customScoreStyles: "_25IkBM0rRUqWX5ZojEMAFQ",
				customDownvoteStyles: "_783RL1AYIib59nxLCXhgv"
			}
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/components/CompactPost/HorizontalVotes/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(a.a)(e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement(i.a, l({}, n, {
					className: Object(o.a)(c.a.horizontalVotes, t),
					scoreClassName: Object(o.a)(c.a.customScoreStyles, n.scoreClassName),
					downvoteClassName: Object(i.b)(n) ? c.a.customDownvoteStyles : void 0
				}))
			});
			t.a = u
		},
		"./src/reddit/components/CompactPost/index.m.less": function(e, t, n) {
			e.exports = {
				hideAboveSmallTablet: "FX_aWE8xMirpzniJDh7I9",
				responsiveExpandoButton: "_3gazhzxd2iBGYb2k67_HTw",
				mHideAboveSmallTablets: "_2zV_ARVPrYN10xmbbb_4Lu",
				responsiveMeta: "_1xomvNxK4aHGoGa-YDw1Mc",
				verticalVotes: "WAapGmF_gr09J509Af-gC",
				commentsLink: "Nz0lkWnnj2V_4iBKE0WL7",
				hideBelowSmallTablet: "z_7pbLL4hZp6ikYkq0prE",
				horizontalVotes: "_37nbKm3ee5NGx6e-LXErLD",
				postTopMeta: "_1ghZRP5m5xDLh0up1rFt0e",
				mHideBelowSmallTablets: "_3x_hdVQw5uJh6xeAGoZock",
				adLinkWrapper: "_4Dt8djtbHlJ5uCZDX_SeV",
				ctaExperiment: "_3xMykgG1y_Ln8tQs4ciV4i",
				content: "_1B7SUGHK0QDoHimxX2a9D0",
				leftRail: "_2r9FABr2qYEUDyZoenhn6N",
				bulkActionCheckbox: "_44ehKZ_pl1NGGaaTYouZR",
				subredditIcon: "_1kWbgdOrvSeXIZZRIw4uBS",
				topLine: "_2ZjElFi3ORaU3VPrwmdoCp",
				postBadges: "_126a2ACB41algqMEwA34TF",
				flatList: "_3jwri54NGT-SRatPIZYiMo",
				expandedContentWrapper: "_12wy0ZFFaS3a49145uXWXt",
				crosspostMediaWrapper: "_2fCIreZsKBNS3esgsKKksM",
				compactWrapper: "YA9IzN0YR-G5_oD5EUydl",
				compactPostRow: "WnMeTcero48dKo501T-19",
				leftRailWrapper: "_3YgWdffoKyCp7UaGAEQpoo",
				proposalMetaData: "_1_B8IWlNlt5jJVg4cKy7nL",
				isEvent: "_1csviRG5jI9xOrcsmpbfwt",
				modToolsFlatlist: "_20p7Nh6bZU7MOqYuB2uJcy",
				postContainer: "_2bHVWuR_l_wVivC3FKfLFf",
				leftBorderWrapper: "_3ZmFVbkR23TIZ-3nboLYXe",
				modModeBannerWrapper: "_1_voPxd0-GKljAjvO7ZcgJ"
			}
		},
		"./src/reddit/components/CompactPost/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "renderSubredditIcon", (function() {
				return Re
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				h = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				f = n("./src/reddit/helpers/trackers/post.ts"),
				g = n("./src/reddit/models/Media/index.ts"),
				_ = n("./src/reddit/models/User/index.ts"),
				v = n("./src/reddit/models/Vote/index.ts"),
				O = n("./src/reddit/actions/post.ts"),
				x = n("./src/reddit/actions/postFlair.ts"),
				E = n("./src/reddit/actions/tooltip.ts"),
				y = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/moderatorPermissions.ts"),
				C = n("./src/reddit/selectors/postFlair.ts"),
				k = n("./src/reddit/selectors/posts.ts"),
				I = n("./src/reddit/components/AdLinkWrapper/index.tsx"),
				S = n("./src/reddit/components/AdLinkWrapperContent/index.tsx"),
				w = n("./src/reddit/components/AwardBadges/index.tsx"),
				T = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				N = n("./src/reddit/components/CommentsLink/index.tsx"),
				P = n("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				R = n("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				A = n("./src/reddit/components/ExpandoButton/index.tsx"),
				M = n("./src/reddit/components/Flatlist/index.tsx"),
				D = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				L = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				F = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				U = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				B = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				G = n("./src/reddit/components/ModModeReports/index.tsx"),
				H = n("./src/reddit/components/ModModeReports/helpers.ts"),
				W = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				q = n("./src/reddit/components/OneFeed/PostRecommendationContext.tsx"),
				V = n("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				z = n("./src/reddit/components/PostBadges/index.tsx"),
				K = n("./src/reddit/components/PostContainer/index.tsx"),
				Q = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				J = n("./src/reddit/components/PostLeftRail/index.tsx"),
				Y = n("./src/reddit/components/PostMedia/index.tsx"),
				X = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				Z = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				$ = n("./src/reddit/components/PostTitle/index.tsx"),
				ee = n("./src/reddit/components/PostTopMeta/index.tsx"),
				te = n("./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx"),
				ne = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				se = n("./src/reddit/components/SponsoredLabel/index.tsx"),
				re = n("./src/reddit/components/SubredditIcon/index.tsx"),
				oe = n("./src/reddit/components/VerticalVotes/index.tsx"),
				ae = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				ie = n("./src/reddit/contexts/PageLayer/index.tsx"),
				de = n("./src/reddit/contexts/Post/index.tsx"),
				ce = n("./src/reddit/controls/Checkbox/index.tsx"),
				le = n("./src/reddit/controls/MetaData/index.tsx"),
				ue = n("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				me = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				pe = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				be = n("./src/reddit/helpers/postEvent.ts"),
				he = n("./src/reddit/hooks/useIsOverlay.ts"),
				fe = n("./src/reddit/hooks/useTheme.ts"),
				ge = n("./src/reddit/hooks/useUserContext.ts"),
				_e = n("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				ve = n("./src/reddit/icons/fonts/Report/index.tsx"),
				Oe = n("./src/reddit/selectors/experiments/web2x_cta.ts"),
				xe = n("./src/reddit/selectors/showPromotedCTA.ts"),
				Ee = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				ye = n.n(Ee),
				je = n("./src/reddit/components/CompactPost/index.m.less"),
				Ce = n.n(je);

			function ke() {
				return (ke = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Ie = e => {
					let {
						isCompact: t,
						...n
					} = e;
					return o.a.createElement(A.a, ke({
						className: Object(l.a)(Ce.a.responsiveExpandoButton, {
							[Ce.a.mHideAboveSmallTablets]: !!t,
							[Ce.a.mHideBelowSmallTablets]: !t
						})
					}, n))
				},
				Se = () => Object(d.c)({
					activeModalId: y.a,
					crosspost: k.d,
					flairStyleTemplate: ie.W,
					isActive: k.j,
					isExpanded: k.m,
					showPromotedCTA: xe.a,
					layout: ie.S,
					moderatorPermissions: j.m,
					poll: (e, t) => {
						const n = e.posts.metaMap[t.postId];
						if (n) return e.polls.models[n]
					},
					showEditFlair: C.a,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subreddit: n
						} = t;
						return !!n && Object(j.i)(e, n.id)
					},
					showCTAExperimentDesign: Oe.a
				}),
				we = (e, t) => {
					let {
						postId: n
					} = t;
					return {
						dispatchFlairChanged: t => {
							let {
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							} = t;
							return e(Object(x.h)({
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							}))
						},
						handleVote: t => {
							const s = t === v.a.upvoted ? Object(O.kb)(n) : Object(O.w)(n);
							e(s)
						},
						onIgnoreReports: () => e(Object(O.gb)(n)),
						onOpenReportsDropdown: t => e(Object(E.h)({
							tooltipId: t
						}))
					}
				};
			class Te extends o.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						activeModalId: e,
						className: t,
						currentProfileName: n,
						crosspost: s,
						currentUser: r,
						eventFactory: a,
						flairStyleTemplate: i,
						handleVote: d,
						imageGalleryCurrentItem: u,
						isCheckboxSelected: m = !1,
						isCommentsPage: v,
						isCommentPermalink: O,
						isExpanded: x,
						isGalleryTileLayoutDefault: E,
						isModWithUserNotesPermissions: y,
						isOverlay: j,
						isProfilePostListing: C,
						inSubredditOrProfile: k = !1,
						layout: A,
						moderatorPermissions: Y,
						modModeEnabled: se,
						onClickPost: re,
						onFlairChanged: ie,
						onIgnoreReports: de,
						poll: le,
						post: he,
						subredditOrProfile: fe,
						userIsOp: ge,
						hideModTools: Oe,
						scrollerItemRef: xe,
						showBulkActionCheckbox: Ee,
						showEditFlair: je,
						toggleCheckbox: ke,
						tooltipType: Se,
						sendEvent: we,
						shouldShowGalleryTileOption: Te,
						showPromotedCTA: Pe,
						showCTAExperimentDesign: Re
					} = this.props, Me = !!he.media && he.media.type === g.o.RTJSON, De = ge && Me, Le = Object(Q.b)(he.id, j), Fe = Object(pe.a)(Y), Ue = Object(ue.a)(Y), Be = Object(me.a)(Y), Ge = `-mod-actions-menu-${he.id}`, He = `voting-arrows-${he.id}`, We = !!r && Object(_.e)(r) === he.author, qe = Object(B.a)(he), Ve = Object(H.c)(he), ze = Object(D.a)("View--Reports", he.id, Se), Ke = Object(H.a)(he), Qe = !(j || v || O), Je = he.media && he.media.type === g.o.LIVEVIDEO, Ye = e => we(Object(f.k)(he.id, e)), Xe = Object(c.t)(he, u), {
						source: Ze
					} = Xe, $e = o.a.createElement(K.a, {
						className: Object(l.a)(ye.a.compactPostStyles, Ce.a.postContainer, Object(h.a)(this.props), t),
						isOverlay: j,
						style: {
							...Object(h.d)(this.props),
							...Object(h.b)(this.props.flairStyleTemplate)
						},
						post: he,
						onClick: re,
						eventFactory: a
					}, o.a.createElement("div", {
						className: Ce.a.compactWrapper
					}, o.a.createElement("div", {
						className: Ce.a.leftRailWrapper
					}, o.a.createElement("div", {
						className: Ce.a.leftRail,
						style: {
							borderColor: Object(J.c)({
								isRemoved: !!he.bannedBy,
								isReported: Object(b.a)(he),
								isSponsored: he.isSponsored,
								theme: this.props.theme
							})
						}
					}, Ee && o.a.createElement(ce.a, {
						className: Ce.a.bulkActionCheckbox,
						isCheckboxSelected: m,
						toggleCheckbox: ke
					}), o.a.createElement(oe.a, {
						className: Ce.a.verticalVotes,
						compact: !0,
						flairStyleTemplate: i,
						model: he,
						onVoteClick: d
					}), o.a.createElement(P.a, {
						className: Ce.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: i,
						model: he,
						onVoteClick: d,
						upvoteTooltipId: He
					}))), o.a.createElement(V.a, {
						className: Object(l.a)(Ce.a.content, {
							[Ce.a.isEvent]: Object(be.a)(he)
						}),
						"data-click-id": "background",
						flairStyleTemplate: i
					}, o.a.createElement(R.a, {
						isCompactMode: !0,
						post: he
					}), o.a.createElement("div", {
						className: Ce.a.compactPostRow
					}, !Oe && o.a.createElement(Ie, {
						crosspost: s,
						isCommentsPage: v,
						isCompact: !1,
						isExpanded: x,
						post: he,
						useMediaIcons: !0
					}), !k && !he.isSponsored && o.a.createElement(L.h, {
						type: he.belongsTo.type,
						id: he.belongsTo.id
					}), o.a.createElement("div", {
						className: Ce.a.topLine,
						"data-click-id": "body"
					}, !!he.recommendationContext && o.a.createElement(q.a, {
						content: he.recommendationContext.content,
						layout: p.g.Compact,
						post: he
					}), o.a.createElement($.c, {
						post: he,
						poll: le,
						size: $.b.Small,
						titleColor: i && i.postTitleColor,
						isOverlay: !1
					}), Ae(he, fe), o.a.createElement(ee.d, {
						className: Ce.a.postTopMeta,
						flairStyleTemplate: i,
						isModWithUserNotesPermissions: y,
						post: he,
						showSub: !!fe && !k && !he.isSponsored,
						subredditOrProfile: fe
					}), o.a.createElement(z.a, {
						className: Ce.a.postBadges,
						displayText: fe ? fe.displayText : null,
						inSubredditOrProfile: k,
						post: he
					}), o.a.createElement(w.a, {
						thing: he,
						tooltipType: j ? ee.c.Lightbox : void 0
					})), Qe && !Je && o.a.createElement("div", null, o.a.createElement(T.a, {
						className: Ce.a.liveDiscussionIcon,
						postId: he.postId
					})), !he.isSurveyAd && o.a.createElement("div", {
						className: Ce.a.flatList
					}, o.a.createElement(N.a, {
						className: Ce.a.commentsLink,
						hasModPostPerms: Fe,
						isCommentsPage: v,
						isCommentPermalink: O,
						isOverlay: j,
						postId: he.id,
						modModeEnabled: se,
						numComments: he.numComments,
						type: p.g.Compact
					}), o.a.createElement(W.a, {
						className: Ce.a.modToolsFlatlist,
						isOverlay: !1,
						layout: A,
						modModeEnabled: se,
						post: he,
						sendEvent: we,
						showIconsOnly: !0
					}), Fe && o.a.createElement(F.a, {
						dropdownId: Ge,
						onClick: () => Ye("post_mod_action_menu")
					}, o.a.createElement(M.b, null), o.a.createElement(X.a, {
						canEditFlair: Ue && je,
						hasModPostPerms: Fe,
						hasModFullPerms: Be,
						isOverlay: !1,
						isPostAuthor: We,
						modModeEnabled: se,
						post: he,
						tooltipId: Ge
					})), Fe && Ve && !se && o.a.createElement(ne.c, {
						text: `${Ke}`,
						onClick: () => {
							this.props.onOpenReportsDropdown(ze), Ye("post_report_menu")
						},
						id: ze
					}, o.a.createElement(ae.a, {
						model: he,
						onIgnoreReports: () => {
							de(), Ye(he.ignoreReports ? "restore_reports" : "ignore_reports")
						},
						tooltipId: ze
					}), he.ignoreReports ? o.a.createElement(_e.a, null) : o.a.createElement(ve.a, null)), o.a.createElement(Z.a, {
						currentProfileName: n,
						isCommentsPage: v,
						isOverlay: !1,
						isProfilePostListing: C,
						isRecommendationPost: !!he.recommendationContext,
						layout: A,
						permalink: he.permalink,
						sendEvent: we,
						showEditPost: De,
						showEditFlair: je,
						dropdownId: `${he.id}-overflow-menu`,
						useFlatlistBreakpoints: Object(Z.b)({
							share: !1,
							editPost: !1,
							save: !1,
							gild: !1,
							hide: !1,
							report: !1
						})
					}), !Oe && o.a.createElement(Ie, {
						crosspost: s,
						isCommentsPage: v,
						isCompact: !0,
						isExpanded: x,
						post: he,
						useMediaIcons: !0
					}))), Pe && Ze && Ze.url && !he.isSurveyAd && o.a.createElement(I.a, {
						className: Object(l.a)(Ce.a.adLinkWrapper, {
							[Ce.a.ctaExperiment]: Re
						}),
						ctaExperimentDesign: Re && "compact"
					}, o.a.createElement(S.a, {
						post: he,
						adLinkContent: Xe,
						isCompact: !0,
						ctaExperimentDesign: Re && "compact"
					})), se && Fe && qe && o.a.createElement("div", {
						className: Ce.a.modModeBannerWrapper
					}, o.a.createElement(U.a, {
						thing: he
					})), se && Fe && Ve && o.a.createElement("div", {
						className: Ce.a.modModeBannerWrapper
					}, o.a.createElement(G.a, {
						onIgnoreReports: de,
						reportable: he
					})), o.a.createElement(L.d, null))), x && o.a.createElement(Ne, {
						post: he,
						scrollerItemRef: xe,
						flairStyleTemplate: i,
						shouldShowGalleryTileOption: Te,
						isGalleryTileLayoutDefault: E
					}), e === Le && o.a.createElement(Q.a, {
						flairs: he.flair,
						subredditId: he.belongsTo.id,
						modalId: Le,
						onFlairChanged: ie
					}));
					return o.a.createElement(te.b, null, $e)
				}
			}
			const Ne = e => o.a.createElement(V.a, {
					className: Object(l.a)(e.className, Ce.a.expandedContentWrapper),
					flairStyleTemplate: e.flairStyleTemplate
				}, e.post.crosspostRootId ? o.a.createElement("div", {
					className: Ce.a.crosspostMediaWrapper
				}, Pe(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)) : Pe(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)),
				Pe = (e, t, n, s) => o.a.createElement(Y.a, {
					isExpando: !0,
					isGalleryTileLayoutDefault: s,
					isListing: !0,
					isNotCardView: !0,
					post: e,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					shouldShowGalleryTileOption: n,
					showCentered: !0,
					showFull: !0,
					showPromotedCTA: !0
				}),
				Re = e => o.a.createElement(i.a, {
					"data-click-id": "subreddit",
					to: e.url
				}, o.a.createElement(re.b, {
					className: Ce.a.subredditIcon,
					subredditOrProfile: e
				})),
				Ae = (e, t) => o.a.createElement("div", {
					className: Ce.a.responsiveMeta
				}, o.a.createElement(le.b, {
					isScoreHidden: e.scoreHidden,
					score: e.score
				}), o.a.createElement(le.c, null), Object(le.d)(e.numComments), o.a.createElement(le.c, null), t && o.a.createElement("a", {
					href: t.url
				}, o.a.createElement(le.a, null, t.displayText)), e.isSponsored && [o.a.createElement(se.a, {
					key: "label",
					isSurveyAd: e.isSurveyAd
				}), o.a.createElement(le.c, {
					key: "separator"
				})], !e.isSponsored && o.a.createElement(le.a, null, " ", s.fbt._("Posted by", null, {
					hk: "UqFDR"
				}), " "), o.a.createElement(ee.b, {
					post: e,
					isDeleted: e.author === u.E
				}));
			t.default = Object(de.b)(o.a.memo((function(e) {
				const t = Object(ge.a)(),
					n = Object(r.useMemo)(() => Se(), []),
					s = Object(a.e)(s => n(s, {
						...e,
						...t
					})),
					i = Object(a.d)(),
					d = we(i, {
						...e,
						...t
					});
				return o.a.createElement(Te, ke({}, e, t, s, d, {
					onFlairChanged: t => {
						let {
							previewFlair: n,
							selectedTemplateId: s
						} = t;
						return d.dispatchFlairChanged({
							post: e.post,
							previewFlair: n,
							selectedTemplateId: s
						})
					},
					sendEvent: Object(m.b)(),
					isOverlay: Object(he.a)(),
					theme: Object(fe.a)()
				}))
			})))
		},
		"./src/reddit/components/ConfirmModal/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3DhQ2s_h1XCiwltypHmlbp",
				close: "_2oxgXPm-tiPAEPsJoUw-ZD",
				headerText: "_2sDCzF6zlpNJ5cbVDRCPOS",
				text: "_3eWjwYvkDvPzyq4FlubrF9",
				buttonWrapper: "_6ZHRZ8Epefe887d7LL-q6",
				primaryButton: "Ch-0dFLxLOtcc6xCyQvsk",
				secondaryButton: "bgwHoiDoSwFVZKRTLRQMF"
			}
		},
		"./src/reddit/components/ConfirmModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				i = n("./src/reddit/components/ConfirmModal/index.m.less"),
				d = n.n(i),
				c = n("./src/reddit/components/ModalStyledComponents/index.tsx");
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: d.a.container
			}, r.a.createElement("button", {
				onClick: () => e.onClose ? e.onClose() : e.onCancel(),
				className: d.a.close
			}, r.a.createElement(c.b, null)), r.a.createElement(c.i, null, r.a.createElement("h2", {
				className: d.a.headerText
			}, e.headerText)), r.a.createElement(c.l, null, e.message && r.a.createElement("p", {
				className: d.a.text
			}, e.message), e.children && r.a.createElement("div", {
				className: d.a.text
			}, e.children), r.a.createElement("div", {
				className: d.a.buttonWrapper
			}, e.cancelText && r.a.createElement(a.o, {
				className: d.a.secondaryButton,
				onClick: e.onCancel
			}, e.cancelText), r.a.createElement(a.l, {
				className: d.a.primaryButton,
				onClick: e.onAccept
			}, e.acceptText)))))
		},
		"./src/reddit/components/ConfirmUserActionModal/index.m.less": function(e, t, n) {
			e.exports = {
				buttonWidth: "ogOEj4x-0BpDZWeccJwxx",
				ModalText: "_2YxEi97B6Nm7NCgLG6pCud",
				modalText: "_2YxEi97B6Nm7NCgLG6pCud"
			}
		},
		"./src/reddit/components/ConfirmUserActionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				l = n("./src/reddit/components/ConfirmUserActionModal/index.m.less"),
				u = n.n(l);
			const m = e => e.preventDefault();
			t.a = Object(a.a)(e => o.a.createElement(i.e, null, o.a.createElement(i.i, null, o.a.createElement(c.a, null, o.a.createElement(i.q, null, e.headerText || s.fbt._("Confirm", null, {
				hk: "2zlvKa"
			})), o.a.createElement(d.a, {
				onClick: () => {
					e.onClose && e.onClose(), e.toggleModal && e.toggleModal()
				}
			}, o.a.createElement(i.b, null)))), o.a.createElement(i.l, null, o.a.createElement(i.p, {
				className: u.a.ModalText
			}, e.modalText)), o.a.createElement(i.g, null, !e.hideCancelButton && o.a.createElement(i.a, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: () => {
					e.onCancel && e.onCancel(), e.toggleModal && e.toggleModal()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.cancelActionText || s.fbt._("Cancel", null, {
				hk: "2TSLl5"
			})), o.a.createElement(i.u, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: t => {
					e.onConfirm(), e.toggleModal && e.toggleModal(), e.trackClick && e.trackClick()
				},
				"data-redditstyle": !e.disableRedditStyle,
				disabled: e.isDisabled
			}, e.actionText))))
		},
		"./src/reddit/components/ContentGate/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				buttonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				Container: "_32zGs4bO3IunZfS9bSJY0_",
				container: "_32zGs4bO3IunZfS9bSJY0_",
				ContainerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				containerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				Description: "_3VTI5BOpJO70xoBKSqz3O9",
				description: "_3VTI5BOpJO70xoBKSqz3O9",
				PrivateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				privateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				PrivateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				privateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				PrivateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				privateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				Link: "o4oSRcSrppMzf__hxJKxn",
				link: "o4oSRcSrppMzf__hxJKxn",
				LinkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				linkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				LinkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				linkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				SecondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				secondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				SecondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				secondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				CreateCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				createCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				GoHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				goHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				PrivateKey: "kwHMAzQCDA69TaL3eHZLa",
				privateKey: "kwHMAzQCDA69TaL3eHZLa",
				Image: "_1jefpljVGT-eHObg40F8Dm",
				image: "_1jefpljVGT-eHObg40F8Dm",
				ImagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				imagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				LeftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				leftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				LeftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				leftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				SecondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				secondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				SecondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				secondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				Title: "_2XKLlvmuqdor3RvVbYZfgz",
				title: "_2XKLlvmuqdor3RvVbYZfgz",
				PageBody: "bDDEX4BSkswHAG_45VkFB",
				pageBody: "bDDEX4BSkswHAG_45VkFB",
				InterstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				interstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				ContributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz",
				contributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz"
			}
		},
		"./src/reddit/components/ContentGate/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router/esm/react-router.js"),
				d = n("./src/reddit/contexts/NavbarExp.ts"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/loginHref/index.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/preferences.ts"),
				b = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx"),
				h = n("./src/reddit/components/CreateCommunityButton/index.tsx"),
				f = n("./src/reddit/components/Footer/index.tsx"),
				g = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				_ = n("./src/reddit/components/RichTextJson/index.tsx"),
				v = n("./src/reddit/components/SubredditSearchCarousel/async.tsx"),
				O = n("./node_modules/lodash/flatMap.js"),
				x = n.n(O),
				E = n("./src/lib/linkMatchers/index.ts"),
				y = n("./src/lib/linkMatchers/customLinks.ts"),
				j = n("./src/reddit/controls/OutboundLink/index.tsx");
			const C = /\[(.+?)\]\((.+?)\)/g,
				k = e => {
					const t = e.split(C);
					if (1 === t.length) return [e];
					const n = [];
					for (let s = 0; s < t.length; s += 3) {
						const [e, r, o] = t.slice(s, s + 3);
						n.push(e), n.push([o, r])
					}
					return n
				};
			var I = o.a.memo(e => {
					let t = [e.text];
					return e.parseMdLinks && (t = x()(t, k)), e.parseRegularLinks && (t = x()(t, e => Array.isArray(e) ? [e] : (e => {
						const t = E.f.add(y.g.subreddit.prefix, y.g.subreddit.config).match(e);
						if (!t) return [e];
						const n = [];
						let s = null;
						for (const r of t) n.push(e.slice(s ? s.lastIndex : 0, r.index)), s = r, n.push([r.url, r.text]);
						return s && n.push(e.slice(s.lastIndex)), n
					})(e))), o.a.createElement(o.a.Fragment, null, " ", t.map((t, n) => {
						if (Array.isArray(t)) {
							const [s, r] = t;
							return o.a.createElement(j.b, {
								className: e.linkClassName,
								href: s,
								key: n
							}, r)
						}
						return o.a.createElement("span", {
							key: n
						}, t)
					}), " ")
				}),
				S = n("./src/reddit/constants/parameters.ts"),
				w = n("./src/reddit/contexts/PageLayer/index.tsx"),
				T = n("./src/reddit/controls/Button/index.tsx"),
				N = n("./src/chat/controls/Svg/index.tsx");

			function P() {
				return (P = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var R = e => o.a.createElement(N.a, P({}, e, {
					viewBox: "-1 -1 21 21"
				}), o.a.createElement("path", {
					d: "M16.64,2.32a4.5,4.5,0,0,0-7,5.57L4.85,12.69,3.59,13.95h0L2.34,15.2a1,1,0,0,0,0,1.41l1.25,1.25h0l.42.42a1,1,0,0,0,1.41-1.41L5,16.46H5a.78.78,0,0,1,0-1.09.79.79,0,0,1,1.09,0h0l.42.42a1,1,0,0,0,1.41-1.41L7.52,14h0L7,13.4l4.1-4.1a4.5,4.5,0,0,0,5.57-7Zm-1.41,5a2.5,2.5,0,1,1,0-3.54A2.5,2.5,0,0,1,15.22,7.27Z"
				})),
				A = n("./src/reddit/models/ContentGate.ts"),
				M = n("./src/lib/constants/index.ts"),
				D = n("./src/reddit/selectors/platform.ts"),
				L = n("./src/reddit/selectors/user.ts");
			var F = n("./src/reddit/selectors/meta.ts"),
				U = n("./src/reddit/components/ContentGate/index.m.less"),
				B = n.n(U);
			const {
				fbt: G
			} = n("./node_modules/fbt/lib/FbtPublic.js"), H = l.a.wrapped(R, "PrivateKey", B.a), W = l.a.div("ButtonsContainer", B.a), q = l.a.div("Container", B.a), V = l.a.div("ContainerExp", B.a), z = l.a.div("Description", B.a), K = l.a.div("PrivateSubredditDetails", B.a), Q = l.a.div("PrivateSubredditDescription", B.a), J = l.a.h3("PrivateSubredditName", B.a), Y = l.a.a("Link", B.a), X = l.a.wrapped(T.n, "LinkRouterButton", B.a), Z = l.a.wrapped(T.m, "LinkButton", B.a), $ = l.a.wrapped(T.q, "SecondaryLinkRouterButton", B.a), ee = l.a.wrapped(T.p, "SecondaryLinkButton", B.a), te = l.a.wrapped(X, "GoHomeLinkButton", B.a), ne = l.a.wrapped(h.a, "CreateCommunityButton", B.a), se = l.a.img("Image", B.a), re = l.a.img("ImagePlaceholder", B.a), oe = l.a.wrapped(X, "LeftLinkRouterButton", B.a), ae = l.a.wrapped(Z, "LeftLinkButton", B.a), ie = l.a.wrapped(ee, "SecondaryLeftLinkButton", B.a), de = l.a.wrapped($, "SecondaryLeftLinkRouterButton", B.a), ce = l.a.h3("Title", B.a), le = l.a.div("PageBody", B.a), ue = l.a.div("InterstitialMessageWrapper", B.a), me = Object(c.c)({
				isLoggedIn: L.P,
				origin: F.k,
				user: L.k,
				isPrivateSubredditContributorRequestPending: e => (e => {
					if (!Object(L.Q)(e)) return !1;
					const t = Object(D.d)(e);
					if (!t) return !1;
					const n = Object(L.f)(e, t);
					if (!n) return !1;
					if (!n.privateSubreddit) return !1;
					const {
						isContributorRequestTimestamp: s
					} = n;
					if (!s) return !1;
					const r = 30 * M.B;
					return s > Date.now() - r
				})(e),
				isSeo: F.h
			}), pe = Object(w.u)(), be = Object(a.b)(me, (e, t) => {
				let {
					subredditName: n
				} = t;
				return {
					continueToQuarantinedSubreddit: async () => {
						await e(p.D(n)), window.location.reload()
					},
					continueToGatedSubreddit: async () => {
						await e(p.v(n)), window.location.reload()
					},
					setNSFWPreference: async () => {
						await e(Object(m.o)())
					}
				}
			}), he = e => {
				const {
					banMessage: t,
					contentGateType: n,
					continueToQuarantinedSubreddit: r,
					continueToGatedSubreddit: a,
					isLoggedIn: i,
					isContributorRequestsDisabled: d,
					isPrivateSubredditContributorRequestPending: c,
					isSeo: l,
					location: p,
					origin: h,
					pageLayer: f,
					quarantineRequiresEmail: O,
					quarantineMessage: x,
					quarantineMessageHtml: E,
					quarantineMessageRTJson: y,
					interstitialWarningMessage: j,
					interstitialWarningMessageHtml: C,
					interstitialWarningMessageRTJson: k,
					setNSFWPreference: w,
					subredditDescription: T,
					subredditName: N,
					user: P
				} = e, R = async () => {
					if (i ? await w() : await Object(m.n)(), l) {
						const e = new URL(window.location.href);
						e.searchParams.set(S.f, "1"), window.location.href = e.href
					} else window.location.reload()
				};
				switch (n) {
					case A.a.GoldSubreddit:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/gold/premium-crest.png`
						}), o.a.createElement(ce, null, G._("r/{community name} is a Reddit Premium community", [G._param("community name", N)], {
							hk: "2lyDwB"
						})), o.a.createElement(z, null, G._("The moderators in this community have set it to Reddit Premium members only. You must upgrade to a Reddit Premium membership to continue.", null, {
							hk: "mIiOw"
						})), o.a.createElement(W, null, P ? o.a.createElement(ie, {
							href: `${s.a.redditUrl}/premium`,
							redditStyle: !0
						}, G._("Get Premium", null, {
							hk: "3ChWi4"
						})) : o.a.createElement(ae, {
							href: Object(u.a)(p, h),
							redditStyle: !0
						}, G._("Sign Up", null, {
							hk: "rvpjy"
						})), P ? o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, G._("Go Home", null, {
							hk: "49p4or"
						})) : o.a.createElement(ee, {
							href: Object(u.a)(p, h),
							redditStyle: !0
						}, G._("Log In", null, {
							hk: "4Cxw0g"
						}))));
					case A.a.Nsfw:
					case A.a.NsfwCustomFeed:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/nsfw.png`
						}), o.a.createElement(ce, null, n === A.a.Nsfw ? G._("You must be 18+ to view this community", null, {
							hk: "IQmEA"
						}) : G._("You must be 18+ to view this Custom Feed", null, {
							hk: "3pmHS2"
						})), o.a.createElement(z, null, G._("You must be at least eighteen years old to view this content. Are you over eighteen and willing to see adult content?", null, {
							hk: "gI12S"
						})), o.a.createElement(W, null, o.a.createElement(oe, {
							to: "/",
							redditStyle: !0
						}, G._("No", null, {
							hk: "3fMglW"
						})), o.a.createElement(ee, {
							onClick: R,
							redditStyle: !0
						}, G._("Yes", null, {
							hk: "2hpRkN"
						}))));
					case A.a.PrivateSubreddit:
						return o.a.createElement("div", null, o.a.createElement(H, null), o.a.createElement(ce, null, "r/", N, " ", G._("is a private community", null, {
							hk: "7zZmq"
						})), T && T.length && o.a.createElement(K, null, o.a.createElement(J, null, "r/", N), o.a.createElement(Q, null, o.a.createElement("div", null, T))), o.a.createElement(z, null, G._("The moderators of", null, {
							hk: "3QSrbr"
						}), " ", "r/", N, " ", G._("have set this community as private.", null, {
							hk: "3zhD9F"
						}), o.a.createElement("br", null), G._("Only approved members can view and take part in its discussions.", null, {
							hk: "af0uR"
						})), o.a.createElement(W, null, P ? o.a.createElement(o.a.Fragment, null, !d && o.a.createElement(b.a, {
							eventSource: "content_gate",
							smallButton: !0,
							className: B.a.ContributorRequestButton,
							isContributorRequestPending: c
						}), o.a.createElement(ie, {
							href: `${s.a.redditUrl}/message/compose?to=/r/${N}`,
							redditStyle: !0
						}, G._("Message Mods", null, {
							hk: "vVe1i"
						}))) : o.a.createElement(ie, {
							href: Object(u.a)(p, h),
							redditStyle: !0
						}, G._("Sign Up", null, {
							hk: "rvpjy"
						})), o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, G._("Browse Reddit", null, {
							hk: "1fi8kh"
						}))), N && o.a.createElement(v.a, {
							subredditName: N
						}));
					case A.a.QuarantinedSubreddit:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/quarantined.png`
						}), o.a.createElement(ce, null, G._("Are you sure you want to view this community?", null, {
							hk: "2BtxLM"
						})), o.a.createElement(z, null, G._("This community is {=quarantined}", [G._param("=quarantined", o.a.createElement(Y, {
							href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/quarantined-subreddits"
						}, G._("quarantined", null, {
							hk: "2XqfJa"
						})))], {
							hk: "2B9i8y"
						}), o.a.createElement(ue, null, y ? o.a.createElement(_.b, {
							content: y,
							rtJsonElementProps: {
								pageLayer: f
							}
						}) : E ? o.a.createElement(g.a, {
							html: E
						}) : x || G._("Quarantined communities are dedicated to shocking or highly offensive content. You must be logged in with a verified email to continue.", null, {
							hk: "3kRIzE"
						})), G._("Are you certain you want to continue?", null, {
							hk: "1gr5Bw"
						})), o.a.createElement(W, null, ((e, t, n) => {
							return !(e && e.hasVerifiedEmail) && n ? o.a.createElement(W, null, o.a.createElement(de, {
								to: "/",
								redditStyle: !0
							}, G._("No Thank You", null, {
								hk: "4B26AR"
							})), o.a.createElement(Z, {
								href: `${s.a.redditUrl}/prefs/update`,
								redditStyle: !0
							}, G._("Verify Email", null, {
								hk: "1893cq"
							}))) : o.a.createElement(W, null, o.a.createElement(oe, {
								to: "/",
								redditStyle: !0
							}, G._("No Thank You", null, {
								hk: "4B26AR"
							})), o.a.createElement(ee, {
								onClick: t,
								redditStyle: !0
							}, G._("Continue", null, {
								hk: "4nU0mS"
							})))
						})(P, r, O)));
					case A.a.GatedSubreddit:
						return o.a.createElement("div", null, o.a.createElement(ce, null, G._("Are you sure you want to view this community?", null, {
							hk: "1K5UIm"
						})), o.a.createElement(z, null, o.a.createElement(ue, null, k ? o.a.createElement(_.b, {
							content: k,
							rtJsonElementProps: {
								pageLayer: f
							}
						}) : C ? o.a.createElement(g.a, {
							html: C
						}) : j), G._("Are you certain you want to continue?", null, {
							hk: "3pT969"
						})), o.a.createElement(W, null, o.a.createElement(oe, {
							to: "/",
							redditStyle: !0
						}, G._("No Thank You", null, {
							hk: "4B26AR"
						})), o.a.createElement(ee, {
							onClick: a,
							redditStyle: !0
						}, G._("Continue", null, {
							hk: "2rLyAk"
						}))));
					case A.a.SubredditBanned:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/banned.png`
						}), o.a.createElement(ce, null, G._("r/{community name} has been banned from Reddit", [G._param("community name", N)], {
							hk: "2at9Se"
						})), (e => o.a.createElement(z, null, e ? o.a.createElement(I, {
							linkClassName: B.a.Link,
							text: e,
							parseMdLinks: !0,
							parseRegularLinks: !0
						}) : G._("This community has been banned for violating the Reddit rules.", null, {
							hk: "3iUVxA"
						})))(t), o.a.createElement(W, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, G._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case A.a.SubredditBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, G._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "4bCnhl"
						})), o.a.createElement(W, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, G._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case A.a.SubredditDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement(re, null), o.a.createElement(ce, null, G._("Sorry, there arent any communities on Reddit with that name.", null, {
							hk: "31DRpe"
						})), o.a.createElement(z, null, G._("This community may have been banned or the community name is incorrect.", null, {
							hk: "1lYMG2"
						})), o.a.createElement(W, null, P && o.a.createElement(ne, {
							eventSource: "content_gate"
						}), o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, G._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.ProfileDoesNotExist:
					case A.a.ProfileDeleted:
					case A.a.ProfileSuspended:
					case A.a.ProfileBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, (e => {
							const {
								contentGateType: t
							} = e;
							switch (t) {
								case A.a.ProfileBlockedForLegalReason:
									return G._("This content has been restricted in your country in response to a legal request.", null, {
										hk: "4eeylO"
									});
								case A.a.ProfileDeleted:
									return G._("This user has deleted their account.", null, {
										hk: "2IAF6m"
									});
								case A.a.ProfileSuspended:
									return o.a.createElement(o.a.Fragment, null, G._("This account has been {=suspended} .", [G._param("=suspended", o.a.createElement(Y, {
										href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/suspensions"
									}, G._("suspended", null, {
										hk: "3nHGgi"
									})))], {
										hk: "4cuTBS"
									}));
								case A.a.ProfileDoesNotExist:
									return o.a.createElement(o.a.Fragment, null, o.a.createElement(ce, null, G._("Sorry, nobody on Reddit goes by that name.", null, {
										hk: "3i02av"
									})), o.a.createElement(z, null, G._("The person may have been banned or the username is incorrect.", null, {
										hk: "36ab4J"
									})))
							}
						})(e)), o.a.createElement(W, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, G._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.CustomFeedDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, G._("Sorry, this custom feed is private or does not exist.", null, {
							hk: "2Ml4j9"
						})), o.a.createElement(W, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, G._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.PostBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, G._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "1q1rVU"
						})), o.a.createElement(W, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, G._("Browse Reddit", null, {
							hk: "1XnYmj"
						}))))
				}
			};
			t.default = pe(be(Object(i.i)(e => {
				const t = Object(r.useContext)(d.a) ? V : q;
				return o.a.createElement(t, null, o.a.createElement("div", {
					"data-testid": "content-gate"
				}, o.a.createElement(le, null, he(e))), o.a.createElement(f.b, null))
			})))
		},
		"./src/reddit/components/ContentSurvey/RatingCard.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/components/ContentSurvey/index.m.less"),
				i = n.n(a),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/SubredditIcon/index.tsx"),
				l = n("./src/reddit/hooks/useTheme.ts"),
				u = n("./src/reddit/icons/svgs/Info/index.tsx"),
				m = n("./src/reddit/models/Theme/index.ts"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/selectors/subreddit.ts");
			const {
				fbt: h
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function f(e) {
				var t, n;
				const {
					ratingResponse: s,
					subredditId: a,
					children: f
				} = e, g = null !== (t = Object(o.e)(e => Object(b.U)(e, {
					subredditId: a
				}))) && void 0 !== t ? t : {}, _ = Object(l.a)();
				return r.a.createElement("div", {
					className: i.a.ratingCard
				}, "PENDING" === (null == s ? void 0 : s.status) && r.a.createElement("div", {
					className: Object(d.a)(i.a.card, i.a.pending)
				}, r.a.createElement(u.a, {
					className: i.a.infoIcon
				}), h._("Content tag is pending until reviewed", null, {
					hk: "Umha7"
				})), r.a.createElement("div", {
					className: i.a.card
				}, r.a.createElement("div", {
					className: i.a.banner,
					style: {
						background: Object(m.g)(Object(p.a)({
							theme: _
						}).banner.backgroundColor, Object(p.a)({
							theme: _
						}).banner.backgroundImage, Object(p.a)({
							theme: _
						}).banner.backgroundImagePosition)
					}
				}, r.a.createElement(c.b, {
					className: i.a.communityIcon,
					iconUrl: null === (n = g.icon) || void 0 === n ? void 0 : n.url
				})), r.a.createElement("h3", {
					className: i.a.communityName
				}, s ? r.a.createElement("span", null, g.displayText, r.a.createElement("img", {
					className: i.a.ratingImg,
					src: s.rating.icon.png
				})) : g.displayText), f))
			}
		},
		"./src/reddit/components/ContentSurvey/SurveyModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/higherOrderComponents/asModal/index.tsx");
			const o = Object(s.a)({
					resolved: {},
					chunkName: () => "",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e(6), n.e(8)]).then(n.bind(null, "./src/reddit/components/ContentSurvey/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ContentSurvey/index.tsx"
					}
				}),
				a = Object(r.a)(o);
			t.a = a
		},
		"./src/reddit/components/ContentSurvey/index.m.less": function(e, t, n) {
			e.exports = {
				feedBanner: "_3oY2sjcQ7EgBYd7agqleJv",
				notepadSnoo: "B0cLCCVs794x74kjJidDO",
				bannerCopy: "_2NfcId0Mtt4-NP4AbrAck5",
				copy: "BcSr5zM39F4cQJ9MQqkRn",
				meta: "r9AkMaLWOPKfC5Swx9XQf",
				chevron: "yFbNzMMxa-u2DgUP3Gz5h",
				header: "wKkshJ3Og8gaDgJmSULiK",
				introCopy: "m3rT-KnA6An7scRNg10UW",
				checkbox: "Y5aDAUsXXQaMbdCe1-qdG",
				result: "_29ewfEVekvKEl_P2hqf4tI",
				heading: "_3yKTUBG4MrGHv9n644t4Ua",
				card: "_18VT-IpGoX6SDdyHHLI_eo",
				pending: "hg80uiMz2ssH44RLsmlhG",
				infoIcon: "_3HgNBpJCFAy2mohcd9VxmZ",
				banner: "_23eBsXSECZlQ3Eh-zXhEbC",
				communityIcon: "_2Z8cRxGvjX2hQUlQK_VEOE",
				communityName: "_1sHP__xe_7iTbSpLKp7FeC",
				ratingImg: "UZWqo3i6ydUcE18iJqx3P",
				ratingAudience: "_1Y5aAemcMRF3uwSgYpqbsT",
				ratingDescription: "_1e5wHYsIyWJlZSjZCHhBKg",
				reasonsHeader: "_1npcgCYHbRcUsU6KOI7ony",
				reason: "_3rlzPcuZsxLsVx6ib3oBjk"
			}
		},
		"./src/reddit/components/ContentTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				styledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				fadeIn: "_2bkYZH_kJx5pIHW0Ts5P6e",
				caretOnBottom: "_1rF-A55THyDL-rQ9ZUDQ4_",
				caretOnTop: "_1MHCyMQAMeqRqf5DPWWeq3",
				hideCaret: "dExJJiXRwxVrKsDJRWSQl",
				caretOnLeft: "nVD-oexLbZI_4QjhrkLFz",
				caretOnRight: "KRVDnoE1RIC5qyqQLXxGG"
			}
		},
		"./src/reddit/components/ContentTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/lib/fastdom/index.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = n("./src/reddit/selectors/tooltip.ts"),
				b = n("./src/reddit/components/ContentTooltip/index.m.less"),
				h = n.n(b);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const g = {
					height: 200,
					width: 200
				},
				_ = e => {
					switch (e) {
						case "top":
							return "bottom";
						case "right":
							return "left";
						case "left":
							return "right";
						case "bottom":
						default:
							return "top"
					}
				},
				v = Object(c.a)(e => {
					const {
						children: t,
						className: n,
						style: s,
						caretPosition: r,
						caretColor: a,
						onClick: i,
						hideCaret: c
					} = e;
					return o.a.createElement("div", {
						onClick: i,
						className: Object(d.a)(n, h.a.StyledTooltipContainer, {
							[h.a.caretOnTop]: "top" === r,
							[h.a.caretOnLeft]: "left" === r,
							[h.a.caretOnRight]: "right" === r,
							[h.a.caretOnBottom]: "bottom" === r,
							[h.a.hideCaret]: c
						}),
						style: {
							...s,
							"--contentTooltip-caretColor": a && a[r] ? a[r] : Object(m.a)(e).body
						}
					}, t)
				}),
				O = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(p.b)(n)(e)
					}
				}),
				x = Object(u.a)(v, [s.a.Click, s.a.Keydown]),
				E = Object(a.b)(O);
			class y extends o.a.Component {
				constructor(e) {
					super(e), this.checkAndSetPosition = () => {
						const {
							tooltipId: e,
							tooltipSizeEstimate: t = g
						} = this.props;
						l.a.read(() => {
							const n = document.getElementById(e);
							if (!n) return;
							const s = n.getBoundingClientRect();
							if (!("undefined" != typeof window)) return void this.setState({
								position: this.props.defaultTooltipPosition
							});
							let r = !0;
							switch (this.props.defaultTooltipPosition) {
								case "bottom":
									r = window.innerHeight - s.bottom > t.height;
									break;
								case "left":
									r = s.left > t.width;
									break;
								case "right":
									r = s.right <= window.innerWidth - t.width;
									break;
								case "top":
								default:
									r = s.top > t.height
							}
							this.setState({
								position: r ? this.props.defaultTooltipPosition : _(this.props.defaultTooltipPosition)
							})
						})
					}, this.state = {
						position: null
					}
				}
				componentDidUpdate(e) {
					!e.isOpen && this.props.isOpen && this.checkAndSetPosition(), e.isOpen && !this.props.isOpen && this.setState({
						position: null
					})
				}
				getPositions(e) {
					switch (e || this.props.defaultTooltipPosition) {
						case "bottom":
							return {
								tooltipPosition: ["center", "top"], targetPosition: ["center", "bottom"], caretPosition: "top"
							};
						case "left":
							return {
								tooltipPosition: ["right", "center"], targetPosition: ["left", "center"], caretPosition: "right"
							};
						case "right":
							return {
								tooltipPosition: ["left", "center"], targetPosition: ["right", "center"], caretPosition: "left"
							};
						case "top":
						default:
							return {
								tooltipPosition: ["center", "bottom"], targetPosition: ["center", "top"], caretPosition: "bottom"
							}
					}
				}
				render() {
					const {
						position: e
					} = this.state, {
						targetPosition: t,
						tooltipPosition: n,
						caretPosition: s
					} = this.getPositions(e);
					return o.a.createElement(x, f({}, this.props, {
						caretPosition: s,
						targetPosition: t,
						tooltipPosition: n
					}))
				}
			}
			t.a = E(y)
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ContributorRequestButton",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ContributorRequestButton").then(n.bind(null, "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CountAnimation/index.m.less": function(e, t, n) {
			e.exports = {
				countAnimation: "_3z5CnRH3l7hQGI8TQYFyqX",
				digitDeltaWrapper: "WBY6J5DJsZFZXSxBqtq0F",
				digitDelta: "_3LT2yD0gRFklddn3Ra9ElD",
				"sr-only": "D6SuXeSnAAagG8dKAb4O4",
				srOnly: "D6SuXeSnAAagG8dKAb4O4"
			}
		},
		"./src/reddit/components/CountAnimation/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/hooks/usePrevious.ts"),
				a = n("./src/realtime/GQLSubscription/async.tsx"),
				i = n("./src/reddit/hooks/useIntersectionObserver.ts");
			const d = e => {
				return Math.abs(e).toString().split("").map(e => parseInt(e))
			};
			var c = n("./src/reddit/components/CountAnimation/index.m.less"),
				l = n.n(c);
			var u;
			! function(e) {
				e.Vote = "vote", e.Comment = "comment"
			}(u || (u = {}));
			const m = () => 0;
			t.b = e => {
				const {
					countToUpperBound: t,
					featureName: n,
					incrementDelta: c,
					initialDelay: u,
					initialDisplayCount: p,
					isLoadTestOnly: b,
					onDataCB: h,
					postId: f,
					queryKey: g,
					queryVariables: _,
					shouldDisjointAnimation: v,
					subsequentRecurringDelay: O
				} = e, [x, E] = Object(s.useState)(!1), [y, j] = Object(s.useState)(!0), [C, k] = Object(s.useState)([]), [I, S] = Object(s.useState)(d(p).reverse()), w = Object(s.useRef)(!1), T = Object(s.useRef)(null), N = Object(s.useRef)(e => {}), P = Object(s.useRef)();
				N.current = Object(s.useCallback)(e => {
					let n = e || c();
					const s = [...I].reverse().join("");
					let r = parseInt(s) + n;
					r > t && (n = t - parseInt(s), r = t);
					const o = d(r).reverse();
					E(!1), k(I), S(o), j(!1), P.current = setTimeout(() => {
						E(!0)
					}, 0)
				}, [t, c, I]);
				const R = Object(s.useRef)(() => {}),
					A = Object(s.useRef)(),
					M = Object(s.useRef)();
				R.current = Object(s.useCallback)(() => {
					M.current = setTimeout(() => {
						N.current();
						const e = [...C].reverse().join("");
						parseInt(e) < t && R.current()
					}, O())
				}, [t, O, C]);
				const D = Object(s.useRef)(0),
					L = Object(s.useRef)(!1),
					F = Object(s.useCallback)(e => {
						e.forEach(e => {
							const {
								isIntersecting: t,
								intersectionRatio: n
							} = e, s = 1 !== n;
							t ? (L.current = !0, w.current || (w.current = !0, A.current = setTimeout(() => {
								N.current(), R.current()
							}, u())), D.current > 0 && (N.current(D.current), D.current = 0)) : s && (L.current = !1)
						})
					}, []);
				Object(i.a)(T, F);
				const [U, B] = Object(s.useState)(!1), G = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? B(!0) : s && B(!1)
					})
				}, []), H = Object(s.useRef)({
					rootMargin: "2000px 0px 2000px 0px"
				});
				Object(i.a)(T, G, H.current);
				const W = Object(o.a)(t);
				Object(s.useEffect)(() => {
					if (void 0 !== W && W !== t) {
						const e = t - W;
						L.current ? N.current(e) : D.current += e
					}
					return () => {
						clearTimeout(A.current), clearTimeout(M.current), clearTimeout(P.current)
					}
				}, [t]);
				const q = Object(s.useCallback)(() => j(!0), [j]),
					V = 0 === C.length,
					z = y || V,
					K = Object(s.useRef)(((e, t) => `${t}_${e}_count_anim`)(f, n));
				return r.a.createElement(r.a.Fragment, null, !b && r.a.createElement("div", {
					className: l.a.countAnimation
				}, I.map((e, t) => {
					const n = ((e, t) => {
						let n = Math.abs(e);
						const s = Math.abs(t),
							r = [n];
						if (n === s) return r;
						let o = !0;
						for (; o;) ++n > 9 && (n = 0), r.push(n), n === s && (o = !1);
						return r
					})(C[t] || 0, e);
					return r.a.createElement("span", {
						"aria-hidden": !0,
						className: l.a.digitDeltaWrapper,
						key: t,
						onTransitionEnd: q,
						style: x && C.length > 0 && !y ? {
							transform: `translateY(-${v&&n.length>1?100:100*(n.length-1)}%)`,
							transitionDuration: `${(v?500:750)/1e3}s`
						} : {
							transform: "translateY(0)"
						}
					}, z ? r.a.createElement("span", {
						className: l.a.digitDelta
					}, e) : n.map((e, t) => {
						const s = 0 === t || t === n.length - 1;
						if (!v || v && s) return r.a.createElement("span", {
							className: l.a.digitDelta,
							key: t
						}, e)
					}).filter(e => !!e))
				}), r.a.createElement("span", {
					className: l.a.srOnly,
					role: "screen-reader"
				}, [...I].reverse().join(""))), r.a.createElement("span", {
					ref: T
				}), U && r.a.createElement(a.a, {
					variables: _,
					onData: b ? m : h,
					queryKey: g,
					uniqueKey: K.current
				}))
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltip: "FIYolDqalszTnjjNfThfT",
				styledTooltip: "FIYolDqalszTnjjNfThfT"
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/constants/modals.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				f = n("./src/reddit/components/CreateCommunityButton/index.m.less"),
				g = n.n(f),
				_ = n("./src/lib/lessComponent.tsx");
			const v = "create-community-button",
				O = _.a.wrapped(l.c, "StyledTooltip", g.a),
				x = Object(i.c)({
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(h.pb)(e),
					userIsSuspended: h.X
				});
			t.a = Object(a.b)(x, (e, t) => {
				let {
					eventSource: n
				} = t;
				return {
					openCommunityCreation: t => {
						t(Object(b.c)(n)), e(Object(d.h)(m.a.SUBREDDIT_CREATION_MODAL_ID))
					},
					onShowTooltip: () => e(Object(c.f)({
						tooltipId: v
					})),
					onHideTooltip: () => e(Object(c.i)())
				}
			})(Object(u.c)(e => {
				let {
					className: t,
					eventSource: n,
					onShowTooltip: r,
					onHideTooltip: a,
					openCommunityCreation: i,
					sendEvent: d,
					userDoesNotHaveEnoughExpToCreateCommunity: c,
					userIsSuspended: l,
					onClick: u
				} = e;
				return o.a.createElement(p.t, {
					className: t,
					disabled: l || c,
					onClick: e => {
						u && u(e), i(d)
					},
					onMouseEnter: r,
					onMouseLeave: a,
					priority: p.c.Secondary,
					id: v,
					isFullWidth: !0
				}, s.fbt._("Create Community", null, {
					hk: "28v7Qq"
				}), c ? o.a.createElement(O, {
					caretOnTop: !0,
					tooltipId: v,
					text: s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "2R1OXu"
					})
				}) : l ? o.a.createElement(O, {
					caretOnTop: !0,
					tooltipId: v,
					text: s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "2xBDEw"
					})
				}) : null)
			}))
		},
		"./src/reddit/components/CreatorStats/Icon.m.less": function(e, t, n) {
			e.exports = {
				icon: "D7SJKwX8OlPkNjhgXO71s"
			}
		},
		"./src/reddit/components/CreatorStats/Icon.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/icons.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/selectors/subreddit.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/components/CreatorStats/Icon.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					postCreated: t,
					subredditId: n
				} = e;
				const l = Object(a.e)(e => n ? Object(d.U)(e, {
						subredditId: n
					}) : void 0),
					[m, p] = Object(r.useState)(!0);
				return Object(r.useEffect)(() => {
					let e = !0;
					if (void 0 !== t) {
						const n = Object(c.e)(t);
						e = e && !n
					}
					if (void 0 !== l) {
						const t = l.isQuarantined;
						e = e && !t
					}
					p(e)
				}, [t, l]), o.a.createElement(i.a, {
					name: s.a.statistics,
					className: m ? u.a.icon : void 0
				})
			}
		},
		"./src/reddit/components/CreatorStats/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = 16374492e5,
				o = 45 * s.B;
			var a;
			! function(e) {
				e.NotAvailableYet = "NotAvailableYet", e.NotAvailable = "NotAvailable", e.Available = "Available", e.Expired = "Expired", e.Quarantined = "Quarantined"
			}(a || (a = {}));
			const i = e => {
					return e < Date.now() - o
				},
				d = e => e > r,
				c = (e, t, n, s) => {
					if (!n && !d(e.created)) return a.NotAvailable;
					if (n && !d(e.created) || i(e.created)) return a.Expired;
					if (n && s) return a.Quarantined;
					if (!t) return a.NotAvailableYet;
					const {
						shareAllCountTotals: r,
						shareCopyCountTotals: o,
						viewCountTotals: c,
						viewCountTrends: l
					} = t;
					return (null == r ? void 0 : r.availability.isAvailable) && (null == o ? void 0 : o.availability.isAvailable) && (null == c ? void 0 : c.availability.isAvailable) && (null == l ? void 0 : l.availability.isAvailable) && l.data && 0 !== l.data.length ? !(null == c ? void 0 : c.totalCount) || c.totalCount < 10 ? a.NotAvailableYet : a.Available : a.NotAvailableYet
				}
		},
		"./src/reddit/components/CreatorStats/loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "CreatorStats",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("CreatorStats").then(n.bind(null, "./src/reddit/components/CreatorStats/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CreatorStats/index.tsx"
				}
			})
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, n) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return j
			})), n.d(t, "a", (function() {
				return C
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/lib/prettyPrintNumber/index.ts"),
				u = n("./src/reddit/components/Media/index.tsx"),
				m = n("./src/reddit/components/PostMeta/index.tsx"),
				p = n("./src/reddit/components/PostTitle/index.tsx"),
				b = n("./src/reddit/components/SourceLink/index.tsx"),
				h = n("./src/reddit/components/Thumbnail/index.tsx"),
				f = n("./src/lib/constants/index.ts"),
				g = n("./src/reddit/contexts/Post/index.tsx"),
				_ = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/components/CrosspostBox/index.m.less"),
				x = n.n(O),
				E = n("./src/lib/lessComponent.tsx");

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const j = 8,
				C = 1,
				k = E.a.div("Container", x.a),
				I = E.a.div("PostMetaWrapper", x.a),
				S = E.a.wrapped(p.c, "PostTitle", x.a),
				w = E.a.div("FlatList", x.a),
				T = E.a.div("FlatItem", x.a),
				N = E.a.span("FlatListDotSpacer", x.a),
				P = E.a.wrapped(k, "LinkContainer", x.a),
				R = E.a.div("Content", x.a),
				A = E.a.div("ThumbnailContainer", x.a),
				M = Object(d.c)({
					isCurrentUserProfilePost: _.l,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== f.Nb.TOPIC),
					shouldOpenPostInNewTab: v.jb
				}),
				D = Object(a.b)(M);
			t.c = Object(g.b)(D(e => {
				const {
					className: t,
					isCurrentUserProfilePost: n,
					isTopicPage: s,
					mediaProps: r,
					post: a,
					subredditOrProfile: i
				} = e;
				if (!a) return null;
				const d = {
						post: a,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: n,
						isTopicPage: s,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: i,
						tooltipType: `CrosspostBox--${r.isListing}`
					},
					c = t;
				return a && !a.media ? o.a.createElement(P, {
					className: c
				}, o.a.createElement(R, null, o.a.createElement(I, null, o.a.createElement(m.a, d)), L(a), a.source && o.a.createElement(b.a, {
					post: a
				}), U(e)), G(e)) : o.a.createElement(k, {
					className: c
				}, o.a.createElement(I, null, o.a.createElement(m.a, d)), L(a), F(e), U(e))
			}));
			const L = e => o.a.createElement(S, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: p.b.Small
				}),
				F = e => {
					const {
						mediaProps: t,
						post: n
					} = e, s = {
						...t,
						post: n,
						crosspost: t.post
					};
					return o.a.createElement("div", null, o.a.createElement(u.a, y({}, s, {
						className: x.a.mediaContainer,
						scrollerItemRef: t.scrollerItemRef
					})))
				},
				U = e => {
					const {
						post: t
					} = e, {
						score: n
					} = t;
					return o.a.createElement(w, null, o.a.createElement(T, null, s.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [s.fbt._plural(n, "point count", Object(l.b)(n))], {
						hk: "PNZhd"
					})), o.a.createElement(N, null), o.a.createElement(T, null, B(e)))
				},
				B = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: n
					} = e, {
						numComments: r
					} = t;
					return o.a.createElement(i.a, {
						"data-click-id": "comments",
						to: Object(c.a)(t.permalink, !0),
						target: n ? "_blank" : void 0
					}, s.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [s.fbt._plural(r, "comment count", Object(l.b)(r))], {
						hk: "xPYWL"
					}))
				},
				G = e => o.a.createElement(A, null, o.a.createElement(h.a, {
					post: e.post
				}))
		},
		"./src/reddit/components/CrosspostRecommendationsModal/constants.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "crosspost_recommendations_modal_id",
				r = 3e3
		},
		"./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return v
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/constants/experiments.ts"),
				d = n("./src/reddit/constants/localStorage.ts"),
				c = n("./src/reddit/hooks/useExperimentVariant.ts"),
				l = n("./src/reddit/hooks/useLocalStorage.ts"),
				u = n("./src/reddit/hooks/useMounted.ts"),
				m = n("./src/reddit/selectors/platform.ts"),
				p = n("./src/reddit/selectors/subreddit.ts");
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const b = new Set(["antievilplayground", "dirtyr4r", "amitheasshole", "gonewild", "advice", "askreddit", "legaladvice", "trueoffmychest", "ishowspeed", "needysluts", "sex", "freekarma4u", "sluttyconfessions", "preguntaleareddit", "nolawrus", "freekarma4you", "askgaybros", "worldpolitics", "videos", "dreamgenderlove", "atheism", "manga", "anime", "wichsbros3", "ladybonersgw", "sugarmommas", "cumsluts", "travel", "confessions", "tooafraidtoask", "israelexposed", "tiktokthots", "clashofclans", "ama", "tribute_girls_i_know", "christianity", "changemyview", "ratemyboobs", "xboxone", "fortnitebr", "straightturnedgay", "sissies", "funny", "femboy", "place", "virgin", "apexlegends", "gaming", "incestconfessions", "tipofmytongue", "dirtysocialmedia", "normalnudes", "piracy", "askgaymen", "unpopularopinion", "mildlyinfuriating", "conspiracy", "gtaonline", "slutsofonlyfans", "askscience", "wtf", "stepn", "newmexico_nsfw", "banvideogames", "dogecoin", "personalfinancecanada", "askarussian", "mildlyinteresting", "naughtyonlyfans", "deutschepornos", "deadbydaylight", "twitch", "wow", "meetpeople", "askwomenadvice", "dadshouldbeproud", "onlyfansxxx", "techsupport", "offmychest", "twitchtributes", "fortnite", "nebraskanudes", "ohiohookups", "branlette_entre_potes", "jokes", "findfashion", "onlyfanscollabs", "biology", "germany", "skincareaddiction", "bitcoin", "onlyfanshottest", "confession", "punhetabr", "onlyfansamateurs", "iphone", "assistance", "baseballcards", "jailbreak", "sugarmamma", "mexico", "yugioh", "aww", "casualuk", "mapporn", "dating", "seduction", "plasticsurgery", "hardwareswap", "gonewildonlyfans", "summonerswar", "juicyonlyfans", "movies", "tifu", "scams", "sluttyonlyfans", "nintendo", "tipofmypenis", "television", "destiny2", "pcmasterrace", "onlyfanschicks", "escapefromtarkov", "antilolitary", "sugarbabygroup", "dating_advice", "hotonlyfans", "chess", "asknyc", "skyrim", "warthunder", "rape_hentai", "mlbtheshow", "ginalaitschek_", "julesboringlifevideos", "nsfw_tributes", "sugarmommyclub", "asktransgender", "safemoon", "ps5", "austin", "destinythegame", "askengineers", "autism", "coachella", "degradethispig", "playrust", "deutschetributes", "michigantitties", "nftexchange", "pornid", "australia", "cats", "dreamwastaken2", "legaladvicecanada", "bettercallsaul", "motorcycles", "hearthstone", "wonderlands", "watches", "noelleleyvahot", "cumarmy", "programming", "philadelphiar4r", "naughtychicks", "fantomfoundation", "casualiama", "ubereats", "coins", "nashvilleswingersr4r", "youtube", "seaofthieves", "legaladviceofftopic", "tradenudesnolimits", "generationstation", "help", "dykesgonewild", "bodybuilding", "askredditafterdark", "comicbooks", "stuffers", "juliabeautxnew", "touhou", "writing", "librandu", "genshin_impact", "2007scape", "blatantmisogyny", "dreamwastaken", "cocaine", "askanamerican", "ukraineinvasionvideos", "earthporn", "army", "povertyfinance", "rant", "lululemon", "celebasspussymouth", "grandorder", "gamedev", "germancelebritiesfap2", "morbosypajas", "moonknight", "femboys", "polls", "btc", "cooking", "coffee", "pokemon", "pennsylvaniar4r", "nosleep", "lego", "casero", "cincinnatiohiogirls", "ethereum", "mtgfinance", "rocketleague", "sixers", "suicidewatch", "maiaknight", "poland", "crappydesign", "halo", "buildapc", "kingdomhearts", "foodporn", "ufos", "cumtributeee", "publicfreakout", "depression", "peytoncoffee_nsfw", "showerthoughts", "curvy", "de", "vent", "mikeadriano", "ontarioswingers", "bitcoinbeginners", "overwatch", "dadsandboys", "mbti", "amateurgirlsbigcocks", "finland", "6ix9ine", "fatfire", "magictcg", "the8bitryanreddit", "adorableonlyfans", "oddlyterrifying", "memes", "tinder", "bigtiddygothgf", "wrestlefap", "creepypms", "parenting", "askphysics", "celebsarg", "southdakotar4r", "college", "nofap", "serbia", "etsysellers", "gloryholelocations", "marylandr4r", "starwars", "batman", "forzahorizon", "twitter", "gwcouples", "allhoesmatter", "wildrift", "bad_cop_no_donut", "idiotsincars", "scotland", "ghosts", "femboyhentai", "shrooms", "bangalore", "politically_nsfw", "spiderman", "ontariocanada", "askdocs", "nystateofmind", "kitchenconfidential", "bbw", "medical", "incestfucking", "theimaginednsfw", "running", "tulsar4r", "fanfiction", "samplesize", "hextcg", "askhr", "btd6", "footballmanagergames", "hasan_piker", "askto", "lifeprotips", "beyondthebump", "loseit", "methodsandjuggs", "gamingcirclejerk", "phinvest", "askagerman", "ucla", "momforaminute", "askphilosophy", "modsupport", "trees", "pidigroscul", "newswithjingjing", "tihi", "codcompetitive", "naruto", "magicarena", "nascar", "rustconsole", "lawschool", "machinelearning", "coinbase", "askfeminists", "neoliberal", "politicalcompassmemes", "amithebuttface", "cursedcomments", "texansgonewild", "realestate", "meme", "gardening", "alabamar4r", "music", "irelandgonewild", "juuicyjordan", "glocks", "juicyasians", "collegerant", "jordanpeterson", "fetishbuyerscommunity", "iwantout", "ww2", "watchpeopledieinside", "tiktoknsfw", "bourbon", "classicwow", "sextoys", "oklahomar4r", "yumi_waifu", "dubai", "dualipafapclub", "hingeapp", "languagelearning", "poker", "uscis", "wordpress", "utahswingers", "facepalm", "debateanatheist", "latestagecapitalism", "hololive", "timberwolves", "egg_irl", "exchristian", "abdl", "pregnant", "oculusnsfw", "truerateme", "agedlikemilk", "askredditespanol", "lifehacks", "airdrie", "grindr", "massivecock", "debateavegan", "thefighterandthekid", "figureskating", "clashofclansleaks", "madfut", "rapekink", "castlecrashers", "cyprus", "godzilla", "piratedgames", "walmart", "guitar", "radiology", "academicpsychology", "shitpostxiv", "privacy", "skyrimmods", "pornfree", "guitarporn", "jrpg", "paymoneywubby", "questions", "lawofattraction", "drawforme", "gaybros", "premierleague", "prius", "soccercirclejerk", "tattoo", "teenagersbuthot", "art", "performium", "worldnews", "terraluna", "unexpected", "feminineboys", "mmabetting", "turningred", "hawaiiswingers", "swingers", "consulting", "sugarlifestyleforum", "dogtraining", "shittydarksouls", "masterduel", "psychic", "rpdrdrama", "serbiancringe", "rpscommunity", "mommit", "smite", "gettingbigger", "emogirls", "apple", "saudiarabia", "binichdasarschloch", "helpmefind", "germansgonewild", "eldenbling", "funnyanimals", "dragonball", "sexpolls", "muslimlounge", "photography", "popculturechat", "washingtondc", "aspergers", "tampa", "gabygardez2", "optometry", "peakyblinders", "celebritycumtributes", "assholedesign", "coprophiles", "gamecollecting", "tax", "quebec", "escortclientsonly", "paag", "prolife", "environment", "nft", "vaushv", "nftcollect", "eyeblech", "sacramento", "smallpenishumiliation", "buttcoin", "fire", "bumble", "texas", "bitcoincashsv", "damnthatsinteresting", "celebnsfw", "hentai_gif", "freecompliments", "confidentlyincorrect", "socialjusticeinaction", "destiny", "truscum", "laclippers", "truechristian", "justneckbeardthings", "satoshibets", "iamatotalpieceofshit", "atlantahawks", "mtf", "landlord", "truefmk", "trashy", "shitposting", "boxoffice", "amiugly", "gothsluts", "04twerkin", "dealflags", "dealparty", "comingdeals", "surprisediscounts", "horny", "raidcelebration", "famil", "snapchatsingles_xxx", "anticommie", "snapchatsext_", "louisianagonewild", "sypherpk", "losangelesswingers", "rateme", "blackedfantasy", "morbius", "indianahookup", "cousinfuckers_2", "steamtradingmods", "smalldickhumiliation", "sacramentor4r", "pennsylvaniadirtyr4r", "real_life_ladies", "addison_rae_worship", "deutschevideos", "kentuckygonewild", "churchofthebbc", "sissykik2", "german_kahis", "celebcucking", "minnesotar4r", "portlandsex", "michigangw", "hornyamateurgirls", "cock", "lasvegasxxxparties", "corpuschristinsfw", "drewdurnil", "wickrforhotteens", "wixbrosneu2", "dadsgonewild", "stlouisgw", "dmmeporn", "britneyyyofficial__", "phr4r", "julesboringlife_hot", "omahanudes", "sukihannagoat", "taliamarcumtribut", "columbushookups", "erayileboslugadogru", "oregonhookups", "whootyclappers", "californiahookupsex", "shadowban", "ukpakibeautyv2", "calii", "nashvillegw", "fifa", "ratemycock", "massachusettsfreaks", "sanantonioswingers", "mngonewild", "georgiaswingers", "atlantology", "famosasgifs", "julesboringlife1", "indieheads", "wixbros_nsfw", "aradiroff", "deutschememes", "mississippihookups", "ratorix", "bpdlovedones", "arizonansfw", "gameassets", "tiktoklive", "malaysia", "cassiiemelindaxxx", "elpasoswings", "newhampshiresex", "warframe", "onlyifshespackin", "bombshellbra", "cencalgonewild", "cuckbetchallenge", "misogynygonewild", "tanyateyhanna", "thighzone", "missouri_r4r", "anykinks", "arizonahookups", "cuckoldparadise", "grenbaud", "louisianasex", "nvidia", "sandiegonsfwpt2", "socialmediachicks", "unsentletters", "wickr_jerkrs", "theestallion", "tributo_br", "unicornswingers", "learnprogramming", "kentuckyr4r", "mother_son_incest", "chicagohookup", "jaliyah", "sanjosegonewild", "toribrixx2", "dallashookups", "bodyswap", "asiangirls4whitecocks", "fredericksburgonewild", "indianansfw", "nsfwgg", "wetpussys", "amateurgonewildplus", "londonr4r", "gaysnapchat", "bibisbeautypalacehott", "dakotagonzalez", "highandhorny", "ilgabbrone", "malutrevejoonlyfans", "mba", "zargoryangalaksisi", "coloradosex", "bigtiddiegothgirls", "daniellemcqueennn", "gaykik", "phr4friends", "slaveworld", "vevecollectables", "construction", "youtubehaiku", "datascience", "dylangonzalez", "socalswingers", "illinoisswingers", "showercoffee", "umurafan", "wisconsinswingers", "fortworthhookups", "hentaiandroleplayy", "trap", "refunduk", "naughtymediachicks", "osugame", "baddieviral", "boobsbetweenarms", "calango", "elpasoratedr", "onlyliveslips", "pickone", "qcofleak", "dnb", "germancelebfeet", "uncommonposes", "dommesforsissies", "guysfrombehind", "nudetrades01", "louisianaswingers", "onlineaffairs", "auntnsfw", "ayonnarenee", "cuckikofficial", "fatpussylovers", "mdmamollygonewild", "men_in_panties", "perfectdick", "pornselected", "southcarolinaswingers", "texascuckoldcommunity", "thotnetwork", "whatsthatbook", "raceplay", "krissummrs", "philadelphiagonewild", "physics", "misogynisticlife", "sggirls", "onlyfans_naked", "clashofclansrecruit", "cubandasavage", "filipinohotties", "jacksucksatlife", "marylandhookups", "sdhookups", "sissygermany", "sjr4r", "snapchatdiscussion", "symbaserothick", "tabooempirex", "xfibiiiund15cellystuf", "hottiesoftvandyt", "imkung_fulove", "shezbooteeful", "pokemontcg", "adultcontentcreator", "andyousayblm", "dojacatfans", "elizaluv", "german_cumtribute", "happycuckold", "herpespics", "kentuckyhookups", "kpoptributes", "leaeluig", "missourimilfs", "pantiesfetish", "sellingnudesxx", "snapsexting1", "thatkittygurll", "basketballcards", "hiphopheads", "xxfitness", "knockmeup", "trianglestrategy", "endthefurryhate", "gainesviller4r", "albuquerquehookup", "audiobooks_knigachet", "beelcitosmemes", "bloxymemes", "bot_test66", "broslikeus", "cocktribute", "coloradosluts", "coloradoswingers", "comfybuthorny", "concentrates", "emo", "fofocah", "frenchfilles", "hayday", "iam_amarie", "incestdoujinshi", "kopiernudeln", "lubatv", "michiganpussy", "minicompetition", "nerf", "portlandhookups", "shamelessplug", "surveyexchange", "thundapawg", "whereisthis", "amd", "fridaynighthighjinks", "homeimprovement", "nomansskythegame", "thegirlsurvivalguide", "femdomselfies", "freekarma4all", "socialhoes", "tiktokclap", "residentevil", "xbox", "afkarena", "brittneyhoney", "newyorkthotclub", "guildwars2", "houstonhookups", "adhdwomen", "alabamaswingerreal", "babycousinspotlights", "blackedmilfs", "branletteentrebi_", "cxxxxstfuuu", "dirtyphoenixr4r", "freakyhoesforever", "fresnoafterdark", "gangbangporno", "goosiest", "gwgirls4girls", "juliabeautxnsfw2", "lightskinkeishaa", "lolaclr_vms", "lostmedia", "mzstandingovation", "nickiminajbody", "onlyfanssales101", "puredata", "real_onlyfans", "repostingrisk", "tucsonazgw", "wichsende", "brandonde", "house", "animecumtributes", "deepintoyoutube", "miyamarie", "sandyycheekssssof", "washingtongw", "javahelp", "navy", "wwegames", "backpacking", "worldbuilding", "columbiaschookups", "psnfriends", "activitati_si_jocuri", "adele_grisoni", "alahnalypics", "apsarabazaar", "arizonagirls", "charliedmealio18", "ctgonewild2", "degradebollywhore3", "deutschenudez", "dirtysexykikpals", "ethothub", "fabriziocerrone", "gaypaypigs", "germanpornstuff", "graffiti", "jakertown", "krunkerio", "laredotx_nsfw", "multitasker", "ponytails", "refereum", "sidehustleideas", "smurfdomuca", "snapcaps", "snapchatsext_1826", "stuffpeoplebuy", "swensfw", "amberlynnsnark", "apexuniversity", "brawlhalla", "forcedbreeding", "thesilphroad", "advertiseeverything", "desimom", "mariamalkk", "nudetrading2", "brawlstars", "electricians", "terraria", "angelwrld", "worshiptaylorswift", "crushes", "gachaclub", "legostarwarsvideogame", "mercari", "playstationplus", "memesita", "airdropalertcom", "alienswingers", "amigas_gostosas", "angelakinseyjerk", "angelbrothel", "azswingers", "bellyexpansion", "boisesex", "chegganswers", "deutschporntiktok", "dilarahava", "dragonballlegends", "dreddxxx", "gayinceststory", "gaymexico", "geileumfragen", "hookups_nepal", "hookupsfs", "houston", "ineedthatass", "j0eistestingh1snewb0t", "jadaamornsfw", "kansasswingers", "kyliejennerpics", "perthnaughtyfun", "pokemongo", "promote", "puberty", "punegw", "retrogaming", "sextsnap", "sissy_heaven", "snapchathoez", "stellacox", "sunraybee", "upvote", "veterinary", "wisconsinhookup", "aggies", "airforce", "bigdickjoy", "celebswithpetitetits", "deutschesissys", "flipping", "golf", "lean", "milfie", "singleparents", "tacoma", "tewbre", "vinyl", "wrestlefaptributes", "bhadyayaof", "diamondmonroe1", "evansvillensfw", "nsfwskype", "rapperasses", "tay_5_", "android", "askmath", "petsimulatorx", "camgirlproblems", "tvtoohigh", "frenchgonewild", "rpfr_anim_celebrite", "pokemoncards", "1004ko", "airdroprating", "armsupporn", "asiangaypornplace", "azgonewild", "bahrain", "bullysfuckyourmom", "bunniemmie", "celebroleplay", "darkviperau", "denvergw", "destinyfashion", "dickslips", "dubaiencounters", "ebayselleradvice", "enneagram", "faceofpain", "felps", "fighters", "gaycumsluts", "gayrateme", "goldiemrsperfect", "greenbayhookup", "incestobrazil", "jana_librahot", "kennedycymone_", "luvtheflexgw", "malluhorny", "metalgearsolid", "michigandate", "milwaukee_gone_wild", "mississippir4r", "mollymaensfwnew", "ohiopersonals", "orlandoswingers", "overheardsex", "pahookups", "paolaparente", "passiveincome", "photographs", "pnw_4_adults", "rapefantasies2", "referalcodesforfree", "roadtrip", "rock", "sextingfun", "smilingsluts", "tampar4r", "louisvuitton", "plex", "stardustcrusaders", "freakywhitewomen", "germannsfwboerse", "scholarships", "snapchatstreaks", "hardstyle", "horror", "lawyertalk", "boardgames", "iowansfw", "penis", "arifletcherv2", "dannygonzalez", "kalibugandito", "pinaywalker", "wikicatcoin", "cookierunkingdoms", "mira004", "berlinsocialclub", "kokkorohentai", "mousereview", "ajar_malaysia", "aothentai", "arabshentai", "assholegonewild", "awaitingcum", "batonrougeslutclub", "beastierp", "blackpornlegends", "businessintelligence", "buyingcontent", "carrot_cake_nude2", "celebwouldyourather", "cockheadlovers", "dallasr4r", "dariomocciatwitch", "daytonohiohookup", "ebonydsls", "ediblebuttholes", "elizabetholsenfans", "embarrassedyiff", "f4m1", "fambase", "followforfollow", "fortniteleaks", "gabriellaannalisaa", "hentaitrades", "himawarinsfww", "houstonswingers", "imaginarymaps", "jodiecalussionlyfan", "juliabayonetta", "kansashookupss", "katstickler", "kindafunny", "kykilo", "livensfwnow", "locochon", "macrofetish", "manifestationin", "marryfuckkillcelebs", "marylandadultparty", "mathematics", "midlandtxhookups", "nakedandfunnygirls", "naturalpenis", "phillyhookup", "polishinflucumtribute", "pornaddiction", "pupplay", "sissytribute", "sklaven", "southcarolinansfw", "spotifyplaylists", "suckdaddysballs", "tanmaybhatkedost", "theresaxre_official_", "tightywhities", "trovo", "truth", "westtexasmeets", "whopperme4", "barber", "camping", "csharp", "dentalhygiene", "hypixelskyblock", "liminalspace", "ludwigahgren", "musictheory", "rapbattles", "sexypolishyoutuber", "wowservers", "bangaloregw", "bengalimomsonfantasy", "bludsuc1", "college_homework", "missouriswingers3", "schwul_iel", "starlink", "thabootygawduss", "3ds", "amithedevil", "audioengineering", "cinematography", "jawsurgery", "moviesanywhere", "disability", "kenya", "cyberpunkgame", "diablo", "polyamoryr4r", "ask", "oculus", "screenwriting", "bigboobsgw", "saturnstormcube", "teenleaksnew", "polygonmoonshots", "xrptrader", "bttcoin", "uniswap", "shitcoin", "polygon", "polygonnfts", "bsc", "nearprotocol", "lowcapcryptogems", "nothowgirlswork", "cryptocurrencyclassic", "dogelonarmy", "poocoin", "justiceserved", "ethereumnoobies", "amandacernyonlyfans", "solanax", "watchitfortheplot", "blondegirlsfucking", "byebyejob", "shibadults", "bitcoinabc", "technews", "bsclorax", "coingecko", "binance_lawsuit", "trxhub", "binanceexchange", "bnbtrader", "luna", "btcnews", "galacoin", "thatsinsane", "dot", "arbitrage", "shitcoinstreet", "babydogearmy", "hitbtc", "coronavirus", "shibainucoin", "boredapeyachtclub", "bscarmy", "cryptomarketsbet", "altcoin_news", "metaverse_blockchain", "dodge", "sushiswap", "cryptotofuture", "defi_", "loopring", "bestofredditorupdates", "enjincoin", "solananft", "cryptodevs", "adaxpro", "bscbomb_crypto", "filecoin", "memecoinnews", "moonbeam", "moonhunters", "oceanprotocol", "originprotocol", "uuex", "betterbitcoin", "cryptoall", "cryptocurrencyoffers", "helium", "manacoin", "harmony_markets", "doubangoosegroup", "defisignals", "marswallstreet", "safepal", "cryptomooncoins", "findapath", "illnessfakers", "raiblocks", "cryptogamesnft", "satoshistreetsbets", "polkadot_io", "meirl", "thebidenshitshow", "litecoinmining", "cryptocurrencydefi", "bnbcash", "criptomonede", "qtum", "legitgemhunters", "transformation", "bnbbets", "aave_official", "cryptomator", "milliontoken", "tronuprising", "bsclistings", "guro", "cryptotax", "ohlympics", "notinteresting", "bi_irl", "cryptocurrencygems", "shitamericanssay", "fitgirls", "bnbinance", "economy", "hentai", "hilariabaldwin", "crt_so_scary", "chiliz", "mississippi", "babydogecoin", "cryptomarsmoonshots", "deficryptos", "loomnetwork", "landlordlove", "thickthighs", "yearn_finance", "gentlefemdom", "cryptosoul", "solana", "dogelon", "cryptomars", "bsccryptolistings", "toiletpaperusa", "enlightenedcentrism", "samoyedcoin", "spotted", "asiansgonewild", "canadapolitics", "cro", "defi", "killingeve", "vvsfinance", "tinyman", "cryptography", "pitbullhate", "makemycoffin", "fightsticks", "benshapiro", "grandrapids", "openseanft", "fedexers", "cryptostreetbets", "realmadrid", "cryptogemdiscovery", "dogemining", "kpopfap", "shib", "allcryptobets", "cryptomarsshots", "interestingasfuck", "economics", "redscarepod", "gme_meltdown", "nextfuckinglevel", "openseamarket", "nftmarketplace", "lostgeneration", "psychology", "antinatalism", "communismmemes", "bostonceltics", "books", "rule34", "historymemes", "comics", "crazyfuckingvideos", "cryptomoon", "technology", "ukraina", "cryptocurrencyico", "trueatheism", "clevelandcavs", "ico", "atletico", "selfawarewolves", "anarcho_capitalism", "exhindu", "israelpalestine", "denvernuggets", "memphisgrizzlies", "nbayoungboy", "ccw", "memepiece", "gaymers", "lesbianactually", "actuallesbians", "asexuality", "bisexual", "malefashionadvice", "malehairadvice", "gay", "femalefashionadvice", "lingerieaddiction", "twoxsex", "accutane", "ausskincare", "beards", "haircarescience", "tattoos", "abcdesis", "asablackman", "asexual", "ausfemalefashion", "awfuleyebrows", "beauty", "beautydiagrams", "bigboobproblems", "blackculture", "blackhair", "blackpeople", "climbergirls", "curlyhair", "lacqueristas", "makeup", "muacirclejerk", "naturalhair", "nopoo", "redditlaqueristas", "transbeauty", "vaginismus", "xxketo", "transgender", "girlgamers", "honesttransgender", "acne", "chickflixxx", "eczema", "blackpeoplegifs", "veganbeauty", "blackgirls", "fancyfollicles", "abrathatfits", "africanhistory", "australianmakeup", "beautytalkph", "ladiesofscience", "makeupaddictionuk", "sweden", "tumblrinaction", "nyyankees", "ohio", "outoftheloop", "tech", "australianpolitics", "futurology", "hololewd", "ithinkyoushouldleave", "workersstrikeback", "askaliberal", "awfuleverything", "losangeles", "celebs", "basedislamists", "shanghai", "whatcouldgowrong", "kanye", "yimo", "dankmemes", "catholicism", "lolitary", "hawaii", "sadcringe", "actualpublicfreakouts", "blowjobs", "banned4life", "furry", "darkjokes", "kidsarefuckingstupid", "lawschooladmissions", "persecutionfetish", "teachers", "space", "dankleft", "muslumanturk", "aznidentity", "debatereligion", "insurance", "sexstories", "paris", "beamazed", "programmerhumor", "financialindependence", "tiktokcringe", "mhahentai", "tja", "entertainment", "nhl", "playboicarti", "ssbm", "abruptchaos", "decentraland", "extomatoes", "battlejackets", "starbucks", "arethestraightsok", "hentaibondage", "monstergirl", "leafs", "maybemaybemaybe", "oldschoolcool", "reactiongifs", "sikh", "waifuism", "dmt", "inceltear", "loveforlandlords", "trishyland", "kiwisavengers", "china_irl", "winstupidprizes", "askouija", "girlskissing", "historyporn", "serialpodcast", "amptoken", "childfree", "indiandankmemes", "overwatchtmz", "transpassing", "tumblr", "debatevaccines", "greentext", "shitpoliticssays", "openchristian", "aberdeen", "arethecisok", "celebritybutts", "contagiouslaughter", "rarepuppers", "warhammer30k", "binance", "oddlysatisfying", "studentloans", "summertimesaga", "bdsmpersonals", "legendsofruneterra", "moviedetails", "hardware", "transgenderuk", "absoluteunits", "pitbulls", "redditmoment", "ufc", "suns", "solarpunk", "youtubersgonewild", "aboringdystopia", "bdsmcommunity", "deadbedrooms", "workingmoms", "bloodborne", "mcfc", "bdsm", "asianmasculinity", "deepthroat", "pandr", "playboy", "schaffrillas", "wholesomememes", "rareinsults", "starwarscantina", "90s", "homestead", "kosovo", "rolex", "fightporn", "xboxinsiders", "lotrmemes", "askmiddleeast", "bonehealingjuice", "dementia", "law", "saintmeghanmarkle", "stopdrinking", "yiff", "adviceanimals", "nolapelicans", "sleepapnea", "toradora", "vore", "pornstarescort", "reptime", "acab", "politicaldiscussion", "amcstock", "gaysoundsshitposts", "sinfest", "brooklyn", "terriblefacebookmemes", "newyorkmets", "wayofthebern", "adoptmerbx", "askacanadian", "askhistorians", "dndmemes", "lostredditors", "antilgbtq", "prequelmemes", "hindutvawatch", "pamedicalmarijuana", "askspain", "baddragon", "dayz", "newyorkcity", "nootropics", "thelastairbender", "azurlewd", "petioles", "pokemonbdsp", "raisedbynarcissists", "singaporeraw", "streamersgonewild", "vexillologycirclejerk", "youtubetitties", "jeep", "netherlands", "religion", "funpiece", "gachagaming", "joi", "undertale", "asroma", "blessedimages", "celebritypussy", "edanonymemes", "jav", "seamonkeys", "aphextwin", "business", "enoughpetersonspam", "jocat", "mealtimevideos", "transsocialism", "saltierthancrait", "sissycaptions", "dc_cinematic", "adultery", "belarus", "fo76", "diabetes_t1", "abortion", "billieeilishgw", "doujinshi", "funsized", "futanaripegging", "nio", "tili", "fragilemaleredditor", "houseofthedragon", "spiders", "straightpegging", "muslimmarriage", "survivinginfidelity", "cycling", "victoria3", "wellthatsucks", "asklosangeles", "strangerthings", "kendricklamar", "popping", "animalcrossing", "target", "biggerthanherhead", "bluray", "hugedildos", "maher", "pokemonart", "yesyesyesno", "algeria", "entrepreneur", "genshin_impact_leaks", "lesbians", "peds", "scjerk", "traphentai", "askle", "breastenvy", "dccomicscirclejerk", "evangelion", "iasip", "lockdownskepticism", "talktherapy", "ukbabes", "writingcirclejerk", "blender", "gunaccessoriesforsale", "stocks", "cybersecurity", "tf2", "badchoicesgoodstories", "cltv", "courtneytailorhub", "covid19", "feminism", "genshin_memepact", "labouruk", "queervexillology", "suspiciouslyspecific", "thetrumpzone", "instagramreality", "izlam", "medical_advice", "newyorknine", "noahgettheboat", "tankporn", "topmindsofreddit", "coronabr", "cricket", "hugeboobshardcore", "sakartvelo", "theleftcantmeme", "theultimatumnetflix", "torontorealestate", "trippieredd", "tryingforababy", "incelexit", "incest", "attackonretards", "liverpoolfc", "muslim", "the10thdentist", "wallstreetsilver", "lakers", "royalehightrading", "sadboys", "taxpros", "agender", "futadomworld", "keskustelu", "lewdgames", "me_irl", "missoula", "emulation", "fetishsellersforum", "fuckyoukaren", "hijabis", "hpv", "joinsquad", "kazakhstan", "kurdistan", "lds", "libertarianmeme", "masskillers", "northernireland", "prematurefetish", "truesph", "armenia", "nsfw", "trashtaste", "amsterdam", "borderlands3", "chrischansonichu", "ftm", "hairtransplants", "socialskills", "teslamodel3", "energy", "windows11", "yeagerbomb", "askconservatives", "bicycling", "elderscrollsonline", "exismailis", "animemilfs", "chaoticgood", "chastity", "dadjokes", "death_by_snusnu", "internationalleft", "kentucky", "netorare", "severanceappletvplus", "suicidegirls", "tiktokcringetime", "tucker_carlson", "wgbeforeafter", "xmen", "ayato_mains", "genshinimpactnsfw", "goldenretrievers", "houseplants", "nintendowaifus", "ootp", "starterpacks", "translater", "vet", "bondage", "erotichypnosis", "plussize", "relacionamentos", "trueratecelebrities", "uwaterloo", "youngpeopleyoutube", "daniellarson", "belgium", "wearethemusicmakers", "accidentalally", "afghan", "aroundthenfl", "bdsmerotica", "chennai", "clevercomebacks", "copenhagen", "coronavirus_nz", "indianews", "justrolledintotheshop", "murderedbyaoc", "nonbinary", "progressive_islam", "proship", "purplepilldebate", "recruitinghell", "stevenaveryisguilty", "conspiracy_commons", "edmontonoilers", "fireindia", "gadgets", "gangstalking", "gay_irl", "iptv", "supplements", "urantia", "money", "oakville", "phenotypes", "transplace", "anime_irl", "bollywood", "chicagobulls", "enoughmuskspam", "newworldgame", "nofapchristians", "nuclear", "redsox", "rwby", "addiction", "aoe2", "fuckyourbicycle", "guitarpedals", "vegas", "aliens", "dankinindia", "juicewrld", "norge", "taskmaster", "austria", "warhammercompetitive", "asktrumpsupporters", "bidenisnotmypresident", "bikinibottomtwitter", "breakingmom", "covid19positive", "eroticliterature", "genshinimpacthentai", "groupofnudegirls", "happyendingmassage", "healthygamergg", "heyimbee_sfw", "japaneseporn2", "leftistvexillology", "moldymemes", "oklahoma", "playarkservers", "polska_wpz", "ukinvesting", "wfh", "antitheistcheesecake", "fresno", "newyorkislanders", "nsfwgaming", "phallo", "pornoinromana", "publix", "rebubble", "sciencebasedparenting", "scuba", "texasrangers", "travisscott", "averagedickproblems", "dancegavindance", "realtesla", "seinfeld", "stripper", "windows10", "90dayfiance", "algorand", "applehelp", "auslegal", "ballbusting", "joerogan", "martialarts", "popheadscirclejerk", "trueunpopularopinion", "wikipedia", "witcher3", "yourmomshousepodcast", "fakecartridges", "fantasypl", "fragreddit", "jujutsukaisen", "nostalgia", "shitpostcrusaders", "vindictaratecelebs", "atheistexperience", "celinasmith", "discgolf", "gunners", "speedrun", "creditcards", "nashville", "barrie", "blackmagicfuckery", "canadianconservative", "churning", "collared", "conservatives", "cracksmokers", "credibledefense", "demonslayer34", "dutchgonewild", "femdomcommunity", "forwardsfromgrandma", "fuckamazon", "guessmyage", "knoxville", "librarians", "makemesuffer", "maliciouscompliance", "nsfw_japan", "okmarijuana", "rule34_comics", "russophobiawatch", "spacefrogs", "starwarsnsfw", "teenmomogandteenmom2", "the_pack", "toocuteforporn", "vindictarateme", "virginiapolitics", "xenogendersandmore", "arianagrande", "bellypunchingchamber", "bigseo", "cantax", "catfish", "cringe", "fightingfakenews", "howto", "indianfood", "indoorgarden", "ksi", "medicalgore", "michigents", "minecraftchampionship", "nfl_draft", "peoplefuckingdying", "pizzacrimes", "retailhell", "shittymoviedetails", "taiwan", "ukdrill", "votedem", "winnipegmusicscene", "bodydysmorphia", "demonssouls", "linuxmasterrace", "mkebucks", "professors", "stardewvalley", "streetfighter", "ukrainewarreports", "animalsbeingjerks", "godsunchained", "mac", "mensa", "padres", "primeiraliga", "rants", "reno", "spacexlounge", "youtooz", "3dshacks", "airsoft", "bimbofication", "etsy", "ladiesofwrestling", "mycology", "seltinsweety", "switchpirates", "whowouldwin", "maine", "marvel", "mavericks", "self", "unpopularkpopopinions", "huntshowdown", "airbnb", "brandonherrara", "chastitytraining", "crossstitch", "datingoverthirty", "diamonds", "drogasbrazilrebooted", "femalehairadvice", "gatekeeping", "halifax", "hentaibeast", "jjdandfamily", "kotakuinaction", "leavingneverlandhbo", "litrpg", "modafinil", "nsfwfunny", "ptsd", "regularcarreviews", "republicanvalues", "rhodeisland", "smashrage", "spacex", "tappedout", "teslamodely", "theamazingrace", "uoguelph", "worldofpvp", "youshouldknow", "americabad", "astrologyreadings", "brandnewsentence", "bulgaria", "canadianforces", "completeanarchy", "cyberpunk", "elderscrolls", "entitledparents", "etsystrike", "globeskepticism", "infp", "intermittentfasting", "loopringorg", "redscareforcishetmen", "spells", "ucsd", "adhdmeme", "amazonfc", "askparents", "assassinscreed", "cheating_stories", "dodgers", "eicerb", "evolution", "gonewildtrans", "hangukin", "keto", "linuxquestions", "marvelmemes", "nbaspurs", "outerwilds", "phillies", "shittyfoodporn", "smalldickproblems", "starcraft", "theamericans", "vamscenes", "whatisthiscar", "worldoftanks", "colombia", "edc", "financialplanning", "jamesbond", "kerala", "persona5", "rabm", "uktrees", "unimelb", "bigdickproblems", "clopclop", "dundermifflin", "gymnastics", "hollowknight", "testosterone", "virginiagonewild", "ausfinance", "campinggear", "celsiusnetwork", "discordapp", "hockeyplayers", "japanlife", "weightgain", "edm", "ardspotd", "balticssrs", "bokoen1", "celebsbr", "chinalife", "deltarune", "diablo2resurrected", "dogfreehumor", "forwardsfromklandma", "geschichtsmaimais", "gothgirls", "gtfo", "koreanfood", "lincoln", "memevideos", "mopeio", "mylittlepony", "narcissisticparents", "nevillegoddard", "nsfwcyoa", "offlinetvgirls", "pandemicpreps", "philosophy", "pickoneceleb", "piltoversfinest", "pinkomega", "schoolfight", "spiderbro", "systemscringe", "tallahassee", "titfuck", "transgenderau", "trustapp", "trustwalletcommunity", "turkishchicks", "virtualyoutubers", "wallstreetbetsogs", "weird", "whitesox", "woahdude", "anarchychess", "aoe3", "auckland", "bdsmadvice", "bettafish", "cosplaybutts", "cvs", "diablo2", "eremika", "galatasaray", "german", "howyoudoin", "malefashion", "moderatepolitics", "moretankie196", "namenerds", "piratefolk", "plotholes", "pokemongofriends", "portugalcaralho", "ragnarokonline", "sexyfrex", "shitmomgroupssay", "skateboarding", "sorare", "thunder", "tigerbelly", "ubreddit", "unket", "agegap", "anorexianervosa", "argentina", "blursedimages", "buffalo", "christian", "delta", "dndnext", "grime", "hermanmiller", "jizzedtothis", "rapefantasies", "riddles", "russiangirls", "startrekdiscovery", "ateistturk", "buddhism", "choosingbeggars", "cruise", "hmmm", "illegallysmolcats", "immigrationcanada", "ismailis", "mortalkombat", "oculusquest", "short", "torontobluejays", "truegaming", "warzone", "deathgrips", "edinburgh", "germanrap", "linguistics", "marijuanaenthusiasts", "medicalschool", "northcarolina", "pennsylvania", "raiders", "raidshadowlegends", "simracingstewards", "survivor", "berserklejerk", "tfablineporn", "unethicallifeprotips", "ups", "berkeley", "filmmakers", "hamster", "market76", "mechanicalkeyboards", "networking", "worldnews2", "1000ccplus", "90dayfianceuncensored", "aaaaaaacccccccce", "alcoholicsanonymous", "alltheleft", "amd_stock", "asiancuties", "askfrance", "bolehland", "bonersinpublic", "caps", "childrenfallingover", "chloe", "columbiyeah", "comedyheaven", "damngoodinterracial", "disturbedmedia", "eldenrule34", "excatholic", "fcbayern", "femboy_irl", "gamepaddigital", "gaybrosgonemild", "genshinhacked", "hentaibondagetales", "hyderabad", "lactation", "leangains", "mewgulf_the_series", "minipainting", "mschvs", "nsfwcelebs", "perfectlycutscreams", "pokemonconspiracies", "pornstarsonpoles", "progun", "publicfreakouts", "re_zero", "redpillwomen", "saltierthankrayt", "scatporn2", "sleepycabin", "tgirls", "thelastkingdom", "thepaknarrative", "throatpies", "veganfoodporn", "warplaneporn", "alaskaairlines", "androidquestions", "askculinary", "canadacoronavirus", "es", "fantheories", "harley", "homeowners", "macdemarco", "mechanicadvice", "mintmobile", "panthers", "pokemonunite", "porsche", "purdue", "rotc", "sexualassault", "teamfourstar", "veteransbenefits", "worldcup", "chat", "chickens", "competitiveoverwatch", "emulationonandroid", "indianapolis", "instantkarma", "marvellegends", "outdoors", "prettypussypage", "puppy101", "quant", "r4rtoronto", "stupidfood", "swedishproblems", "tressless", "yeat_", "academicbiblical", "askprofessors", "boruto", "detroitlions", "dividends", "emory", "expats", "premed", "psych", "quityourbullshit", "smashbros", "snakes", "spain", "thebatmanfilm", "totalwar", "xxxtentacion", "broadway", "cringepics", "glasgow", "iphonehelp", "learnjapanese", "minecraftsuggestions", "monsterdicks", "okcupid", "spyxfamily", "suddenlygay", "ubc", "archlinux", "bmw", "equestrian", "gamestop", "home", "mmfinance", "nbacirclejerk", "chemistry", "flexigirls", "lsd", "realonlyfansreviews"]);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function f() {
				return Object(c.a)(i.X) === i.xd
			}

			function g() {
				return function(e) {
					let {
						storageKey: t,
						setValueOnDismiss: n,
						checkIfDismissed: s
					} = e;
					const r = f(),
						a = Object(o.e)(m.e),
						[i, c] = Object(l.a)(d.b.CROWD_CONTROL_CAMPAIGN_STORE, {}),
						h = Object(o.e)(e => Object(p.W)(e, null == a ? void 0 : a.id)),
						g = Object(u.a)(),
						_ = !(!a || !b.has(a.name.toLowerCase())),
						v = !1 === (null == h ? void 0 : h.crowdControlFilter) && 0 === (null == h ? void 0 : h.crowdControlPostLevel),
						O = !s(i[t]);
					return {
						showCrowdControlCampaign: g && r && _ && v && O,
						dismissCrowdControlCampaign: () => c({
							...i,
							[t]: n()
						})
					}
				}({
					storageKey: "hideModQueueCTAUntil",
					setValueOnDismiss: () => Date.now() + 30 * a.B,
					checkIfDismissed: e => !!e && Date.now() < e
				})
			}

			function _() {
				return {
					showCrowdControlCampaign: f()
				}
			}

			function v(e) {
				function t(t) {
					const {
						showCrowdControlCampaign: n
					} = _();
					return r.a.createElement(e, h({}, t, {
						showCrowdControlCampaign: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `CrowdControlCampaignNewTag(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/Econ/Audio/MuteIcon.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					id: "icons_flat",
					"data-name": "icons flat"
				}, r.a.createElement("path", {
					d: "M13.5,9.5v-5A3.493,3.493,0,0,0,6.723,3.3l6.724,6.723A3.524,3.524,0,0,0,13.5,9.5Z"
				}), r.a.createElement("path", {
					d: "M15.5,9.5a5.472,5.472,0,0,1-.436,2.144l1.487,1.486A7.428,7.428,0,0,0,17.5,9.5Z"
				}), r.a.createElement("path", {
					d: "M2.341,4.1,6.5,8.258V9.5A3.5,3.5,0,0,0,10,13a3.441,3.441,0,0,0,1.059-.183l1.529,1.529A5.449,5.449,0,0,1,10,15,5.506,5.506,0,0,1,4.5,9.5h-2A7.5,7.5,0,0,0,9,16.925V18H7.581v2h4.838V18H11V16.925a7.388,7.388,0,0,0,3.026-1.141l1.044,1.044,1.414-1.414L3.755,2.686Z"
				})))
			}
		},
		"./src/reddit/components/Econ/Audio/SpeakerRings.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					width: "226",
					height: "226",
					viewBox: "0 0 226 226",
					fill: "none",
					xmlns: "http://www.w3.org/2000/svg"
				}, r.a.createElement("g", {
					opacity: "0.8"
				}, r.a.createElement("rect", {
					opacity: "0.8",
					x: "36.7704",
					y: "36.7703",
					width: "152.462",
					height: "152.462",
					rx: "76.2308",
					stroke: "url(#paint0_linear)",
					strokeWidth: "4"
				}), r.a.createElement("rect", {
					opacity: "0.5",
					x: "18.8851",
					y: "18.8822",
					width: "188.231",
					height: "188.231",
					rx: "94.1153",
					stroke: "url(#paint1_linear)",
					strokeWidth: "3"
				}), r.a.createElement("rect", {
					opacity: "0.3",
					x: "1.25",
					y: "1.25",
					width: "223.5",
					height: "223.5",
					rx: "111.75",
					stroke: "url(#paint2_linear)",
					strokeWidth: "2.5"
				})), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
					id: "paint0_linear",
					x1: "17.886",
					y1: "34.7703",
					x2: "213.283",
					y2: "40.3684",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				})), r.a.createElement("linearGradient", {
					id: "paint1_linear",
					x1: "-3.25127",
					y1: "17.3822",
					x2: "235.567",
					y2: "24.2243",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				})), r.a.createElement("linearGradient", {
					id: "paint2_linear",
					x1: "-24.3885",
					y1: "2.87774e-05",
					x2: "257.851",
					y2: "8.08615",
					gradientUnits: "userSpaceOnUse"
				}, r.a.createElement("stop", {
					stopColor: "#FF538C"
				}), r.a.createElement("stop", {
					offset: "0.989583",
					stopColor: "#FFAB39"
				}))))
			}
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less": function(e, t, n) {
			e.exports = {
				img: "_2j4blQAaYrPKIhe5jBJ9c8"
			}
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less"),
				d = n.n(i),
				c = n("./src/reddit/icons/fonts/Gift/index.tsx"),
				l = n("./src/reddit/selectors/gold/awardIcon.ts"),
				u = n("./src/reddit/selectors/gold/purchaseCatalog.ts");
			t.a = e => {
				const t = Object(o.e)(u.b),
					n = Object(o.e)(e => Object(l.a)(e, {
						award: t,
						minSize: 32
					}));
				return t && n ? r.a.createElement("img", {
					alt: t.name,
					className: Object(a.a)(d.a.img, e.className),
					id: e.id,
					src: n
				}) : r.a.createElement(c.a, e)
			}
		},
		"./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NftProfileUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e(1), n.e("NftProfileUnit")]).then(n.bind(null, "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "UserAchievementFlair",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("UserAchievementFlair").then(n.bind(null, "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx"
				}
			})
		},
		"./src/reddit/components/EditableImage/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_27zThB3Syksyv8gLdDJqep",
				container: "_27zThB3Syksyv8gLdDJqep",
				HitBox: "_1RlGOQJAoxE66cPOVTH0s",
				hitBox: "_1RlGOQJAoxE66cPOVTH0s",
				Image: "_1te2cn6lvn-YtGSv-hrM7g",
				image: "_1te2cn6lvn-YtGSv-hrM7g",
				ImageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				imageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				ImageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				imageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				LoadingIcon: "_3syvcMeczod-NOIewWIb8n",
				loadingIcon: "_3syvcMeczod-NOIewWIb8n",
				EditButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				editButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				profileCard: "eHsnwmpOgtfnBAgrWXQKq",
				EditIcon: "_3X4DuB4IpAlTY0XMdSI5q6",
				editIcon: "_3X4DuB4IpAlTY0XMdSI5q6"
			}
		},
		"./src/reddit/components/EditableImage/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ImageInput/index.tsx"),
				d = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				c = n("./src/reddit/icons/fonts/index.tsx"),
				l = n("./src/reddit/models/ApiRequestState/index.ts"),
				u = n("./src/reddit/selectors/experiments/profileAvatarChangeFix.ts"),
				m = n("./src/reddit/components/EditableImage/index.m.less"),
				p = n.n(m);
			const {
				fbt: b
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				let {
					altText: t,
					children: n,
					className: s,
					isProfileCard: m,
					isLoading: b,
					imageUrl: h,
					onFileSelected: f
				} = e;
				const g = Object(o.e)(u.a);
				return r.a.createElement("div", {
					className: Object(a.a)(p.a.Container, s)
				}, r.a.createElement("label", {
					className: p.a.HitBox
				}, r.a.createElement("span", {
					className: p.a.ImageContainer,
					role: "presentation"
				}, h ? r.a.createElement("img", {
					alt: t,
					className: p.a.Image,
					src: h
				}) : n), r.a.createElement(i.a, {
					className: p.a.ImageUploader,
					multiple: !1,
					onChange: e => {
						const t = Object(l.b)();
						f(e, t)
					},
					isPending: g ? b : void 0
				}), !b && r.a.createElement("div", {
					className: Object(a.a)(p.a.EditButton, {
						[p.a.profileCard]: m
					})
				}, r.a.createElement(c.a, {
					name: "add_media",
					className: p.a.EditIcon
				}))), b && r.a.createElement(d.a, {
					className: p.a.LoadingIcon,
					sizePx: 80
				}))
			}
		},
		"./src/reddit/components/EmailInvitePaintedDoor/loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "EmailInvitePaintedDoor",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("EmailInvitePaintedDoor").then(n.bind(null, "./src/reddit/components/EmailInvitePaintedDoor/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/EmailInvitePaintedDoor/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/Emoji/index.m.less": function(e, t, n) {
			e.exports = {
				EmojiDisplay: "_2Gt13AX94UlLxkluAMsZqP",
				emojiDisplay: "_2Gt13AX94UlLxkluAMsZqP"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2A1Ng1fBxjU-qYqbEJn_sm",
				EventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventFollowButton: "_2XCKBYzBTZpjOAFEWv1tSy",
				isCompact: "_2gNxoOe_xKaMk0mmYMQCGs"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/eventTools/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/EventPost/PostEventMeta/index.tsx"),
				c = n("./src/reddit/components/PostFollow/index.tsx"),
				l = n("./src/reddit/helpers/postCollection.ts"),
				u = n("./src/reddit/helpers/postEvent.ts"),
				m = n("./src/reddit/components/EventPost/EventMetaHeader/index.m.less"),
				p = n.n(m);
			const b = i.a.div("EventMetaWrapper", p.a);
			t.a = e => {
				let {
					className: t,
					isCompactMode: n,
					post: s
				} = e;
				if (!Object(u.a)(s)) return null;
				const i = s && s.eventInfo,
					m = Object(l.a)(s),
					h = i && Object(a.c)(i.eventStart, i.eventEnd);
				return r.a.createElement("div", {
					className: Object(o.a)(p.a.container, t, {
						[p.a.isCompact]: !!n
					})
				}, r.a.createElement(b, {
					className: p.a.eventMetaWrapper
				}, r.a.createElement(d.a, {
					post: s
				}), !m && h && r.a.createElement(c.a, {
					className: p.a.eventFollowButton,
					post: s,
					isEventFollow: !0
				})))
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.m.less": function(e, t, n) {
			e.exports = {
				PostEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				postEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				PostEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				postEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				PostEventNowText: "BGfronFwr_0rXxOJmxp10",
				postEventNowText: "BGfronFwr_0rXxOJmxp10",
				Container: "_3NIcD2Vr2xrSAq08U14kCy",
				container: "_3NIcD2Vr2xrSAq08U14kCy",
				CalendarIcon: "LEz3F0HfvMpdo96occzKU",
				calendarIcon: "LEz3F0HfvMpdo96occzKU",
				LiveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				liveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				LoadingState: "_27_KVVxYHZ7v44CE2vg8bT",
				loadingState: "_27_KVVxYHZ7v44CE2vg8bT"
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/eventTools/index.ts"),
				a = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/icons/fonts/helpers.tsx"),
				c = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				l = n.n(c);
			var u = e => r.a.createElement("i", {
				className: Object(i.a)(Object(d.b)("scheduled", e.isFilled), l.a.calendarIcon, e.className)
			});
			var m = e => r.a.createElement("i", {
					className: Object(i.a)(Object(d.b)("live", e.isFilled), l.a.liveIcon, e.className)
				}),
				p = n("./src/reddit/components/HumanDate/index.tsx"),
				b = n("./src/reddit/components/EventPost/PostEventMeta/index.m.less"),
				h = n.n(b),
				f = n("./src/lib/lessComponent.tsx");
			const g = f.a.span("PostEventFutureText", h.a),
				_ = f.a.span("PostEventPastText", h.a),
				v = f.a.span("PostEventNowText", h.a),
				O = f.a.span("Container", h.a),
				x = f.a.wrapped(u, "CalendarIcon", h.a),
				E = f.a.wrapped(m, "LiveIcon", h.a),
				y = f.a.div("LoadingState", h.a);
			class j extends s.Component {
				constructor(e) {
					super(e), this.state = {
						mounted: !1
					}
				}
				componentDidMount() {
					this.setState({
						mounted: !0
					})
				}
				render() {
					const {
						className: e,
						post: t
					} = this.props, {
						eventInfo: n
					} = t;
					if (!n) return null;
					const {
						eventEnd: s,
						eventIsLive: i,
						eventStart: d
					} = n, c = Object(o.e)(d, s);
					let l, u;
					if (this.state.mounted || c === o.a.Live) l = r.a.createElement(p.c, {
						startTime: d,
						endTime: s,
						isLive: i
					});
					else {
						const e = Object(a.a)({
							isLoading: !0
						});
						l = r.a.createElement(y, {
							className: e
						})
					}
					if (i) u = r.a.createElement(v, null, r.a.createElement(E, null), l);
					else if (c === o.a.Future) u = r.a.createElement(g, null, r.a.createElement(x, null), l);
					else {
						if (c !== o.a.Past) return null;
						u = r.a.createElement(_, null, r.a.createElement(x, null), l)
					}
					return r.a.createElement(O, {
						className: e
					}, u)
				}
			}
			t.a = j
		},
		"./src/reddit/components/ExpandoButton/index.m.less": function(e, t, n) {
			e.exports = {
				outer: "RvLtAcdRtbOQbhFB7MD_T",
				icon: "saNpcHve-34zjaa0cbIxW",
				hideOnHover: "_25HJpaEPiVNq6Ss3Ad7dp9",
				showOnHover: "_2S05CzViTnl3I2ekCABqFo"
			}
		},
		"./src/reddit/components/ExpandoButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/controls/OutboundLink/index.tsx"),
				m = n("./src/reddit/helpers/path/index.ts"),
				p = n("./src/reddit/helpers/postHasSelfText/index.ts"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				h = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/models/Post/index.ts"),
				g = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				_ = n("./src/telemetry/models/Outbound.ts"),
				v = n("./src/reddit/components/ExpandoButton/index.m.less"),
				O = n.n(v);
			const x = Object(a.b)(null, (e, t) => ({
					toggle: () => e(Object(l.x)({
						postId: t.post.id
					})),
					showModalOnPostLinkClick: t => e(Object(l.bb)(Object(m.b)(t.permalink), t.id))
				})),
				E = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 ? arguments[2] : void 0;
					const s = Object(d.a)(O.a.icon, O.a.hideOnHover);
					if (t) return o.a.createElement(b.a, {
						name: "crosspost",
						className: s
					});
					if (n.pollData) return o.a.createElement(b.a, {
						name: "poll_post",
						className: s
					});
					if (n.audioRoom) return o.a.createElement(b.a, {
						name: "audio",
						className: s
					});
					switch (e) {
						case h.o.GIFVIDEO:
							return o.a.createElement(b.a, {
								name: "gif_post",
								className: s
							});
						case h.o.IMAGE:
							return o.a.createElement(b.a, {
								name: "image_post",
								className: s
							});
						case h.o.TEXT:
						case h.o.RTJSON:
							return o.a.createElement(b.a, {
								name: "text_post",
								className: s
							});
						case h.o.VIDEO:
							return o.a.createElement(b.a, {
								name: "video_post",
								className: s
							});
						case h.o.GALLERY:
							return o.a.createElement(b.a, {
								name: "media_gallery",
								className: s
							});
						case h.o.EMBED:
						default:
							return o.a.createElement(b.a, {
								name: "embed",
								className: s
							})
					}
				};
			t.a = x(e => {
				const {
					className: t,
					crosspost: n,
					enableCrosspostIcon: r,
					isCommentsPage: l,
					isExpanded: m,
					post: h,
					toggle: v,
					useMediaIcons: x
				} = e, y = n || h, j = Object(a.e)(g.b), C = Object(a.e)(g.c), k = t => {
					(j || C) && (t.preventDefault(), e.showModalOnPostLinkClick(y))
				}, I = y.media, S = Object(f.p)(h), w = r && !!n;
				return I && !S && !(("rtjson" === I.type || "text" === I.type || "liveaudio" === I.type) && !Object(p.a)(y)) || !!h.pollData ? o.a.createElement("button", {
					"aria-expanded": !!m,
					"aria-haspopup": !0,
					"aria-label": s.fbt._("Expand content", null, {
						hk: "1e35IG"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": m ? "expando_close" : "expando_open",
					onClick: v
				}, m ? o.a.createElement(b.a, {
					name: "collapse",
					className: O.a.icon
				}) : x ? o.a.createElement(o.a.Fragment, null, E(y.media && y.media.type, w, h), o.a.createElement(b.a, {
					name: "expand",
					className: Object(d.a)(O.a.icon, O.a.showOnHover)
				})) : o.a.createElement(b.a, {
					name: "expand",
					className: O.a.icon
				})) : y.source && y.source.url ? o.a.createElement(u.b, {
					"aria-label": s.fbt._("Open external content", null, {
						hk: "2FfpSI"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					href: y.source.url,
					isSponsored: h.isSponsored,
					postId: h.id,
					source: h.source,
					sourceElement: l ? _.SourceElement.PostImage : _.SourceElement.ListingPostImage,
					target: "_blank"
				}, o.a.createElement(b.a, {
					name: "external_link",
					className: Object(d.a)(O.a.icon, O.a.outboundLinkIcon)
				})) : o.a.createElement(i.a, {
					"aria-label": s.fbt._("View content", null, {
						hk: "24KLWF"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					to: Object(c.a)(y.permalink),
					rel: "nofollow",
					onClick: k
				}, o.a.createElement(b.a, {
					name: "text_post",
					className: O.a.icon
				}))
			})
		},
		"./src/reddit/components/Flair/index.m.less": function(e, t, n) {
			e.exports = {
				FlairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				flairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				FlairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				flairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				TextFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				textFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				transparentBackgroundColor: "_39BEcWjOlYi1QGcJil6-yl",
				RichTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				richTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				MetaFlair: "_1wzhGvvafQFOWAyA157okr",
				metaFlair: "_1wzhGvvafQFOWAyA157okr",
				CloseButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				closeButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				CloseIcon: "_2cvySYWkqJfynvXFOpNc5L",
				closeIcon: "_2cvySYWkqJfynvXFOpNc5L",
				small: "aJrgrewN9C8x1Fusdx4hh",
				large: "_1wj6zoMi6hRP5YhJ8nXWXE",
				flairVariant: "_2VqfzH0dZ9dIl3XWNxs42y"
			}
		},
		"./src/reddit/components/Flair/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return B
			})), n.d(t, "a", (function() {
				return G
			})), n.d(t, "b", (function() {
				return V
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				a = n("./node_modules/polished/dist/polished.es.js"),
				i = n("./node_modules/react/index.js"),
				d = n.n(i),
				c = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/components/Emoji/index.m.less"),
				h = n.n(b);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const g = p.a.wrapped(e => {
				let {
					backgroundImage: t,
					style: n,
					...s
				} = e;
				return d.a.createElement("div", f({
					style: {
						...n || {},
						backgroundImage: `url('${t}')`
					}
				}, s))
			}, "EmojiDisplay", h.a);
			var _ = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				v = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				O = n("./src/reddit/constants/colors.ts"),
				x = n("./src/reddit/constants/parameters.ts"),
				E = n("./src/reddit/controls/InternalLink/index.tsx"),
				y = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				j = n("./src/reddit/icons/svgs/Close/index.tsx"),
				C = n("./src/reddit/models/Flair/index.ts"),
				k = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				I = n("./src/reddit/components/Flair/index.m.less"),
				S = n.n(I);

			function w() {
				return (w = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const T = Object(v.a)(_.b),
				N = p.a.div("FlairWrapper", S.a),
				P = p.a.wrapped(c.a, "CloseButton", S.a),
				R = p.a.wrapped(Object(m.a)(e => {
					let {
						forceSmallEmojis: t,
						theme: n,
						...s
					} = e;
					const r = n;
					return d.a.createElement(g, w({
						style: {
							...A(!!t, r) || {}
						}
					}, s))
				}), "FlairEmojiDisplay", S.a),
				A = (e, t) => {
					if (!e && !!t.subredditContext.emojiHeight && !!t.subredditContext.emojiWidth) return {
						height: `${t.subredditContext.emojiHeight}px`,
						width: `${t.subredditContext.emojiWidth}px`
					}
				},
				M = (e, t) => {
					const n = t ? `/r/${t}/search` : "/search",
						s = `${t?"flair_name":"flair"}:"${e}"`;
					return Object(l.a)(n, {
						[x.p]: s,
						[x.s]: t ? "1" : ""
					})
				},
				D = e => e.isFlairFilter ? d.a.createElement(E.default, {
					onMouseDown: e.onMouseDown,
					to: e.to || ""
				}, e.flair) : e.onClick ? d.a.createElement(E.default, {
					onClick: () => e.onClick(e.searchableTerm),
					to: M(e.searchableTerm, e.subredditName)
				}, e.flair) : e.flair;
			class L extends d.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.state = {
						isTooltipOpen: !1
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							isTooltipOpen: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							isTooltipOpen: !1
						})
					}
				}
				render() {
					const e = d.a.createElement("span", {
						className: Object(u.a)(this.props.className, {
							[S.a.transparentBackgroundColor]: "transparent" === this.props.backgroundColor
						}),
						onMouseEnter: this.props.tooltip ? this.onShowTooltip : void 0,
						onMouseLeave: this.props.tooltip ? this.onHideTooltip : void 0,
						ref: this.setTooltipTargetRef,
						style: {
							backgroundColor: this.props.backgroundColor || Object(k.a)(this.props).flair,
							color: `${B(this.props)}`
						}
					}, this.props.text, this.props.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: this.props.onCloseClick
					}, d.a.createElement(j.a, {
						className: S.a.CloseIcon,
						style: {
							fill: this.props.backgroundColor || Object(k.a)(this.props).flair
						}
					})), !!this.props.tooltip && d.a.createElement(T, {
						text: this.props.tooltip,
						isOpen: this.state.isTooltipOpen,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: ["center", "top"],
						tooltipPosition: ["center", "bottom"]
					}));
					return d.a.createElement(D, {
						flair: e,
						isFlairFilter: this.props.isFlairFilter,
						onClick: this.props.onClick,
						onMouseDown: this.props.onMouseDown,
						searchableTerm: this.props.text,
						subredditName: this.props.subredditName,
						to: this.props.to
					})
				}
			}
			const F = Object(m.a)(L),
				U = Object(m.a)(e => {
					let t = "",
						n = !1;
					const s = e.richtext.map((s, r) => {
						if (s.e === C.c.Emoji) {
							const o = s;
							return t += o.a, n = !0, d.a.createElement(R, {
								forceSmallEmojis: e.forceSmallEmojis,
								backgroundImage: o.u,
								key: r,
								title: o.a
							})
						} {
							const e = s;
							return t += e.t, d.a.createElement("span", {
								key: r
							}, e.t)
						}
					});
					let r;
					n && !e.forceSmallEmojis && e.theme && e.theme.subredditContext.emojiWidth && e.theme.subredditContext.emojiHeight && e.theme.subredditContext.emojiHeight > 16 && (r = {
						marginTop: `-${e.theme.subredditContext.emojiHeight-16}px`
					});
					const o = d.a.createElement(N, {
						className: Object(u.a)(e.className, {
							[S.a.transparentBackgroundColor]: "transparent" === e.backgroundColor
						}),
						style: {
							...r,
							backgroundColor: e.backgroundColor || Object(k.a)(e).flair,
							color: `${B(e)}`
						}
					}, s, e.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: e.onCloseClick
					}, d.a.createElement(j.a, {
						className: S.a.CloseIcon,
						style: {
							fill: e.backgroundColor || Object(k.a)(e).flair
						}
					})));
					return d.a.createElement(D, {
						flair: o,
						isFlairFilter: e.isFlairFilter,
						onClick: e.onClick ? () => {
							e.onClick(t)
						} : void 0,
						onMouseDown: e.onMouseDown,
						searchableTerm: t,
						subredditName: e.subredditName,
						to: e.to
					})
				}),
				B = e => !e.textColor || e.textColor && !e.backgroundColor ? Object(k.a)(e).postFlairText : "transparent" === e.backgroundColor ? Object(y.a)(Object(k.a)(e).post, O.a.black, O.a.white) : e.textColor === C.e.Dark ? O.a.black : O.a.white,
				G = p.a.wrapped(F, "TextFlair", S.a),
				H = p.a.wrapped(U, "RichTextFlair", S.a),
				W = e => {
					switch (e.type) {
						case "spoiler":
							return "#A4A7A8";
						case "nsfw":
							return "#FF585B";
						default:
							return Object(a.i)(.1, Object(k.a)(o()(e, "theme", "redditStyle", "data-redditstyle")).button)
					}
				},
				q = p.a.wrapped(e => {
					const t = W(e),
						n = d.a.createElement("span", {
							className: e.className,
							style: {
								border: `1px solid ${t}`,
								color: t
							}
						}, e.text);
					return d.a.createElement(D, {
						flair: n,
						searchableTerm: e.text
					})
				}, "MetaFlair", S.a);

			function V(e) {
				const {
					className: t,
					disabled: n = !1,
					flair: r,
					isFlairFilter: o,
					isSelected: a,
					onClick: i,
					onCloseClick: c,
					onMouseDown: l,
					subredditName: m,
					usesCommunityStyles: p,
					forceSmallEmojis: b,
					to: h
				} = e, f = Object(u.a)({
					[S.a.flairVariant]: o,
					[S.a.small]: o && !e.large,
					[S.a.large]: o && e.large
				}, t);
				switch (r.type) {
					case C.f.Richtext:
						return n || !r.richtext ? null : d.a.createElement(H, {
							backgroundColor: r.backgroundColor,
							className: f,
							forceSmallEmojis: b,
							isFlairFilter: o,
							isSelected: a,
							onClick: i,
							onCloseClick: c,
							onMouseDown: l,
							redditStyle: !p,
							richtext: r.richtext,
							subredditName: m,
							textColor: r.textColor,
							to: h
						});
					case C.f.Text:
						return n || !r.text ? null : d.a.createElement(G, {
							backgroundColor: r.backgroundColor,
							className: f,
							isFlairFilter: o,
							isSelected: a,
							onClick: i,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: h
						});
					case C.f.Meta:
						return d.a.createElement(G, {
							backgroundColor: r.backgroundColor,
							className: t,
							isFlairFilter: o,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: h
						});
					case C.f.Nsfw:
					case C.f.Spoiler:
						return d.a.createElement(q, {
							className: t,
							text: r.text,
							type: r.type
						});
					case C.f.Quarantined:
						return null;
					case C.f.Oc:
						return d.a.createElement(G, {
							backgroundColor: O.a.alienblue,
							text: r.text,
							textColor: C.e.Light,
							tooltip: s.fbt._("This post is marked as Original Content [OC]", null, {
								hk: "h7je6"
							})
						});
					default:
						return r.text ? d.a.createElement(G, {
							backgroundColor: r.backgroundColor,
							className: f,
							isFlairFilter: o,
							onClick: i,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							redditStyle: !p,
							to: h
						}) : null
				}
			}
		},
		"./src/reddit/components/FlairList/index.m.less": function(e, t, n) {
			e.exports = {
				flairVariantInList: "_1Dl-kvSxyJMWO9nuoTof8N"
			}
		},
		"./src/reddit/components/FlairList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/Flair/index.tsx"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/components/FlairList/index.m.less"),
				b = n.n(p);
			const h = Object(d.c)({
					labelNSFW: m.ab
				}),
				f = Object(i.b)(h),
				g = e => {
					if (e.type === u.f.Richtext && e.richtext) {
						const t = e.richtext.map(e => e.e === u.c.Emoji ? e.u : e.t).join("-");
						return `${e.type}--${t}`
					}
					return `${e.type}--${e.text}`
				};
			t.a = f(e => {
				let {
					className: t,
					isFlairFilter: n,
					onClick: s,
					onMouseDown: o,
					disabled: i = !1,
					flair: d,
					labelNSFW: m,
					subredditName: p
				} = e;
				const h = !!d.find(e => e.type === u.f.Richtext),
					f = d.map(e => {
						if (e.type === u.f.Text && h) return null;
						if (!m && e.type === u.f.Nsfw) return null;
						const t = Object(l.j)(e),
							d = `/r/${p}/`,
							f = o ? () => o(e) : r.a,
							_ = n && (e.type === u.f.Richtext || e.type === u.f.Text);
						return a.a.createElement(c.b, {
							className: _ ? b.a.flairVariantInList : void 0,
							isFlairFilter: n,
							key: g(e),
							onClick: s,
							onMouseDown: f,
							disabled: i,
							flair: e,
							forceSmallEmojis: !0,
							subredditName: p,
							to: Object(l.e)(d, t)
						})
					});
				return a.a.createElement("div", {
					className: t
				}, f)
			})
		},
		"./src/reddit/components/FlairPickerTitle/index.m.less": function(e, t, n) {
			e.exports = {
				modalHeader: "_26bOTAKvGixX5tMC3vGfTv"
			}
		},
		"./src/reddit/components/FlairPickerTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/components/FlairPickerTitle/index.m.less"),
				l = n.n(c);
			t.a = e => a.a.createElement(i.i, {
				className: l.a.modalHeader
			}, a.a.createElement(i.q, null, e.title), a.a.createElement(d.a, {
				onClick: e.onClosePressed || r.a
			}, a.a.createElement(i.b, null)))
		},
		"./src/reddit/components/FlairPickerWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3nRJIwLuth2pKYrXnr2jPN",
				wrapper: "_3nRJIwLuth2pKYrXnr2jPN"
			}
		},
		"./src/reddit/components/FlairPickerWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/FlairPickerWrapper/index.m.less"),
				o = n.n(r);
			const a = s.a.div("Wrapper", o.a);
			t.a = a
		},
		"./src/reddit/components/FlairPreview/index.m.less": function(e, t, n) {
			e.exports = {
				Placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				SelectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				selectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				FlairComponent: "vynkb69RQyUY-PA6bCaW0",
				flairComponent: "vynkb69RQyUY-PA6bCaW0"
			}
		},
		"./src/reddit/components/FlairPreview/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/Flair/index.tsx"),
				d = n("./src/reddit/components/FlairPreview/index.m.less"),
				c = n.n(d);
			const l = a.a.span("Placeholder", c.a),
				u = a.a.div("SelectedFlair", c.a),
				m = a.a.wrapped(i.b, "FlairComponent", c.a);
			t.a = e => e.flair ? o.a.createElement(u, null, o.a.createElement(l, null, s.fbt._("{placeholder}", [s.fbt._param("placeholder", e.placeholderText)], {
				hk: "4G6VRy"
			})), o.a.createElement(m, {
				flair: e.flair,
				forceSmallEmojis: !0
			})) : o.a.createElement(u, null, s.fbt._("No flair selected", null, {
				hk: "1XPXbv"
			}))
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.m.less": function(e, t, n) {
			e.exports = {
				FlairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				flairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				isCompact: "_3YjPWOd9tK9O_DN50RI_FN"
			}
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/lodash/once.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/higherOrderComponents/makeAsync.tsx"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/loadWithRetries/index.ts"),
				u = n("./src/reddit/components/FlairSearch/FlairEdit/helper.m.less"),
				m = n.n(u);
			const p = c.a.wrapped(e => a.a.createElement("div", {
					className: Object(d.a)(e.className, {
						[m.a.isCompact]: e.isCompact
					})
				}), "FlairEditStub", m.a),
				b = r()((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p;
					return Object(i.a)({
						getComponent: () => Object(l.a)(() => Promise.all([n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("FlairEdit")]).then(n.bind(null, "./src/reddit/components/FlairSearch/FlairEdit/index.tsx")).then(e => e.default)),
						ErrorComponent: e,
						LoadingComponent: e
					})
				}))
		},
		"./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1bdAduczElF9-gLoCvHz-p",
				flairComponent: "_2leID3tMN8hpvVd4XhEqTl",
				radioOption: "FJIE5E2gciCA8q3Jzvcyg",
				pencil: "_3H_wwe03-Fkrm6oWGakXI8",
				searchBoxWrapper: "_18cuM8Uu7RcIFu1bCT0r4t",
				searchIcon: "_2bECVWL_WJ9RGBx7-RnzfO",
				searchInput: "_1nQbRaoAvb6Uy0oI-OfDtZ"
			}
		},
		"./src/reddit/components/FlairSearch/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2AKP6aCod0Z6TuXXfc1ZqL",
				buttonsRow: "_3w7b_fPwMuVD17J7epjTXi",
				clearButton: "_3WykjMvdVO5xibqd5xlfTC",
				flairEditSection: "SVd7IxchgiWetdYbftTHx",
				editLabel: "KTa3kg9lzGPUeLuhAHMT_",
				restrictionHintText: "_1fV9kJfKnED9qQ2AF8f3iT"
			}
		},
		"./src/reddit/components/FlairSearch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/memoizeByReference/index.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				m = n("./src/reddit/helpers/trackers/userFlair.ts"),
				p = n("./src/reddit/hooks/useTracking.ts"),
				b = n("./src/reddit/selectors/moderatorPermissions.ts"),
				h = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				f = n("./src/reddit/components/Flair/index.tsx"),
				g = n("./src/reddit/components/TrackingHelper/index.tsx"),
				_ = n("./src/reddit/controls/RadioInput/index.tsx"),
				v = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				O = n("./src/reddit/helpers/trackers/postComposer.ts"),
				x = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				E = n("./src/reddit/icons/svgs/Search/index.tsx"),
				y = n("./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less"),
				j = n.n(y);
			class C extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						searchQuery: ""
					}, this.onSearchChange = e => {
						this.setState({
							searchQuery: e.target.value
						})
					}, this.onSearchClick = () => {
						this.props.sendEvent(Object(O.n)())
					}
				}
				render() {
					const {
						templates: e,
						templateIds: t,
						selectedTemplateId: n
					} = this.props, {
						searchQuery: r
					} = this.state, a = t.map(t => e[t]).filter(e => e.text.toLowerCase().includes(r)), i = !!n && a.some(e => e.id === n);
					return o.a.createElement("div", {
						className: j.a.container
					}, o.a.createElement("div", {
						className: j.a.searchBoxWrapper
					}, o.a.createElement("input", {
						className: j.a.searchInput,
						onChange: this.onSearchChange,
						onClick: this.onSearchClick,
						type: "text",
						placeholder: s.fbt._("Search for flair", null, {
							hk: "jQdqA"
						}),
						value: r
					}), o.a.createElement(E.a, {
						className: j.a.searchIcon
					})), o.a.createElement(_.a, {
						name: "flair_picker",
						onChange: this.props.onChange,
						value: n
					}, a.map((e, t) => {
						const s = Object(u.c)(e),
							r = n === e.id || !i && 0 === t;
						return o.a.createElement(v.a, {
							className: j.a.radioOption,
							key: e.id,
							showButton: !0,
							tabIndex: r ? 0 : -1,
							value: e.id
						}, o.a.createElement(f.b, {
							className: j.a.flairComponent,
							flair: s,
							forceSmallEmojis: !0
						}), e.textEditable && o.a.createElement(x.a, {
							className: j.a.pencil
						}))
					})))
				}
			}
			var k = Object(g.c)(C),
				I = n("./src/reddit/components/FlairSearch/index.m.less"),
				S = n.n(I);
			const w = Object(c.a)(e => e && Object(u.c)(e)),
				T = Object(i.c)({
					areFlairRestrictionsEnabled: l.d.flairRestrictions,
					isModerator: b.g
				}),
				N = Object(a.b)(T);
			t.a = N(e => {
				const {
					flairTemplateType: t,
					flair: n,
					className: r,
					onChange: a,
					subredditId: i,
					templates: c,
					templateIds: l,
					areFlairRestrictionsEnabled: b,
					isModerator: f
				} = e, g = Object(p.a)(), _ = c && n && n.templateId && c[n.templateId] || void 0, v = Object(h.a)(), O = n || w(_);
				return o.a.createElement("div", {
					className: Object(d.a)(r, S.a.container)
				}, c && l && o.a.createElement(k, {
					flairTemplateType: t,
					onChange: e => {
						if (c) {
							const t = c[e],
								n = Object(u.c)(t);
							g(Object(m.b)({
								userFlair: t
							})), a(n)
						}
					},
					selectedTemplateId: _ ? _.id : "",
					templateIds: l,
					templates: c
				}), O && _ && (f || _.textEditable) && o.a.createElement("div", {
					className: S.a.flairEditSection
				}, o.a.createElement("div", {
					className: S.a.editLabel
				}, s.fbt._("Edit flair", null, {
					hk: "1APWWu"
				})), b && o.a.createElement("div", {
					className: S.a.restrictionHintText
				}, Object(u.k)(_)), o.a.createElement(v, {
					autofocus: !0,
					emojiPickerId: "FlairSearch-EmojiPicker-DropdownId",
					flair: O,
					flairTemplate: _,
					flairTemplateType: t,
					isFlairModOnly: _.modOnly,
					onChange: e => {
						const t = c && e.templateId ? c[e.templateId] : void 0;
						let n = e;
						t && (n = Object(u.d)({
							flair: e,
							template: t,
							ignoreTextAllowance: !0
						})), a(n)
					},
					subredditId: i
				})))
			})
		},
		"./src/reddit/components/FlairWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				flairList: "lrzZ8b0L6AzLkQj5Ww7H1",
				flairWrapper: "_2fiIRtMpITeCAzXc4cANKp",
				flairNoWrap: "_2xu1HuBz1Yx6SP10AGVx_I"
			}
		},
		"./src/reddit/components/FlairWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/FlairList/index.tsx"),
				l = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				u = n("./src/reddit/contexts/PageLayer/index.tsx"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/flair.ts"),
				b = n("./src/reddit/helpers/trackers/postFlair.ts"),
				h = n("./src/reddit/models/Flair/index.ts"),
				f = n("./src/reddit/selectors/postFlair.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/components/FlairWrapper/index.m.less"),
				v = n.n(_);
			const O = Object(a.b)(() => Object(i.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(u.q)(e, {
							pageLayer: n
						})
					},
					isPostFlairEnabled: (e, t) => Object(f.c)(e, {
						subredditId: t.post.belongsTo.id
					}),
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(g.U)(e, {
							subredditId: n.belongsTo.id
						}).name
					}
				})),
				x = e => {
					const t = [];
					return e.isOriginalContent && t.push({
						text: s.fbt._("OC", null, {
							hk: "1i721p"
						}),
						type: h.f.Oc
					}), e.isMeta && t.push({
						text: s.fbt._("Poll", null, {
							hk: "1scdU1"
						}),
						type: h.f.Meta
					}), t.push(...e.flair), t
				};
			t.a = O(e => {
				let {
					className: t,
					disableFlair: n,
					flairPosition: s,
					isFlairFilter: r,
					isPostFlairEnabled: a,
					nowrap: i,
					post: u,
					sendEvent: f,
					subredditName: g,
					titleFlair: _
				} = e;
				const O = Object(l.a)(),
					E = s === h.b.Left,
					y = _ || x(u),
					j = [];
				let C = [];
				E ? y.map(e => {
					Object(p.q)(e.type) ? j.push(e) : C.push(e)
				}) : C = y;
				const k = i ? v.a.flairNoWrap : j.length > 0 || C.length > 0 ? v.a.flairWrapper : null,
					I = e => {
						const t = {
							id: u.belongsTo.id,
							eventType: u.belongsTo.type,
							originElement: "post_flair",
							postFlairName: e
						};
						Object(m.d)(m.a.SearchResults), f && f(Object(b.a)(u.id, t))
					},
					S = e => {
						Object(m.d)(m.a.SearchResults), f && f(Object(b.e)(e, u.id))
					},
					w = !(n || !y || !y.length);
				return w ? o.a.createElement("div", {
					className: Object(d.a)(k, t),
					"data-ignore-click": O
				}, w && j && o.a.createElement(c.a, {
					className: v.a.flairList,
					isFlairFilter: r,
					key: "leftFlair",
					onClick: I,
					onMouseDown: S,
					flair: j,
					disabled: !a,
					subredditName: g
				}), w && o.a.createElement(c.a, {
					className: v.a.flairList,
					isFlairFilter: r,
					key: "rightFlair",
					onClick: I,
					onMouseDown: S,
					flair: C,
					disabled: !a,
					subredditName: g
				})) : null
			})
		},
		"./src/reddit/components/Flatlist/ResponsiveRow.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				i = n("./src/reddit/controls/Dropdown/Row.tsx"),
				d = n("./src/reddit/components/Flatlist/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					flatlistItem: t,
					isLoggedIn: n,
					isUserOp: s,
					noBreakpoints: d,
					...u
				} = e;
				return r.a.createElement("div", {
					"data-ignore-click": !!u.searchIgnoreClick,
					className: c.a.rowContainer
				}, r.a.createElement(i.a, l({}, u, {
					className: d ? c.a.responsiveRow : Object(o.a)(c.a.responsiveRow, Object(a.b)({
						flatlistItem: t,
						isLoggedIn: n,
						isUserOp: s
					}))
				})))
			}
		},
		"./src/reddit/components/Flatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				hideIfVwSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				FirstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				firstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				LoggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				loggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				LoggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				loggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				OpVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				opVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				EditingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				editingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				SecondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				secondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				AwardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				awardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				HideIfVWLarger: "_1k3nXWGGz2NdPr8dg49Tbs",
				hideIfVwLarger: "_1k3nXWGGz2NdPr8dg49Tbs"
			}
		},
		"./src/reddit/components/Flatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.EditPost = "EDITPOST", e.EditFlair = "EDITFLAIR", e.Save = "SAVE", e.Gild = "GILD", e.Hide = "HIDE", e.PostOverflowMenu = "POST_OVERFLOW_MENU", e.Report = "REPORT", e.Share = "SHARE", e.ShowFewerLikeThis = "SHOW_FEWER_LIKE_THIS", e.ShowMoreLikeThis = "SHOW_MORE_LIKE_THIS", e.Insights = "INSIGHTS"
				}(s || (s = {}))
		},
		"./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return u
			}));
			var s, r, o, a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Flatlist/breakpoints.m.less"),
				d = n.n(i),
				c = n("./src/reddit/components/Flatlist/constants.ts");
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.First = "FirstGroup", e.Editing = "EditingGroup", e.Second = "SecondGroup", e.Awarding = "AwardingGroup"
			}(r || (r = {})),
			function(e) {
				e.LoggedIn = "LoggedInVariant", e.LoggedOut = "LoggedOutVariant", e.Op = "OpVariant"
			}(o || (o = {}));
			const l = {
					[c.a.EditFlair]: r.Editing,
					[c.a.EditPost]: r.Editing,
					[c.a.Gild]: r.Awarding,
					[c.a.Hide]: r.First,
					[c.a.PostOverflowMenu]: r.First,
					[c.a.Report]: r.First,
					[c.a.Save]: r.First,
					[c.a.Share]: r.Second,
					[c.a.ShowFewerLikeThis]: r.First,
					[c.a.ShowMoreLikeThis]: r.First,
					[c.a.Insights]: r.First
				},
				u = e => {
					return (e => {
						const t = d.a[e.type],
							n = d.a[e.group],
							s = d.a[e.groupVariant];
						return Object(a.a)(t, n, s)
					})({
						type: e.breakpointType || s.HideIfVWSmaller,
						group: l[e.flatlistItem],
						groupVariant: ((e, t) => e && t ? o.Op : e ? o.LoggedIn : o.LoggedOut)(e.isLoggedIn, e.isUserOp)
					})
				}
		},
		"./src/reddit/components/Flatlist/index.m.less": function(e, t, n) {
			e.exports = {
				flatlistContainer: "_3-miAEojrCvx_4FQ8x3P-s",
				responsiveRow: "YszYBnnIoNY8pZ6UwCivd",
				rowContainer: "_3U_7i38RDPV5eBv7m4M-9J",
				responsiveRowText: "_70940WUuFmpHbhKlj8EjZ",
				insightsButtonText: "WH45FmM2j_4Snucem7pcm",
				flatlistSeparator: "x7sinePdvDKj7bf-cdm4Z",
				flexSpacer: "_21pmAV9gWG6F_UKVe7YIE0",
				modActionsIcon: "_15c1hqseW25EvRu0WP2Dq5",
				shareText: "_6_44iTtZoeY6_XChKt5b0",
				commentsLink: "_2qww3J5KKzsD7e5DO0BvvU",
				supportButton: "_3NIVQWStkLT7RXnwKpKNuT",
				text: "YCL-CnLJKXzXbwuLZEyh1",
				ShareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareIcon: "_1GQDWqbF-wkYWbrpmOvjqJ",
				ShareMenu: "_JRBNstMcGxbZUxrrIKXe",
				shareMenu: "_JRBNstMcGxbZUxrrIKXe",
				liveDiscussionWrapper: "_3rnnBQZL1OOttG3tFn629n",
				modLargePost: "_1rz4qmtk19qk1KbsKVMbAq",
				overflowMenuContainer: "_3MmwvEEt6fv5kQPFCVJizH",
				awardIcon: "_3yNNYT3e1avhAAWVHd0-92",
				saveIcon: "_1Xe01txJfRB9udUU85DNeR"
			}
		},
		"./src/reddit/components/Flatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return xe
			})), n.d(t, "a", (function() {
				return Ee
			})), n.d(t, "d", (function() {
				return Ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/lib/ads/index.ts"),
				p = n("./src/lib/timezone/index.ts"),
				b = n("./src/reddit/actions/gold/modals.ts"),
				h = n("./src/reddit/actions/modal.ts"),
				f = n("./src/reddit/actions/post.ts"),
				g = n("./src/reddit/actions/postCreation/editing.ts"),
				_ = n("./src/reddit/actions/postFlair.ts"),
				v = n("./src/reddit/actions/reportFlow/index.ts"),
				O = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				x = n("./src/reddit/components/CommentsLink/index.tsx"),
				E = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				y = n("./src/reddit/hooks/useTracking.ts"),
				j = n("./src/reddit/helpers/trackers/freeAwardOffer.ts"),
				C = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				k = n("./src/reddit/components/ContentTooltip/index.tsx"),
				I = n("./src/reddit/components/GiveAwardTooltip/index.m.less"),
				S = n.n(I);
			const {
				fbt: w
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var T = e => {
					const {
						tooltipId: t
					} = e, n = Object(a.e)(C.b), s = Object(y.a)();
					return Object(r.useEffect)(() => {
						n && s(Object(j.c)())
					}, [n, s]), n ? o.a.createElement(k.a, {
						className: S.a.freeAwardTooltip,
						caretColor: {
							bottom: "#F6481E"
						},
						tooltipSizeEstimate: {
							height: 48,
							width: 148
						},
						tooltipId: t,
						defaultTooltipPosition: "top"
					}, o.a.createElement("div", {
						className: S.a.freeAwardContainer
					}, w._("Tap to give your {award name} Award", [w._param("award name", n.name)], {
						hk: "2EMqbP"
					}))) : null
				},
				N = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				P = n("./src/reddit/components/ModModeReports/helpers.ts"),
				R = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				A = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				M = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				D = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				L = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				F = n("./src/reddit/components/ShareMenu/index.tsx"),
				U = n("./src/reddit/components/TrackingHelper/index.tsx"),
				B = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				G = n("./src/reddit/constants/postLayout.ts"),
				H = n("./src/reddit/contexts/PageLayer/index.tsx"),
				W = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				q = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				V = n("./src/reddit/selectors/user.ts"),
				z = n("./src/reddit/components/Flatlist/ResponsiveRow.tsx"),
				K = n("./src/reddit/helpers/correlationIdTracker.ts"),
				Q = n("./src/reddit/helpers/trackers/modTools.ts"),
				J = n("./src/reddit/helpers/trackers/post.ts"),
				Y = n("./src/reddit/icons/fonts/index.tsx"),
				X = n("./src/reddit/icons/fonts/ModActions/index.tsx"),
				Z = n("./src/reddit/icons/fonts/Share/index.tsx"),
				$ = n("./src/reddit/models/Media/index.ts"),
				ee = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				te = n("./src/reddit/models/PostCreationForm/index.ts"),
				ne = n("./src/reddit/models/User/index.ts"),
				se = n("./src/reddit/components/Flatlist/constants.ts"),
				re = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				oe = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				ae = n("./src/reddit/actions/postCollection/index.ts"),
				ie = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx"),
				de = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				ce = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				le = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				ue = n("./src/reddit/selectors/activeModalId.ts"),
				me = n("./src/reddit/selectors/experiments/antievil/index.tsx"),
				pe = n("./src/reddit/selectors/posts.ts"),
				be = n("./src/reddit/components/Flatlist/index.m.less"),
				he = n.n(be);

			function fe() {
				return (fe = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			let ge, _e;
			const ve = u.a.button("ShareButton", he.a),
				Oe = u.a.wrapped(F.a, "ShareMenu", he.a),
				xe = Object(l.a)(e => {
					let {
						className: t,
						...n
					} = e;
					return o.a.createElement(X.a, fe({}, n, {
						className: Object(d.a)(he.a.modActionsIcon, t),
						style: {
							color: Object(q.a)(Object(W.a)(n), ee.a.actionIcon, ee.b.actionIcon)
						}
					}))
				}),
				Ee = e => o.a.createElement("div", fe({}, e, {
					className: Object(d.a)(he.a.flatlistSeparator, e.className)
				})),
				ye = Object(H.u)({
					currentProfileName: H.i,
					isCommentPermalink: H.w,
					isCommentsPage: H.x,
					isProfilePostListing: H.L,
					pageLayer: e => e
				}),
				je = Object(i.c)({
					activeModalId: ue.a,
					claimedFreeAward: C.b,
					layout: H.S,
					userIsOp: V.Db,
					subreddit: H.r,
					isBlockedUserBannerEnabled: (e, t) => {
						let {
							post: n
						} = t;
						return !!Object(pe.w)(e, {
							postId: n.postId
						}) && Object(me.a)(e)
					},
					isTrueblockPCBlockeeEnabled: me.d
				}),
				Ce = Object(a.b)(je, (e, t) => {
					let {
						post: s,
						isOverlay: r,
						isCommentsPage: o
					} = t;
					return {
						addPostToCollection: (t, n) => e(Object(ae.a)(t, n)),
						onToggleModal: t => e(Object(h.i)(t)),
						onToggleSave: () => e(Object(f.V)(s.postId)),
						onHide: t => e(Object(f.fb)(s.postId, !s.hidden, r, !0)),
						onReportClick: () => e(Object(v.c)(s.postId, r)),
						onEdit: () => {
							const t = !r && !o;
							e(Object(g.a)(s.postId, t))
						},
						onFlairPost: () => e(Object(h.i)(Object(A.b)(s.postId, r))),
						onGildClick: (t, n) => e(Object(b.d)({
							awardId: n,
							correlationId: t,
							thingId: s.postId
						})),
						onFlairChanged: t => {
							let {
								selectedTemplateId: n,
								previewFlair: r
							} = t;
							return e(Object(_.h)({
								post: s,
								selectedTemplateId: n,
								previewFlair: r
							}))
						},
						toggleEditStartTimeModal: async () => {
							ge && _e || ([ge, _e] = await Promise.all([n.e("schedulePickerModal").then(n.bind(null, "./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx")).then(e => e.default), Promise.resolve().then(n.bind(null, "./src/reddit/actions/eventPosts/index.ts")).then(e => e.editEventTimeRequested)])), e(Object(h.i)(Object(te.s)(s.postId, r, te.k.POST_OVERFLOW_MENU)))
						},
						addEventStartTime: t => {
							_e && e(_e(s.id, t))
						}
					}
				}),
				ke = o.a.memo(e => {
					const {
						activeModalId: t,
						addEventStartTime: a,
						className: i,
						currentProfileName: l,
						currentUser: u,
						forceOpenInNewTab: b,
						hasModFlairPerms: h,
						hasModFullPerms: f,
						hasModPostPerms: g,
						isCommentPermalink: _,
						isCommentsPage: v,
						isCountAnimShadowTestEnabled: y,
						isLargePost: j,
						isOverlay: C,
						isProfilePostListing: k,
						isSticky: I,
						layout: S,
						modModeEnabled: w,
						onClickInsightsButton: F,
						onFlairChanged: U,
						onIgnoreReports: H,
						onOpenReportsDropdown: W,
						pageLayer: q,
						post: V,
						sendEvent: X,
						showEditFlair: ee,
						showEditPost: ae,
						subreddit: le,
						toggleEditStartTimeModal: ue,
						tooltipType: me,
						userIsOp: pe,
						searchIgnoreClick: be,
						isCommentCountAnimation: fe,
						hostPostData: _e,
						listingKey: Ee,
						onGildClick: ye,
						onToggleModal: je,
						claimedFreeAward: Ce,
						onToggleSave: ke,
						onHide: Se,
						addPostToCollection: we,
						onReportClick: Te,
						isBlockedUserBannerEnabled: Ne,
						shouldHideItems: Pe,
						shouldShowInsightsButton: Re,
						isTrueblockPCBlockeeEnabled: Ae
					} = e, Me = Object(r.useCallback)(async () => {
						const e = Object(K.d)(K.a.GildingFlow, !0);
						ye(e, null == Ce ? void 0 : Ce.id);
						const {
							clickGildEvent: t
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						X(t(V.id))
					}, [ye, V, X, Ce]), De = Object(r.useCallback)(() => {
						t && je(t)
					}, [t, je]), Le = Object(r.useCallback)(() => {
						const e = Object(te.t)(V.id, C);
						je(e)
					}, [je, C, V]), Fe = Object(r.useCallback)(e => {
						we(e.id, V.id).then(() => De())
					}, [we, De, V]), Ue = Object(r.useCallback)((e, t) => {
						X(Object(J.k)(V.id, e, C ? "post_detail" : "post", Ee, _e, void 0, null == t ? void 0 : t.referralId))
					}, [_e, C, X, Ee, V]), Be = Object(r.useCallback)(() => {
						ke(), Ue(V.saved ? "unsave" : "save")
					}, [ke, V, Ue]), Ge = Object(r.useCallback)(() => {
						Se(!!V.hidden), Ue(V.hidden ? "unhide" : "hide")
					}, [Se, V, Ue]), He = Object(r.useCallback)(() => {
						Te(), Ue("report")
					}, [Te, Ue]), We = Object(r.useMemo)(() => o.a.createElement(ve, {
						"data-click-id": "share"
					}, o.a.createElement(Z.a, {
						className: he.a.shareIcon
					}), o.a.createElement("span", {
						className: he.a.shareText
					}, s.fbt._("share", null, {
						hk: "1eAfZg"
					}))), []), qe = !!u && Object(ne.e)(u) === V.author, Ve = Object(oe.a)("View--Reports", V.id, me), ze = Object(oe.a)(c.qc, V.id, me), Ke = Object(P.c)(V), Qe = Ie("-mod-actions-menu", V.id, C, I), Je = Object(P.a)(V), Ye = V.postId, Xe = S === G.g.Large, Ze = !v && Xe || g && w || Pe, $e = !(C || v || _), et = !(V.authorIsBlocked && Ae) && u && V.isGildable && !(V.authorIsBlocked && Ne) && !(V.unrepliableReason && Ae), tt = V.media && V.media.type === $.o.LIVEVIDEO, nt = !!V.recommendationContext, st = V.isSponsored || Object(m.u)(q);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(d.a)(he.a.flatlistContainer, i)
					}, o.a.createElement(x.a, {
						className: Object(d.a)(he.a.rowContainer, he.a.commentsLink),
						forceOpenInNewTab: b,
						hasModPostPerms: g,
						isCommentsPage: v,
						isCommentPermalink: _,
						isOverlay: C,
						postId: V.id,
						modModeEnabled: w,
						numComments: V.numComments,
						isCommentCountAnimation: fe,
						isCountAnimShadowTestEnabled: y
					}), et && o.a.createElement(o.a.Fragment, null, o.a.createElement(z.a, {
						displayText: s.fbt._("Award", null, {
							hk: "2fZCpE"
						}),
						textClassName: he.a.responsiveRowText,
						flatlistItem: se.a.Gild,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: Me,
						searchIgnoreClick: be,
						skipRoleAttr: !0
					}, o.a.createElement(ie.a, {
						className: he.a.awardIcon,
						id: ze
					})), o.a.createElement(T, {
						postOrComment: V,
						tooltipId: ze
					})), o.a.createElement(Oe, {
						className: Object(d.a)(he.a.rowContainer, Object(re.b)({
							flatlistItem: se.a.Share,
							isLoggedIn: !!u,
							isUserOp: pe
						})),
						dropdownId: Ie("-share-menu", V.id, C, I),
						permalink: V.permalink,
						post: V,
						sendEventWithName: Ue,
						subredditType: null == le ? void 0 : le.type
					}, We), ae && !Ze && o.a.createElement(z.a, {
						displayText: s.fbt._("Edit post", null, {
							hk: "Jq2Cr"
						}),
						textClassName: he.a.responsiveRowText,
						flatlistItem: se.a.EditPost,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: e.onEdit,
						skipRoleAttr: !0
					}, o.a.createElement(Y.a, {
						name: "edit"
					})), (!g || !w) && o.a.createElement(z.a, {
						displayText: V.saved ? s.fbt._("unsave", null, {
							hk: "4Dn4IT"
						}) : s.fbt._("save", null, {
							hk: "3NOMst"
						}),
						textClassName: he.a.responsiveRowText,
						flatlistItem: se.a.Save,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: Be,
						searchIgnoreClick: be,
						skipRoleAttr: !0
					}, o.a.createElement(Y.a, {
						name: V.saved ? "saved" : "save",
						className: he.a.saveIcon
					})), !st && !Ze && o.a.createElement(z.a, {
						displayText: V.hidden ? s.fbt._("unhide", null, {
							hk: "151XLs"
						}) : s.fbt._("hide", null, {
							hk: "4AnA6R"
						}),
						textClassName: he.a.responsiveRowText,
						flatlistItem: se.a.Hide,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: Ge,
						searchIgnoreClick: be,
						skipRoleAttr: !0
					}, o.a.createElement(Y.a, {
						name: "hide",
						isFilled: V.hidden
					})), !qe && !st && !Ze && o.a.createElement(z.a, {
						displayText: s.fbt._("report", null, {
							hk: "1phfns"
						}),
						textClassName: he.a.responsiveRowText,
						flatlistItem: se.a.Report,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: He,
						searchIgnoreClick: be,
						skipRoleAttr: !0
					}, o.a.createElement(Y.a, {
						name: "report"
					})), o.a.createElement(R.a, {
						isOverlay: C,
						layout: S,
						modModeEnabled: w,
						post: V,
						sendEvent: X
					}), g && o.a.createElement(N.a, {
						dropdownId: Qe,
						onClick: () => X(Object(J.k)(V.id, "post_mod_action_menu"))
					}, o.a.createElement(xe, null), o.a.createElement(M.a, {
						canEditFlair: h && !!ee,
						hasModFullPerms: f,
						hasModPostPerms: g,
						isOverlay: !!C,
						isPostAuthor: qe,
						modModeEnabled: w,
						post: V,
						tooltipId: Qe
					})), g && Ke && !w && o.a.createElement(L.c, {
						text: `${Je}`,
						onClick: () => {
							W(Ve), X(Object(J.k)(V.id, "post_report_menu"))
						},
						id: Ve
					}, o.a.createElement(B.a, {
						model: V,
						onIgnoreReports: () => {
							H(), X(Object(Q.m)(V.ignoreReports ? "restore_reports" : "ignore_reports", V.id))
						},
						tooltipId: Ve
					}), o.a.createElement(Y.a, {
						className: he.a.icon,
						name: V.ignoreReports ? "ignore_reports" : "report"
					})), Re && o.a.createElement(z.a, {
						displayText: s.fbt._("Insights", null, {
							hk: "2IyDq5"
						}),
						textClassName: Object(d.a)(he.a.responsiveRowText, he.a.insightsButtonText),
						flatlistItem: se.a.Insights,
						isLoggedIn: !!u,
						isUserOp: pe,
						onClick: F,
						skipRoleAttr: !0
					}, o.a.createElement(E.a, {
						postCreated: V.created,
						subredditId: V.belongsTo.id
					})), !st && o.a.createElement("div", {
						className: he.a.overflowMenuContainer
					}, o.a.createElement(D.a, {
						currentProfileName: l,
						dropdownId: Ie("-overflow-menu", V.id, C, I),
						ignoreOverflowMenuBreakpoints: Pe,
						isCommentsPage: v,
						isFixed: I,
						isOverlay: !!C,
						isProfilePostListing: k,
						isRecommendationPost: nt,
						layout: S,
						modModeWithPost: w && g,
						onClickInsightsButton: F,
						pageLayer: q,
						permalink: V.permalink,
						postId: Ye,
						sendEvent: X,
						shouldShowInsightsButton: Re,
						showEditPost: !!ae,
						showEditFlair: !!ee,
						useFlatlistBreakpoints: e.useFlatlistBreakpoints,
						toggleAddEventStartTimeModal: ue,
						toggleEditStartTimeModal: ue
					})), t === Object(te.t)(V.id, C) && o.a.createElement(de.a, {
						subredditId: V.belongsTo.id,
						onClose: De,
						postId: V.id,
						onSelectCollection: Fe,
						titleText: s.fbt._("Add post to a collection", null, {
							hk: "38vSyF"
						}),
						onItemHoverActionText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						isOverlay: C
					}), t === Object(te.s)(V.id, C, te.k.POST_OVERFLOW_MENU) && ge && o.a.createElement(ge, {
						onChange: a,
						onClose: ue,
						schedule: Object(p.c)(V),
						shouldShowDeleteButton: !1
					}), t === Object(te.u)(V.id, C) && o.a.createElement(ce.a, {
						onCancel: Le,
						onCollectionCreated: Fe,
						subredditId: V.belongsTo.id
					}), t === Object(A.b)(V.id, C) && o.a.createElement(A.a, {
						flairs: V.flair,
						subredditId: V.belongsTo.id,
						modalId: Object(A.b)(V.id, C),
						onFlairChanged: U
					}), o.a.createElement("div", {
						className: he.a.flexSpacer
					})), $e && !tt && o.a.createElement(O.a, {
						className: Object(d.a)(he.a.liveDiscussionWrapper, {
							[he.a.modLargePost]: j && g
						}),
						postId: V.postId
					}))
				});
			ke.displayName = "Flatlist";
			const Ie = (e, t, n, s) => {
					let r = t;
					return n && (r += "-overlay"), s && (r += "-sticky"), r += e
				},
				Se = ye(Ce(Object(U.c)(ke)));
			t.c = o.a.memo((function(e) {
				const t = Object(le.a)();
				return o.a.createElement(Se, fe({}, e, {
					searchIgnoreClick: t
				}))
			}))
		},
		"./src/reddit/components/Footer/index.m.less": function(e, t, n) {
			e.exports = {
				FooterContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				footerContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				mIsWhite: "_3TyrvwTfHlJHEevBoOKkDJ",
				PrivacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				privacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				UserAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				userAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				UserAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				userAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				mIsGrey: "_2g4mHpbVF30jxvk8ZPbqBe"
			}
		},
		"./src/reddit/components/Footer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/Footer/index.m.less"),
				c = n.n(d);
			const {
				fbt: l
			} = n("./node_modules/fbt/lib/FbtPublic.js"), u = i.a.div("UserAgreement", c.a), m = i.a.a("UserAgreementLink", c.a), p = i.a.a("PrivacyLink", c.a);
			var b;
			! function(e) {
				e.Grey = "grey", e.White = "white"
			}(b || (b = {}));
			t.b = e => r.a.createElement("div", {
				className: Object(a.a)(c.a.FooterContainer, {
					[c.a.mIsGrey]: e.textColor === b.Grey,
					[c.a.mIsWhite]: e.textColor === b.White
				})
			}, r.a.createElement(u, null, l._("Use of this site constitutes acceptance of our {=User Agreement} and {=Privacy Policy.} {year} reddit inc. All rights reserved. REDDIT and the ALIEN Logo are registered trademarks of reddit inc.", [l._param("=User Agreement", r.a.createElement(m, {
				href: `${o.a.redditUrl}/help/useragreement`
			}, l._("User Agreement", null, {
				hk: "YviZP"
			}))), l._param("=Privacy Policy.", r.a.createElement(p, {
				href: `${o.a.redditUrl}/help/privacypolicy`
			}, l._("Privacy Policy.", null, {
				hk: "1fsgYq"
			}))), l._param("year", (new Date).getFullYear())], {
				hk: "3wzgp7"
			})))
		},
		"./src/reddit/components/GeoForm/GeoForm.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/uuid/v4.js"),
				d = n.n(i),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/hooks/useMounted.ts"),
				m = n("./node_modules/p-debounce/index.js"),
				p = n.n(m),
				b = n("./src/lib/hooks/useOnClickOutside.ts"),
				h = n("./src/reddit/constants/keycodes.ts"),
				f = n("./src/lib/makeGqlRequest/index.ts"),
				g = n("./src/lib/sentry/index.ts"),
				_ = n("./src/redditGQL/operations/GeoPlaceAutocomplete.json");
			! function(e) {
				e.GoogleMaps = "GOOGLE_MAPS", e.Geonames = "GEONAMES"
			}(s || (s = {}));
			const v = (e, t) => async n => {
				let s;
				try {
					s = await async function(e, t) {
						return Object(f.a)(e, {
							..._,
							variables: t
						})
					}(e(), {
						query: n,
						sessionId: t
					})
				} catch (r) {
					return g.c.captureException(r), []
				}
				return s.body.data.geoPlaceAutocomplete || []
			};
			var O = n("./src/reddit/hooks/useGqlContext.ts"),
				x = n("./src/reddit/icons/svgs/Location/index.tsx"),
				E = n("./src/reddit/components/GeoForm/index.m.less"),
				y = n.n(E);

			function j(e) {
				const {
					value: t,
					setValue: n,
					setPlace: s,
					disabled: i,
					onFocus: d,
					sessionId: l,
					className: u
				} = e, m = Object(O.a)(), [b, f] = Object(o.useState)(!1), g = function(e, t, n) {
					const [s, r] = Object(o.useState)([]), a = Object(o.useMemo)(() => p()(n, 300), [n]);
					return Object(o.useEffect)(() => {
						e && t && a(e).then(e => {
							r(e)
						}).catch(() => r([]))
					}, [e]), s
				}(t, b, v(m, l)), {
					highlightValue: _,
					selectedIndex: E,
					onKeyDown: j,
					isClosed: k,
					setClosed: I
				} = function(e, t, n) {
					const [s, r] = Object(o.useState)(-1), [a, i] = Object(o.useState)(!!e.length), [d, c] = Object(o.useState)(void 0);
					return {
						highlightValue: d,
						selectedIndex: s,
						onKeyDown: o => {
							if (o.key === h.b.ArrowDown) {
								const t = Math.min(s + 1, e.length - 1);
								r(t), c(e[t])
							} else if (o.key === h.b.ArrowUp) {
								const t = Math.max(s - 1, -1);
								r(t), c(e[t])
							} else o.key === h.b.Enter && s > -1 ? (r(-1), t(e[s].name), n(e[s]), i(!0), o.preventDefault()) : o.key === h.b.Escape ? (r(-1), i(!0)) : c(void 0)
						},
						isClosed: a,
						setClosed: i
					}
				}(g, n, s), S = `location-input-${l}`;
				return a.a.createElement("div", {
					className: y.a.autocompleteInput
				}, a.a.createElement("label", {
					className: y.a.geoLabel,
					htmlFor: S
				}, a.a.createElement(x.a, {
					className: y.a.locationIcon
				})), a.a.createElement("input", {
					className: Object(c.a)(y.a.geoInput, u),
					name: S,
					disabled: i,
					onKeyDown: j,
					value: _ && _.name || t,
					placeholder: r.fbt._("Add location", null, {
						hk: "1BaqFd"
					}),
					onChange: e => {
						n(e.currentTarget.value), s(void 0), I(!1)
					},
					onFocus: () => {
						f(!0), d()
					},
					onBlur: () => f(!1)
				}), g.length && !k ? a.a.createElement(C, {
					id: l,
					items: g.map(e => e.name),
					selectedIndex: E,
					selectValue: e => {
						n(g[e].name), s(g[e]), I(!0)
					},
					onClickOutside: () => I(!0)
				}) : null)
			}

			function C(e) {
				const {
					id: t,
					items: n,
					selectedIndex: s,
					selectValue: r,
					onClickOutside: o
				} = e;
				return Object(b.a)(`autocomplete-dropdown-${t}`, o), a.a.createElement("ul", {
					className: y.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${t}`
				}, n.map((e, t) => a.a.createElement("li", {
					key: `${e}${t}`,
					onClick: () => r(t),
					className: Object(c.a)({
						[y.a.highlight]: t === s
					})
				}, e)))
			}
			const k = () => {};

			function I(e) {
				const {
					className: t,
					initialValue: n,
					initialPlace: s,
					disabled: i = !1,
					onFocus: m = k,
					onPlace: p = k,
					onValue: b = k,
					inputClassName: h
				} = e, f = Object(u.a)(), [g] = Object(o.useState)(() => d()()), [_, v] = Object(o.useState)(n || ""), [O, x] = Object(o.useState)(s);
				return f ? a.a.createElement("form", {
					className: Object(c.a)(y.a.geoForm, t),
					onSubmit: t => {
						t.preventDefault(), (null == s ? void 0 : s.id) !== (null == O ? void 0 : O.id) && e.onSubmit({
							name: _,
							place: O,
							sessionId: g
						})
					}
				}, a.a.createElement(j, {
					className: h,
					value: _,
					sessionId: g,
					setValue: e => {
						v(e), b(e)
					},
					setPlace: e => {
						x(e), p(e)
					},
					disabled: i,
					onFocus: m
				}), O && O.id !== (null == s ? void 0 : s.id) && a.a.createElement(l.o, {
					className: y.a.submitButton,
					type: "submit",
					disabled: i
				}, r.fbt._("Submit", null, {
					hk: "4aU3dh"
				}))) : null
			}
		},
		"./src/reddit/components/GeoForm/index.m.less": function(e, t, n) {
			e.exports = {
				geoForm: "dnC9V9HtkUxsmza-vEXgC",
				geoLabel: "_3T9bJ1ttSXUxb9rxZI9jMC",
				locationIcon: "_2Jm0p-hd1-KYZJI9iP3n6",
				geoInput: "_2O28-fZaU1kYnMmsiMKw3y",
				autocompleteInput: "oP84ZJjEgYLr154hrXHd8",
				autocompleteDropdown: "_1pwsnPyclgUCyjdfT0xWmx",
				highlight: "_1kfPE4TrjHsTFgvmrF1s33"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_17AlFvm1kWw8NYe0FZKlMB",
				newBadge: "_18TPfQgPhTmXJ8270Nc5nM",
				text: "_26N1OuVJykHlztxQkPEfqb",
				freeAwardTooltip: "_1C7AEhBd1Od4VDczirG0jB",
				freeAwardContainer: "P0AA_X8_E-4IwAxzn2uke"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.m.less": function(e, t, n) {
			e.exports = {
				titleRow: "_1knBg4PWacEaLvDRHAvsTp",
				flairDetails: "_2bPY-7msbc_UjCac-In6Li",
				flairEditColumn: "_2ebZb7SML8ZCy-QsS6tUc0",
				column: "_3vuuCvX3U56Wb64Bz3AX9W",
				iconsColumn: "Q9C1YLEYQHPi_NuLIcsS3",
				removeIcon: "_2IP600IxdVV8-hzfus_xst",
				removeButton: "Yd-aY1XSmw6atYPPJHm9n",
				row: "_3W5UQ4TDClfiDY4zEBYSqT",
				flairEditHelperText: "_2JpPK1gCbDBJBbMRrx-fe6",
				errorIndicator: "_1gmumWT2YihpY16NJJw_ac",
				hasError: "Uu_my_fNiUJaUT-wFhyeq",
				flairContainer: "_1c46XAzSY3wg6lATaRh11v",
				userLink: "_14IDyvxQsRUGTR9unevdzm",
				textInput: "_3OzKI46CUHBipWh2v7Cfq",
				dropdownTriangle: "_3L2zEwdN8hdor-MjnuTTXx",
				dropdownTarget: "_2q91kdzeOjUsLeozfWfPZI",
				dropdownContainer: "_2SgxV6WihN0lLBZ06jChDN",
				dropdownRow: "Hsh_7uWgjhtYFcA5QqiI6",
				userIcon: "uHVmBRWHNpGMMkIFBthWs",
				modIcon: "_31YDoZrj2KLLxWJhYimRfb",
				infoTooltip: "i75byXeh_ZzdbD0HGxb4",
				tooltipText: "_3FXJw0xh37YZHaJP_j3Npe",
				tooltipIconContainer: "_1dZeti3tpsM8YrfluheTX5",
				tooltipIconRow: "_2B9YDCXdUsKx20YPQ_0guj",
				tooltipIconText: "_2_doCenMWfLXsGEvDSq1NB",
				cssInputError: "_3ySNKx0QJZRCNOFB6345zX",
				bottomBarRow: "Tf16TWgXZcNKzLmD4PDPq",
				topBar: "e-h9YD6UZh8FOUPTG6drY",
				disabledBanner: "_3rrCSsx0QD7pFwGJquTq-6",
				warningIcon: "_3MSU8YNfdz6icABES0GIkK",
				emptyList: "y4YDfdWBHO7s3GVuYjBDF",
				flairIcon: "_3RYWcdo8Ov1AjwCGeCUsfs",
				mainText: "_8uYoAAuUrGW1iwcBP-2eS",
				fadeIn: "_3YR0vW4lNgbJJ7RgssVmf-"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/find.js"),
				a = n.n(o),
				i = n("./node_modules/react/index.js"),
				d = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts"),
				m = n("./src/lib/omitKey/index.ts"),
				p = n("./src/lib/stripQueryParams/index.ts"),
				b = n("./src/reddit/actions/grantUserFlair/index.ts"),
				h = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				_ = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				v = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				O = n("./src/lib/classNames/index.ts"),
				x = n("./src/reddit/components/SaveIndicator/index.m.less"),
				E = n.n(x),
				y = n("./src/reddit/icons/svgs/CheckmarkFitted/index.tsx"),
				j = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				C = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				k = n("./src/reddit/models/ApiRequestState/index.ts");
			const I = {
				[k.a.Pending]: () => r.fbt._("Saving", null, {
					hk: "3r9uZO"
				}),
				[k.a.Complete]: () => r.fbt._("Saved", null, {
					hk: "e9tAk"
				}),
				[k.a.Failed]: () => r.fbt._("Save error", null, {
					hk: "3NFi3S"
				})
			};
			var S = e => d.a.createElement(d.a.Fragment, null, e.status === k.a.Pending && d.a.createElement(C.a, {
					className: Object(O.a)(E.a.icon, E.a.pendingIcon)
				}), e.status === k.a.Complete && d.a.createElement(y.a, {
					className: Object(O.a)(E.a.icon, E.a.savedIcon)
				}), e.status === k.a.Failed && d.a.createElement(j.a, {
					className: Object(O.a)(E.a.icon, E.a.saveErrorIcon)
				}), d.a.createElement("span", {
					className: E.a.caption
				}, I[e.status]())),
				w = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				T = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				N = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				P = n("./src/reddit/components/TrackingHelper/index.tsx"),
				R = n("./src/reddit/constants/colors.ts"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				M = n("./src/reddit/helpers/flair.ts"),
				D = n("./src/reddit/selectors/telemetry.ts");
			const L = e => ({
					subreddit: D.hb(e),
					profile: D.R(e),
					userSubreddit: D.rb(e)
				}),
				F = e => t => ({
					source: "grant_user_flair",
					action: "click",
					noun: e,
					...L(t)
				}),
				U = () => F("search_username"),
				B = () => F("page_forward"),
				G = () => F("page_back"),
				H = () => F("remove_granted_user_flair"),
				W = (e, t) => n => ({
					source: "grant_user_flair",
					action: "autosave",
					noun: e,
					actionInfo: {
						...D.d(n),
						settingValue: t
					},
					...L(n)
				}),
				q = () => W("flair_text"),
				V = e => W("flair_template", e || "none"),
				z = e => W("css_class", e);
			var K = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Q = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				J = n("./src/reddit/icons/svgs/User/index.tsx"),
				Y = n("./src/reddit/models/SubredditModeration/index.ts");
			const X = [];
			var Z = n("./src/reddit/selectors/meta.ts"),
				$ = n("./src/reddit/selectors/userFlair.ts"),
				ee = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				te = n("./src/reddit/components/GrantUserFlair/index.m.less"),
				ne = n.n(te);
			var se = () => d.a.createElement("div", {
					className: ne.a.emptyList
				}, d.a.createElement(ee.a, {
					className: ne.a.flairIcon
				}), d.a.createElement("div", {
					className: ne.a.mainText
				}, r.fbt._("You do not have any users with user flair", null, {
					hk: "4D1S5Z"
				})), d.a.createElement("div", null, r.fbt._("Search for a user to assign a user flair", null, {
					hk: "2YaDOy"
				}))),
				re = n("./node_modules/lodash/filter.js"),
				oe = n.n(re),
				ae = n("./node_modules/lodash/isEqual.js"),
				ie = n.n(ae),
				de = n("./node_modules/lodash/omit.js"),
				ce = n.n(de),
				le = n("./src/reddit/constants/flair.ts"),
				ue = n("./src/reddit/helpers/validateFlairCssClass.ts");
			const me = 200;
			var pe;
			! function(e) {
				e[e.Save = 0] = "Save", e[e.Delete = 1] = "Delete"
			}(pe || (pe = {}));
			const be = e => null === e.flair,
				he = e => !(!e.apiError && !e.clientValidationError),
				fe = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const n = Date.now();
					return oe()(e, e => {
						if (!e || e.clientValidationError) return !1;
						if (e.apiError && !t) return !1;
						if (be(e)) return !0;
						return n - e.changedAt > 2e3 || t
					})
				},
				ge = (e, t, n) => {
					const s = Object.keys(e).filter(s => {
						const r = e[s],
							o = t[s] || null;
						return !(!!o || s === n || !he(r)) || !!ie()(o, r.flair)
					});
					return s.length ? ce()(e, s) : e
				},
				_e = (e, t) => {
					const n = t || le.a;
					return (e ? Object(M.m)(e, n) || Object(ue.a)(e.cssClass || "") : "") || void 0
				};
			var ve = n("./node_modules/lodash/noop.js"),
				Oe = n.n(ve),
				xe = n("./src/reddit/components/Flair/index.tsx"),
				Ee = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				ye = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				je = n("./src/reddit/controls/InternalLink/index.tsx"),
				Ce = n("./src/reddit/icons/svgs/Remove/index.tsx"),
				ke = n("./src/reddit/models/Flair/index.ts"),
				Ie = n("./src/higherOrderComponents/asTooltip.tsx"),
				Se = n("./src/reddit/actions/tooltip.ts"),
				we = n("./src/reddit/constants/keycodes.ts"),
				Te = n("./src/reddit/controls/Dropdown/index.tsx"),
				Ne = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				Pe = n("./src/reddit/selectors/tooltip.ts");
			const Re = e => `UserFlairPicker--${e}`,
				Ae = Object(Ie.a)(Te.a),
				Me = e => {
					let {
						flair: t
					} = e;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(xe.b, {
						flair: Object(M.c)(t),
						forceSmallEmojis: !0
					}), t.textEditable && d.a.createElement(J.a, {
						className: ne.a.userIcon
					}), t.modOnly && d.a.createElement(K.a, {
						className: ne.a.modIcon
					}))
				},
				De = Object(l.c)({
					isDropdownOpen: (e, t) => Object(Pe.b)(Re(t.userName))(e)
				});
			class Le extends d.a.Component {
				constructor(e) {
					super(e), this.onSetFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.findNextFocusableItem = () => {
						if (void 0 === this.state.focusedIndex) return -1; {
							const e = this.state.focusedIndex + 1;
							if (e <= this.props.templateIds.length - 1) return e
						}
					}, this.onMouseEnter = e => {
						const t = document.getElementById(`focus-${e}`);
						t && (t.focus(), this.onSetFocus(e))
					}, this.findPreviousFocusableItem = () => {
						if (void 0 !== this.state.focusedIndex && -1 !== this.state.focusedIndex) return this.state.focusedIndex - 1
					}, this.onKeyDown = e => {
						if (e.keyCode === we.a.ArrowDown)
							if (e.preventDefault(), this.props.isDropdownOpen) {
								const e = this.findNextFocusableItem();
								if (void 0 !== e) {
									const t = document.getElementById(`focus-${e}`);
									t && (t.focus(), t.scrollIntoView({
										block: "nearest"
									})), this.onSetFocus(e)
								}
							} else this.props.onToggleDropdown();
						if (e.keyCode === we.a.ArrowUp) {
							e.preventDefault();
							const t = this.findPreviousFocusableItem();
							if (void 0 !== t) {
								const e = document.getElementById(`focus-${t}`);
								e && (e.focus(), e.scrollIntoView({
									block: "nearest"
								})), this.onSetFocus(t)
							}
						}
						if (e.keyCode === we.a.Tab && this.props.isDropdownOpen && e.preventDefault(), e.keyCode === we.a.Enter) {
							if (e.preventDefault(), e.stopPropagation(), this.props.isDropdownOpen && void 0 !== this.state.focusedIndex) {
								const e = this.props.templateIds[this.state.focusedIndex];
								this.props.onSelectFlairTemplate(e)
							}
							this.props.onToggleDropdown()
						}
					}, this.state = {}
				}
				render() {
					const {
						props: e
					} = this;
					return d.a.createElement("button", {
						className: ne.a.dropdownTarget,
						id: Re(e.userName),
						onClick: e.onToggleDropdown,
						onKeyDown: this.onKeyDown
					}, e.selectedTemplateId && e.userFlairTemplates[e.selectedTemplateId] ? d.a.createElement(Me, {
						flair: e.userFlairTemplates[e.selectedTemplateId]
					}) : r.fbt._("none", null, {
						hk: "ng6B"
					}), d.a.createElement(Ne.a, {
						className: ne.a.dropdownTriangle
					}), d.a.createElement(Ae, {
						className: ne.a.dropdownContainer,
						isOpen: e.isDropdownOpen,
						tooltipId: Re(e.userName)
					}, d.a.createElement("button", {
						className: ne.a.dropdownRow,
						id: "focus--1",
						onClick: () => e.onSelectFlairTemplate(void 0),
						onMouseEnter: () => this.onMouseEnter(-1),
						tabIndex: -1
					}, r.fbt._("none", null, {
						hk: "ng6B"
					})), e.templateIds.map((t, n) => {
						const s = e.userFlairTemplates[t];
						return d.a.createElement("button", {
							className: ne.a.dropdownRow,
							id: `focus-${n}`,
							key: t,
							onClick: () => e.onSelectFlairTemplate(t),
							onMouseEnter: () => this.onMouseEnter(n),
							tabIndex: -1
						}, d.a.createElement(Me, {
							flair: s
						}))
					})))
				}
			}
			var Fe = Object(c.b)(De, (e, t) => ({
				onToggleDropdown: () => e(Object(Se.h)({
					tooltipId: Re(t.userName)
				}))
			}))(Le);
			const Ue = e => `emoji-picker-${e}`,
				Be = Object(M.b)();
			class Ge extends d.a.PureComponent {
				constructor() {
					super(...arguments), this.onSelectFlairTemplate = e => {
						const t = e && this.props.userFlairTemplates[e],
							n = t ? Object(M.c)(t) : Be;
						this.props.onChange(this.props.username, n)
					}, this.onFlairContentChanged = e => {
						this.props.onChange(this.props.username, e)
					}, this.onChangeCssClass = e => {
						const t = e.target.value,
							n = this.props.flair || Be;
						this.props.onChange(this.props.username, {
							...n,
							cssClass: t
						})
					}, this.removeFlair = () => {
						this.props.onChange(this.props.username, null)
					}
				}
				render() {
					const {
						props: e
					} = this, {
						hasError: t
					} = e, n = e.flair || Be, s = Object(Ee.a)(), r = n.templateId, o = r && e.userFlairTemplates[r] || le.a, a = !!o && o.modOnly, i = !Object(ue.a)(n.cssClass || "");
					return d.a.createElement("div", {
						className: Object(O.a)(ne.a.row, t ? ne.a.hasError : null)
					}, d.a.createElement("div", {
						className: ne.a.errorIndicator
					}, d.a.createElement(j.a, null)), d.a.createElement(je.default, {
						className: ne.a.userLink,
						to: `/user/${e.username}`
					}, d.a.createElement(ye.a, {
						user: e.username,
						tooltipId: `grantuserflair--userhovercard--${e.username}`,
						subredditId: e.subredditId,
						sendHoverCardEvent: Oe.a
					}, e.username, d.a.createElement("div", {
						className: ne.a.flairContainer
					}, d.a.createElement(xe.b, {
						flair: n
					})))), d.a.createElement("div", {
						className: ne.a.flairDetails
					}, d.a.createElement("div", {
						className: ne.a.column
					}, d.a.createElement(Fe, {
						onSelectFlairTemplate: this.onSelectFlairTemplate,
						selectedTemplateId: r,
						templateIds: e.templateIds,
						userFlairTemplates: e.userFlairTemplates,
						userName: this.props.username
					})), d.a.createElement("div", {
						className: ne.a.flairEditColumn
					}, d.a.createElement(s, {
						allowBlank: !e.isChanged,
						emojiPickerId: Ue(e.username),
						flair: n,
						flairTemplateType: ke.d.UserFlair,
						flairTemplate: o,
						helperTextClass: ne.a.flairEditHelperText,
						isCompact: !0,
						isFlairModOnly: a,
						onChange: this.onFlairContentChanged,
						subredditId: e.subredditId
					})), d.a.createElement("div", {
						className: ne.a.column
					}, d.a.createElement("input", {
						className: Object(O.a)(ne.a.textInput, {
							[ne.a.cssInputError]: !i
						}),
						value: n.cssClass || "",
						onChange: this.onChangeCssClass,
						disabled: !!o.id
					})), d.a.createElement("button", {
						className: ne.a.removeButton,
						onClick: this.removeFlair
					}, d.a.createElement(Ce.a, {
						className: ne.a.removeIcon
					}))))
				}
			}
			var He = Ge;
			const We = {},
				qe = Object(A.u)({
					currentPageUrl: A.f
				}),
				Ve = Object(l.c)({
					flairedUserOrder: (e, t) => {
						const n = Object(Y.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.userOrder[n] || X
					},
					flairedUsers: (e, t) => e.pages.modHub.flairedUsers.models[t.subredditId],
					isFlairedUsersListPending: e => e.pages.modHub.flairedUsers.api.pending,
					isSearchPending: e => e.pages.modHub.flairedUsers.search.api.pending,
					isUserFlairEnabled: $.a,
					origin: Z.k,
					pageInfo: (e, t) => {
						const n = Object(Y.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.pageInfo[n]
					},
					searchResult: (e, t) => e.pages.modHub.flairedUsers.search.result,
					userFlairData: $.d
				}),
				ze = Object(c.b)(Ve, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						deleteUserFlair: (t, n) => e(Object(b.a)(t, n)),
						saveFlairedUser: (t, s) => e(Object(b.d)(t, n, s)),
						searchFlairedUser: t => e(Object(b.e)(n, t))
					}
				});
			class Ke extends d.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.isUnmounted = !1, this.pendingRequestsMap = new Map, this.autoSaveIntervalId = 0, this.processChanges = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						t.autoSaveIntervalId || (t.autoSaveIntervalId = window.setInterval(t.processChanges, me));
						const {
							flairedUsers: n
						} = t.props, {
							unsavedChanges: s,
							searchTerm: r
						} = t.state, o = ge(s, n, r), a = fe(o, e);
						a.forEach(t.sendChangeToServer), o !== s && t.setState({
							unsavedChanges: o
						})
					}, this.sendChangeToServer = async e => {
						const t = e.username;
						if (this.pendingRequestsMap.get(t)) return;
						const n = this.props.flairedUsers[t] || null;
						this.sendTelemetryEvents(n, e.flair);
						const s = e.flair ? {
							type: pe.Save,
							promise: this.props.saveFlairedUser(t, e.flair)
						} : {
							type: pe.Delete,
							promise: this.props.deleteUserFlair(t, this.props.subredditId)
						};
						this.pendingRequestsMap.set(t, s);
						const r = await s.promise;
						this.pendingRequestsMap.delete(t), this.isUnmounted || this.setState(n => {
							const s = n.unsavedChanges[t];
							return e !== s ? null : {
								unsavedChanges: !0 === r ? Object(m.a)(n.unsavedChanges, t) : {
									...this.state.unsavedChanges,
									[t]: {
										...e,
										apiError: r
									}
								}
							}
						})
					}, this.onFlairChanged = (e, t) => {
						const {
							templates: n
						} = this.props.userFlairData, s = t && t.templateId ? n[t.templateId] : void 0;
						this.setState(n => {
							return {
								unsavedChanges: {
									...n.unsavedChanges,
									[e]: {
										flair: t,
										username: e,
										changedAt: Date.now(),
										clientValidationError: _e(t, s)
									}
								}
							}
						})
					}, this.onSearch = e => {
						this.props.searchFlairedUser(e), this.setState({
							searchTerm: e
						}), this.props.sendEvent(U())
					}, this.onCancelSearch = () => {
						this.setState({
							searchTerm: null
						})
					}, this.onClickNextPage = () => this.props.sendEvent(B()), this.onClickPrevPage = () => this.props.sendEvent(G()), this.renderUserRow = e => {
						const {
							state: t,
							props: n
						} = this, s = n.flairedUsers[e] || null, r = t.unsavedChanges[e], o = r && !be(r) ? r.flair : s;
						return d.a.createElement(He, {
							flair: o,
							hasError: !!r && he(r),
							isChanged: !!r,
							key: e,
							onChange: this.onFlairChanged,
							subredditId: n.subredditId,
							templateIds: n.userFlairData.templateIds,
							userFlairTemplates: n.userFlairData.templates,
							username: e
						})
					}, this.state = {
						searchTerm: null,
						unsavedChanges: We
					}
				}
				componentDidUpdate() {
					this.processChanges()
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.processChanges(!0), window.clearInterval(this.autoSaveIntervalId)
				}
				sendTelemetryEvents(e, t) {
					if (!t) return void this.props.sendEvent(H());
					let n = e || Object(M.b)();
					const s = n.templateId || void 0,
						r = t.templateId || void 0;
					if (r !== s) {
						this.props.sendEvent(V(r));
						const e = t.templateId && this.props.userFlairData.templates[t.templateId];
						n = e ? Object(M.c)(e) : n
					}
					Object(M.p)(t, n) || this.props.sendEvent(q()), t.cssClass !== n.cssClass && this.props.sendEvent(z(t.cssClass || ""))
				}
				getIndicatorStatus() {
					const {
						unsavedChanges: e
					} = this.state;
					if (e === We) return null;
					const t = !!a()(e, e => he(e));
					return !!a()(e, e => !he(e)) ? k.a.Pending : t ? k.a.Failed : k.a.Complete
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = this.getIndicatorStatus(), o = e.pageInfo && (e.pageInfo.hasNextPage || e.pageInfo.hasPreviousPage), a = !e.flairedUserOrder.length && !o;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(v.c, {
						className: ne.a.topBar
					}, null !== n && d.a.createElement(S, {
						status: n
					})), d.a.createElement(v.a, null, d.a.createElement(v.b, null, r.fbt._("Grant user flair", null, {
						hk: "N1r42"
					}), d.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360028091332`
					})), !e.isUserFlairEnabled && d.a.createElement(h.a, {
						className: ne.a.disabledBanner,
						color: R.a.quarantine,
						icon: d.a.createElement(Q.a, {
							className: ne.a.warningIcon
						}),
						title: r.fbt._("User flair has been disabled for this community", null, {
							hk: "3BBvFe"
						}),
						subtitle: r.fbt._("User flair will not be displayed in posts or comments", null, {
							hk: "3E4WaA"
						})
					}), d.a.createElement(T.b, {
						activeSearchQuery: t.searchTerm,
						onSearch: this.onSearch
					}, e.pageInfo && !t.searchTerm && d.a.createElement(_.a, {
						prevTo: Object(u.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							after: e.pageInfo.endCursor
						})
					})), d.a.createElement("div", {
						className: ne.a.titleRow
					}, r.fbt._("Username with preview", null, {
						hk: "1RFjbI"
					}), d.a.createElement("div", {
						className: ne.a.flairDetails
					}, d.a.createElement("div", {
						className: ne.a.column
					}, r.fbt._("Flair template", null, {
						hk: "18cQfH"
					}), d.a.createElement(g.a, {
						className: ne.a.infoTooltip
					}, d.a.createElement("div", {
						className: ne.a.tooltipText
					}, r.fbt._("Flair templates determine the flair's background colors, text colors, and permissions", null, {
						hk: "4y58Eg"
					})), d.a.createElement("div", {
						className: ne.a.tooltipIconContainer
					}, d.a.createElement("div", {
						className: ne.a.tooltipIconRow
					}, d.a.createElement(K.a, {
						className: ne.a.modIcon
					}), d.a.createElement("span", {
						className: ne.a.tooltipIconText
					}, r.fbt._("Available only to mods", null, {
						hk: "2s7Gci"
					}))), d.a.createElement("div", {
						className: ne.a.tooltipIconRow
					}, d.a.createElement(J.a, {
						className: ne.a.userIcon
					}), d.a.createElement("span", {
						className: ne.a.tooltipIconText
					}, r.fbt._("User editable", null, {
						hk: "3tIGRy"
					})))))), d.a.createElement("div", {
						className: ne.a.flairEditColumn
					}, r.fbt._("Flair text", null, {
						hk: "2ab8Up"
					}), d.a.createElement(g.a, {
						text: r.fbt._("Changes the text and emojis within the user flair", null, {
							hk: "4dBW4C"
						})
					})), d.a.createElement("div", {
						className: ne.a.column
					}, r.fbt._("Css class", null, {
						hk: "1TNNcJ"
					}), d.a.createElement(g.a, {
						text: r.fbt._("CSS classes determine styling for flair in old Reddit", null, {
							hk: "j4AU"
						})
					})))), t.searchTerm ? d.a.createElement(w.a, {
						cancelSearch: this.onCancelSearch,
						noResultsFound: !e.searchResult,
						searchTerm: t.searchTerm,
						searchPending: e.isSearchPending
					}, e.searchResult && this.renderUserRow(e.searchResult)) : e.isFlairedUsersListPending ? d.a.createElement(N.a, null) : a ? d.a.createElement(se, null) : e.flairedUserOrder.map(this.renderUserRow), e.pageInfo && !t.searchTerm && d.a.createElement("div", {
						className: ne.a.bottomBarRow
					}, d.a.createElement(_.a, {
						prevTo: Object(u.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							before: e.pageInfo.startCursor
						}),
						prevButtonEnabled: e.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: e.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(p.a)(`${e.origin}${e.currentPageUrl}`), {
							after: e.pageInfo.endCursor
						})
					}))))
				}
			}
			t.a = qe(ze(Object(P.c)(Ke)))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/actions/snoovatarModal.ts"),
				d = n("./src/reddit/actions/tooltip.ts"),
				c = n("./src/reddit/helpers/isPost.ts"),
				l = n("./src/reddit/selectors/commentSelector.ts"),
				u = n("./src/reddit/selectors/gold/awardIcon.ts"),
				m = n("./src/reddit/selectors/moderatorPermissions.ts"),
				p = n("./src/reddit/selectors/modUserNotes.ts"),
				b = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/profile.ts"),
				f = n("./src/reddit/selectors/structuredStyles.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/reddit/selectors/tooltip.ts"),
				v = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/selectors/userFlair.ts"),
				x = n("./src/reddit/selectors/userPrefs.ts"),
				E = n("./src/reddit/selectors/platform.ts"),
				y = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				j = n("./node_modules/fbt/lib/FbtPublic.js"),
				C = n("./src/config.ts"),
				k = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				I = n("./src/lib/lessComponent.tsx"),
				S = n("./src/lib/prettyPrintNumber/index.ts"),
				w = n("./src/reddit/components/Admin/index.tsx"),
				T = n("./src/reddit/components/ChatButton/index.tsx"),
				N = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				P = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				R = n("./src/reddit/components/SubscribeButton/index.tsx"),
				A = n("./src/reddit/components/UserIcon/index.tsx"),
				M = n("./src/reddit/controls/Button/index.tsx"),
				D = n("./src/reddit/endpoints/profile/info.ts"),
				L = n("./src/reddit/helpers/trackers/authorHovercard.ts"),
				F = n("./src/reddit/icons/fonts/Info/index.tsx"),
				U = n("./src/reddit/icons/svgs/Premium/index.tsx"),
				B = n("./src/reddit/models/Gold/Award.ts"),
				G = n("./src/reddit/models/User/index.ts"),
				H = n("./src/reddit/components/HumanDate/index.tsx"),
				W = n("./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx"),
				q = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx"),
				V = n("./src/reddit/actions/inContextModeration.ts"),
				z = n("./src/reddit/actions/modal.ts"),
				K = n("./src/reddit/actions/subredditModeration/ban.ts"),
				Q = n("./src/reddit/constants/modals.ts"),
				J = n("./src/reddit/components/Hovercards/helpers.ts"),
				Y = n("./src/reddit/icons/fonts/index.tsx"),
				X = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				Z = n("./src/reddit/selectors/bannedUser.ts"),
				$ = n("./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less"),
				ee = n.n($);
			const {
				fbt: te
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ne = Object(a.c)({
				hasModMailPermissions: Object(m.b)(X.c.mail),
				isUserBanned: (e, t) => !!Object(Z.b)(e, {
					subredditId: t.subredditId,
					username: t.username
				}),
				user: (e, t) => Object(v.Ab)(e, {
					userName: t.username
				})
			});
			class se extends r.a.Component {
				componentDidMount() {
					this.props.requestUserBanInfo()
				}
				render() {
					const {
						className: e,
						contextId: t,
						hasModMailPermissions: n,
						isUserBanned: s,
						onUnbanUser: o,
						sendEvent: a,
						toggleBanModal: i,
						toggleMuteModal: d
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, s ? r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							o(this.props.user.id), a(L.e(t))
						}
					}, r.a.createElement(Y.a, {
						name: "ban",
						isFilled: !0,
						className: ee.a.icon
					}), te._("Unban User", null, {
						hk: "1aASyW"
					})) : r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							i(), a(L.a(t))
						}
					}, r.a.createElement(Y.a, {
						name: "ban",
						className: ee.a.icon
					}), te._("Ban User", null, {
						hk: "3OhuLx"
					})), n && r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							d(), a(L.d(t))
						}
					}, r.a.createElement(Y.a, {
						name: "mod_mute",
						className: ee.a.icon
					}), te._("Mute User", null, {
						hk: "3MCujH"
					})))
				}
			}
			var re = Object(o.b)(ne, (e, t) => {
					let {
						username: n,
						subredditId: s,
						contextId: r
					} = t;
					return {
						onUnbanUser: t => e(Object(K.e)(s, t)),
						requestUserBanInfo: () => e(Object(K.c)(s, {
							username: n
						})),
						toggleBanModal: () => {
							e(Object(V.c)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(K.a)(s, n))
						},
						toggleMuteModal: () => {
							e(Object(V.d)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(z.i)(Q.a.MUTE_USER))
						}
					}
				})(se),
				oe = n("./src/reddit/actions/userFlair/index.ts");
			const {
				fbt: ae
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var ie = Object(o.b)(null, (e, t) => ({
					onToggleUserFlairModal: () => e(Object(oe.g)(t.subredditId, t.username))
				}))(e => r.a.createElement(J.a, {
					role: "button",
					onClick: () => {
						e.onToggleUserFlairModal(), e.sendEvent(L.c(e.contextId))
					}
				}, r.a.createElement(Y.a, {
					name: "tag",
					className: ee.a.icon
				}), ae._("Edit user flair", null, {
					hk: "4mTxM"
				}))),
				de = n("./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less"),
				ce = n.n(de);

			function le() {
				return (le = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const ue = I.a.wrapped(A.a, "UserIcon", ce.a),
				me = I.a.wrapped(R.a, "SubscribeButton", ce.a),
				pe = I.a.wrapped(T.b, "ChatButton", ce.a),
				be = I.a.wrapped(U.a, "PremiumIcon", ce.a),
				he = I.a.wrapped(k.a, "UserNameLink", ce.a),
				fe = I.a.div("UserNameMetaData", ce.a),
				ge = I.a.div("MetaDataItem", ce.a),
				_e = I.a.div("Bullet", ce.a),
				ve = I.a.div("UserNameContainer", ce.a),
				Oe = I.a.div("KarmaGrid", ce.a),
				xe = I.a.div("GenericKarma", ce.a),
				Ee = I.a.a("InfoLink", ce.a),
				ye = I.a.div("KarmaCount", ce.a),
				je = I.a.div("GenericKarmaLabel", ce.a),
				Ce = I.a.div("BannerImage", ce.a),
				ke = I.a.div("UserContainer", ce.a),
				Ie = I.a.div("BottomSpacer", ce.a),
				Se = I.a.div("Container", ce.a),
				we = e => r.a.createElement("div", null, r.a.createElement("div", null, r.a.createElement(he, {
					to: `/user/${e.userName}/`
				}, e.title || e.userName), e.user.isGold && r.a.createElement(k.a, {
					to: "/premium"
				}, r.a.createElement(be, null)), e.user.isEmployee && r.a.createElement(w.a, null)), r.a.createElement(fe, null, r.a.createElement(ge, null, `u/${e.userName}`, r.a.createElement(_e, null, "")), r.a.createElement(ge, null, (e.user.createdUtc || e.user.created) && r.a.createElement(H.d, {
					seconds: e.user.createdUtc || e.user.created
				})))),
				Te = e => {
					const {
						user: {
							karma: t
						}
					} = e, n = {
						...D.a,
						...t
					};
					return r.a.createElement(Oe, null, r.a.createElement(xe, null, r.a.createElement(ye, null, Object(S.b)(n.fromPosts)), r.a.createElement(je, null, j.fbt._({
						"*": "Post Karma",
						_1: " Post Karma"
					}, [j.fbt._plural(n.fromPosts)], {
						hk: "3K4oaH"
					}))), r.a.createElement(xe, null, r.a.createElement(ye, null, Object(S.b)(n.fromComments)), r.a.createElement(je, null, j.fbt._({
						"*": "Comment Karma",
						_1: " Comment Karma"
					}, [j.fbt._plural(n.fromComments)], {
						hk: "3gKRx9"
					}))), r.a.createElement(xe, null, r.a.createElement(ye, null, Object(S.b)(n.fromAwardsReceived)), r.a.createElement(je, null, j.fbt._({
						"*": "Awardee Karma",
						_1: " Awardee Karma"
					}, [j.fbt._plural(n.fromAwardsReceived)], {
						hk: "3nzm9q"
					}), r.a.createElement(Ee, {
						href: B.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, r.a.createElement(F.a, {
						className: ce.a.infoIcon
					})))), r.a.createElement(xe, null, r.a.createElement(ye, null, Object(S.b)(n.fromAwardsGiven)), r.a.createElement(je, null, j.fbt._({
						"*": "Awarder Karma",
						_1: " Awarder Karma"
					}, [j.fbt._plural(n.fromAwardsGiven)], {
						hk: "4zXN3B"
					}), r.a.createElement(Ee, {
						href: B.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, r.a.createElement(F.a, {
						className: ce.a.infoIcon
					})))))
				},
				Ne = e => {
					var t, n;
					const {
						className: s,
						contextId: o,
						currentUser: a,
						hideNSFWPref: i,
						hoverId: d,
						isLoggedIn: c,
						onClickSnoovatar: l,
						moderatorPermissions: u,
						prefersReducedAnimations: m,
						profile: p,
						sendEvent: b,
						style: h,
						subredditId: f,
						topAwardIcon: g,
						userName: _,
						user: v,
						userFlair: O,
						isCurrentUserBanned: x,
						userProfileStyles: E,
						acceptChats: y,
						isCommentAuthorBlocked: k
					} = e;
					if (!v) return r.a.createElement(Se, {
						style: h
					});
					const I = !!a && Object(G.e)(a) === _,
						S = !!(null == a ? void 0 : a.snoovatarFullBodyAsset),
						w = v.accountIcon || `${C.a.assetPath}/img/snoo_user_placeholder.png`,
						T = null == u ? void 0 : u.flair,
						P = null == u ? void 0 : u.access,
						R = (null == O ? void 0 : O.templateIds) && (null === (t = null == O ? void 0 : O.templateIds) || void 0 === t ? void 0 : t.length) > 0,
						A = null === (n = null == O ? void 0 : O.displaySettings) || void 0 === n ? void 0 : n.isEnabled,
						{
							awardedLastMonth: D
						} = v,
						F = !!v.snoovatarFullBodyAsset,
						U = v.isNSFW && i;
					let B;
					return B = F ? !U && E && E.bannerBackgroundImage || void 0 : U ? `${C.a.assetPath}/img/user-info-banner.png` : e.user.bannerImage, r.a.createElement(Se, {
						className: s,
						id: d,
						style: h
					}, !F && B && r.a.createElement(Ce, {
						style: {
							backgroundImage: `url('${B}')`
						}
					}), r.a.createElement(ke, null, F ? r.a.createElement(q.a, {
						isHovercard: !0,
						bannerBackgroundImage: B,
						compact: !0,
						currentUserHasSnoovatar: S,
						isEmployee: v.isEmployee,
						isGold: v.isGold,
						isNSFW: v.isNSFW,
						isOwnProfile: I,
						onClickSnoovatar: () => l && l(),
						prefersReducedAnimations: !!m,
						snoovatarUrl: v.snoovatarFullBodyAsset,
						title: null == p ? void 0 : p.title,
						userCreated: v.created,
						username: _,
						url: `/user/${e.userName}/`
					}) : r.a.createElement(ve, null, r.a.createElement(ue, {
						iconUrl: w,
						isNSFW: v.isNSFW,
						userName: _
					}), r.a.createElement(we, {
						title: null == p ? void 0 : p.title,
						user: v,
						userName: _
					})), r.a.createElement(Te, {
						user: v
					}), D && r.a.createElement(W.a, {
						recentAwardings: D,
						topAwardIcon: g,
						username: _
					}), c && !I && !x && y && !k && r.a.createElement(pe, {
						contextId: o,
						priority: M.c.Secondary,
						userId: v.id,
						text: j.fbt._("Start Chat", null, {
							hk: "2mfqRE"
						}),
						isFullWidth: !0
					}), v.hasUserProfile && !x && !k && !I && v.enableFollowers && r.a.createElement(me, {
						identifier: {
							name: e.user.username,
							type: "profile"
						},
						getEventFactory: e => Object(L.h)(e ? "unfollow" : "follow", o),
						isFullWidth: !0,
						small: !0
					})), P && o && !I && f && r.a.createElement(re, {
						contextId: o,
						subredditId: f,
						sendEvent: b,
						username: _
					}), T && o && R && A && f && r.a.createElement(ie, {
						contextId: o,
						subredditId: f,
						sendEvent: b,
						username: _
					}), r.a.createElement(N.i, {
						contextId: o,
						subredditId: f,
						user: v
					}), !(P || c) && r.a.createElement(Ie, null))
				},
				Pe = Object(P.a)(Ne),
				Re = e => {
					const t = e.activeTooltipId === e.tooltipId && !e.collapsed;
					return r.a.createElement(Pe, le({
						isOpen: t
					}, e))
				};
			Re.WrappedComponent = Ne;
			var Ae = Re;
			const Me = Object(a.c)({
					activeTooltipId: _.a,
					currentUser: v.k,
					isLoggedIn: v.Q,
					hideNSFWPref: v.F,
					moderatorPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(m.n)(e, {
							subredditId: n
						}) : void 0
					},
					prefersReducedAnimations: x.c,
					profile: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(h.j)(e, {
							profileName: n
						})
					},
					topAwardIcon: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(u.e)(e, {
							userName: n,
							minSize: 32
						})
					},
					user: v.Ab,
					userFlair: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(O.d)(e, {
							subredditId: n
						}) : void 0
					},
					isCurrentUserBanned: (e, t) => !!Object(g.n)(t) && Object(g.fb)(e, t),
					userProfileStyles: (e, t) => Object(f.m)(e, Object(h.m)(e, t.userName)),
					acceptChats: (e, t) => {
						const n = Object(h.h)(e, {
							profileName: t.userName
						});
						return !n || n.acceptChats
					},
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(E.e)(e),
							r = n || s && Object(g.F)(e, s.name);
						return !!r && Object(m.i)(e, r)
					},
					trophyCase: (e, t) => Object(h.r)(e, Object(h.m)(e, t.userName)),
					isNightMode: v.db,
					lastAuthorModNote: (e, t) => {
						if (!t.contextId) return;
						const n = Object(c.a)(t.contextId) ? Object(b.G)(e, {
							postId: t.contextId
						}) : Object(l.b)(e, {
							commentId: t.contextId
						});
						return Object(p.b)(e, null == n ? void 0 : n.authorId, t.subredditId)
					},
					userIsSubscriber: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(g.gb)(e, {
							identifier: {
								name: n,
								type: "profile"
							}
						})
					}
				}),
				De = Object(o.b)(Me, (e, t) => ({
					onClickSnoovatar: () => e(Object(i.b)({
						clickSource: "user_hovercard"
					})),
					onHideTooltip: () => e(Object(d.i)())
				}));
			t.a = De(e => e.isModWithUserNotesPermissions ? r.a.createElement(y.b, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				currentUser: e.currentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				moderatorPermissions: e.moderatorPermissions,
				prefersReducedAnimations: e.prefersReducedAnimations,
				profile: e.profile,
				subredditId: e.subredditId,
				tooltipId: e.tooltipId,
				user: e.user,
				isCurrentUserBanned: e.isCurrentUserBanned,
				userName: e.userName,
				userProfileStyles: e.userProfileStyles,
				acceptChats: e.acceptChats,
				isCommentAuthorBlocked: e.isCommentAuthorBlocked,
				collapsed: e.collapsed,
				trophyCase: e.trophyCase,
				isNightMode: e.isNightMode,
				lastAuthorModNote: e.lastAuthorModNote,
				userIsSubscriber: e.userIsSubscriber
			}) : r.a.createElement(Ae, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				currentUser: e.currentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				moderatorPermissions: e.moderatorPermissions,
				onClickSnoovatar: e.onClickSnoovatar,
				prefersReducedAnimations: e.prefersReducedAnimations,
				profile: e.profile,
				sendEvent: e.sendEvent,
				subredditId: e.subredditId,
				topAwardIcon: e.topAwardIcon,
				tooltipId: e.tooltipId,
				tooltipType: e.tooltipType,
				user: e.user,
				userFlair: e.userFlair,
				isCurrentUserBanned: e.isCurrentUserBanned,
				userName: e.userName,
				userProfileStyles: e.userProfileStyles,
				acceptChats: e.acceptChats,
				isCommentAuthorBlocked: e.isCommentAuthorBlocked,
				collapsed: e.collapsed
			}))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less": function(e, t, n) {
			e.exports = {
				icon: "xd9vrdS8_V6IVus6-mHAM"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/Hovercards/HoverDiv/index.tsx"),
				a = n("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				i = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = Object(i.c)(e => {
				const t = `${e.tooltipId}-hover-id`;
				return r.a.createElement(o.a, {
					className: e.wrapperClassName,
					hoverId: t,
					sendHoverEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId,
					authorOrSubredditName: e.user
				}, e.children, r.a.createElement(a.a, {
					className: e.className,
					hoverId: t,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					userName: e.user
				}))
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less": function(e, t, n) {
			e.exports = {
				ChatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				chatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				UserIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				userIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				SubscribeButton: "yFByQg8RzENoqoOt0ysAk",
				subscribeButton: "yFByQg8RzENoqoOt0ysAk",
				PremiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				premiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				Token: "_2U0P3n4v75sHsDvQmSKNz3",
				token: "_2U0P3n4v75sHsDvQmSKNz3",
				UserNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				userNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				UserNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				userNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				GildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				gildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				Bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				MetaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				metaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				UserNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				userNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				KarmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				karmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				GenericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				genericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				KarmaCount: "_18aX_pAQub_mu1suz4-i8j",
				karmaCount: "_18aX_pAQub_mu1suz4-i8j",
				GenericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				genericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				InfoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				infoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				BannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				bannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				UserContainer: "_m7PpFuKATP9fZF4xKf9R",
				userContainer: "_m7PpFuKATP9fZF4xKf9R",
				BottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				bottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				UserActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				userActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				Container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				container: "_1sbZnfdaxhCOFVUCJ3Z75m"
			}
		},
		"./src/reddit/components/Hovercards/SubredditHovercard/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("SubredditHovercard").then(n.bind(null, "./src/reddit/components/Hovercards/SubredditHovercard/_SubredditHovercard.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/HumanDate/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/timeAgo/index.ts"),
				a = n("./src/reddit/hooks/useLocale.ts");
			var i = function(e) {
					let {
						seconds: t,
						...n
					} = e;
					var s;
					const i = Object(a.a)(),
						d = {
							...n,
							locale: null !== (s = n.locale) && void 0 !== s ? s : i
						};
					return r.a.createElement(r.a.Fragment, null, Object(o.d)(t, d))
				},
				d = n("./src/lib/humanizeDate/index.ts");
			var c = function(e) {
					let {
						seconds: t,
						...n
					} = e;
					var s;
					const o = Object(a.a)(),
						i = {
							...n,
							locale: null !== (s = n.locale) && void 0 !== s ? s : o
						};
					return r.a.createElement(r.a.Fragment, null, Object(d.a)(t, i))
				},
				l = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				u = n("./src/lib/constants/index.ts");
			var m = function(e) {
					let {
						seconds: t,
						locale: n
					} = e;
					const s = Object(a.a)(),
						o = null != n ? n : s;
					return r.a.createElement(r.a.Fragment, null, function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l.DEFAULT_LOCALE;
						const n = e * u.Sb;
						return new Date(n).toLocaleString(t, {
							weekday: "short",
							month: "short",
							year: "numeric",
							day: "2-digit",
							hour: "2-digit",
							minute: "2-digit",
							second: "2-digit",
							timeZoneName: "long"
						})
					}(t, o))
				},
				p = n("./node_modules/fbt/lib/FbtPublic.js"),
				b = n("./src/lib/eventTools/index.ts");

			function h(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l.DEFAULT_LOCALE;
				return e.toLocaleDateString(t, {
					month: "numeric",
					day: "numeric"
				})
			}

			function f(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
					s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : l.DEFAULT_LOCALE;
				const r = Object(b.e)(e, t),
					o = new Date(e * u.Sb);
				let a;
				if (r === b.a.Live || n) return p.fbt._("Now", null, {
					hk: "Prpcg"
				});
				return r === b.a.Future ? a = Object(b.d)(e) ? p.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : Object(b.b)(e) >= 5 ? h(o, s) : function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l.DEFAULT_LOCALE;
					return e.toLocaleDateString(t, {
						weekday: "long"
					})
				}(o, s) : r === b.a.Past && (a = Object(b.d)(e) ? p.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : h(o, s)), `${a} @ ${function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.DEFAULT_LOCALE;return e.toLocaleTimeString(t,{hour12:!0,hour:"numeric",minute:"2-digit"}).replace(/ /g,"").toUpperCase()}(o,s)}`
			}
			var g = function(e) {
				let {
					startTime: t,
					endTime: n,
					isLive: s,
					locale: o
				} = e;
				const i = Object(a.a)(),
					d = null != o ? o : i;
				return r.a.createElement(r.a.Fragment, null, f(t, n, s, d))
			};
			n("./src/lib/humanizeUTCDate/index.tsx")
		},
		"./src/reddit/components/ImageWithFallback/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/react/index.js");
			const s = e => new Promise((t, n) => {
				const s = new Image;
				s.onload = () => t(s), s.onerror = n, s.src = e
			})
		},
		"./src/reddit/components/InboxBanner/Banner.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				i = n("./src/reddit/helpers/trackers/inbox.ts"),
				d = n("./src/reddit/hooks/useTracking.ts"),
				c = n("./src/reddit/icons/fonts/index.tsx"),
				l = n("./src/reddit/components/InboxBanner/index.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					className: t,
					closeButtonText: n,
					closeIcon: s,
					descriptionText: l,
					primaryButtonText: m,
					titleText: p,
					onClose: b,
					onClick: h
				} = e;
				const f = Object(d.a)();
				return r.a.createElement("div", {
					className: Object(o.a)(u.a.banner, t)
				}, r.a.createElement("div", {
					className: u.a.bannerTitleContainer
				}, p && r.a.createElement("h4", {
					className: u.a.bannerTitle
				}, p), s && r.a.createElement(a.t, {
					onClick: e => {
						b && b(e), f(Object(i.p)({
							dnPromptAction: "dismiss"
						}))
					},
					Icon: Object(c.b)("close_fill"),
					className: Object(o.a)(u.a.closeIcon, u.a.closeButton),
					size: a.d.XXS,
					priority: a.c.Plain
				})), l && r.a.createElement("p", {
					className: u.a.bannerDescription
				}, l), r.a.createElement("div", {
					className: u.a.bannerButtonsContainer
				}, m && r.a.createElement(a.t, {
					text: m,
					priority: a.c.Tertiary,
					className: Object(o.a)(u.a.button, u.a.primaryButton),
					size: a.d.XS,
					onClick: e => {
						h && h(e), f(Object(i.p)({
							dnPromptAction: "cta"
						}))
					}
				}), n && r.a.createElement(a.t, {
					text: n,
					onClick: e => {
						b && b(e), f(Object(i.p)({
							dnPromptAction: "refuse"
						}))
					},
					priority: a.c.Plain,
					size: a.d.XS,
					className: Object(o.a)(u.a.button, u.a.closeButton)
				})))
			}
		},
		"./src/reddit/components/InboxBanner/PolicyBanner.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/reddit/components/InboxBanner/Banner.tsx"),
				i = n("./src/reddit/helpers/trackers/inbox.ts"),
				d = n("./src/reddit/hooks/useTracking.ts"),
				c = n("./src/reddit/components/InboxBanner/index.m.less"),
				l = n.n(c);
			const u = e => {
				let {
					onClose: t,
					pageType: n
				} = e;
				const r = Object(d.a)(),
					c = s.fbt._("Weve updated our {userAgreement} and {privacyPolicy}. Take a look, as the changes take effect September 12, 2021.", [s.fbt._param("userAgreement", o.a.createElement("a", {
						className: l.a.underlineLink,
						href: "https://www.redditinc.com/policies/user-agreement",
						target: "_blank",
						rel: "noopener noreferrer"
					}, "User Agreement")), s.fbt._param("privacyPolicy", o.a.createElement("a", {
						className: l.a.underlineLink,
						href: "https://www.redditinc.com/policies/privacy-policy",
						target: "_blank",
						rel: "noopener noreferrer"
					}, "Privacy Policy"))], {
						hk: "3bGC4g"
					});
				return o.a.createElement(a.a, {
					className: l.a.policyBanner,
					titleText: s.fbt._("Reddits User Agreement & Privacy Policy", null, {
						hk: "32fxCY"
					}),
					descriptionText: c,
					primaryButtonText: s.fbt._("Ok", null, {
						hk: "1IJxzv"
					}),
					onClick: e => {
						e.stopPropagation(), t(), r(Object(i.g)(n, i.a.Confirm))
					}
				})
			}
		},
		"./src/reddit/components/InboxBanner/index.m.less": function(e, t, n) {
			e.exports = {
				underlineLink: "_3vOO3WyD7yteL4Rr9E1i2y",
				banner: "_34mO86zNIysmcISYIe8gVT",
				bannerTitleContainer: "rh7yf_ejK6H75L6jZkb6C",
				bannerTitle: "V_VLkmdSrXqz92-5vad5F",
				bannerDescription: "_1vbdR0mal1nPuuTOZIemLg",
				closeButton: "-Fi_Lr4OQ6XfCIiufmgxa",
				bannerButtonsContainer: "_1a9VL63O5el1YN7RuPoDLy",
				button: "_1mejKTw8yWGmudymV6GufX",
				primaryButton: "_1mR2YFl21PdJDX9T7ykA7c",
				welcomeBanner: "_3QWgBcfZuqQ6TlxZa6uYkS",
				dnPromptBanner: "_3IIpKn1IlCXgko4sLMEie1",
				policyBanner: "GLgkxGZkPymWBWeRISXBe",
				modalHeader: "_2Ggqgl_RyXu2U-mPYZSaCk",
				modalTitle: "_2C3YUpN8pGzseZOBK0tl0I",
				modalCloseIcon: "_2BTQI8_1TIwwfdecOP_j6o",
				modalListItem: "-sXLpWAGj2HMFvzRvH_bC",
				modalListIcon: "_3UO2hA0CsOqKl1bYybPZGs",
				hotPotatoBanner: "_2oy7Xi4NUleUcHtb8YDZh7",
				bannerContainer: "V5Q75l1gWtGpBZEehJiGH",
				bannerDataContainer: "SIz6ozr7aqewYGVSLfSf6",
				bannerImage: "_2zetWw7f4W-0OWrUYJHPQ-"
			}
		},
		"./src/reddit/components/InboxTooltip/Component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return te
			})), n.d(t, "b", (function() {
				return oe
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/notifications/index.ts"),
				i = n("./src/lib/notifications/constants.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/BadgeCounter/index.tsx"),
				u = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				m = n("./node_modules/lodash/omit.js"),
				p = n.n(m),
				b = n("./src/reddit/components/InboxBanner/Banner.tsx"),
				h = n("./src/reddit/components/InboxBanner/index.m.less"),
				f = n.n(h);
			const g = e => {
				let {
					onClose: t,
					onTurnOnBrowserNotifications: n
				} = e;
				return o.a.createElement(b.a, {
					className: f.a.dnPromptBanner,
					titleText: s.fbt._("Dont miss out on updates  Turn on desktop notifications.", null, {
						hk: "10oNqB"
					}),
					onClose: e => {
						e.stopPropagation(), t()
					},
					closeIcon: !0,
					primaryButtonText: s.fbt._("Turn On", null, {
						hk: "3hywR9"
					}),
					closeButtonText: s.fbt._("No Thanks", null, {
						hk: "2GQOmV"
					}),
					onClick: e => {
						n(), t()
					}
				})
			};
			var _ = n("./node_modules/react-redux/es/index.js"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				O = n("./src/reddit/controls/InternalLink/index.tsx"),
				x = n("./src/reddit/helpers/trackers/hotPotato.ts"),
				E = n("./src/reddit/hooks/useTracking.ts"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/icons/svgs/HotPotato/index.tsx"),
				C = n("./src/reddit/selectors/experiments/hotPotato.ts");
			const k = e => {
				let {
					onClose: t
				} = e;
				const n = Object(_.e)(C.b),
					a = Object(E.a)(),
					i = Object(r.useCallback)(e => {
						t && t(e), a(Object(x.a)())
					}, [t, a]);
				return o.a.createElement("div", {
					className: Object(d.a)(f.a.banner, f.a.hotPotatoBanner)
				}, o.a.createElement(O.default, {
					to: `/r/${n}`,
					className: f.a.bannerContainer,
					onClick: i
				}, o.a.createElement("div", {
					className: f.a.bannerDataContainer
				}, o.a.createElement("div", {
					className: f.a.bannerTitleContainer
				}, o.a.createElement("h4", {
					className: f.a.bannerTitle
				}, s.fbt._("There's a time and r/place for everything", null, {
					hk: "10MnL"
				}))), o.a.createElement("p", {
					className: f.a.bannerDescription
				}, s.fbt._("r/Place is now open. Together we can make something more. Claim your tile and make r/place yours.", null, {
					hk: "2f11Wg"
				}))), o.a.createElement(j.a, {
					className: f.a.bannerImage
				})), o.a.createElement(v.t, {
					onClick: t,
					Icon: Object(y.b)("close_fill"),
					className: f.a.closeButton,
					size: v.d.XXS,
					priority: v.c.Plain
				}))
			};
			var I = n("./src/reddit/components/InboxBanner/PolicyBanner.tsx"),
				S = n("./src/reddit/components/NotificationUnit/Loader.tsx"),
				w = n("./src/reddit/components/ResizeSensor/index.tsx"),
				T = n("./src/reddit/components/InboxTooltip/index.m.less"),
				N = n.n(T);
			const P = 3;
			class R extends o.a.Component {
				constructor() {
					super(...arguments), this.ref = o.a.createRef(), this.handleResize = () => {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						e !== this.props.notificationHeight && this.props.setNotificationHeight(e, this.props.index)
					}
				}
				componentDidMount() {
					if (this.props.index + 1 <= P) {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						this.props.setNotificationHeight(e, this.props.index)
					}
				}
				render() {
					const {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						blockAwarder: a,
						index: i,
						isInboxPostEmbedEnabled: d,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m
					} = this.props, p = i + 1 <= P;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						ref: this.ref,
						className: N.a.notificationResizeWrapper
					}, o.a.createElement(S.a, {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						isInboxPostEmbedEnabled: d,
						isInTooltip: !0,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m,
						blockAwarder: a
					}), !!p && o.a.createElement(w.a, {
						onResize: this.handleResize
					})))
				}
			}
			var A = n("./src/reddit/components/NotificationUnit/Placeholder.tsx"),
				M = n("./src/reddit/helpers/trackers/inbox.ts"),
				D = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx");

			function L() {
				return (L = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const F = {},
				U = "",
				B = 0,
				G = "200px",
				H = "250px",
				W = "270px",
				q = 100,
				V = .5,
				z = 5,
				K = 50,
				Q = 55;
			class J extends o.a.Component {
				constructor() {
					super(...arguments), this.container = o.a.createRef(), this.state = {
						notificationHeights: F,
						currentNotificationCursorIndex: -1
					}, this.resetOverflowMenu = () => {
						this.props.activeOverflowMenuId.length > B && this.props.setActiveOverflowMenuId(U)
					}, this.getContainerHeight = () => {
						const {
							notificationHeights: e
						} = this.state, {
							isDNInboxPromptBannerEnabled: t,
							isInboxPrivacyPolicyBannerEnabled: n,
							isLoggedIn: s
						} = this.props, r = t || n, o = window.innerHeight - K - 2 * Q - (r ? q : 0);
						let a = 0;
						for (const i in e) a += e[i];
						return 0 === a ? r ? H : s ? G : W : (r && (a += q), o < a && (a = o + (r ? q : 0)), a)
					}, this.setNotificationHeight = (e, t) => {
						this.setState(n => ({
							notificationHeights: {
								...n.notificationHeights,
								[t]: e
							}
						}))
					}, this.updateCurrentCursorIndex = () => {
						const {
							notifications: e
						} = this.props, {
							currentNotificationCursorIndex: t
						} = this.state, n = t + z, s = n > e.length ? n : e.length - 1;
						this.setState({
							currentNotificationCursorIndex: s
						})
					}, this.renderNotifications = () => {
						const e = p()(this.props, ["notifications"]),
							{
								notificationHeights: t,
								currentNotificationCursorIndex: n
							} = this.state,
							{
								isInboxInfiniteScrollEnabled: s,
								notifications: r
							} = this.props,
							a = r.length > n + z;
						return (s && r.length > 0 && a ? r.slice(0, n + 1) : r).map((n, s) => o.a.createElement(R, L({}, e, {
							index: s,
							key: s,
							notification: n,
							notificationHeight: t[s],
							setNotificationHeight: this.setNotificationHeight
						})))
					}, this.loadNotifications = e => {
						const {
							cursor: t,
							fetchNotifications: n,
							isInboxInfiniteScrollEnabled: s,
							notifications: r
						} = this.props;
						if (e.isIntersecting) {
							const e = r.length > this.state.currentNotificationCursorIndex + z;
							this.props.notifications.length > 0 && s && e ? this.updateCurrentCursorIndex() : t && n({
								after: t,
								first: z
							})
						}
					}
				}
				componentDidMount() {
					const e = this.container && this.container.current;
					e && e.addEventListener("scroll", this.resetOverflowMenu)
				}
				componentWillUnmount() {
					const e = this.container && this.container.current;
					e && e.removeEventListener("scroll", this.resetOverflowMenu), this.resetOverflowMenu()
				}
				render() {
					const {
						hasNextPage: e,
						isDNInboxPromptBannerEnabled: t,
						isHotPotatoEnabled: n,
						isInboxPrivacyPolicyBannerEnabled: s,
						isInboxInfiniteScrollEnabled: r,
						isLoggedIn: a,
						isPending: i,
						notifications: d,
						setDesktopNotificationsPromptSeen: c,
						setInboxPrivacyPolicyBannerSeen: l,
						showBrowserNotificationsPermissionSettings: m,
						setHotPotatoBannerSeen: p
					} = this.props, b = !(!d || !d.length), h = this.getContainerHeight(), f = d.length > this.state.currentNotificationCursorIndex + z, _ = s || t || n;
					return o.a.createElement("div", {
						className: N.a.notificationList,
						ref: this.container,
						style: b ? {
							height: h,
							maxHeight: h
						} : {
							minHeight: G
						}
					}, _ && o.a.createElement("div", {
						className: N.a.notificationBannerContainer
					}, s && o.a.createElement(I.a, {
						onClose: l,
						pageType: M.c.MiniInbox
					}), t && o.a.createElement(g, {
						onTurnOnBrowserNotifications: m,
						onClose: c
					}), n && o.a.createElement(k, {
						onClose: p
					})), !b && i && o.a.createElement(A.a, null), !b && !i && o.a.createElement(D.a, {
						isBannerEnabled: _,
						isLoggedIn: a,
						inTooltip: !0,
						hideTooltip: this.props.onItemClick
					}), b && this.renderNotifications(), r && b && !i && (e || f) && o.a.createElement(u.a, {
						onChange: this.loadNotifications,
						rootMargin: "0px 0px 0px 0px",
						threshold: V
					}, o.a.createElement("div", null)))
				}
			}
			var Y = n("./src/reddit/constants/localStorage.ts"),
				X = n("./src/reddit/hooks/useLocalStorage.ts");
			var Z = n("./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts"),
				$ = n("./src/reddit/hooks/useInboxPrivacyPolicyBannerSeen.ts");

			function ee() {
				return (ee = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const te = [],
				ne = c.a.div("StyledDropdown", N.a),
				se = e => {
					let {
						isLoggedIn: t,
						onMessagesClick: n,
						onBarClick: a,
						markAllAsRead: i,
						messagesBadgeCount: c,
						sendInboxClickSettings: u
					} = e;
					const m = !!c,
						p = Object(r.useCallback)(() => {
							n(), a()
						}, [n, a]),
						b = Object(r.useCallback)(() => {
							u(), a()
						}, [u, a]);
					return o.a.createElement("nav", {
						className: N.a.topNav
					}, o.a.createElement("span", {
						className: N.a.topNavTitle
					}, s.fbt._("Notifications", null, {
						hk: "1sYFjx"
					})), t && o.a.createElement("span", {
						className: N.a.topNavLinks
					}, o.a.createElement("span", {
						className: N.a.messagesLinkContainer
					}, o.a.createElement(O.default, {
						className: Object(d.a)(N.a.messagesLink, {
							[N.a.mActive]: m
						}),
						onClick: p,
						to: m ? "/message/unread" : "/message/messages"
					}, s.fbt._("Messages", null, {
						hk: "hulKY"
					}), o.a.createElement(l.a, {
						className: N.a.badgeCount,
						isActive: m,
						unreadCount: c
					}))), o.a.createElement("button", {
						className: N.a.navLink,
						onClick: i
					}, o.a.createElement(y.a, {
						name: "mark_read",
						className: N.a.icon
					})), o.a.createElement(O.default, {
						className: N.a.navLink,
						onClick: b,
						to: "/settings/notifications"
					}, o.a.createElement(y.a, {
						name: "settings",
						className: N.a.icon
					}))))
				},
				re = e => o.a.createElement("div", {
					className: N.a.bottomBar
				}, o.a.createElement(O.default, {
					className: N.a.bottomLink,
					onClick: () => {
						e.sendInboxClickSeeAll(), e.onBarClick()
					},
					to: "/notifications"
				}, s.fbt._("See All", null, {
					hk: "3L3tFc"
				}))),
				oe = e => {
					const t = Object(E.a)(),
						{
							clearMessageTabBadgeCount: n,
							inboxBadgeCount: s,
							isPending: r,
							messagesBadgeCount: d,
							notifications: c,
							hideTooltip: l,
							isHotPotatoEnabled: u,
							isInboxPolicyBannerEnabled: m,
							isLoggedIn: p,
							isPushNotificationsSupported: b,
							userId: h
						} = e,
						[f, g] = Object(Z.a)(h),
						[_, v] = Object($.a)(h),
						[O, x] = function(e) {
							let {
								key: t,
								userId: n
							} = e;
							const [s, r] = Object(X.a)(t, []);
							return [-1 !== s.indexOf(n), () => {
								r([...s, n])
							}]
						}({
							key: Y.b.HOT_POTATO_BANNER_SEEN,
							userId: h
						}),
						y = !(!c || !c.length),
						j = Object(a.a)(),
						C = j === i.a.Closed || j === i.a.Default || j === i.a.Denied,
						k = b && C && !f;
					return o.a.createElement(ne, null, o.a.createElement("div", {
						className: N.a.tooltipContainer
					}, o.a.createElement(se, {
						markAllAsRead: () => {
							e.markAllAsRead(), t(Object(M.i)({
								isMiniInbox: !0
							}))
						},
						messagesBadgeCount: d,
						onMessagesClick: () => {
							t(Object(M.u)({
								badgeCount: s,
								tab: M.f.Messages
							})), t(Object(M.j)()), n()
						},
						sendInboxClickSettings: () => t(Object(M.o)(M.c.MiniInbox)),
						onBarClick: l,
						isLoggedIn: p
					}), o.a.createElement(J, ee({}, e, {
						isPending: r,
						onItemClick: l,
						setDesktopNotificationsPromptSeen: g,
						isDNInboxPromptBannerEnabled: k,
						isInboxPrivacyPolicyBannerEnabled: m && !_,
						setInboxPrivacyPolicyBannerSeen: v,
						isHotPotatoEnabled: u && !O,
						setHotPotatoBannerSeen: x
					})), (y || r) && o.a.createElement(re, {
						sendInboxClickSeeAll: () => t(Object(M.n)()),
						onBarClick: l
					})))
				}
		},
		"./src/reddit/components/InboxTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				carot: "_389RY3FytRs4F82-BLVEiq",
				StyledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				styledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				tooltipContainer: "_3oNU8Gzy2V3jDPhFfeEFbD",
				topNav: "F0hrtz76LlopbY9X0wtDo",
				topNavTitle: "wdFbe8PT7DInxaiHo2Me1",
				messagesLinkContainer: "_1581SeO-Xb1j1kfhIRrIyB",
				topNavLinks: "_1R0ZV71kh7uwDXo7fn1eDk",
				messagesLink: "_27rjoZBkLhiqLLjBu-xU_p",
				"m-active": "_29xCmtH_l8UtRn8IP08VLB",
				mActive: "_29xCmtH_l8UtRn8IP08VLB",
				badgeCount: "_1mrhJHegVozrNeTH7r5svN",
				navLink: "_2l1d6HSQ764u0JcvRSEJXD",
				notificationList: "_2MId4QR3fPm4RPlrSTZg_E",
				notificationResizeWrapper: "_3PWmWL3sMw23-xBHydcnPf",
				emptyState: "_17HPdVVhdV3LWBjzHwGlhA",
				emptyTitle: "_2CY3n2AMoj0af7gQhj9dfI",
				emptyDescription: "HxBuWRTAFa8y8bMiQKdSJ",
				bottomBar: "_8INvnNiEMHRndJ0M-LiY",
				bottomLink: "X1WC7m4hrFQNzINreBRsv",
				icon: "_3pDOQfbIbQuT4PBwPGp85E",
				BellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				bellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				notificationBannerContainer: "_2prSjBmU3TS_Liup8DFR-2",
				welcomeTooltipContainer: "_1OZgaZvEs6sdhMUCqaUCW_",
				closeButton: "_3fWRL_DhsIqXjpW4eXDwmR",
				CloseIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				closeIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				tooltipTitle: "_3EmopbfaUR0bemuuUcEcko",
				tooltipDescription: "_3MtkPXIDbG9Hf6YeNOxAxv"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, n) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				i = n.n(a),
				d = n("./src/lib/lessComponent.tsx");
			const c = d.a.div("IconWrapper", i.a),
				l = d.a.div("TextWrapper", i.a);

			function u(e) {
				const {
					className: t,
					color: n,
					icon: s,
					subtitle: a,
					title: d,
					textWrapperClassName: u
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(t, i.a.wrapper),
					style: n && {
						borderColor: n
					} || {}
				}, r.a.createElement("div", {
					className: i.a.leftSideRectangle,
					style: n && {
						backgroundColor: n
					} || {}
				}), s ? r.a.createElement(c, null, s) : r.a.createElement(c, null), r.a.createElement(l, {
					className: u
				}, r.a.createElement("div", {
					className: i.a.title
				}, d), a && r.a.createElement("div", {
					className: i.a.subtitle
				}, a)))
			}
		},
		"./src/reddit/components/InfoTextTooltip/Hooked.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/InfoTextTooltip/hooked.m.less"),
				i = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = r.a.memo((function(e) {
				let {
					visible: t,
					...n
				} = e;
				const [a, c] = Object(s.useState)(t);
				return Object(s.useEffect)(() => {
					let e = window.setTimeout(() => {
						e = void 0, c(t)
					}, 0);
					return () => {
						e && window.clearTimeout(e), c(!1)
					}
				}, [t]), t ? r.a.createElement("div", d({
					className: Object(o.a)(i.a.tooltip, n.className, {
						[i.a.visible]: a
					})
				}, n.popperProps), n.children, a && r.a.createElement("div", d({
					className: i.a.arrow
				}, n.arrowProps))) : null
			}))
		},
		"./src/reddit/components/InfoTextTooltip/hooked.m.less": function(e, t, n) {
			e.exports = {
				arrow: "_1jsc29CjRXZWjd2tr0Ji0Y",
				tooltip: "_2J_zB4R1FH2EjGMkQjedwc",
				visible: "u6HtAZu8_LKL721-EnKuR"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				d = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				c = n("./src/reddit/selectors/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const b = m.a.div("Text", u.a),
				h = m.a.div("BottomText", u.a),
				f = e => r.a.createElement(b, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				g = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return r.a.createElement(h, {
						className: e.className,
						style: {
							...e.style,
							"--infoTextTooltip-overflow-left": `${t}px`
						}
					}, e.text, e.children)
				},
				_ = Object(a.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(c.b)(n)(e)
					}
				}),
				v = Object(d.a)(g, [i.a.Click, i.a.Keydown]),
				O = Object(d.a)(f, [i.a.Click, i.a.Keydown]),
				x = Object(o.b)(_);
			t.c = x(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? r.a.createElement(v, p({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : r.a.createElement(O, p({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/InlineSubredditEditing/index.m.less": function(e, t, n) {
			e.exports = {
				tooltipContent: "RrvkJ7ntzKYyaCOxMJ1RM",
				title: "BE2vGjFTJ80XkdBpRRr0p",
				tooltipBody: "_2yezzi8dgIemh3F2q_kvcp",
				topRow: "_1JfvdiRxYTSKf1IIe7DUvM",
				gotIt: "_1MHKCZd72tAgyoZWvIYM-G"
			}
		},
		"./src/reddit/components/LinkOrOverlayLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				a = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				i = n("./src/reddit/helpers/overlay/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e) {
				const {
					children: t,
					className: n,
					to: s,
					...o
				} = e, c = Object(i.b)(s);
				return r.a.createElement(a.a, d({
					className: n,
					to: c
				}, o), t)
			}

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				const {
					isOverlay: t,
					...n
				} = e, s = t ? c : o.a;
				return r.a.createElement(s, l({}, n, {
					children: n.children,
					className: n.className,
					onClick: n.onClick,
					to: n.to
				}))
			}
		},
		"./src/reddit/components/LottieAnimation/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lottie-web/build/player/lottie.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/components/LottieAnimation/util.ts");
			const d = a.a.memo(e => {
				const t = a.a.createRef(),
					{
						assetData: n,
						assetUrl: s,
						className: d,
						hidden: c,
						loop: l,
						useCanvasRenderer: u,
						onClick: m,
						prefersReducedAnimation: p
					} = e,
					[b, h] = Object(o.useState)(n);
				Object(o.useEffect)(() => {
					s ? Object(i.a)(s).then(h) : n && h(n)
				}, [s, n]);
				const [f, g] = Object(o.useState)(null);
				Object(o.useEffect)(() => {
					const e = t.current;
					if (!e || 0 !== e.childElementCount || f || !b) return;
					const n = r.a.loadAnimation({
						autoplay: !1,
						renderer: u ? "canvas" : "svg",
						loop: l,
						container: e,
						animationData: b
					});
					g(n)
				}, [l, t, f, b]), Object(o.useEffect)(() => {
					if (f)
						if (c) f.stop();
						else if (p) {
						const e = f.getDuration(!0);
						f.goToAndPlay(e, !0)
					} else f.goToAndPlay(0)
				}, [c, p, f]);
				const _ = Object(o.useCallback)(() => {
					f && f.goToAndPlay(0)
				}, [f]);
				return a.a.createElement("div", {
					className: d,
					style: {
						display: c ? "none" : "block"
					},
					ref: t,
					onClick: m || _
				})
			});
			t.a = d
		},
		"./src/reddit/components/LottieAnimation/util.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./src/reddit/components/ImageWithFallback/index.tsx");
			const s = {};

			function r(e) {
				let t = s[e];
				return t || (t = s[e] = fetch(e, {
					mode: "cors",
					cache: "force-cache"
				}).then(t => (t.ok || function(e) {
					throw new Error(`Unable to download effect asset "${e}"`)
				}(e), t.json()))), t
			}
		},
		"./src/reddit/components/ModActionsMenu/index.m.less": function(e, t, n) {
			e.exports = {
				ModActionsMenu: "_28noJDp6DzFWESejYQdpcD",
				modActionsMenu: "_28noJDp6DzFWESejYQdpcD"
			}
		},
		"./src/reddit/components/ModActionsMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/actions/tooltip.ts"),
				d = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				c = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				l = n("./src/reddit/selectors/tooltip.ts"),
				u = n("./src/reddit/components/ModActionsMenu/index.m.less"),
				m = n.n(u);
			const p = Object(a.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(l.b)(n)(e)
					}
				}),
				b = Object(o.b)(p, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(i.h)({
							tooltipId: n
						}))
					}
				}),
				h = () => null;
			t.a = b(e => r.a.createElement("div", {
				className: m.a.ModActionsMenu,
				id: e.dropdownId,
				onClick: e.dropdownIsOpen ? h : e.onClick
			}, e.inCommentFlatlist ? r.a.createElement(d.a, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children) : r.a.createElement(c.c, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children)))
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "yumI0nyT2gr7SFtITyKpa",
				primaryButton: "yumI0nyT2gr7SFtITyKpa"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				pencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				noPermissions: "_2L3p28vjPxj-Ab-h1gRXii",
				helperTitle: "_3qVhi7y_9yxVxxDGEHORe9"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				h = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				f = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/Scroller/Simple.tsx"),
				_ = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/models/SubredditModeration/index.ts"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/lib/objectSelector/index.ts"),
				j = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const C = Object(y.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				return e.pages.modHub.approvedTalkHosts.models[n] || j.a
			});
			var k = n("./src/reddit/selectors/user.ts"),
				I = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				S = n("./src/higherOrderComponents/asModal/index.tsx"),
				w = n("./src/lib/lessComponent.tsx"),
				T = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				N = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				P = n("./src/reddit/controls/TextButton/index.tsx"),
				R = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				A = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				M = n("./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less"),
				D = n.n(M);
			const L = w.a.wrapped(v.l, "PrimaryButton", D.a);
			var F = Object(S.a)(e => {
					let {
						subredditId: t,
						onAddTalkHost: n,
						toggleModal: s,
						sendEventWithName: i
					} = e;
					const [d, c] = Object(o.useState)("");
					return a.a.createElement(T.e, null, a.a.createElement(T.i, null, a.a.createElement(A.a, null, a.a.createElement(T.q, null, r.fbt._("Add approved Talk host", null, {
						hk: "38DcZT"
					})), a.a.createElement(P.a, {
						onClick: s
					}, a.a.createElement(T.b, null)))), a.a.createElement(T.l, null, a.a.createElement(N.d, {
						placeholder: r.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: e => {
							c(e.currentTarget.value)
						},
						value: d,
						autoFocus: !0
					})), a.a.createElement(T.g, null, a.a.createElement(T.a, {
						onClick: s,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(L, {
						onClick: () => {
							n(t, d), i("add")(), s()
						},
						"data-redditstyle": !0,
						disabled: !Object(R.a)(d)
					}, r.fbt._("Approve user", null, {
						hk: "4Awx1T"
					}))))
				}),
				U = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less"),
				B = n.n(U);
			const G = 24,
				H = Object(d.c)({
					approvedTalkHosts: C,
					approvedTalkHostsListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(x.f)(n);
						return !!e.pages.modHub.approvedTalkHosts.api.pending[s]
					},
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedTalkHosts.loadMore[n]
					},
					currentUser: k.k,
					isAddApprovedTalkHostModalOpen: e => "ModerationPage--Modal--AddApprovedTalkHost" === Object(E.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveHostConfirmation" === Object(E.a)(e)
				}),
				W = Object(i.b)(H, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addApprovedTalkHost: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)({
							subredditId: n,
							before: t
						})),
						toggleAddApprovedHostModal: () => e(Object(u.i)("ModerationPage--Modal--AddApprovedTalkHost")),
						toggleRemoveHostModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveHostConfirmation")),
						removeApprovedTalkHost: (t, n) => e(Object(m.c)(t, n))
					}
				});
			class q extends a.a.Component {
				constructor(e) {
					super(e), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveTalkHost = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddApprovedHostModal()
					}, this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveHostModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeApprovedTalkHost(this.props.subredditId, this.state.userId)
					}, this.renderAddApprovedHostModal = () => a.a.createElement(F, {
						ignoreDefaultFocus: !0,
						onAddTalkHost: this.props.addApprovedTalkHost,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddApprovedHostModal,
						sendEventWithName: this.props.sendEventWithName,
						withOverlay: !0
					}), this.renderUser = e => {
						var t, n, o;
						return a.a.createElement(_.b, {
							timeAgo: a.a.createElement(b.d, {
								seconds: Date.parse(e.addedAt) / 1e3
							}),
							pageName: l.gc.TalkHosts,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.redditor.id ? a.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.redditor.displayName}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, a.a.createElement(v.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? a.a.createElement(v.r, {
								onClick: () => this.handleRemoveToggled(e.redditor.id, e.redditor.displayName)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: null === (o = e.redditor.icon) || void 0 === o ? void 0 : o.url,
							username: e.redditor.displayName
						})
					}, this.state = x.a
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedTalkHosts.length > 0 ? t.approvedTalkHosts[t.approvedTalkHosts.length - 1].redditor.id : void 0, i = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(f.c, null, a.a.createElement(v.l, {
						disabled: !i,
						onClick: this.approveTalkHost
					}, r.fbt._("Add Talk Host", null, {
						hk: "w94Fa"
					}))), a.a.createElement(f.a, {
						className: Object(c.a)(!i && B.a.noPermissions)
					}, a.a.createElement(f.b, null, r.fbt._("Talk hosts", null, {
						hk: "3ypfgA"
					}), a.a.createElement(I.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/4411156549389`
					})), a.a.createElement("p", {
						className: B.a.helperTitle
					}, r.fbt._("Talk hosts are members who are approved to create Reddit Talk posts.", null, {
						hk: "2mnjQi"
					})), t.approvedTalkHostsListPending && a.a.createElement(_.a, null), t.approvedTalkHosts.length > 0 ? a.a.createElement(g.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedTalkHosts.map(e => ({
						estHeight: G,
						id: e.redditor.id,
						render: () => this.renderUser(e)
					}))) : a.a.createElement(h.c, {
						text: r.fbt._("No approved Talk hosts in {subredditName}", [r.fbt._param("subredditName", t.subredditName)], {
							hk: "3lDejn"
						})
					}, a.a.createElement(O.a, {
						name: "edit",
						className: B.a.PencilIcon
					}))), t.isAddApprovedTalkHostModalOpen && this.renderAddApprovedHostModal(), t.isConfirmModalOpen && n.userId && n.username && a.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved Talk host?", [r.fbt._param("username", n.username)], {
							hk: "1p0fqz"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveHostModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					}))
				}
			}
			t.a = W(q)
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_12gWQ2C_gotA8s5-CJIlq9",
				icon: "_3-Fcrds7R5ihAWPAttv3AL",
				title: "_1vL1j4mpTYI5NOR335bInG",
				subtitle: "_3FOOtAw2Q-T7szrSBAbo9i"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less": function(e, t, n) {
			e.exports = {
				tabBar: "_1ItRVjBpP4aLG0vg-nXbwO",
				tab: "_3A18ggmDWAI5_Fz0nDOs-z",
				selected: "_3U85C8qDDoOUoOINg-E_3S"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_2O3bUryrh35-WVnz9Zoet5",
				content: "_1FTRfhuddBV5YzYiIzObiO",
				grid: "_3i8uEN2ZVREoZOqW0PBJKD",
				header: "_3TFv4L83k0sAQxxxDJCzh9",
				actionHeader: "_3XGx1tfvY30VXMwrnAYMfZ",
				cell: "_30GfT3S_RWhS9B1JiSCaIJ",
				imageCell: "_1mzA539xYQn08RGzbn-Rgl",
				image: "_2UKv8w6-nnOZn6-lOqv57x",
				imagePlaceholder: "_2-8LfoYIQ37smNisBTPrPA",
				title: "_2cEKePFj4PUyuqlM_8uInw",
				caption: "_33iTirQvYAUBeq5vAp6Nr6",
				timeCell: "_1EzbYLhrmLPhhpk2FFAmcj",
				actionCell: "_1JvlfJR1EFT7pnSONpgiXk",
				dropdownSelector: "_2K7txHCmQX-J_7K7zNiCM1",
				byModerator: "_3czV_FVsdvYbnimTT57vCK",
				line: "_22JqeR_rL-tI8mxRb7N8Mq",
				loadingTextLong: "_2AZFpVa_LwltM1gTwCGIDe",
				loadingTextShort: "_1LWRk2sNojXWsOI1Y85nf7"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return H
			})), n.d(t, "b", (function() {
				return W
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/actions/governance/errorToast.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				l = n("./src/reddit/contexts/ApiContext.tsx"),
				u = n("./src/reddit/endpoints/economics/uploadedAssets.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/icons/svgs/SnooHappy/index.tsx"),
				h = n("./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less"),
				f = n.n(h);
			const g = {
				[u.a.Uploaded]: {
					title: () => s.fbt._("No more to review!", null, {
						hk: "2rF58X"
					}),
					subtitle: () => s.fbt._("There are no new submissions", null, {
						hk: "3h54Ot"
					})
				},
				[u.a.Approved]: {
					title: () => s.fbt._("Nothing approved yet", null, {
						hk: "157fUO"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you approve them", null, {
						hk: "pLc2c"
					})
				},
				[u.a.Rejected]: {
					title: () => s.fbt._("Nothing rejected yet", null, {
						hk: "1XN9kw"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you reject them", null, {
						hk: "2IYFHB"
					})
				}
			};

			function _(e) {
				const t = g[e.selectedStatus];
				return o.a.createElement("div", {
					className: f.a.container
				}, o.a.createElement(b.a, {
					className: f.a.icon
				}), o.a.createElement("h3", {
					className: f.a.title
				}, t.title()), o.a.createElement("p", {
					className: f.a.subtitle
				}, t.subtitle()))
			}
			var v = n("./src/reddit/components/AuthorLink/index.tsx"),
				O = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				x = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less"),
				E = n.n(x);
			const y = p.a.div("cell", E.a),
				j = () => [{
					displayText: s.fbt._("New", null, {
						hk: "2xTBYx"
					}),
					value: u.a.Uploaded
				}, {
					displayText: s.fbt._("Approved", null, {
						hk: "1xx5DL"
					}),
					value: u.a.Approved
				}, {
					displayText: s.fbt._("Rejected", null, {
						hk: "25TTJE"
					}),
					value: u.a.Rejected
				}],
				C = () => j().slice(1, 3),
				k = new Intl.DateTimeFormat(void 0, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric"
				}).format;

			function I(e) {
				const {
					item: t,
					onItemAction: n
				} = e, r = j().find(e => e.value === t.status);
				let a = t.type === u.b.Badge ? t.extra.description : void 0;
				return a && a.endsWith(" u/" + t.uploader) && (a = a.slice(0, a.length - t.uploader.length - 3)), o.a.createElement(o.a.Fragment, null, o.a.createElement(y, {
					className: E.a.imageCell
				}, o.a.createElement("div", {
					className: E.a.image,
					style: {
						backgroundImage: `url(${t.url})`
					}
				})), o.a.createElement(y, {
					className: E.a.nameCell
				}, o.a.createElement("div", {
					className: E.a.title
				}, t.type === u.b.Emote ? `:${t.name}:` : t.name), o.a.createElement("div", {
					className: E.a.caption
				}, a, "", o.a.createElement(v.a, {
					author: t.uploader,
					style: {
						color: t.type === u.b.Badge ? t.extra.color : void 0
					}
				}, "u/", t.uploader))), o.a.createElement(y, {
					className: E.a.timeCell
				}, k(t.createdAt)), o.a.createElement(y, {
					className: E.a.actionCell
				}, o.a.createElement(O.a, {
					className: E.a.dropdownSelector,
					displayText: r ? r.displayText : "",
					options: C(),
					onSelect: e => n(t, e.value),
					isCompactStyle: !0
				}), t.status !== u.a.Uploaded && !!t.moderator && !!t.modifiedAt && o.a.createElement("div", {
					className: E.a.byModerator
				}, s.fbt._("by u/ {moderator}, {time-modified}", [s.fbt._param("moderator", t.moderator), s.fbt._param("time-modified", k(t.modifiedAt))], {
					hk: "25I5ES"
				}))), o.a.createElement("div", {
					className: E.a.line
				}))
			}
			var S = n("./src/lib/classNames/index.ts");
			const w = p.a.div("cell", E.a),
				T = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(w, {
					className: E.a.imageCell
				}, o.a.createElement("div", {
					className: Object(S.a)(E.a.image, E.a.imagePlaceholder)
				})), o.a.createElement(w, {
					className: E.a.nameCell
				}, o.a.createElement("div", {
					className: E.a.loadingTextLong
				})), o.a.createElement(w, null, o.a.createElement("div", {
					className: E.a.loadingTextShort
				})), o.a.createElement(w, {
					className: E.a.actionCell
				}, o.a.createElement("div", {
					className: E.a.loadingTextShort
				})), o.a.createElement("div", {
					className: E.a.line
				}));
			var N = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(T, null), o.a.createElement(T, null), o.a.createElement(T, null), o.a.createElement(T, null));
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), R = p.a.div("header", E.a);

			function A(e) {
				const {
					onAssetAction: t,
					assets: n,
					selectedStatus: s
				} = e;
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: E.a.grid
				}, o.a.createElement(R, null, P._("Image", null, {
					hk: "3ImlXy"
				})), o.a.createElement(R, null, P._("Name and Description", null, {
					hk: "ZMWPH"
				})), o.a.createElement(R, null, P._("Submission Time", null, {
					hk: "3qPqQa"
				})), o.a.createElement(R, {
					className: E.a.actionHeader
				}, P._("Action", null, {
					hk: "27SYzP"
				})), !n && o.a.createElement(N, null), n && !!n.length && n.map(e => o.a.createElement(I, {
					item: e,
					key: e.name,
					onItemAction: t
				}))), n && !n.length && o.a.createElement(_, {
					selectedStatus: s
				}))
			}
			var M = n("./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less"),
				D = n.n(M);
			const L = e => o.a.createElement("button", {
					className: Object(S.a)(D.a.tab, {
						[D.a.selected]: e.selected
					}),
					onClick: e.onClick
				}, e.children),
				F = e => o.a.createElement("div", {
					className: D.a.tabBar
				}, [u.a.Uploaded, u.a.Approved, u.a.Rejected].map(t => o.a.createElement(L, {
					onClick: () => e.onTabSelected(t),
					selected: t === e.value,
					value: t,
					key: t
				}, (e => {
					switch (e) {
						case u.a.Uploaded:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							});
						case u.a.Approved:
							return s.fbt._("Approved", null, {
								hk: "37lIL9"
							});
						case u.a.Rejected:
							return s.fbt._("Rejected", null, {
								hk: "W16pI"
							});
						default:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							})
					}
				})(t))));

			function U() {
				return (U = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class B extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						selectedStatus: u.a.Uploaded
					}, this.onTabChange = async e => {
						this.setState({
							assets: void 0,
							selectedStatus: e
						});
						const t = await Object(u.c)(this.props.apiContext(), this.props.subredditId, this.props.assetType, e);
						t.ok ? this.setState({
							assets: t.body.assets || []
						}) : this.props.onGovernanceError(t.error)
					}, this.onAssetAction = async (e, t) => {
						if (e.status === t) return;
						const n = this.props.assetType,
							s = await Object(u.d)(this.props.apiContext(), this.props.subredditId, n, e.id, {
								status: t
							});
						if (s.ok) {
							const s = this.state.assets;
							this.setState({
								assets: s && s.filter(t => t !== e)
							}), t === u.a.Approved ? this.props.onApproved(n) : t === u.a.Rejected && this.props.onRejected(n)
						} else this.props.onGovernanceError(s.error)
					}
				}
				componentDidMount() {
					this.onTabChange(this.state.selectedStatus)
				}
				render() {
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(c.a, {
						className: E.a.contentContainer
					}, o.a.createElement(c.b, null, this.props.assetType === u.b.Badge ? s.fbt._("User uploaded badges", null, {
						hk: "3qGdzT"
					}) : s.fbt._("User uploaded emotes", null, {
						hk: "1GJiVz"
					})), o.a.createElement("div", {
						className: E.a.content
					}, o.a.createElement(F, {
						onTabSelected: this.onTabChange,
						value: this.state.selectedStatus
					}), o.a.createElement(A, {
						selectedStatus: this.state.selectedStatus,
						assets: this.state.assets,
						onAssetAction: this.onAssetAction
					}))))
				}
			}
			const G = Object(l.b)(Object(a.b)(void 0, (e, t) => ({
					onGovernanceError: t => Object(i.a)(e, t),
					onApproved: t => e(Object(d.f)({
						kind: m.b.SuccessCommunity,
						text: t === u.b.Badge ? s.fbt._("Approved badge!", null, {
							hk: "3B3r07"
						}) : s.fbt._("Approved emote!", null, {
							hk: "tWzSE"
						})
					})),
					onRejected: t => e(Object(d.f)({
						kind: m.b.SuccessCommunity,
						text: t === u.b.Badge ? s.fbt._("Rejected badge", null, {
							hk: "1X6cSg"
						}) : s.fbt._("Rejected emote", null, {
							hk: "3RS2kT"
						})
					}))
				}))(B)),
				H = e => o.a.createElement(G, U({
					assetType: u.b.Badge
				}, e)),
				W = e => o.a.createElement(G, U({
					assetType: u.b.Emote
				}, e))
		},
		"./src/reddit/components/ModHub/Content/NoPermissions.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/contexts/NavbarExp.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/ModHub/Content/index.m.less"),
				l = n.n(c);
			t.a = e => {
				const t = Object(o.useContext)(i.a);
				return a.a.createElement("div", {
					className: Object(d.a)(l.a.noPermissions, {
						[l.a.noPermissionsExp]: t
					})
				}, a.a.createElement("img", {
					className: l.a.rememberTheHuman,
					src: `${s.a.assetPath}/img/content-gate-icons/remember-the-human.png`
				}), e.isModerator ? r.fbt._("Sorry, you do not have the moderator permissions needed to view this page", null, {
					hk: "4wUDIF"
				}) : r.fbt._("Sorry, this is a moderator-only page", null, {
					hk: "2BZEIA"
				}), a.a.createElement("div", {
					className: l.a.noPermissionsSmallText
				}, e.isModerator ? r.fbt._("You need to change your mod permissions to view this page", null, {
					hk: "RS9sd"
				}) : e.subredditDisplayText ? r.fbt._("You must be a moderator of {subredditName} to view this page", [r.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "8eU68"
				}) : r.fbt._("You must be a moderator to view this page", null, {
					hk: "2N7TXH"
				})))
			}
		},
		"./src/reddit/components/ModHub/Content/WelcomeMessage.m.less": function(e, t, n) {
			e.exports = {
				ModerateIcon: "khXWcHNm7cUFKCGgNfNPy",
				moderateIcon: "khXWcHNm7cUFKCGgNfNPy",
				ModHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ",
				modHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ"
			}
		},
		"./src/reddit/components/ModHub/Content/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "CgYEK3BSwEitV3N5dS53Y",
				titleFontH2: "WtxSi4x3A6EHSYOlNO6dC",
				titleFontH3: "_1s8gRCw9ZEGeZdDLi4SjEs",
				titleFontH4: "iJgEN-DVO9xH1ING9PGia",
				titleFontH5: "_1Pk2HmstIcHsVCyXL0s7WR",
				titleFontH6: "_27G51xRMOXRk6p8hF2iFF4",
				metadataFont: "_3qFnOmsyfNVU4dOg-nT7AH",
				flairFont: "IHVtmv3d9vjFTy7sOv4nb",
				labelsFont: "_3veeqeCCuB-y_5Uz7aZwNo",
				actionFont: "_2GGs_1qJNsgRTBkJjB3JyV",
				smallButtonFont: "_1wMkSw4TKFwpURuJjoijc8",
				largeButtonFont: "_37n4mei_IKI2b0S9cUN6kj",
				strongTextFont: "_3iiIycx9Jvd-wtbZRRlyrS",
				tabFont: "_2uzD_ZiaRuda1gPntdeFV-",
				buttonFontXS: "X1zM6CuE0STTL567u2KEr",
				buttonFontXs: "X1zM6CuE0STTL567u2KEr",
				buttonFontS: "_35xxostuR-t_KnCQpTxb0F",
				buttonFontM: "_1siVd6fOXNWDs8SbSH_HQ5",
				buttonFontL: "_1mAbhFs88EE9k-jaJMzlbM",
				buttonFontXL: "FxQ8KBPxEROiwB1EG0sLr",
				buttonFontXl: "FxQ8KBPxEROiwB1EG0sLr",
				bodyFontH1: "_18F7ywSczMXfDxvUzIkKou",
				bodyFontH2: "_2gpSS7qXgM9-crN9KgQr_O",
				bodyFontH3: "-JM-6-h-SOMTCi9a5ZG0g",
				bodyFontH4: "_3ZVYgWzZxJjL_cahDG32l",
				bodyFontH5: "_15iJEJUM-il2Ud09a9yqhY",
				bodyFontH6: "_2kFIrTxjdWaprwQ9leev5x",
				bodyFontH6Small: "mhRrYXj7dAprAm-wE7DdO",
				bodyFont: "_38q9ZzND20FKMoX8BeB0u8",
				bodyFontSmall: "_1tFfFAHeLftmld2a2M4yIs",
				bodyFontMono: "_1N1SJCd40K_9LeW3MSWULf",
				rememberTheHuman: "_2S6IM2TPtTriI4r_2Op1Od",
				noPermissions: "_3jaCG74Q3u55JqGJy3u664",
				noPermissionsExp: "_30KCF1VJPMgbkHOfEhoE2p",
				noPermissionsSmallText: "_1Kxv5kLQoEOhRatEhltXrQ",
				container: "_3gsyCuYXsGWEEgPSTuX9aw",
				isLargePostLayout: "_1WGjuBpIEjcQC-x3_lE_Nu"
			}
		},
		"./src/reddit/components/ModHub/Content/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/assertNever.ts"),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/components/ApprovedSubmitterList/index.tsx"),
				c = n("./src/reddit/components/BannedUserList/index.tsx"),
				l = n("./src/reddit/components/CommunityAwardList/index.tsx"),
				u = n("./src/reddit/components/CommunitySettings/index.tsx"),
				m = n("./src/reddit/components/GrantUserFlair/index.tsx"),
				p = n("./src/reddit/components/ModerationLog/index.tsx"),
				b = n("./src/reddit/components/ModeratorsList/index.tsx"),
				h = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx"),
				f = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx"),
				g = n("./src/reddit/components/ModHub/Emojis/index.tsx"),
				_ = n("./src/reddit/components/MutedUserList/index.tsx"),
				v = n("./src/reddit/components/PowerupsSettings/index.tsx"),
				O = n("./src/reddit/components/RemovalReasons/index.tsx"),
				x = n("./src/reddit/components/Streaming/ModSettings/index.tsx"),
				E = n("./src/reddit/components/SubredditContent/EventPostContent/index.tsx"),
				y = n("./src/reddit/components/SubredditContent/PredictionsContent/async.ts"),
				j = n("./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx"),
				C = n("./src/reddit/components/SubredditRules/index.tsx");
			const k = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-ContentControls",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-ContentControls").then(n.bind(null, "./src/reddit/components/ModHub/ContentControls/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/ContentControls/index.tsx"
					}
				}),
				I = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-ChatSettings",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-ChatSettings").then(n.bind(null, "./src/reddit/components/ModHub/ChatSettings/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/ChatSettings/index.tsx"
					}
				}),
				S = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-TrafficStats",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-TrafficStats").then(n.bind(null, "./src/reddit/components/ModHub/TrafficStats/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/TrafficStats/index.tsx"
					}
				}),
				w = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-PostFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-PostFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx"
					}
				}),
				T = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-UserFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-UserFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx"
					}
				}),
				N = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-Wiki-ModHubWikiManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("SubredditWiki~reddit-components-Wiki-ModHubWikiManagement"), n.e("reddit-components-Wiki-ModHubWikiManagement")]).then(n.bind(null, "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx"
					}
				}),
				P = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-Content-ModQueue",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-Content-ModQueue").then(n.bind(null, "./src/reddit/components/ModHub/Content/ModQueue.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/Content/ModQueue.tsx"
					}
				}),
				R = e => {
					const {
						layout: t,
						pageName: n,
						postTypeFilter: s,
						postSort: r,
						subpageName: R,
						...A
					} = e, M = {
						...A,
						subredditId: e.subreddit.id
					};
					switch (n) {
						case i.gc.Removal:
							return o.a.createElement(O.a, {
								subredditId: e.subreddit.id,
								sendEventWithName: e.sendEventWithName
							});
						case i.gc.Contributors:
							return o.a.createElement(d.a, M);
						case i.gc.Banned:
							return o.a.createElement(c.a, M);
						case i.gc.Streaming:
							return o.a.createElement(x.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case i.gc.Muted:
							return o.a.createElement(_.a, M);
						case i.gc.Moderators:
							return o.a.createElement(b.a, M);
						case i.gc.Modlog:
							return o.a.createElement(p.a, M);
						case i.gc.ContentControls:
							return o.a.createElement(k, {
								subredditName: e.subreddit.name
							});
						case i.gc.ChatSettings:
							return o.a.createElement(I, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case i.gc.Flair:
							return o.a.createElement(m.a, {
								after: e.after,
								before: e.before,
								subredditId: e.subreddit.id
							});
						case i.gc.PostFlair:
							return o.a.createElement(w, {
								subredditId: e.subreddit.id
							});
						case i.gc.UserFlair:
							return o.a.createElement(T, {
								subredditId: e.subreddit.id
							});
						case i.gc.Badges:
							return o.a.createElement(f.a, {
								subredditId: e.subreddit.id
							});
						case i.gc.Emotes:
							return o.a.createElement(f.b, {
								subredditId: e.subreddit.id
							});
						case i.gc.SubredditRules:
							return o.a.createElement(C.a, {
								subreddit: e.subreddit
							});
						case i.gc.CommunitySettings:
							return o.a.createElement(u.a, {
								subredditId: e.subreddit.id,
								subpageName: e.subpageName,
								subredditName: e.subreddit.name
							});
						case i.gc.Modqueue:
						case i.gc.Reports:
						case i.gc.Spam:
						case i.gc.Edited:
						case i.gc.Unmoderated:
							return o.a.createElement(P, {
								after: e.after,
								layout: t,
								page: e.page,
								pageName: n,
								postTypeFilter: s,
								postSort: r,
								sendEventWithName: e.sendEventWithName,
								subredditName: e.subreddit.name
							});
						case i.gc.Awards:
							return o.a.createElement(l.a, {
								subredditOrProfile: e.subreddit,
								subredditOrProfileId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions
							});
						case i.gc.Powerups:
							return o.a.createElement(v.a, {
								subredditId: e.subreddit.id
							});
						case i.gc.Emojis:
							return o.a.createElement(g.a, {
								subreddit: e.subreddit
							});
						case i.gc.Wiki:
						case i.gc.WikiContributors:
						case i.gc.WikiBanned:
							return o.a.createElement(N, {
								subreddit: e.subreddit
							});
						case i.gc.Traffic:
							return o.a.createElement(S, {
								subreddit: e.subreddit
							});
						case i.gc.SubredditContent:
							return null;
						case i.gc.ScheduledPostContent:
							return o.a.createElement(j.a, {
								subreddit: e.subreddit
							});
						case i.gc.EventPostContent:
							return o.a.createElement(E.a, {
								subredditName: e.subreddit.name
							});
						case i.gc.Predictions:
							return o.a.createElement(y.a, {
								subreddit: e.subreddit
							});
						case i.gc.TalkHosts:
							return o.a.createElement(h.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions,
								sendEventWithName: e.sendEventWithName
							});
						default:
							return Object(a.a)(n)
					}
				};
			t.a = R
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_20ADRJAodM5zU1OpvNEeRz",
				checkboxText: "_21Bw38NODPHxkJ8zAXjoUZ",
				closeButton: "_3m2cog1fzR2zNYfyXI2GUB",
				emojiDisplay: "_1mMSj2QBZEQ97i-4y3-WOp",
				emojiNameDisplay: "_2lbIQVKPZ4LHDNpBLwSOps",
				imageDisplay: "_3BXziWyChS-zhQ5XC9lt4k",
				appearsIn: "_1DhToTbLLM2OC-Ze5nDwCq",
				imageTitle: "_2KrLezTGMfd18btz-KkYMi",
				modalBody: "_1PLlW-_ZV0vWQQ6LS1Z2lH",
				modalAddButton: "_1vUjBClk27uHOAYH__0rj9",
				modalCancelButton: "_23RRFTkR9NKrC22rmMDNfI",
				modFlairOnlyToggle: "_19ExxuLL5lOZW35TZFXIHf",
				modIcon: "_3ta-U9hY9R1H_BRwYv1zhl",
				modProTip: "_2yN7aUrL8peCADm-u303LV",
				modProTips: "_3WtRXJc1jCLpCEw7-mlEBU",
				proTip: "_8wjmRK1w6qEGzue3BNNOA",
				modProTipTitle: "_392GI--ZxhpUHn1eRTKzqA",
				tipList: "_3PPlagKiQrtoOsW4pcf3vc"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_34rhMfrLYNSjUkhTK958Um",
				characterCountdown: "_15Hq3tMBKH4TWo9OJs8gny",
				clearIcon: "aCmT6tHKACP3PLk6IU6XT",
				duplicatesIcon: "Eq88P0Zb-rOoo4N5OL5uk",
				duplicateWarning: "DRp2YTik6Ln3yUKp7LBUv",
				editEmojiFooter: "_2ZoRiRDs45wlLK-ZnHzUh",
				editEmojiDisplay: "_2rDJJ0Uk_ySvUA9QNoKoKU",
				emojiDisplays: "_2FsakuX5ZR_IIPcwXQu0eD",
				errorText: "_3bRRwpzb2xfP5erPt9R6Cg",
				expandLeft: "_2byjR1IbLclRfoyvyjMDUz",
				iconSpacer: "_3tWeESqi0MQaqN5wKqkv68",
				imageDisplay: "_1MHWj3sdAGALX7r7UzFF0J",
				duplicateInput: "_280zGglckljUYhFjwaBt14",
				input: "_3xzW-TBy6RXHXBjCE9Yz7s",
				inputPlaceholder: "_1964bAdk8xBAb8-d_Mthtt",
				modalAddButton: "_2yQ10LXNPJ6antT2NgaTmI",
				modalCancelButton: "_31Qk2tb7PaP2XWWL2o4HM1",
				modProTip: "NSSpRN8n70A1TesDNcvxE",
				progressBar: "_3EbPa1JwqT9b_QgXnHzJsx",
				innerBarClassName: "_3CJpdsYAp2vfEOO_U7AaO8",
				progressText: "Wz5fdVLDZuS4d-ix-j4s9",
				replacingDescription: "_1oXr6AKswirSKypchDoX1n",
				replacingTitle: "oNyr5QxUcemiI3SFwjhvc",
				uploadingTitle: "_3ZEFRZKrLVT92hTIG7sRa9",
				textButton: "_3ZzQTZKV1t84-ND6HHwnsx",
				uploaderContainer: "OCFZ6HIQUbokDXiubxQEZ"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_3x5p0Ujs6EWdeLO8-fVE7v",
				emojisDisabled: "_2H7y73ZptDGSake8tFEj0n",
				labelTitle: "_2R2K1Sz81kscliWYqOq1xU",
				labelDescription: "_1TqFvv__UfmckLHp5llo7q",
				leftForm: "_22aW9zYAhDGH2HdlJ-WWIM",
				modalBody: "_1_UK8ZmVC7e_nkeSs5CGnA",
				modalCloseButton: "_2-arZqA5i-aG-76OM9aj7k",
				modalEnableSection: "_2Wd3qBH4SU1NauwzVOQbVT",
				modalFooter: "_2R2UP3vtcyZqyNdUy9Y0nX",
				modalSubmitButton: "w7T2GA8_RqtkSpD4h6YKH",
				modalCancelButton: "_2wvHObzKgyjObCvFZ0QOp0",
				rightForm: "_1eE1s4H4f1_A3ck0iF679O",
				row: "_2NQoOHp9q7uhb8h4XdVWK",
				displayWrapper: "jiCIuKa0E1BjfGfUV407r",
				emojiDisplay: "_32BxZer8uLzSVJMZqqo95_",
				emojiName: "_2hJHG1X01WKzuznOL4l6ge",
				appears: "ZVOiCMvsomJLwhS8k4VPP",
				permissions: "UxdnKubszq3iR9sJGFwiY",
				buttonWrapper: "PflXNgwgKckPGaFe9wW8V",
				editEmoji: "_3RR0-7gyjso1AHuVhVbb6u",
				editSnoomoji: "FCFv4UPC_NQjiTCEBoOCD",
				trashIcon: "_2l2KeCLkXUEz_czKdpFqSw",
				settingsButton: "_2dh14d_OrE4Etrg44_cb4t",
				toggleSwitch: "_17kocpcRdOCXJwPiOk68B-",
				topRow: "_2oevuimQpT3hztJ5Rpf_hy",
				appearsTitle: "_1Qzxm6lOFpTR3O3hzKloA9",
				imageTitle: "_1NOoO9mz09cpZjIRT9nHTh",
				nameTitle: "_1Ra9yqtrrSj9q0akrKs83v",
				permissionsTitle: "_1gNO8_Ywz6va1MbMV7-jDG",
				titleTooltip: "_279Uba_Gpg0WVLV8efIdK_"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/map.js"),
				a = n.n(o),
				i = n("./node_modules/react/index.js"),
				d = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/actions/emoji.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				h = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				_ = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				O = n("./src/reddit/components/TrackingHelper/index.tsx"),
				x = n("./src/reddit/constants/colors.ts"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/selectors/telemetry.ts");
			const j = e => ({
					subreddit: y.hb(e),
					profile: y.R(e),
					userSubreddit: y.rb(e)
				}),
				C = (e, t) => n => ({
					source: "emoji",
					action: "toggle",
					noun: e,
					actionInfo: {
						settingValue: t ? "on" : "off"
					},
					...j(n)
				}),
				k = e => t => ({
					source: "emoji",
					action: "click",
					noun: e,
					...j(t)
				}),
				I = (e, t) => n => ({
					source: "emoji",
					action: "click",
					noun: e,
					actionInfo: y.d(n, {
						count: t
					}),
					...j(n)
				});
			var S = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				w = n("./src/reddit/selectors/activeModalId.ts"),
				T = n("./src/reddit/selectors/emojis.ts"),
				N = n("./src/reddit/components/ModHub/Emojis/index.m.less"),
				P = n.n(N),
				R = n("./src/reddit/controls/ImageDisplay/index.tsx"),
				A = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				M = n("./src/reddit/layout/row/Inline/index.tsx");
			const D = u.a.span("appears", P.a),
				L = u.a.span("buttonWrapper", P.a),
				F = u.a.span("displayWrapper", P.a),
				U = u.a.wrapped(R.a, "emojiDisplay", P.a),
				B = u.a.span("emojiName", P.a),
				G = u.a.span("permissions", P.a),
				H = u.a.wrapped(M.a, "row", P.a),
				W = u.a.wrapped(A.b, "trashIcon", P.a);
			var q = e => d.a.createElement(H, null, d.a.createElement(F, null, d.a.createElement(U, {
					backgroundImage: e.emoji.url
				})), d.a.createElement(B, null, e.emoji.name), d.a.createElement(D, null, ((e, t) => e && t ? r.fbt._("Post flair, user flair", null, {
					hk: "gLvKb"
				}) : e ? r.fbt._("Post flair", null, {
					hk: "dcIoz"
				}) : t ? r.fbt._("User flair", null, {
					hk: "4fQagx"
				}) : "")(e.emoji.postFlairAllowed, e.emoji.userFlairAllowed)), d.a.createElement(G, null, e.emoji.modFlairOnly && r.fbt._("Mod only", null, {
					hk: "NMZoE"
				})), d.a.createElement(L, null, d.a.createElement(E.r, {
					className: e.isSnoomoji ? P.a.editSnoomoji : P.a.editEmoji,
					onClick: () => e.onEdit(e.emoji, e.isSnoomoji)
				}, r.fbt._("Edit", null, {
					hk: "1nftDt"
				})), !e.isSnoomoji && d.a.createElement("button", {
					onClick: () => e.onRemove(e.emoji.name)
				}, d.a.createElement(W, null)))),
				V = n("./src/higherOrderComponents/asModal/index.tsx"),
				z = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				K = n("./src/reddit/controls/TextButton/index.tsx"),
				Q = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				J = n("./src/reddit/selectors/subreddit.ts"),
				Y = n("./src/reddit/controls/ToggleSwitch/index.tsx");
			const X = u.a.span("labelDescription", P.a),
				Z = u.a.span("labelTitle", P.a),
				$ = u.a.div("leftForm", P.a),
				ee = u.a.div("rightForm", P.a),
				te = u.a.wrapped(Y.a, "toggleSwitch", P.a);
			var ne = e => d.a.createElement("div", {
				className: e.className
			}, d.a.createElement($, null, d.a.createElement(Z, null, r.fbt._("{title}", [r.fbt._param("title", e.title)], {
				hk: "4bYhaP"
			})), d.a.createElement(X, null, r.fbt._("{description}", [r.fbt._param("description", e.description)], {
				hk: "1lFxbr"
			}))), d.a.createElement(ee, null, d.a.createElement(te, {
				on: e.on,
				onToggle: e.onToggle
			})));
			const se = u.a.wrapped(ne, "modalEnableSection", P.a),
				re = u.a.wrapped(z.e, "modalBody", P.a),
				oe = u.a.wrapped(z.a, "modalCancelButton", P.a),
				ae = u.a.wrapped(K.a, "modalCloseButton", P.a),
				ie = u.a.wrapped(z.g, "modalFooter", P.a),
				de = u.a.wrapped(E.l, "modalSubmitButton", P.a),
				ce = Object(l.c)({
					isEmojisEnabled: (e, t) => Object(J.w)(e, {
						subredditName: t.subreddit.name
					}).emojisEnabled
				}),
				le = Object(c.b)(ce, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						toggleEnableEmojis: t => e(Object(m.j)(n.id, t))
					}
				});
			class ue extends d.a.Component {
				constructor(e) {
					super(e), this.handleEnableEmojisToggle = () => this.setState({
						emojisEnabled: !this.state.emojisEnabled
					}), this.enableHasBeenToggled = () => this.props.isEmojisEnabled !== this.state.emojisEnabled, this.canSave = () => this.enableHasBeenToggled(), this.onSave = () => {
						const {
							props: e,
							state: t
						} = this;
						this.enableHasBeenToggled() && (e.toggleEnableEmojis(t.emojisEnabled), e.sendEvent(C("enable", t.emojisEnabled))), e.toggleModal(), e.sendEvent(k("save_emoji_settings"))
					}, this.state = {
						emojisEnabled: e.isEmojisEnabled
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return d.a.createElement(re, null, d.a.createElement(z.i, null, d.a.createElement(Q.a, null, d.a.createElement(z.q, null, r.fbt._("Emoji settings", null, {
						hk: "1GjUM3"
					})), d.a.createElement(ae, {
						onClick: e.toggleModal
					}, d.a.createElement(z.b, null)))), d.a.createElement(z.l, null, d.a.createElement(se, {
						description: r.fbt._("Allow emojis to be used in post and user flair within your community", null, {
							hk: "3ppqgX"
						}),
						on: t.emojisEnabled,
						onToggle: this.handleEnableEmojisToggle,
						title: r.fbt._("Enable emojis in this community", null, {
							hk: "3uLrQi"
						})
					})), d.a.createElement(ie, null, d.a.createElement(oe, {
						onClick: e.toggleModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(de, {
						disabled: !this.canSave(),
						onClick: this.onSave
					}, r.fbt._("Save", null, {
						hk: "4yMsMq"
					}))))
				}
			}
			var me = Object(V.a)(le(ue)),
				pe = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/toaster.ts")),
				be = n("./src/reddit/components/StructuredStyles/ImageUpload/index.tsx"),
				he = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				fe = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				ge = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				_e = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				ve = n("./src/reddit/models/Image/index.tsx"),
				Oe = n("./src/reddit/models/Toast/index.ts"),
				xe = n("./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less"),
				Ee = n.n(xe),
				ye = n("./src/higherOrderComponents/withImageUploads.tsx"),
				je = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				Ce = n("./src/reddit/models/Emoji/index.ts"),
				ke = n("./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less"),
				Ie = n.n(ke),
				Se = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				we = n("./src/reddit/components/ProgressBar/index.tsx"),
				Te = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				Ne = n("./src/reddit/controls/ErrorText/index.tsx");
			const Pe = 5,
				Re = 95,
				Ae = 600,
				Me = 100;
			class De extends d.a.Component {
				constructor() {
					super(...arguments), this.intervalToken = 0, this.state = {
						timeStarted: Date.now(),
						percent: Pe
					}, this.tick = () => {
						const e = function(e) {
							const t = e / Ae,
								n = (Math.log(t / 10) + 3) / 2.1;
							return Math.max(Re, Math.min(Pe, 100 * n))
						}(Date.now() - this.state.timeStarted);
						this.setState({
							percent: e
						}), e === Re && this.intervalToken && window.clearInterval(this.intervalToken)
					}
				}
				componentDidMount() {
					this.intervalToken = window.setInterval(this.tick, Me)
				}
				componentWillUnmount() {
					this.intervalToken && window.clearInterval(this.intervalToken)
				}
				render() {
					return d.a.createElement(we.a, {
						className: Ie.a.progressBar,
						innerBarClassName: Ie.a.innerBarClassName,
						percent: this.state.percent
					})
				}
			}
			var Le = De;
			const Fe = u.a.wrapped(Se.a, "characterCountdown", Ie.a),
				Ue = u.a.wrapped(je.a, "clearIcon", Ie.a),
				Be = u.a.wrapped(Ne.b, "errorText", Ie.a),
				Ge = u.a.wrapped(Q.a, "expandLeft", Ie.a),
				He = u.a.div("iconSpacer", Ie.a),
				We = u.a.wrapped(R.a, "imageDisplay", Ie.a),
				qe = u.a.div("inputPlaceholder", Ie.a),
				Ve = u.a.wrapped(Q.a, "inputPlaceholder", Ie.a),
				ze = u.a.wrapped(K.a, "textButton", Ie.a);
			class Ke extends d.a.Component {
				constructor() {
					super(...arguments), this.handleChangeEmojiName = e => {
						this.props.onChangeEmojiName && this.props.onChangeEmojiName(this.props.index, e.target.value)
					}, this.handleRemove = e => {
						this.props.onCancel(this.props.index)
					}, this.renderContent = () => {
						const {
							emojiName: e,
							errorText: t,
							fileName: n,
							handleRetry: s,
							imageData: o,
							isDuplicate: a
						} = this.props;
						switch (o.kind) {
							case ve.b.NotUploaded:
							case ve.b.Pending:
								return d.a.createElement("div", null, d.a.createElement(Ve, null, o.kind === ve.b.NotUploaded ? d.a.createElement(Le, null) : d.a.createElement(we.a, {
									className: Ie.a.progressBar,
									innerBarClassName: Ie.a.innerBarClassName,
									percent: 0
								}), d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Cancel", null, {
									hk: "2TSLl5"
								}))), d.a.createElement(he.b, null, r.fbt._("Uploading {fileName}", [r.fbt._param("fileName", n)], {
									hk: "NIxvK"
								})));
							case ve.b.FailedToUpload:
							case ve.b.Invalid:
								return d.a.createElement("div", null, d.a.createElement(Ve, null, r.fbt._("Failed to upload", null, {
									hk: "2LBRW2"
								}), s ? d.a.createElement(ze, {
									onClick: s
								}, r.fbt._("Retry", null, {
									hk: "3EwbaK"
								})) : d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(Be, null, t));
							case ve.b.Uploaded:
								return d.a.createElement(qe, null, r.fbt._("Saved", null, {
									hk: "2xDFZZ"
								}));
							default:
								return d.a.createElement("div", null, d.a.createElement(Te.c, {
									className: a ? Ie.a.duplicateInput : Ie.a.input,
									onChange: this.handleChangeEmojiName,
									placeholder: r.fbt._("Emoji name", null, {
										hk: "UpQdA"
									}),
									value: e
								}), d.a.createElement(Ge, null, d.a.createElement(Fe, {
									maxChars: Ce.d,
									text: e
								}), d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(Be, null, t))
						}
					}
				}
				render() {
					const {
						emojiName: e,
						imageData: t,
						isSaving: n
					} = this.props;
					return n ? d.a.createElement(d.a.Fragment, null, d.a.createElement(qe, null, d.a.createElement(Le, null)), d.a.createElement(he.b, null, r.fbt._("Saving {emojiName}", [r.fbt._param("emojiName", e)], {
						hk: "3lMST7"
					}))) : d.a.createElement(_e.a, null, t.kind === ve.b.FailedToUpload || t.kind === ve.b.Invalid ? d.a.createElement(He, null, d.a.createElement(Ue, null)) : d.a.createElement(We, {
						backgroundImage: t.url
					}), this.renderContent())
				}
			}
			var Qe = Ke,
				Je = n("./node_modules/lodash/countBy.js"),
				Ye = n.n(Je),
				Xe = n("./node_modules/lodash/filter.js"),
				Ze = n.n(Xe),
				$e = n("./node_modules/lodash/includes.js"),
				et = n.n($e),
				tt = n("./node_modules/lodash/transform.js"),
				nt = n.n(tt);
			const st = /^[A-Za-z0-9_-]{1,24}$/,
				rt = ["reddit", "snoo", "spez"],
				ot = (e, t, n) => !st.test(e) || !n && (e => {
					const t = e.toLowerCase();
					return rt.reduce((e, n) => e || -1 !== t.indexOf(n), !1)
				})(e) ? r.fbt._("Invalid emoji name", null, {
					hk: "2Oromm"
				}) : et()(t, e) ? r.fbt._("This name is already taken", null, {
					hk: "4dwdJL"
				}) : "",
				at = e => e.name ? e.name.replace(/\.[^.]*$/, "").replace(/[^A-Za-z0-9_-]/g, " ").trim().replace(/ +/g, "_").slice(0, 24) : "",
				it = (e, t) => (t.kind !== ve.b.TempUploaded || !e.emojiNameError && !e.isNameMissing) && (t.kind !== ve.b.NotUploaded && t.kind !== ve.b.Pending),
				dt = e => {
					let t = "";
					return e.file.size > Ce.a ? t = "file-size-error" : (e.height > Ce.b || e.width > Ce.c) && (t = "image-size-error"), {
						emojiNameError: "",
						imageError: t,
						name: at(e.file),
						fileName: e.file.name,
						isNameMissing: !1
					}
				},
				ct = (e, t) => t.reduce((t, n) => n.kind === e ? t + 1 : t, 0),
				lt = (e, t) => {
					const {
						emojiNameError: n,
						imageError: s,
						isNameMissing: o
					} = t;
					let a = "";
					e.kind === ve.b.FailedToUpload && (a = e.error.fields && e.error.fields.length ? e.error.fields[0].msg : r.fbt._("Something went wrong", null, {
						hk: "2fCWXR"
					}));
					const i = a || !1,
						d = n || !!o && r.fbt._("Emoji name is required", null, {
							hk: "4sL3l7"
						});
					let c = "";
					return "file-size-error" === s ? c = r.fbt._("File size too large", null, {
						hk: "EksGU"
					}) : "image-size-error" === s && (c = r.fbt._("Image size too large", null, {
						hk: "1xjOmq"
					})), c || i || d || ""
				},
				ut = e => {
					const t = Ze()(e, e => !e.emojiNameError && !e.imageError),
						n = Ye()(t, e => e.name);
					return nt()(n, (e, t, n) => {
						t > 1 && e.push(n)
					}, [])
				},
				mt = 500,
				pt = u.a.div("UploaderContainer", Ie.a),
				bt = u.a.wrapped(S.a, "alertIcon", Ie.a),
				ht = u.a.wrapped(je.a, "duplicatesIcon", Ie.a),
				ft = u.a.wrapped(z.p, "duplicateWarning", Ie.a),
				gt = u.a.wrapped(E.l, "modalAddButton", Ie.a),
				_t = u.a.wrapped(z.a, "modalCancelButton", Ie.a),
				vt = u.a.div("uploaderContainer", Ie.a),
				Ot = u.a.wrapped(z.p, "modProTip", Ie.a),
				xt = u.a.div("progressText", Ie.a),
				Et = u.a.wrapped(z.p, "replacingDescription", Ie.a),
				yt = u.a.div("replacingTitle", Ie.a),
				jt = u.a.div("uploadingTitle", Ie.a),
				Ct = Object(l.c)({
					emojis: T.d,
					isSnoomojiSubreddit: J.l,
					reservedEmojiNames: T.e
				}),
				kt = Object(c.b)(Ct, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						emojisUploadedToast: () => e(pe.f({
							kind: Oe.b.SuccessCommunityGreen,
							text: r.fbt._("New emojis added!", null, {
								hk: "1Q1mEq"
							})
						})),
						saveEmoji: (t, s, r) => e(Object(m.n)({
							imageData: t,
							subredditId: n,
							emojiName: s,
							settings: r
						}))
					}
				});
			class It extends d.a.Component {
				constructor(e) {
					super(e), this.timeoutToken = 0, this.loadIndex = 0, this.tempUploadNext = async () => {
						const e = this.getNextPendingImageToLoad();
						if (!e) return this.timeoutToken = 0, void(this.loadIndex = 0);
						const {
							subredditId: t
						} = this.props, n = this.state.emojiData[e.id], s = Object(ve.m)(e);
						await this.props.uploadImage({
							imageData: s,
							subredditId: t,
							emojiName: n.name,
							settings: this.props.emojiSettings
						}), this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(this.tempUploadNext, mt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.emojiIsADuplicate = (e, t) => e && t && t.some(t => t.id === e.id), this.saveNext = e => {
						const t = this.getNextTempUploadedImageToSave();
						if (!t) return this.timeoutToken = 0, void(this.loadIndex = 0);
						if (!this.emojiIsADuplicate(t, e)) {
							const e = this.state.emojiData[t.id],
								n = this.props.saveEmoji(t, e.name, this.props.emojiSettings);
							this.setState({
								emojisUploaded: this.state.emojisUploaded || n
							})
						}
						this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(() => this.saveNext(e), mt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.onChangeEmojiName = (e, t) => {
						const {
							isSnoomojiSubreddit: n,
							reservedEmojiNames: s
						} = this.props;
						if (t.length > Ce.d) return;
						const r = this.state.isReplacing ? this.state.replacingEmoji && this.state.replacingEmoji[e] : this.state.localData[e];
						if (!r) return;
						const o = this.state.emojiData,
							a = o[r.id],
							i = t ? ot(t, s, n) : "";
						o[r.id].emojiNameError = i, o[r.id].name = t;
						const d = ut(o);
						this.setState({
							duplicateNames: d,
							emojiData: {
								...this.state.emojiData,
								[r.id]: {
									...a,
									emojiNameError: i,
									isNameMissing: !t,
									name: t
								}
							}
						})
					}, this.canSave = () => {
						let e = !1;
						for (const t of this.state.localData) {
							if (!it(this.state.emojiData[t.id], t)) return !1;
							t.kind === ve.b.TempUploaded && (e = !0)
						}
						return e
					}, this.getValidatedState = () => {
						const {
							isSnoomojiSubreddit: e,
							reservedEmojiNames: t
						} = this.props, n = {};
						for (const s of this.state.localData) {
							let r = this.state.emojiData[s.id];
							const o = ot(r.name, t, e);
							r.name && !o || (r = {
								...r,
								emojiNameError: o,
								isNameMissing: !r.name
							}), n[s.id] = r
						}
						return {
							emojiData: n
						}
					}, this.onApply = () => {
						const e = this.getValidatedState();
						this.setState(e, () => {
							if (this.canSave()) {
								const e = this.props.emojis[this.props.subredditId].emojis,
									t = [];
								for (const s of this.state.localData) {
									if (s.kind !== ve.b.TempUploaded) continue;
									this.state.emojiData[s.id].name in e && t.push(s)
								}
								t.length ? (this.setState({
									replacingEmoji: t,
									isReplacing: !0
								}), this.saveNext(t)) : (this.setState({
									isSavingImage: !0
								}), this.props.setIsSaving(!0), this.saveNext());
								const n = ct(ve.b.TempUploaded, this.state.localData) - t.length;
								n > 0 && (this.props.sendEvent(I("add", n)), this.sendSettingsEvent())
							}
						})
					}, this.sendSettingsEvent = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.props.emojiSettings;
						this.props.sendEvent(C("mods_only", e)), this.props.sendEvent(C("appear_user_flair", t)), this.props.sendEvent(C("appear_post_flair", n))
					}, this.handleSaveAndReplace = () => {
						this.setState({
							isReplacing: !1,
							isSavingImage: !0
						}), this.props.setIsSaving(!0);
						const {
							replacingEmoji: e
						} = this.state, t = e ? e.length : 0;
						this.saveNext(), t > 0 && (this.props.sendEvent(I("replace", t)), this.sendSettingsEvent())
					}, this.handleCancelReplace = () => {
						this.setState({
							isReplacing: !1,
							replacingEmoji: null
						}), this.props.stopEditing(), this.props.sendEvent(k("dont_replace"))
					}, this.findEmojiIndexById = e => this.state.localData.findIndex(t => t.id === e), this.removeEmoji = e => {
						const {
							isReplacing: t,
							localData: n,
							replacingEmoji: s
						} = this.state;
						let r, o = e;
						t && s && s[e] && (o = this.findEmojiIndexById(s[e].id), (r = s.slice(0)).splice(e, 1), this.setState({
							replacingEmoji: r
						}));
						const a = n[o],
							i = n.slice(0);
						i.splice(o, 1);
						const d = {
							...this.state.emojiData
						};
						delete d[a.id], this.setState({
							duplicateNames: ut(d),
							emojiData: d,
							localData: i
						}), t && s ? 0 === r.length && this.props.returnToAddState() : 0 === i.length && this.props.returnToAddState()
					}, this.retryEmojiUpload = () => {
						this.props.returnToAddState()
					};
					const t = {},
						n = [];
					for (const s of e.images) {
						const e = dt(s);
						t[s.id] = e, e.imageError ? n.push(Object(ve.l)(s, e.imageError)) : n.push(s)
					}
					this.state = {
						duplicateNames: ut(t),
						emojiData: t,
						emojisUploaded: !1,
						isReplacing: !1,
						isSavingImage: !1,
						localData: n,
						replacingEmoji: null
					}
				}
				UNSAFE_componentWillMount() {
					this.loadIndex = 0, this.tempUploadNext()
				}
				getNextPendingImageToLoad() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ve.b.Pending) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				getNextTempUploadedImageToSave() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ve.b.TempUploaded) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				UNSAFE_componentWillReceiveProps(e) {
					const t = e.getImageUploadsIfModified(this.state.localData);
					if (!t) return;
					let n = !1;
					const {
						isSavingImage: s
					} = this.state, r = {};
					for (const o of t) r[o.id] = this.state.emojiData[o.id], n = n || o.kind === ve.b.TempUploaded;
					!s || n ? (this.props.setIsSaving(s), this.setState({
						emojiData: r,
						isSavingImage: s,
						localData: t
					})) : this.props.stopEditing()
				}
				componentWillUnmount() {
					for (const e of this.state.localData) this.props.cancelUpload(e);
					this.timeoutToken && window.clearTimeout(this.timeoutToken), this.state.emojisUploaded && this.props.emojisUploadedToast(), this.setState({
						emojisUploaded: !1,
						isReplacing: !1
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = t.isReplacing ? t.replacingEmoji || [] : t.localData;
					return d.a.createElement(pt, null, d.a.createElement(vt, null, t.duplicateNames.length > 0 ? d.a.createElement(ft, null, d.a.createElement(ht, null), r.fbt._("Duplicate names", null, {
						hk: "4kkNr1"
					})) : !t.isReplacing && d.a.createElement(Ot, null, d.a.createElement(bt, null), r.fbt._("Names cannot be edited once added", null, {
						hk: "3f45r5"
					})), d.a.createElement(z.l, null, t.isReplacing ? d.a.createElement(d.a.Fragment, null, d.a.createElement(yt, null, r.fbt._("Replacing emojis", null, {
						hk: "4cKike"
					})), d.a.createElement(Et, null, r.fbt._("These emoji names already exist in your community. Replacing these emojis will not change pre-existing permissions. Do you want to replace them?", null, {
						hk: "3iPBUU"
					}))) : d.a.createElement(jt, null, r.fbt._("Uploading emojis", null, {
						hk: "7keSV"
					})), d.a.createElement("div", {
						className: t.isReplacing ? void 0 : Ie.a.emojiDisplays
					}, n.map((e, n) => {
						const s = this.state.emojiData[e.id],
							r = e.kind === ve.b.FailedToUpload || e.kind === ve.b.Invalid,
							o = t.replacingEmoji && !t.replacingEmoji.find(t => t.id === e.id);
						if (t.isSavingImage && (r || o)) return;
						const a = lt(e, s);
						return d.a.createElement(he.a, {
							key: e.id
						}, d.a.createElement(Qe, {
							emojiName: s.name,
							errorText: a,
							fileName: s.fileName,
							imageData: e,
							index: n,
							isDuplicate: t.duplicateNames.includes(s.name),
							isSaving: t.isSavingImage,
							onCancel: this.removeEmoji,
							onChangeEmojiName: this.onChangeEmojiName
						}))
					})), !t.isReplacing && d.a.createElement(xt, null, t.isSavingImage ? r.fbt._("{savedCount} out of {savedTotal} saved", [r.fbt._param("savedCount", ct(ve.b.Uploaded, t.localData).toString()), r.fbt._param("savedTotal", t.localData.length.toString())], {
						hk: "3v1E9N"
					}) : r.fbt._("{uploadedCount} out of {uploadedTotal} uploaded", [r.fbt._param("uploadedCount", ct(ve.b.TempUploaded, t.localData).toString()), r.fbt._param("uploadedTotal", t.localData.length.toString())], {
						hk: "41qbSa"
					})))), d.a.createElement(z.g, null, d.a.createElement(_t, {
						disabled: t.isSavingImage,
						onClick: t.isReplacing ? this.handleCancelReplace : e.stopEditing
					}, t.isReplacing ? r.fbt._("Don't replace", null, {
						hk: "4d8hwM"
					}) : r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(gt, {
						disabled: t.isSavingImage || !this.canSave() || t.duplicateNames.length > 0,
						onClick: t.isReplacing ? this.handleSaveAndReplace : this.onApply
					}, t.isReplacing ? r.fbt._("Replace", null, {
						hk: "45noqB"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					}))))
				}
			}
			var St = Object(ye.a)(kt(It), m.o),
				wt = n("./src/reddit/actions/imageUploads.ts"),
				Tt = n("./src/reddit/selectors/imageUploads.ts");
			const Nt = u.a.div("UploaderContainer", Ie.a),
				Pt = u.a.wrapped(Nt, "editEmojiDisplay", Ie.a),
				Rt = Object(l.c)({
					reduxImage: (e, t) => {
						let {
							pendingImage: n
						} = t;
						const s = Object(Tt.b)(e),
							r = n && n.id;
						return r && s[r] || void 0
					}
				});
			class At extends d.a.Component {
				constructor(e) {
					super(e), this.onCancelAndRetry = () => {
						this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage), this.props.onRetryUpload()
					}
				}
				componentDidMount() {
					const e = Object(ve.m)(this.props.pendingImage);
					this.props.uploadImage({
						imageData: e,
						subredditId: this.props.subredditId,
						emojiName: this.props.emoji.name,
						settings: this.props.emojiSettings
					})
				}
				componentDidUpdate(e) {
					this.props.reduxImage && this.props.reduxImage !== e.reduxImage && this.props.onImageChange(this.props.reduxImage)
				}
				componentWillUnmount() {
					this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage)
				}
				render() {
					const {
						pendingImage: e,
						reduxImage: t,
						emoji: n
					} = this.props, s = dt(e), r = Object(ve.l)(e, s.imageError), o = s.imageError ? r : t || e, a = lt(o, s);
					return !a && o.kind === ve.b.TempUploaded || o.kind === ve.b.Uploaded ? null : d.a.createElement(Pt, null, d.a.createElement(Qe, {
						emojiName: n.name,
						errorText: a,
						fileName: s.fileName,
						handleRetry: this.onCancelAndRetry,
						imageData: o,
						index: 0,
						isSaving: !1,
						onCancel: this.onCancelAndRetry
					}))
				}
			}
			var Mt = Object(c.b)(Rt, e => ({
				uploadImage: t => e(Object(m.o)(t)),
				cancelUpload: t => e(Object(wt.h)(t))
			}))(At);

			function Dt() {
				return (Dt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Lt = 32,
				Ft = 128,
				Ut = 64,
				Bt = 100,
				Gt = u.a.div("appearsIn", Ee.a),
				Ht = u.a.wrapped(fe.a, "checkbox", Ee.a),
				Wt = u.a.span("checkboxText", Ee.a),
				qt = u.a.wrapped(K.a, "closeButton", Ee.a),
				Vt = u.a.div("imageTitle", Ee.a),
				zt = u.a.wrapped(E.l, "modalAddButton", Ee.a),
				Kt = u.a.wrapped(z.e, "modalBody", Ee.a),
				Qt = u.a.wrapped(z.a, "modalCancelButton", Ee.a),
				Jt = u.a.wrapped(z.l, "modalMain", Ee.a),
				Yt = u.a.wrapped(ne, "modFlairOnlyToggle", Ee.a),
				Xt = u.a.wrapped(ge.a, "modIcon", Ee.a),
				Zt = u.a.li("modProTip", Ee.a),
				$t = u.a.div("modProTips", Ee.a),
				en = u.a.div("modProTipTitle", Ee.a),
				tn = u.a.div("proTip", Ee.a),
				nn = u.a.ul("tipList", Ee.a),
				sn = e => !!e && (e.kind === ve.b.Pending ? !!dt(e).imageError : e.kind === ve.b.FailedToUpload);
			var rn;
			! function(e) {
				e[e.AddState = 0] = "AddState", e[e.SingleEmojiEditState = 1] = "SingleEmojiEditState", e[e.BulkUploadState = 2] = "BulkUploadState"
			}(rn || (rn = {}));
			const on = u.a.wrapped(_e.a, "emojiDisplay", Ee.a),
				an = u.a.div("emojiNameDisplay", Ee.a),
				dn = u.a.wrapped(R.a, "imageDisplay", Ee.a),
				cn = e => d.a.createElement(on, null, d.a.createElement(dn, {
					backgroundImage: e.url
				}), d.a.createElement(an, null, e.emojiName)),
				ln = Object(l.c)({
					emojisCustomSize: (e, t) => Object(J.w)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize
				}),
				un = Object(c.b)(ln, (e, t) => {
					let {
						emoji: n,
						isSnoomoji: s,
						subreddit: o
					} = t;
					return {
						saveEmoji: (t, n, s) => e(m.n({
							imageData: s,
							subredditId: o.id,
							emojiName: t,
							settings: n
						})),
						saveEmojiSettings: t => {
							n && e(m.m(n.name, s, t, o.id))
						},
						saveEmojiSuccessToast: () => e(pe.f({
							kind: Oe.b.SuccessCommunityGreen,
							text: r.fbt._("Emoji edits saved!", null, {
								hk: "3luBMA"
							})
						}))
					}
				});
			class mn extends d.a.Component {
				constructor(e) {
					super(e), this.closeModal = () => {
						this.props.toggleModal()
					}, this.clearImageData = () => {
						this.setState({
							imageData: [],
							emojiDraftImage: void 0
						})
					}, this.onEditingImageChange = e => {
						this.setState({
							emojiDraftImage: e
						})
					}, this.handleMultiImageInput = async e => {
						let t;
						const n = this.state.emojiState === rn.SingleEmojiEditState;
						n && this.clearImageData(), t = Array.isArray(e) ? n ? e.slice(0, 1) : e.slice(0, Bt) : [e];
						const s = await Promise.all(t.map(ve.f));
						n ? this.setState({
							imageData: s
						}) : this.setState({
							emojiState: rn.BulkUploadState,
							imageData: s
						})
					}, this.handleModExclusiveToggle = () => this.setState({
						settings: {
							...this.state.settings,
							modFlairOnly: !this.state.settings.modFlairOnly
						}
					}), this.handleTogglePostFlair = () => this.setState({
						settings: {
							...this.state.settings,
							postFlairAllowed: !this.state.settings.postFlairAllowed
						}
					}), this.handleToggleUserFlair = () => this.setState({
						settings: {
							...this.state.settings,
							userFlairAllowed: !this.state.settings.userFlairAllowed
						}
					}), this.returnToAdd = () => {
						this.setState({
							emojiState: rn.AddState
						}), this.clearImageData()
					}, this.sendToggleEvent = (e, t) => this.props.sendEvent(C(e, t)), this.modFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.modFlairOnly !== this.state.settings.modFlairOnly, this.userFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.userFlairAllowed !== this.state.settings.userFlairAllowed, this.postFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.postFlairAllowed !== this.state.settings.postFlairAllowed, this.settingsHaveBeenChanged = () => this.modFlairSettingHasChanged() || this.userFlairSettingHasChanged() || this.postFlairSettingHasChanged(), this.sendTelemetryEvents = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.state.settings;
						this.modFlairSettingHasChanged() && this.sendToggleEvent("mods_only", e), this.userFlairSettingHasChanged() && this.sendToggleEvent("appear_user_flair", t), this.postFlairSettingHasChanged() && this.sendToggleEvent("appear_post_flair", n)
					}, this.saveEmoji = async () => {
						const {
							props: e,
							state: t
						} = this, n = {
							modFlairOnly: t.settings.modFlairOnly,
							postFlairAllowed: t.settings.postFlairAllowed,
							userFlairAllowed: t.settings.userFlairAllowed
						};
						if (this.setIsSaving(!0), e.emoji) {
							if (e.isSnoomoji || e.emoji && !t.emojiDraftImage) e.saveEmojiSettings(n);
							else if (e.emoji && t.emojiDraftImage && t.emojiDraftImage.kind === ve.b.TempUploaded) {
								await e.saveEmoji(e.emoji.name, n, t.emojiDraftImage) && e.saveEmojiSuccessToast()
							}
							this.sendTelemetryEvents()
						}
						this.closeModal(), this.setIsSaving(!1)
					}, this.setIsSaving = e => this.setState({
						isSaving: e
					}), this.state = {
						emojiState: e.emoji ? rn.SingleEmojiEditState : rn.AddState,
						imageData: [],
						isSaving: !1,
						settings: {
							modFlairOnly: !!e.emoji && e.emoji.modFlairOnly,
							postFlairAllowed: !e.emoji || e.emoji.postFlairAllowed,
							userFlairAllowed: !e.emoji || e.emoji.userFlairAllowed
						}
					}
				}
				render() {
					const {
						emoji: e,
						emojisCustomSize: t,
						isSnoomoji: n,
						sendEvent: s,
						subreddit: o
					} = this.props, {
						emojiDraftImage: a,
						emojiState: i,
						imageData: c,
						isSaving: l,
						settings: u
					} = this.state, m = {
						emojiSettings: u,
						stopEditing: this.closeModal,
						subredditId: o.id
					}, p = 2 * (t ? t[0] : Lt), b = 2 * (t ? t[1] : Lt), h = c.length > 0 ? c[0] : void 0, f = h && h.url, g = a && a.url, _ = f || g, v = a && a.kind === ve.b.TempUploaded, O = sn(h || a), x = i !== rn.SingleEmojiEditState || (!this.settingsHaveBeenChanged() && !v || O);
					return d.a.createElement(Kt, null, d.a.createElement(z.i, null, d.a.createElement(Q.a, null, d.a.createElement(z.q, null, e ? r.fbt._("Edit emoji", null, {
						hk: "4awCz5"
					}) : r.fbt._("Add new emojis", null, {
						hk: "2DrJ62"
					})), d.a.createElement(qt, {
						disabled: l,
						onClick: this.closeModal
					}, d.a.createElement(z.b, null)))), (i === rn.AddState || i === rn.SingleEmojiEditState) && d.a.createElement(d.a.Fragment, null, i === rn.AddState && d.a.createElement($t, null, d.a.createElement(en, null, d.a.createElement(Xt, null), r.fbt._("Mod pro tips!", null, {
						hk: "30l9bq"
					})), d.a.createElement(nn, null, d.a.createElement(Zt, null, r.fbt._("Emoji names will use the image file name and will be editable once uploaded", null, {
						hk: "2fvAIQ"
					})), d.a.createElement(Zt, null, r.fbt._("You can upload up to {maxUpload} emojis at once", [r.fbt._param("maxUpload", Bt.toString())], {
						hk: "4aMYoX"
					})))), d.a.createElement(Jt, null, i === rn.SingleEmojiEditState && e && d.a.createElement(cn, {
						emojiName: e.name,
						url: _ || e.url
					}), !n && d.a.createElement(d.a.Fragment, null, d.a.createElement(he.i, null, d.a.createElement(Vt, null, e ? r.fbt._("Image", null, {
						hk: "3fzI70"
					}) : r.fbt._("Images", null, {
						hk: "3SapUk"
					})), e && i === rn.SingleEmojiEditState && h && d.a.createElement(Mt, Dt({}, m, {
						emoji: e,
						onRetryUpload: this.clearImageData,
						pendingImage: h,
						onImageChange: this.onEditingImageChange
					})), (!c.length || v) && !(e && O) && d.a.createElement(be.b, {
						label: r.fbt._("Drag and Drop or Upload Image", null, {
							hk: "3y5WvP"
						}),
						onChange: this.handleMultiImageInput,
						multiple: !0
					}), d.a.createElement(he.b, null, r.fbt._("Max upload dimensions {maxEmojiWidth} x {maxEmojiHeight}px", [r.fbt._param("maxEmojiWidth", Ft.toString()), r.fbt._param("maxEmojiHeight", Ft.toString())], {
						hk: "yal28"
					})), d.a.createElement(he.b, null, r.fbt._("Max file size {MAX_FILE_SIZE}KB", [r.fbt._param("MAX_FILE_SIZE", Ut.toString())], {
						hk: "1t1L0f"
					}))), d.a.createElement(tn, null, r.fbt._("Recommended upload dimensions: {recommendedWidth} x {recommendedHeight}px", [r.fbt._param("recommendedWidth", p.toString()), r.fbt._param("recommendedHeight", b.toString())], {
						hk: "35CqDV"
					}))), d.a.createElement(Gt, null, r.fbt._("Appears in:", null, {
						hk: "3SZP5W"
					})), d.a.createElement(Ht, {
						name: "postFlair",
						onChange: this.handleTogglePostFlair,
						value: u.postFlairAllowed
					}, d.a.createElement(Wt, null, r.fbt._("Post flair", null, {
						hk: "mAzeZ"
					}))), d.a.createElement(Ht, {
						name: "userFlair",
						onChange: this.handleToggleUserFlair,
						value: u.userFlairAllowed
					}, d.a.createElement(Wt, null, r.fbt._("User flair", null, {
						hk: "qVf7x"
					}))), d.a.createElement(Yt, {
						description: "Only appears in post and user flair that are restricted for mod use.",
						on: u.modFlairOnly,
						onToggle: this.handleModExclusiveToggle,
						title: "Mod only"
					})), d.a.createElement(z.g, null, d.a.createElement(Qt, {
						disabled: l,
						onClick: this.closeModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(zt, {
						disabled: x,
						onClick: this.saveEmoji
					}, e ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					})))), i === rn.BulkUploadState && d.a.createElement(St, Dt({}, m, {
						images: c,
						returnToAddState: this.returnToAdd,
						sendEvent: s,
						setIsSaving: this.setIsSaving
					})))
				}
			}
			var pn = Object(V.a)(un(mn));
			const bn = u.a.wrapped(S.a, "alertIcon", P.a),
				hn = u.a.span("appearsTitle", P.a),
				fn = u.a.span("imageTitle", P.a),
				gn = u.a.span("nameTitle", P.a),
				_n = u.a.span("permissionsTitle", P.a),
				vn = u.a.wrapped(E.o, "settingsButton", P.a),
				On = u.a.wrapped(g.a, "titleTooltip", P.a),
				xn = u.a.wrapped(v.a, "topRow", P.a),
				En = Object(l.c)({
					emojis: T.d,
					isConfirmModalOpen: Object(w.b)("EmojiManager--DeleteEmojiConfirmation--Modal"),
					isEmojisEnabled: (e, t) => Object(T.b)(e, t.subreddit.name),
					isEmojiSettingsModalOpen: Object(w.b)("EmojiManager--Settings--Modal"),
					isUploadEmojisModalOpen: Object(w.b)("EmojiManager--UploadEmojis--Modal")
				}),
				yn = Object(c.b)(En, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						deleteEmoji: t => e(m.i(t, n.id)),
						toggleDeleteConfirmationModal: () => e(Object(p.i)("EmojiManager--DeleteEmojiConfirmation--Modal")),
						toggleSettingsModal: () => e(Object(p.i)("EmojiManager--Settings--Modal")),
						toggleUploadEmojisModal: () => e(Object(p.i)("EmojiManager--UploadEmojis--Modal"))
					}
				});
			class jn extends d.a.Component {
				constructor(e) {
					super(e), this.onClickEditEmoji = (e, t) => {
						this.props.toggleUploadEmojisModal(), this.setState({
							emojiToEdit: e,
							isSnoomoji: t
						})
					}, this.onConfirmDelete = () => {
						this.props.deleteEmoji(this.state.emojiNameToDelete), this.setState({
							emojiNameToDelete: ""
						}), this.props.sendEvent(k("delete"))
					}, this.handleRemoveEmoji = e => {
						this.setState({
							emojiNameToDelete: e
						}), this.props.toggleDeleteConfirmationModal()
					}, this.state = {
						emojiNameToDelete: "",
						emojiToEdit: null,
						isSnoomoji: !1
					}
				}
				static getDerivedStateFromProps(e, t) {
					return t.emojiToEdit && !e.isUploadEmojisModalOpen ? {
						emojiToEdit: null,
						isSnoomoji: !1
					} : null
				}
				render() {
					const {
						emojis: e,
						isConfirmModalOpen: t,
						isEmojisEnabled: n,
						isEmojiSettingsModalOpen: o,
						isUploadEmojisModalOpen: i,
						sendEvent: c,
						subreddit: l,
						toggleDeleteConfirmationModal: u,
						toggleSettingsModal: m,
						toggleUploadEmojisModal: p
					} = this.props;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(_.c, null, d.a.createElement(vn, {
						onClick: m
					}, r.fbt._("Emoji settings", null, {
						hk: "2k202A"
					})), d.a.createElement(E.l, {
						onClick: p
					}, r.fbt._("Add emoji", null, {
						hk: "DTe8a"
					}))), d.a.createElement(_.a, null, d.a.createElement(_.b, null, r.fbt._("Emoji management", null, {
						hk: "6xN5s"
					}), d.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010560371`
					})), !n && d.a.createElement(h.a, {
						className: P.a.emojisDisabled,
						color: x.a.quarantine,
						icon: d.a.createElement(bn, null),
						subtitle: r.fbt._("Emojis in flairs will not be displayed, and existing emojis will appear as plain text.", null, {
							hk: "2WaMtH"
						}),
						title: r.fbt._("Emojis have been disabled for this community", null, {
							hk: "7LNIO"
						})
					}), d.a.createElement(xn, null, d.a.createElement(fn, null, r.fbt._("Image", null, {
						hk: "1rlqjH"
					})), d.a.createElement(gn, null, r.fbt._("Name", null, {
						hk: "1ugGFI"
					})), d.a.createElement(hn, null, r.fbt._("Appears in", null, {
						hk: "3K8vjU"
					}), d.a.createElement(On, {
						text: r.fbt._("Set emoji to appear in post flair or user flair", null, {
							hk: "4cg4Se"
						})
					})), d.a.createElement(_n, null, r.fbt._("Settings", null, {
						hk: "2CRrAq"
					}), d.a.createElement(On, {
						text: r.fbt._("Set emoji to only appear in mod-only flair", null, {
							hk: "2yS10f"
						})
					}))), e[l.id] && a()(e[l.id].emojis, e => d.a.createElement(q, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !1,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), e[l.id] && a()(e[l.id].snoomojis, e => d.a.createElement(q, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !0,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), t && d.a.createElement(b.a, {
						toggleModal: u,
						onConfirm: this.onConfirmDelete,
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete emoji?", null, {
							hk: "3VBsS8"
						}),
						modalText: r.fbt._("Do you wish to delete this emoji?", null, {
							hk: "2sPCxc"
						}),
						trackClick: () => {},
						withOverlay: !0
					}), o && d.a.createElement(me, {
						sendEvent: c,
						subreddit: l,
						toggleModal: m,
						withOverlay: !0
					}), i && d.a.createElement(pn, {
						emoji: this.state.emojiToEdit,
						isSnoomoji: this.state.isSnoomoji,
						sendEvent: c,
						subreddit: l,
						toggleModal: p,
						withOverlay: !0
					})))
				}
			}
			t.a = yn(Object(O.c)(jn))
		},
		"./src/reddit/components/ModHub/InfoLink/index.m.less": function(e, t, n) {
			e.exports = {
				linkContainer: "_3-yXs2bljbMxTPT6hDZU1I",
				infoIcon: "_2Eloqzd6Vfz9eGsjyzVfsf"
			}
		},
		"./src/reddit/components/ModHub/InfoLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoLink/index.m.less"),
				l = n.n(c);
			const u = Object(a.a)(i.b),
				m = ["center", "top"],
				p = ["center", "bottom"];
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					return o.a.createElement("a", {
						className: l.a.linkContainer,
						href: this.props.linkUrl,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef,
						target: "_blank",
						rel: "noopener noreferrer"
					}, o.a.createElement(d.a, {
						className: l.a.infoIcon
					}), o.a.createElement(u, {
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: s.fbt._("Learn more", null, {
							hk: "3zoGtq"
						}),
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				iconContainer: "_39qwCVfS_zadCI7gaPX3MI",
				textTooltip: "_1yEjLpHWBPakuE9kTnIp_w"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoTooltip/index.m.less"),
				l = n.n(c);
			const u = Object(o.a)(i.a),
				m = ["center", "bottom"],
				p = ["center", "top"];
			class b extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement("span", {
						className: l.a.iconContainer,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef
					}, r.a.createElement(d.a, null), r.a.createElement(u, {
						className: Object(a.a)(e.className, l.a.textTooltip),
						children: e.children,
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: e.text,
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/ModHubNav/NavItem.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				l = n.n(c);
			const u = e => {
				let {
					className: t
				} = e;
				return o.a.createElement("div", {
					className: Object(a.a)(l.a.newLinkIndicator, t)
				}, s.fbt._("New", null, {
					hk: "BnhHE"
				}))
			};
			t.b = e => e.path ? e.isExternal ? o.a.createElement("a", {
				className: l.a.navLinkStyles,
				href: e.path,
				onClick: e.onClick,
				target: "_blank",
				rel: "noopener noreferrer"
			}, e.label, o.a.createElement(d.a, {
				name: "external_link",
				className: l.a.outboundLinkIcon
			})) : o.a.createElement(i.default, {
				className: Object(a.a)(l.a.navLinkStyles, {
					[l.a.activeLink]: !!e.isActive
				}),
				to: e.path,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})), e.showInboundArrow && o.a.createElement(d.a, {
				name: "right",
				className: l.a.inboundLinkIcon
			})) : o.a.createElement("button", {
				className: l.a.navLinkStyles,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})))
		},
		"./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less": function(e, t, n) {
			e.exports = {
				wikiNavPanel: "KAUs91LhLIPR2bTL1aZRJ",
				contentTree: "_3_qIKXEwRmWcog7k9kGSno",
				footer: "_3FqEpSEBROhNwQ6pW6xmwJ",
				primaryButton: "_3fO0HSLh0kUxdhfv06hiTX",
				pageNavItem: "gCZ0Yr9nZYa9NaCdn8-eS",
				indentLine: "_2qFuXxmElNrzv3E9Qyb5xi",
				itemText: "_8bMrzJrL3U19A5yc6HTgj",
				mActive: "_1gyKwA8_GLuoQ1hu3Apd-w",
				mExists: "_3E5JJL5f6BXoTxqDq40IbB"
			}
		},
		"./src/reddit/components/ModHub/ModHubNav/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1rWejsW3eX4yw72E6Wfmyh",
				titleFontH2: "_10H_HMu7R7ett8pmawqwCS",
				titleFontH3: "_22nuZii7bWeL3c1xoXOl9",
				titleFontH4: "_2UjVJakiyf4d3yQ1sBrOzz",
				titleFontH5: "_22v1odcGzDJaLHik5W5qCz",
				titleFontH6: "_3BdZeq3g8CWhfeqBhIiW7f",
				metadataFont: "BQ88O08B4nIUNd4oLud39",
				flairFont: "_24GksXJ4va-4ZEamEGSlFB",
				labelsFont: "bd2r035T3aLLBkiMZaODQ",
				actionFont: "v0ITosHo9F3Rl2_llDtrc",
				smallButtonFont: "_3Sxxei5IvhyFBFPSQeJemM",
				largeButtonFont: "_-8HW12kqXpCzSoPxOQgrN",
				strongTextFont: "jPwoQR2t4sGD2BGLwCS0o",
				tabFont: "_2TpZx4pScQqA92z2QTYbIk",
				buttonFontXS: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontXs: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontS: "_2geB6McFSdWvuGRz3nyzjb",
				buttonFontM: "_1uuuzIbDmUCEWDPkR9T_dx",
				buttonFontL: "_1AhaF3ULgALw9k8OUmf0pY",
				buttonFontXL: "_2iQE9slD0Zw-wYQx5FCL1j",
				buttonFontXl: "_2iQE9slD0Zw-wYQx5FCL1j",
				bodyFontH1: "_3hxV-zVTwf7J5X6U1gL2PA",
				bodyFontH2: "_1lSzh7ct7vogYQk35ULeJl",
				bodyFontH3: "_2C3DyZAU4ai6HhZtVTe-Bu",
				bodyFontH4: "_2tzV3r0Sow-B7LA2KMLD45",
				bodyFontH5: "_1-ivrwr3LQQJ2_7q7woFBf",
				bodyFontH6: "pJbG4WvyXqhjYGMHv_062",
				bodyFontH6Small: "_2lZmvARU6npWzDSAF2ffm7",
				bodyFont: "gPA4LKC5gx8g56loAEuW2",
				bodyFontSmall: "_2U2PATpiHbmfDjkovIbtF9",
				bodyFontMono: "_1tyVWTRiPy8hBs1o6HBJ_a",
				navContainer: "_2xA0SygQ9V-9Vkdad_4tnh",
				wikiNavContainer: "_3wKmughJWQCbpbTpgwf2R_",
				navContainerExp: "_1HiZS01lfLdV-mZxJbB2r1",
				navSection: "_1hDKgrVgEqwg3ogyzK0xTx",
				sectionHeader: "_1C6NYhYvuXKUDoONxrMR0d",
				iconStyles: "_1lHK5OQSXGaQzgW07E3Fh4",
				inboundLinkIcon: "_1cE0_wpoZtV5YKzwxXgxQ6",
				outboundLinkIcon: "_2Fb1fof3pZ4qO7_ZowwnXG",
				navLinkStyles: "jFCRipwFbBNJ4rl18HMK5",
				activeLink: "_4Gq-jEYAhrOCtha4RZ1JZ",
				breadcrumb: "_2Pw-8XrjTaQdxaxIicJXly",
				breadcrumbButton: "_1ofO-HYNTNyx_FUAEbIMME",
				newLinkIndicator: "_26hxZhi3N_WA1WUC6pQRpa",
				updatedLinkIndicator: "_1oCiY0B1NLkEfFfIfSJIF_"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2QinjfjfDTG6Df4_Tb_eRN",
				iconStyles: "_1MvzgnzkNefTZKkd4A5o1Y",
				arrowLeft: "_1Hul4w6ANujC9NsFF6_j4f"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				i = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				d = n("./src/reddit/components/ModHub/PaginationButtons/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("div", {
				className: c.a.container
			}, e.prevButtonEnabled && r.a.createElement(a.default, {
				to: e.prevTo,
				onClick: e.prevButtonOnClick
			}, r.a.createElement(i.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.arrowLeft)
			})), e.nextButtonEnabled && r.a.createElement(a.default, {
				to: e.nextTo,
				onClick: e.nextButtonOnClick
			}, r.a.createElement(i.a, {
				className: c.a.iconStyles
			})))
		},
		"./src/reddit/components/ModHub/StyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				ContentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				contentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				PageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				pageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				TopBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				topBar: "_2YY5qLRbI5q6_0JQVKiGt_"
			}
		},
		"./src/reddit/components/ModHub/StyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				o = n.n(r);
			const a = s.a.div("ContentContainer", o.a),
				i = s.a.div("PageTitle", o.a),
				d = s.a.div("TopBar", o.a)
		},
		"./src/reddit/components/ModModeBanners/index.m.less": function(e, t, n) {
			e.exports = {
				banner: "_3FJq-cq7boH_EAWZsUPWY0",
				icon: "_1QOFlf2Sv2RU3pPqUKD6UD",
				staticBanner: "_14wV0QXuPq6IJL_pdl8sQs"
			}
		},
		"./src/reddit/components/ModModeFilteredReason/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/ModQueueTrigger/index.ts");
			const r = e => (e => !e.isApproved && !!Object(s.b)(e, s.a.AUTOMOD))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.BAN_EVASION))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.CROWD_CONTROL))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.HATEFUL_CONTENT))(e)
		},
		"./src/reddit/components/ModModeFilteredReason/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(i);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => a.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading filter reason", null, {
				hk: "K3Ipd"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx"
				}
			}, {
				fallback: a.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModModeReports/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = e => (e.numReports || 0) > 0 || !!e.modReportsDismissed && e.modReportsDismissed.length > 0 || !!e.userReportsDismissed && e.userReportsDismissed.length > 0,
				r = e => {
					if (e.numReports && e.numReports > 0) return e.numReports;
					return (e.modReportsDismissed && e.modReportsDismissed.length || 0) + (e.userReportsDismissed && e.userReportsDismissed.length || 0)
				},
				o = e => (e.numReports || 0) > 0
		},
		"./src/reddit/components/ModModeReports/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(i);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => a.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading reports", null, {
				hk: "4gwdQw"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeReports/_ModModeReports.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeReports/_ModModeReports.tsx"
				}
			}, {
				fallback: a.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModToolsFlatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				hideIfVwSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				ApproveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				approveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				DefaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				defaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				CompactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				compactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				ClassicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				classicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				RemoveGroup: "_3LzZxt89CjBbx__WYlCPCh",
				removeGroup: "_3LzZxt89CjBbx__WYlCPCh",
				SpamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				spamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				FlairGroup: "_129dedXMiIcel_grUelwoG",
				flairGroup: "_129dedXMiIcel_grUelwoG",
				HideIfVWLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				hideIfVwLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				ButtonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9",
				buttonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Flair = "FLAIR", e.Spam = "SPAM", e.Remove = "REMOVE", e.Approve = "APPROVE"
				}(s || (s = {}))
		},
		"./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			}));
			var s, r, o, a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/components/ModToolsFlatlist/breakpoints.m.less"),
				l = n.n(c),
				u = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				m = n.n(u);
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.Approve = "ApproveGroup", e.Remove = "RemoveGroup", e.Spam = "SpamGroup", e.Flair = "FlairGroup"
			}(r || (r = {})),
			function(e) {
				e.Classic = "ClassicVariant", e.Compact = "CompactVariant", e.Default = "DefaultVariant"
			}(o || (o = {}));
			const p = {
					[i.a.Approve]: r.Approve,
					[i.a.Remove]: r.Remove,
					[i.a.Spam]: r.Spam,
					[i.a.Flair]: r.Flair
				},
				b = {
					[d.g.Classic]: o.Classic,
					[d.g.Compact]: o.Compact,
					[d.g.Large]: o.Default,
					[d.g.Medium]: o.Default,
					[d.g.Search]: o.Default
				},
				h = e => {
					const t = p[e.flatlistItem],
						n = e.postLayout && b[e.postLayout],
						s = l.a[e.breakpointType],
						r = l.a[t],
						i = n ? l.a[n] : l.a[o.Default];
					return Object(a.a)(s, r, i)
				},
				f = e => {
					const t = e && b[e],
						n = t ? l.a[t] : l.a[o.Default];
					return Object(a.a)(n, m.a.ButtonTextWrapper, l.a.ButtonTextWrapper)
				}
		},
		"./src/reddit/components/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				container: "OccjSdFd6HkHhShRg6DOl",
				tooltip: "_2a9swcTo72vLia4mUm08Fk",
				ButtonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq",
				buttonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				p = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				b = n("./src/reddit/components/ModModeReports/helpers.ts"),
				h = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				f = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				g = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				_ = n("./src/reddit/helpers/trackers/post.ts"),
				v = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				O = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				x = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/reddit/selectors/moderatorPermissions.ts"),
				j = n("./src/reddit/selectors/postFlair.ts"),
				C = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				k = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				I = n("./src/lib/constants/index.ts"),
				S = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				w = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx"),
				T = n("./src/reddit/hooks/useTracking.ts"),
				N = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				P = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				R = n.n(P);
			const A = e => {
					let {
						className: t,
						textClassName: n,
						isOverlay: r,
						iconOnly: i,
						post: d
					} = e;
					const [c, p] = o.a.useState(!1), [b, h] = o.a.useState(!1), g = Object(T.a)(), v = Object(a.d)(), {
						isPrediction: O,
						resolvedOptionId: x,
						totalVoteCount: E
					} = d.pollData || {}, y = () => {
						p(!1), v(Object(l.U)(d.id, !1)), d.isRemoved && d.bannedBy === I.k ? g(Object(_.k)(d.id, "confirm_remove")) : g(Object(_.k)(d.id, "remove"))
					}, j = ((e, t) => e ? t === I.k ? s.fbt._("Confirm removal", null, {
						hk: "1t5tKM"
					}) : s.fbt._("removed", null, {
						hk: "35ZTch"
					}) : s.fbt._("remove", null, {
						hk: "3LWMcS"
					}))(d.isRemoved, d.bannedBy), C = M("Remove", d.id, r), k = () => i && v(Object(u.h)({
						tooltipId: C
					})), P = o.a.useMemo(() => E ? 1 === E ? s.fbt._("Removing this post will cancel the 1 prediction that has already been made.", null, {
						hk: "hVYeT"
					}) : s.fbt._("Removing this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", E.toString())], {
						hk: "47oACN"
					}) : s.fbt._("Removing this post will cancel any predictions that have already been made.", null, {
						hk: "26cLeP"
					}), [E]);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(f.d, {
						className: t,
						textClassName: n,
						id: C,
						text: i ? void 0 : j,
						disabled: d.isRemoved && d.bannedBy !== I.k,
						onMouseEnter: k,
						onMouseLeave: k,
						onClick: () => {
							O ? x ? h(!0) : p(!0) : y()
						}
					}, o.a.createElement(N.a, {
						desc: i ? j : void 0
					}), i && o.a.createElement(m.c, {
						className: R.a.tooltip,
						tooltipId: C,
						text: j
					})), b && o.a.createElement(w.a, {
						title: s.fbt._("This post can't be removed", null, {
							hk: "2GbryD"
						}),
						body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't remove the post.", null, {
							hk: "3wgNhQ"
						}),
						onClose: () => h(!b)
					}), c && o.a.createElement(S.a, {
						withOverlay: !0,
						modalText: P,
						actionText: s.fbt._("Remove", null, {
							hk: "2DXJl4"
						}),
						headerText: s.fbt._("Are you sure?", null, {
							hk: "3CJLRE"
						}),
						onConfirm: y,
						onOverlayClick: () => p(!c),
						toggleModal: () => p(!c)
					}))
				},
				M = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return `ModToolsFlatlist-${e}${t}${n?"inOverlay":""}`
				},
				D = (e, t) => Object(k.b)({
					breakpointType: k.a.HideIfVWSmaller,
					flatlistItem: e,
					postLayout: t
				}),
				L = Object(a.b)(() => Object(i.c)({
					activeModalId: E.a,
					canEditFlair: (e, t) => {
						let {
							post: n
						} = t;
						return Object(j.a)(e, {
							postId: n.id
						})
					},
					moderatorPermissions: (e, t) => Object(y.m)(e, {
						postId: t.post.id
					})
				}), (e, t) => {
					let {
						post: n
					} = t;
					return {
						onApprovePost: () => e(Object(l.s)(n.id)),
						onOpenPostModModeDropdown: t => e(Object(u.h)({
							tooltipId: t
						})),
						onSpamPost: () => e(Object(l.U)(n.id, !0)),
						onFlairPost: t => () => e(Object(c.i)(t))
					}
				});
			t.a = L(e => {
				const {
					canEditFlair: t,
					className: n,
					isOverlay: i,
					layout: c,
					moderatorPermissions: l,
					modModeEnabled: E,
					onApprovePost: y,
					onFlairPost: j,
					onSpamPost: I,
					post: S,
					sendEvent: w,
					showIconsOnly: T
				} = e, N = Object(a.d)(), P = Object(g.a)(l), L = Object(b.b)(S), F = !(!S.approvedBy || !L), U = Object(h.b)(S.id, i), B = P && E && !S.isSponsored, G = t && E, H = ((e, t) => e ? s.fbt._("reapprove", null, {
					hk: "OJvB1"
				}) : t ? s.fbt._("approved", null, {
					hk: "2bWAFI"
				}) : s.fbt._("approve", null, {
					hk: "2DIHcM"
				}))(F, S.approvedBy), W = (e => e ? s.fbt._("spammed", null, {
					hk: "3GPrkZ"
				}) : s.fbt._("spam", null, {
					hk: "3ebJLg"
				}))(S.isSpam), q = M("Approve", S.id, i), V = M("Spam", S.id, i), z = () => T && N(Object(u.h)({
					tooltipId: q
				})), K = () => T && N(Object(u.h)({
					tooltipId: V
				})), Q = i ? void 0 : c;
				return o.a.createElement("div", {
					className: Object(d.a)(R.a.container, n)
				}, B && o.a.createElement(r.Fragment, null, o.a.createElement(f.b, {
					className: D(C.a.Approve, Q),
					key: "approveButton",
					text: T ? void 0 : H,
					textClassName: Object(k.c)(Q),
					disabled: !!S.approvedBy && !L,
					id: q,
					onMouseEnter: z,
					onMouseLeave: z,
					onClick: () => {
						y(), w(Object(_.k)(S.id, "approve"))
					}
				}, o.a.createElement(v.a, {
					desc: T ? H : void 0
				}), T && o.a.createElement(m.c, {
					className: R.a.tooltip,
					tooltipId: q,
					text: H
				})), o.a.createElement(A, {
					className: D(C.a.Remove, Q),
					textClassName: Object(k.c)(Q),
					isOverlay: i,
					iconOnly: T,
					post: S
				}), o.a.createElement(f.d, {
					className: D(C.a.Spam, Q),
					key: "removeSpamButton",
					text: T ? void 0 : W,
					textClassName: Object(k.c)(Q),
					disabled: S.isSpam,
					id: V,
					onMouseEnter: K,
					onMouseLeave: K,
					onClick: () => {
						I(), w(Object(_.k)(S.id, "spam"))
					}
				}, o.a.createElement(O.a, {
					desc: T ? W : void 0
				}), T && o.a.createElement(m.c, {
					className: R.a.tooltip,
					tooltipId: V,
					text: W
				}))), G && o.a.createElement(f.c, {
					className: D(C.a.Flair, Q),
					key: "tagButton",
					onClick: () => {
						j(U)(), w(Object(_.k)(S.id, "post_flair_picker"))
					}
				}, o.a.createElement(x.a, null)), o.a.createElement(p.f, null))
			})
		},
		"./src/reddit/components/ModWelcomeTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				Overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				isOverlayOpen: "_1LKHMvN5rVxTXGRnTa9hrB",
				DropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				dropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				Tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				TooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				tooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				Title: "_1BFO2H2-rybL94nyL7n-e_",
				title: "_1BFO2H2-rybL94nyL7n-e_",
				Description: "_2DnHuFoYoKwYaBvTkLrs0v",
				description: "_2DnHuFoYoKwYaBvTkLrs0v",
				modLink: "_16moQ9CB6asKjB-qTj8Tvf",
				Button: "_2x6OQ6vZfN3PNhM6Eh6FLq",
				button: "_2x6OQ6vZfN3PNhM6Eh6FLq"
			}
		},
		"./src/reddit/components/ModWelcomeTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "MOD_WELCOME_TOOLTIP_ID", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				b = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				h = n("./src/reddit/selectors/platform.ts"),
				f = n("./src/reddit/components/ModWelcomeTooltip/index.m.less"),
				g = n.n(f);
			const _ = Object(l.a)(m.a),
				v = "ModProgressModule--ModWelcomeTooltip";
			t.default = Object(d.a)(e => {
				const t = Object(a.e)(h.d),
					n = v,
					d = Object(a.d)(),
					l = e => {
						e.stopPropagation(), d(Object(c.h)({
							tooltipId: n
						}))
					};
				return Object(r.useEffect)(() => {
					e.isOpen ? setTimeout(() => Object(p.a)(), 500) : setTimeout(() => Object(p.b)(), 500)
				}, [d, e.isOpen]), t ? o.a.createElement(_, {
					className: g.a.Tooltip,
					isOpen: e.isOpen,
					targetPosition: ["left", "top"],
					tooltipPosition: ["right", "top"],
					tooltipId: n,
					componentWrapper: t => o.a.createElement("div", {
						className: Object(i.a)(g.a.Overlay, {
							[g.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}, o.a.createElement("div", {
						className: Object(i.a)(g.a.DropdownPadding, {
							[g.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}), t)
				}, o.a.createElement("div", {
					className: g.a.TooltipContent
				}, o.a.createElement("div", {
					className: g.a.Title
				}, s.fbt._("Welcome to your community, r/{subredditName}!", [s.fbt._param("subredditName", t)], {
					hk: "e3rbC"
				})), o.a.createElement("div", {
					className: g.a.Description
				}, s.fbt._("Well walk you through how to get started here, and you can get more tips and advice through Reddits", null, {
					hk: "lffxe"
				}), " ", o.a.createElement("a", {
					className: g.a.modLink,
					style: {
						color: Object(b.a)(e).linkText
					},
					href: "https://www.reddit.com/r/ModCertification101/",
					rel: "noopener noreferrer",
					target: "_blank"
				}, s.fbt._("Mod Certification Program", null, {
					hk: "1FTpvR"
				})), "."), o.a.createElement(u.t, {
					className: g.a.Button,
					onClick: l
				}, s.fbt._("Let's go", null, {
					hk: "4hWwxv"
				})))) : null
			})
		},
		"./src/reddit/components/ModalStyledComponents/MessageBox.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(a.a)(e => {
					let {
						title: t,
						body: n,
						actionText: r = s.fbt._("OK", null, {
							hk: "1eo6HO"
						}),
						onClose: a
					} = e;
					return o.a.createElement(i.e, null, o.a.createElement(i.i, null, o.a.createElement(c.a, null, o.a.createElement(i.q, null, t), o.a.createElement(d.a, {
						onClick: a
					}, o.a.createElement(i.b, null)))), o.a.createElement(i.l, null, o.a.createElement(i.p, null, n)), o.a.createElement(i.g, null, o.a.createElement(i.u, {
						"data-redditstyle": !0,
						onClick: a
					}, r)))
				}),
				m = e => o.a.createElement(u, l({
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e))
		},
		"./src/reddit/components/ModalStyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				CloseIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				closeIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				ModalBody: "_2R3RlhymCOkPrz9TusvcPq",
				modalBody: "_2R3RlhymCOkPrz9TusvcPq",
				ModalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				modalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				ModalText: "mFTHPdbEAklUs8yhT4Xm7",
				modalText: "mFTHPdbEAklUs8yhT4Xm7",
				ModalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				modalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				ModalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				modalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				ModalMetaText: "_27eskYssCs-urVW1uHI4YI",
				modalMetaText: "_27eskYssCs-urVW1uHI4YI",
				ModalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				modalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				ModalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				modalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				ModalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				modalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				ModalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				modalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				ModalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				modalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				ModalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				modalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				ModalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				modalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				ModalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				modalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				TextArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				textArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				WarningButton: "_17UyTSs2atqnKg9dIq5ERg",
				warningButton: "_17UyTSs2atqnKg9dIq5ERg",
				PrimaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				primaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				CancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				cancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				RemoveButton: "_2ulRgczjI5SWCMgSA1CNLj",
				removeButton: "_2ulRgczjI5SWCMgSA1CNLj",
				ConfirmButton: "JZC61-VzVuaiHdWuRUiSC",
				confirmButton: "JZC61-VzVuaiHdWuRUiSC"
			}
		},
		"./src/reddit/components/ModalStyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "o", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "m", (function() {
				return v
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "q", (function() {
				return C
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "t", (function() {
				return S
			})), n.d(t, "u", (function() {
				return w
			})), n.d(t, "r", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "c", (function() {
				return R
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/lib/lessComponent.tsx"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/controls/Input/ModalInput.tsx"),
				c = n("./src/reddit/icons/svgs/Close/index.tsx"),
				l = n("./src/reddit/components/ModalStyledComponents/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.wrapped(c.a, "CloseIcon", u.a),
				b = r.a.section("ModalBody", u.a),
				h = r.a.section("ModalPostPreview", u.a),
				f = r.a.p("ModalText", u.a),
				g = r.a.div("ModalSmallText", u.a),
				_ = r.a.div("ModalDescriptionText", u.a),
				v = r.a.div("ModalMetaText", u.a),
				O = r.a.label("ModalFormItem", u.a),
				x = r.a.wrapped(d.a, "ModalInput", u.a),
				E = r.a.label("ModalInputLabel", u.a),
				y = r.a.footer("ModalFooter", u.a),
				j = r.a.header("ModalHeader", u.a),
				C = r.a.div("ModalTitle", u.a),
				k = r.a.div("ModalAnnotation", u.a),
				I = r.a.div("ModalMain", u.a),
				S = r.a.textarea("TextArea", u.a),
				w = r.a.wrapped(i.l, "WarningButton", u.a),
				T = r.a.wrapped(i.l, "PrimaryButton", u.a),
				N = r.a.wrapped(i.o, "CancelButton", u.a),
				P = r.a.wrapped(i.r, "RemoveButton", u.a),
				R = e => {
					let {
						className: t,
						...n
					} = e;
					return a.a.createElement(i.t, m({
						kind: i.b.Button,
						priority: i.c.Primary,
						className: Object(s.a)(u.a.ConfirmButton, t)
					}, n))
				}
		},
		"./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_3aaWXDPwVg-rhD0DvWeyIg",
				titleFontH2: "_3RrF8F_t0SfGrUYfrMwbPy",
				titleFontH3: "_36oA-I2A9k4cBPYs3kAlux",
				titleFontH4: "_1neT2k10waDvSZYxkd9bk8",
				titleFontH5: "_3oeJNjYGx_aLE6l4o6Jhcr",
				titleFontH6: "_2CsvILRAMCNlhcGlq7eAZF",
				metadataFont: "_2odnjtlqO4r8tdO5H9fwLW",
				flairFont: "k5rlVaQw1fQ4nW2C-cK8H",
				labelsFont: "_20rPk9VJ1JfA7IuzEuFf25",
				actionFont: "_1YoZx3mOGBx4yxG_aQD3dq",
				smallButtonFont: "_3eWaIQ1VVjPR_5vUm4bU74",
				largeButtonFont: "rBsu7j_nL4EsDsP9nsEx4",
				strongTextFont: "_1efJllSuh9p67WrocQmmWR",
				tabFont: "_3WOHej9q3BPonP3nmtGWrh",
				buttonFontXS: "_1MX_r3WunmJuovmTcVFbK2",
				buttonFontXs: "_1MX_r3WunmJuovmTcVFbK2",
				buttonFontS: "_2KcOk-_dCdoa6LYzk-AP_9",
				buttonFontM: "BRJSsisfnzhNDIzzkZ0iD",
				buttonFontL: "WtDuFUG7c1VkpSlmXgZux",
				buttonFontXL: "_1K99pLAcTgTp5K71-CnCYk",
				buttonFontXl: "_1K99pLAcTgTp5K71-CnCYk",
				bodyFontH1: "_1m_v2MMDlDugLUDKRkPnPP",
				bodyFontH2: "uhtqruCImDdb6YMrply29",
				bodyFontH3: "oI7G9eYumAFmPy69WN078",
				bodyFontH4: "_3NN_fRjCSJGnly_ejXsz8m",
				bodyFontH5: "_1lK4S52h6Glz4-OysTx6SF",
				bodyFontH6: "BarCcSBvd2WaM4vhBY1_R",
				bodyFontH6Small: "BxuTxX9RmChqU7mme4ODG",
				bodyFont: "RIX67Ch_ZE4SYGnQlkPWs",
				bodyFontSmall: "_1_FK7Ynr3eStBK-2Nbutbg",
				bodyFontMono: "_1mpZy47SxXNRDTLTEdCUmV",
				dropdownRow: "_3p4amLmnNdNRS9NcI_TnQm",
				filter: "_1LUEYTVtU-JweRiTGrVNn6",
				container: "_1GH53do8Ql17wdDC_i_NDf",
				containerText: "KiwwtIazAS77Aa_w3AdBE",
				listContainer: "FyBjuKMom1xYgTT7w5Dg1",
				selector: "_3fe64brTItATv48WIPt-Af"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "a0XACZdyt4BIb8ijZeyYs",
				thumbnail: "_3Gr4zaxYVxnSJsswDS3DrH",
				blur: "_30-TA_nC39RinVaoLGAM80"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less": function(e, t, n) {
			e.exports = {
				body: "_12PFG6h73jYoYE1nkFmj7W",
				bodyExpanded: "_2rmMZ9SgqIsu5N4npqtHGO",
				seeMore: "_26bn7M6DKZgOME8sYRiK6_"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less": function(e, t, n) {
			e.exports = {
				noPreview: "yTkGz6Kz44pP8NXnyVDNL"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less": function(e, t, n) {
			e.exports = {
				previewInfo: "sSchFsTKqgMqRa_PNJb4a",
				previewInfoItem: "_1lSOacsboVGtIvlrcO3-W1"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3HBJtoQ8F-vJNqmtmc9gol",
				contentWrapperComment: "_3_Nih9SNk9GvWVAs0sn5FM",
				title: "_12exdWB71qX-NBs6EzOu9s",
				authorLink: "_6znEPG6Fc4vtLPviu5sZi"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1o6EpuTR_pbdKk4biOJFOD",
				titleFontH2: "_2scGKAM0oQo5UQ0sAeTYcJ",
				titleFontH3: "nZ8gtQ7wSBH1Ei4U88QyH",
				titleFontH4: "cWWmG8ptxDy68exgcmkxK",
				titleFontH5: "_2ltEgDFK7lEC55mqYn2t1k",
				titleFontH6: "_1wRduyAnZyUXSUvy0rPJ7E",
				metadataFont: "_3iKB3xohr95CjhTE-YrXL4",
				flairFont: "_2tIFOrubLwHvQfSpZ7MBvr",
				labelsFont: "_1Qc6zGFV60DgXsfeg4iK1-",
				actionFont: "bD7YA5ocXtmwPNG0x7gqi",
				smallButtonFont: "wa3Y6CP3s2WY-9hiMRcK6",
				largeButtonFont: "_1Td1TQRNZA20xRbI-LLHsA",
				strongTextFont: "_2bBsKMYboYeah9nlKp4p8e",
				tabFont: "_3Bdl5CdTghtfz5X9Qkn7y0",
				buttonFontXS: "_2hkAgq5O_JUGmz41U0fhSZ",
				buttonFontXs: "_2hkAgq5O_JUGmz41U0fhSZ",
				buttonFontS: "zi9zhcyy9sg1XQb4uP15B",
				buttonFontM: "_2V_SS1DAOgvZNAM9mW40qn",
				buttonFontL: "_3yj5sHGC15tSX0YBraNh9S",
				buttonFontXL: "_2rPaWVGnRh6kEv7M1PJXWa",
				buttonFontXl: "_2rPaWVGnRh6kEv7M1PJXWa",
				bodyFontH1: "_2b6RUiVz7aEMUoaiEalXki",
				bodyFontH2: "_1gD38a1FX6kmxcFvUyP8bB",
				bodyFontH3: "_20D34o21pcOy-JSvp0fq42",
				bodyFontH4: "_368KGbv676rMnmb_kPY7-A",
				bodyFontH5: "_2o6Gp_6yxl-T5p9MHsV3hI",
				bodyFontH6: "_2jp4S3tPdfLXU3FVoOvCWi",
				bodyFontH6Small: "_1OIs3KOCi4nPYoXgyoYWwD",
				bodyFont: "O3aukKYU-BhYFQQgCIAcN",
				bodyFontSmall: "_10AKt1uw6lDYoTkaQ2Egu-",
				bodyFontMono: "_3tQKpxkireZBsmkNyZ5-0J",
				row: "_3sZTiywtJTK5dskqy0h2G2",
				modNameCell: "_1hV1AUW4J0YvMuEK7-Ph1H",
				usernameLink: "_25VIbQ9CpcAT2Uys4A2mFb",
				actionLink: "_2yXBXFFI2XxJRqd89Zwd25",
				createdAtTooltip: "zMBbz2oHRB9_15CBkQ3P4",
				container: "_3jmSP5NpjJgNS7rO9dBogO",
				detailsContainer: "_3pusa5HaB8VO3ODi63vjLl",
				detailsContent: "piNOo-es-o0F7rcLiUu0N",
				detailsType: "_3P62Ird8EqkkVbqN0bv1tU",
				icon: "VzgXNIgPGoNVtsv9-uwYE",
				iconWrapper: "_3cDZ1nhaOv-edC1Ixznjgd",
				negativeTreatment: "XqM6DP9JAGpvwgodvCcuI",
				positiveTreatment: "Ob5o1Q3oVSaizQinm6DD",
				tooltip: "_33OjvBwqb5PPwalXFSmAoy",
				takedownContentPreviewCell: "_1KwIUVKOHu_rA2x5r1tUU5",
				takedownContentPreviewWrapper: "_2poUGYxpTc65DM1BGLyGcf"
			}
		},
		"./src/reddit/components/ModerationLog/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_2OYuAlGNOY6MlJjEC6nWEY",
				titleFontH2: "_2cz1b71RqIGBP0q1sEpoc1",
				titleFontH3: "pNuW5Xi4qPFjDgkhE2utU",
				titleFontH4: "HnjsgzUiJm7Rz4yf-QTnU",
				titleFontH5: "_32jYSRMv-UqDvlwAZ9yI4P",
				titleFontH6: "WyhSydN2c9D7w_ikI_LsS",
				metadataFont: "klmtj4Euuox2ljWXOzJqz",
				flairFont: "_1XFZbbYMt1bMVk_65YaTug",
				labelsFont: "_2lbFHk9fPHfy-Pj2cQ56ef",
				actionFont: "_250q84vRQ0qeydB79AJun",
				smallButtonFont: "_3QKadDpX2GixU1usvLUiww",
				largeButtonFont: "_24SnRKi2v2z3Q8DfWx8Cfd",
				strongTextFont: "_1bRU6ybRMZMA-zL-dR_BFc",
				tabFont: "_1y1SLpqv4ViOdLE8d7R03R",
				buttonFontXS: "_3WZjqmvG0dFKc8UjITKDDM",
				buttonFontXs: "_3WZjqmvG0dFKc8UjITKDDM",
				buttonFontS: "_2wD06G9nLrctZ6G6-fnvzn",
				buttonFontM: "f89wHQzBr1xXirRhM2r3L",
				buttonFontL: "_2B8vK6cxvYeJYneLcXU7pS",
				buttonFontXL: "_2wEcZ9dZ6skPqfnohnMjY8",
				buttonFontXl: "_2wEcZ9dZ6skPqfnohnMjY8",
				bodyFontH1: "_2qrAJcHH1W18XK6K_iZjmY",
				bodyFontH2: "_2yInLfhO3hB7n5aflEa_Y5",
				bodyFontH3: "_31VlGQEcOO_KNq8afFO4lZ",
				bodyFontH4: "_13MU9oPUeX9-FTZJw6fEdd",
				bodyFontH5: "_3h1ag_p5AVxzseMoTk9Oee",
				bodyFontH6: "_2GA-IlakdRmzOgQVFN2Q_F",
				bodyFontH6Small: "_19LZGpX04-M-lUtj-duZpb",
				bodyFont: "_3W9ZZjex4uhC0x4j0tXUE8",
				bodyFontSmall: "_2wYhe0C_P9ON8nur1uwzBd",
				bodyFontMono: "Ygu6NDZ2VS1jqJxKuuJ67",
				contentContainer: "PLQrC-Lzmu2AHBmciLxW5",
				table: "_27_l-nXesULxjvqLhpd6Ie",
				actionNameColHeader: "_3pOXEjq1uyvW71Pp3gS7yv",
				hiddenContentPreviewColumn: "QUUF5WYqgf5deYjxoorkx",
				icon: "_2iiHYO0HlG5gGeXyf7S3_q",
				iconContainer: "_3leJW5B-x65UTDfhDAblD_",
				title: "_2pFg2GOWUWlkKFlSaV-iFq",
				tooltip: "jkeAqS2MNV7nCHZkp4vi9",
				actionTooltip: "p12QqrsFSXUXQXCVTreZ5",
				actionTooltipDescription: "_2SZhKngNXxQ-MnrDr17Fm-",
				allIconsContainer: "_2zekEhqxlIqb4STkFCskIT",
				detailTooltip: "_20tDXbrpUnXW12ZXmRZdKa",
				bottomBarRow: "_28pYv3DHnyqXo6lJwzAOcG"
			}
		},
		"./src/reddit/components/ModerationLog/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/actions/moderationLog/constants.ts");
			const b = Object(c.a)(p.a);
			var h = n("./node_modules/react-router-redux/es/index.js"),
				f = n("./src/higherOrderComponents/asTooltip.tsx"),
				g = n("./src/reddit/actions/tooltip.ts"),
				_ = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/constants/keycodes.ts")),
				v = n("./src/redditGQL/types.ts");
			const O = ["Anti-Evil Operations", "Reddit Legal"];
			var x;
			! function(e) {
				e.ACTION = "action", e.MODERATOR = "moderator"
			}(x || (x = {}));
			const E = {
					ALL_ACTIONS: () => r.fbt._("All actions", null, {
						hk: "3sHzD4"
					}),
					ACCEPT_MODERATOR_INVITE: () => r.fbt._("Accept moderator invite", null, {
						hk: "3WJot2"
					}),
					ADD_COMMUNITY_TOPICS: () => r.fbt._("Add community topics", null, {
						hk: "4xgglk"
					}),
					ADD_CONTRIBUTOR: () => r.fbt._("Add contributor", null, {
						hk: "444ZK"
					}),
					ADD_MODERATOR: () => r.fbt._("Add moderator", null, {
						hk: "4rRghF"
					}),
					ADD_NOTE: () => r.fbt._("Add note", null, {
						hk: "2UjBm"
					}),
					ADD_REMOVAL_REASON: () => r.fbt._("Add removal reason", null, {
						hk: "jCC35"
					}),
					ADJUST_POST_CROWD_CONTROL_LEVEL: () => r.fbt._("Adjust post crowd control level", null, {
						hk: "Eqwnv"
					}),
					ENABLE_POST_CROWD_CONTROL_FILTER: () => r.fbt._("Enable post crowd control filter", null, {
						hk: "1uzJGq"
					}),
					DISABLE_POST_CROWD_CONTROL_FILTER: () => r.fbt._("Disable post crowd control filter", null, {
						hk: "UrQCB"
					}),
					APPROVE_COMMENT: () => r.fbt._("Approve comment", null, {
						hk: "1gvHWC"
					}),
					APPROVE_LINK: () => r.fbt._("Approve link", null, {
						hk: "2LqFt4"
					}),
					BAN_USER: () => r.fbt._("Ban user", null, {
						hk: "4DmPqi"
					}),
					COLLECTIONS: () => r.fbt._("Collections", null, {
						hk: "3a39Wa"
					}),
					COMMUNITY_STYLING: () => r.fbt._("Community styling", null, {
						hk: "386ps9"
					}),
					COMMUNITY_WIDGETS: () => r.fbt._("Community widgets", null, {
						hk: "4ml45n"
					}),
					CREATE_AWARD: () => r.fbt._("Create award", null, {
						hk: "bWa9w"
					}),
					CREATE_REMOVAL_REASON: () => r.fbt._("Create removal reason", null, {
						hk: "i1LIy"
					}),
					CREATE_RULE: () => r.fbt._("Create rule", null, {
						hk: "28uE69"
					}),
					CREATE_SCHEDULED_POST: () => r.fbt._("Create scheduled post", null, {
						hk: "mVbI1"
					}),
					DELETE_AWARD: () => r.fbt._("Delete award", null, {
						hk: "3xYaZ7"
					}),
					DELETE_REMOVAL_REASON: () => r.fbt._("Delete removal reason", null, {
						hk: "3FdYhk"
					}),
					DELETE_RULE: () => r.fbt._("Delete rule", null, {
						hk: "2lWdRL"
					}),
					DELETE_SCHEDULED_POST: () => r.fbt._("Delete scheduled post", null, {
						hk: "MhwRy"
					}),
					DELETE_OVERRIDDEN_CLASSIFICATION: () => r.fbt._("Delete overridden classification", null, {
						hk: "3hPfDT"
					}),
					DELETE_NOTE: () => r.fbt._("Delete note", null, {
						hk: "1P0prb"
					}),
					DISABLE_AWARD: () => r.fbt._("Disable award", null, {
						hk: "2yFBt7"
					}),
					DISTINGUISH: () => r.fbt._("Distinguish", null, {
						hk: "3cWniK"
					}),
					EDIT_FLAIR: () => r.fbt._("Edit flair", null, {
						hk: "mD0CV"
					}),
					EDIT_POST_REQUIREMENTS: () => r.fbt._("Edit post requirements", null, {
						hk: "1SLqNE"
					}),
					EDIT_RULE: () => r.fbt._("Edit rule", null, {
						hk: "2T4TJx"
					}),
					EDIT_SCHEDULED_POST: () => r.fbt._("Edit scheduled post", null, {
						hk: "1XCmsI"
					}),
					EDIT_SETTINGS: () => r.fbt._("Edit settings", null, {
						hk: "3o8q46"
					}),
					ENABLE_AWARD: () => r.fbt._("Enable award", null, {
						hk: "3zYir4"
					}),
					HIDDEN_AWARD: () => r.fbt._("Hide award", null, {
						hk: "31lRN8"
					}),
					EVENTS: () => r.fbt._("Events", null, {
						hk: "4Bq9wt"
					}),
					IGNORE_REPORTS: () => r.fbt._("Ignore reports", null, {
						hk: "1defIy"
					}),
					INVITE_MODERATOR: () => r.fbt._("Invite moderator", null, {
						hk: "1DbgL5"
					}),
					INVITE_SUBSCRIBER: () => r.fbt._("Invite subscriber", null, {
						hk: "4yEMNb"
					}),
					LOCK: () => r.fbt._("Lock", null, {
						hk: "39hTi5"
					}),
					MARK_NSFW: () => r.fbt._("Mark nsfw", null, {
						hk: "3bo45o"
					}),
					MARK_ORIGINAL_CONTENT: () => r.fbt._("Mark original content", null, {
						hk: "SadHO"
					}),
					MOD_AWARD_GIVEN: () => r.fbt._("Mod award given by moderators", null, {
						hk: "35cQgR"
					}),
					MODMAIL_ENROLLMENT: () => r.fbt._("Modmail enrollment", null, {
						hk: "4ee1XK"
					}),
					MUTE_USER: () => r.fbt._("Mute user", null, {
						hk: "3kPYe4"
					}),
					OVERRIDE_CLASSIFICATION: () => r.fbt._("Override classification", null, {
						hk: "2VPY6n"
					}),
					REMOVE_COMMENT: () => r.fbt._("Remove comment", null, {
						hk: "vEI4S"
					}),
					REMOVE_COMMUNITY_TOPICS: () => r.fbt._("Remove community topics", null, {
						hk: "1tLjxQ"
					}),
					REMOVE_CONTRIBUTOR: () => r.fbt._("Remove contributor", null, {
						hk: "4FMLz6"
					}),
					REMOVE_LINK: () => r.fbt._("Remove link", null, {
						hk: "tmjch"
					}),
					REMOVE_MODERATOR: () => r.fbt._("Remove moderator", null, {
						hk: "1FHVTB"
					}),
					REMOVE_WIKI_CONTRIBUTOR: () => r.fbt._("Remove wiki contributor", null, {
						hk: "1PcCja"
					}),
					REORDER_MODERATORS: () => r.fbt._("Reorder moderators", null, {
						hk: "3Csxj8"
					}),
					REORDER_RULES: () => r.fbt._("Reorder rules", null, {
						hk: "306Bqx"
					}),
					SET_CONTEST_MODE: () => r.fbt._("Set contest mode", null, {
						hk: "1pERnU"
					}),
					SET_PERMISSIONS: () => r.fbt._("Set permissions", null, {
						hk: "3UzkKU"
					}),
					SET_SUGGESTEDSORT: () => r.fbt._("Set suggested sort", null, {
						hk: "208T6K"
					}),
					SHOW_COMMENT: () => r.fbt._("Show comment", null, {
						hk: "n5M3i"
					}),
					SNOOZE_REPORTS: () => r.fbt._("Snooze reports", null, {
						hk: "3gOkDV"
					}),
					SPAM_COMMENT: () => r.fbt._("Spam comment", null, {
						hk: "2ROyTD"
					}),
					SPAM_LINK: () => r.fbt._("Spam link", null, {
						hk: "2G5xg3"
					}),
					SPOILER: () => r.fbt._("Spoiler", null, {
						hk: "2nfv1a"
					}),
					STICKY: () => r.fbt._("Sticky", null, {
						hk: "1W6JrJ"
					}),
					SUBMIT_CONTENT_RATING_SURVEY: () => r.fbt._("Submit content rating survey", null, {
						hk: "1F1ead"
					}),
					SUBMIT_SCHEDULED_POST: () => r.fbt._("Submit scheduled post", null, {
						hk: "1i2VUH"
					}),
					UNBAN_USER: () => r.fbt._("Unban user", null, {
						hk: "4m2iNP"
					}),
					UNIGNORE_REPORTS: () => r.fbt._("Unignore reports", null, {
						hk: "1wfp99"
					}),
					UNINVITE_MODERATOR: () => r.fbt._("Uninvite moderator", null, {
						hk: "3E6UkD"
					}),
					UNLOCK: () => r.fbt._("Unlock", null, {
						hk: "2BHnOC"
					}),
					UNMUTE_USER: () => r.fbt._("Unmute user", null, {
						hk: "25tct2"
					}),
					UNSET_CONTEST_MODE: () => r.fbt._("Unset contest mode", null, {
						hk: "AxsDk"
					}),
					UNSNOOZE_REPORTS: () => r.fbt._("Unsnooze reports", null, {
						hk: "4nlwcg"
					}),
					UNSPOILER: () => r.fbt._("Unspoiler", null, {
						hk: "2gE1K1"
					}),
					UNSTICKY: () => r.fbt._("Unsticky", null, {
						hk: "U5tvd"
					}),
					UPDATE_REMOVAL_REASON: () => r.fbt._("Update removal reason", null, {
						hk: "aDPHp"
					}),
					WIKI_BANNED: () => r.fbt._("Wiki banned", null, {
						hk: "1nk4H7"
					}),
					WIKI_CONTRIBUTOR: () => r.fbt._("Wiki contributor", null, {
						hk: "1W6zn3"
					}),
					WIKI_PAGE_LISTED: () => r.fbt._("Wiki page listed", null, {
						hk: "4aghdO"
					}),
					WIKI_PERM_LEVEL: () => r.fbt._("Wiki perm level", null, {
						hk: "4waHE"
					}),
					WIKI_REVISE: () => r.fbt._("Wiki revise", null, {
						hk: "3FZuIJ"
					}),
					WIKI_UNBANNED: () => r.fbt._("Wiki unbanned", null, {
						hk: "1fAtKd"
					})
				},
				y = {
					added_event_times: () => r.fbt._("added event times to post", null, {
						hk: "1TpgVq"
					}),
					added_flair_styling: () => r.fbt._("added flair styling", null, {
						hk: "zQ6Tv"
					}),
					added_styling: () => r.fbt._("modified community styling", null, {
						hk: "xSJ7B"
					}),
					added_to_collection: () => r.fbt._("added post to collection", null, {
						hk: "3V4fk0"
					}),
					added_widget: () => r.fbt._("added widget", null, {
						hk: "1eVJg6"
					}),
					allow_discovery: () => r.fbt._("toggle allow in search/onboarding/discovery", null, {
						hk: "3on6Qf"
					}),
					allow_top: () => r.fbt._("toggle allow in default/trending lists", null, {
						hk: "DikzW"
					}),
					collapse_deleted_comments: () => r.fbt._("toggle collapse deleted/removed comments", null, {
						hk: "22QPzD"
					}),
					comment_score_hide_mins: () => r.fbt._("comment score hide period", null, {
						hk: "21jsup"
					}),
					confirm_ham: () => r.fbt._("approved", null, {
						hk: "3xh84x"
					}),
					confirm_spam: () => r.fbt._("confirm spam", null, {
						hk: "2yAos0"
					}),
					created_collection: () => r.fbt._("created collection", null, {
						hk: "3vtmUM"
					}),
					css_on_cname: () => r.fbt._("toggle custom css from cname", null, {
						hk: "LTlcB"
					}),
					del_banner: () => r.fbt._("delete banner image", null, {
						hk: "2HRlu"
					}),
					del_header: () => r.fbt._("delete header image", null, {
						hk: "2k08m2"
					}),
					del_icon: () => r.fbt._("delete icon image", null, {
						hk: "43ObSQ"
					}),
					del_image: () => r.fbt._("delete image", null, {
						hk: "4ztzG0"
					}),
					deleted_collection: () => r.fbt._("deleted collection", null, {
						hk: "1T8FDF"
					}),
					description: () => r.fbt._("sidebar description", null, {
						hk: "3gBQBx"
					}),
					domain: () => r.fbt._("domain", null, {
						hk: "37Eg7w"
					}),
					edit_post_requirements: () => r.fbt._("edited post requirements", null, {
						hk: "CoMF6"
					}),
					edited_collection_description: () => r.fbt._("edited collection description", null, {
						hk: "ViGod"
					}),
					edited_collection_display_layout: () => r.fbt._("edited collection display layout", null, {
						hk: "xGExq"
					}),
					edited_collection_title: () => r.fbt._("edited collection title", null, {
						hk: "2x6aKQ"
					}),
					edited_event_body: () => r.fbt._("edited event post body", null, {
						hk: "2uwjvL"
					}),
					edited_event_times: () => r.fbt._("edited event post times", null, {
						hk: "3HNoa4"
					}),
					edited_event_title: () => r.fbt._("edited event post title", null, {
						hk: "4itZHA"
					}),
					edited_widget: () => r.fbt._("edited widget", null, {
						hk: "4eaNe6"
					}),
					enable_award: () => r.fbt._("enabled award", null, {
						hk: "3Ehki9"
					}),
					exclude_banned_modqueue: () => r.fbt._("toggle exclude banned users posts from modqueue", null, {
						hk: "j41F1"
					}),
					flair_clear_template: () => r.fbt._("clear flair template", null, {
						hk: "1IMRYi"
					}),
					flair_csv: () => r.fbt._("edit flair by csv", null, {
						hk: "480ZDT"
					}),
					flair_delete_template: () => r.fbt._("delete flair template", null, {
						hk: "bJ8f2"
					}),
					flair_add: () => r.fbt._("add flair", null, {
						hk: "281rsb"
					}),
					flair_delete: () => r.fbt._("delete flair", null, {
						hk: "2UkqAp"
					}),
					flair_edit: () => r.fbt._("edit flair", null, {
						hk: "3oxZYq"
					}),
					flair_enabled: () => r.fbt._("toggle flair enabled", null, {
						hk: "9WUzt"
					}),
					flair_position: () => r.fbt._("toggle user flair position", null, {
						hk: "4cwkk5"
					}),
					flair_self_enabled: () => r.fbt._("toggle user assigned flair enabled", null, {
						hk: "4q13ZR"
					}),
					flair_template: () => r.fbt._("add/edit flair templates", null, {
						hk: "NSSHD"
					}),
					free_form_reports: () => r.fbt._("toggle allow free form reports by users", null, {
						hk: "3MBfJn"
					}),
					header_title: () => r.fbt._("header title", null, {
						hk: "40Y0QO"
					}),
					ignore_reports: () => r.fbt._("ignore reports", null, {
						hk: "h7fov"
					}),
					lang: () => r.fbt._("language", null, {
						hk: "2xhrR8"
					}),
					link_flair_position: () => r.fbt._("toggle link flair position", null, {
						hk: "3j33wQ"
					}),
					link_flair_self_enabled: () => r.fbt._("toggle submitter assigned link flair enabled", null, {
						hk: "43EykN"
					}),
					link_type: () => r.fbt._("link type", null, {
						hk: "2FuNM"
					}),
					over_18: () => r.fbt._("toggle viewers must be over 18", null, {
						hk: "PRgas"
					}),
					permanent: () => r.fbt._("permanent ban", null, {
						hk: "3MeL5T"
					}),
					permission_moderator_invite: () => r.fbt._("set permissions on moderator invitation", null, {
						hk: "hA7I9"
					}),
					permission_moderator: () => r.fbt._("set permissions on moderator", null, {
						hk: "1yq3O2"
					}),
					public_description: () => r.fbt._("description", null, {
						hk: "JizZj"
					}),
					public_traffic: () => r.fbt._("toggle public traffic stats page", null, {
						hk: "qIXty"
					}),
					remove_self: () => r.fbt._("removed self", null, {
						hk: "I5wgr"
					}),
					remove: () => r.fbt._("remove", null, {
						hk: "mAXhe"
					}),
					removed_from_collection: () => r.fbt._("removed post from collection", null, {
						hk: "2dwuxr"
					}),
					removed_styling: () => r.fbt._("removed community styling", null, {
						hk: "1p7Io9"
					}),
					removed_widget: () => r.fbt._("removed widget", null, {
						hk: "43WUko"
					}),
					show_cname_sidebar: () => r.fbt._("toggle show sidebar from cname", null, {
						hk: "4nlv2A"
					}),
					show_media: () => r.fbt._("toggle show thumbnail images of content", null, {
						hk: "2XmVTJ"
					}),
					spam: () => r.fbt._("spam", null, {
						hk: "3usg93"
					}),
					stylesheet: () => r.fbt._("stylesheet", null, {
						hk: "1TOdUF"
					}),
					submit_link_label: () => r.fbt._("submit link button label", null, {
						hk: "4BdL19"
					}),
					submit_text_label: () => r.fbt._("submit text post button label", null, {
						hk: "4wc8qi"
					}),
					title: () => r.fbt._("title", null, {
						hk: "3tlhiX"
					}),
					type: () => r.fbt._("type", null, {
						hk: "14BQua"
					}),
					unspam: () => r.fbt._("unspam", null, {
						hk: "3SxHQ4"
					}),
					upload_image_banner: () => r.fbt._("upload image banner", null, {
						hk: "1ocFEe"
					}),
					upload_image_header: () => r.fbt._("upload image header", null, {
						hk: "3J6pke"
					}),
					upload_image_icon: () => r.fbt._("upload image icon", null, {
						hk: "4jr6Eg"
					}),
					upload_image: () => r.fbt._("upload image", null, {
						hk: "2KN9ig"
					}),
					copyright_removal: () => r.fbt._("copyright removal", null, {
						hk: "9vN6G"
					}),
					copyright_restoration: () => r.fbt._("copyright restoration", null, {
						hk: "35qFx5"
					})
				};
			var j, C;
			! function(e) {
				e.AWARD = "Award", e.COMMENT = "Comment", e.FLAIR = "Flair", e.MULTIPLE = "Multiple", e.POST = "Post", e.REDDITOR = "Redditor", e.SETTINGS = "Settings", e.WIKI = "Wiki", e.COLLECTION = "Collection", e.EVENT = "Event", e.NOTE = "Note"
			}(j || (j = {})),
			function(e) {
				e.NONE = "none", e.POSITIVE = "positive", e.NEGATIVE = "negative"
			}(C || (C = {}));
			const k = {
				[v.f.Rule_1]: () => r.fbt._("Sitewide Rule 1", null, {
					hk: "3jk6cs"
				}),
				[v.f.Rule_2]: () => r.fbt._("Sitewide Rule 2", null, {
					hk: "4xT4lX"
				}),
				[v.f.Rule_3]: () => r.fbt._("Sitewide Rule 3", null, {
					hk: "3BFdeS"
				}),
				[v.f.Rule_4]: () => r.fbt._("Sitewide Rule 4", null, {
					hk: "4COU2Q"
				}),
				[v.f.Rule_5]: () => r.fbt._("Sitewide Rule 5", null, {
					hk: "QU0F5"
				}),
				[v.f.Rule_6]: () => r.fbt._("Sitewide Rule 6", null, {
					hk: "45NxT7"
				}),
				[v.f.Rule_7]: () => r.fbt._("Sitewide Rule 7", null, {
					hk: "1uFtlD"
				}),
				[v.f.Rule_8]: () => r.fbt._("Sitewide Rule 8", null, {
					hk: "4Gj2wR"
				}),
				[v.f.Dmca]: () => r.fbt._("Copyright Violation", null, {
					hk: "4ekSIy"
				}),
				[v.f.Unknown]: () => r.fbt._("Sitewide Rule", null, {
					hk: "16haBr"
				})
			};
			var I = n("./src/reddit/controls/InternalLink/index.tsx"),
				S = n("./src/lib/addQueryParams/index.ts"),
				w = n("./src/lib/stripQueryParams/index.ts");
			const T = e => {
				const t = e.action && "ALL_ACTIONS" !== e.action ? e.action : null,
					n = e.moderator || null,
					s = e.endCursor || null,
					r = e.startCursor || null;
				return Object(S.a)(Object(w.a)(e.currentPageUrl), {
					action: t,
					moderator: n,
					after: s,
					before: r
				})
			};
			var N = n("./src/reddit/selectors/telemetry.ts");
			const P = e => ({
					subreddit: N.hb(e),
					userSubreddit: N.rb(e)
				}),
				R = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_filter_dropdown",
					...P(e)
				}),
				A = () => e => ({
					source: "mod_filter_dropdown",
					action: "click",
					noun: "moderator",
					...P(e)
				}),
				M = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_action_dropdown",
					...P(e)
				}),
				D = e => t => ({
					source: "mod_action_dropdown",
					action: "click",
					noun: e.toLowerCase(),
					...P(t)
				});
			var L = n("./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less"),
				F = n.n(L);
			class U extends a.a.Component {
				constructor(e) {
					super(e), this.buildModLogUrlForAction = e => {
						const {
							currentPageUrl: t,
							moderator: n
						} = this.props;
						return T({
							currentPageUrl: t,
							moderator: n,
							action: e
						})
					}, this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							n = this.getFilteredActions(t);
						this.setState({
							currentInputText: t,
							filteredActions: n
						})
					}, this.onKeyDown = e => {
						if (e.which === _.a.Enter) {
							const {
								filteredActions: t
							} = this.state, n = t.length ? this.buildModLogUrlForAction(t[0]) : null;
							n && (this.props.onChangeUrl(n), e.preventDefault())
						}
					}, this.onActionClick = e => {
						this.props.sendEvent(D(e))
					}, this.state = {
						currentInputText: "",
						filteredActions: this.getFilteredActions("")
					}
				}
				getFilteredActions(e) {
					let t = Object.keys(E);
					if (e) {
						const n = e.toLowerCase();
						t = t.filter(e => E[e]().toString().toLowerCase().includes(n))
					}
					return t
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredActions: t
					} = this.state;
					return a.a.createElement("div", {
						role: "menu",
						className: e
					}, a.a.createElement("input", {
						"aria-label": r.fbt._("Filter", null, {
							hk: "UqHZD"
						}),
						className: F.a.filter,
						placeholder: r.fbt._("Filter", null, {
							hk: "3sxP3l"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map(e => a.a.createElement(I.default, {
						className: F.a.dropdownRow,
						onClick: () => this.onActionClick(e),
						to: this.buildModLogUrlForAction(e)
					}, E[e]())))
				}
			}
			var B = U,
				G = n("./src/lib/constants/index.ts"),
				H = n("./src/lib/objectSelector/index.ts"),
				W = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts");
			const q = Object(H.a)((e, t) => {
					let {
						subredditId: n
					} = t, s = [];
					const r = V(e),
						o = z(e);
					if (r && o) {
						const t = Object(W.a)(n, r, o),
							a = e.pages.modHub.moderationLog.actions.itemOrder[n] && e.pages.modHub.moderationLog.actions.itemOrder[n][t];
						a && (s = a.map(t => e.pages.modHub.moderationLog.actions.models[n][t]))
					}
					return s
				}),
				V = e => e.pages.modHub.moderationLog.endCursor,
				z = e => e.pages.modHub.moderationLog.startCursor,
				K = e => {
					let {
						name: t,
						urlPath: n
					} = e;
					return a.a.createElement(I.default, {
						className: F.a.dropdownRow,
						to: n
					}, t)
				},
				Q = "a",
				J = Object(d.c)({
					allModerators: (e, t) => {
						let {
							subredditId: n
						} = t;
						return ((e, t) => e.pages.modHub.moderationLog.moderators[t] || [])(e, n)
					}
				});
			class Y extends a.a.Component {
				constructor(e) {
					super(e), this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							n = this.getList(t);
						this.setState({
							currentInputText: t,
							filteredList: n
						})
					}, this.onKeyDown = e => {
						if (e.which === _.a.Enter) {
							const {
								filteredList: t
							} = this.state, n = t.length ? t[0].url : "";
							n && (this.props.onChangeUrl(n), e.preventDefault())
						}
					}, this.onDropdownClick = e => {
						e.target instanceof HTMLAnchorElement && this.props.sendEvent(A())
					}, this.state = {
						currentInputText: "",
						filteredList: this.getList("")
					}
				}
				getList(e) {
					const {
						action: t,
						currentPageUrl: n
					} = this.props, s = e => T({
						currentPageUrl: n,
						action: t,
						moderator: e
					}), o = [{
						url: s(""),
						displayText: `${r.fbt._("All Moderators",null,{hk:"3vmWA8"})}`
					}, {
						url: s(Q),
						displayText: `${r.fbt._("Admins",null,{hk:"4mKRNI"})}`
					}, {
						url: s(G.k),
						displayText: `${r.fbt._("AutoModerator",null,{hk:"4wxc1W"})}`
					}, ...this.props.allModerators.map(e => ({
						url: s(e.name),
						displayText: e.name
					}))];
					if (e) {
						const t = e.toLowerCase();
						return o.filter(e => e.displayText.toLowerCase().includes(t))
					}
					return o
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredList: t
					} = this.state;
					return a.a.createElement("div", {
						role: "menu",
						className: e,
						onClick: this.onDropdownClick
					}, a.a.createElement("input", {
						"aria-label": r.fbt._("Filter", null, {
							hk: "1qnOD5"
						}),
						className: F.a.filter,
						placeholder: r.fbt._("Filter", null, {
							hk: "1sWvOA"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map((e, t) => a.a.createElement(K, {
						key: t,
						name: e.displayText,
						urlPath: e.url
					})))
				}
			}
			var X = Object(i.b)(J)(Y),
				Z = n("./src/reddit/components/TrackingHelper/index.tsx"),
				$ = n("./src/reddit/controls/Dropdown/index.tsx"),
				ee = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				te = n("./src/reddit/selectors/tooltip.ts");
			const ne = "mod-log-action-filter-dropdown",
				se = "mod-log-moderator-filter-dropdown",
				re = Object(f.a)($.a),
				oe = Object(d.c)({
					isActionFilterDropdownOpen: Object(te.b)(ne),
					isModeratorFilterDropdownOpen: Object(te.b)(se)
				});
			class ae extends a.a.Component {
				constructor() {
					super(...arguments), this.getContainerText = e => {
						const {
							action: t,
							moderator: n
						} = this.props;
						if (e === x.MODERATOR) {
							let e = n;
							return n === Q && (e = r.fbt._("Admins", null, {
								hk: "1qJDMA"
							})), e || r.fbt._("All Moderators", null, {
								hk: "18DhaK"
							})
						}
						if (e === x.ACTION) {
							return t && E[t] && E[t]() || r.fbt._("Actions", null, {
								hk: "1s4OJD"
							})
						}
					}, this.openModFilterDropdown = () => {
						this.props.onOpenDropdown(se), this.props.sendEvent(R())
					}, this.openActionFilterDropdown = () => {
						this.props.onOpenDropdown(ne), this.props.sendEvent(M())
					}
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						isActionFilterDropdownOpen: n,
						isModeratorFilterDropdownOpen: s,
						moderator: o,
						subredditId: i
					} = this.props;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
						className: F.a.container,
						onClickCapture: this.stopPropagation
					}, a.a.createElement("button", {
						"aria-expanded": s,
						"aria-label": r.fbt._("Start typing to filter moderators or use up and down to select.", null, {
							hk: "4ff0MW"
						}),
						className: F.a.selector,
						id: se,
						onClick: this.openModFilterDropdown,
						role: "navigation"
					}, a.a.createElement("span", {
						className: F.a.containerText
					}, this.getContainerText(x.MODERATOR)), a.a.createElement(ee.a, null)), a.a.createElement(re, {
						tooltipId: se,
						isOpen: s
					}, a.a.createElement(X, {
						action: e,
						className: F.a.listContainer,
						currentPageUrl: t,
						moderator: o,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent,
						subredditId: i
					}))), a.a.createElement("div", {
						className: F.a.container,
						onClickCapture: this.stopPropagation
					}, a.a.createElement("button", {
						"aria-expanded": n,
						"aria-label": r.fbt._("Start typing to filter the mod actions or use up and down to select.", null, {
							hk: "32A4KB"
						}),
						className: F.a.selector,
						id: ne,
						onClick: this.openActionFilterDropdown,
						role: "navigation"
					}, a.a.createElement("span", {
						className: F.a.containerText
					}, this.getContainerText(x.ACTION)), a.a.createElement(ee.a, null)), a.a.createElement(re, {
						tooltipId: ne,
						isOpen: n
					}, a.a.createElement(B, {
						action: e,
						className: F.a.listContainer,
						currentPageUrl: t,
						moderator: o,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent
					}))))
				}
			}
			var ie = Object(i.b)(oe, e => ({
					onOpenDropdown: t => e(Object(g.h)({
						tooltipId: t
					})),
					pushUrl: t => e(Object(h.b)(t))
				}))(Object(Z.c)(ae)),
				de = n("./node_modules/lodash/noop.js"),
				ce = n.n(de),
				le = n("./src/reddit/components/AuthorLink/index.tsx"),
				ue = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				me = n("./src/reddit/components/HumanDate/index.tsx"),
				pe = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				be = n("./src/reddit/controls/InvisibleScreenReaderText/index.tsx"),
				he = n("./src/reddit/models/User/index.ts"),
				fe = (n("./src/lib/assertNever.ts"), n("./src/lib/sentry/index.ts"));
			var ge = n("./src/reddit/icons/fonts/index.tsx"),
				_e = n("./src/reddit/icons/fonts/Comment/index.tsx"),
				ve = n("./src/reddit/icons/svgs/Collection/index.tsx"),
				Oe = n("./src/reddit/icons/svgs/Event/index.tsx"),
				xe = n("./src/reddit/icons/svgs/Gild/index.tsx"),
				Ee = n("./src/reddit/icons/svgs/ModLogPosts/index.tsx"),
				ye = n("./src/reddit/icons/svgs/Negative/index.tsx"),
				je = n("./src/reddit/icons/svgs/Positive/index.tsx"),
				Ce = n("./src/reddit/icons/svgs/Redditor/index.tsx"),
				ke = n("./src/reddit/icons/svgs/Settings/index.tsx"),
				Ie = n("./src/reddit/icons/svgs/Tag/index.tsx"),
				Se = n("./src/reddit/icons/svgs/Wiki/index.tsx"),
				we = n("./src/reddit/models/Comment/index.ts"),
				Te = n("./src/reddit/models/FeedElement/index.ts"),
				Ne = n("./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less"),
				Pe = n.n(Ne);
			const Re = e => {
				let {
					action: t,
					urlPath: n
				} = e;
				const s = (e => {
						switch (e) {
							case "ALL_ACTIONS":
								return;
							case "ADD_CONTRIBUTOR":
							case "ADD_MODERATOR":
								return {
									type: j.REDDITOR, treatment: C.POSITIVE
								};
							case "BAN_USER":
							case "MUTE_USER":
							case "REMOVE_CONTRIBUTOR":
							case "REMOVE_MODERATOR":
								return {
									type: j.REDDITOR, treatment: C.NEGATIVE
								};
							case "CREATE_AWARD":
							case "MOD_AWARD_GIVEN":
								return {
									type: j.AWARD, treatment: C.POSITIVE
								};
							case "DELETE_AWARD":
							case "DISABLE_AWARD":
							case "ENABLE_AWARD":
							case "HIDDEN_AWARD":
								return {
									type: j.AWARD, treatment: C.NEGATIVE
								};
							case "ACCEPT_MODERATOR_INVITE":
							case "INVITE_MODERATOR":
							case "INVITE_SUBSCRIBER":
							case "SET_PERMISSIONS":
							case "UNBAN_USER":
							case "UNINVITE_MODERATOR":
							case "UNMUTE_USER":
								return {
									type: j.REDDITOR, treatment: C.NONE
								};
							case "APPROVE_COMMENT":
							case "SHOW_COMMENT":
								return {
									type: j.COMMENT, treatment: C.POSITIVE
								};
							case "REMOVE_COMMENT":
							case "SPAM_COMMENT":
								return {
									type: j.COMMENT, treatment: C.NEGATIVE
								};
							case "EDIT_FLAIR":
								return {
									type: j.FLAIR, treatment: C.NONE
								};
							case "APPROVE_LINK":
								return {
									type: j.POST, treatment: C.POSITIVE
								};
							case "REMOVE_LINK":
							case "SPAM_LINK":
							case "ADD_REMOVAL_REASON":
								return {
									type: j.POST, treatment: C.NEGATIVE
								};
							case "LOCK":
							case "MARK_NSFW":
							case "MARK_ORIGINAL_CONTENT":
							case "SET_CONTEST_MODE":
							case "SET_SUGGESTEDSORT":
							case "SPOILER":
							case "UNLOCK":
							case "UNSET_CONTEST_MODE":
							case "UNSPOILER":
								return {
									type: j.POST, treatment: C.NONE
								};
							case "DISTINGUISH":
							case "IGNORE_REPORTS":
							case "SNOOZE_REPORTS":
							case "STICKY":
							case "UNIGNORE_REPORTS":
							case "UNSNOOZE_REPORTS":
							case "UNSTICKY":
								return {
									type: j.MULTIPLE, treatment: C.NONE
								};
							case "ADD_COMMUNITY_TOPICS":
							case "ADJUST_POST_CROWD_CONTROL_LEVEL":
							case "ENABLE_POST_CROWD_CONTROL_FILTER":
							case "DISABLE_POST_CROWD_CONTROL_FILTER":
							case "REMOVE_COMMUNITY_TOPICS":
							case "COMMUNITY_STYLING":
							case "COMMUNITY_WIDGETS":
							case "CREATE_RULE":
							case "DELETE_RULE":
							case "EDIT_POST_REQUIREMENTS":
							case "EDIT_RULE":
							case "REORDER_RULES":
							case "REORDER_MODERATORS":
							case "EDIT_SETTINGS":
							case "MODMAIL_ENROLLMENT":
							case "SUBMIT_CONTENT_RATING_SURVEY":
							case "DELETE_OVERRIDDEN_CLASSIFICATION":
							case "OVERRIDE_CLASSIFICATION":
							case "CREATE_REMOVAL_REASON":
							case "DELETE_REMOVAL_REASON":
							case "UPDATE_REMOVAL_REASON":
								return {
									type: j.SETTINGS, treatment: C.NONE
								};
							case "REMOVE_WIKI_CONTRIBUTOR":
							case "WIKI_BANNED":
								return {
									type: j.WIKI, treatment: C.NEGATIVE
								};
							case "WIKI_CONTRIBUTOR":
							case "WIKI_PAGE_LISTED":
							case "WIKI_PERM_LEVEL":
							case "WIKI_REVISE":
							case "WIKI_UNBANNED":
								return {
									type: j.WIKI, treatment: C.NONE
								};
							case "COLLECTIONS":
								return {
									type: j.COLLECTION, treatment: C.NONE
								};
							case "EVENTS":
								return {
									type: j.EVENT, treatment: C.NONE
								};
							case "CREATE_SCHEDULED_POST":
							case "EDIT_SCHEDULED_POST":
							case "DELETE_SCHEDULED_POST":
							case "SUBMIT_SCHEDULED_POST":
								return {
									type: j.POST, treatment: C.NONE
								};
							case "ADD_NOTE":
								return {
									type: j.NOTE, treatment: C.POSITIVE
								};
							case "DELETE_NOTE":
								return {
									type: j.NOTE, treatment: C.NEGATIVE
								};
							default:
								return void fe.c.captureMessage(`Unknown mod action "${e}"`)
						}
					})(t.action),
					r = t.target && t.target.__typename,
					o = r === we.d.Comment || we.d.DeletedComment;
				let i;
				switch (s && s.type) {
					case j.AWARD:
						i = a.a.createElement(xe.a, {
							className: Pe.a.icon
						});
						break;
					case j.COMMENT:
						i = a.a.createElement(_e.a, null);
						break;
					case j.FLAIR:
						i = a.a.createElement(Ie.a, {
							className: Pe.a.icon
						});
						break;
					case j.POST:
						i = a.a.createElement(Ee.a, {
							className: Pe.a.icon
						});
						break;
					case j.REDDITOR:
						i = a.a.createElement(Ce.a, {
							className: Pe.a.icon
						});
						break;
					case j.SETTINGS:
						i = a.a.createElement(ke.a, {
							className: Pe.a.icon
						});
						break;
					case j.WIKI:
						i = a.a.createElement(Se.a, {
							className: Pe.a.icon
						});
						break;
					case j.COLLECTION:
						i = a.a.createElement(ve.a, {
							className: Pe.a.icon
						});
						break;
					case j.EVENT:
						i = a.a.createElement(Oe.a, {
							className: Pe.a.icon
						});
						break;
					case j.MULTIPLE:
						o && (i = a.a.createElement(_e.a, null)), r === Te.a.SubredditPost && (i = a.a.createElement(Ee.a, {
							className: Pe.a.icon
						}));
						break;
					case j.NOTE:
						const e = Object(ge.b)("user_note");
						i = a.a.createElement(e, {
							className: Pe.a.icon,
							style: {
								fontSize: "16px"
							}
						})
				}
				const d = E[t.action];
				return a.a.createElement(I.default, {
					className: Pe.a.actionLink,
					to: n
				}, a.a.createElement("span", {
					className: Pe.a.iconWrapper
				}, i, s && s.treatment === C.POSITIVE ? a.a.createElement(je.a, {
					className: Pe.a.positiveTreatment
				}) : s && s.treatment === C.NEGATIVE ? a.a.createElement(ye.a, {
					className: Pe.a.negativeTreatment
				}) : null), d && d())
			};
			var Ae = n("./src/reddit/helpers/graphql/helpers.ts");
			const Me = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === he.c.AvailableRedditor ? t.name : null
				},
				De = e => `${e.id}-takedown-content-preview`,
				Le = e => {
					var t, n;
					return !!((null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.title) || (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.body))
				},
				Fe = e => {
					var t;
					return null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.violatedContentPolicyRule
				},
				Ue = e => {
					const {
						target: t,
						takedownContentPreview: n
					} = e;
					if (!t || !n) return null;
					const {
						title: s,
						body: r,
						thumbnail: o,
						violatedContentPolicyRule: a
					} = n;
					if ((e => e.__typename === Te.a.SubredditPost)(t)) {
						const e = t,
							{
								score: n,
								commentCount: i,
								createdAt: d
							} = e;
						return {
							title: s,
							body: r,
							thumbnail: o,
							violatedContentPolicyRule: a,
							score: n,
							commentCount: i,
							author: Me(e),
							createdAt: Object(Ae.g)(d)
						}
					}
					if ((e => e.__typename === we.d.Comment)(t)) {
						const e = t,
							{
								score: n,
								createdAt: s,
								postInfo: o
							} = e;
						return {
							title: null == o ? void 0 : o.title,
							body: r,
							parent: {
								score: null == o ? void 0 : o.score,
								commentCount: null == o ? void 0 : o.commentCount,
								createdAt: (null == o ? void 0 : o.createdAt) ? Object(Ae.g)(null == o ? void 0 : o.createdAt) : null
							},
							score: n,
							author: Me(e),
							createdAt: Object(Ae.g)(s)
						}
					}
					return null
				};
			var Be = n("./src/reddit/controls/Button/index.tsx"),
				Ge = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less"),
				He = n.n(Ge);
			const {
				fbt: We
			} = n("./node_modules/fbt/lib/FbtPublic.js"), qe = e => {
				let {
					action: t,
					showTakedownPreview: n,
					toggleShowTakedownPreview: s
				} = e;
				return Le(t) ? a.a.createElement(Be.t, {
					Icon: Object(ge.b)(n ? "caret_up" : "caret_down"),
					iconPosition: Be.h.R,
					priority: Be.c.PlainLink,
					onClick: s,
					"aria-expanded": n,
					"aria-controls": De(t)
				}, n ? We._("Hide details", null, {
					hk: "4295ML"
				}) : We._("Show details", null, {
					hk: "4d94Js"
				})) : a.a.createElement("span", {
					className: He.a.noPreview
				}, We._("Details removed", null, {
					hk: "25LG4u"
				}))
			}, Ve = e => {
				let {
					authorInfo: t
				} = e;
				return t && t.__typename === he.c.AvailableRedditor && t.name || null
			}, ze = e => {
				let {
					action: t,
					showTakedownPreview: n,
					toggleShowTakedownPreview: s
				} = e;
				const r = Object(Z.b)(),
					{
						authorUsername: o,
						content: i,
						urlPath: d
					} = (e => {
						var t, n, s;
						const r = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let o = e.target;
						switch (r) {
							case Te.a.SubredditPost:
								return {
									authorUsername: Ve(o = o), content: (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.title) || o.title, urlPath: o.permalink
								};
							case Te.a.DeletedSubredditPost:
								return {
									authorUsername: null, content: (o = o).title, urlPath: o.permalink
								};
							case he.c.AvailableRedditor:
								return {
									authorUsername: (o = o) && o.name || null, content: null, urlPath: void 0
								};
							case we.d.Comment:
								return {
									authorUsername: Ve(o = o), content: (null === (s = e.takedownContentPreview) || void 0 === s ? void 0 : s.body) || o.content && o.content.markdown, urlPath: o.permalink
								};
							case we.d.DeletedComment:
								return {
									authorUsername: null, content: (o = o).postInfo && o.postInfo.title, urlPath: o.postInfo && o.postInfo.permalink
								};
							default:
								return {
									authorUsername: null, content: null, urlPath: void 0
								}
						}
					})(t),
					{
						text: c,
						url: l
					} = (e => {
						var t;
						const {
							actionNotes: n,
							details: s,
							takedownContentPreview: r
						} = e;
						if (null == r ? void 0 : r.violatedContentPolicyRule) return {
							text: k[r.violatedContentPolicyRule](),
							url: r.violatedContentPolicyRule === v.f.Dmca ? "https://reddit.zendesk.com/hc/en-us/sections/360008810152-Copyright-Help-Center" : "https://www.redditinc.com/policies/content-policy"
						};
						const o = (null === (t = y[s]) || void 0 === t ? void 0 : t.call(y)) || s;
						return n ? o ? {
							text: `${o}: ${e.actionNotes}`
						} : {
							text: n
						} : {
							text: o
						}
					})(t),
					u = (e => {
						var t;
						const n = Fe(e) || void 0,
							s = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let r = e.target;
						switch (s) {
							case Te.a.SubredditPost:
							case Te.a.DeletedSubredditPost:
								return {
									post: {
										id: (r = r).id
									}, comment: void 0, violatedContentPolicyRule: n
								};
							case we.d.Comment:
							case we.d.DeletedComment:
								return {
									post: void 0, comment: {
										id: (r = r).id
									}, violatedContentPolicyRule: n
								};
							default:
								return {
									post: void 0, comment: void 0, violatedContentPolicyRule: n
								}
						}
					})(t),
					m = (e => !!Fe(e))(t);
				return a.a.createElement("div", {
					className: Pe.a.container
				}, a.a.createElement("div", {
					className: Pe.a.detailsContainer
				}, o && !O.includes(o) ? a.a.createElement(ue.a, {
					tooltipId: `userlink-${t.id}`,
					user: o,
					sendHoverCardEvent: ce.a
				}, a.a.createElement(le.a, {
					className: Pe.a.usernameLink,
					author: o,
					onClick: () => r((e => {
						let {
							violatedContentPolicyRule: t,
							post: n,
							comment: s
						} = e;
						return e => ({
							source: "mod_log",
							action: "click",
							noun: "user_profile",
							post: n,
							comment: s,
							...N.n(e),
							actionInfo: N.d(e, {
								reason: t
							})
						})
					})(u))
				}, `u/${o}`)) : o, i && d && a.a.createElement("a", {
					className: Pe.a.detailsContent,
					target: "_blank",
					rel: "noopener noreferrer",
					href: d,
					onClick: () => r((e => {
						let {
							violatedContentPolicyRule: t,
							post: n,
							comment: s
						} = e;
						return e => ({
							source: "mod_log",
							action: "click",
							noun: (null == s ? void 0 : s.id) ? "comment" : "post",
							post: n,
							comment: s,
							...N.n(e),
							actionInfo: N.d(e, {
								reason: t
							})
						})
					})(u))
				}, i), c && a.a.createElement("span", {
					className: Pe.a.detailsType
				}, "(", l ? a.a.createElement("a", {
					href: l,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: () => r((e => {
						let {
							violatedContentPolicyRule: t,
							post: n,
							comment: s
						} = e;
						return e => ({
							source: "mod_log",
							action: "click",
							noun: "content_policy",
							post: n,
							comment: s,
							...N.n(e),
							actionInfo: N.d(e, {
								reason: t
							})
						})
					})(u))
				}, c) : c, ")")), m && a.a.createElement(qe, {
					action: t,
					showTakedownPreview: n,
					toggleShowTakedownPreview: () => {
						s(), n || r((e => {
							let {
								violatedContentPolicyRule: t,
								post: n,
								comment: s
							} = e;
							return e => ({
								source: "mod_log",
								action: "click",
								noun: "show_details",
								post: n,
								comment: s,
								...N.n(e),
								actionInfo: N.d(e, {
									reason: t
								})
							})
						})(u))
					}
				}))
			};
			var Ke = n("./src/lib/classNames/index.ts"),
				Qe = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less"),
				Je = n.n(Qe);
			const Ye = e => {
				let {
					src: t
				} = e;
				const [n, s] = Object(o.useState)(!0);
				return a.a.createElement("button", {
					className: Je.a.wrapper,
					onClick: () => s(e => !e),
					role: "img",
					"aria-label": r.fbt._("Thumbnail preview of content media", null, {
						hk: "43MhFw"
					})
				}, a.a.createElement("img", {
					className: Object(Ke.a)(Je.a.thumbnail, {
						[Je.a.blur]: n
					}),
					src: t
				}))
			};
			var Xe = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less"),
				Ze = n.n(Xe);
			const $e = e => {
				let {
					children: t
				} = e;
				const n = Object(o.useRef)(null),
					[s, i] = Object(o.useState)(!1);
				Object(o.useLayoutEffect)(() => {
					if (n.current) {
						const e = n.current,
							t = e.clientHeight >= e.scrollHeight;
						i(t)
					}
				}, [n, i]);
				return a.a.createElement(a.a.Fragment, null, a.a.createElement("p", {
					ref: n,
					className: Object(Ke.a)(Ze.a.body, {
						[Ze.a.bodyExpanded]: s
					})
				}, t), !s && a.a.createElement(Be.t, {
					className: Ze.a.seeMore,
					size: Be.d.XS,
					priority: Be.c.PlainLink,
					onClick: () => {
						i(!0)
					}
				}, r.fbt._("See more", null, {
					hk: "PNFjo"
				})))
			};
			var et = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less"),
				tt = n.n(et),
				nt = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less"),
				st = n.n(nt);
			const rt = e => {
					let {
						author: t,
						score: n,
						commentCount: s,
						createdAt: o
					} = e;
					return a.a.createElement("ul", {
						className: st.a.previewInfo
					}, t && a.a.createElement("li", {
						className: st.a.previewInfoItem
					}, a.a.createElement(le.a, {
						author: t,
						className: st.a.authorLink
					}, "u/", t)), Number.isInteger(n) && a.a.createElement("li", {
						className: st.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} points",
						_1: "1 point"
					}, [r.fbt._plural(n, "number")], {
						hk: "1nHdfa"
					})), Number.isInteger(s) && a.a.createElement("li", {
						className: st.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} comments",
						_1: "1 comment"
					}, [r.fbt._plural(s, "number")], {
						hk: "1izKX9"
					})), o && a.a.createElement("li", {
						className: st.a.previewInfoItem
					}, a.a.createElement(me.d, {
						seconds: o / G.Sb
					})))
				},
				ot = e => {
					let {
						action: t
					} = e;
					var n, s, r;
					const o = Ue(t);
					return null === o ? null : a.a.createElement("article", {
						className: tt.a.container,
						id: De(t)
					}, (null == o ? void 0 : o.title) && a.a.createElement("p", {
						className: tt.a.title
					}, o.title), a.a.createElement("div", {
						className: Object(Ke.a)({
							[tt.a.contentWrapperComment]: !!o.parent
						})
					}, (null == o ? void 0 : o.body) && a.a.createElement($e, null, o.body), (null == o ? void 0 : o.thumbnail) && a.a.createElement(Ye, {
						src: o.thumbnail
					}), a.a.createElement(rt, {
						author: null == o ? void 0 : o.author,
						score: null == o ? void 0 : o.score,
						commentCount: null == o ? void 0 : o.commentCount,
						createdAt: null == o ? void 0 : o.createdAt
					})), (null == o ? void 0 : o.parent) && a.a.createElement(rt, {
						score: null === (n = null == o ? void 0 : o.parent) || void 0 === n ? void 0 : n.score,
						commentCount: null === (s = null == o ? void 0 : o.parent) || void 0 === s ? void 0 : s.commentCount,
						createdAt: null === (r = null == o ? void 0 : o.parent) || void 0 === r ? void 0 : r.createdAt
					}))
				},
				at = "mod-log-timestamp-";
			class it extends a.a.Component {
				constructor(e) {
					super(e), this.createTimestamp = e => {
						return new Date(e).toString()
					}, this.getTooltipId = e => `${at}${e}`, this.getActionModeratorName = e => e && e.__typename === he.c.AvailableRedditor ? e.name : null, this.toggleShowTakedownPreview = () => {
						this.setState(e => ({
							showTakedownPreview: !e.showTakedownPreview
						}))
					}, this.state = {
						showTakedownPreview: !1
					}
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						moderator: n,
						onHideTooltip: s,
						onShowTooltip: o
					} = this.props, {
						showTakedownPreview: i
					} = this.state, d = this.getTooltipId(e.id), c = this.getActionModeratorName(e.moderator), l = Le(e);
					return a.a.createElement("tr", {
						className: Pe.a.row
					}, a.a.createElement("td", null, a.a.createElement("span", {
						id: d,
						onMouseEnter: () => o(d),
						onMouseLeave: s,
						className: Pe.a.tooltip
					}, a.a.createElement(me.d, {
						seconds: e.createdAt / G.Sb
					}), a.a.createElement(pe.c, {
						className: Pe.a.createdAtTooltip,
						tooltipId: d,
						text: this.createTimestamp(e.createdAt)
					}))), a.a.createElement("td", {
						className: Pe.a.modNameCell
					}, c && !O.includes(c) ? a.a.createElement(ue.a, {
						tooltipId: `modlink-${e.id}`,
						user: c,
						sendHoverCardEvent: ce.a
					}, a.a.createElement(le.a, {
						author: c,
						className: Pe.a.usernameLink
					}, c)) : c), a.a.createElement("td", null, a.a.createElement(Re, {
						action: e,
						urlPath: T({
							currentPageUrl: t,
							action: e.action,
							moderator: n
						})
					})), a.a.createElement("td", null, a.a.createElement(ze, {
						action: e,
						showTakedownPreview: i,
						toggleShowTakedownPreview: this.toggleShowTakedownPreview
					})), a.a.createElement("td", {
						className: Pe.a.takedownContentPreviewCell
					}, l && i ? a.a.createElement("div", {
						className: Pe.a.takedownContentPreviewWrapper
					}, a.a.createElement(ot, {
						action: e
					})) : a.a.createElement(be.a, null, l ? r.fbt._("No content preview shown. Press show details in previous cell to reveal.", null, {
						hk: "3OP9nc"
					}) : r.fbt._("No content preview available.", null, {
						hk: "4mp2x9"
					}))))
				}
			}
			var dt = Object(i.b)(null, e => ({
					onHideTooltip: () => e(Object(g.i)()),
					onShowTooltip: t => e(Object(g.f)({
						tooltipId: t
					}))
				}))(it),
				ct = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				lt = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				ut = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				mt = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				pt = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				bt = n("./src/reddit/constants/parameters.ts"),
				ht = n("./src/reddit/contexts/PageLayer/index.tsx"),
				ft = n("./src/reddit/components/ModerationLog/index.m.less"),
				gt = n.n(ft);
			const _t = Object(ht.u)({
					currentPageUrl: ht.f,
					queryParams: ht.X
				}),
				vt = Object(d.c)({
					actionsList: q,
					endCursor: V,
					nextPage: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.moderationLog.hasNextPage[n]
					},
					previousPage: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.moderationLog.hasPreviousPage[n]
					},
					startCursor: z
				}),
				Ot = Object(i.b)(vt, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						fetchAllModerators: () => e((e => async (t, n, s) => {
							let {
								gqlContext: r
							} = s;
							const o = n(),
								a = Object(m.F)(o, e);
							if (o.pages.modHub.moderationLog.moderators[a]) return;
							const i = await Object(l.b)(r(), e);
							if (i.body) {
								const e = i.body.data.subreddit.moderators;
								if (e) {
									const n = Object(u.a)(e);
									t(b({
										normalizedModerators: n,
										subredditId: a
									}))
								}
							}
						})(n.name))
					}
				});
			class xt extends a.a.Component {
				componentDidMount() {
					"complete" === document.readyState ? this.props.fetchAllModerators() : window.addEventListener("load", this.props.fetchAllModerators)
				}
				render() {
					const {
						actionsList: e,
						currentPageUrl: t,
						endCursor: n,
						nextPage: o,
						previousPage: i,
						queryParams: d,
						startCursor: c,
						subredditId: l
					} = this.props, u = d[bt.m] || null, m = d[bt.l] || null, p = {
						currentPageUrl: t,
						action: u,
						moderator: m,
						startCursor: c
					}, b = {
						currentPageUrl: t,
						endCursor: n,
						action: u,
						moderator: m
					};
					return a.a.createElement(mt.a, {
						className: gt.a.contentContainer
					}, a.a.createElement(mt.b, null, r.fbt._("Mod log", null, {
						hk: "UdwRO"
					}), a.a.createElement(ct.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360022402312`
					})), a.a.createElement(pt.a, null, a.a.createElement("span", {
						className: gt.a.title
					}, r.fbt._("Filter by", null, {
						hk: "3RkGvd"
					})), a.a.createElement(ie, {
						action: u,
						currentPageUrl: t,
						moderator: m,
						subredditId: l
					}), a.a.createElement(ut.a, {
						prevButtonEnabled: i,
						prevTo: T(p),
						nextButtonEnabled: o,
						nextTo: T(b)
					})), a.a.createElement("table", {
						className: gt.a.table
					}, a.a.createElement("thead", null, a.a.createElement("tr", null, a.a.createElement("th", null, r.fbt._("time", null, {
						hk: "1EnamY"
					})), a.a.createElement("th", null, r.fbt._("moderator", null, {
						hk: "22lRDF"
					})), a.a.createElement("th", {
						className: gt.a.actionNameColHeader
					}, a.a.createElement("span", {
						className: gt.a.tooltip
					}, r.fbt._("action", null, {
						hk: "243Ltb"
					}), a.a.createElement(lt.a, {
						className: gt.a.actionTooltip
					}, a.a.createElement("div", {
						className: gt.a.actionTooltipDescription
					}, r.fbt._("Actions performed within your community", null, {
						hk: "3RTNED"
					})), a.a.createElement("div", {
						className: gt.a.allIconsContainer
					}, a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(Ee.a, {
						className: gt.a.icon
					}), r.fbt._("Post", null, {
						hk: "9rK7i"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(_e.a, null), r.fbt._("Comment", null, {
						hk: "1N3Vo2"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(Ie.a, {
						className: gt.a.icon
					}), r.fbt._("Flair", null, {
						hk: "roX9r"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(Se.a, {
						className: gt.a.icon
					}), r.fbt._("Wiki", null, {
						hk: "27Czfb"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(Ce.a, {
						className: gt.a.icon
					}), r.fbt._("User management", null, {
						hk: "NIFnh"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(ke.a, {
						className: gt.a.icon
					}), r.fbt._("Community settings", null, {
						hk: "139FAy"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(ve.a, {
						className: gt.a.icon
					}), r.fbt._("Collection", null, {
						hk: "3a6W4E"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(Oe.a, {
						className: gt.a.icon
					}), r.fbt._("Event", null, {
						hk: "2odtv8"
					})), a.a.createElement("div", {
						className: gt.a.iconContainer
					}, a.a.createElement(xe.a, {
						className: gt.a.icon
					}), r.fbt._("Award", null, {
						hk: "2l9uEL"
					})))))), a.a.createElement("th", null, a.a.createElement("span", {
						className: gt.a.tooltip
					}, r.fbt._("details", null, {
						hk: "1hCsar"
					}), a.a.createElement(lt.a, {
						text: r.fbt._("Displays the author, post or comment link, and any additional information", null, {
							hk: "1EN2HF"
						})
					}))), a.a.createElement("th", {
						className: gt.a.hiddenContentPreviewColumn
					}, r.fbt._("Content preview", null, {
						hk: "4C4kIi"
					})))), a.a.createElement("tbody", null, e.map(e => a.a.createElement(dt, {
						key: e.id,
						action: e,
						currentPageUrl: t,
						moderator: m
					})))), a.a.createElement("div", {
						className: gt.a.bottomBarRow
					}, a.a.createElement(ut.a, {
						prevButtonEnabled: i,
						prevTo: T(p),
						nextButtonEnabled: o,
						nextTo: T(b)
					})))
				}
			}
			t.a = _t(Ot(xt))
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.m.less": function(e, t, n) {
			e.exports = {
				NoResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				noResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				NoResultsText: "_3V0T64xptTp5xLaY-1nsaz",
				noResultsText: "_3V0T64xptTp5xLaY-1nsaz"
			}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/ModerationPagesEmptyList/index.m.less"),
				i = n.n(a);
			const d = o.a.div("NoResultsContainer", i.a),
				c = o.a.div("NoResultsText", i.a);

			function l(e) {
				const {
					childrenPosition: t = "top"
				} = e;
				return r.a.createElement(d, {
					className: e.className
				}, "top" === t && e.children, r.a.createElement(c, null, e.text), "bottom" === t && e.children)
			}
		},
		"./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "TOhrvfHoucDPr36mCCzXd",
				titleFontH2: "_3brDTRw250hGX1o5_C0hbB",
				titleFontH3: "_1wry80KT9v8gZ-OR85HxZU",
				titleFontH4: "_3UyiSE-qM-508iK8v3J9VE",
				titleFontH5: "_1X7-zzcj5Xf8vTf2xtYjK5",
				titleFontH6: "_2o19XEin0G5ad6iDvABrhH",
				metadataFont: "_1IpedXmIlnKyWpICNENnHX",
				flairFont: "_17kIb-dmfAlFCaIsLz34ar",
				labelsFont: "_3IrRBgoth_MxadAqzwGE2p",
				actionFont: "_1F_YPbXlF7ItI0z0j2Kdvy",
				smallButtonFont: "Irj9r66tO2hdWqbJx-vWa",
				largeButtonFont: "_26FBjOBHlTgNO9o-fMxWOX",
				strongTextFont: "_2umiFjo_kHT370YVhqkBUV",
				tabFont: "_1DLO-Qu2r3PHt-swAklwVx",
				buttonFontXS: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontXs: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontS: "_2MZUL_NnTj8rQV3EzNYnUE",
				buttonFontM: "_3cvFNq2HJE_JQWxO1GFYqj",
				buttonFontL: "_3PGa9K2pADItl7cyT0ykh_",
				buttonFontXL: "_1ZxChwU_-XfEgc5UHBhcTo",
				buttonFontXl: "_1ZxChwU_-XfEgc5UHBhcTo",
				bodyFontH1: "czPuE4HoIQInpzrURaqrX",
				bodyFontH2: "_1RMqo3EKzteTfSdM5Q-OSg",
				bodyFontH3: "_1SHo5_8OixTqxTjJ466mw1",
				bodyFontH4: "_3_zdAqdo55tnx5RHhyuGVr",
				bodyFontH5: "_22jno3ihRm-Ef63KN0Wuxa",
				bodyFontH6: "_28OREyYTHZDHgLjcK4pt_d",
				bodyFontH6Small: "_2TEwXCwEPVa9d9qN9FdZkk",
				bodyFont: "_38nKHi6IDujIOM7SuazWPd",
				bodyFontSmall: "_1lPuNthSPFYSROqTVgJlNG",
				bodyFontMono: "_3C9ynyJ6Z174Fb3-8O20xa",
				footer: "_1a_UtwKPW009WQq9JDInTY",
				checkbox: "hXaFasafnItuHCckiO50p",
				checkboxDescription: "_2HjmM9sJH5PNkLQde58pxS",
				checkboxContainer: "_15zz-Q8aRGCDeqROyYsa6f",
				divider: "_1QbYDWR424D6xhw9foYGiP",
				primaryButton: "h4QlBfFmd6UnAtiNaOhcR",
				SecondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				secondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				ModalBody: "_2UK71LqBvNes-Kto-uSxfU",
				modalBody: "_2UK71LqBvNes-Kto-uSxfU",
				automodMore: "_2IpMI7l5irmIV4rSq0_hXy"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitePendingModal.m.less": function(e, t, n) {
			e.exports = {
				ModalText: "LuEOOX6cpsihxJHcF5aDv",
				modalText: "LuEOOX6cpsihxJHcF5aDv",
				ModalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				modalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				PrimaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				primaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				SecondaryButton: "_31o7G_2349tIzHKunBJEua",
				secondaryButton: "_31o7G_2349tIzHKunBJEua",
				Section: "K3DxSh_MxIy1lMkeHIPMc",
				section: "K3DxSh_MxIy1lMkeHIPMc",
				Image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				ModalMain: "_3Nec6X3UqKJgLUGDaw4NCq",
				modalMain: "_3Nec6X3UqKJgLUGDaw4NCq"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less": function(e, t, n) {
			e.exports = {
				ListTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				listTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				ListContainer: "_1IFQy3zyz-Lgs7iYZtQaPI",
				listContainer: "_1IFQy3zyz-Lgs7iYZtQaPI"
			}
		},
		"./src/reddit/components/ModeratorsList/Moderator.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				pencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				TrashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				trashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				InteractiveDiv: "qaNZ40bbce8HBshNk04f0",
				interactiveDiv: "qaNZ40bbce8HBshNk04f0"
			}
		},
		"./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_3j2WCnh8ZjDRHIILJwKzkx",
				primaryButton: "_3j2WCnh8ZjDRHIILJwKzkx"
			}
		},
		"./src/reddit/components/ModeratorsList/index.m.less": function(e, t, n) {
			e.exports = {
				ListContainer: "_3s9PIWHO5f49Yj01FelAkk",
				listContainer: "_3s9PIWHO5f49Yj01FelAkk",
				SecondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				secondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				EditableTitle: "_1IBuDqoejky7tmj25quCUh",
				editableTitle: "_1IBuDqoejky7tmj25quCUh",
				UsersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				usersLoading: "_1oLmt3eyMItCQozx1nTk1E"
			}
		},
		"./src/reddit/components/ModeratorsList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/stripQueryParams/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/subredditModeration/index.ts"),
				b = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				h = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				f = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				_ = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				O = n("./src/reddit/contexts/PageLayer/index.tsx"),
				x = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				j = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/meta.ts"),
				k = n("./src/reddit/selectors/moderatorPermissions.ts"),
				I = n("./src/reddit/selectors/subredditModeration.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/asModal/index.tsx")),
				T = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				N = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				P = n("./src/reddit/controls/CheckboxWithLabel/index.tsx"),
				R = n("./src/reddit/controls/TextButton/index.tsx"),
				A = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				M = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				D = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				L = n("./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less"),
				F = n.n(L);
			const U = e => {
					switch (e) {
						case D.c.access:
							return r.fbt._("Manage Users", null, {
								hk: "2cVPGG"
							});
						case D.c.config:
							return r.fbt._("Manage Settings", null, {
								hk: "10NyX"
							});
						case "chat_config":
						case D.c.chatConfig:
							return r.fbt._("Create Live Chats", null, {
								hk: "2OsHBQ"
							});
						case "chat_operator":
						case D.c.chatOperator:
							return r.fbt._("Monitor Chats", null, {
								hk: "3x751K"
							});
						case D.c.flair:
							return r.fbt._("Manage Flair", null, {
								hk: "IgS6W"
							});
						case D.c.mail:
							return r.fbt._("Manage Mod Mail", null, {
								hk: "1H5qJm"
							});
						case D.c.posts:
							return r.fbt._("Manage Posts & Comments", null, {
								hk: "1IVGI9"
							});
						case D.c.wiki:
							return r.fbt._("Manage Wiki Pages", null, {
								hk: "4gZJ2V"
							});
						case D.c.all:
						default:
							return r.fbt._("Everything", null, {
								hk: "24E26J"
							})
					}
				},
				B = (e, t) => {
					switch (e) {
						case D.c.access:
							return t ? r.fbt._("Access mod notes, ban and mute users, and approve submitters*.", null, {
								hk: "24IuB9"
							}) : r.fbt._("Approve submitters and ban and mute users*.", null, {
								hk: "KndNL"
							});
						case D.c.config:
							return r.fbt._("Manage community settings, appearance, emojis, rules, and AutoMod*.", null, {
								hk: "4djZSI"
							});
						case "chat_config":
						case D.c.chatConfig:
							return r.fbt._("Create live chat posts in this community.", null, {
								hk: "1Hxgd8"
							});
						case "chat_operator":
						case D.c.chatOperator:
							return r.fbt._("Remove messages, remove users, and lock chats.", null, {
								hk: "TFYA1"
							});
						case D.c.flair:
							return r.fbt._("Create and manage user and post flair.", null, {
								hk: "1oN7ft"
							});
						case D.c.mail:
							return r.fbt._("Read and respond to modmail and mute users*.", null, {
								hk: "2F8Yd"
							});
						case D.c.posts:
							return r.fbt._("Access queues, take action on content, and manage collections and events.", null, {
								hk: "vJ5lR"
							});
						case D.c.wiki:
							return r.fbt._("Create and manage wiki pages and AutoMod*.", null, {
								hk: "JarEL"
							});
						case D.c.all:
						default:
							return r.fbt._("Full access including the ability to manage moderator access and permissions.", null, {
								hk: "2r1vEj"
							})
					}
				},
				G = Object(i.b)(null, (e, t) => {
					let {
						subredditId: n,
						after: s,
						before: r
					} = t;
					return {
						addModerator: (t, s) => e(Object(p.b)(n, t, s)),
						editModerator: (t, s, r) => e(Object(p.d)(n, t, s, r)),
						removeModerator: t => e(Object(p.k)(n, t, s, r))
					}
				}),
				H = l.a.span("SecondaryText", F.a),
				W = l.a.wrapped(T.e, "ModalBody", F.a);
			class q extends a.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.toggleSelect = (e, t) => {
						if (this.props.isEditingSelf) return;
						const n = {
							...this.state.permissions,
							[e]: !t
						};
						"all" === e ? Object.keys(n).forEach(e => n[e] = n.all) : n[e] || (n.all = !1), this.setState({
							permissions: n
						}), this.props.sendEventWithName("permission")()
					}, this.onSubmit = e => {
						e.preventDefault();
						const {
							props: t,
							state: n
						} = this;
						t.isEditingSelf ? t.toggleModal() : (t.isEditingPerms && t.user ? (t.editModerator(n.username, n.permissions, t.user.id), t.sendEventWithName("edit")()) : (t.addModerator(n.username, n.permissions), t.sendEventWithName("invite_moderator")()), t.toggleModal())
					}, this.onRemove = () => {
						this.props.user && (this.props.removeModerator(this.props.user.id), this.props.sendEventWithName("remove")()), this.props.toggleModal()
					}, this.state = {
						username: e.user ? e.user.username : "",
						permissions: e.user ? e.user.modPermissions : D.a
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = ["all", ...Object.keys(t.permissions).filter(t => !["all", ...e.isLivePostCreatorModRoleEnabled ? ["chat_operator", D.c.chatOperator] : []].includes(t))];
					return a.a.createElement(W, null, a.a.createElement(T.i, null, a.a.createElement(M.a, null, a.a.createElement(T.q, null, e.isEditingPerms ? r.fbt._("Edit", null, {
						hk: "1nftDt"
					}) : r.fbt._("Invite Moderators", null, {
						hk: "hkBh1"
					}), e.username && r.fbt._(": u/{username}", [r.fbt._param("username", e.username)], {
						hk: "2FWWEd"
					})), a.a.createElement(R.a, {
						onClick: e.toggleModal
					}, a.a.createElement(T.b, null)))), a.a.createElement("form", {
						onSubmit: this.onSubmit
					}, a.a.createElement(T.l, null, !e.isEditingPerms && a.a.createElement(T.h, null, a.a.createElement(N.d, {
						autoFocus: !0,
						placeholder: r.fbt._("Enter Username", null, {
							hk: "2fYsDe"
						}),
						onChange: this.onUsernameChange
					})), a.a.createElement(T.q, null, e.isEditingSelf ? a.a.createElement(a.a.Fragment, null, r.fbt._("Access", null, {
						hk: "2We3HN"
					}), a.a.createElement(H, null, r.fbt._("(can't edit)", null, {
						hk: "3LZvZi"
					}))) : r.fbt._("Give them access to...", null, {
						hk: "1DzYmU"
					})), t.permissions && n.map((n, s) => a.a.createElement("div", {
						className: F.a.checkboxContainer,
						key: n
					}, a.a.createElement(P.a, {
						autoFocus: !(!e.isEditingPerms || 0 !== s) || void 0,
						className: F.a.checkbox,
						disabled: e.isEditingSelf,
						isSelected: t.permissions[n],
						onClick: () => this.toggleSelect(n, t.permissions[n]),
						text: U(n)
					}), a.a.createElement("p", {
						className: F.a.checkboxDescription
					}, B(n, e.isModWithUserNotesPermissions)), "all" === n && a.a.createElement("hr", {
						className: F.a.divider
					}))), a.a.createElement("p", {
						className: F.a.automodMore
					}, r.fbt._("*Note: To manage AutoMod, mods must have access to Wiki Pages and Manage Settings. To mute users, mods must have access to Mod Mail and Manage Users.", null, {
						hk: "1AYX38"
					}))), a.a.createElement(T.g, {
						className: F.a.footer
					}, a.a.createElement(x.l, {
						className: F.a.primaryButton,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(A.a)(t.username),
						type: "submit"
					}, e.isEditingPerms ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Invite", null, {
						hk: "2F1syY"
					})), a.a.createElement(T.a, {
						autoFocus: !!e.isEditingSelf || void 0,
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.isEditingPerms && !e.isEditingSelf && a.a.createElement(T.s, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, r.fbt._("Remove", null, {
						hk: "3tYl0U"
					})))))
				}
			}
			var V = Object(w.a)(G(q)),
				z = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				K = n("./src/reddit/components/TrackingHelper/index.tsx"),
				Q = n("./src/reddit/selectors/telemetry.ts");
			const J = e => ({
					screen: Q.Z(e),
					subreddit: Q.hb(e)
				}),
				Y = e => t => ({
					source: "remove_mod_invite",
					action: "click",
					noun: e,
					...J(t)
				});
			var X = n("./src/lib/constants/index.ts"),
				Z = n("./src/reddit/components/HumanDate/index.tsx"),
				$ = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				ee = n("./src/reddit/icons/svgs/Trash/index.tsx"),
				te = n("./src/reddit/components/ModeratorsList/Moderator.m.less"),
				ne = n.n(te);
			const se = e => {
					const t = [],
						n = Object.keys(e);
					return e.all ? U("all") : (n.forEach((function(n) {
						e[n] && t.push(U(n))
					})), 0 === t.length ? r.fbt._("No permissions", null, {
						hk: "3eH05z"
					}) : t.join(", "))
				},
				re = l.a.wrapped($.a, "PencilIcon", ne.a),
				oe = l.a.wrapped(ee.a, "TrashIcon", ne.a),
				ae = l.a.div("InteractiveDiv", ne.a),
				ie = e => a.a.createElement(ae, {
					onClick: e.onClick
				}, e.moderatorType === y.c.Editable ? a.a.createElement(re, null) : a.a.createElement(oe, null));
			var de = e => a.a.createElement(v.b, {
					additionalText: se(e.moderator.modPermissions),
					pageName: X.gc.Moderators,
					primaryButton: e.moderatorType && e.onClick && a.a.createElement(ie, {
						onClick: e.onClick,
						moderatorType: e.moderatorType
					}),
					timeAgo: a.a.createElement(Z.d, {
						seconds: e.moderator.moddedAtUTC
					}),
					subredditId: e.subredditId,
					userIcon: e.moderator.accountIcon,
					username: e.moderator.username,
					moderatorType: e.moderatorType
				}),
				ce = n("./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less"),
				le = n.n(ce);
			const ue = l.a.div("ListTitle", le.a),
				me = l.a.div("ListContainer", le.a),
				pe = Object(d.c)({
					invitedModeratorsList: I.f,
					isConfirmModalOpen: Object(j.b)("ModerationPage--Modal--RemoveModeratorConfirmation")
				});
			class be extends a.a.Component {
				constructor(e) {
					super(e), this.onToggleRemovalModal = e => {
						this.setState({
							selectedModerator: e
						}), this.props.toggleConfirmUserActionModal(), e && this.props.sendEventWithName("remove_mod_invite")()
					}, this.state = {
						selectedModerator: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (0 === e.invitedModeratorsList.length) return null;
					const n = () => this.props.sendEvent(Y("cancel"));
					return a.a.createElement("div", null, a.a.createElement(ue, null, r.fbt._("Invited moderators", null, {
						hk: "2UdpbF"
					})), a.a.createElement(me, null, e.invitedModeratorsList.map(t => a.a.createElement(de, {
						key: t.id,
						moderator: t,
						moderatorType: y.c.Invited,
						onClick: () => this.onToggleRemovalModal(t),
						subredditId: e.subredditId
					}))), e.isConfirmModalOpen && t.selectedModerator && a.a.createElement(z.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to rescind the moderator invite to {username}?", [r.fbt._param("username", t.selectedModerator.username)], {
							hk: "3Z7yAI"
						}),
						onConfirm: () => e.removeInvitedModerator(t.selectedModerator.id),
						toggleModal: this.onToggleRemovalModal,
						onCancel: n,
						onClose: n,
						trackClick: () => this.props.sendEvent(Y("remove"))
					}))
				}
			}
			var he = Object(i.b)(pe, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						removeInvitedModerator: t => e(Object(p.j)(n, t)),
						toggleConfirmUserActionModal: () => e(Object(m.i)("ModerationPage--Modal--RemoveModeratorConfirmation"))
					}
				})(Object(K.c)(be)),
				fe = n("./src/reddit/components/ModeratorsList/InvitePendingModal.m.less"),
				ge = n.n(fe);
			const {
				fbt: _e
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ve = Object(i.b)(null, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					acceptInvite: () => e(Object(p.a)(n)),
					declineInvite: () => e(Object(p.c)(n))
				}
			}), Oe = l.a.wrapped(T.p, "ModalText", ge.a), xe = l.a.wrapped(Oe, "ModalTextBold", ge.a), Ee = l.a.wrapped(x.l, "PrimaryButton", ge.a), ye = l.a.wrapped(x.o, "SecondaryButton", ge.a), je = l.a.div("Section", ge.a), Ce = l.a.img("Image", ge.a), ke = l.a.wrapped(T.l, "ModalMain", ge.a);
			var Ie = Object(w.a)(ve(e => a.a.createElement(T.e, null, a.a.createElement(ke, null, a.a.createElement(M.a, null, a.a.createElement("div", null), a.a.createElement(R.a, {
					onClick: e.toggleModal
				}, a.a.createElement(T.b, null))), a.a.createElement(je, null, a.a.createElement(Ce, {
					src: `${s.a.assetPath}/img/snoo-success@2x.png`
				})), a.a.createElement(xe, null, _e._("Congrats!", null, {
					hk: "T4Ccw"
				})), a.a.createElement(Oe, null, _e._("You are invited to become a moderator!", null, {
					hk: "1jRLWz"
				}))), a.a.createElement(T.g, null, a.a.createElement(ye, {
					onClick: t => {
						e.toggleModal(), e.declineInvite(), e.sendEventWithName("declineinvite")()
					},
					"data-redditstyle": !0
				}, _e._("Decline", null, {
					hk: "1iOsJe"
				})), a.a.createElement(Ee, {
					onClick: t => {
						e.toggleModal(), e.acceptInvite(), e.sendEventWithName("acceptinvite")()
					},
					"data-redditstyle": !0
				}, _e._("Accept", null, {
					hk: "2fkYc4"
				})))))),
				Se = n("./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less"),
				we = n.n(Se);
			const {
				fbt: Te
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Ne = Object(i.b)(null, (e, t) => {
				let {
					subredditId: n,
					userId: s,
					after: r,
					before: o
				} = t;
				return {
					removeModerator: () => e(Object(p.k)(n, s, r, o))
				}
			}), Pe = l.a.wrapped(x.l, "PrimaryButton", we.a);
			class Re extends a.a.Component {
				constructor() {
					super(...arguments), this.onRemove = () => {
						this.props.removeModerator(), this.props.sendEventWithName("resign")(), this.props.toggleModal()
					}
				}
				render() {
					const {
						props: e
					} = this;
					return a.a.createElement(T.e, null, a.a.createElement(T.i, null, a.a.createElement(M.a, null, a.a.createElement(T.q, null, Te._("Leave as mod", null, {
						hk: "3ajWeG"
					})), a.a.createElement(R.a, {
						onClick: e.toggleModal
					}, a.a.createElement(T.b, null)))), a.a.createElement(T.l, null, a.a.createElement(T.p, null, Te._("Once you leave as a mod, you will lose mod permissions and will be unable to access any mod tools for this community. Are you sure you wish to leave as a mod of this community?", null, {
						hk: "4qm9md"
					}))), a.a.createElement(T.g, null, a.a.createElement(T.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Te._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(Pe, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, Te._("Leave", null, {
						hk: "2ZHZVX"
					}))))
				}
			}
			var Ae = Object(w.a)(Ne(Re)),
				Me = n("./src/reddit/selectors/experiments/chat.ts"),
				De = n("./src/reddit/components/ModeratorsList/index.m.less"),
				Le = n.n(De);
			const Fe = l.a.div("ListContainer", Le.a),
				Ue = l.a.wrapped(x.o, "SecondaryButton", Le.a),
				Be = Object(O.u)({
					currentPageUrl: O.f
				}),
				Ge = Object(d.c)({
					currentUser: S.k,
					nextAfterToken: I.k,
					nextAfterEditableToken: I.c,
					nextBeforeToken: I.l,
					nextBeforeEditableToken: I.d,
					editableModerators: I.e,
					editableModeratorsList: I.b,
					isInvitePending: I.h,
					moderators: I.o,
					moderatorsList: I.j,
					moderatorPermissions: k.n,
					isAddUserModalOpen: Object(j.b)("ModerationPage--Modal--AddModerator"),
					isEditableListPending: I.a,
					isInvitePendingModalOpen: Object(j.b)("ModerationPage--Modal--InvitePending"),
					isLivePostCreatorModRoleEnabled: Me.e,
					isModeratorListPending: I.i,
					isResignAsModeratorModalOpen: Object(j.b)("ModerationPage--Modal--Resign"),
					origin: C.k,
					searchPending: I.m,
					searchResult: I.n,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(k.i)(e, n)
					}
				}),
				He = Object(i.b)(Ge, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						searchForModerator: t => e(Object(p.h)(n, t)),
						toggleAddModeratorModal: () => e(Object(m.i)("ModerationPage--Modal--AddModerator")),
						toggleInvitePendingModal: () => e(Object(m.i)("ModerationPage--Modal--InvitePending")),
						toggleResignAsModModal: () => e(Object(m.i)("ModerationPage--Modal--Resign"))
					}
				}),
				We = l.a.div("EditableTitle", Le.a),
				qe = l.a.wrapped(v.a, "UsersLoading", Le.a);
			class Ve extends a.a.Component {
				constructor() {
					super(...arguments), this.state = y.a, this.toggleModal = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.isAddUserModalOpen || t || this.props.sendEventWithName("open_invite_dialog")(), this.props.toggleAddModeratorModal()
					}, this.onSearch = e => {
						this.props.searchForModerator(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.isButtonEnabled = (e, t) => !!(e && e.length > 0 && t), this.isModeratorsListPaginated = () => !(!this.props.nextBeforeToken && !this.props.nextAfterToken), this.renderEditableList = e => {
						const t = !(!e.nextBeforeEditableToken && !e.nextAfterEditableToken),
							n = e.isEditableListPending || e.isModeratorListPending;
						return a.a.createElement(a.a.Fragment, null, a.a.createElement(We, null, r.fbt._("You can edit these moderators", null, {
							hk: "1KTZtm"
						})), t && a.a.createElement(_.a, null, a.a.createElement(h.a, {
							prevButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextBeforeEditableToken),
							prevTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
								before: e.before,
								beforeEditable: e.nextBeforeEditableToken,
								after: e.after
							}),
							nextButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextAfterEditableToken),
							nextTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
								after: e.after,
								afterEditable: e.nextAfterEditableToken,
								before: e.before
							})
						})), a.a.createElement(Fe, null, e.editableModeratorsList && e.editableModeratorsList.length > 0 ? e.editableModeratorsList.map(e => a.a.createElement(de, {
							key: e.id,
							moderator: e,
							moderatorType: y.c.Editable,
							onClick: this.toggleModal(e.id, e.username),
							subredditId: this.props.subredditId
						})) : n ? a.a.createElement(qe, null) : null))
					}
				}
				componentDidMount() {
					this.props.isInvitePending && !this.props.isInvitePendingModalOpen && this.props.toggleInvitePendingModal()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = !!e.moderatorPermissions, o = Object(E.a)(e.moderatorPermissions);
					return a.a.createElement(a.a.Fragment, null, n && a.a.createElement(f.c, null, a.a.createElement(Ue, {
						onClick: e.toggleResignAsModModal
					}, r.fbt._("Leave as mod", null, {
						hk: "3TwqTg"
					})), o && a.a.createElement(x.l, {
						onClick: this.toggleModal(null, null)
					}, r.fbt._("Invite user as mod", null, {
						hk: "3lJRJW"
					}))), a.a.createElement(f.a, null, a.a.createElement(f.b, null, r.fbt._("Moderators of {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
						hk: "3p7NwA"
					}), a.a.createElement(b.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009381491`
					})), a.a.createElement(_.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}, !t.searchTerm && this.isModeratorsListPaginated() && a.a.createElement(h.a, {
						prevButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextBeforeToken),
						prevTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
							afterEditable: e.afterEditable,
							before: e.nextBeforeToken,
							beforeEditable: e.beforeEditable
						}),
						nextButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextAfterToken),
						nextTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
							after: e.nextAfterToken,
							afterEditable: e.afterEditable,
							beforeEditable: e.beforeEditable
						})
					})), t.searchTerm ? a.a.createElement(g.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && a.a.createElement(de, {
						moderator: e.searchResult,
						moderatorType: e.searchResult.isEditable ? y.c.Editable : void 0,
						onClick: e.searchResult.isEditable ? this.toggleModal(e.searchResult.id, e.searchResult.username) : void 0,
						subredditId: e.subredditId
					})) : a.a.createElement(a.a.Fragment, null, a.a.createElement(Fe, null, e.moderatorsList && e.moderatorsList.length > 0 ? e.moderatorsList.map(e => a.a.createElement(de, {
						key: e.id,
						moderator: e,
						subredditId: this.props.subredditId
					})) : e.isModeratorListPending ? a.a.createElement(qe, null) : null), o && a.a.createElement(a.a.Fragment, null, this.renderEditableList(e), a.a.createElement(he, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId
					})))), e.isAddUserModalOpen && a.a.createElement(V, {
						ignoreDefaultFocus: !0,
						after: e.afterEditable,
						before: e.beforeEditable,
						subredditId: e.subredditId,
						sendEventWithName: e.sendEventWithName,
						toggleModal: this.toggleModal(null, null),
						isEditingPerms: !!t.username,
						isEditingSelf: !(!t.userId || !e.currentUser) && t.userId === e.currentUser.id,
						username: t.username,
						user: t.userId && e.editableModerators ? e.editableModerators[t.userId] : null,
						withOverlay: !0,
						isModWithUserNotesPermissions: e.isModWithUserNotesPermissions,
						isLivePostCreatorModRoleEnabled: e.isLivePostCreatorModRoleEnabled
					}), e.currentUser && e.isResignAsModeratorModalOpen && a.a.createElement(Ae, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleResignAsModModal,
						userId: e.currentUser.id,
						withOverlay: !0
					}), e.isInvitePendingModalOpen && a.a.createElement(Ie, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleInvitePendingModal,
						withOverlay: !0
					}))
				}
			}
			t.a = Be(He(Ve))
		},
		"./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				optionSearchBarContainer: "_3eVrzdp5khbz6W2NhQv7kl",
				optionSearchBarError: "_3va8RfTnDLBo2hfMm5URpu",
				optionSearchBarReadOnly: "_2siJVLOBn72IxBt8i_A1gZ",
				loadingIcon: "_3UsfWdV2CKiIs_EOeGhVxv",
				input: "_1OEtZmrYX2ct3ycV1AaUZS",
				hiddenInput: "_3WSlf55CAQYRdOxtxENgA7",
				optionsOverflowIndication: "_2qfFc8Ix-QpBqu8UNEXeH3"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				activeOption: "_2Kg5EXAuLcqhsBbdEr4SGZ",
				freeTextOption: "_2H29-4MOHAslt1eKYtcGaV",
				lastFixedOption: "_1ClyNNAK4vP9o_uoSwKe0Q",
				option: "_1xWVaijFIih7uj-n4FXzH2",
				availableOptionContainer: "T2jLhmuhOy8DeOHjz6WRG",
				addText: "_1OqThwyrfhl2eJ9YhWoy2I",
				optionsContainer: "_1ZmC1GBXYnksnMU9IrTAHd",
				relativeContainer: "_3SrGeaD5FxXfpWjhSAFBD-",
				dropdown: "_2dqCXnStO_Dc8Srt_lJqVj",
				dropdownHeaderText: "_2EaXrPilAtjz6VRh_xvOGU"
			}
		},
		"./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less": function(e, t, n) {
			e.exports = {
				selectedOptionComponentContainer: "_3nUaRUcJJfrvOWldA3i10S",
				closeIcon: "_1RvgsgnXdbtv2cwTTTbT7o",
				selectedOptionComponentContainerError: "_2Qpr0YORGp3CmDjJW9Txrf"
			}
		},
		"./src/reddit/components/MultiOptionSelect/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends a.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.handleOptionSelected(this.props.index)
					}, this.handleMouseEnter = () => {
						this.props.handleOnMouseEnter(this.props.index)
					}
				}
				shouldComponentUpdate(e) {
					return e.className !== this.props.className || e.divRef !== this.props.divRef || e.displayText !== this.props.displayText
				}
				render() {
					const {
						addText: e,
						displayText: t,
						divRef: n,
						handleOnMouseEnter: s,
						handleOptionSelected: r,
						index: o,
						className: d,
						...c
					} = this.props;
					return a.a.createElement("div", u({
						className: Object(i.a)(l.a.availableOptionContainer, d)
					}, c, {
						onMouseEnter: this.handleMouseEnter,
						onClick: this.handleClick,
						ref: n
					}), e && a.a.createElement("span", {
						className: l.a.addText
					}, e, ""), t)
				}
			}
			class p extends a.a.Component {
				constructor(e) {
					super(e), this.handleOptionSelectedByIndex = e => {
						this.props.selectableOptions[e] && this.handleOptionSelected(this.props.selectableOptions[e])
					}, this.handleFreeTextOptionSelected = () => {
						this.handleOptionSelected({
							id: null,
							displayText: this.props.currentInput,
							selected: !0
						})
					}, this.clearSelectedIndex = () => {
						this.setSelectedIndex(-1)
					}, this.setOptionActiveByIndex = e => {
						"number" == typeof e && e > -1 && this.setSelectedIndex(e)
					}, this.setFreeTextOptionActive = () => {
						this.setSelectedIndex(this.getOptionsLength() - 1)
					}, this.state = {
						selectedIndex: -1
					}, this.scrollContainer = a.a.createRef(), this.optionsContainer = a.a.createRef(), this.activeOptionDOMRef = a.a.createRef()
				}
				focus() {
					this.optionsContainer.current && this.optionsContainer.current.focus()
				}
				matchesDOMElement(e) {
					return this.optionsContainer.current === e
				}
				handleOptionSelected(e) {
					this.handleOptionsSelected([e])
				}
				handleOptionsSelected(e) {
					this.props.onOptionsChanged(e.map(e => ({
						...e,
						selected: !0
					})))
				}
				setSelectedIndex(e) {
					this.setState({
						selectedIndex: e
					})
				}
				freeTextEntryActive() {
					return this.props.allowFreeTextEntry && this.props.currentInput
				}
				getOptionsLength() {
					return this.freeTextEntryActive() ? this.props.selectableOptions.length + 1 : this.props.selectableOptions.length
				}
				freeTextOptionSelected() {
					return this.freeTextEntryActive() && this.state.selectedIndex === this.getOptionsLength() - 1
				}
				validOptionSelected() {
					return this.state.selectedIndex > -1 && this.state.selectedIndex < this.getOptionsLength()
				}
				handlePaste(e) {
					if (e.clipboardData.types.includes("text/plain")) return e.preventDefault(), e.stopPropagation(), void this.handleOptionsSelected(e.clipboardData.getData("text/plain").split(d.b.Comma).filter(e => !!e).map(e => ({
						id: null,
						displayText: e.trim(),
						selected: !0
					})))
				}
				handleKeyPress(e) {
					const {
						splitOnCommaPress: t
					} = this.props;
					return e.which === d.a.ArrowUp ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex - 1 > -1 ? this.state.selectedIndex - 1 : this.getOptionsLength() - 1)) : e.which === d.a.ArrowDown ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex + 1 < this.getOptionsLength() ? this.state.selectedIndex + 1 : 0)) : e.which === d.a.Comma && t ? (e.preventDefault(), e.stopPropagation(), this.handleFreeTextOptionSelected()) : e.which === d.a.Enter ? (e.preventDefault(), e.stopPropagation(), !this.validOptionSelected() || this.freeTextOptionSelected() ? this.handleFreeTextOptionSelected() : this.handleOptionSelected(this.props.selectableOptions[this.state.selectedIndex])) : void 0
				}
				componentDidUpdate() {
					if (!this.activeOptionDOMRef.current || !this.scrollContainer.current) return;
					const e = this.activeOptionDOMRef.current.getBoundingClientRect(),
						t = this.scrollContainer.current.getBoundingClientRect();
					if (e.top < t.top || e.bottom > t.bottom) {
						if (0 === this.state.selectedIndex) return void(this.scrollContainer.current.scrollTop = 0);
						if (e.top < t.top) return void(this.scrollContainer.current.scrollTop = this.activeOptionDOMRef.current.offsetTop);
						this.scrollContainer.current.scrollTop += e.bottom - t.bottom
					}
				}
				shouldRenderDropdownHeaderText() {
					return !!this.props.dropdownHeaderText && (!this.freeTextEntryActive() || this.props.selectableOptions.length > 0)
				}
				render() {
					return a.a.createElement("div", {
						className: l.a.relativeContainer
					}, a.a.createElement("div", {
						className: Object(i.a)(l.a.dropdown, this.props.className),
						ref: this.scrollContainer
					}, a.a.createElement("div", {
						ref: this.optionsContainer,
						tabIndex: -1,
						className: l.a.optionsContainer,
						onMouseOut: this.clearSelectedIndex
					}, this.shouldRenderDropdownHeaderText() && a.a.createElement("h3", {
						className: l.a.dropdownHeaderText
					}, this.props.dropdownHeaderText), this.props.selectableOptions.map((e, t) => {
						const n = [this.state.selectedIndex === t ? l.a.activeOption : l.a.option];
						return this.freeTextEntryActive() && t === this.props.selectableOptions.length - 1 && n.push(l.a.lastFixedOption), a.a.createElement(m, {
							key: e.id,
							className: Object(i.a)(...n),
							index: t,
							handleOptionSelected: this.handleOptionSelectedByIndex,
							handleOnMouseEnter: this.setOptionActiveByIndex,
							divRef: t === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
							displayText: e.displayText
						})
					}), this.freeTextEntryActive() && a.a.createElement(m, {
						key: "options-list-dropdown-free-text-option",
						className: Object(i.a)(l.a.freeTextOption, this.state.selectedIndex === this.getOptionsLength() - 1 ? l.a.activeOption : l.a.option),
						handleOptionSelected: () => this.handleFreeTextOptionSelected(),
						handleOnMouseEnter: this.setFreeTextOptionActive,
						divRef: this.getOptionsLength() - 1 === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
						addText: this.props.addText,
						displayText: this.props.currentInput
					}))))
				}
			}
			var b = n("./src/reddit/icons/svgs/Close/index.tsx"),
				h = n("./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less"),
				f = n.n(h);

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var _ = e => {
					const {
						className: t,
						innerRef: n,
						onClickHandler: s,
						option: r,
						maxLength: o,
						...d
					} = e, c = [f.a.selectedOptionComponentContainer, t];
					return o && o < r.displayText.length && c.push(f.a.selectedOptionComponentContainerError), a.a.createElement("div", g({
						className: Object(i.a)(...c),
						ref: n
					}, d, {
						onClick: s
					}), r.displayText, a.a.createElement(b.a, {
						className: f.a.closeIcon
					}))
				},
				v = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				O = n("./src/reddit/helpers/readOnlyMode/index.ts"),
				x = n("./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less"),
				E = n.n(x);

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const j = 10,
				C = e => e.stopPropagation();
			class k extends a.a.Component {
				constructor(e) {
					super(e), this.handleKeyPress = e => {
						e.which !== d.a.Delete && e.which !== d.a.Backspace || !this.lastSelectedOptionComponentRef.current || "" !== this.props.value || (this.lastSelectedOptionComponentRef.current.focus(), e.preventDefault(), e.stopPropagation())
					}, this.handleMouseEnterSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !0
						})
					}, this.handleMouseLeaveSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !1
						})
					}, this.onSearchBarFocus = e => {
						Object(O.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
							isFocused: !0
						}), this.props.onFocus && this.inputRef.current === e.target && this.props.onFocus())
					}, this.onSearchBarBlur = e => {
						if (this.containerRef.current && e.relatedTarget && this.containerRef.current.contains(e.relatedTarget)) return e.preventDefault(), void e.stopPropagation();
						this.props.onBlur && this.props.onBlur(e), this.setState({
							isFocused: !1
						})
					}, this.inputRef = a.a.createRef(), this.containerRef = a.a.createRef(), this.lastSelectedOptionComponentRef = a.a.createRef(), this.state = {
						isHoveringOverSelectedOption: !1,
						isFocused: !1
					}
				}
				focus() {
					Object(O.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
						isFocused: !0
					}))
				}
				reset() {
					this.inputRef.current && (this.inputRef.current.value = "")
				}
				deselectOption(e) {
					this.props.onOptionsChanged([{
						...e,
						selected: !1
					}]), this.setState({
						isHoveringOverSelectedOption: !1
					})
				}
				onSelectedOptionComponentKeyDown(e, t) {
					this.state.isHoveringOverSelectedOption || e.which !== d.a.Delete && e.which !== d.a.Backspace || (e.preventDefault(), e.stopPropagation(), this.deselectOption(t), this.focus())
				}
				render() {
					const e = {};
					Object(O.c)(this.props.readOnlyMode) || (e.tabIndex = 0);
					const t = this.props.selectedOptionComponent || _,
						n = "number" == typeof this.props.maxOptionsToDisplay && this.props.options.length > this.props.maxOptionsToDisplay;
					return a.a.createElement("div", y({
						"aria-invalid": this.props.isError,
						className: Object(i.a)(this.props.className, E.a.optionSearchBarContainer, {
							[E.a.optionSearchBarError]: this.props.isError,
							[E.a.optionSearchBarReadOnly]: Object(O.c)(this.props.readOnlyMode)
						}),
						ref: this.containerRef,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur
					}, e), this.props.options.map((e, s) => {
						if (!(n && s >= (this.props.maxOptionsToDisplay || 0))) return a.a.createElement(t, {
							tabIndex: 0,
							onFocus: C,
							key: e.id || e.displayText,
							option: e,
							onKeyDown: t => this.onSelectedOptionComponentKeyDown(t, e),
							onClickHandler: () => {
								this.deselectOption(e), this.focus()
							},
							onMouseEnter: this.handleMouseEnterSelectedOptionComponent,
							onMouseLeave: this.handleMouseLeaveSelectedOptionComponent,
							maxLength: this.props.maxLength,
							innerRef: s === this.props.options.length - 1 ? this.lastSelectedOptionComponentRef : void 0
						})
					}), n && a.a.createElement("span", {
						className: E.a.optionsOverflowIndication
					}, `+${this.props.options.length-(this.props.maxOptionsToDisplay||0)}`), this.props.children, !Object(O.c)(this.props.readOnlyMode) && a.a.createElement("input", {
						className: Object(i.a)(E.a.input, {
							[E.a.hiddenInput]: Object(O.b)(this.props.readOnlyMode)
						}),
						ref: this.inputRef,
						type: "text",
						onKeyDown: this.handleKeyPress,
						value: this.props.value,
						onChange: this.props.onInputChanged,
						maxLength: this.props.maxLength
					}), this.props.isLoading && a.a.createElement(v.a, {
						className: E.a.loadingIcon,
						sizePx: j
					}), this.state.isFocused && a.a.createElement(p, {
						className: this.props.dropdownClassName,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						selectableOptions: this.props.selectableOptions,
						onOptionsChanged: this.props.onOptionsChanged,
						ref: this.props.dropdownRef,
						currentInput: this.props.value,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						splitOnCommaPress: this.props.splitOnCommaPress
					}))
				}
			}
			var I = n("./node_modules/reselect/es/index.js");
			const S = [],
				w = {};
			class T extends a.a.Component {
				constructor(e) {
					super(e), this._selectableOptionsSelector = Object(I.a)(e => e.availableOptions || S, e => e.input, (e, t) => e.filter(e => {
						const n = e.displayText.toLowerCase(),
							s = t.toLowerCase();
						return 0 === n.indexOf(s) || r()(n.split(/[\s\/]+/), e => 0 === e.indexOf(s))
					})), this.onSearchBarFocus = () => {
						Object(O.c)(this.props.readOnlyMode) || this.state.searchBarIsFocused || (this.setState({
							searchBarIsFocused: !0
						}), this.props.onSearchBarFocus && this.props.onSearchBarFocus())
					}, this.onSearchBarBlur = e => {
						if (!Object(O.c)(this.props.readOnlyMode)) return e.relatedTarget && this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.matchesDOMElement(e.relatedTarget) ? (e.stopPropagation(), e.preventDefault(), void setTimeout(() => {
							this.optionSearchBarRef.current && this.optionSearchBarRef.current.focus()
						}, 0)) : (this.setState({
							searchBarIsFocused: !1
						}), void(this.props.onSearchBarBlur && this.props.onSearchBarBlur(e)))
					}, this.setInput = e => {
						Object(O.b)(this.props.readOnlyMode) || this.props.input !== e && this.props.onInputChanged(e)
					}, this.onOptionChanged = e => {
						this.onOptionsChanged([e])
					}, this.onOptionsChanged = e => {
						this.props.onOptionsChanged(e), r()(e, e => !!e.selected) && this.setInput("")
					}, this.onInputChanged = e => {
						Object(O.b)(this.props.readOnlyMode) || this.setInput(e.currentTarget.value)
					}, this.onKeyDown = e => {
						Object(O.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handleKeyPress(e)
					}, this.onPaste = e => {
						Object(O.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handlePaste(e)
					}, this.state = {
						searchBarIsFocused: !1
					}, this.optionsListDropdownRef = a.a.createRef(), this.optionSearchBarRef = a.a.createRef()
				}
				getSelectableOptions() {
					return this._selectableOptionsSelector(this.props)
				}
				render() {
					const {
						childClassNames: e = w
					} = this.props;
					return a.a.createElement("div", {
						className: this.props.className,
						onKeyDown: this.onKeyDown,
						onPaste: this.onPaste
					}, a.a.createElement(k, {
						className: e.searchBarClassName,
						dropdownClassName: e.optionsListDropdownClassName,
						isError: this.props.isError,
						readOnlyMode: this.props.readOnlyMode || O.a.editable,
						isLoading: this.props.isLoading,
						ref: this.optionSearchBarRef,
						options: this.props.selectedOptions,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur,
						onOptionsChanged: this.onOptionsChanged,
						onInputChanged: this.onInputChanged,
						maxLength: this.props.maxOptionLength,
						maxOptionsToDisplay: this.props.maxOptionsToDisplay,
						value: this.props.input,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						selectableOptions: this.getSelectableOptions(),
						dropdownRef: this.optionsListDropdownRef,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: this.props.splitOnCommaPress
					}, this.props.children))
				}
			}
			t.a = T
		},
		"./src/reddit/components/MutedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				BannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				bannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				EmptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				emptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				ExpandedContainer: "_1EEdKUOD4OiTBBQQkot-L9",
				expandedContainer: "_1EEdKUOD4OiTBBQQkot-L9"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				primaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				ModalText: "_3P1niYqJc2au-fmA-xIl7i",
				modalText: "_3P1niYqJc2au-fmA-xIl7i"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/subredditModeration/mute.ts"),
				l = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/TextButton/index.tsx"),
				h = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				f = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				g = n("./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less"),
				_ = n.n(g);
			const v = 300,
				O = Object(a.b)(null, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						onMuteUser: (t, s) => e(Object(c.a)(n, t, s))
					}
				}),
				x = d.a.wrapped(p.l, "PrimaryButton", _.a),
				E = d.a.wrapped(u.p, "ModalText", _.a);
			class y extends o.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onReasonChange = e => {
						this.setState({
							reason: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = this.state.username;
						this.props.onMuteUser(e, this.state.reason), this.props.trackAddEvent(), this.props.toggleModal()
					}, this.state = {
						username: this.props.username || "",
						reason: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(u.e, null, o.a.createElement(u.i, null, o.a.createElement(f.a, null, o.a.createElement(u.q, null, s.fbt._("Mute user", null, {
						hk: "326ljo"
					}), e.username && `: u/${e.username}`), o.a.createElement(b.a, {
						onClick: e.toggleModal
					}, o.a.createElement(u.b, null)))), o.a.createElement(u.l, null, !e.username && o.a.createElement(u.h, null, o.a.createElement(m.d, {
						autoFocus: !0,
						placeholder: s.fbt._("Username to mute", null, {
							hk: "3GB7UW"
						}),
						onChange: this.onUsernameChange,
						value: this.state.username,
						"data-redditstyle": !0
					})), o.a.createElement(u.h, null, o.a.createElement(E, null, s.fbt._("Note about why they are muted", null, {
						hk: "12YIn5"
					})), o.a.createElement(u.f, null, s.fbt._("Only visible to other moderators. Not visible to user", null, {
						hk: "4Ahum2"
					}))), o.a.createElement(u.t, {
						maxLength: v,
						onChange: this.onReasonChange,
						placeholder: s.fbt._("Reason they were muted", null, {
							hk: "3E29Hf"
						}),
						value: this.state.reason,
						"data-redditstyle": !0
					}), o.a.createElement(l.a, {
						maxChars: v,
						text: this.state.reason
					})), o.a.createElement(u.g, null, o.a.createElement(u.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(x, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(h.a)(t.username)
					}, s.fbt._("Mute user", null, {
						hk: "1z1Ss8"
					}))))
				}
			}
			t.default = Object(i.a)(O(y))
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~CommentsPage~ModerationPages~Reddit~reddit-components-ClassicPost~reddit-components-CompactP~d737df3e"), n.e("vendors~CommentsPage~Governance~ModListing~ModerationPages~Reddit~Subreddit"), n.e("vendors~ModerationPages"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Mem~c8b748a6"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("CollectionCommentsPage~CommentsPage~ModerationPages~PostCreation~ProfileComments~ProfileOverview~Pro~d39c0d57"), n.e("ModerationPages")]).then(n.bind(null, "./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/MutedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				MuteIcon: "XHViv8EEjdjsATc3T66r9",
				muteIcon: "XHViv8EEjdjsATc3T66r9"
			}
		},
		"./src/reddit/components/MutedUserList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditModeration/mute.ts"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				p = n("./src/reddit/components/HumanDate/index.tsx"),
				b = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/Scroller/Simple.tsx"),
				_ = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				x = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				j = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/muted.ts"),
				k = n("./src/reddit/components/MutedUserList/ExpandedComponent.m.less"),
				I = n.n(k),
				S = n("./src/lib/lessComponent.tsx");
			const {
				fbt: w
			} = n("./node_modules/fbt/lib/FbtPublic.js"), T = S.a.span("BannedBy", I.a), N = S.a.span("EmptyState", I.a), P = S.a.div("ExpandedContainer", I.a);
			var R = e => a.a.createElement(P, null, e.reason ? a.a.createElement(T, null, w._("Mod note {mutedByUsername}", [w._param("mutedByUsername", e.mutedBy)], {
					hk: "15D34v"
				})) : a.a.createElement(N, null, w._("No mod note.", null, {
					hk: "3rpIuv"
				})), e.reason),
				A = n("./src/reddit/components/MutedUserList/MuteUserModal/index.tsx"),
				M = n("./src/reddit/components/MutedUserList/index.m.less"),
				D = n.n(M);
			const L = 24,
				F = Object(d.c)({
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(j.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(j.a)(e),
					loadMoreToken: C.d,
					mutedUsers: C.g,
					mutedUsersListPending: C.c,
					searchPending: C.e,
					searchResult: C.f
				}),
				U = Object(i.b)(F, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(u.b)(n, {
							after: t
						})),
						searchForMutedUser: t => e(Object(u.c)(n, t)),
						toggleAddUserModal: () => e(Object(l.i)("ModerationPage--Modal--AddUser")),
						toggleUnmuteUserModal: () => e(Object(l.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						unmuteUser: t => () => e(Object(u.d)(n, t))
					}
				});
			class B extends a.a.Component {
				constructor(e) {
					super(e), this.onSearch = e => {
						this.props.searchForMutedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.unmuteToggled = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.sendEventWithName("edit_user")(), this.props.toggleUnmuteUserModal()
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.muteUser = () => {
						this.props.toggleAddUserModal(), this.props.sendEventWithName("mute_dialog_mutepage")()
					}, this.renderMutedUser = e => a.a.createElement(O.b, {
						description: e.reason,
						expandedComponent: a.a.createElement(R, {
							mutedBy: e.mutedBy,
							reason: e.reason
						}),
						pageName: c.gc.Muted,
						primaryButton: a.a.createElement(x.r, {
							onClick: this.unmuteToggled(e.id, e.username)
						}, r.fbt._("Unmute", null, {
							hk: "334kKM"
						})),
						subredditId: this.props.subredditId,
						timeAgo: a.a.createElement(p.d, {
							seconds: e.mutedAtUTC
						}),
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderMuteUserModal = () => a.a.createElement(A.a, {
						ignoreDefaultFocus: !0,
						trackAddEvent: this.props.sendEventWithName("add_mutepage"),
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						withOverlay: !0
					}), this.state = y.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, {
						mutedUsers: n
					} = e;
					let o;
					return n.length && (o = n[n.length - 1].id), e.mutedUsers.length ? a.a.createElement(a.a.Fragment, null, a.a.createElement(f.c, null, a.a.createElement(x.l, {
						onClick: this.muteUser
					}, r.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), a.a.createElement(f.a, null, a.a.createElement(f.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), a.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), a.a.createElement(v.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}), t.searchTerm ? a.a.createElement(_.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderMutedUser(e.searchResult)) : a.a.createElement(g.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, e.mutedUsers.map((e, t) => ({
						estHeight: L,
						id: e.id,
						render: () => this.renderMutedUser(e)
					})))), e.isAddUserModalOpen && this.renderMuteUserModal(), e.isConfirmModalOpen && t.userId && t.username && a.a.createElement(m.a, {
						actionText: r.fbt._("Unmute", null, {
							hk: "334kKM"
						}),
						modalText: r.fbt._("Are you sure you want to unmute {username}?", [r.fbt._param("username", t.username)], {
							hk: "2Pq8hv"
						}),
						onConfirm: e.unmuteUser(t.userId),
						toggleModal: e.toggleUnmuteUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : a.a.createElement(a.a.Fragment, null, a.a.createElement(f.c, null, a.a.createElement(x.l, {
						onClick: this.muteUser
					}, r.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), a.a.createElement(f.a, null, a.a.createElement(f.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), a.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.mutedUsersListPending ? a.a.createElement(O.a, null) : a.a.createElement(b.c, {
						text: r.fbt._("No muted users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1o0lOP"
						})
					}, a.a.createElement(E.a, {
						name: "mod_mute",
						className: D.a.MuteIcon
					})), e.isAddUserModalOpen && this.renderMuteUserModal()))
				}
			}
			t.a = U(B)
		},
		"./src/reddit/components/NotificationUnit/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NotificationUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("NotificationUnit").then(n.bind(null, "./src/reddit/components/NotificationUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/NotificationUnit/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/NotificationUnit/Placeholder.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/NotificationUnit/index.m.less"),
				a = n.n(o);
			const i = () => r.a.createElement("li", {
					className: a.a.placeholderWrapper
				}, r.a.createElement("span", {
					className: a.a.placeholderAvatar
				}), r.a.createElement("span", {
					className: a.a.placeholderContent
				})),
				d = () => r.a.createElement("ol", null, r.a.createElement(i, null), r.a.createElement(i, null), r.a.createElement(i, null))
		},
		"./src/reddit/components/NotificationUnit/index.m.less": function(e, t, n) {
			e.exports = {
				notificationItem: "_3mUSJN4kdLCGjq-K-JLJw",
				unread: "_2n4UrzwZ3VBdRmFUYAHF_9",
				isNightMode: "_3ds5pVvIyBrh1GgQ2O7AFd",
				contextContainer: "_3T3J7R8JnlSfiFdB5bxe5h",
				link: "_1tpiOc0IxpDU113wUs4zi1",
				inAppNotification: "_3U799isaNx88b2pVv1S7m1",
				avatarContainer: "_2WN4-UdVoyjpLQ8mpNTQA",
				avatar: "_12V0IULSx8mSJHxdpHwOGE",
				nsfwAvatar: "_1Bzw8F6BC4Vk8OzAgnU0z3",
				notificationIconContainer: "_3smo-GSstogGTGh6ArpwI0",
				NotifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				notifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				RedditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				redditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				Separator: "_1caKsZ5CCRPSfIgoh608Ej",
				separator: "_1caKsZ5CCRPSfIgoh608Ej",
				topBar: "_3mGSd8RyCZhF_eqyrV_Bvk",
				TitleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				titleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				title: "_180jOSBDwwE60X5UR8zt3-",
				"m-tooltip": "_2a8MIP8QlMF7KPqTup62Vt",
				mTooltip: "_2a8MIP8QlMF7KPqTup62Vt",
				timeAgo: "_2fQXbzOYQuzqlwMzxgtBKH",
				menuButton: "_8Q653FSGz7lD9Ux0AQsXY",
				isOpen: "WHFiF_asC8mzlevTdJv26",
				MenuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				menuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				contentContainer: "_3Q_e75oXJ8meqWwAQS36l2",
				body: "_2VDnxV3G5ZvEDq10Z-_fM9",
				ButtonIcon: "_25ecrisK-bGTesa4kIqyHR",
				buttonIcon: "_25ecrisK-bGTesa4kIqyHR",
				ReplyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				replyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				notificationButton: "_3doOacPPJ-LU-aBSoLl9TV",
				isFullWidth: "_36xH7NkS9uRrlN87iMo6Bw",
				isUnread: "_2svu3lh5YfWQmYfACdB2J5",
				replyIcon: "_3LbCSOW9yuZK_CHzTuR9M5",
				postIcon: "_102yZEdZMcXLlu2Ri0KD9O",
				postEmbedContainer: "_1cndvAxAFPMUr8IaWuw_we",
				postEmbedContent: "_2fsQOzhZpW9XNu1RXtgzqW",
				deleted: "LypGzp3NJwjpkpsRn9Ocn",
				postEmbedTitleContainer: "_2XT3C7unUlQXgaiyeYfIYv",
				postEmbedTitle: "_1SZwyv3jy4dBipT0yC1CcI",
				postEmbedMeta: "_1LcCO3y9JhylZFlKsgvzHs",
				postEmbedBlurredThumbnailContainer: "_2EmrjrpYxkgB5_ljritGbO",
				postEmbedThumbnail: "msJLWFmahK0W8JhaqYny9",
				postEmbedThumbnailBase: "_3CGVcVQDu97m9Oj_xs0n01",
				postEmbedBlurredThumbnail: "_2a0rc3KL05PEnGmVWcQI8W",
				postEmbedNSFWThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				postEmbedNsfwThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				WarningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				warningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				StyledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				styledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				overflowMenuContainer: "_2UKt6pQu-os9uxZnfhPydP",
				overflowMenuOption: "_1g8x_Z2KsTf65RBk7dRBZm",
				placeholderWrapper: "_2iacm7sPgvO9z8gO1W7FoY",
				placeholderAvatar: "_2_cDiTNVpitX7CtTmIambB",
				placeholderContent: "_2KpinIkIJ7VxNGQgUgzJCA",
				glimmer: "_27pfB7o_o_4F4TdujFhrNO",
				PostUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				postUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				StateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				stateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				Text: "_2bba9zuFqUwxMhGdswkU86",
				text: "_2bba9zuFqUwxMhGdswkU86"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.m.less": function(e, t, n) {
			e.exports = {
				RecommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				recommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				classicLayout: "_3gsfwiq-rM6zSz9YoMlnJ0",
				compactLayout: "_9huHAs0mdMzeF-pUhJbwX",
				largeLayout: "_3hWVRt6y8PqOoC2VuZETZI"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/objectSelector/index.ts"),
				i = n("./src/reddit/components/RichTextJson/index.tsx"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/hooks/useRecommendationPostContext.ts"),
				l = n("./src/reddit/components/OneFeed/PostRecommendationContext.m.less"),
				u = n.n(l);
			const m = Object(a.b)(e => ({
				renderingObjectInfo: e
			}));
			t.a = e => {
				let {
					content: t,
					layout: n,
					post: s
				} = e;
				return Object(c.a)().hideRecommendationContext ? null : r.a.createElement(i.b, {
					className: Object(o.a)(u.a.RecommendationContextStyles, {
						[u.a.classicLayout]: n === d.g.Classic,
						[u.a.compactLayout]: n === d.g.Compact,
						[u.a.largeLayout]: n === d.g.Large
					}),
					content: t,
					rtJsonElementProps: m(s),
					useExplicitTextColor: !0
				})
			}
		},
		"./src/reddit/components/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				_Dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				MenuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				menuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				mIsEnabled: "uMPgOFYlCc5uvpa2Lbteu",
				MenuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				menuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				DropdownRow: "_2DO72U0b_6CUw3msKGrnnT",
				dropdownRow: "_2DO72U0b_6CUw3msKGrnnT"
			}
		},
		"./src/reddit/components/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				h = n("./src/reddit/selectors/tooltip.ts"),
				f = n("./src/reddit/components/OverflowMenu/index.m.less"),
				g = n.n(f);
			const _ = c.a.wrapped(m.a, "_Dropdown", g.a),
				v = Object(u.a)(_),
				O = c.a.button("MenuButton", g.a),
				x = c.a.wrapped(p.b, "DropdownRow", g.a),
				E = Object(i.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(h.b)(n)(e)
					}
				}),
				y = Object(a.b)(E, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(l.h)({
							tooltipId: n
						}))
					}
				}),
				j = e => t => {
					e.onClick && e.onClick(), e.toggleDropdown(), t.stopPropagation()
				};
			t.b = y(e => o.a.createElement(O, {
				"aria-expanded": e.dropdownIsOpen,
				"aria-haspopup": !0,
				"aria-label": s.fbt._("more options", null, {
					hk: "2EnY1x"
				}),
				className: Object(d.a)(e.className, {
					[g.a.mIsEnabled]: !e.disabled && !e.defaultButtonOutline
				}),
				disabled: e.disabled,
				onClick: j(e),
				onMouseDown: e.handleMouseDown,
				id: e.dropdownId
			}, e.icon ? e.icon : o.a.createElement(b.a, {
				name: "overflow_horizontal",
				className: g.a.MenuIcon
			}), o.a.createElement(v, {
				className: e.dropdownClassName,
				isOpen: e.dropdownIsOpen,
				tooltipId: e.dropdownId,
				isFixed: e.isFixed,
				targetPosition: e.targetPosition,
				tooltipPosition: e.tooltipPosition,
				style: e.style
			}, e.children)))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				a = n("./src/reddit/constants/elementIds.ts"),
				i = n("./src/reddit/contexts/InsideOverlay.tsx");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e, t) {
				const n = Object(o.a)(e, t);
				class s extends r.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(a.e);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return r.a.createElement(n, d({}, this.props, {
							container: this.state.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(i.b)(s)
			}
		},
		"./src/reddit/components/Paginator/index.m.less": function(e, t, n) {
			e.exports = {
				controlRow: "_2ixigr45sqDsYvVlMBgbMm",
				nextButtonContainer: "CloCv22o0KvzOk8LzB4VX",
				prevButtonContainer: "_2Tfdm_mlb1NvgbaCCkMtdV",
				nextButton: "_1VFGYMJpiKtL_S9_RYS-CD",
				prevButton: "eX92mTA_HDG9gpfIzIGhs"
			}
		},
		"./src/reddit/components/Poll/PollExpiry/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/HumanDate/index.tsx"),
				o = n("./src/lib/timeUntil/index.ts"),
				a = n("./node_modules/react/index.js"),
				i = n.n(a);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function c(e) {
				const t = new Date(e.poll.endsAt).getTime() - Date.now() <= 0;
				return i.a.createElement("span", {
					className: e.className
				}, t ? d._("Voting closed {timeAgo}", [d._param("timeAgo", i.a.createElement(r.d, {
					seconds: e.poll.endsAt / s.Sb
				}))], {
					hk: "3OERID"
				}) : Object(o.a)(new Date(e.poll.endsAt)))
			}
		},
		"./src/reddit/components/Poll/PostTitleMetaData/index.m.less": function(e, t, n) {
			e.exports = {
				proposalMetaData: "_3yYOHq_rWQcgaR_pinEQU7",
				proposalExpiry: "_1poH87fXNrjNu84jKXBtun"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				backgroundWrapper: "_1poyrkZ7g36PawDueRza-J",
				badge: "_1lLKAbRNH1mm32sVm7yCzQ"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				d = n("./src/reddit/components/PostBackgroundWrapper/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(a.a)(e => {
				const {
					children: t,
					className: n,
					flairStyleTemplate: s,
					onClick: a,
					post: d,
					redditStyle: u,
					theme: m,
					...p
				} = e;
				return r.a.createElement("div", l({
					className: Object(o.a)(c.a.backgroundWrapper, n),
					style: Object(i.c)(s, e),
					onClick: a
				}, p), t)
			})
		},
		"./src/reddit/components/PostContainer/index.m.less": function(e, t, n) {
			e.exports = {
				WrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz",
				wrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz"
			}
		},
		"./src/reddit/components/PostContainer/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/ads/index.ts"),
				i = n("./src/reddit/components/AdViewability/index.tsx"),
				d = n("./src/reddit/helpers/trackers/gallery.ts"),
				c = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				l = n("./src/reddit/hooks/useTracking.ts");
			var u = r.a.memo(e => {
					const t = Object(s.useRef)(null),
						n = Object(l.a)(),
						o = Object(s.useCallback)(t => {
							t.forEach(t => {
								const {
									intersectionRatio: s
								} = t;
								s >= .5 && n(d.d(e.postId))
							})
						}, [n, e.postId]),
						a = Object(s.useMemo)(() => ({
							threshold: [.5]
						}), []);
					return Object(c.a)(t, o, a), r.a.createElement("div", {
						role: "presentation"
					}, r.a.createElement("div", {
						ref: t
					}, e.children))
				}),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/connectors/PostViewable/index.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/selectors/posts.ts"),
				f = n("./src/reddit/selectors/telemetry.ts"),
				g = n("./src/lib/classNames/index.ts"),
				_ = n("./src/lib/objectSelector/index.ts"),
				v = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				O = n("./src/reddit/components/PostContainer/index.m.less"),
				x = n.n(O);
			const E = Object(p.a)(() => Object(o.c)({
					basePixelMetadata: Object(_.a)((e, t) => {
						let {
							post: n
						} = t;
						return Object(h.b)(e, n.id)
					}),
					clickTrackingId: (e, t) => {
						let {
							post: n
						} = t;
						return n.id
					},
					imageGalleryCurrentItem: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.i)(e, {
							postId: n.id
						})
					},
					pageType: e => Object(f.d)(e).pageType
				})),
				y = "post-container";
			class j extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						basePixelMetadata: t,
						children: n,
						className: s,
						imageGalleryCurrentItem: o,
						makePostContainerId: c,
						post: l,
						onClick: m,
						pageType: p,
						sendEvent: h,
						style: f,
						ref: _,
						shouldAddGalleryViewability: v = !0
					} = this.props, O = r.a.createElement("div", {
						"data-click-id": this.props["data-click-id"],
						style: f,
						ref: _,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3))
						},
						onClick: n => {
							if (!this.cancelClick && n.button < 2 && e(() => m && m(n, l, t, o, p))(n), l.id && o) {
								const {
									source: e
								} = Object(a.t)(l, o);
								e && e.outboundUrl && h(Object(d.c)(l.id, e.outboundUrl))
							}
						},
						className: Object(g.a)(x.a.WrappedPost, s, `Post ${l.id}`, {
							promotedlink: l.isSponsored
						}),
						"data-testid": y,
						id: c ? c(l.id) : l.id,
						tabIndex: -1
					}, n), E = !!l.media && l.media.type === b.o.VIDEO;
					return (e => l.media && Object(b.E)(l.media) && v ? r.a.createElement(u, {
						postId: l.id
					}, e) : e)((e => l.isSponsored || E ? r.a.createElement(i.a, {
						post: l,
						trackDisplay: !0
					}, e) : e)(O))
				}
			}
			t.a = E(Object(v.a)(Object(m.c)(j)))
		},
		"./src/reddit/components/PostContent/ViewCount.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/prettyPrintNumber/index.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/selectors/creatorStats.ts"),
				u = n("./src/reddit/components/PostContent/viewCount.m.less"),
				m = n.n(u);
			t.a = e => {
				let {
					className: t,
					post: n,
					showViewCount: r
				} = e;
				const {
					upvotePercentString: u,
					viewCountString: p
				} = (e => {
					const t = e.upvoteRatio ? Math.round(100 * e.upvoteRatio).toString() : "",
						n = Object(d.b)(e.viewCount);
					return {
						upvotePercentString: s.fbt._("{percent upvoted}% Upvoted", [s.fbt._param("percent upvoted", t)], {
							hk: "432tjJ"
						}),
						viewCountString: s.fbt._({
							"*": "{number of views} Views",
							_1: "1 View"
						}, [s.fbt._plural(e.viewCount, "number of views", n)], {
							hk: "rP01m"
						})
					}
				})(n), b = r && !!n.viewCount, h = Object(a.e)(e => Object(l.a)(e, n.id)), f = Object(a.e)(e => Object(l.c)(e, n.id)), g = Object(c.c)(n, f), _ = h && g === c.b.Available;
				return o.a.createElement("div", {
					className: Object(i.a)(m.a.viewCounts, t)
				}, b && o.a.createElement("span", null, p), b && !!n.upvoteRatio && o.a.createElement("span", {
					className: m.a.dotSpacer
				}), !!n.upvoteRatio && !_ && o.a.createElement("span", null, u))
			}
		},
		"./src/reddit/components/PostContent/viewCount.m.less": function(e, t, n) {
			e.exports = {
				dotSpacer: "_3g_cwSqBe5o5mAuhfMeGu5",
				viewCounts: "t4Hq30BDzTeJ85vREX7_M"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/lib/memoizeByReference/index.ts"),
				u = n("./src/reddit/actions/postCreation/general.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/icons/svgs/Close/index.tsx"),
				g = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				_ = n("./src/reddit/icons/svgs/Search/index.tsx"),
				v = n("./src/reddit/layout/row/Inline/index.tsx"),
				O = n("./src/reddit/models/PostCreationForm/index.ts"),
				x = n("./src/reddit/selectors/postCollection.ts"),
				E = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				y = n("./src/reddit/components/HumanDate/index.tsx"),
				j = n("./src/reddit/helpers/name/index.ts"),
				C = n("./src/reddit/models/Subreddit/index.ts"),
				k = n("./src/reddit/models/User/index.ts"),
				I = n("./src/reddit/selectors/subreddit.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				T = n.n(w),
				N = n("./src/lib/lessComponent.tsx");
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), R = N.a.div("Container", T.a), A = N.a.h2("PostTitle", T.a), M = N.a.div("MetaLine", T.a), D = N.a.span("SubredditName", T.a), L = N.a.time("InfoSpan", T.a), F = Object(d.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: n
						}
					} = t;
					return n ? Object(I.U)(e, {
						subredditId: n
					}) : void 0
				},
				user: S.k
			});
			class U extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: n,
						onHoverActionText: s
					} = this.props, r = t && Object(C.h)(t) && n ? Object(j.d)(Object(k.e)(n)) : t ? t.displayText : "", o = e.postIds.length;
					return a.a.createElement(R, {
						onClick: this.onClick,
						className: T.a.container
					}, a.a.createElement(A, {
						"data-redditstyle": !0
					}, e.title), a.a.createElement(M, {
						"data-redditstyle": !0
					}, r && a.a.createElement(D, {
						"data-redditstyle": !0
					}, r), r && a.a.createElement(E.b, null), a.a.createElement(L, null, P._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [P._plural(o, "number of posts")], {
						hk: "1Uy96U"
					})), a.a.createElement(E.b, null), a.a.createElement(L, null, P._("created {time}", [P._param("time", a.a.createElement(y.d, {
						seconds: e.createdAtUTC
					}))], {
						hk: "2cUc5m"
					}))), s && a.a.createElement("div", {
						className: T.a.onHoverActionText
					}, a.a.createElement("span", null, s)))
				}
			}
			var B = Object(i.b)(F)(U),
				G = n("./src/reddit/helpers/trackers/postCollection.ts"),
				H = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				W = n.n(H);
			const q = `${s.a.assetPath}/img/snoo-drafts.png`,
				V = N.a.div("TopRow", W.a),
				z = N.a.div("TitleRow", W.a),
				K = N.a.div("DetailsContainer", W.a),
				Q = N.a.wrapped(v.a, "ButtonRow", W.a),
				J = N.a.div("CloseWrapper", W.a),
				Y = N.a.wrapped(f.a, "Close", W.a),
				X = N.a.div("Empty", W.a),
				Z = N.a.img("EmptyImage", W.a),
				$ = N.a.p("EmptyText", W.a),
				ee = N.a.div("FilterWrapper", W.a),
				te = N.a.wrapped(h.a, "FilterInput", W.a),
				ne = N.a.wrapped(_.a, "SearchIcon", W.a),
				se = N.a.wrapped(g.a, "PlusIcon", W.a),
				re = N.a.wrapped(b.p, "CreateCollectionButton", W.a),
				oe = Object(l.a)((e, t) => {
					const n = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(n))
				}),
				ae = Object(d.c)({
					collections: x.v
				}),
				ie = Object(i.b)(ae, (e, t) => {
					let {
						postId: n,
						isOverlay: s
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = O.b;
							n && (t = Object(O.u)(n, !!s)), e(Object(u.z)(t))
						}
					}
				});
			class de extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(G.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === p.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(G.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(G.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => a.a.createElement(B, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(G.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return a.a.createElement(X, null, a.a.createElement(Z, {
						src: q
					}), a.a.createElement($, null, r.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return a.a.createElement(X, null, a.a.createElement($, null, r.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let n;
					if (0 === e.length) n = this.renderNoCollections();
					else {
						const t = oe(e, this.state.filterStr);
						n = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return a.a.createElement("div", {
						className: W.a.wrapper,
						"data-redditstyle": !0
					}, a.a.createElement(V, null, a.a.createElement(z, {
						"data-redditstyle": !0
					}, t || r.fbt._("My collections", null, {
						hk: "3yKovS"
					}), a.a.createElement(J, {
						onClick: this.close
					}, a.a.createElement(Y, {
						"data-redditstyle": !0
					}))), a.a.createElement(ee, null, a.a.createElement(ne, null), a.a.createElement(te, {
						placeholder: r.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), a.a.createElement(K, null, n), a.a.createElement(Q, null, a.a.createElement(re, {
						onClick: this.handleCreateCollectionClicked
					}, a.a.createElement(se, null), r.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const ce = Object(c.a)(ie(Object(m.c)(de)));
			t.a = ce
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/reddit/actions/postCollection/index.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/constants/postCreation.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/index.tsx"),
				h = n("./src/reddit/controls/Input/index.tsx"),
				f = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				g = n("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				_ = n("./src/reddit/icons/svgs/Close/index.tsx"),
				v = n("./src/reddit/layout/row/Inline/index.tsx"),
				O = n("./src/reddit/selectors/postCollection.ts"),
				x = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				E = n.n(x),
				y = n("./src/lib/lessComponent.tsx");
			const j = y.a.div("Container", E.a),
				C = y.a.div("Content", E.a),
				k = y.a.div("TitleRow", E.a),
				I = y.a.div("Details", E.a),
				S = y.a.wrapped(u.g, "Footer", E.a),
				w = y.a.wrapped(p.o, "CancelButton", E.a),
				T = y.a.div("CloseWrapper", E.a),
				N = y.a.wrapped(_.a, "CloseIcon", E.a),
				P = y.a.label("Label", E.a),
				R = y.a.wrapped(h.a, "TitleInput", E.a),
				A = y.a.wrapped(g.a, "AddCollectionIcon", E.a),
				M = y.a.wrapped(p.l, "PrimaryActionButton", E.a),
				D = y.a.wrapped(f.a, "LoadingIcon", E.a),
				L = y.a.wrapped(b.b, "ErrorText", E.a),
				F = Object(i.c)({
					collection: O.q,
					error: O.c,
					isPending: O.g
				}),
				U = Object(a.b)(F, (e, t) => ({
					onCreate: (t, n) => e(Object(l.b)(t, n)),
					onUpdate: n => e(Object(l.h)(t.collectionId, n))
				}));
			class B extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: n
						} = this.state;
						if (e) {
							await this.props.onUpdate(n) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(n, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: n
					} = this.props, r = !e, a = !!this.state.collectionTitle.trim(), i = r ? s.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : s.fbt._("Save", null, {
						hk: "4yMsMq"
					});
					return o.a.createElement(j, null, o.a.createElement(T, {
						onClick: this.props.onCancel
					}, o.a.createElement(N, null)), o.a.createElement(C, null, r && o.a.createElement(o.a.Fragment, null, o.a.createElement(k, null, o.a.createElement(A, null), s.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), o.a.createElement(I, null, s.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), o.a.createElement(P, null, r ? s.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : s.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), o.a.createElement(R, {
						maxLength: m.e,
						onChange: this.onTitleChange,
						placeholder: s.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), o.a.createElement(S, null, o.a.createElement(v.a, null, o.a.createElement(w, {
						onClick: this.props.onCancel
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(M, {
						onClick: this.onPrimaryButtonClick,
						disabled: n || !a
					}, n ? o.a.createElement(D, {
						sizePx: 10
					}) : i)), t && o.a.createElement(L, null, Object(c.a)(t))))
				}
			}
			t.a = Object(d.a)(U(B))
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = 20,
				r = 180
		},
		"./src/reddit/components/PostFlairPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/flair.ts"),
				a = n("./src/reddit/helpers/flair.ts"),
				i = n("./src/reddit/models/Flair/index.ts");
			const d = e => (e || []).find(e => e.type === i.f.Text || e.type === i.f.Image || e.type === i.f.Richtext);
			var c;
			! function(e) {
				e[e.InvalidTemplate = 0] = "InvalidTemplate", e[e.NoChanges = 1] = "NoChanges", e[e.NotSelected = 2] = "NotSelected", e[e.TextIsNotAllowed = 3] = "TextIsNotAllowed", e[e.TextIsEmpty = 4] = "TextIsEmpty", e[e.TextIsTooLong = 5] = "TextIsTooLong"
			}(c || (c = {}));
			const l = (e, t, n) => {
				if (n && !t) return {
					canSave: !0
				};
				if (!t) return {
					canSave: !1,
					reason: c.NotSelected
				};
				const s = e && t.templateId ? e[t.templateId] : void 0;
				if (!s) return {
					canSave: !1,
					reason: c.InvalidTemplate
				};
				const i = Object(a.g)(t).length;
				return 0 === i ? {
					canSave: !1,
					reason: c.TextIsEmpty
				} : i > o.g ? {
					canSave: !1,
					reason: c.TextIsTooLong
				} : Object(a.n)(t) && !Object(a.r)(s) ? {
					canSave: !1,
					reason: c.TextIsNotAllowed
				} : r()(n, t) ? {
					canSave: !1,
					reason: c.NoChanges
				} : {
					canSave: !0
				}
			}
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, n) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return j
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/TrackingHelper/index.tsx"),
				l = n("./src/higherOrderComponents/asModal/index.tsx"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				p = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				b = n("./src/reddit/components/FlairPreview/index.tsx"),
				h = n("./src/reddit/components/FlairSearch/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/helpers/trackers/postComposer.ts"),
				_ = n("./src/reddit/models/Flair/index.ts"),
				v = n("./src/reddit/selectors/postFlair.ts"),
				O = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/components/PostFlairPicker/helpers.ts"),
				E = n("./src/reddit/components/PostFlairPicker/index.m.less"),
				y = n.n(E);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(s || (s = {}));
			const j = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.UNSET;
					return `PostFlair__Modal-[postId: ${e}]-isOverlay[${t}]-position[${n}]`
				},
				C = Object(d.c)({
					flairData: v.d,
					subreddit: O.U
				});
			class k extends a.a.Component {
				constructor(e) {
					super(e), this.trackEvent = () => {
						this.props.sendEvent(Object(g.F)(this.props.subredditId))
					}, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.trackEvent()
					}, this.onClear = () => {
						this.props.sendEvent(Object(g.b)()), this.setSelectedFlair(null)
					}, this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					};
					const t = Object(x.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, n = Object(x.c)(this.props.flairs) || null;
					return Object(x.b)(e, t, n)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: n,
						flairData: s,
						subreddit: o
					} = e, i = o.displayText, {
						templates: d,
						templateIds: c
					} = s, {
						canSave: l
					} = this.canSave();
					return a.a.createElement(p.a, {
						className: n
					}, a.a.createElement(m.a, {
						onClosePressed: e.closeModal,
						title: r.fbt._("Select {subredditName} flair", [r.fbt._param("subredditName", i)], {
							hk: "1lDMWS"
						})
					}), a.a.createElement(b.a, {
						flair: t,
						flairTemplateType: _.d.LinkFlair,
						placeholderText: r.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), a.a.createElement(h.a, {
						flair: t,
						flairTemplateType: _.d.LinkFlair,
						subredditId: o.id,
						templates: d,
						templateIds: c,
						onChange: this.setSelectedFlair
					}), a.a.createElement("div", {
						className: y.a.buttonsRow
					}, a.a.createElement(f.l, {
						disabled: !l,
						onClick: this.onApply
					}, r.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), a.a.createElement(f.o, {
						className: y.a.clearButton,
						onClick: this.onClear
					}, r.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const I = Object(i.b)(C, (e, t) => ({
				closeModal: () => e(Object(u.i)(t.modalId))
			}))(k);
			t.a = Object(l.a)(Object(c.c)(I))
		},
		"./src/reddit/components/PostFollow/index.m.less": function(e, t, n) {
			e.exports = {
				collectionFollow: "_1yF34mDRcD_ii0n-Ak0OdI",
				isFollowed: "gBrTiaH_Z7HT5D96vnUfJ",
				isEventFollow: "_1iTFEDTdpF-KFmOZvDuGHH"
			}
		},
		"./src/reddit/components/PostFollow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/post.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/helpers/trackers/postCollection.ts"),
				m = n("./src/reddit/components/PostFollow/index.m.less"),
				p = n.n(m);
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.onFollowClick = () => {
						const {
							isEventFollow: e,
							onFollow: t,
							post: {
								id: n,
								isFollowed: s
							},
							sendEvent: r
						} = this.props, o = !!s;
						r(e ? Object(u.o)({
							postId: n,
							isFollowed: o
						}) : Object(u.g)({
							postId: n,
							isFollowed: o
						})), t && t()
					}, this.onMouseEnter = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !1
						})
					}, this.state = {
						isHovered: !1
					}
				}
				render() {
					const {
						className: e,
						isEventFollow: t,
						post: n
					} = this.props, r = this.state.isHovered, a = n.isFollowed;
					let i = a ? s.fbt._("Followed", null, {
						hk: "2oc9IH"
					}) : s.fbt._("Follow", null, {
						hk: "NkunG"
					});
					return a && r && (i = s.fbt._("Unfollow", null, {
						hk: "2sJ8xn"
					})), o.a.createElement("button", {
						className: Object(d.a)(p.a.collectionFollow, {
							[p.a.isFollowed]: !!n.isFollowed,
							[p.a.isEventFollow]: t
						}, e),
						onClick: this.onFollowClick,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, i)
				}
			}
			const h = Object(a.b)(() => Object(i.c)({}), (e, t) => {
				let {
					post: n
				} = t;
				return {
					onFollow: () => e(Object(c.A)(n.isSponsored ? n.postId : n.id))
				}
			})(Object(l.c)(b))
		},
		"./src/reddit/components/PostMedia/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/CrosspostBox/index.tsx"),
				a = n("./src/reddit/components/Media/index.tsx");

			function i(e) {
				const {
					post: t
				} = e;
				return t.crosspostRootId ? r.a.createElement(o.c, {
					postId: t.crosspostRootId,
					mediaProps: {
						...e,
						availableWidth: e.availableWidth ? e.availableWidth - 2 * o.b - 2 * o.a : void 0,
						crosspost: t,
						primaryContent: !1
					}
				}) : r.a.createElement(a.a, {
					...e,
					primaryContent: !!e.showFull
				})
			}
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR",
				SubscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				subscribeButton: "_2r87gmhJ9n0MsylKHkgDcp"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/moderatorPermissions.ts"),
				i = n("./src/reddit/components/AwardBadges/index.tsx"),
				d = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				c = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				l = n("./src/reddit/components/PostBadges/index.tsx"),
				u = n("./src/reddit/components/PostTopMeta/index.tsx"),
				m = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				p = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				b = n("./src/reddit/components/SubscribeButton/Inline.tsx"),
				h = n("./src/reddit/constants/posts.ts"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				_ = n("./src/reddit/helpers/trackers/post.ts"),
				v = n("./src/reddit/hooks/useClickSourceData.ts"),
				O = n("./src/reddit/models/Subreddit/index.ts"),
				x = n("./src/reddit/components/PostMeta/index.m.less"),
				E = n.n(x);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: n,
					inSubredditOrProfile: s,
					isCurrentUserProfilePost: x,
					isOverlay: y,
					isTopicPage: j,
					post: C,
					shouldShowSubscribeButton: k,
					subredditOrProfile: I,
					tooltipType: S
				} = e, w = !!j, T = Object(v.a)(), N = Object(o.e)(e => !!I && Object(a.i)(e, I.id));
				return r.a.createElement("div", {
					className: E.a.metaContainer
				}, !s && !C.isSponsored && I && r.a.createElement(d.a, {
					postId: C.id,
					subredditName: I.name
				}, r.a.createElement(p.a, {
					className: E.a.subredditName,
					"data-click-id": "subreddit",
					to: {
						pathname: I.url,
						state: T
					}
				}, I.displayText)), I && I.isQuarantined && r.a.createElement(m.a, null), !s && !C.isSponsored && I && k && !x && r.a.createElement(b.a, {
					className: E.a.SubscribeButton,
					getEventFactory: e => Object(_.k)(C.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: I.name,
						type: Object(O.h)(I) ? h.a.PROFILE : h.a.SUBREDDIT
					},
					postId: C.id,
					size: f.d.XXS,
					small: !0
				}), !s && !C.isSponsored && r.a.createElement(g.b, null), !s && !C.isSponsored && r.a.createElement(c.h, {
					type: C.belongsTo.type,
					id: C.belongsTo.id
				}), r.a.createElement(u.d, {
					className: E.a.postTopMeta,
					flairStyleTemplate: t,
					post: C,
					tooltipType: S,
					isModWithUserNotesPermissions: N
				}), r.a.createElement(l.a, {
					displayText: I ? I.displayText : null,
					inSubredditOrProfile: !!s,
					post: C,
					tooltipType: S
				}), !w && r.a.createElement(i.a, {
					hideCta: n,
					thing: C,
					tooltipType: y ? u.c.Lightbox : void 0
				}))
			}
		},
		"./src/reddit/components/PostModModeDropdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("ModerationDropdowns").then(n.bind(null, "./src/reddit/components/PostModModeDropdown/_PostModModeDropdown.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/PostOverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				overflowMenu: "_1EbinKu2t3KjaT2gR156Qp",
				DropdownRow: "_1muOrgIRB6t41qDocDiXul",
				dropdownRow: "_1muOrgIRB6t41qDocDiXul",
				disabledRow: "_2Odc33_zXVGMHX8Um_2eO7",
				HideIcon: "_3CksthIwbeJIolp7OYeQYv",
				hideIcon: "_3CksthIwbeJIolp7OYeQYv",
				Icon: "_2V4nGS1AmzWhA62lzdCu4r",
				icon: "_2V4nGS1AmzWhA62lzdCu4r"
			}
		},
		"./src/reddit/components/PostOverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return Ee
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/telemetry/index.ts"),
				l = n("./node_modules/uuid/v4.js"),
				u = n.n(l),
				m = n("./src/config.ts"),
				p = n("./src/lib/addQueryParams/index.ts"),
				b = n("./src/lib/classNames/index.ts"),
				h = n("./src/lib/lessComponent.tsx"),
				f = n("./src/reddit/actions/eventPosts/index.ts"),
				g = n("./src/reddit/actions/gold/modals.ts"),
				_ = n("./src/reddit/actions/modal.ts"),
				v = n("./src/reddit/actions/pinnedPost.ts"),
				O = n("./src/reddit/actions/post.ts"),
				x = n("./src/reddit/actions/postCreation/editing.ts"),
				E = n("./src/reddit/actions/reportFlow/index.ts"),
				y = n("./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx"),
				j = n("./src/reddit/constants/oneFeed.ts"),
				C = n("./src/reddit/constants/parameters.ts"),
				k = n("./src/reddit/constants/posts.ts"),
				I = n("./src/reddit/hooks/useRecommendationPostContext.ts");

			function S() {
				return (S = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var w = function(e) {
					function t(t) {
						const n = Object(I.a)();
						return o.createElement(e, S({}, t, {
							recommendationPostContext: n
						}))
					}
					const n = e.displayName || e.name || "Component";
					return t.displayName = `withRecommendationPostContext(${n})`, t
				},
				T = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				N = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				P = n("./src/reddit/icons/fonts/index.tsx"),
				R = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				A = n("./src/reddit/components/OverflowMenu/index.tsx"),
				M = n("./src/reddit/components/ReportFlow/index.tsx"),
				D = n("./src/reddit/contexts/PageLayer/index.tsx"),
				L = n("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				F = n("./src/reddit/controls/Dropdown/Row.tsx"),
				U = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				B = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				G = n("./src/reddit/components/Flatlist/constants.ts"),
				H = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				W = n("./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx"),
				q = n("./src/reddit/constants/postLayout.ts"),
				V = n("./src/reddit/helpers/correlationIdTracker.ts"),
				z = n("./src/reddit/helpers/isCrosspost.ts"),
				K = n("./src/reddit/helpers/media/index.ts"),
				Q = n("./src/reddit/helpers/postEvent.ts"),
				J = n("./src/reddit/helpers/trackers/post.ts"),
				Y = n("./src/reddit/helpers/trackers/react.ts"),
				X = n("./src/reddit/models/Post/index.ts"),
				Z = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				$ = n("./src/reddit/models/Subreddit/index.ts"),
				ee = n("./src/reddit/selectors/activeModalId.ts"),
				te = n("./src/reddit/selectors/experiments/videoReactions.ts"),
				ne = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				se = n("./src/reddit/selectors/posts.ts"),
				re = n("./src/reddit/selectors/subreddit.ts"),
				oe = n("./src/reddit/selectors/user.ts"),
				ae = n("./src/reddit/selectors/experiments/reportingRevampDesktop.ts"),
				ie = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				de = n("./src/reddit/components/ReportFlow/new.tsx"),
				ce = n("./src/reddit/actions/postCollection/index.ts"),
				le = n("./src/reddit/contexts/Post/index.tsx"),
				ue = n("./src/reddit/helpers/trackers/postCollection.ts"),
				me = n("./src/reddit/models/PostCreationForm/index.ts"),
				pe = n("./src/reddit/selectors/postCollection.ts"),
				be = n("./node_modules/react-router/esm/react-router.js"),
				he = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				fe = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx");
			const ge = Object(be.i)(e => {
				let {
					post: t,
					toggleConfirmDelete: n,
					handleDeletePost: r,
					location: o
				} = e;
				const {
					isPrediction: i,
					resolvedOptionId: d,
					totalVoteCount: c
				} = t.pollData || {}, l = i ? s.fbt._("Are you sure?", null, {
					hk: "2mIMwE"
				}) : s.fbt._("Delete post?", null, {
					hk: "3g7QoX"
				}), u = a.a.useMemo(() => {
					const e = c || 0;
					return i ? 0 === e ? s.fbt._("Deleting this post will cancel any predictions that have been made.", null, {
						hk: "1OCTd3"
					}) : 1 === e ? s.fbt._("Deleting this post will cancel the 1 prediction that have already been made.", null, {
						hk: "1MnrUP"
					}) : s.fbt._("Deleting this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", e.toString())], {
						hk: "1jBXxs"
					}) : s.fbt._("Are you sure you want to delete your post? You can't undo this.", null, {
						hk: "2eDKWP"
					})
				}, [i, c]), m = i ? s.fbt._("Delete", null, {
					hk: "3NNdm0"
				}) : s.fbt._("Delete post", null, {
					hk: "28hc1p"
				});
				return i && d ? a.a.createElement(fe.a, {
					title: s.fbt._("This post can't be deleted", null, {
						hk: "1sZ013"
					}),
					body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't delete the post.", null, {
						hk: "32l6dr"
					}),
					onClose: n
				}) : a.a.createElement(he.a, {
					withOverlay: !0,
					toggleModal: n,
					onConfirm: () => r(o),
					onOverlayClick: n,
					actionText: m,
					headerText: l,
					modalText: u
				})
			});
			var _e = n("./src/reddit/components/PostOverflowMenu/index.m.less"),
				ve = n.n(_e);
			const Oe = h.a.wrapped(F.b, "DropdownRow", ve.a),
				xe = u()(),
				Ee = e => {
					let {
						gild: t = !0,
						save: n = !0,
						share: s = !0,
						report: r = !0,
						editPost: o = !0,
						hide: a = !0,
						insights: i = !0
					} = e;
					return {
						[G.a.Gild]: t,
						[G.a.Save]: n,
						[G.a.Share]: s,
						[G.a.Report]: r,
						[G.a.EditPost]: o,
						[G.a.Hide]: a,
						[G.a.Insights]: i
					}
				},
				ye = Object(i.b)(() => Object(d.c)({
					claimedFreeAward: ne.b,
					isFutureEvent: pe.i,
					isPinned: se.q,
					isAllowReactionsKillswitchEnabled: te.a,
					subredditAboutInfo: se.H,
					reportFlowIsOpen: (e, t) => {
						let {
							isOverlay: n,
							postId: s
						} = t;
						var r, o, a, i;
						return (null === (o = null === (r = e.features) || void 0 === r ? void 0 : r.reportFlow) || void 0 === o ? void 0 : o.openedFromModalPage) === n && (null === (i = null === (a = e.features) || void 0 === a ? void 0 : a.reportFlow) || void 0 === i ? void 0 : i.postOrCommentId) === s
					},
					showPinAction: (e, t) => {
						let {
							isProfilePostListing: n,
							userIsOp: s,
							post: r,
							pageLayer: o
						} = t;
						return Object(D.E)(e, {
							pageLayer: o
						}) && n && s && Object(oe.Bb)(e, {
							userName: r.author
						})
					},
					hasSubredditRules: re.h,
					isPostPartOfACollection: pe.k,
					shouldRenderCollectionEditButtons: (e, t) => {
						let {
							post: n,
							subredditOrProfile: s
						} = t;
						if (n.isSponsored) return !1;
						if (!s) return !1;
						const r = s.type === $.f.User;
						return Object(pe.r)(e, s.name, r)
					},
					reportingRevampEnabled: ae.a,
					videoShareModalOpen: (e, t) => {
						let {
							postId: n
						} = t;
						return Object(ee.a)(e) === Object(W.a)(n)
					}
				}), (e, t) => {
					let {
						postId: n,
						isOverlay: s,
						isCommentsPage: r
					} = t;
					return {
						onCopyLink: t => e(Object(O.D)(t)),
						onDelete: t => e(Object(O.N)(n, t, s)),
						onDistinguishPost: t => e(Object(O.v)(n, t)),
						onGildClick: (t, s) => e(Object(g.d)({
							awardId: s,
							correlationId: t,
							thingId: n
						})),
						onToggleSave: () => e(Object(O.V)(n)),
						onToggleNSFW: () => e(Object(O.G)(n)),
						onToggleOC: () => e(Object(O.J)(n)),
						onTogglePinned: () => e(Object(v.i)(n)),
						onToggleSpoiler: () => e(Object(O.eb)(n)),
						onHide: t => e(Object(O.fb)(n, !t, s, !0)),
						onReportClick: () => e(Object(E.c)(n, s)),
						onStartEventNow: () => {
							e((e, t) => Object(c.a)(Object(N.l)()(t()))), e(Object(f.startEventNowRequested)(n))
						},
						onEdit: () => {
							const t = !s && !r;
							e(Object(x.a)(n, t))
						},
						onFlairPost: () => e(Object(_.i)(Object(ie.b)(n, s))),
						onToggleSendReplies: () => e(Object(O.W)(n)),
						onToggleReactAllowed: () => e(Object(O.T)(n)),
						showCollectionsList: (t, n) => {
							e(Object(ce.e)(t)).then(() => {
								const t = Object(me.t)(n, s);
								e(_.i(t))
							})
						},
						onToggleVideoShareModal: () => e(Object(_.i)(Object(W.a)(n)))
					}
				});
			class je extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						isConfirmDeleteOpen: !1
					}, this.handlePostEvent = (e, t) => {
						const {
							isOverlay: n,
							post: s,
							sendEvent: r
						} = this.props;
						r(Object(J.k)(s.id, e, n ? "post_detail" : "post", void 0, void 0, void 0, null == t ? void 0 : t.referralId))
					}, this.handleClickMenuButton = () => {
						this.handlePostEvent("post_overflow_menu")
					}, this.handleDeletePost = e => {
						e && (this.props.onDelete(e), this.handlePostEvent("delete"))
					}, this.handleEdit = () => {
						this.handlePostEvent("edit"), this.props.onEdit()
					}, this.handleGild = async () => {
						var e;
						const t = Object(V.d)(V.a.GildingFlow, !0);
						this.props.onGildClick(t, null === (e = this.props.claimedFreeAward) || void 0 === e ? void 0 : e.id);
						const {
							clickGildEvent: s
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						this.props.sendEvent(s(this.props.postId))
					}, this.onShowFewerOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(J.n)(e)), t(j.a.SeeFewerPostsView)
					}, this.onShowMoreOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(J.o)(e)), t(j.a.ThankYouView)
					}, this.toggleHide = () => {
						const e = this.props.post.hidden ? "unhide" : "hide";
						this.handlePostEvent(e), this.props.onHide(!!this.props.post.hidden)
					}, this.toggleSave = () => {
						const e = this.props.post.saved ? "unsave" : "save";
						this.handlePostEvent(e), this.props.onToggleSave()
					}, this.handleReport = () => {
						this.handlePostEvent("report"), this.props.onReportClick()
					}, this.toggleOC = () => {
						this.handlePostEvent(this.props.post.isOriginalContent ? "unmark_original_content" : "mark_original_content"), this.props.onToggleOC()
					}, this.togglePinned = () => {
						this.handlePostEvent(this.props.isPinned ? "unpin" : "pin"), this.props.isPinned ? this.props.sendEvent(Object(J.r)(this.props.post.id)) : this.props.sendEvent(Object(J.h)(this.props.post.id)), this.props.onTogglePinned()
					}, this.toggleSpoiler = () => {
						this.handlePostEvent(this.props.post.isSpoiler ? "unmark_spoiler" : "mark_spoiler"), this.props.onToggleSpoiler()
					}, this.toggleNSFW = () => {
						this.handlePostEvent(this.props.post.isNSFW ? "unmark_nsfw" : "mark_nsfw"), this.props.onToggleNSFW()
					}, this.toggleDeleteConfirmation = () => {
						this.setState({
							isConfirmDeleteOpen: !this.state.isConfirmDeleteOpen
						})
					}, this.getBreakpointClass = e => {
						const {
							props: t
						} = this;
						if (!t.ignoreBreakpoints && t.useFlatlistBreakpoints[e]) return Object(H.b)({
							breakpointType: H.a.HideIfVWLarger,
							flatlistItem: e,
							isLoggedIn: !!t.currentUser,
							isUserOp: t.userIsOp
						})
					}, this.getBreakpointCx = (e, t) => Object(B.b)({
						breakpointType: H.a.HideIfVWLarger,
						flatlistItem: e,
						postLayout: t
					}), this.handleAddToCollection = () => {
						const {
							isPostPartOfACollection: e,
							showCollectionsList: t,
							post: n,
							sendEvent: s
						} = this.props;
						e || (s(Object(ue.b)(n.id)), t(n.belongsTo.id, n.id))
					}, this.onCloseShareModal = e => {
						e && (this.handlePostEvent("copy_link", {
							referralId: xe
						}), this.props.onCopyLink(e)), this.props.onToggleVideoShareModal()
					}, this.renderReportFlow = () => this.props.reportingRevampEnabled ? a.a.createElement(de.a, {
						withOverlay: !0,
						overlayCustomStyles: M.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					}) : a.a.createElement(M.a, {
						withOverlay: !0,
						overlayCustomStyles: M.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					})
				}
				getOverflowMenuBreakpointClass() {
					const {
						currentUser: e,
						ignoreBreakpoints: t,
						ignoreOverflowMenuBreakpoints: n,
						isCommentsPage: s,
						isRecommendationPost: r,
						layout: o,
						modModeWithPost: a,
						recommendationPostContext: {
							hideRecommendationContext: i
						},
						userIsOp: d
					} = this.props, c = o === q.g.Classic;
					if (!(t || n || a || d || !s && !c || r && !i)) return Object(H.b)({
						breakpointType: H.a.HideIfVWLarger,
						flatlistItem: G.a.PostOverflowMenu,
						isLoggedIn: !!e,
						isUserOp: d
					})
				}
				renderDropdownIcons() {
					const {
						props: e
					} = this, {
						currentUser: t,
						isFutureEvent: n,
						isOverlay: o,
						isPinned: i,
						isRecommendationPost: d,
						layout: c,
						onClickInsightsButton: l,
						onStartEventNow: u,
						post: p,
						recommendationPostContext: {
							hideRecommendationContext: b
						},
						shouldRenderCollectionEditButtons: h,
						shouldShowInsightsButton: f,
						showEditFlair: g,
						showPinAction: _,
						toggleAddEventStartTimeModal: v,
						toggleEditStartTimeModal: O,
						userIsOp: x
					} = e, E = e.currentUser && e.currentUser.isEmployee, y = Object(z.a)(e.post), j = e.post.belongsTo.type === k.a.PROFILE || Object($.g)(e.subredditAboutInfo), C = e.post.belongsTo.type === k.a.PROFILE || Object($.i)(e.subredditAboutInfo), I = t && p.isGildable, S = Object(Q.a)(e.post), w = o ? void 0 : c;
					return a.a.createElement("div", null, f && a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Insights),
						displayText: s.fbt._("Insights", null, {
							hk: "t7dpi"
						}),
						onClick: l
					}, a.a.createElement(R.a, {
						postCreated: p.created,
						subredditId: p.belongsTo.id
					})), I && a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Gild),
						displayText: s.fbt._("Give Award", null, {
							hk: "3mYeGJ"
						}),
						onClick: this.handleGild
					}, a.a.createElement(P.a, {
						name: "award",
						className: ve.a.Icon
					})), d && !b && a.a.createElement(a.a.Fragment, null, a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.ShowMoreLikeThis),
						displayText: s.fbt._("Show more posts like this", null, {
							hk: "2t0WMg"
						}),
						onClick: this.onShowMoreOfClick
					}, a.a.createElement(P.a, {
						name: "checkmark",
						className: ve.a.Icon
					})), a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.ShowFewerLikeThis),
						displayText: s.fbt._("Show fewer posts like this", null, {
							hk: "k9sBL"
						}),
						onClick: this.onShowFewerOfClick
					}, a.a.createElement(P.a, {
						name: "hide",
						className: ve.a.Icon
					}))), a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Share),
						displayText: s.fbt._("Copy link", null, {
							hk: "ETZxA"
						}),
						onClick: () => {
							const {
								permalink: t,
								post: n
							} = e;
							n && Object(X.q)(n) ? (e.onToggleVideoShareModal(), this.handlePostEvent("share")) : (this.handlePostEvent("share_copy"), e.onCopyLink(t))
						}
					}, a.a.createElement(P.a, {
						name: "link_post",
						className: ve.a.Icon
					})), a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Share),
						displayText: s.fbt._("Embed", null, {
							hk: "3u0v6r"
						}),
						onClick: () => {
							this.handlePostEvent("share_embed"), window.open(`${m.a.rebedMediaUrl}/embed?url=${e.post.permalink}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, a.a.createElement(P.a, {
						name: "embed",
						className: ve.a.Icon
					})), e.showEditPost && !Object(Z.b)(this.props.post) && a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.EditPost),
						displayText: s.fbt._("Edit post", null, {
							hk: "3gVzz0"
						}),
						onClick: this.handleEdit,
						isSelected: e.post.hidden
					}, a.a.createElement(P.a, {
						name: "edit",
						className: ve.a.Icon
					})), g && a.a.createElement(Oe, {
						className: this.getBreakpointCx(U.a.Flair, w),
						displayText: s.fbt._("Edit Post Flair", null, {
							hk: "1pGISD"
						}),
						onClick: e.onFlairPost,
						isSelected: e.post.hidden
					}, a.a.createElement(P.a, {
						name: "tag",
						className: ve.a.Icon
					})), a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Save),
						displayText: e.post.saved ? s.fbt._("unsave", null, {
							hk: "HDDPm"
						}) : s.fbt._("save", null, {
							hk: "3bg2gs"
						}),
						onClick: this.toggleSave,
						isSelected: e.post.saved
					}, a.a.createElement(P.a, {
						name: e.post.saved ? "saved" : "save",
						className: ve.a.Icon
					})), _ && a.a.createElement(Oe, {
						displayText: i ? s.fbt._("Unpin Post from Profile", null, {
							hk: "6DYfk"
						}) : s.fbt._("Pin Post to Profile", null, {
							hk: "2RWbNF"
						}),
						onClick: this.togglePinned
					}, a.a.createElement(P.a, {
						name: "pin",
						className: ve.a.Icon,
						isFilled: this.props.isPinned
					})), !e.post.isSponsored && a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Hide),
						displayText: e.post.hidden ? s.fbt._("unhide", null, {
							hk: "1P4IxC"
						}) : s.fbt._("hide", null, {
							hk: "48yKzW"
						}),
						onClick: this.toggleHide,
						isSelected: e.post.hidden
					}, a.a.createElement(P.a, {
						name: "hide",
						className: ve.a.HideIcon
					})), !e.post.isSponsored && !x && a.a.createElement(Oe, {
						className: this.getBreakpointClass(G.a.Report),
						displayText: s.fbt._("report", null, {
							hk: "128RPn"
						}),
						onClick: this.handleReport
					}, a.a.createElement(P.a, {
						name: "report",
						className: ve.a.Icon
					})), h && n && u && a.a.createElement(Oe, {
						onClick: u,
						displayText: s.fbt._("Start event now", null, {
							hk: "3VomTN"
						})
					}, a.a.createElement(P.a, {
						name: "live",
						className: ve.a.Icon
					})), h && n && O && a.a.createElement(Oe, {
						onClick: O,
						displayText: s.fbt._("Edit start time", null, {
							hk: "2typ17"
						})
					}, a.a.createElement(P.a, {
						name: "scheduled",
						className: ve.a.Icon
					})), h && !S && v && a.a.createElement(Oe, {
						displayText: s.fbt._("Add event start time", null, {
							hk: "1XXqzu"
						}),
						onClick: v
					}, a.a.createElement(P.a, {
						name: "scheduled",
						className: ve.a.Icon
					})), h && a.a.createElement(Oe, {
						className: this.props.isPostPartOfACollection ? ve.a.disabledRow : void 0,
						displayText: s.fbt._("Add to collection", null, {
							hk: "3UNHgN"
						}),
						onClick: this.handleAddToCollection,
						noHover: this.props.isPostPartOfACollection
					}, a.a.createElement(P.a, {
						name: "collection",
						className: ve.a.Icon
					})), x && a.a.createElement(Oe, {
						displayText: s.fbt._("delete", null, {
							hk: "4kSfzC"
						}),
						onClick: this.toggleDeleteConfirmation
					}, a.a.createElement(P.a, {
						name: "delete",
						className: ve.a.Icon
					})), E && e.userIsOp && a.a.createElement(Oe, {
						displayText: e.post.distinguishType === r.G.ADMIN ? s.fbt._("undistinguish", null, {
							hk: "2chGON"
						}) : s.fbt._("Distinguish as admin", null, {
							hk: "2xltiM"
						}),
						onClick: () => e.post.distinguishType === r.G.ADMIN ? e.onDistinguishPost(r.G.NONE) : e.onDistinguishPost(r.G.ADMIN)
					}, a.a.createElement(P.a, {
						name: "admin",
						className: ve.a.Icon
					})), x && j && !y && a.a.createElement(L.a, {
						text: s.fbt._("Mark as OC", null, {
							hk: "2vGyoC"
						}),
						onClick: this.toggleOC,
						isSelected: this.props.post.isOriginalContent
					}), x && C && a.a.createElement(L.a, {
						text: s.fbt._("Mark as Spoiler", null, {
							hk: "3PJk7A"
						}),
						onClick: this.toggleSpoiler,
						isSelected: this.props.post.isSpoiler
					}), x && a.a.createElement(L.a, {
						text: s.fbt._("Mark as NSFW", null, {
							hk: "4qK6JN"
						}),
						onClick: this.toggleNSFW,
						isSelected: this.props.post.isNSFW
					}), x && p.domain === K.a && !this.props.isAllowReactionsKillswitchEnabled && a.a.createElement(L.a, {
						text: s.fbt._("Allow video threads", null, {
							hk: "DJXlU"
						}),
						onClick: () => {
							var t;
							e.onToggleReactAllowed(), this.props.sendEvent(Object(Y.a)({
								subredditId: null === (t = this.props.subredditOrProfile) || void 0 === t ? void 0 : t.id,
								postId: this.props.postId,
								reactionsEnabled: this.props.post.isReactAllowed
							}))
						},
						isSelected: this.props.post.isReactAllowed
					}), e.userIsOp && a.a.createElement(L.a, {
						text: s.fbt._("Send me reply notifications", null, {
							hk: "6AmTA"
						}),
						onClick: e.onToggleSendReplies,
						isSelected: this.props.post.sendReplies
					}))
				}
				render() {
					const {
						props: e
					} = this;
					return a.a.createElement("div", null, a.a.createElement(A.b, {
						className: Object(b.a)(ve.a.overflowMenu, this.getOverflowMenuBreakpointClass(), e.className),
						dropdownId: e.dropdownId,
						isFixed: e.isFixed,
						layout: e.layout,
						onClick: this.handleClickMenuButton
					}, this.renderDropdownIcons()), e.reportFlowIsOpen && e.subredditOrProfile && e.hasSubredditRules && this.renderReportFlow(), this.state.isConfirmDeleteOpen && a.a.createElement(ge, {
						post: this.props.post,
						toggleConfirmDelete: this.toggleDeleteConfirmation,
						handleDeletePost: this.handleDeletePost
					}), e.videoShareModalOpen && a.a.createElement(W.b, {
						className: ve.a.modalBody,
						onClose: this.onCloseShareModal,
						withOverlay: !1,
						url: Object(p.a)(Object(T.a)(e.postId), {
							[C.q]: xe,
							utm_source: "share",
							utm_medium: "web2x",
							utm_content: "rpan_stream"
						})
					}))
				}
			}
			je.contextType = y.a;
			t.a = w(Object(le.e)(ye(je)))
		},
		"./src/reddit/components/PostRailAndVotes/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_3a2ZHWaih05DgAOtvu6cIo",
				allowPointerEvents: "_2iiIcja5xIjg-5sI4ECvcV",
				checkbox: "_25sIJZLIxTa3eolXDWieo5"
			}
		},
		"./src/reddit/components/PostRailAndVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/PostLeftRail/index.tsx"),
				i = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/controls/Checkbox/index.tsx"),
				c = n("./src/reddit/helpers/isPost.ts"),
				l = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				u = n("./src/reddit/components/PostRailAndVotes/index.m.less"),
				m = n.n(u);
			t.a = e => {
				const {
					model: t,
					handleVote: n,
					showBulkActionCheckbox: s = !1,
					isCheckboxSelected: u = !1,
					isCountAnimShadowTestEnabled: p,
					toggleCheckbox: b = (() => {}),
					flairStyleTemplate: h,
					redditStyle: f,
					isOverlay: g,
					isVoteCountAnimation: _,
					postId: v,
					shouldShowUpvoteRatioOnHover: O
				} = e, x = `upvote-button-${t.id}${g?"-overlay":""}`;
				return r.a.createElement(a.b, {
					isRemoved: !!t.bannedBy,
					isReported: Object(l.a)(t),
					isSponsored: !!Object(c.b)(t) && t.isSponsored,
					redditStyle: f
				}, s && r.a.createElement(d.a, {
					className: m.a.checkbox,
					isCheckboxSelected: u,
					toggleCheckbox: b
				}), r.a.createElement(i.a, {
					flairStyleTemplate: h,
					model: t,
					onVoteClick: n,
					redditStyle: f,
					upvoteTooltipId: x,
					isVoteCountAnimation: _,
					isCountAnimShadowTestEnabled: p,
					postId: v,
					scoreClassName: Object(o.a)(m.a.score, {
						[m.a.allowPointerEvents]: O
					}),
					shouldShowUpvoteRatioOnHover: O
				}))
			}
		},
		"./src/reddit/components/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				outboundLinkIcon: "qgDkGQIoFEpMMeNtfI0BY",
				pollMeta: "FKej75-i0z1XubMqeVh9Q",
				styledLink: "SQnoC3ObvgnGjWt90zD9Z",
				isVisitedEnabled: "_2INHSNB8V5eaWp4P0rY_mE",
				Title: "_2SdHzo12ISmrC8H86TgSCp",
				title: "_2SdHzo12ISmrC8H86TgSCp",
				titleContainer: "y8HYJ-y_lTUHkQIc1mdCq",
				isNoWrap: "_2_QBmCTk6VD4M3dvKqXD23",
				postTitleVisibility: "_1hLrLjnE1G_RBCNcN9MVQf",
				blur: "_1Y3R-LNfq0EOkZUcePSt1j",
				ExtraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				extraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				Large: "_3wqmjmv3tb_k-PROt7qFZe",
				large: "_3wqmjmv3tb_k-PROt7qFZe",
				Medium: "_1zpZYP8cFNLfLDexPY65Y7",
				medium: "_1zpZYP8cFNLfLDexPY65Y7",
				Small: "uWdXen_41bh0iwLrgzFkc",
				small: "uWdXen_41bh0iwLrgzFkc",
				ExtraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				extraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				Metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				Component: "_2FCtq-QzlfuN-SwVMUZMM3",
				component: "_2FCtq-QzlfuN-SwVMUZMM3"
			}
		},
		"./src/reddit/components/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return Q
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/controls/OutboundLink/index.tsx"),
				b = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				h = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				f = n("./src/reddit/actions/post.ts"),
				g = n("./src/reddit/helpers/flair.ts"),
				_ = n("./src/reddit/helpers/path/index.ts"),
				v = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/models/Flair/index.ts"),
				E = n("./src/reddit/models/Media/index.ts"),
				y = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				j = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				C = n("./src/lib/getShortenedLink.ts"),
				k = n("./src/reddit/components/FlairWrapper/index.tsx"),
				I = n("./node_modules/fbt/lib/FbtPublic.js"),
				S = n("./src/lib/prettyPrintNumber/index.ts"),
				w = n("./src/reddit/components/Poll/PollExpiry/index.tsx"),
				T = n("./src/reddit/components/Poll/PostTitleMetaData/index.m.less"),
				N = n.n(T),
				P = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts");
			const R = Object(d.c)({
				poll: (e, t) => e.polls.models[t.pollId],
				resultsByVoters: (e, t) => e.polls.results.byVoters[t.pollId]
			});
			var A, M = Object(a.b)(R)((function(e) {
					const {
						poll: t,
						resultsByVoters: n
					} = e, s = n ? n.totalVotes : "0";
					return Object(P.a)() ? null : o.a.createElement("div", {
						className: Object(l.a)(e.className, N.a.proposalMetaData)
					}, o.a.createElement("span", null, I.fbt._({
						"*": "{count} votes",
						_1: "{count} vote"
					}, [I.fbt._param("count", Object(S.a)(s)), I.fbt._plural(parseInt(s))], {
						hk: "4rP1VK"
					})), t && o.a.createElement(w.a, {
						className: N.a.proposalExpiry,
						poll: t
					}))
				})),
				D = n("./src/reddit/components/SEOTitle/index.tsx"),
				L = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				F = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				U = n("./src/reddit/selectors/user.ts"),
				B = n("./src/reddit/components/PostTitle/index.m.less"),
				G = n.n(B),
				H = n("./src/config.ts"),
				W = n("./src/reddit/hooks/useClickSourceData.ts"),
				q = n("./src/reddit/hooks/usePostContext.ts"),
				V = n("./src/reddit/hooks/useTheme.ts"),
				z = n("./src/telemetry/models/Outbound.ts");

			function K() {
				return (K = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}! function(e) {
				e[e.ExtraLarge = 0] = "ExtraLarge", e[e.Large = 1] = "Large", e[e.Medium = 2] = "Medium", e[e.Small = 3] = "Small", e[e.ExtraSmall = 4] = "ExtraSmall", e[e.Metadata = 5] = "Metadata"
			}(A || (A = {}));
			const Q = e => {
					let {
						size: t,
						titleColor: n,
						titleType: s,
						nowrap: r,
						children: a,
						className: i,
						redditStyle: d,
						shouldBlurTitle: c
					} = e;
					const u = Object(V.a)();
					let m = "";
					switch (t) {
						case A.ExtraLarge:
							m = G.a.ExtraLarge;
							break;
						case A.Large:
							m = G.a.Large;
							break;
						case A.Medium:
							m = G.a.Medium;
							break;
						case A.Small:
							m = G.a.Small;
							break;
						case A.ExtraSmall:
							m = G.a.ExtraSmall;
							break;
						case A.Metadata:
							m = G.a.Metadata
					}
					return o.a.createElement("div", {
						className: Object(l.a)(G.a.Title, i, m, {
							[G.a.isNoWrap]: r,
							[G.a.blur]: c
						}),
						style: {
							"--posttitletextcolor": n || Object(j.a)({
								redditStyle: d,
								theme: u
							}).titleText
						}
					}, s ? o.a.createElement(D.b, {
						type: s
					}, a) : a)
				},
				J = e => {
					let {
						className: t,
						disableVisited: n,
						titleColor: s,
						children: r,
						...a
					} = e;
					return o.a.createElement(i.a, K({}, a, {
						className: Object(l.a)(t, G.a.styledLink, {
							[G.a.isVisitedEnabled]: !n
						})
					}), r)
				},
				Y = e => {
					let {
						disableVisited: t,
						nowrap: n,
						className: s,
						children: r
					} = e;
					return o.a.createElement("div", {
						className: Object(l.a)(G.a.titleContainer, s, {
							[G.a.isNoWrap]: n,
							[G.a.isVisitedEnabled]: !t
						})
					}, r)
				},
				X = Object(d.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(m.q)(e, {
							pageLayer: n
						})
					},
					isNsfwBlurSubreddit: F.e,
					shouldOpenPostInNewTab: U.jb
				}),
				Z = e => {
					const {
						post: t,
						subreddit: n
					} = e, {
						isSponsored: s
					} = t, r = Object(a.d)(), i = Object(W.a)(), d = Object(a.e)(L.b), l = Object(a.e)(L.c), u = e => {
						!d && !l || t.media && Object(E.H)(t.media) || (e.preventDefault(), r(Object(f.bb)(Object(_.b)(t.permalink), t.id)))
					};
					if (e.isCommentsPage && !e.isCommentPermalink && !e.shouldLinkWrap) return o.a.createElement(Y, {
						nowrap: e.nowrap
					}, o.a.createElement($, e));
					if (e.isCommentsPageAd && t.source && t.source.url) return o.a.createElement(p.b, {
						href: t.source.url,
						isSponsored: s,
						postId: t.id,
						source: t.source
					}, o.a.createElement($, e)); {
						const r = t.media && Object(E.H)(t.media) ? Object(v.c)(t.id, n.name) : t.permalink,
							a = e.isCommentPermalink ? Object(_.b)(r) : Object(h.a)(r, void 0, i);
						return o.a.createElement(Y, {
							disableVisited: e.disableVisited,
							nowrap: e.nowrap
						}, s ? ((e, t) => {
							const {
								source: n
							} = Object(c.t)(e, t.imageGalleryCurrentItem);
							return n ? o.a.createElement(p.b, {
								href: n.url,
								isSponsored: e.isSponsored,
								postId: e.id,
								source: n
							}, o.a.createElement($, t)) : o.a.createElement($, t)
						})(t, e) : o.a.createElement(J, {
							className: e.titleLinkClassName,
							"data-click-id": "body",
							disableVisited: e.disableVisited,
							target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
							titleColor: e.titleColor,
							to: a,
							onClick: u
						}, o.a.createElement($, e)))
					}
				},
				$ = e => {
					const {
						leftFlair: t,
						isCommentsPageAd: n,
						post: s
					} = e;
					let r = e.format ? e.format(s) : s.title;
					n && "string" == typeof r && (r = (e => {
						return e.length >= 250 ? e.slice(0, 250 - "...".length) + "..." : e
					})(r));
					const a = e.isCommentsPage ? D.a.PostComments : D.a.PostItem,
						i = !(!e.isNsfwBlurSubreddit || !e.post.isNSFW);
					return o.a.createElement(Q, {
						className: e.titleClassName,
						nowrap: e.nowrap,
						redditStyle: e.redditStyle || e.isCommentsPage || e.isCommentsPageAd,
						shouldBlurTitle: i,
						size: e.size,
						titleColor: e.titleColor,
						titleType: a
					}, t && o.a.createElement(k.a, {
						titleFlair: t,
						nowrap: !0,
						post: s,
						sendEvent: e.sendEvent
					}), r)
				},
				ee = e => {
					const {
						hideSourceLink: t,
						isNsfwBlurSubreddit: n,
						post: s
					} = e, {
						isSponsored: r
					} = s, a = e.isCommentsPage ? z.SourceElement.PostLink : z.SourceElement.ListingPostLink;
					if (Object(P.a)()) return null;
					if (n && s.isNSFW) return null;
					const i = !t && !e.isCrosspost && e.size !== A.Large && !s.isSponsored && !(s.media && Object(E.H)(s.media)) && (s.source || s.media && (s.media.type === E.o.GIFVIDEO || s.media.type === E.o.IMAGE || s.media.type === E.o.EMBED));
					if (t || !e.isCommentsPage || e.isCommentPermalink || e.shouldLinkWrap) {
						if (i) return o.a.createElement(b.a, {
							className: e.outboundLinkClassName,
							href: Object(E.D)(s),
							isSponsored: r,
							postId: s.id,
							source: s.source,
							sourceElement: a
						}, Object(C.a)(s), !s.isSponsored && o.a.createElement(O.a, {
							name: "external_link",
							className: G.a.outboundLinkIcon
						}))
					} else if (s.source && !e.isCrosspost && e.size !== A.Large && e.size !== A.ExtraLarge) return o.a.createElement(b.a, {
						className: e.outboundLinkClassName,
						href: s.source.url,
						isSponsored: r,
						postId: s.id,
						source: s.source,
						sourceElement: a
					}, Object(C.a)(s), !s.isSponsored && o.a.createElement(O.a, {
						name: "external_link",
						className: G.a.outboundLinkIcon
					}));
					return null
				};
			class te extends o.a.Component {
				getDynamicStyleTags() {
					return o.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: `\n        .${this.props.post.id}.${G.a.Component} {\n          --postTitle-VisitedLinkColor: ${Object(s.c)(.45,Object(j.a)(this.props).titleText,"#FFFFFF")};\n          --postTitleLink-VisitedLinkColor: ${Object(s.c)(.45,this.props.titleColor||Object(j.a)(this.props).titleText,Object(j.a)(this.props).body)};\n        }\n      `
						}
					})
				}
				render() {
					const {
						className: e,
						disableFlair: t,
						flairPosition: n,
						isCommentsPage: s,
						isOverlay: r,
						poll: a,
						post: i,
						showNSFWSpoilerFlairsOnly: d,
						showNSFWFlairsOnly: c
					} = this.props, u = n === x.b.Left, m = Object(k.b)(i), p = d ? m.filter(e => e.type === x.f.Nsfw || e.type === x.f.Spoiler) : u ? m.filter(e => Object(g.q)(e.type)) : [];
					let b = m;
					d ? b = [] : c ? b = m.filter(e => e.type === x.f.Nsfw) : u && (b = m.filter(e => !Object(g.q)(e.type)));
					const h = !r && !s,
						f = !t && p && p.length > 0 && h,
						_ = !t && b && b.length > 0 && h;
					return o.a.createElement("div", {
						className: Object(l.a)(G.a.Component, e, i.id),
						ref: this.props.innerRef
					}, !d && f && o.a.createElement(k.a, {
						isFlairFilter: !0,
						titleFlair: p,
						nowrap: !0,
						post: i,
						sendEvent: this.props.sendEvent
					}), !Object(y.b)(i) && o.a.createElement(Z, K({}, this.props, {
						leftFlair: d ? p : void 0
					})), a && o.a.createElement(M, {
						className: G.a.pollMeta,
						pollId: a.id
					}), o.a.createElement(ee, this.props), _ && o.a.createElement(k.a, {
						isFlairFilter: !0,
						titleFlair: b,
						nowrap: !0,
						post: i,
						sendEvent: this.props.sendEvent
					}), o.a.createElement("div", {
						className: G.a.postTitleVisibility,
						dangerouslySetInnerHTML: {
							__html: `\n              <img alt="" src="${H.a.assetPath}/img/renderTimingPixel.png" style="width: 1px; height: 1px;" onLoad="(__markFirstPostVisible || function(){})();" />\n            `
						}
					}), this.getDynamicStyleTags())
				}
			}
			t.c = o.a.memo((function(e) {
				const t = Object(m.fb)(),
					n = Object(m.w)(t),
					s = Object(q.a)(),
					r = Object(a.e)(r => X(r, {
						...s,
						...e,
						isCommentPermalink: n,
						pageLayer: t
					})),
					i = Object(V.a)(),
					d = Object(u.b)();
				return s ? o.a.createElement(te, K({
					pageLayer: t,
					isCommentPermalink: n
				}, s, r, e, {
					theme: i,
					sendEvent: d
				})) : null
			}))
		},
		"./src/reddit/components/PowerupsSettings/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_2UnJkyErREO4UdPRO2_Nu_",
				formContainer: "_24DNbvpFOApkjl_aDxLQIe",
				emojiContainer: "KGb-9Fn_9opTkp9y4F7pK",
				emoteButtonContainer: "_3M018emNKEEexK1HjMZQTj",
				emoteButton: "_2f3AHI0QU_oQcjl8U5ZdRz",
				placeholderEmoteButton: "_2YQF3WYehiGNW2iR67S75X",
				uploadInput: "KmfMmSLuXzGdzc_3tPHy2",
				loadingContainer: "_2Z0VpSy4swcUtFNyxmSsg8",
				addButton: "_36wmuGVu3czQNqKncBoxBO",
				addButtonDisabled: "_3mYS-GLsakSC0Gu9a3ux8H",
				addIcon: "_3yRqzxOhoT1PNGoWZLh4bl"
			}
		},
		"./src/reddit/components/PowerupsSettings/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return P
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/config.ts"),
				i = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/reddit/hooks/useTracking.ts"),
				c = n("./src/reddit/actions/gold/powerups.ts"),
				l = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				u = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/reddit/actions/economics/powerups/index.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/components/RichTextEditor/emotes/EmoteButton.tsx"),
				f = n("./src/reddit/components/RichTextEditor/emotes/Powerups/DeleteEmojiModal.tsx"),
				g = n("./src/reddit/components/RichTextEditor/emotes/Powerups/useEmojiUpload.ts"),
				_ = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				v = n("./src/reddit/helpers/trackers/powerups.ts"),
				O = n("./src/reddit/icons/svgs/AddSquare/index.tsx"),
				x = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/gold/powerups/index.ts"),
				y = n("./src/reddit/components/PowerupsSettings/index.m.less"),
				j = n.n(y);
			const C = e => {
				let {
					subredditId: t
				} = e;
				const n = Object(o.d)(),
					a = Object(d.a)(),
					[c, l] = Object(s.useState)(null),
					u = () => l(null),
					[y, C] = Object(s.useState)(!1),
					k = Object(o.e)(e => Object(E.g)(e, {
						subredditId: t
					})),
					{
						uploadInput: I,
						maxEmojisUploading: S,
						numUploading: w,
						onFileChange: T,
						onClickUpload: N
					} = Object(g.a)(t, k, e => {
						n(Object(b.f)({
							duration: b.a,
							kind: x.b.Error,
							text: i.fbt._({
								"*": "You can only add {number} more emojis.",
								_1: "You can only add 1 more emoji."
							}, [i.fbt._plural(e, "number")], {
								hk: "117Ker"
							})
						}))
					}, e => {
						a(Object(v.a)(e, "mod_tools"))
					}, e => {
						a(Object(v.l)(e, "mod_tools")), n(Object(b.f)({
							duration: b.a,
							kind: x.b.SuccessCommunity,
							text: i.fbt._({
								"*": "Looking good! Emojis added.",
								_1: "Looking good! Emoji added."
							}, [i.fbt._plural(e)], {
								hk: "43WkeN"
							})
						}))
					}, e => {
						n(Object(b.f)({
							duration: b.a,
							kind: x.b.Error,
							text: i.fbt._({
								"*": "Failed to upload {number} emojis",
								_1: "Failed to upload 1 emoji"
							}, [i.fbt._plural(e, "number")], {
								hk: "2s093I"
							})
						}))
					}),
					P = S;
				return r.a.createElement(r.a.Fragment, null, r.a.createElement("input", {
					ref: I,
					className: j.a.uploadInput,
					onChange: T,
					type: "file",
					accept: "image/png,image/jpeg",
					multiple: !0
				}), w ? r.a.createElement("div", {
					className: j.a.loadingContainer
				}, r.a.createElement(O.a, {
					className: j.a.addIcon
				})) : r.a.createElement("button", {
					className: Object(m.a)(j.a.emoteButton, j.a.addButton, {
						[j.a.addButtonDisabled]: P
					}),
					disabled: P,
					onClick: N,
					title: i.fbt._("Add Custom Emoji", null, {
						hk: "M580t"
					})
				}, r.a.createElement(O.a, {
					className: j.a.addIcon
				})), k.map(e => r.a.createElement(h.a, {
					key: e.id,
					className: j.a.emoteButton,
					containerClassName: j.a.emoteButtonContainer,
					imageClassName: j.a.customEmoteImage,
					imagePath: e.emoji.path,
					onClickDelete: () => l(e),
					mouseEnterBufferTime: 0
				})), [...Array(w)].map((e, t) => r.a.createElement("div", {
					key: t,
					className: Object(m.a)(j.a.emoteButton, j.a.placeholderEmoteButton)
				}, r.a.createElement(_.a, {
					sizePx: 12,
					center: !0
				}))), c && r.a.createElement(f.a, {
					emojiUrl: c.emoji.path,
					onCancel: u,
					onClose: u,
					onConfirm: async () => {
						if (c && !y) try {
							C(!0), await n(Object(p.a)({
								subredditId: t,
								emojiId: c.id
							})), u(), a(Object(v.b)(1, "mod_tools")), n(Object(b.f)({
								duration: b.a,
								kind: x.b.SuccessCommunity,
								text: i.fbt._("Emoji removed.", null, {
									hk: "3Ox8xb"
								})
							}))
						} catch (e) {
							n(Object(b.f)({
								duration: b.a,
								kind: x.b.Error,
								text: i.fbt._("Failed to delete emoji", null, {
									hk: "2GukOR"
								})
							}))
						} finally {
							C(!1)
						}
					}
				}))
			};
			var k = n("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				I = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				S = n("./src/reddit/models/Gold/Powerups/index.ts"),
				w = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				T = n("./src/reddit/selectors/gold/powerups/benefitSettings.ts"),
				N = n("./src/reddit/selectors/subreddit.ts");
			const P = e => {
				let {
					subredditId: t
				} = e;
				const n = Object(o.d)(),
					s = Object(d.a)(),
					m = Object(o.e)(e => Object(E.f)(e, {
						subredditId: t
					})),
					p = Object(o.e)(e => Object(N.U)(e, {
						subredditId: t
					})),
					b = Object(o.e)(e => Object(T.a)(e, {
						subredditId: t
					})),
					h = (null == b ? void 0 : b[S.a.CommentsWithGifs]) || !1,
					f = Object(o.e)(w.b);
				return r.a.createElement(u.a, {
					className: j.a.contentContainer
				}, r.a.createElement(u.b, null, i.fbt._("Powerups settings", null, {
					hk: "1OxM4K"
				}), r.a.createElement(l.a, {
					linkUrl: `${a.a.redditModHelpUrl}/hc/en-us/articles/4403699823629`
				})), r.a.createElement("div", {
					className: j.a.formContainer
				}, m && r.a.createElement(r.a.Fragment, null, r.a.createElement(k.a, null, i.fbt._("Comments", null, {
					hk: "1TCs6F"
				})), !f && r.a.createElement(I.p, {
					on: h,
					onClick: () => (e => {
						s(Object(v.n)("comments_with_gifs", e, !e)), n(Object(c.k)(t, {
							[S.a.CommentsWithGifs]: e
						}))
					})(!h),
					label: i.fbt._("Allow GIFs in comments", null, {
						hk: "2nJiHt"
					}),
					subtext: i.fbt._("It may take a few minutes to update", null, {
						hk: "aU7tk"
					})
				}), r.a.createElement(I.l, {
					label: i.fbt._("{subreddit name} emojis", [i.fbt._param("subreddit name", p.displayText)], {
						hk: "4tuD3i"
					}),
					subtext: i.fbt._("Add up to 20 custom emojis. Images under 128kb with a transparent background work the best.", null, {
						hk: "EAXAA"
					})
				}), r.a.createElement("div", {
					className: j.a.emojiContainer
				}, r.a.createElement(C, {
					subredditId: t
				})))))
			}
		},
		"./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				a = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/components/ProfileIdCard/index.m.less"),
				d = n.n(i);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class l extends r.a.PureComponent {
				render() {
					const {
						topAwardIcon: e,
						recentAwardings: t,
						username: n
					} = this.props;
					if (!t.topAward) return null;
					const {
						topAward: s,
						totalCount: i
					} = t, l = s.description ? s.description : s.name;
					return r.a.createElement("a", {
						className: d.a.AwardedLastMonth,
						href: `${o.a.oldRedditUrl}/user/${n}/gilded`
					}, r.a.createElement("div", {
						className: d.a.iconColumn
					}, r.a.createElement("img", {
						alt: l,
						className: d.a.icon,
						src: e
					}), i > 1 && r.a.createElement("span", {
						className: d.a.count
					}, `+${Object(a.b)(i-1)}`)), r.a.createElement("div", {
						className: d.a.textColumn
					}, c._({
						"*": "Received the {award-name} Award and more in the past 30 days",
						_1: "Received the {award-name} Award in the past 30 days"
					}, [c._param("award-name", s.name), c._plural(i)], {
						hk: "16MJHe"
					})))
				}
			}
			t.a = l
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less": function(e, t, n) {
			e.exports = {
				Banner: "_2ZyL7luKQghNeMnczY3gqW",
				banner: "_2ZyL7luKQghNeMnczY3gqW"
			}
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/reddit/models/Image/index.tsx"),
				i = n("./src/reddit/components/EditableImage/index.tsx"),
				d = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts"),
				l = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less"),
				u = n.n(l);
			class m extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						isUpdating: !1
					}, this.updateProfileIcon = async (e, t) => {
						const n = await Object(a.e)(e);
						this.setState({
							isUpdating: !0
						}, async () => {
							await this.props.imageUpdateRequested(n, "profileBanner"), this.setState({
								isUpdating: !1
							})
						})
					}
				}
				render() {
					const {
						bannerUrl: e,
						className: t,
						currentUser: n,
						hideNSFWPref: r,
						isNSFW: a,
						userName: c
					} = this.props, {
						isUpdating: l
					} = this.state, m = e ? o.a.createElement("div", {
						className: u.a.Banner,
						style: {
							backgroundImage: `url(${e})`
						}
					}) : null;
					return n && Object(d.e)(n) === c ? o.a.createElement(i.a, {
						altText: s.fbt._("{userName} banner image", [s.fbt._param("userName", c)], {
							hk: "1PcEBS"
						}),
						className: t,
						isLoading: l,
						onFileSelected: this.updateProfileIcon
					}, m) : a && r ? null : m
				}
			}
			t.a = Object(c.a)(m)
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/preferences.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = Object(r.c)({
					currentUser: a.k,
					hideNSFWPref: a.F
				}),
				d = Object(s.b)(i, e => ({
					imageUpdateRequested: (t, n) => e(Object(o.C)(t, n))
				}));
			t.a = d
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				c = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				l = n.n(c);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					compact: t,
					currentUserHasSnoovatar: n,
					className: s,
					isOwnProfile: c,
					onClick: m
				} = e;
				return r.a.createElement(a.t, {
					onClick: m,
					isFullWidth: !0,
					className: Object(o.a)(l.a.snoovatarButton, {
						[l.a.snoovatarExtraPadding]: !n && c,
						[l.a.compactButtonLayout]: t
					}, s)
				}, n ? r.a.createElement(d.a, {
					className: l.a.shirtIcon
				}) : r.a.createElement("div", {
					className: l.a.shirtIcon
				}), n ? u._("Style Avatar", null, {
					hk: "UEtBO"
				}) : c ? u._("Create Avatar", null, {
					hk: "2pJgje"
				}) : u._("Create Your Own Avatar", null, {
					hk: "22FFcO"
				}), n ? r.a.createElement("div", {
					className: l.a.chevronIcon
				}) : r.a.createElement(i.a, {
					name: "caret_right",
					className: l.a.chevronIcon
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less": function(e, t, n) {
			e.exports = {
				BannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				bannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				BannerImage: "_1IvROQ79nAJZ87_JkTFsLO",
				bannerImage: "_1IvROQ79nAJZ87_JkTFsLO"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				a = n("./src/reddit/icons/svgs/Close/index.tsx"),
				i = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx"),
				d = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less"),
				c = n.n(d),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				u = n.n(l);
			t.a = function(e) {
				let {
					bannerBackgroundImage: t,
					isNSFW: n,
					username: s,
					editMode: d,
					isDeletingBanner: l,
					onDeleteBanner: m
				} = e;
				return r.a.createElement("div", {
					className: c.a.bannerWrapper
				}, r.a.createElement(i.a, {
					bannerUrl: t,
					isNSFW: n,
					userName: s
				}), d && t && (l ? r.a.createElement(o.a, {
					sizePx: 20,
					className: u.a.loadingIcon
				}) : r.a.createElement(a.a, {
					className: u.a.closeIcon,
					onClick: m
				})))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/components/HumanDate/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					className: t,
					shouldDisplaySnoovatar: n,
					url: s,
					userCreated: d,
					username: c,
					...l
				} = e;
				const u = n ? r.a.createElement(r.a.Fragment, null, "u/", c, "  ", r.a.createElement(a.d, {
					seconds: d,
					noPostfix: !0,
					shortenedUnit: !0
				})) : `u/${c}`;
				return s ? r.a.createElement(o.default, i({}, l, {
					className: t,
					to: s
				}), u) : r.a.createElement("span", i({}, l, {
					className: t
				}), u)
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_2DTxp6tzlJMeNlZ-cjXWTs",
				closeIcon: "_2ioQgcdZvYlf34S0OEqBuQ",
				settingsIcon: "A4Iifg_NCOrfabq0ON3mW"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts"),
				c = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				l = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				u = n("./src/reddit/selectors/experiments/econ/marketplace.ts"),
				m = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				p = n.n(m);
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const b = 25;

			function h(e, t) {
				return Object.keys(t).filter(t => 0 === t.indexOf(e)).map(e => t[e])
			}

			function f(e) {
				return e[Math.floor(Math.random() * e.length)]
			}
			const g = h("particleDelay", p.a),
				_ = h("particleX", p.a),
				v = h("particleFloat", p.a),
				O = () => {
					const e = f(_),
						t = f(v),
						n = f(g);
					return Object(r.a)(p.a.particle, e, t, n)
				};
			class x extends a.a.Component {
				shouldComponentUpdate() {
					return !1
				}
				render() {
					const e = [];
					for (let t = 0; t < b; t++) e.push(this.createParticle(t));
					return a.a.createElement("div", {
						role: "presentation",
						className: p.a.particleWrapper
					}, e)
				}
				createParticle(e) {
					return a.a.createElement("div", {
						key: e,
						className: `${O()}`
					})
				}
			}
			var E = x;
			const y = e => {
				let {
					className: t,
					isGold: n,
					snoovatarUrl: o,
					prefersReducedAnimations: m,
					origin: b
				} = e;
				const h = Object(i.e)(u.b),
					f = o && Object(l.d)(o) && h,
					g = b === c.a.Profile,
					_ = b === c.a.Hovercard;
				return f ? a.a.createElement("div", {
					className: Object(r.a)({
						[p.a.profileTreatment]: g,
						[p.a.hovercardTreatment]: _
					})
				}, a.a.createElement("div", {
					className: p.a.nftProfileUnitContainer
				}, a.a.createElement(d.a, {
					className: p.a.nftProfileUnit,
					imageUrl: o,
					origin: b
				}))) : a.a.createElement("div", {
					className: Object(r.a)(p.a.snoovatarContainer, t)
				}, n && a.a.createElement(a.a.Fragment, null, a.a.createElement("div", {
					className: p.a.topGlow
				}), a.a.createElement("div", {
					className: p.a.bottomGlow
				}), !m && a.a.createElement(E, null)), a.a.createElement("img", {
					className: Object(r.a)(p.a.snoovatar, {
						[p.a.premiumGlow]: n
					}),
					src: o,
					alt: s.fbt._("User Avatar", null, {
						hk: "3aQoRV"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/reddit/components/Admin/index.tsx"),
				d = n("./src/reddit/icons/svgs/Nsfw/index.tsx"),
				c = n("./src/reddit/icons/svgs/PremiumCircle/index.tsx"),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					title: t,
					username: n,
					isEmployee: o,
					isGold: l,
					isNSFW: m
				} = e;
				return a.a.createElement("h1", {
					className: u.a.snoovatarUserTitle
				}, t || n, l && a.a.createElement("a", {
					title: r.fbt._("{username} has Reddit Premium", [r.fbt._param("username", n)], {
						hk: "3Fylv"
					}),
					href: `${s.a.redditUrl}/premium`
				}, a.a.createElement(c.a, {
					className: u.a.snoovatarPremiumIcon
				})), o && a.a.createElement(i.a, null), m && a.a.createElement(d.a, {
					className: u.a.snoovatarNsfwIcon,
					title: r.fbt._("NSFW - Adult Content", null, {
						hk: "2Iw7mN"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarContainer: "_34XIqvI8-YT1wukR_W8vj6",
				profileTreatment: "_2xpFvOlDs0HF8bwR0pDmqt",
				hovercardTreatment: "_34eH8NsQ_ay5kowUWt9-6E",
				nftProfileUnitContainer: "OfvB_Czxn5wwXiBN6RVlG",
				nftProfileUnit: "n5OW4wkmX5R3yYizuJXw1",
				bottomGlow: "_18b8M-cZftX_frkYRy3DN1",
				topGlow: "_1-PwjX8ETMrfCu2hAkAHFd",
				snoovatar: "_2bLCGrtCCJIMNCZgmAMZFM",
				premiumGlow: "_18BjSGkpIVVfS1xJXL1eoW",
				snoovatarUserName: "_28nEhn86_R1ENZ59eAru8S",
				snoovatarUserTitle: "_3LM4tRaExed4x1wBfK1pmg",
				snoovatarSettingsLink: "PNl4tAYE2TRxhOc34iqcY",
				snoovatarAdminIcon: "kOKnXvA8jebkfk2wVIb9R",
				snoovatarNsfwIcon: "Wb4wBt474lETdwG0YpWID",
				snoovatarPremiumIcon: "_3NZUKOdsA_2X9TrZGSNQyP",
				particleWrapper: "_3sckwXGpSWEBLgH7dBHDSI",
				particle: "R8JC02qFTBSKsWVEamnnh",
				particleX0: "_2FHPkirHUUZZ53WuQRt_ku",
				particleX20: "DeM4CXWl9dmFhzxbChV3v",
				particleX40: "_2jQr36LfrhyZudo0c4r5qb",
				particleX60: "_2ThlCGLfserHkMW64od-w_",
				particleX80: "_2PoCUl_D7HnNn8GhlmyNMn",
				particleX100: "_3xLPb9tG5DMGKH5Qmq0lMn",
				particleFloat1: "_2Tlu1OsBOwuxXIF1MLT2k",
				floatUp1: "_1-74-z_0KhbvP-MLUh63RF",
				particleFloat2: "BW4L6Zj7IYZtY4carTDWz",
				floatUp2: "BhXouEsciSb0lIayg329d",
				particleFloat3: "UjQ0lRcZlylUigyKGCSrO",
				floatUp3: "_2cAI3EiKyyG1hMFOLbG7ka",
				particleFloat4: "_2_ke4gf08pfYrY6lP-aPZ_",
				floatUp1Left: "_2D7to5Dk7q0ZyKN3MMQfuJ",
				particleFloat5: "_2wM6_vp4fY0ziLkOrGaobV",
				floatUp2Left: "_3BR2d3YbOQLeA3LmAmwBJL",
				particleFloat6: "_23n0biPU5CQf96pEUSFupJ",
				floatUp3Left: "_3FnzyfIl1wHuAYA54rlkJH",
				particleDelay1: "_3meTYeYw1F3UdYO0v-gAYr",
				particleDelay2: "_3d8_fd8LwWsj0tyZWIeQdt",
				particleDelay3: "_2PLSBdnBk3jcotYknlKud1",
				particleDelay4: "_2pnTv5ZAxpIbkx38PkPJPg",
				particleDelay5: "_3j1NzwW_t2Ufnx4ed9QabN",
				particleDelay6: "_1hddWHnQ8DFnwilLlN9GEO",
				particleDelay7: "_3eRR1I_MwXC19q9sr8mKaR",
				particleDelay8: "_1sCUpg4sdajNDXrcNTP0qW",
				particleDelay9: "_3J5h1MCyY_xUf2QP7PDSHY",
				particleDelay10: "_2RqcLn9onSZQmKQgvKmSF7"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				i = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/selectors/experiments/econ/index.ts"),
				l = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx"),
				u = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				m = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx"),
				p = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx"),
				b = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				h = n.n(b),
				f = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				g = n.n(f),
				_ = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx"),
				v = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx");
			t.a = e => {
				let {
					bannerBackgroundImage: t,
					compact: n,
					currentUserHasSnoovatar: s,
					editMode: b,
					isDeletingBanner: f,
					isEmployee: O,
					isGold: x,
					isNSFW: E,
					isOwnProfile: y,
					onClickSnoovatar: j,
					onDeleteBanner: C,
					prefersReducedAnimations: k,
					snoovatarUrl: I,
					title: S,
					userCreated: w,
					username: T,
					url: N,
					isHovercard: P
				} = e;
				const R = Object(o.e)(e => !y && !!I && Object(c.f)(e));
				return r.a.createElement(r.a.Fragment, null, r.a.createElement(m.a, {
					bannerBackgroundImage: t,
					editMode: !!b,
					isNSFW: E,
					username: T,
					isDeletingBanner: !!f,
					onDeleteBanner: C
				}), !b && y && r.a.createElement(a.default, {
					to: "/settings/profile",
					className: h.a.snoovatarSettingsLink
				}, r.a.createElement(d.a, {
					name: "settings",
					className: g.a.settingsIcon
				})), r.a.createElement(_.a, {
					isGold: x,
					snoovatarUrl: I,
					prefersReducedAnimations: k,
					origin: P ? i.a.Hovercard : i.a.Profile
				}), r.a.createElement(v.a, {
					isEmployee: O,
					isGold: x,
					isNSFW: E,
					title: S,
					username: T
				}), r.a.createElement(p.a, {
					className: h.a.snoovatarUserName,
					shouldDisplaySnoovatar: !0,
					username: T,
					userCreated: w,
					url: N
				}), (y || !s && !!I) && r.a.createElement(l.a, {
					compact: n,
					currentUserHasSnoovatar: s,
					isOwnProfile: y,
					onClick: j
				}), R && r.a.createElement(u.a, {
					username: T,
					isHovercard: !!P,
					share: {
						username: T
					}
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/index.m.less": function(e, t, n) {
			e.exports = {
				actionItem: "_1l7CTV4NjDjmzX8DiiSgTL",
				AwardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				awardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				textColumn: "_wi1DtT7oN7k_x5oIV8zm",
				iconColumn: "_32tzMaZn7x3dfQC5MXndJn",
				icon: "_12jN4wdttUosp76WHzuieI",
				count: "_6xPPP5HdELF-SZJL8layH",
				awardIcon: "_2Eq8z6UD7I0ul3wnZ-YT80",
				adminIcon: "_1sNQxemH_0rq1jtZAMyAZd",
				snoovatarAdminIcon: "_1rf3zLc4sH59mO7_BEXyze",
				snoovatarPremiumIcon: "_3QQFENUs15G6BHI5pjsswJ",
				button: "_2q1wcTx60QKM_bQ1Maev7b"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, n) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/ProgressBar/index.m.less"),
				i = n.n(a);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: n,
					percent: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(i.a.outerBar, t)
				}, r.a.createElement("div", {
					className: Object(o.a)(i.a.innerBar, n),
					style: {
						width: `${s.toFixed(2)}%`
					}
				}))
			}
		},
		"./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			const o = Object(s.createContext)({
					currentTime: 0,
					setCurrentTime: () => {},
					isLive: !1,
					setIsLive: () => {},
					totalTime: 0,
					setTotalTime: () => {}
				}),
				a = e => {
					let {
						children: t
					} = e;
					const [n, a] = Object(s.useState)(0), [i, d] = Object(s.useState)(!1), [c, l] = Object(s.useState)(0), u = {
						currentTime: n,
						setCurrentTime: a,
						isLive: i,
						setIsLive: d,
						totalTime: c,
						setTotalTime: l
					};
					return r.a.createElement(o.Provider, {
						value: u
					}, t)
				}
		},
		"./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = e => `PublicAccessNetwork--VideoShare--Modal-${e}`,
				o = Object(s.a)({
					resolved: {},
					chunkName: () => "VideoShareModal",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("VideoShareModal").then(n.bind(null, "./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/VideoShareModal.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/VideoShareModal.tsx"
					}
				}, {
					ssr: !1
				});
			t.b = o
		},
		"./src/reddit/components/RawHTMLDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				StyledRawHTMLDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH",
				styledRawHtmlDisplay: "_3ms2Z8z8rPWLXaErcTJ9yH"
			}
		},
		"./src/reddit/components/RawHTMLDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/urlRequested.ts"),
				l = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				u = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				m = n("./src/reddit/components/RawHTMLDisplay/index.m.less"),
				p = n.n(m);
			const b = Object(a.b)(null, e => ({
					onNavigate: t => e(Object(c.a)(t))
				})),
				h = d.a.wrapped(e => {
					const t = Object(l.a)();
					return o.a.createElement("div", {
						className: e.className,
						dangerouslySetInnerHTML: {
							__html: e.html
						},
						onClick: n => {
							((e, t, n, s, r) => {
								if (!e.ctrlKey && !e.metaKey && 1 !== e.button && "A" === e.target.tagName) {
									e.preventDefault();
									const n = e.target.getAttribute("href");
									r && s(n, r), t(n)
								}
								e.target.classList && e.target.classList.contains("md-spoiler-text") && (e.target.dataset.revealed = !0), n && n(e)
							})(n, e.onNavigate, e.onClick, t, e.sourceElement)
						},
						style: {
							...e.style,
							"--RawHTMLDisplay-tr-even": Object(s.f)(Object(u.a)(e).body, .8),
							"--RawHTMLDisplay-tr-odd": Object(s.f)(Object(u.a)(e).line, .8)
						}
					})
				}, "StyledRawHTMLDisplay", p.a);
			t.a = b(Object(i.a)(h))
		},
		"./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_1i9YssSDgp0wmEC43VdLTX",
				prevButton: "_2IBDYNRoTxtwgs13LWRpeM",
				arrowIcon: "QD6Re7us6VNRFNYSiD6to",
				disabled: "_3Lm3n-nPFfEcJoNjVwcm3r"
			}
		},
		"./src/reddit/components/RecurringPostList/EditModal/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-RecurringPostList-EditModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-RecurringPostList-EditModal").then(n.bind(null, "./src/reddit/components/RecurringPostList/EditModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/RecurringPostList/EditModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				contentRow: "Bt3uIal7yhwFSN9JorIng",
				contentRowMeta: "t6hD4d7F06TL2yv9vfp7h",
				title: "_3Evplg8YGmH6GDFsdQ0_nE",
				ownerName: "_215cUXwEuCE5hl0eYEIt_o",
				ownerNameContainer: "_2yAEv_Vw_ItUYbNbAjpSsL"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_29n8ITXzfA7e5YAUZXR5Tv",
				failedStateIndicator: "_3wJPsvksvDytrEsrrZd1vI",
				metaRow: "NjfRmSRZrEkWYNAACYBql",
				replayIcon: "_17pwQtUdmIHAeybqNegNzP",
				metaRowText: "qlCreM7NlHbkzV-xkEGE7",
				recurrenceRules: "rX2aiRDwgPF22x70hQxqp",
				parametricMetaData: "_3mlGpRO1Z1gZJkATQcRNHO",
				pencilIcon: "z5A_DxaYn2G2TQSSQCpi2"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return A
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/telemetry/index.ts"),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/scheduledPosts/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/components/AuthorLink/index.tsx"),
				m = n("./src/reddit/components/Thumbnail/index.tsx"),
				p = n("./src/reddit/components/RecurringPostList/Thumbnail/index.m.less"),
				b = n.n(p);
			var h = e => {
					let {
						post: t
					} = e;
					return r.a.createElement("div", {
						className: b.a.thumbnailContainer
					}, r.a.createElement(m.a, {
						post: t,
						contentTypeClassName: b.a.placeholderIcon
					}))
				},
				f = n("./src/reddit/components/ScheduledPost/index.tsx"),
				g = n("./src/reddit/models/ScheduledPost/index.ts"),
				_ = n("./node_modules/reselect/es/index.js"),
				v = n("./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less"),
				O = n.n(v);
			const {
				fbt: x
			} = n("./node_modules/fbt/lib/FbtPublic.js"), E = Object(_.c)({
				media: (e, t) => {
					let {
						scheduledPost: n
					} = t;
					const s = {
							...f.b
						},
						r = n.postKind === g.e.LINK;
					return r && (s.media = null), {
						...s,
						isNSFW: n.isNsfw,
						title: n.title,
						...r && {
							source: n.url
						},
						pollData: n.poll
					}
				}
			});
			var y = Object(o.b)(E)(e => {
					const {
						scheduledPost: t
					} = e, {
						isPostAsMetaMod: n,
						owner: s
					} = t, o = n ? l.k : Object(g.o)(s) ? s.name : void 0;
					return r.a.createElement("div", {
						className: Object(i.a)(O.a.contentRow, e.className)
					}, r.a.createElement(h, {
						post: e.media
					}), r.a.createElement("div", {
						className: O.a.contentRowMeta
					}, r.a.createElement("div", {
						className: O.a.title
					}, e.scheduledPost.title), r.a.createElement("div", {
						className: O.a.ownerNameContainer
					}, o && r.a.createElement("span", {
						className: O.a.ownerName
					}, x._("by {username}", [x._param("username", r.a.createElement(u.a, {
						author: o,
						isUnstyled: !0
					}, `u/${o}`))], {
						hk: "FAgpK"
					})), e.children)))
				}),
				j = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx");
			var C = Object(j.a)(e => r.a.createElement(r.a.Fragment, null, e.renderOverflowMenu())),
				k = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				I = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				S = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				w = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				T = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				N = n("./src/reddit/components/RecurringPostList/RecurringPost/index.m.less"),
				P = n.n(N);
			const {
				fbt: R
			} = n("./node_modules/fbt/lib/FbtPublic.js"), A = "RECURRING_POSTS__EDIT", M = Object(o.b)(null, (e, t) => ({
				editRecurringPostRequested: () => {
					e(Object(c.c)({
						id: t.item.id,
						subredditId: t.item.subreddit.id
					})), e((e, t) => Object(a.a)(Object(S.e)()(t()))), e(Object(d.i)(A))
				},
				onOpenOverflow: () => {
					e((e, t) => Object(a.a)(Object(S.h)(!0)(t())))
				},
				onUpdateMetadata: n => e(Object(c.b)(n, t.item))
			}));
			class D extends r.a.PureComponent {
				render() {
					const {
						className: e,
						item: t,
						editRecurringPostRequested: n
					} = this.props, s = Object(I.e)(t), o = t.state === g.f.FAILED, {
						owner: a
					} = t, d = Object(g.o)(a) && a.prefixedName;
					return r.a.createElement("div", {
						className: Object(i.a)(e, P.a.container)
					}, o && r.a.createElement("div", {
						className: P.a.failedStateIndicator
					}, R._("Recurring post failed to submit. {Link: update recurring scheduled post} to reset", [R._param("Link: update recurring scheduled post", r.a.createElement(k.o, {
						onClick: n
					}, "Update schedule"))], {
						hk: "3Uitas"
					})), r.a.createElement("div", {
						className: P.a.metaRow
					}, r.a.createElement(T.a, {
						className: P.a.replayIcon
					}), r.a.createElement("div", {
						className: P.a.metaRowText
					}, r.a.createElement("div", {
						className: P.a.recurrenceRules,
						title: s
					}, s), r.a.createElement("div", null, R._("Scheduled by {=[post owner]}", [R._param("=[post owner]", r.a.createElement("span", {
						className: P.a.parametricMetaData
					}, R._("{post owner}", [R._param("post owner", d)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					}))), r.a.createElement("button", {
						onClick: n
					}, r.a.createElement(w.a, {
						className: P.a.pencilIcon
					}))), r.a.createElement(y, {
						scheduledPost: t
					}, r.a.createElement(C, {
						scheduledPost: t,
						onUpdateMetadata: this.props.onUpdateMetadata,
						onOpenOverflow: this.props.onOpenOverflow
					})))
				}
			}
			t.b = M(D)
		},
		"./src/reddit/components/RecurringPostList/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				placeholderIcon: "_2rWvDY38-Fa_14y347Il6W",
				thumbnailContainer: "_3cYCw7NYRAJwj6LvL8esBu"
			}
		},
		"./src/reddit/components/RecurringPostList/index.m.less": function(e, t, n) {
			e.exports = {
				titleContainer: "p9wLLlADU1pVQu4nx3HCF",
				postList: "_1qL48rnJIqcVj5nNuXkDSw",
				pageButtonPortal: "_3lBUQT-Vexm0jXk3WmIYJq",
				recurringPostsContainer: "_2UggIw0Xee7HvpOtrWrepd",
				lastRecurringPostItem: "dx2RjIkNec1E2-a1DyP07",
				emptyContainer: "_1Aurc-hBrd1zsfrQxHeZoq",
				icon: "_1BRYUIpfNcLUEr5L8DeJ8i",
				schedulePostLink: "_1mxUgytAdxfLqJuzRgGifT"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less": function(e, t, n) {
			e.exports = {
				DisplayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				displayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				DropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				dropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				ReasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				reasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				Dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				DropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				dropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				DropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				dropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				DropdownContainer: "_33sg6HoBYll4rCDqRzRUdu",
				dropdownContainer: "_33sg6HoBYll4rCDqRzRUdu"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/controls/Dropdown/index.tsx"),
				d = n("./src/reddit/controls/Dropdown/Row.tsx"),
				c = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				u = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less"),
				m = n.n(u);
			const p = a.a.wrapped(l.a, "DisplayContainer", m.a),
				b = a.a.div("DropdownLabel", m.a),
				h = a.a.div("ReasonTitle", m.a),
				f = e => o.a.createElement(p, null, o.a.createElement(b, null, e.dropdownLabel), e.selectedReason && o.a.createElement(h, null, e.selectedReason)),
				g = a.a.wrapped(i.a, "Dropdown", m.a),
				_ = a.a.wrapped(c.b, "DropdownTriangle", m.a),
				v = a.a.wrapped(d.b, "DropdownRow", m.a),
				O = a.a.button("DropdownContainer", m.a);
			t.a = e => o.a.createElement(O, {
				onClick: e.onToggleDropdown
			}, o.a.createElement(f, {
				dropdownLabel: e.isLoading ? s.fbt._("Loading...", null, {
					hk: "1bT6op"
				}) : s.fbt._("Reason for removal", null, {
					hk: "3C9ecg"
				}),
				selectedReason: e.selectedReason ? e.selectedReason.title : null
			}), o.a.createElement(_, null), e.isDropdownOpen && o.a.createElement(g, {
				isOverlay: !0
			}, o.a.createElement(v, {
				displayText: s.fbt._("None", null, {
					hk: "2443EZ"
				}),
				onClick: () => e.onSelectReason(null)
			}), e.subredditRemovalReasons.map((t, n) => o.a.createElement(v, {
				displayText: `${n+1}. ${t.title}`,
				key: t.title,
				onClick: () => e.onSelectReason(t)
			}))))
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less": function(e, t, n) {
			e.exports = {
				CharacterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				characterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				EmptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				emptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				ModNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				modNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				PrimaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				primaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				RadioOption: "_30JuaHooKBU-I9UQwxEwhL",
				radioOption: "_30JuaHooKBU-I9UQwxEwhL",
				BoldText: "_22_ggqyuhsjDD3F2auyNjc",
				boldText: "_22_ggqyuhsjDD3F2auyNjc",
				ModNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				modNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				MessageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				messageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				Info: "_3Bf1PCbZnJJBM391IWRv8D",
				info: "_3Bf1PCbZnJJBM391IWRv8D",
				SmallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				smallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				FormOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				formOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				ModalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				modalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				FooterRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				footerRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				ButtonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				buttonRow: "_3zZmX0EjloIkzwt2-sRI2_"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "dispatcher", (function() {
				return T
			})), n.d(t, "selector", (function() {
				return N
			})), n.d(t, "connector", (function() {
				return P
			})), n.d(t, "CharacterCountdown", (function() {
				return R
			})), n.d(t, "EmptyState", (function() {
				return A
			})), n.d(t, "MessageInput", (function() {
				return B
			})), n.d(t, "FormOptionsContainer", (function() {
				return W
			})), n.d(t, "ModalFooter", (function() {
				return q
			})), n.d(t, "ButtonRow", (function() {
				return z
			})), n.d(t, "AddRemovalReasonModal", (function() {
				return K
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/removalReasons/index.ts"),
				l = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/controls/InternalLink/index.tsx"),
				b = n("./src/reddit/controls/RadioInput/index.tsx"),
				h = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				f = n("./src/reddit/controls/TextButton/index.tsx"),
				g = n("./src/reddit/icons/fonts/Info/index.tsx"),
				_ = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				v = n("./src/reddit/models/RemovalReason/index.ts"),
				O = n("./src/reddit/selectors/removalReasons.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				E = n("./src/reddit/selectors/user.ts"),
				y = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				j = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.tsx"),
				C = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less"),
				k = n.n(C);
			const {
				fbt: I
			} = n("./node_modules/fbt/lib/FbtPublic.js"), S = e => {
				switch (e) {
					case v.f.Private:
						return "private_subreddit";
					case v.f.PrivateExposed:
						return "private_personal";
					default:
						return e
				}
			}, w = {
				isDropdownOpen: !1,
				message: "",
				modNote: "",
				removalType: v.f.Public,
				selectedReason: null
			}, T = e => ({
				submitBulkRemovalReason: (t, n, s, r, o) => e(Object(c.submitBulkRemovalReason)(t, n, s, r, o)),
				submitRemovalReason: (t, n, s, r, o) => e(Object(c.submitRemovalReason)(t, n, s, r, o))
			}), N = Object(a.c)({
				currentUserName: e => {
					const t = Object(E.k)(e);
					if (t) return t.displayText
				},
				isLoading: O.a,
				isPostCommentAsSubredditEnabled: y.d,
				removalReasons: O.c,
				subredditName: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(x.U)(e, {
						subredditId: n
					}).name
				}
			}), P = Object(o.b)(N, T), R = d.a.wrapped(l.a, "CharacterCountdown", k.a), A = d.a.div("EmptyState", k.a), M = d.a.wrapped(u.o, "ModNoteDescription", k.a), D = d.a.wrapped(m.l, "PrimaryButton", k.a), L = d.a.wrapped(h.a, "RadioOption", k.a), F = d.a.span("BoldText", k.a), U = d.a.wrapped(u.t, "ModNoteInput", k.a), B = d.a.wrapped(u.t, "MessageInput", k.a), G = d.a.wrapped(g.a, "Info", k.a), H = d.a.div("SmallInfoText", k.a), W = d.a.div("FormOptionsContainer", k.a), q = d.a.wrapped(u.g, "ModalFooter", k.a), V = d.a.div("FooterRow", k.a), z = d.a.wrapped(V, "ButtonRow", k.a);
			class K extends r.a.Component {
				constructor(e) {
					super(e), this.onSelectRemovalType = e => {
						this.setState({
							removalType: e
						}), this.props.trackClick(`type_${S(e)}`)()
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onUpdateModNote = e => {
						this.setState({
							modNote: e.currentTarget.value
						})
					}, this.handleToggleDropdown = () => this.setState({
						isDropdownOpen: !this.state.isDropdownOpen
					}), this.closeDropdown = () => {
						this.state.isDropdownOpen && this.setState({
							isDropdownOpen: !1
						})
					}, this.onSelectReason = e => {
						this.setState({
							selectedReason: e
						}), this.props.trackClick("reason")(), e && this.setState({
							message: e.message
						}), this.closeDropdown()
					}, this.canSave = () => !(this.state.message.length > v.a || this.state.modNote.length > v.b) && (this.state.selectedReason ? this.state.message.trim().length > 0 : this.state.modNote.trim().length > 0), this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.canSave()) {
							(t.removalContextType === v.e.Bulk ? e.submitBulkRemovalReason : e.submitRemovalReason)(e.itemIds, t.selectedReason, t.message.trim(), t.removalType, t.modNote.trim()), e.trackClick("sent")(), t.selectedReason && e.trackClick(`sent_${S(t.removalType)}`)(), t.modNote && e.trackClick("sent_modnote")(), e.toggleModal()
						}
					}, this.onCancel = () => {
						this.props.toggleModal(), this.props.trackClick("cancel")()
					}, this.renderRemovalTypeOptions = () => {
						const {
							props: e,
							state: t
						} = this, n = [];
						return t.removalContextType !== v.e.Bulk && (e.isPostCommentAsSubredditEnabled ? (n.push(r.a.createElement(L, {
							key: v.f.PublicSubreddit,
							showButton: !0,
							tabIndex: 0,
							value: v.f.PublicSubreddit
						}, r.a.createElement("div", null, t.removalContextType === v.e.Post ? I._("Public: Write a sticky comment on the post as {subredditName}", [I._param("subredditName", r.a.createElement(F, null, `r/${e.subredditName}`))], {
							hk: "4XPuC"
						}) : I._("Public: Write a reply to the comment as {subredditName}", [I._param("subredditName", r.a.createElement(F, null, `r/${e.subredditName}`))], {
							hk: "FeqMl"
						})))), n.push(r.a.createElement(L, {
							key: v.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: v.f.Public
						}, r.a.createElement("div", null, t.removalContextType === v.e.Post ? I._("Public: Write a sticky comment on the post as {currentUserName}", [I._param("currentUserName", r.a.createElement(F, null, `u/${e.currentUserName}`))], {
							hk: "2jsvEB"
						}) : I._("Public: Write a reply to the comment as {currentUserName}", [I._param("currentUserName", r.a.createElement(F, null, `u/${e.currentUserName}`))], {
							hk: "LZfBm"
						}))))) : n.push(r.a.createElement(L, {
							key: v.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: v.f.Public
						}, r.a.createElement("div", null, t.removalContextType === v.e.Post ? I._("Public: Write a sticky comment on the post", null, {
							hk: "1UIQkF"
						}) : I._("Public: Write a reply to the comment", null, {
							hk: "1iZ1RC"
						}))))), n.push(r.a.createElement(L, {
							key: v.f.Private,
							showButton: !0,
							tabIndex: 0,
							value: v.f.Private
						}, r.a.createElement("div", null, I._("Private: send a Modmail from {subredditName} to the user", [I._param("subredditName", r.a.createElement(F, null, `r/${e.subredditName}`))], {
							hk: "1wUxMe"
						})))), e.currentUserName && n.push(r.a.createElement(L, {
							key: v.f.PrivateExposed,
							showButton: !0,
							tabIndex: 0,
							value: v.f.PrivateExposed
						}, r.a.createElement("div", null, I._("Private: send a Modmail from {currentUserName} to the user", [I._param("currentUserName", r.a.createElement(F, null, `u/${e.currentUserName}`))], {
							hk: "wFSJr"
						})))), n
					}, this.state = {
						...w,
						removalType: e.isPostCommentAsSubredditEnabled ? v.f.PublicSubreddit : v.f.Public,
						removalContextType: Object(v.g)(e.itemIds)
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(u.e, {
						onClick: this.closeDropdown
					}, e.isLoading || e.removalReasons.length > 0 && r.a.createElement(u.i, null, r.a.createElement(_.a, null, r.a.createElement(u.q, null, I._("Add a removal reason", null, {
						hk: "4odEgX"
					}), e.itemIds.length > 1 && I._("({number of items} posts/comments)", [I._param("number of items", e.itemIds.length)], {
						hk: "4u7ZzL"
					})), r.a.createElement(f.a, {
						onClick: this.onCancel
					}, r.a.createElement(u.b, null)))), r.a.createElement(u.l, null, e.isLoading || e.removalReasons.length > 0 ? r.a.createElement(j.a, {
						isDropdownOpen: t.isDropdownOpen,
						isLoading: e.isLoading,
						onSelectReason: this.onSelectReason,
						onToggleDropdown: this.handleToggleDropdown,
						selectedReason: t.selectedReason,
						subredditRemovalReasons: e.removalReasons
					}) : r.a.createElement(A, null, I._("You don't have any removal reasons yet", null, {
						hk: "2cPgPy"
					}), r.a.createElement(p.default, {
						to: `/r/${e.subredditName}/about/removal`,
						target: "_blank"
					}, r.a.createElement(m.r, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, I._("Add a removal reason", null, {
						hk: "3MHM7e"
					})))), t.selectedReason && r.a.createElement(W, null, r.a.createElement(u.h, null, r.a.createElement(b.a, {
						name: "REMOVAL_REASON_INPUT",
						onChange: this.onSelectRemovalType,
						value: t.removalType
					}, this.renderRemovalTypeOptions())), r.a.createElement(B, {
						value: t.message,
						onChange: this.onMessageInputChange
					}), r.a.createElement(R, {
						maxChars: v.a,
						text: t.message.trim()
					}), r.a.createElement(H, null, t.removalType !== v.f.Public && t.removalType !== v.f.PublicSubreddit && r.a.createElement(r.a.Fragment, null, r.a.createElement(G, null), I._("A link to the removed content will be appended to your message", null, {
						hk: "1DbEGF"
					}))))), r.a.createElement(q, null, r.a.createElement(V, null, r.a.createElement(M, null, I._("Mod note (Only mods will see this note)", null, {
						hk: "3InAsy"
					}))), r.a.createElement(V, null, r.a.createElement(U, {
						placeholder: I._("This is a short note to your mod team on why the content was removed.", null, {
							hk: "4goqsC"
						}),
						value: t.modNote,
						onChange: this.onUpdateModNote
					})), r.a.createElement(V, null, r.a.createElement(R, {
						maxChars: v.b,
						text: t.modNote.trim()
					})), r.a.createElement(z, null, r.a.createElement(m.o, {
						onClick: this.onCancel,
						"data-redditstyle": !0
					}, I._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(D, {
						onClick: this.onSubmit,
						disabled: !this.canSave(),
						"data-redditstyle": !0
					}, I._("Submit", null, {
						hk: "4aU3dh"
					})))))
				}
			}
			t.default = Object(i.a)(P(K))
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less": function(e, t, n) {
			e.exports = {
				GenericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				genericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				DeleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				deleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				PrimaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				primaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				TextArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				textArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				ModalFooter: "a8KANZ6wvta1y_8QSZmeS",
				modalFooter: "a8KANZ6wvta1y_8QSZmeS",
				Input: "tWupUgopHVvjD9_bZZVy0",
				input: "tWupUgopHVvjD9_bZZVy0"
			}
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less": function(e, t, n) {
			e.exports = {
				EditButton: "_3Z3niHttcaJCxThBE2-eNN",
				editButton: "_3Z3niHttcaJCxThBE2-eNN",
				Row: "_1ERpdeakuaRdyW5OEGvV_a",
				row: "_1ERpdeakuaRdyW5OEGvV_a",
				ReasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				reasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				ReasonText: "_3Vv7n3XK-P5uslyAy7Li0w",
				reasonText: "_3Vv7n3XK-P5uslyAy7Li0w"
			}
		},
		"./src/reddit/components/RemovalReasons/index.m.less": function(e, t, n) {
			e.exports = {
				Rules: "-z_XjylM-4VxXIVlUJupm",
				rules: "-z_XjylM-4VxXIVlUJupm",
				title: "_1wclVdwRTNycOnlbH1IkQU",
				subtext: "_2IxjljuOnx5CrtK0CMzstT",
				removalReasonsCount: "_1B3ouNDntikHo-PDWo9Gwk",
				tooltipContent: "_2KMnTQyMVHRHQBFfwLKxrJ",
				tooltip: "_3YCzepP6_mhRVOdUDnmkEo"
			}
		},
		"./src/reddit/components/RemovalReasons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/constants/colors.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/removalReasons/index.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/ContentTooltip/index.tsx"),
				h = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				g = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				O = n("./src/reddit/helpers/localStorage/index.ts"),
				x = n("./src/reddit/icons/fonts/index.tsx"),
				E = n("./src/reddit/models/RemovalReason/index.ts"),
				y = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/removalReasons.ts"),
				C = n("./src/higherOrderComponents/asModal/index.tsx"),
				k = n("./src/lib/lessComponent.tsx"),
				I = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				S = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				w = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				T = n("./src/reddit/controls/TextButton/index.tsx"),
				N = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				P = n("./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less"),
				R = n.n(P);
			const A = {
					message: "",
					title: ""
				},
				M = k.a.wrapped(S.f, "GenericGreetingText", R.a),
				D = k.a.wrapped(S.s, "DeleteReasonButton", R.a),
				L = k.a.wrapped(v.l, "PrimaryButton", R.a),
				F = k.a.wrapped(S.t, "TextArea", R.a),
				U = k.a.wrapped(S.g, "ModalFooter", R.a),
				B = k.a.wrapped(w.c, "Input", R.a);
			class G extends a.a.Component {
				constructor(e) {
					super(e), this.onTitleInputChange = e => {
						e.currentTarget.value.length <= E.d && this.setState({
							title: e.currentTarget.value
						})
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onSave = () => {
						const e = {
							title: this.state.title.trim(),
							message: this.state.message.trim()
						};
						this.props.removalReason && (e.id = this.props.removalReason.id), this.props.onSubmit(e), this.props.sendEvent(), this.props.toggleModal()
					}, this.canSave = () => this.state.title.trim().length > 0 && this.state.title.trim().length <= E.d && this.state.message.trim().length > 0 && this.state.message.trim().length <= E.a, this.state = e.removalReason ? {
						title: e.removalReason.title,
						message: e.removalReason.message
					} : A
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(S.e, null, a.a.createElement(S.i, null, a.a.createElement(N.a, null, a.a.createElement(S.q, null, e.removalReason ? r.fbt._("Edit removal reason", null, {
						hk: "1P0jAw"
					}) : r.fbt._("Add new reason", null, {
						hk: "jDYo"
					})), a.a.createElement(T.a, {
						onClick: e.toggleModal
					}, a.a.createElement(S.b, null)))), a.a.createElement(S.l, null, a.a.createElement(S.h, null, a.a.createElement(B, {
						placeholder: r.fbt._("Removal reason title", null, {
							hk: "4hFurd"
						}),
						value: t.title,
						onChange: this.onTitleInputChange
					}), a.a.createElement(I.a, {
						text: t.title.trim(),
						maxChars: E.d
					})), a.a.createElement(S.o, null, r.fbt._("Reason message:", null, {
						hk: "yMtrM"
					})), a.a.createElement(M, null, r.fbt._("Hi u/username,", null, {
						hk: "NE4XP"
					})), a.a.createElement(F, {
						placeholder: r.fbt._("Write a message that will communicate to the user why their post was removed.", null, {
							hk: "4u5AVO"
						}),
						value: t.message,
						onChange: this.onMessageInputChange,
						"data-redditstyle": !0
					}), a.a.createElement(I.a, {
						text: t.message.trim(),
						maxChars: E.a
					})), a.a.createElement(U, null, a.a.createElement(L, {
						onClick: this.onSave,
						"data-redditstyle": !0,
						disabled: !this.canSave()
					}, e.removalReason ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add new reason", null, {
						hk: "34P0ii"
					})), a.a.createElement(S.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.removalReason && a.a.createElement(D, {
						onClick: e.onDeleteReason
					}, r.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var H = Object(C.a)(G),
				W = n("./src/reddit/layout/row/Inline/index.tsx"),
				q = n("./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less"),
				V = n.n(q);
			const {
				fbt: z
			} = n("./node_modules/fbt/lib/FbtPublic.js"), K = k.a.wrapped(v.r, "EditButton", V.a), Q = k.a.wrapped(W.a, "Row", V.a), J = k.a.div("ReasonNumber", V.a), Y = k.a.div("ReasonText", V.a);
			var X = e => a.a.createElement(Q, null, a.a.createElement(J, null, e.index + 1), a.a.createElement(Y, null, e.removalReason.title), a.a.createElement(K, {
					onClick: e.onEdit,
					"data-redditstyle": !0
				}, z._("Edit", null, {
					hk: "1nftDt"
				}))),
				Z = n("./src/reddit/components/RemovalReasons/index.m.less"),
				$ = n.n(Z);
			const ee = "RemovalReasons--Tooltip",
				te = 1e4,
				ne = {
					reasonToEdit: null
				},
				se = Object(d.c)({
					isConfirmModalOpen: e => "RemovalReasons--Modal--DeleteConfirmation" === Object(y.a)(e),
					isRemovalReasonEditorModalOpen: e => "RemovalReasons--Editor--Modal" === Object(y.a)(e),
					removalReasons: j.c
				}),
				re = Object(i.b)(se, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addRemovalReason: t => e(Object(u.addRemovalReason)(n, t)),
						deleteRemovalReason: t => e(Object(u.deleteRemovalReason)(n, t)),
						editRemovalReason: t => e(Object(u.editRemovalReason)(n, t)),
						toggleConfirmationModal: () => e(Object(l.i)("RemovalReasons--Modal--DeleteConfirmation")),
						toggleReasonEditorModal: () => e(Object(l.i)("RemovalReasons--Editor--Modal")),
						onShowTooltip: t => e(Object(m.f)({
							tooltipId: t
						})),
						onHideTooltip: () => e(Object(m.i)())
					}
				});
			class oe extends a.a.Component {
				constructor(e) {
					super(e), this.onShowTooltip = () => {
						Object(O.u)() || (this.props.onShowTooltip(ee), setTimeout(() => {
							this.props.onHideTooltip()
						}, te), Object(O.Pb)())
					}, this.onAddReason = () => {
						this.setState({
							reasonToEdit: null
						}), this.props.toggleReasonEditorModal(), this.props.sendEventWithName("add_new")()
					}, this.onEditReason = e => () => {
						this.setState({
							reasonToEdit: e
						}), this.props.toggleReasonEditorModal(), e && this.props.sendEventWithName("edit")()
					}, this.onClickTooltip = () => {
						this.props.onHideTooltip()
					}, this.renderReasonEditorModal = () => a.a.createElement(H, {
						onDeleteReason: () => {
							this.props.toggleReasonEditorModal(), this.props.toggleConfirmationModal()
						},
						onSubmit: this.state.reasonToEdit ? this.props.editRemovalReason : this.props.addRemovalReason,
						removalReason: this.state.reasonToEdit,
						sendEvent: this.state.reasonToEdit ? this.props.sendEventWithName("edit_save") : this.props.sendEventWithName("new_save"),
						subredditId: this.props.subredditId,
						toggleModal: this.onEditReason(null),
						withOverlay: !0
					}), this.state = ne
				}
				componentDidMount() {
					this.onShowTooltip()
				}
				render() {
					const {
						deleteRemovalReason: e,
						isConfirmModalOpen: t,
						isRemovalReasonEditorModalOpen: n,
						removalReasons: o,
						sendEventWithName: i,
						toggleConfirmationModal: d
					} = this.props;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(g.c, null, a.a.createElement(v.l, {
						onClick: this.onAddReason,
						disabled: o.length >= E.c || n,
						"data-redditstyle": !0
					}, r.fbt._("Add removal reason", null, {
						hk: "2fHPVe"
					}))), a.a.createElement(g.a, null, a.a.createElement(g.b, {
						className: $.a.title
					}, r.fbt._("Removal reasons", null, {
						hk: "3IWxkH"
					}), a.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010094892`
					}), a.a.createElement(_.n, {
						className: $.a.subtext
					}, r.fbt._("Help people become better posters by giving a short reason why their post was removed.", null, {
						hk: "2X1Ma2"
					}), a.a.createElement("span", {
						className: $.a.removalReasonsCount,
						id: ee,
						onClick: this.onClickTooltip
					}, a.a.createElement(b.a, {
						className: $.a.tooltip,
						defaultTooltipPosition: "left",
						tooltipId: ee,
						caretColor: {
							right: c.a.alienblue
						}
					}, a.a.createElement("div", {
						className: $.a.tooltipContent
					}, r.fbt._("NEW! Add up to 50 removal reasons.", null, {
						hk: "1LM0MR"
					}))), o.length, "/", E.c))), o.length > 0 ? o.map((e, t) => a.a.createElement(X, {
						index: t,
						key: e.id,
						onEdit: this.onEditReason(e),
						removalReason: e
					})) : a.a.createElement(h.c, {
						text: r.fbt._("No removal reasons yet", null, {
							hk: "1j70G1"
						})
					}, a.a.createElement(x.a, {
						name: "rules",
						className: $.a.Rules
					}))), n && this.renderReasonEditorModal(), t && this.state.reasonToEdit && a.a.createElement(p.a, {
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete reason", null, {
							hk: "q2qun"
						}),
						modalText: r.fbt._("Are you sure you want to delete this reason?", null, {
							hk: "1FTfMR"
						}),
						onConfirm: () => {
							this.state.reasonToEdit && e(this.state.reasonToEdit.id)
						},
						toggleModal: () => {
							d(), this.setState({
								reasonToEdit: null
							})
						},
						trackClick: i("delete"),
						withOverlay: !0
					}))
				}
			}
			t.a = re(oe)
		},
		"./src/reddit/components/ReportFlow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
				backgroundColor: r.a.overlayReportFlow
			};
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "ReportFlow",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlow.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ReportFlow/_ReportFlow.tsx"
				}
			})
		},
		"./src/reddit/components/ReportFlow/new.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
					backgroundColor: r.a.overlayReportFlow
				},
				a = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlow",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx"
					}
				}),
				i = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlowNew",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("ReportFlowNew").then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx"
					}
				});
			t.b = i
		},
		"./src/reddit/components/ResizeSensor/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/raf/index.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o);
			class i extends a.a.Component {
				constructor(e) {
					super(e), this.isIE = () => /Trident/.test(navigator.userAgent), this.setContainerRef = e => {
						this.containerRef || (this.containerRef = e, this.createSensor())
					}, this.handleResize = () => {
						void 0 !== this.frame && r.a.cancel(this.frame), this.frame = r()(this.props.onResize)
					}, this.containerRef = e.containerRef
				}
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					this.createSensor()
				}
				createSensor() {
					if (!this.containerRef || this.sensor) return;
					this.sensor = document.createElement("object"), this.sensor.setAttribute("style", "\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n      pointer-events: none;\n      z-index: -1;\n    "), this.sensor.setAttribute("tabindex", "-1"), this.sensor.onload = () => {
						this.props.onResize(), this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.addEventListener("resize", this.handleResize)
					}, this.sensor.type = "text/html";
					const e = this.isIE();
					e && this.containerRef.appendChild(this.sensor), this.sensor.data = "about:blank", e || this.containerRef.appendChild(this.sensor), this.props.onResize()
				}
				componentWillUnmount() {
					this.sensor && (this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.removeEventListener("resize", this.handleResize), this.containerRef && this.containerRef.removeChild(this.sensor))
				}
				render() {
					return a.a.createElement("div", {
						ref: this.setContainerRef
					})
				}
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = a.a.wrapped(e => {
				const {
					children: t,
					className: n,
					renderBelow: s,
					text: a,
					tooltipContentClass: i,
					...l
				} = e;
				return r.a.createElement("div", c({}, l, {
					className: Object(o.a)(d.a.container, n)
				}), a ? r.a.createElement("div", {
					className: Object(o.a)(d.a.tooltip, i, s ? d.a.below : d.a.above)
				}, a) : null, t)
			}, "HoverTooltip", d.a)
		},
		"./src/reddit/components/RichTextEditor/emotes/EmoteButton.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s, r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/components/RichTextEditor/emotes/emoteButton.m.less"),
				c = n.n(d);
			! function(e) {
				e[e.Inside = 0] = "Inside", e[e.Outside = 1] = "Outside"
			}(s || (s = {}));
			const l = 750,
				u = e => {
					let {
						className: t,
						containerClassName: n,
						imageClassName: d,
						disabled: u,
						id: m,
						imagePath: p,
						onClick: b,
						onKeyDown: h,
						title: f,
						onClickDelete: g,
						mouseEnterBufferTime: _ = l
					} = e;
					const v = Object(r.useRef)(s.Outside),
						[O, x] = Object(r.useState)(!1);
					return o.a.createElement("div", {
						className: Object(a.a)(c.a.container, n),
						onMouseEnter: g ? () => {
							v.current = s.Inside, setTimeout(() => {
								v.current === s.Inside && x(!0)
							}, _)
						} : void 0,
						onMouseLeave: g ? () => {
							v.current = s.Outside, x(!1)
						} : void 0
					}, O && o.a.createElement("button", {
						className: c.a.deleteButton,
						onClick: g
					}, o.a.createElement(i.b, {
						className: c.a.deleteIcon
					})), o.a.createElement("button", {
						className: Object(a.a)(c.a.emoteButton, t),
						disabled: u,
						id: m,
						title: f,
						onClick: b,
						onKeyDown: h,
						tabIndex: 1
					}, o.a.createElement("div", {
						className: Object(a.a)(c.a.emoteImage, d),
						style: {
							backgroundImage: `url(${p})`
						}
					})))
				}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/DeleteEmojiModal.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				a = n("./src/reddit/components/RichTextEditor/emotes/Powerups/emotesSection.m.less"),
				i = n.n(a);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js"), c = e => {
				let {
					emojiUrl: t,
					onConfirm: n,
					onCancel: s,
					onClose: a
				} = e;
				return r.a.createElement(o.a, {
					onConfirm: n,
					onCancel: s,
					onClose: a,
					headerText: d._("Delete emoji", null, {
						hk: "27GEDb"
					}),
					modalText: r.a.createElement("p", {
						className: i.a.deleteModalContainer
					}, r.a.createElement("img", {
						className: i.a.deleteModalImage,
						src: t
					}), d._("Are you sure you want to delete this emoji?", null, {
						hk: "1bmNdu"
					})),
					actionText: d._("Delete", null, {
						hk: "4lt26q"
					}),
					cancelActionText: d._("Go back", null, {
						hk: "3zzMov"
					}),
					withOverlay: !0
				})
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/emotesSection.m.less": function(e, t, n) {
			e.exports = {
				addButton: "_131SsHx6UfUQsBbPHh8m1D",
				addButtonDisabled: "eRYyo8WYr0Hti7IAGe_gO",
				addIcon: "R3xFUrQvsMx3gn2gqGv0w",
				uploadInput: "_183AY4WVSatH9Qe_MAXDE-",
				loadingContainer: "_2xoHnDYYs7peY_5Im4vQDn",
				emoteButton: "_2s68zj-4Pb6nTX2IUDzLkz",
				placeholderEmoteButton: "_1xLXujnXEDJIfZl94qCnb6",
				customEmoteImage: "_3yyGg_Mez5tP41OCc9Nne8",
				emotePackTitle: "_2ukOHQG9KkBde1ztDLudOP",
				newIcon: "_3_QvdlHkxRkqBb9ZNRQZXx",
				emotePackSubtitle: "_1-OnXZrmw20X79pBvJWaEy",
				emotes: "DNWbRyf3z71g0nqfrzQ4T",
				freeEmotePack: "_13ylKQWUAkdhTJRIuHyJfq",
				disabled: "Ejq92_2ovDkhH3FjoerXW",
				deleteModalContainer: "_2JcZhkY3vXBVFEAMyuM8D5",
				deleteModalImage: "_1V2bCmzxzskT1fA3fY70lK"
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/useEmojiUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/actions/economics/powerups/index.ts");
			const a = (e, t, n, a, i, d) => {
				const c = Object(r.d)(),
					l = Object(s.useRef)(null),
					[u, m] = Object(s.useState)(0),
					p = async function(t) {
						let n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
							s = arguments.length > 2 ? arguments[2] : void 0;
						try {
							return await c(Object(o.b)({
								subredditId: e,
								file: t
							})), s(), {
								success: !0
							}
						} catch (r) {
							return n ? p(t, !1, s) : (s(), {
								success: !1,
								error: r.message
							})
						}
					}, b = () => m(e => e - 1);
				return {
					maxEmojisUploaded: t.length >= 20,
					maxEmojisUploading: t.length + u >= 20,
					onFileChange: async e => {
						const s = e.currentTarget.files;
						if (!(null == s ? void 0 : s.length)) return;
						if (s.length + t.length > 20) {
							const e = 20 - t.length;
							return null == n || n(e), void(l.current && (l.current.value = ""))
						}
						m(s.length), null == a || a(s.length);
						const r = await Promise.all([...s].map(e => p(e, !0, b))),
							o = r.reduce((e, t) => e + (t.success ? 1 : 0), 0);
						o > 0 && (null == i || i(o));
						const c = r.length - o;
						c > 0 && (null == d || d(c)), l.current && (l.current.value = ""), m(0)
					},
					numUploading: u,
					onClickUpload: () => {
						var e;
						null === (e = l.current) || void 0 === e || e.click()
					},
					uploadInput: l
				}
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/emoteButton.m.less": function(e, t, n) {
			e.exports = {
				container: "_1xDkiINVQUjf0tjZcbF3a7",
				emoteButton: "_2-SqXmcI6RcjKEbTfkrLVe",
				emoteImage: "_1WpEszyqkHofX36kiLrJ8x",
				deleteButton: "_2mgKNuqCKnjSfh2dBW7iqI",
				deleteIcon: "_1BJNzscR61JS-t7pR4p3Ik"
			}
		},
		"./src/reddit/components/SEOTitle/index.m.less": function(e, t, n) {
			e.exports = {
				Title: "_eYtD2XCVieq6emjKBH3m",
				title: "_eYtD2XCVieq6emjKBH3m"
			}
		},
		"./src/reddit/components/SEOTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r, o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js");
			! function(e) {
				e[e.Collection = 0] = "Collection", e[e.HeaderSelector = 1] = "HeaderSelector", e[e.PostComments = 2] = "PostComments", e[e.PostItem = 3] = "PostItem", e[e.TopicHeader = 4] = "TopicHeader", e[e.Widget = 5] = "Widget"
			}(s || (s = {})),
			function(e) {
				e[e.H1 = 1] = "H1", e[e.H2 = 2] = "H2", e[e.H3 = 3] = "H3", e[e.H4 = 4] = "H4", e[e.H5 = 5] = "H5", e[e.H6 = 6] = "H6"
			}(r || (r = {}));
			var c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/helpers/postCollection.ts");
			const u = [c.Nb.COMMENTS, c.Nb.COLLECTION_COMMENTS],
				m = (e, t) => {
					if (!e) return [];
					const n = u.includes(e),
						r = e === c.Nb.COLLECTION_COMMENTS || t && Object(l.a)(t),
						o = c.V.has(e),
						a = c.Cb.has(e),
						i = e === c.Nb.SUBREDDIT,
						d = e === c.Nb.TOPIC;
					let m, p, b;
					return o && !i || a ? m = s.HeaderSelector : r ? m = s.Collection : n ? m = s.PostComments : d && (m = s.TopicHeader), (o || a || r || n) && (p = s.Widget), (o || n) && (b = s.PostItem), [m, p, b]
				};
			var p = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/selectors/platform.ts"),
				h = n("./src/reddit/components/SEOTitle/index.m.less"),
				f = n.n(h);
			const g = e => {
					let {
						level: t,
						children: n
					} = e;
					const s = `h${t}`;
					return a.a.createElement(s, {
						className: f.a.Title
					}, n)
				},
				_ = Object(p.u)(),
				v = Object(i.b)(() => Object(d.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && Object(b.n)(e, {
						page: n
					})
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && n.meta && n.meta.name
				}, (e, t) => {
					let {
						type: n
					} = t;
					return n
				}, (e, t, n) => ({
					level: m(t, e).indexOf(n) + 1 || void 0
				})));
			class O extends a.a.Component {
				render() {
					const {
						children: e,
						level: t
					} = this.props;
					return t ? a.a.createElement(g, {
						level: t
					}, e) : a.a.createElement(a.a.Fragment, null, e)
				}
			}
			t.b = _(v(O))
		},
		"./src/reddit/components/SaveIndicator/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_13ubiSSjUBWaeyJM-itH7X",
				titleFontH2: "_2V4_0G0gJO4R1v-_sO5D_j",
				titleFontH3: "_32Uo9qgINsZX5CSOtFM0e2",
				titleFontH4: "_2AWEwOuuK5wBnQGyiB5sSq",
				titleFontH5: "_8460KZXLwbKYkuLfDNr_-",
				titleFontH6: "_7GhKEQrcNu3JuSHqj9pJc",
				metadataFont: "qilOmvvpr4iY8iiHxuV5Y",
				flairFont: "SovT7HaLHcqz1BM9MWXPA",
				labelsFont: "_3Ngpaj84VwPqy3s6Tr3GEJ",
				actionFont: "_3RLwRjy5tGM8nl4kID8Tfg",
				smallButtonFont: "nb_OfRzzHKNkGteZC-TyY",
				largeButtonFont: "_2fhzAdDCEdDseFevwE6mBQ",
				strongTextFont: "_2vvi6WI_4yX2H2H-b2aBCF",
				tabFont: "_3E-egg7Cy7bL6JzsZuFTcn",
				buttonFontXS: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontXs: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontS: "_2fsKOual6xDsvmfB9Z_Gab",
				buttonFontM: "_3pHwBKAuUlalHSG7AJTpEP",
				buttonFontL: "fC3WZNZt7dm3kVDpkLV2",
				buttonFontXL: "_1A7d3cQhRmAUn05diOyF_D",
				buttonFontXl: "_1A7d3cQhRmAUn05diOyF_D",
				bodyFontH1: "_2_nWm6krUlDJnEF9pk7xNK",
				bodyFontH2: "_3zzd4vTmfrG1aK91i6m2j9",
				bodyFontH3: "_3tFwmsoGmyp52EFCoZ0GCV",
				bodyFontH4: "MdKdTVjxUaPPkDvG_msXr",
				bodyFontH5: "_2dNFOZceckCrwGYG8Avi-k",
				bodyFontH6: "_3sSb6LvOgvwy7eawwX4Gtq",
				bodyFontH6Small: "_1W_jjzqvHEQ70RO1EVPhFD",
				bodyFont: "_2fiuzofxgtB6yu9nAHLuqW",
				bodyFontSmall: "_2IcqO4djjAVsOalbW_Zpa9",
				bodyFontMono: "_2i_EmKzaFJfCskmkHdmmgJ",
				icon: "cO908rcinWKz894i8I5jJ",
				pendingIcon: "U2dgL2i9_EJN8R_MLFTjS",
				savedIcon: "_1iGcF7LdvT-OMRgF7xKWqm",
				saveErrorIcon: "kWS-87C-v-iTlGGxQOmxu",
				caption: "_1MAESVWNqu44JbWmHGJsuI"
			}
		},
		"./src/reddit/components/ScheduledPost/ControlRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1xM2tjm8c7LuqnoEJG1Ws1",
				controlRow: "P7KCCrRfT4TO2wcnk_Kjv",
				controlRowItem: "_1AkGbjxtRpq3ZhKADdUTU3"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				content: "_297_pyPlxmqBF0tLkUhTME",
				icon: "_1n_ojuNDT8JeH9DxmHJZt9",
				author: "_1k9D_vEsQ8odWCNERbDOxX",
				modIcon: "_3ryKOTfQ_vqgap0EZsZHAl",
				stickyIcon: "qfjbZcX6-FZK2BGrOXezD"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/components/AuthorLink/index.tsx"),
				i = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				d = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				c = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				l = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/components/ScheduledPost/MetaLine/index.m.less"),
				p = n.n(m);
			class b extends r.a.PureComponent {
				render() {
					if (!Object(u.p)(this.props.subreddit)) return null;
					const {
						isModDistinguished: e,
						isPostAsMetaMod: t,
						subreddit: n,
						owner: s,
						isSticky: m
					} = this.props, b = t ? o.k : Object(u.o)(s) ? s.name : void 0;
					return r.a.createElement("span", {
						className: p.a.content
					}, r.a.createElement(i.a, {
						to: n.path
					}, n.prefixedName), b && r.a.createElement(r.a.Fragment, null, r.a.createElement(d.a, null), r.a.createElement(a.a, {
						className: p.a.author,
						author: b,
						isUnstyled: !0
					}, `u/${b}`)), e && r.a.createElement(l.a, {
						className: p.a.modIcon
					}), m && r.a.createElement(c.a, {
						className: p.a.stickyIcon
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/reddit/components/OverflowMenu/index.tsx"),
				c = n("./src/reddit/controls/CheckboxMenuItem/index.tsx");
			var l = e => r.a.createElement(d.b, {
					dropdownId: `SCHEDULED_POST_DROPDOWN${e.scheduledPostId}`,
					onClick: e.onOpenOverflow
				}, r.a.createElement(c.a, {
					isSelected: e.isSticky,
					onClick: e.onToggleIsSticky,
					text: i.fbt._("Sticky post", null, {
						hk: "UOShB"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isModDistinguished,
					onClick: e.onToggleIsModDistinguished,
					text: i.fbt._("Distinguish as Mod", null, {
						hk: "3opu7K"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isOriginalContent,
					onClick: e.onToggleIsOC,
					text: i.fbt._("Mark as OC", null, {
						hk: "32LGcQ"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isNsfw,
					onClick: e.onToggleIsNsfw,
					text: i.fbt._("Mark as NSFW", null, {
						hk: "2qBIcp"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isSpoiler,
					onClick: e.onToggleIsSpoiler,
					text: i.fbt._("Mark as Spoiler", null, {
						hk: "rOev9"
					})
				})),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const m = Object(a.c)({
					isLoading: u.j
				}),
				p = Object(o.b)(m);

			function b(e) {
				class t extends r.a.Component {
					constructor(e) {
						super(e), this.isSaving = !1, this.onToggleMetadata = e => {
							this.setState({
								...this.state,
								[e]: !this.state[e]
							}), this.isSaving = !0, this.props.onUpdateMetadata(e)
						}, this.onToggleIsSticky = () => this.onToggleMetadata("isSticky"), this.onToggleIsModDistinguished = () => this.onToggleMetadata("isModDistinguished"), this.onToggleIsOriginalContent = () => this.onToggleMetadata("isOriginalContent"), this.onToggleIsNsfw = () => this.onToggleMetadata("isNsfw"), this.onToggleIsSpoiler = () => this.onToggleMetadata("isSpoiler"), this.renderOverflowMenu = () => r.a.createElement(l, {
							scheduledPostId: this.props.scheduledPost.id,
							onOpenOverflow: this.props.onOpenOverflow,
							onToggleIsSticky: this.onToggleIsSticky,
							onToggleIsModDistinguished: this.onToggleIsModDistinguished,
							onToggleIsOC: this.onToggleIsOriginalContent,
							onToggleIsNsfw: this.onToggleIsNsfw,
							onToggleIsSpoiler: this.onToggleIsSpoiler,
							isModDistinguished: this.state.isModDistinguished,
							isOriginalContent: this.state.isOriginalContent,
							isNsfw: this.state.isNsfw,
							isSticky: this.state.isSticky,
							isSpoiler: this.state.isSpoiler
						}), this.state = {
							isModDistinguished: e.scheduledPost.isModDistinguished,
							isNsfw: e.scheduledPost.isNsfw,
							isOriginalContent: e.scheduledPost.isOriginalContent,
							isSpoiler: e.scheduledPost.isSpoiler,
							isSticky: !!e.scheduledPost.sticky && "NONE" !== e.scheduledPost.sticky
						}
					}
					componentDidUpdate(e) {
						e.isLoading && !this.props.isLoading && this.isSaving && (this.isSaving = !1, this.setState({
							isModDistinguished: this.props.scheduledPost.isModDistinguished || !1,
							isNsfw: this.props.scheduledPost.isNsfw || !1,
							isOriginalContent: this.props.scheduledPost.isOriginalContent || !1,
							isSpoiler: this.props.scheduledPost.isSpoiler || !1,
							isSticky: !!this.props.scheduledPost.sticky && "NONE" !== this.props.scheduledPost.sticky
						}))
					}
					render() {
						const {
							isLoading: t,
							scheduledPost: n,
							onUpdateMetadata: s,
							onOpenOverflow: o,
							...a
						} = this.props, i = {
							...a,
							renderOverflowMenu: this.renderOverflowMenu
						};
						return r.a.createElement(e, i)
					}
				}
				return t.displayName = `WithOverflowMenu(${e.displayName||e.name})`, p(t)
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				title: "_3jA9JBnv4bqmmiAw3Akmug"
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ScheduledPost/PostTitle/index.m.less"),
				a = n.n(o);
			class i extends r.a.PureComponent {
				render() {
					return r.a.createElement("span", {
						className: a.a.title
					}, this.props.title)
				}
			}
			t.a = i
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1YrhJ0z1RfTXg7jHYgApSr",
				error: "_2_f_ecVpbx4yoMzazJYkDP",
				retryButton: "_1KbjdUJVdbZQOJN8d6LTsX",
				parametricMetaData: "_2x3oXUTdLAKAob3BYLRkmH"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "qDE3oDok1392-t8IDOBfk",
				clock: "_2sfIhl6E6vfZCwxx54EUNB",
				parametricMetaData: "_3bAfM2inJTjD3ZXNzO5nE5"
			}
		},
		"./src/reddit/components/ScheduledPost/index.m.less": function(e, t, n) {
			e.exports = {
				body: "_320l2eVngsr4Ord9dXc2er",
				container: "_26zeT5d9JKXWbWzOT4ncpg",
				thumbnailContainer: "_2UwJRJuqEbkRCV8O6REq8h",
				mainBody: "_3pHV3zwe-Q9-xNEB0iM3WT",
				backgroundWrapper: "_2KWv8ukh9RMgpOturAiV9z",
				content: "hAQclO6xLNG3WDMgkywGo",
				flairList: "_1-tY_25z_pkhbFvUz2-AqS",
				Icon: "_3XIOnqmz8vxSaPmPEY11Wh",
				icon: "_3XIOnqmz8vxSaPmPEY11Wh"
			}
		},
		"./src/reddit/components/ScheduledPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return ge
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/telemetry/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/reddit/actions/scheduledPosts/index.ts"),
				m = n("./src/reddit/actions/scheduledPosts/delete.ts"),
				p = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				h = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/actions/urlRequested.ts"),
				_ = n("./src/lib/makeGqlRequest/index.ts"),
				v = n("./src/redditGQL/operations/SubmitScheduledPost.json");
			var O = n("./src/reddit/models/Toast/index.ts");
			const x = Object(b.a)(h.l),
				E = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const a = Object(i.p)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (!a) return void n(Object(f.f)(Object(f.e)(h.u(), O.b.Error)));
					const d = await ((e, t) => Object(_.a)(e, {
						...v,
						variables: t
					}))(o(), {
						input: {
							id: a.id
						}
					});
					if (!d.ok) return void n(Object(f.f)(Object(f.e)(h.v(), O.b.Error, h.s(), E(e, t))));
					const c = d.body.data.submitScheduledPost.post.permalink;
					n(Object(g.a)(c, !1)), n(Object(f.f)(Object(f.e)(h.x(), O.b.SuccessCommunity))), n(x({
						subredditId: e,
						scheduledPostId: t
					}))
				};
			var y = n("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				j = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				C = n("./src/reddit/components/FlairList/index.tsx"),
				k = n("./src/reddit/components/PostLeftRail/index.tsx"),
				I = n("./src/lib/classNames/index.ts"),
				S = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				w = n("./src/reddit/controls/Score/index.tsx"),
				T = n("./src/reddit/models/Vote/index.ts"),
				N = n("./src/reddit/components/VerticalVotes/index.m.less"),
				P = n.n(N);
			class R extends o.a.PureComponent {
				render() {
					return o.a.createElement("div", {
						className: P.a.votesContainer
					}, o.a.createElement("button", {
						className: P.a.disabledVoteIcon,
						"aria-label": s.fbt._("Upvote", null, {
							hk: "4aEt1X"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(S.d, {
						compact: !1,
						voteState: T.a.notVoted,
						interactive: !1
					})), o.a.createElement(w.a, {
						disableInlineColor: !0,
						className: Object(I.a)(P.a.Score, P.a.disabledScore),
						score: 0,
						voteState: T.a.notVoted,
						isScoreHidden: !0
					}), o.a.createElement("button", {
						className: P.a.disabledVoteIcon,
						"aria-label": s.fbt._("downvote", null, {
							hk: "4xXpvV"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(S.c, {
						compact: !1,
						voteState: T.a.notVoted,
						interactive: !1
					})))
				}
			}
			var A = R,
				M = n("./src/reddit/constants/thumbnails.ts"),
				D = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				L = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				F = n("./src/reddit/models/PostCreationForm/index.ts"),
				U = n("./src/reddit/models/ScheduledPost/index.ts"),
				B = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx"),
				G = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				H = n("./src/reddit/icons/svgs/Post/index.tsx"),
				W = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				q = n("./src/reddit/components/ScheduledPost/ControlRow/index.m.less"),
				V = n.n(q);
			const z = e => {
				const {
					icon: t,
					onClick: n
				} = e;
				return o.a.createElement("span", {
					onClick: n,
					className: Object(I.a)(V.a.controlRowItem, e.className)
				}, o.a.createElement(t, {
					className: V.a.icon
				}), " ", e.text)
			};
			class K extends o.a.Component {
				render() {
					return o.a.createElement("span", {
						className: V.a.controlRow
					}, this.props.onSubmitPostNow && o.a.createElement(z, {
						icon: H.a,
						text: s.fbt._("Submit post now", null, {
							hk: "QkS4y"
						}),
						onClick: this.props.onSubmitPostNow
					}), o.a.createElement(z, {
						icon: G.a,
						text: s.fbt._("Edit", null, {
							hk: "1nftDt"
						}),
						onClick: this.props.onEditScheduledPost
					}), o.a.createElement(z, {
						icon: W.b,
						text: s.fbt._("Delete", null, {
							hk: "1uVY7w"
						}),
						onClick: this.props.onDeleteScheduledPost
					}), this.props.renderOverflowMenu())
				}
			}
			var Q = Object(B.a)(K),
				J = n("./src/reddit/components/ScheduledPost/MetaLine/index.tsx"),
				Y = n("./src/reddit/components/ScheduledPost/PostTitle/index.tsx"),
				X = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				Z = n("./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less"),
				$ = n.n(Z);
			const {
				fbt: ee
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class te extends o.a.PureComponent {
				componentDidMount() {
					this.props.onViewFailedPost()
				}
				render() {
					const {
						scheduledPost: e
					} = this.props, {
						owner: t
					} = e, n = Object(U.o)(t) && t.prefixedName;
					return o.a.createElement("div", {
						className: $.a.container
					}, o.a.createElement("div", null, o.a.createElement(X.a, {
						className: $.a.error
					}), ee._("Post failed to submit! Please {=retry}", [ee._param("=retry", o.a.createElement("button", {
						className: $.a.retryButton,
						onClick: this.props.onSubmitPostNow
					}, ee._("retry", null, {
						hk: "hER94"
					})))], {
						hk: "4yOnl8"
					})), o.a.createElement("div", null, ee._("Scheduled by {=[post owner]}", [ee._param("=[post owner]", o.a.createElement("span", {
						className: $.a.parametricMetaData
					}, ee._("{post owner}", [ee._param("post owner", n)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					})))
				}
			}
			var ne = Object(a.b)(null, (e, t) => {
					let {
						scheduledPost: n
					} = t;
					return {
						onSubmitPostNow: () => {
							e(E(n.subreddit.id, n.id)), e((e, t) => Object(c.a)(Object(L.n)()(t())))
						},
						onViewFailedPost: () => e((e, t) => Object(c.a)(Object(L.w)()(t(), n)))
					}
				})(te),
				se = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				re = n("./src/reddit/icons/svgs/Clock/index.tsx"),
				oe = n("./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less"),
				ae = n.n(oe);
			const {
				fbt: ie
			} = n("./node_modules/fbt/lib/FbtPublic.js"), de = e => {
				return `${Object(se.c)(e.publishAt)} ${Object(se.d)(e.clientTimezone).displayText}`
			};
			class ce extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props, {
						owner: t
					} = e, n = Object(U.o)(t) && t.prefixedName;
					return o.a.createElement("div", {
						className: ae.a.container
					}, o.a.createElement(re.a, {
						className: ae.a.clock
					}), o.a.createElement("div", null, o.a.createElement("div", null, ie._("This post is scheduled for {=[time]}", [ie._param("=[time]", o.a.createElement("span", {
						className: ae.a.parametricMetaData
					}, ie._("{time}", [ie._param("time", de(e))], {
						hk: "JrMs3"
					})))], {
						hk: "4gFrnr"
					})), o.a.createElement("div", null, ie._("Scheduled by {=[post owner]}", [ie._param("=[post owner]", o.a.createElement("span", {
						className: ae.a.parametricMetaData
					}, ie._("{post owner}", [ie._param("post owner", n)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					}))))
				}
			}
			var le = ce;
			class ue extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props;
					switch (e.state) {
						case U.f.FAILED:
							return o.a.createElement(ne, {
								scheduledPost: e
							});
						case U.f.PROCESSING:
						case U.f.CREATED:
						default:
							return o.a.createElement(le, {
								scheduledPost: e
							})
					}
				}
			}
			var me = ue,
				pe = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				be = n.n(pe),
				he = n("./src/reddit/components/ScheduledPost/index.m.less"),
				fe = n.n(he);
			const ge = {
					isNSFW: !1,
					media: {
						content: "",
						markdownContent: "",
						isRichtextPreview: !0,
						mediaMetadata: null,
						obfuscated: null,
						richtextContent: {
							document: []
						},
						rteMode: F.i.RICH_TEXT,
						type: "rtjson"
					},
					thumbnail: {
						url: M.a.DEFAULT,
						width: null,
						height: null
					},
					title: "",
					source: null,
					isSponsored: !1
				},
				_e = Object(d.c)({
					media: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(i.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						if (!r) return null;
						const o = {
								...ge
							},
							a = r.postKind === U.e.LINK;
						return a && (o.media = null), {
							...o,
							isNSFW: r.isNsfw,
							title: r.title,
							...a && {
								source: r.url
							},
							pollData: r.poll
						}
					},
					flair: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(i.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						return r ? Object(i.m)({
							scheduledPost: r
						}) : null
					},
					scheduledPost: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						return Object(i.p)(e, {
							subredditId: s,
							scheduledPostId: n
						})
					}
				}),
				ve = Object(a.b)(_e, (e, t) => {
					let {
						scheduledPostId: n,
						subredditId: s
					} = t;
					return {
						onSubmitPostNow: () => {
							e(E(s, n)), e((e, t) => Object(c.a)(Object(L.n)()(t())))
						},
						onEditScheduledPost: () => {
							e(Object(p.b)(s, n)), e((e, t) => Object(c.a)(Object(L.d)()(t())))
						},
						onDeleteScheduledPost: () => e(Object(m.a)(s, n)),
						onOpenOverflow: () => {
							e((e, t) => Object(c.a)(Object(L.h)(!1)(t())))
						},
						onUpdateMetadata: t => e((e, r) => {
							const o = Object(i.p)(r(), {
								subredditId: s,
								scheduledPostId: n
							});
							o && e(Object(u.b)(t, o))
						})
					}
				});
			class Oe extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !0
					}), this.onCancelSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !1
					}), this.onConfirmSubmitPostNow = () => this.props.onSubmitPostNow(), this.onEditScheduledPost = () => {
						this.props.onEditScheduledPost()
					}, this.onDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !0
					}), this.onCancelDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !1
					}), this.onConfirmDeleteScheduledPost = () => this.props.onDeleteScheduledPost(), this.state = {
						deleteConfirmModalIsOpen: !1,
						submitConfirmModalIsOpen: !1
					}
				}
				render() {
					const {
						media: e,
						flair: t,
						scheduledPost: n
					} = this.props;
					return e && t && n ? o.a.createElement("div", {
						className: fe.a.container
					}, o.a.createElement(me, {
						scheduledPost: n
					}), o.a.createElement("div", {
						className: be.a.classicPostStyles
					}, o.a.createElement(k.b, null, o.a.createElement(A, null)), o.a.createElement("div", {
						style: Object(D.c)(void 0, this.props),
						className: fe.a.backgroundWrapper
					}, o.a.createElement("div", {
						className: fe.a.mainBody
					}, o.a.createElement("div", {
						className: fe.a.thumbnailContainer
					}, o.a.createElement(y.a, {
						post: e
					})), o.a.createElement("div", {
						className: fe.a.content
					}, o.a.createElement("div", null, o.a.createElement(Y.a, {
						title: n.title
					}), o.a.createElement(C.a, {
						className: fe.a.flairList,
						flair: t
					})), o.a.createElement(J.a, {
						isModDistinguished: n.isModDistinguished,
						isPostAsMetaMod: n.isPostAsMetaMod,
						isSticky: !!n.sticky && "NONE" !== n.sticky,
						subreddit: n.subreddit,
						owner: n.owner
					}), o.a.createElement(Q, {
						onSubmitPostNow: n.state === U.f.FAILED ? void 0 : this.onSubmitPostNow,
						onEditScheduledPost: this.onEditScheduledPost,
						onDeleteScheduledPost: this.onDeleteScheduledPost,
						onUpdateMetadata: this.props.onUpdateMetadata,
						scheduledPost: n,
						onOpenOverflow: this.props.onOpenOverflow
					}))))), this.state.deleteConfirmModalIsOpen && o.a.createElement(j.a, {
						onClose: this.onCancelDeleteScheduledPost,
						onCancel: this.onCancelDeleteScheduledPost,
						onConfirm: this.onConfirmDeleteScheduledPost,
						actionText: s.fbt._("Delete", null, {
							hk: "1WN0R6"
						}),
						modalText: s.fbt._("Are you sure you want to delete this scheduled post? This action cannot be undone.", null, {
							hk: "1EdQC7"
						}),
						withOverlay: !0
					}), this.state.submitConfirmModalIsOpen && o.a.createElement(j.a, {
						onClose: this.onCancelSubmitPostNow,
						onCancel: this.onCancelSubmitPostNow,
						onConfirm: this.onConfirmSubmitPostNow,
						actionText: s.fbt._("Submit", null, {
							hk: "3kl12J"
						}),
						modalText: s.fbt._("Are you sure you want to submit this scheduled post now? This action cannot be undone.", null, {
							hk: "18O8dB"
						}),
						withOverlay: !0
					})) : null
				}
			}
			t.a = Object(l.a)(ve(Oe))
		},
		"./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js");
			const r = Object(s.createContext)(!1);

			function o() {
				return Object(s.useContext)(r)
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.m.less": function(e, t, n) {
			e.exports = {
				Component: "BotIImuktRA9aFAPP0O4Z",
				component: "BotIImuktRA9aFAPP0O4Z"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/Settings/shared/SectionHeading.m.less"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx");
			t.a = o.a.h3("Component", r.a)
		},
		"./src/reddit/components/Settings/shared/Widgets.m.less": function(e, t, n) {
			e.exports = {
				Label: "asxizthf5kZpmoY27VBKd",
				label: "asxizthf5kZpmoY27VBKd",
				HoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				hoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				ControlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				controlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				TextContainer: "_3dLmvT0hpACHFxhncqzCOr",
				textContainer: "_3dLmvT0hpACHFxhncqzCOr",
				inModal: "_2O2JPVgOlh8J6OW_9ur4BQ",
				ActionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				actionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				Wrapper: "_2f63as5b5FASHMqGd5P1o0",
				wrapper: "_2f63as5b5FASHMqGd5P1o0",
				isCreateCommunity: "_38bDTwLcytTCF-174R0UXB",
				mColumn: "_1HH_g-CLQB1BPcqOhZcakt",
				mLast: "_3Lu6XJyVbSLDVKDx-wue2g",
				mIndent: "_2D65jEbgD16ae_sJ8BG4AD",
				mDisabled: "LvI7FSBTGgYo2skaf18Zv",
				Subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				RangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				rangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				isNightModeOn: "KUWYDFs7fIjkQNSOL_BR6",
				Wrapper__LineBreak: "wVinKyEoajEmwhqwINYGd",
				wrapperLineBreak: "wVinKyEoajEmwhqwINYGd",
				ActionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				actionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				Link: "oFObIzV6ZJDQuG09BXh8u",
				link: "oFObIzV6ZJDQuG09BXh8u",
				SubtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				subtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				LinkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				linkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				LinkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				linkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				ArrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				arrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				NoColor: "mI7WmWMma8pZnlYRHtE56",
				noColor: "mI7WmWMma8pZnlYRHtE56",
				StyledFlair: "_1F2irboi-xRChkhyndP6ct",
				styledFlair: "_1F2irboi-xRChkhyndP6ct",
				SpoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				spoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				NSFWFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				nsfwFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				DropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				dropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				DropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				dropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				Row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				DropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				dropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				DescriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				descriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				Circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				RangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				rangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				Ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				TickText: "_1hEYjTFCxEu2ILobPvatAp",
				tickText: "_1hEYjTFCxEu2ILobPvatAp",
				PreSubText: "_2_hv6QgJ151j9WmCyETVfC",
				preSubText: "_2_hv6QgJ151j9WmCyETVfC",
				MultiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				multiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				ActionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				actionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				input: "_14_SnmD6g3FrozcKjTpqoH",
				tag: "_1GQzFyg5xYq94euL74ZaeJ"
			}
		},
		"./src/reddit/components/Settings/shared/Widgets.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "n", (function() {
				return q
			})), n.d(t, "k", (function() {
				return J
			})), n.d(t, "o", (function() {
				return X
			})), n.d(t, "f", (function() {
				return $
			})), n.d(t, "l", (function() {
				return te
			})), n.d(t, "m", (function() {
				return oe
			})), n.d(t, "p", (function() {
				return ae
			})), n.d(t, "j", (function() {
				return pe
			})), n.d(t, "b", (function() {
				return be
			})), n.d(t, "g", (function() {
				return he
			})), n.d(t, "a", (function() {
				return fe
			})), n.d(t, "d", (function() {
				return _e
			})), n.d(t, "i", (function() {
				return ve
			})), n.d(t, "c", (function() {
				return Oe
			})), n.d(t, "e", (function() {
				return xe
			})), n.d(t, "h", (function() {
				return Ee
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-uid/dist/es2015/hooks.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/higherOrderComponents/asTooltip.tsx"),
				u = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				p = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				b = n("./src/reddit/controls/Dropdown/index.tsx"),
				h = n("./src/reddit/controls/Dropdown/Row.tsx"),
				f = n("./src/reddit/controls/FormFields/index.tsx"),
				g = n("./src/lib/lessComponent.tsx"),
				_ = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				v = n("./src/reddit/controls/Select/index.m.less"),
				O = n.n(v);

			function x() {
				return (x = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const E = g.a.span("Wrapper", O.a),
				y = g.a.select("Inner", O.a),
				j = g.a.wrapped(_.b, "Caret", O.a);

			function C(e) {
				let {
					className: t,
					innerClassName: n,
					...s
				} = e;
				const o = s.disabled ? {
					"data-disabled": s.disabled
				} : {};
				return r.a.createElement(E, {
					className: t
				}, r.a.createElement(y, x({
					className: n
				}, s)), r.a.createElement(j, x({
					isSubreddit: !0
				}, o)))
			}
			var k = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				I = n("./src/reddit/controls/Typography/index.tsx"),
				S = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				w = n("./src/reddit/icons/svgs/Circle/index.tsx"),
				T = n("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				N = n("./node_modules/lodash/range.js"),
				P = n.n(N),
				R = n("./src/reddit/controls/Button/index.tsx"),
				A = n("./src/reddit/layout/row/Inline/index.tsx"),
				M = n("./src/reddit/models/Flair/index.ts"),
				D = n("./src/reddit/selectors/tooltip.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				F = n("./src/reddit/components/Settings/shared/Widgets.m.less"),
				U = n.n(F);

			function B() {
				return (B = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const G = Object(l.a)(b.a),
				H = g.a.wrapped(w.a, "Circle", U.a),
				W = g.a.h3("Label", U.a),
				q = g.a.wrapped(I.c, "Subtext", U.a),
				V = g.a.wrapped(m.a, "HoverTooltip", U.a),
				z = g.a.div("ControlContainer", U.a),
				K = g.a.div("TextContainer", U.a),
				Q = g.a.div("ActionContainer", U.a),
				J = e => {
					let {
						className: t,
						direction: n,
						isCreateCommunity: s,
						inModal: o,
						isNightModeOn: a,
						disabled: i,
						indent: c,
						last: l,
						...u
					} = e;
					return r.a.createElement("div", B({}, u, {
						className: Object(d.a)(U.a.Wrapper, t, {
							[U.a.mColumn]: "column" === n,
							[U.a.mDisabled]: !!i,
							[U.a.mIndent]: !!c,
							[U.a.mLast]: !!l,
							[U.a.isCreateCommunity]: !!s,
							[U.a.inModal]: !!o,
							[U.a.isNightModeOn]: !!a
						})
					}))
				},
				Y = g.a.a("Link", U.a),
				X = g.a.wrapped(Y, "SubtextLink", U.a),
				Z = g.a.wrapped(T.a, "LinkIcon", U.a),
				$ = g.a.button("LinkButton", U.a),
				ee = g.a.wrapped(S.a, "ArrowRight", U.a),
				te = e => r.a.createElement(J, {
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					isCreateCommunity: e.isCreateCommunity,
					last: e.last
				}, r.a.createElement(K, {
					className: e.textContainerClassName
				}, r.a.createElement(W, null, e.label, e.isRequired && r.a.createElement(H, null)), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, e.children)),
				ne = g.a.div("StyledFlair", U.a),
				se = g.a.wrapped(ne, "SpoilerFlair", U.a),
				re = g.a.wrapped(ne, "NSFWFlair", U.a),
				oe = e => {
					switch (e.flair) {
						case M.f.Nsfw:
							return r.a.createElement(re, null, "NSFW");
						case M.f.Spoiler:
							return r.a.createElement(se, null, "SPOILER");
						default:
							return null
					}
				},
				ae = e => {
					const t = Object(a.a)();
					return r.a.createElement(J, {
						className: e.className,
						disabled: e.disabled,
						indent: e.indent,
						last: e.last
					}, r.a.createElement(K, null, r.a.createElement(A.a, null, r.a.createElement("label", {
						htmlFor: t,
						className: e.labelClassname
					}, r.a.createElement(W, null, e.label))), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(z, null, e.tooltip && r.a.createElement(V, {
						tooltipContentClass: e.tooltipContentClassName,
						text: e.tooltip
					}), r.a.createElement(k.a, {
						id: t,
						on: e.on,
						forceOn: e.forceOn,
						onToggle: e.onClick,
						disabled: e.disabled
					}))))
				},
				ie = g.a.input("RangeSliderInput", U.a),
				de = g.a.div("RangeSlider", U.a),
				ce = g.a.div("Ticks", U.a),
				le = g.a.div("TickText", U.a),
				ue = g.a.span("PreSubText", U.a),
				me = Object(i.c)({
					isNightModeOn: L.db
				}),
				pe = Object(o.b)(me)(e => r.a.createElement(J, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled,
					inModal: e.inModal,
					isNightModeOn: e.isNightModeOn,
					direction: e.direction,
					className: e.className
				}, r.a.createElement(K, {
					style: {
						flex: 5
					}
				}, !e.inModal && r.a.createElement(A.a, null, r.a.createElement(W, {
					className: e.labelClassname
				}, e.label)), !e.hideSubtext && r.a.createElement(q, null, " ", r.a.createElement(ue, {
					style: {
						color: e.ticks[e.value].color
					}
				}, " ", e.ticks[e.value].text + ": ", " "), " ", e.subtext)), r.a.createElement(Q, {
					style: {
						flex: 3,
						margin: "20px 20px 0 0"
					}
				}, r.a.createElement(de, null, r.a.createElement(ie, {
					style: {
						background: "linear-gradient(to right, " + P()(1, e.max + 1).map((t, n) => t <= e.value ? `${e.ticks[e.value].color} ${(t-1)/e.max*100}%,\n                    ${e.ticks[e.value].color} ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : t !== e.max ? `#c5c5c5 ${(t-1)/e.max*100}%, #c5c5c5 ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : `#c5c5c5 ${(t-1)/e.max*100}%`) + ", #C5C5C5 100%)"
					},
					className: "range-slider-input",
					type: "range",
					min: e.min,
					max: e.max,
					step: e.step,
					value: e.value,
					onChange: e.onChange,
					onInput: e.onChange,
					disabled: e.disabled
				}), r.a.createElement(ce, null, Object.keys(e.ticks).map((t, n) => r.a.createElement(le, {
					key: t,
					style: {
						color: t === e.value.toString() ? e.ticks[t].color : "#878A8C"
					}
				}, e.ticks[t].text))))))),
				be = e => r.a.createElement(J, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(A.a, null, r.a.createElement(W, null, e.label)), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(z, null, r.a.createElement(R.o, {
					onClick: e.onClick
				}, e.actionText)))),
				he = e => r.a.createElement(J, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(Y, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, e.label, r.a.createElement(Z, null)), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(Y, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, r.a.createElement(ee, null)))),
				fe = e => r.a.createElement(J, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(K, null, r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				}, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, !!e.hintText && r.a.createElement("div", {
					className: U.a.ActionHintText
				}, e.hintText), r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				}, r.a.createElement(ee, {
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				})))),
				ge = Object(i.c)({
					isOpen: (e, t) => Object(D.b)(t.id)(e)
				}),
				_e = Object(o.b)(ge, (e, t) => ({
					openDropdown: () => {
						e(Object(c.h)({
							tooltipId: t.id
						}))
					}
				}))(e => r.a.createElement(J, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(W, null, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, (e => r.a.createElement("div", {
					className: U.a.DropdownWrapper,
					onClick: e.openDropdown
				}, r.a.createElement("span", {
					className: U.a.Row,
					id: `SettingDropdown--${e.id}`
				}, e.displayTitle || e.selected), r.a.createElement(_.b, {
					className: U.a.DropdownTriangle
				}), r.a.createElement(G, {
					container: void 0,
					isOpen: e.isOpen,
					renderContentsHidden: !0,
					isOverlay: !1,
					tooltipId: `SettingDropdown--${e.id}`
				}, e.items.map((t, n) => r.a.createElement(h.b, {
					className: U.a.DropdownRow,
					displayText: e.displayItems ? e.displayItems[n] : t,
					isSelected: e.selected === t,
					onClick: () => e.onClick(t),
					key: "row--" + n,
					item: t
				}))), e.descriptions && r.a.createElement("div", {
					className: U.a.DescriptionsRow
				}, e.descriptions[e.items.indexOf(e.selected)] || e.displayItems && e.descriptions[e.displayItems.indexOf(e.selected)])))(e)))),
				ve = e => {
					let {
						disabled: t,
						last: n,
						onClick: o,
						onChange: a,
						...i
					} = e;
					const d = Object(s.useCallback)(e => a(e.target.value), [a]),
						{
							items: c
						} = i;
					return r.a.createElement(J, {
						disabled: t
					}, r.a.createElement(K, null, r.a.createElement("label", {
						htmlFor: i.id
					}, r.a.createElement(W, {
						className: i.labelClassname
					}, i.label)), r.a.createElement(q, null, i.subtext)), r.a.createElement("div", {
						className: U.a.Wrapper__LineBreak
					}), r.a.createElement(J, {
						last: n,
						indent: !0,
						disabled: t
					}, r.a.createElement(C, {
						id: i.id,
						className: "redditStyle",
						disabled: t || i.inputDisabled,
						onChange: d,
						value: i.selected
					}, c.map(e => {
						let {
							value: t,
							displayName: n
						} = e;
						return r.a.createElement("option", {
							key: t,
							value: t
						}, n)
					}))))
				},
				Oe = e => r.a.createElement(J, {
					className: e.className,
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(K, null, r.a.createElement(W, null, e.label), r.a.createElement(q, null, e.subtext)), r.a.createElement(Q, null, e.children)),
				xe = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, e.isCreateCommunity && r.a.createElement("span", {
					className: U.a.tag
				}, "r/"), r.a.createElement(f.a, {
					className: e.isCreateCommunity ? U.a.input : void 0,
					disabled: !!e.disabled,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					type: "text",
					value: e.value,
					onBlur: e.onBlur
				}), !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value
				})),
				Ee = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, r.a.createElement(p.i, {
					disabled: !1,
					onChange: e.onChange,
					onFocus: e.onFocus,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					rows: e.rows || 4,
					style: {
						marginBottom: e.isCreateCommunity ? "4px" : 0,
						resize: e.isCreateCommunity ? "vertical" : "both"
					},
					value: e.value,
					onBlur: e.onBlur
				}), r.a.createElement("div", {
					className: U.a.MultiLineInputSettingsBottomRow
				}, !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value || ""
				}), !!e.actionLink && r.a.createElement("div", {
					className: U.a.ActionLinkContainer
				}, e.actionLink)))
		},
		"./src/reddit/components/ShareMenu/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "PWY92ySDjTYrTAiutq4ty",
				dropdownRow: "_2snJGyyGyyH38duHobOUKE",
				linkIcon: "_1GObrri0j7y_9IWiGUfPjp",
				chatIcon: "_1PhtucoKocd-ADJ-JDEoiC",
				crosspostIcon: "_1m76BHzDzRsM1te7HBxUqd",
				embedIcon: "_3MSdPVJwGxrpakz-e1MQhO",
				modalBody: "T4VmKX-IOkP4UG-B4jUR-"
			}
		},
		"./src/reddit/components/ShareMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/uuid/v4.js"),
				d = n.n(i),
				c = n("./src/config.ts"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/reddit/actions/chat/toggle.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/publicAccessNetwork/streams.ts"),
				h = n("./src/reddit/actions/tooltip.ts"),
				f = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				g = n("./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx"),
				_ = n("./src/reddit/constants/parameters.ts"),
				v = n("./src/reddit/controls/Dropdown/index.tsx"),
				O = n("./src/reddit/controls/Dropdown/Row.tsx"),
				x = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				E = n("./src/reddit/helpers/trackers/shareToChat.ts"),
				y = n("./src/reddit/hooks/useTracking.ts"),
				j = n("./src/reddit/icons/fonts/index.tsx"),
				C = n("./src/reddit/models/Post/index.ts"),
				k = n("./src/reddit/models/Subreddit/index.ts"),
				I = n("./src/reddit/routes/postCreation/constants.ts"),
				S = n("./src/reddit/selectors/activeModalId.ts"),
				w = n("./src/reddit/selectors/experiments/shareToChatButton.ts"),
				T = n("./src/reddit/selectors/tooltip.ts"),
				N = n("./src/reddit/components/ShareMenu/index.m.less"),
				P = n.n(N);
			const R = Object(f.a)(v.a),
				A = d()(),
				M = o.a.memo(e => {
					const t = Object(a.d)(),
						n = Object(y.a)(),
						i = Object(a.e)(w.a),
						d = Object(a.e)(t => Object(T.b)(e.dropdownId)(t)),
						f = Object(a.e)(t => Object(S.b)(Object(g.a)(e.dropdownId))(t)),
						v = Object(r.useCallback)(() => {
							t(Object(h.h)({
								tooltipId: e.dropdownId
							}))
						}, [t, e.dropdownId]),
						N = e => t(Object(p.D)(e)),
						M = Object(r.useCallback)(() => {
							e.post && (t(Object(b.d)(e.post.id)), t(Object(m.i)(Object(g.a)(e.post.id))))
						}, [t, e.post]),
						D = !e.subredditType || e.subredditType === k.f.Public,
						L = !!e.post && e.post.isCrosspostable && !e.post.isSponsored,
						F = Object(r.useCallback)(e => {
							t(Object(u.e)(e)), n(Object(E.a)())
						}, [t, n]);
					return o.a.createElement("div", {
						className: e.className,
						onClick: v,
						id: e.dropdownId
					}, e.children, o.a.createElement(R, {
						className: P.a.dropdown,
						isOpen: d,
						tooltipId: e.dropdownId
					}, o.a.createElement(O.b, {
						className: P.a.dropdownRow,
						displayText: s.fbt._("Copy link", null, {
							hk: "1tCqox"
						}),
						onClick: () => {
							const {
								permalink: t,
								post: n
							} = e;
							if (n && Object(C.q)(n)) e.sendEventWithName("share_copy", {
								referralId: A
							}), M();
							else {
								const n = Object(l.a)(t, {
									utm_source: "share",
									utm_medium: "web2x",
									context: 3
								});
								e.sendEventWithName("share_copy"), N(n)
							}
						}
					}, o.a.createElement(j.a, {
						name: "link_post",
						className: P.a.linkIcon
					})), L && o.a.createElement(O.b, {
						className: P.a.dropdownRow,
						displayText: s.fbt._("crosspost", null, {
							hk: "23zSN6"
						}),
						onClick: () => {
							e.sendEventWithName("share_crosspost"), e.post && window.open(`${I.b}?source_id=${e.post.id}`, "_blank")
						}
					}, o.a.createElement(j.a, {
						name: "crosspost",
						className: P.a.crosspostIcon
					})), D && o.a.createElement(O.b, {
						className: P.a.dropdownRow,
						displayText: s.fbt._("Embed", null, {
							hk: "2CcsuC"
						}),
						onClick: () => {
							e.sendEventWithName("share_embed"), window.open(`${c.a.rebedMediaUrl}/embed?url=${e.permalink}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, o.a.createElement(j.a, {
						name: "embed",
						className: P.a.embedIcon
					})), i && o.a.createElement(O.b, {
						className: P.a.dropdownRow,
						displayText: s.fbt._("share to chat", null, {
							hk: "3EuIWT"
						}),
						onClick: () => {
							const {
								permalink: t
							} = e, n = Object(l.a)(t, {
								utm_source: "share",
								utm_medium: "web2x",
								context: 3
							});
							F(n)
						}
					}, o.a.createElement(j.a, {
						name: "chat",
						className: P.a.chatIcon
					}))), f && e.post && o.a.createElement(g.b, {
						className: P.a.modalBody,
						onClose: t => {
							t && (e.sendEventWithName("copy_link", {
								referralId: A
							}), N(t)), M()
						},
						url: Object(l.a)(Object(x.a)(e.post.id), {
							[_.q]: A,
							utm_source: "share",
							utm_medium: "web2x",
							utm_content: "rpan_stream"
						})
					}))
				});
			t.a = M
		},
		"./src/reddit/components/Streaming/ModSettings/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_16pMBJPhtfeyyncMfo7aDr",
				topBar: "_1DEjdLJpmb7fufFzhwqQm0",
				contentContainer: "ZV-o_W-prpE7EI4zyZ1hr",
				formBody: "_3xfSWCFu_alfjEX12_hBAB"
			}
		},
		"./src/reddit/components/Streaming/ModSettings/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/streaming/modSettings.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				m = n("./src/reddit/components/BlockNavigation/index.tsx"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				h = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				f = n("./src/reddit/contexts/ApiContext.tsx"),
				g = n("./src/reddit/controls/Button/index.tsx"),
				_ = n("./src/reddit/controls/FormFields/index.tsx"),
				v = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				O = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/activeModalId.ts"),
				E = n("./src/reddit/selectors/platform.ts"),
				y = n("./src/reddit/selectors/streamingModSettings.ts"),
				j = n("./src/reddit/components/Streaming/ModSettings/index.m.less"),
				C = n.n(j);
			const k = "streaming-settings-discard-confirmation",
				I = e => Object(l.e)(e, O.b.Error),
				S = Object(i.c)({
					allowNavigationCallback: E.a,
					modSettings: y.e,
					isAddUserModalOpen: e => "ModerationPage--Streaming--AddUser" === Object(x.a)(e),
					isLivestreamingCurrentlyOn: y.d,
					isDiscardModalOpen: Object(x.b)(k),
					isModSettingsSaving: e => Object(y.a)(e)
				}),
				w = Object(a.b)(S, (e, t) => ({
					closeAllModals: () => e(Object(d.f)()),
					onSave: (t, n) => e(Object(c.f)(t, n)),
					onUserAdd: (t, n, s) => e(Object(c.d)(t, n, s)),
					onUserRemove: (t, n, s) => e(Object(c.e)(t, n, s)),
					showToast: t => e(Object(l.f)({
						...t,
						duration: l.a
					})),
					toggleAddUserModal: () => e(Object(d.i)("ModerationPage--Streaming--AddUser")),
					toggleDiscardChangesModal: () => e(Object(d.i)(k))
				})),
				T = e => parseInt(e, 10),
				N = {
					sunday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					monday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					tuesday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					wednesday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					thursday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					friday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					saturday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}]
				},
				P = {
					sunday: [],
					monday: [],
					tuesday: [],
					wednesday: [],
					thursday: [],
					friday: [],
					saturday: []
				};
			class R extends o.a.Component {
				constructor(e) {
					super(e), this.onChange = e => {
						const t = {
							...this.state.changedModSettings,
							...e
						};
						let n = !1;
						Object.keys(t).forEach(e => {
							t[e] !== this.props.modSettings[e] && (n = !0)
						}), this.setState({
							changedModSettings: t,
							hasUnsavedChanges: n
						})
					}, this.onSaveClick = async () => {
						this.props.onSave(this.state.changedModSettings, this.props.subredditId), this.setState({
							hasUnsavedChanges: !1
						})
					}, this.onUserAdd = async (e, t) => {
						this.isDuplicateUser(t) ? await this.props.showToast(I(s.fbt._("'{username}' has already been added", [s.fbt._param("username", t)], {
							hk: "25Zkkf"
						}))) : this.props.onUserAdd(this.props.subredditId, t, this.props.modSettings)
					}, this.isDuplicateUser = e => !!this.props.modSettings.whitelistedUsers.find(t => t.name === e), this.onDiscardUnsavedChangesConfirmed = () => {
						this.performPendingNavigationIfNeeded()
					}, this.onCloseModal = () => {
						this.props.closeAllModals(), this.resetPendingNavigation()
					}, this.resetPendingNavigation = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.performPendingNavigationIfNeeded = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.onUserRemove = async e => {
						this.props.onUserRemove(this.props.subredditId, e, this.props.modSettings)
					}, this.onUserAddButtonClick = () => {
						this.props.toggleAddUserModal()
					}, this.getUpdatedSchedule = e => e ? P : N, this.renderAddUserModal = () => o.a.createElement(u.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.onUserAdd,
						sendEventWithName: this.noopEventSend,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: "",
						withOverlay: !0
					}), this.noopEventSend = () => () => {}, this.state = {
						changedModSettings: {},
						livestreamingToggleStateOn: this.props.isLivestreamingCurrentlyOn,
						hasUnsavedChanges: !1
					}
				}
				render() {
					const e = {
							...this.props.modSettings,
							...this.state.changedModSettings
						},
						{
							maxLiveStreams: t,
							minKarma: n,
							minAccountAgeDays: r,
							durationLimitSeconds: a,
							broadcasterPrompt: i,
							isDiscoveryUnitShown: d,
							inSubMinKarma: c
						} = e;
					return o.a.createElement("div", {
						className: C.a.container
					}, o.a.createElement(b.c, {
						className: C.a.topBar
					}, o.a.createElement(g.l, {
						onClick: this.onSaveClick,
						disabled: this.props.isModSettingsSaving
					}, this.props.isModSettingsSaving ? o.a.createElement(v.a, {
						className: C.a.loadingIcon,
						sizePx: 14,
						center: !0
					}) : s.fbt._("Save changes", null, {
						hk: "1IXBxj"
					}))), o.a.createElement(b.a, {
						className: C.a.contentContainer
					}, o.a.createElement(b.b, null, s.fbt._("Broadcasting", null, {
						hk: "3WAsEz"
					})), o.a.createElement("div", {
						className: C.a.formBody
					}, o.a.createElement(h.p, {
						on: this.state.livestreamingToggleStateOn,
						label: s.fbt._("Allow RPAN Broadcasts", null, {
							hk: "2Jt8fz"
						}),
						subtext: s.fbt._("Allow live broadcasts to the Reddit Public Access Network (RPAN) in this community.", null, {
							hk: "2wjtPG"
						}),
						onClick: () => {
							const e = !this.state.livestreamingToggleStateOn;
							this.onChange({
								weeklySchedule: this.getUpdatedSchedule(this.state.livestreamingToggleStateOn)
							}), this.setState({
								livestreamingToggleStateOn: e,
								hasUnsavedChanges: e !== this.props.isLivestreamingCurrentlyOn
							})
						}
					}), o.a.createElement(h.p, {
						on: d,
						label: s.fbt._("Display RPAN Discovery Unit", null, {
							hk: "3mInib"
						}),
						subtext: s.fbt._("Allow discovery unit for Reddit Public Access Network (RPAN) to be displayed in this community.", null, {
							hk: "3MsZuO"
						}),
						onClick: () => {
							this.onChange({
								isDiscoveryUnitShown: !d
							})
						}
					}), o.a.createElement(h.l, {
						label: s.fbt._("Maximum live broadcasts", null, {
							hk: "bjAcp"
						}),
						direction: "row",
						subtext: s.fbt._("Set the number of broadcasts that can be live at the same time.", null, {
							hk: "fmNzG"
						})
					}, o.a.createElement(_.b, {
						onChange: e => this.onChange({
							maxLiveStreams: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1e3,
						value: t
					})), o.a.createElement(h.l, {
						label: s.fbt._("Required karma", null, {
							hk: "1UzH6K"
						}),
						direction: "row",
						subtext: s.fbt._("Set the amount of global Reddit comment karma someone needs to broadcast live.", null, {
							hk: "1Xa56V"
						})
					}, o.a.createElement(_.b, {
						onChange: e => this.onChange({
							minKarma: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: n
					})), o.a.createElement(h.l, {
						label: s.fbt._("Required community karma", null, {
							hk: "nSuPZ"
						}),
						direction: "row",
						subtext: s.fbt._("Set the amount of community comment karma someone needs to broadcast live.", null, {
							hk: "24qW8L"
						})
					}, o.a.createElement(_.b, {
						onChange: e => this.onChange({
							inSubMinKarma: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: c
					})), o.a.createElement(h.l, {
						label: s.fbt._("Required Account Age", null, {
							hk: "3OXG2v"
						}),
						direction: "row",
						subtext: s.fbt._("Set how old (in days) someones Reddit account needs to be to broadcast live.", null, {
							hk: "24iax6"
						})
					}, o.a.createElement(_.b, {
						onChange: e => this.onChange({
							minAccountAgeDays: T(e.currentTarget.value)
						}),
						min: 0,
						type: "number",
						value: r
					})), o.a.createElement(h.l, {
						label: s.fbt._("Time Limit", null, {
							hk: "2x8YNI"
						}),
						direction: "row",
						subtext: s.fbt._("Broadcasts will end after hitting this limit (in minutes), unless viewers award them more time.", null, {
							hk: "4wwLJ4"
						})
					}, o.a.createElement(_.b, {
						onChange: e => this.onChange({
							durationLimitSeconds: 60 * T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1440,
						value: Math.round(a || 0) / 60,
						disabled: !0
					})), o.a.createElement(h.h, {
						label: s.fbt._("RPAN Description", null, {
							hk: "1WiS6G"
						}),
						direction: "row",
						subtext: s.fbt._("Write a quick description of your community to help broadcasters know what you're about", null, {
							hk: "1fcoqh"
						}),
						onChange: e => this.onChange({
							broadcasterPrompt: e.currentTarget.value
						}),
						maxChars: 250,
						rows: 2,
						value: i || ""
					}))), this.props.isAddUserModalOpen && this.renderAddUserModal(), o.a.createElement(m.a, {
						blockOnBeforeUnload: !0,
						dialogId: k,
						enabled: this.state.hasUnsavedChanges
					}), this.props.isDiscardModalOpen && o.a.createElement(p.a, {
						actionText: s.fbt._("Discard", null, {
							hk: "1SiwLl"
						}),
						headerText: s.fbt._("Discard changes before leaving?", null, {
							hk: "354NTe"
						}),
						modalText: s.fbt._("You have made some changes to broadcasting settings, do you wish to discard the changes?", null, {
							hk: "20tlQp"
						}),
						onConfirm: this.onDiscardUnsavedChangesConfirmed,
						toggleModal: this.onCloseModal,
						withOverlay: !0
					}))
				}
			}
			t.a = Object(f.b)(w(R))
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less": function(e, t, n) {
			e.exports = {
				StyledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				styledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				BreadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				breadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				BreadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbTitle: "_2N7RnlFNJblZD8KUBuiBEQ"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/helpers/trackers/blade.ts"),
				d = n("./src/reddit/icons/svgs/Chevron/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less"),
				l = n.n(c);
			const u = o.a.wrapped(d.a, "StyledChevron", l.a),
				m = o.a.div("BreadcrumbElement", l.a),
				p = o.a.div("BreadcrumbContainer", l.a);
			t.b = Object(a.c)(e => r.a.createElement(p, null, e.breadcrumbs.map(t => r.a.createElement(m, {
				key: t.title,
				onClick: () => {
					e.sendEvent(Object(i.a)()), e.onNavigate(t)
				}
			}, r.a.createElement(u, null), r.a.createElement("span", {
				className: l.a.breadcrumbTitle
			}, t.title)))))
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				ImageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				imageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				ImageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				imageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				ImageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				imageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				FileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				fileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				ContainerUploading: "rOyNUbZnjJvWxtyInd1T8",
				containerUploading: "rOyNUbZnjJvWxtyInd1T8",
				Label: "_2ZFG2IQMaso9iA14qjicA_",
				label: "_2ZFG2IQMaso9iA14qjicA_",
				isOver: "_1B5UKMPaEBX3HOKKEBfp7o",
				ImageInput: "_362HLUlCiz7UbtVPniNjjW",
				imageInput: "_362HLUlCiz7UbtVPniNjjW"
			}
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/controls/FileDrop/index.tsx"),
				d = n("./src/reddit/controls/ImageInput/index.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/svgs/ImageUpload/index.tsx"),
				u = n("./src/reddit/components/StructuredStyles/ImageUpload/index.m.less"),
				m = n.n(u);
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = a.a.wrapped(l.a, "ImageUploadIcon", m.a), h = a.a.div("ImageIconRow", m.a), f = a.a.div("ImageUploadText", m.a), g = a.a.wrapped(i.a, "FileDrop", m.a), _ = a.a.div("ContainerUploading", m.a), v = e => r.a.createElement(_, {
				className: e.className
			}, r.a.createElement(h, null, r.a.createElement(c.a, {
				sizePx: 40,
				center: !0
			})), r.a.createElement(f, null, p._("Uploading...", null, {
				hk: "2ICpZ2"
			}))), O = a.a.label("Label", m.a);
			t.b = e => r.a.createElement(g, {
				className: e.className,
				onDrop: e.onChange,
				render: t => r.a.createElement(O, {
					className: Object(o.a)({
						[m.a.isOver]: t
					}, e.labelClassName)
				}, r.a.createElement(h, null, e.icon || r.a.createElement(b, null)), r.a.createElement(f, null, e.label), r.a.createElement(d.a, {
					className: m.a.ImageInput,
					name: e.name,
					value: e.value,
					onChange: e.onChange,
					multiple: e.multiple,
					tabIndex: e.tabIndex
				}))
			})
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less": function(e, t, n) {
			e.exports = {
				FormPage: "_9ZuQyDXhFth1qKJF4KNm8",
				formPage: "_9ZuQyDXhFth1qKJF4KNm8",
				HomePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				homePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				HomePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				homePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				breadcrumbTitle: "_24r4TaTKqNLBGA3VgswFrN",
				HomePageGroup: "_306gA2lxjCHX44ssikUp3O",
				homePageGroup: "_306gA2lxjCHX44ssikUp3O",
				FormPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				formPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				FormPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				formPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				FormGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				formGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				FormGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				formGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				FormElement: "c5RWd-O3CYE-XSLdTyjtI",
				formElement: "c5RWd-O3CYE-XSLdTyjtI",
				FormGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				formGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				FormItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				formItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				FormElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				formElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				FormElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				formElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				FormElementError: "horIoLCod23xkzt7MmTpC",
				formElementError: "horIoLCod23xkzt7MmTpC",
				FormElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				formElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				FormListItem: "_2M7LQbQxH40ingJ9h9RslL",
				formListItem: "_2M7LQbQxH40ingJ9h9RslL"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return a
			})), n.d(t, "p", (function() {
				return i
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "o", (function() {
				return c
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "j", (function() {
				return x
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less"),
				o = n.n(r);
			const a = s.a.section("FormPage", o.a),
				i = s.a.h1("HomePageTitle", o.a),
				d = s.a.button("HomePageBreadcrumb", o.a),
				c = s.a.div("HomePageGroup", o.a),
				l = s.a.h1("FormPageTitle", o.a),
				u = s.a.div("FormPageSection", o.a),
				m = s.a.div("FormGroup", o.a),
				p = s.a.h2("FormGroupTitle", o.a),
				b = s.a.div("FormElement", o.a),
				h = s.a.div("FormGroupDescription", o.a),
				f = s.a.div("FormItem", o.a),
				g = s.a.h3("FormElementTitle", o.a),
				_ = s.a.div("FormElementDescription", o.a),
				v = s.a.div("FormElementError", o.a),
				O = s.a.div("FormElementSubGroup", o.a),
				x = s.a.li("FormListItem", o.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less": function(e, t, n) {
			e.exports = {
				ModalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				modalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				Input: "_1BJV17HgWhhC-BxrpqGjM",
				input: "_1BJV17HgWhhC-BxrpqGjM",
				Checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				CheckboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				checkboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				iconStyles: "_349rJ1BueyeldYiZniwYOz",
				RadioOff: "_23-RdhX276B0bg5nrt0cpf",
				radioOff: "_23-RdhX276B0bg5nrt0cpf",
				RadioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				radioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				Textarea: "_2gchCc4pmLk-CHEErYmFaP",
				textarea: "_2gchCc4pmLk-CHEErYmFaP",
				StyledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				styledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				StyledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN",
				styledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return v
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/ModalInput.tsx"),
				o = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				a = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less"),
				l = n.n(c);
			const u = s.a.wrapped(r.a, "ModalInput", l.a),
				m = s.a.input("Input", l.a),
				p = s.a.wrapped(d.a, "RadioOn", l.a),
				b = s.a.wrapped(i.a, "RadioOff", l.a),
				h = s.a.wrapped(o.a, "Checkbox", l.a),
				f = s.a.wrapped(a.a, "CheckboxSelected", l.a),
				g = s.a.textarea("Textarea", l.a),
				_ = s.a.label("StyledLabel", l.a),
				v = s.a.input("StyledFileInput", l.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, n) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				i = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
					let {
						disabled: t,
						...n
					} = e;
					return r.a.createElement("div", d({}, n, {
						className: Object(o.a)(i.a.FormNavElement, {
							[i.a.disabled]: t
						})
					}), n.children)
				},
				l = e => {
					let {
						canDrop: t,
						className: n,
						isDragging: s,
						isOver: a,
						disabled: c,
						...l
					} = e;
					return r.a.createElement("div", d({}, l, {
						className: Object(o.a)(i.a.DragCard, {
							[i.a.disabled]: c,
							[i.a.isDraffing]: s,
							[i.a.isOverAndCanDrop]: a && t
						}, n)
					}))
				}
		},
		"./src/reddit/components/SubredditContent/EventPostContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/actions/eventPosts/index.ts"),
				l = n("./src/reddit/components/ClassicPost/index.tsx"),
				u = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				m = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				p = n("./src/reddit/components/Scroller/Simple.tsx"),
				b = n("./src/reddit/components/SubredditContent/index.tsx"),
				h = n("./src/reddit/components/TrackingHelper/index.tsx"),
				f = n("./src/reddit/constants/postLayout.ts"),
				g = n("./src/reddit/controls/Button/index.tsx"),
				_ = n("./src/reddit/helpers/overlay/index.ts"),
				v = n("./src/reddit/helpers/postComponentForLayout/index.tsx"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				x = n("./src/reddit/routes/postCreation/index.ts"),
				E = n("./src/reddit/selectors/eventPosts.ts"),
				y = n("./src/reddit/components/SubredditContent/index.m.less"),
				j = n.n(y);
			const C = Object(d.c)({
					eventPosts: E.f,
					isPending: E.d,
					hasData: E.b,
					endCursor: E.a
				}),
				k = Object(a.b)(C, (e, t) => {
					let {
						subredditName: n
					} = t;
					return {
						onClickPost: t => {
							e(Object(_.a)(t.permalink))
						},
						fetchMorePosts: () => {
							e(Object(c.eventPostsRequested)(n))
						}
					}
				});
			class I extends o.a.PureComponent {
				renderEmptyState() {
					const {
						subredditName: e
					} = this.props;
					return o.a.createElement(u.c, {
						className: j.a.emptyStateContainer,
						text: s.fbt._("No upcoming or live events in r/{subredditName}", [s.fbt._param("subredditName", e)], {
							hk: "3wRma7"
						}),
						childrenPosition: "bottom"
					}, o.a.createElement(O.a, {
						name: "scheduled",
						className: j.a.icon
					}), o.a.createElement(i.a, {
						className: j.a.schedulePostLink,
						to: Object(x.c)(e)
					}, s.fbt._("Create Event Post", null, {
						hk: "PXBmQ"
					})))
				}
				renderBody() {
					const {
						endCursor: e,
						eventPosts: t,
						fetchMorePosts: n,
						hasData: s,
						onClickPost: r
					} = this.props;
					return o.a.createElement("div", {
						className: j.a.contentContainer
					}, o.a.createElement("div", {
						className: j.a.standaloneContainer
					}, s ? o.a.createElement(p.b, {
						className: j.a.scroller,
						onLoadMore: n,
						loadMoreToken: e || void 0
					}, t.map((e, t) => ({
						id: e.id,
						estHeight: Object(v.c)(e, f.g.Classic),
						render: n => o.a.createElement(l.default, {
							key: `event-post-id-${e.id}`,
							postId: e.id,
							className: j.a.eventPostContainer,
							first: 0 === t,
							isOverlay: !1,
							onClickPost: () => r(e)
						})
					}))) : this.renderEmptyState()))
				}
				render() {
					const {
						isPending: e,
						hasData: t
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(m.c, null, o.a.createElement(i.a, {
						to: Object(x.c)(this.props.subredditName)
					}, o.a.createElement(g.l, null, s.fbt._("Schedule an event post", null, {
						hk: "nk1bA"
					})))), o.a.createElement(m.a, null, o.a.createElement(m.b, {
						className: j.a.pageTitle
					}, s.fbt._("Upcoming and live events", null, {
						hk: "MAeQO"
					})), !t && e ? Object(b.a)() : this.renderBody(), t && e && Object(b.a)(1)))
				}
			}
			t.a = k(Object(h.c)(I))
		},
		"./src/reddit/components/SubredditContent/PredictionsContent/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-SubredditContent-PredictionsContent",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-SubredditContent-PredictionsContent").then(n.bind(null, "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx"
				}
			})
		},
		"./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				l = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				u = n("./node_modules/reselect/es/index.js"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/lib/CSSVariableProvider/index.tsx"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				f = n("./src/reddit/components/Paginator/index.m.less"),
				g = n.n(f);

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const v = e => {
				const {
					isNextButton: t,
					isActive: n,
					...s
				} = e;
				return o.a.createElement(h.i, _({
					disabled: !n
				}, s))
			};
			class O extends o.a.Component {
				constructor(e) {
					super(e), this.onHandlePrev = () => this.onHandlePageChange(!1), this.onHandleNext = () => this.onHandlePageChange(!0), this.state = {
						currentCursor: void 0
					}
				}
				getCurrentCursorIdx() {
					const {
						items: e
					} = this.props, {
						currentCursor: t
					} = this.state;
					return t ? e.findIndex(e => e.id === t) : -1
				}
				getRenderableItems() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props, n = this.getCurrentCursorIdx() + 1;
					return e.slice(n, n + t)
				}
				hasPrevPage() {
					return !(this.getCurrentCursorIdx() <= 0)
				}
				hasNextPage() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props;
					return !(this.getCurrentCursorIdx() + t > e.length - 2)
				}
				onHandlePageChange(e) {
					const {
						items: t,
						itemsPerPage: n
					} = this.props, s = this.getCurrentCursorIdx();
					if (e && !this.hasNextPage()) return;
					if (!e && !this.hasPrevPage()) return;
					const r = e ? Math.max(-1, Math.min(s + n, t.length - 2)) : Math.max(-1, s - n);
					this.setState({
						currentCursor: t[r] ? t[r].id : void 0
					})
				}
				renderControlRow() {
					const {
						usePortalForControlRow: e,
						controlRowPortal: t,
						pagerButton: n = v
					} = this.props, r = this.hasPrevPage(), a = this.hasNextPage();
					if (!r && !a) return null;
					const i = o.a.createElement("div", {
						className: g.a.controlRow
					}, o.a.createElement("span", {
						className: g.a.prevButtonContainer
					}, o.a.createElement(n, {
						className: g.a.prevButton,
						onClick: this.onHandlePrev,
						isNextButton: !1,
						isActive: r
					}, s.fbt._("Previous", null, {
						hk: "4hX0ue"
					}))), o.a.createElement("span", {
						className: g.a.nextButtonContainer
					}, o.a.createElement(n, {
						className: g.a.nextButton,
						onClick: this.onHandleNext,
						isNextButton: !0,
						isActive: a
					}, s.fbt._("Next", null, {
						hk: "2mEXAi"
					}))));
					return e && !t ? null : t ? Object(b.d)(i, t) : i
				}
				render() {
					const {
						className: e,
						lastItemClassName: t,
						itemComponent: n
					} = this.props, s = this.getRenderableItems();
					return o.a.createElement("div", {
						className: e
					}, s.map((e, r) => o.a.createElement(n, {
						className: t && r === s.length - 1 ? t : void 0,
						key: e.id,
						item: e
					})), this.renderControlRow())
				}
			}
			var x = O,
				E = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				y = n("./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less"),
				j = n.n(y);
			var C = e => o.a.createElement("button", {
					className: Object(m.a)(j.a.button, e.className, {
						[j.a.prevButton]: !e.isNextButton,
						[j.a.disabled]: !e.isActive
					}),
					onClick: e.onClick,
					disabled: !e.isActive
				}, o.a.createElement(E.a, {
					className: j.a.arrowIcon
				})),
				k = n("./src/reddit/components/RecurringPostList/EditModal/async.tsx"),
				I = n("./src/reddit/components/RecurringPostList/RecurringPost/index.tsx"),
				S = n("./src/reddit/components/TrackingHelper/index.tsx"),
				w = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				T = n("./src/reddit/icons/fonts/index.tsx"),
				N = n("./src/reddit/routes/postCreation/index.ts"),
				P = n("./src/reddit/selectors/activeModalId.ts"),
				R = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				A = n("./src/reddit/components/RecurringPostList/index.m.less"),
				M = n.n(A);
			const {
				fbt: D
			} = n("./node_modules/fbt/lib/FbtPublic.js"), L = 5, F = Object(u.c)({
				recurringPosts: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(R.l)(e, {
						subredditId: n.id
					})
				},
				editModalIsOpen: e => Object(P.a)(e) === I.a,
				editingRecurringPostId: R.d,
				editingRecurringPostSubredditId: R.e
			});
			class U extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.pageButtonPortalRef = o.a.createRef(), this.onEditModalSuccessfulSave = () => {
						this.props.editModalIsOpen && this.props.toggleModal()
					}, this.onClickLink = () => {
						this.props.sendEvent(Object(w.j)())
					}
				}
				renderEmptyState() {
					return o.a.createElement(c.c, {
						className: M.a.emptyContainer,
						text: D._("No recurring posts", null, {
							hk: "2G7szl"
						}),
						childrenPosition: "bottom"
					}, o.a.createElement(T.a, {
						name: "refresh",
						className: M.a.icon
					}), o.a.createElement(i.a, {
						className: M.a.schedulePostLink,
						onClick: this.onClickLink,
						to: Object(N.c)(this.props.subreddit.name)
					}, D._("Schedule recurring post", null, {
						hk: "1TrUPC"
					})))
				}
				render() {
					const {
						className: e,
						recurringPosts: t,
						editModalIsOpen: n,
						subreddit: s,
						editingRecurringPostSubredditId: r,
						editingRecurringPostId: a
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(m.a)(e, M.a.postList)
					}, o.a.createElement("div", {
						className: M.a.titleContainer
					}, D._("Recurring posts", null, {
						hk: "30aHKv"
					}), o.a.createElement("div", {
						ref: this.pageButtonPortalRef,
						className: M.a.pageButtonPortal
					})), t.length ? o.a.createElement(x, {
						className: M.a.recurringPostsContainer,
						lastItemClassName: M.a.lastRecurringPostItem,
						itemsPerPage: L,
						items: t,
						itemComponent: I.b,
						pagerButton: C,
						usePortalForControlRow: !0,
						controlRowPortal: this.pageButtonPortalRef.current
					}) : this.renderEmptyState()), n && !!a && !!r && s.id === r && o.a.createElement(k.a, {
						scheduledPostId: a,
						subredditId: r,
						onSuccessfulSave: this.onEditModalSuccessfulSave,
						withOverlay: !0
					}))
				}
			}
			var B = Object(a.b)(F, (e, t) => ({
					toggleModal: () => e(Object(p.i)(I.a))
				}))(Object(S.c)(U)),
				G = n("./src/reddit/components/ScheduledPost/index.tsx"),
				H = n("./src/reddit/components/Scroller/Simple.tsx"),
				W = n("./src/reddit/components/SubredditContent/index.tsx"),
				q = n("./src/reddit/components/SubredditContent/index.m.less"),
				V = n.n(q),
				z = n("./src/reddit/models/ScheduledPost/index.ts");
			const K = Object(u.c)({
					isLoading: R.i,
					hasData: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.h)(e, {
							subredditId: n.id
						})
					},
					standalonePosts: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.q)(e, {
							subredditId: n.id
						})
					},
					loadMoreToken: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.c)(e, {
							subredditId: n.id,
							type: z.g.standalonePosts
						})
					}
				}),
				Q = Object(a.b)(K, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						onLoadMoreStandaloneScheduledPosts: () => e(Object(d.a)(n.id))
					}
				});
			class J extends o.a.PureComponent {
				render() {
					const {
						hasData: e,
						standalonePosts: t,
						onLoadMore: n,
						loadMoreToken: s,
						renderEmptyState: r,
						subreddit: a
					} = this.props;
					return o.a.createElement("div", {
						className: V.a.contentContainer
					}, o.a.createElement("div", {
						className: V.a.standaloneContainer
					}, e && t.length ? o.a.createElement(H.b, {
						className: V.a.scroller,
						onLoadMore: n,
						loadMoreToken: s || void 0
					}, t.map(e => ({
						id: e.id,
						estHeight: 112,
						render: t => o.a.createElement(G.a, {
							key: `scheduled-post-id-${e.id}`,
							scheduledPostId: e.id,
							subredditId: e.subreddit.id
						})
					}))) : r()), o.a.createElement(B, {
						className: V.a.sidebar,
						subreddit: a
					}))
				}
			}
			class Y extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.renderStandaloneEmptyState = () => {
						const {
							subreddit: e
						} = this.props;
						return o.a.createElement(c.c, {
							className: V.a.emptyStateContainer,
							text: s.fbt._("No scheduled posts in r/{subredditName}", [s.fbt._param("subredditName", e.name)], {
								hk: "mUwQ4"
							}),
							childrenPosition: "bottom"
						}, o.a.createElement(T.a, {
							name: "history",
							className: V.a.icon
						}), o.a.createElement(i.a, {
							className: V.a.schedulePostLink,
							to: Object(N.c)(e.name)
						}, s.fbt._("Schedule post", null, {
							hk: "xI07X"
						})))
					}
				}
				renderBody() {
					const {
						hasData: e,
						loadMoreToken: t,
						onLoadMoreStandaloneScheduledPosts: n,
						standalonePosts: s,
						subreddit: r
					} = this.props;
					return o.a.createElement(J, {
						renderEmptyState: this.renderStandaloneEmptyState,
						hasData: e,
						standalonePosts: s,
						onLoadMore: n,
						subreddit: r,
						loadMoreToken: t
					})
				}
				render() {
					const {
						isLoading: e,
						hasData: t,
						subreddit: n
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(l.c, null, o.a.createElement(i.a, {
						to: Object(N.c)(n.name)
					}, o.a.createElement(h.l, null, s.fbt._("Schedule Post", null, {
						hk: "2Ygkzg"
					})))), o.a.createElement(l.a, null, o.a.createElement(l.b, {
						className: V.a.pageTitle
					}, s.fbt._("Scheduled posts", null, {
						hk: "28Qjmj"
					})), !t && e ? Object(W.a)() : this.renderBody(), t && e && Object(W.a)(1)))
				}
			}
			t.a = Q(Y)
		},
		"./src/reddit/components/SubredditContent/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1N366WahaKnCqUlSezl6CQ",
				titleFontH2: "_2ySCAslCokkxUasLc4m7l0",
				titleFontH3: "_3Na_u-vwpkuPZfuuvUROk-",
				titleFontH4: "_30jImFPUovcaQMWasU-Ohq",
				titleFontH5: "_1fkIEAH9a9eCt2B8XAaUbq",
				titleFontH6: "bHSjFLbSCNEywMorkTrqn",
				metadataFont: "_2Qe8DvvY_RxPEkj-mRpX65",
				flairFont: "_1TXuHKPD3YeZiCgMqyoBBe",
				labelsFont: "_1MiMOmZyBl0g5x8oLzodW8",
				actionFont: "_3USAKL0kbrc0ZhCvZS-J4j",
				smallButtonFont: "_2JaNUow_hy9X8yw0QFNOSg",
				largeButtonFont: "_2QdyaDMXRLLL3gChJ0NOE9",
				strongTextFont: "_3qauH8UCZvDtHIr65uebN5",
				tabFont: "_1bq9fxhlMVaxA2GQdVomf4",
				buttonFontXS: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontXs: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontS: "_2ZBn3QtRUE4GU3UTdoCOzY",
				buttonFontM: "_1FF_0_g8KF3VAe3NMA-Lu6",
				buttonFontL: "_12R7hgqLzyY_mHo7tL6VIy",
				buttonFontXL: "_1c2eC_5e586qF7hV3NBVj_",
				buttonFontXl: "_1c2eC_5e586qF7hV3NBVj_",
				bodyFontH1: "_2qU2oh77HnIxSqTey1ZezW",
				bodyFontH2: "_2XZkZ1zrfSvpi64O-KP4IB",
				bodyFontH3: "_1icF_z4wcZT687-ao6Mzr7",
				bodyFontH4: "ZRi07Zo9aba1n7XQY_Xio",
				bodyFontH5: "_1dhvcwu2KcypL8_En9Aa7I",
				bodyFontH6: "_1FGIk1pK7xZjRbWXhruioE",
				bodyFontH6Small: "gX_Loj9AWtmLld5X2fYAM",
				bodyFont: "_3xTpswgMylBeM6Y-XFNTUD",
				bodyFontSmall: "_3U8U5anYwaLfjJvSrrhIKo",
				bodyFontMono: "_1VL2XaMyhrq5PiMxCa8tkv",
				icon: "_1wICBaO2ARQK5N8CBXP8kI",
				schedulePostLink: "_3hO2emEyTZ-txWczRsI6lb",
				betaIndicator: "q9zqS5nIMgIr22a55zflg",
				pageTitle: "_2HS4U5X7Rt3fT__Kpgmp9M",
				contentContainer: "_2i38uCMOvjLO0N4T-QGmV1",
				scroller: "_2toQcR3aw1_hj1A49e4wi7",
				sidebar: "_3Pz5gIKK5q2FYttguHTNa3",
				emptyStateContainer: "_3uHuaRL_-Tec711luXRhl8",
				standaloneContainer: "Q7W5RJknO1UJ-qscCW0k6",
				eventPostContainer: "_1WvFOm4w7Qt8CpM_XKK9y8"
			}
		},
		"./src/reddit/components/SubredditContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ClassicPost/Placeholder.tsx");

			function a() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
				const t = [];
				for (let n = 0; n < e; n++) t.push(r.a.createElement(o.b, {
					isLoading: !0
				}));
				return r.a.createElement(r.a.Fragment, null, t)
			}
		},
		"./src/reddit/components/SubredditCreationModal/Layout/index.m.less": function(e, t, n) {
			e.exports = {
				Content: "gGAX8JwsFcDSDsT5KcKrL",
				content: "gGAX8JwsFcDSDsT5KcKrL",
				Container: "_1J0hJj-EXr49KppYTmtS9S",
				container: "_1J0hJj-EXr49KppYTmtS9S",
				ContainerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				containerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				OuterContainer: "_1wLNhgzYyv0-JBg0BfYf3Y",
				outerContainer: "_1wLNhgzYyv0-JBg0BfYf3Y"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.m.less": function(e, t, n) {
			e.exports = {
				sublabel: "_1l4AkEjhz6oh1lmsJv-6Oo",
				subtitle: "SJ8r-Lx8GZVAGXaT954wj",
				radioDescription: "_1FBE2BnOrrXe8bCr6ZLfGq",
				buttonContainer: "pllx1jz7x_s-pSUC5f15v",
				field: "_2m493sVo9iDo-3EBxQrAJc",
				isCreatePending: "_39K9U8eGRvjiN3lSUWfoXF",
				subredditCreation: "_3O95baBiXBhn2SNtTQXPun",
				container: "o5ISTIh6L_lvDC1gObc76",
				title: "_2d-OkUXQj6P8CRIrcoi1i9",
				nsfw: "_3bx-zSg4-Vgfi3x1IUw6QP",
				createButton: "_2shIfL3K7ivaojvZFjvI-Z",
				pendingText: "A8PHuGr_4pbV_7t_GaokO",
				metaFieldDescription: "HsJgPFCmZ8OKgFe3tYiOB",
				numCommunityTopicsSelected: "_3-RTBwxKbhnYzfNZydOubp",
				subtextContainer: "_1V3LfcGf8bnGW9vw7JkOOs",
				radioContainer: "_247NCf2PSxl4rhmx2dDhDC",
				radioContent: "_2QiRZZs4K5lTjMTuSaMgDC",
				textButton: "c6YtB-MsWwD2pwSxCRQWE",
				fullWidthTextContainer: "_39cm2YKltxh0YW0O1f54y3",
				Info: "_16_IgJ4BqtadthCKIpnW1g",
				info: "_16_IgJ4BqtadthCKIpnW1g",
				RadioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				radioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				StyledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				styledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				RadioIcon: "_1g89RGQdzecmnfVeXck6JL",
				radioIcon: "_1g89RGQdzecmnfVeXck6JL",
				Employee: "_2gDVAtwwxskByrxI2Zr9BL",
				employee: "_2gDVAtwwxskByrxI2Zr9BL",
				Private: "_1Ma7YYe0ShiEmNSS16r18H",
				private: "_1Ma7YYe0ShiEmNSS16r18H",
				Public: "_3WyydSidemq34inFmhA1SE",
				public: "_3WyydSidemq34inFmhA1SE",
				Restricted: "CodbGPlWjCpPE6jWVhkOn",
				restricted: "CodbGPlWjCpPE6jWVhkOn",
				CloseButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				closeButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				ErrorText: "_2dXAoHGf_uRg0D6ofrpJbr",
				errorText: "_2dXAoHGf_uRg0D6ofrpJbr"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "radioOptions", (function() {
				return ie
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditCreation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/EmailInvitePaintedDoor/loader.tsx"),
				b = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				h = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				f = n("./src/reddit/contexts/NavbarExp.ts"),
				g = n("./src/reddit/components/SubredditCreationModal/Layout/index.m.less"),
				_ = n.n(g);
			var v = e => {
					const t = Object(r.useContext)(f.a);
					return o.a.createElement("div", {
						className: _.a.OuterContainer
					}, o.a.createElement("div", {
						className: Object(c.a)(e.className, _.a.Container)
					}, o.a.createElement("div", {
						className: Object(c.a)(_.a.Content, {
							[_.a.ContainerExp]: t
						})
					}, e.children)))
				},
				O = n("./src/reddit/components/TrackingHelper/index.tsx"),
				x = n("./src/reddit/constants/modals.ts"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				j = n("./src/reddit/controls/ErrorText/index.tsx"),
				C = n("./src/reddit/controls/RadioInput/index.tsx"),
				k = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				I = n("./src/reddit/controls/TextButton/index.tsx"),
				S = n("./src/reddit/helpers/trackers/emailInvite.ts"),
				w = n("./src/reddit/helpers/trackers/screenview.ts"),
				T = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				N = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				P = n("./src/reddit/icons/svgs/Close/index.tsx"),
				R = n("./src/reddit/icons/svgs/Eye/index.tsx"),
				A = n("./src/reddit/icons/svgs/Info/index.tsx"),
				M = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				D = n("./src/reddit/icons/svgs/User/index.tsx"),
				L = n("./src/reddit/models/Subreddit/index.ts"),
				F = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				U = n("./src/reddit/selectors/experiments/emailInvite.ts"),
				B = n("./src/reddit/selectors/subreddit.ts"),
				G = n("./src/reddit/selectors/tags.ts"),
				H = n("./src/reddit/selectors/user.ts"),
				W = n("./src/lib/formatApiError/index.ts");
			const q = (e, t) => {
				if (!e) return {};
				const n = e.fields && e.fields.length && e.fields[0] && e.fields[0].field,
					r = e.type;
				if ("name" === n) {
					if ("NO_TEXT" === r) return {
						name: s.fbt._("A community name is required", null, {
							hk: "QIlYS"
						})
					};
					if ("BAD_SR_NAME" === r) return {
						name: s.fbt._("Community names must be between 321 characters, and can only contain letters, numbers, or underscores.", null, {
							hk: "2rmVgd"
						})
					};
					if ("SUBREDDIT_EXISTS" === r) return {
						name: s.fbt._("Sorry, r/{subreddit name attempt} is taken. Try another.", [s.fbt._param("subreddit name attempt", t)], {
							hk: "CLwzs"
						})
					};
					if ("SUBREDDIT_UNAVAILABLE" === r) return {
						name: s.fbt._("This community name is unavailable", null, {
							hk: "15j6BB"
						})
					}
				}
				return {
					generic: Object(W.a)(e)
				}
			};
			var V = n("./src/reddit/components/SubredditCreationModal/index.m.less"),
				z = n.n(V),
				K = n("./src/lib/lessComponent.tsx");
			const Q = 21,
				J = "create-title-info",
				Y = K.a.wrapped(A.a, "Info", z.a),
				X = K.a.wrapped(k.a, "RadioOption", z.a),
				Z = K.a.wrapped(b.c, "Tooltip", z.a),
				$ = K.a.wrapped(D.a, "Public", z.a),
				ee = K.a.wrapped(R.a, "Restricted", z.a),
				te = K.a.wrapped(M.a, "Private", z.a),
				ne = K.a.wrapped(N.a, "Employee", z.a),
				se = K.a.wrapped(P.a, "CloseButton", z.a),
				re = K.a.wrapped(j.b, "ErrorText", z.a),
				oe = Object(i.c)({
					error: B.f,
					isCreatePending: B.j,
					isEmailInviteExperimentEnabled: U.a,
					isEmployee: H.N,
					crosspostId: B.i,
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(H.pb)(e),
					userIsSuspended: H.X,
					allTags: G.e,
					existingTags: G.f,
					newTags: G.g,
					selectedPrimaryTagId: G.h
				}),
				ae = Object(a.b)(oe, e => ({
					createCommunity: t => e(Object(u.h)(t)),
					clearErrors: () => e(Object(u.f)()),
					onCloseModal: () => e(Object(l.g)(x.a.SUBREDDIT_CREATION_MODAL_ID)),
					onShowTooltip: () => e(Object(m.f)({
						tooltipId: J
					})),
					onHideTooltip: () => e(Object(m.i)()),
					validateSubredditName: t => e(Object(u.i)(t))
				})),
				ie = (e, t) => [o.a.createElement(X, {
					key: "public",
					showButton: !0,
					value: "public"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement($, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Public", null, {
					hk: "DK992"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Anyone can view, post, and comment to this community", null, {
					hk: "1PfFUA"
				}))))), o.a.createElement(X, {
					key: "restricted",
					showButton: !0,
					value: "restricted"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ee, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Restricted", null, {
					hk: "1iBTDq"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, Object(F.g)(t))))), o.a.createElement(X, {
					key: "private",
					showButton: !0,
					value: "private"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(te, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Private", null, {
					hk: "3q5SYn"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Only approved users can view and submit to this community", null, {
					hk: "3z8OI6"
				}))))), o.a.createElement(X, {
					key: "employees_only",
					showButton: !0,
					value: "employees_only",
					hidden: !e
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ne, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Employees only", null, {
					hk: "1arrQC"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Only Reddit employees can view and submit to this community", null, {
					hk: "3ty23C"
				})))))];
			class de extends o.a.Component {
				constructor(e) {
					super(e), this.onNameChange = e => {
						this.setState({
							name: e.target.value
						}), this.props.clearErrors()
					}, this.update = (e, t) => this.setState({
						[t]: e
					}), this.onTypeChange = e => {
						this.setState({
							type: e
						})
					}, this.onInviteViaEmailClick = () => {
						const {
							sendEvent: e
						} = this.props;
						e(Object(S.a)("community_creation")), this.setState({
							showEmailInviteModal: !0
						})
					}, this.onCloseInviteViaEmailModal = () => {
						this.setState({
							showEmailInviteModal: !1
						})
					}, this.onCreateCommunityClick = () => {
						this.props.isCreatePending || (clearTimeout(this.timeout), this.props.createCommunity({
							name: this.state.name,
							publicDescription: "",
							type: this.state.type,
							over18: this.state.over18,
							restrictCommenting: this.state.restrictCommenting,
							restrictPosting: this.state.restrictPosting,
							allTags: this.props.allTags,
							newTags: this.props.newTags,
							crosspostId: this.state.crosspostId,
							existingTags: this.props.existingTags,
							primaryTagId: this.props.selectedPrimaryTagId || void 0
						}), this.timeout = window.setTimeout(() => {
							this.props.isCreatePending && this.setState({
								waitingForSuccessfulCommunity: !0
							})
						}, 2e3))
					}, this.onValidateSubredditName = () => this.props.validateSubredditName(this.state.name), this.onCloseModal = () => {
						this.props.sendEvent(Object(T.b)()), this.props.onCloseModal()
					}, this.onCancelCreation = () => {
						this.props.onCloseModal(), this.props.sendEvent(Object(T.b)())
					}, this.onUpdateOver18 = () => this.update(!this.state.over18, "over18"), this.state = {
						name: "",
						type: L.f.Public,
						crosspostId: e.crosspostId,
						over18: !1,
						waitingForSuccessfulCommunity: !1,
						restrictCommenting: !1,
						restrictPosting: !0,
						showEmailInviteModal: !1
					}
				}
				componentDidMount() {
					const {
						sendEvent: e
					} = this.props;
					e(Object(w.x)())
				}
				componentWillUnmount() {
					clearTimeout(this.timeout), this.props.clearErrors()
				}
				render() {
					const {
						error: e,
						isCreatePending: t,
						isEmailInviteExperimentEnabled: n,
						isEmployee: r,
						onHideTooltip: a,
						onShowTooltip: i,
						sendEvent: d,
						userDoesNotHaveEnoughExpToCreateCommunity: l,
						userIsSuspended: u
					} = this.props, m = q(e, this.state.name), {
						over18: b,
						showEmailInviteModal: f,
						waitingForSuccessfulCommunity: g
					} = this.state;
					return o.a.createElement(v, {
						className: z.a.subredditCreation
					}, o.a.createElement("div", {
						className: z.a.container
					}, o.a.createElement("h1", {
						className: z.a.title
					}, s.fbt._("Create a community", null, {
						hk: "SlFa7"
					}), o.a.createElement(se, {
						onClick: this.onCloseModal
					})), l ? o.a.createElement("h2", {
						className: z.a.sublabel
					}, s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "44qhJp"
					})) : u ? o.a.createElement("h2", {
						className: z.a.sublabel
					}, s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "3trJMZ"
					})) : o.a.createElement(o.a.Fragment, null, o.a.createElement(h.e, {
						isCreateCommunity: !0,
						label: s.fbt._("Name", null, {
							hk: "3OIzgl"
						}),
						textContainerClassName: z.a.fullWidthTextContainer,
						onBlur: this.onValidateSubredditName,
						onChange: this.onNameChange,
						maxChars: Q,
						value: this.state.name,
						subtext: o.a.createElement("span", {
							className: z.a.subtextContainer
						}, s.fbt._("Community names including capitalization cannot be changed.", null, {
							hk: "VjrZg"
						}), o.a.createElement("span", {
							id: J,
							onMouseEnter: i,
							onMouseLeave: a,
							className: z.a.info
						}, o.a.createElement(Y, null), o.a.createElement(Z, {
							className: z.a.StyledTooltip,
							caretOnTop: !0,
							tooltipId: J,
							text: s.fbt._('Names cannot have spaces (e.g., "r/bookclub" not "r/book club"), must be between 3-21 characters, and underscores ("_") are the only special characters allowed. Avoid using solely trademarked names (e.g., "r/FansOfAcme" not "r/Acme").', null, {
								hk: "3RsycS"
							})
						})))
					}), m.name && o.a.createElement(re, null, m.name), o.a.createElement(h.l, {
						label: s.fbt._("Community type", null, {
							hk: "152EhZ"
						}),
						direction: "column",
						isCreateCommunity: !0,
						textContainerClassName: z.a.fullWidthTextContainer
					}, o.a.createElement(C.a, {
						value: this.state.type,
						name: "type",
						onChange: this.onTypeChange
					}, ie(r, "post"))), o.a.createElement("div", {
						className: Object(c.a)(z.a.field, {
							[z.a.isCreatePending]: t
						})
					}, o.a.createElement("div", {
						className: z.a.subtitle
					}, s.fbt._("Adult content", null, {
						hk: "20arB"
					})), o.a.createElement(y.a, {
						name: "over18",
						value: b,
						onChange: this.onUpdateOver18,
						disabled: t
					}, o.a.createElement("div", {
						className: z.a.nsfw
					}, "NSFW"), o.a.createElement("div", {
						className: z.a.sublabel
					}, s.fbt._("18+ year old community", null, {
						hk: "1XxZMV"
					})))), n && o.a.createElement("div", {
						className: Object(c.a)(z.a.field, {
							[z.a.isCreatePending]: t
						})
					}, o.a.createElement(I.a, {
						className: z.a.textButton,
						onClick: this.onInviteViaEmailClick
					}, s.fbt._("Invite members via email", null, {
						hk: "2uViIf"
					}))), m.generic && o.a.createElement(re, null, m.generic), g && o.a.createElement("div", {
						className: z.a.pendingText
					}, s.fbt._("Your community is being created...", null, {
						hk: "3dSTrq"
					})), o.a.createElement("div", {
						className: z.a.buttonContainer
					}, o.a.createElement(E.t, {
						disabled: t,
						className: z.a.createButton,
						onClick: this.onCancelCreation,
						priority: E.c.Secondary
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(E.t, {
						disabled: t,
						className: z.a.createButton,
						onClick: this.onCreateCommunityClick
					}, s.fbt._("Create Community", null, {
						hk: "QE8Y3"
					}))))), f && o.a.createElement(p.a, {
						onClose: this.onCloseInviteViaEmailModal,
						sendEvent: d
					}))
				}
			}
			t.default = Object(d.a)(Object(O.c)(ae(de)))
		},
		"./src/reddit/components/SubredditForkingCTA/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return S
			}));
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				a = n("./node_modules/react/index.js"),
				i = n.n(a),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/reddit/constants/comments.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/selectors/comments.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				b = n("./node_modules/reselect/es/index.js"),
				h = n("./src/lib/cache/index.ts"),
				f = n("./src/lib/makeCommentsPageKey/index.ts"),
				g = n("./src/reddit/helpers/trackers/subredditForking.ts"),
				_ = n("./src/reddit/components/TrackingHelper/index.tsx");
			const v = Object(o.a)({
					resolved: {},
					chunkName: () => "SubredditForkingCTA",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("Governance~Reddit~SubredditForkingCTA"), n.e("SubredditForkingCTA")]).then(n.bind(null, "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx"
					}
				}),
				O = [{
					low: 0,
					high: 1e5,
					threshold: 100
				}, {
					low: 1e5,
					high: 3e5,
					threshold: 200
				}, {
					low: 3e5,
					high: 8e5,
					threshold: 300
				}, {
					low: 8e5,
					high: 1 / 0,
					threshold: 500
				}],
				x = "subreddit-forking.dismissals",
				E = (e, t) => {
					const n = Object(p.k)(e),
						s = Object(f.a)(t.postId),
						r = Object(m.G)(e, t),
						o = Object(u.o)(e, {
							...t,
							commentsPageKey: s
						}),
						a = Object(u.k)(e, {
							...t,
							commentsPageKey: s
						}).reduce((t, n) => {
							var s;
							const r = Object(u.l)(e, {
								commentLink: n
							});
							return n.type !== c.a.Comment && 0 !== (null === (s = o[n.id]) || void 0 === s ? void 0 : s.depth) || t.push(r), t
						}, []).sort((e, t) => t.score - e.score).slice(0, 5);
					return (null == n ? void 0 : n.id) === r.authorId || !!a.find(e => e.authorId === (null == n ? void 0 : n.id))
				},
				y = e => {
					let t = Object(h.b)(x);
					const n = Object.entries(t || {});
					n.length >= 99 && (t = n.sort((e, t) => {
						let [, n] = e, [, s] = t;
						return s - n
					}).splice(0, 99).reduce((e, t) => {
						let [n, s] = t;
						return e[n] = s, e
					}, {})), Object(h.d)(x, {
						...t,
						[e]: Date.now()
					}, Date.now() + 2592e3)
				},
				j = (e, t) => {
					var n;
					if (!Object(p.Q)(e)) return !1;
					if (null === (n = Object(h.b)(x)) || void 0 === n ? void 0 : n[t.postId]) return !1;
					const s = Object(m.G)(e, t),
						r = Object(m.V)(e, {
							...t,
							disallowProfile: !0
						});
					if ((null == r ? void 0 : r.type) !== l.f.Public || r.isNSFW || r.isQuarantined || (null == s ? void 0 : s.isNSFW) || (null == s ? void 0 : s.source)) return !1;
					const o = O.find(e => {
						let {
							low: t,
							high: n
						} = e;
						return n >= r.subscribers && r.subscribers > t
					});
					return !(!o || !s.numComments || o.threshold > s.numComments) && !!E(e, t)
				},
				C = () => Object(b.c)({
					shouldLoadCTA: j
				}),
				k = Object(d.b)(C),
				I = e => {
					let {
						shouldLoadCTA: t,
						postId: n,
						sendEvent: s
					} = e;
					const [r, o] = Object(a.useState)(!1);
					return r || !t ? null : i.a.createElement(v, {
						onClose: () => {
							y(n), o(!0), s(Object(g.b)(n))
						},
						postId: n
					})
				},
				S = Object(a.memo)(k(Object(_.c)(I)))
		},
		"./src/reddit/components/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Image: "_34CfAAowTqdbNDYXz5tBTW",
				image: "_34CfAAowTqdbNDYXz5tBTW",
				UserIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				userIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				blur: "_2P3jpibqK9Q2k2UJYzBNIy",
				PlanetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				planetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				BackupImage: "RK004G8fbNOkGdNLEzm67",
				backupImage: "RK004G8fbNOkGdNLEzm67",
				iconContainer: "_7nyhK_sDI_8i22XNdcMzb",
				editableIcon: "_1AxWRIyg1lV9-r_CmqYj0o",
				flexContainer: "-Mpi2pdgifDBOdpUYX2vh",
				clickableUploadText: "_3H6u2CWhsluIPVF14GpEaA",
				inTopBar: "_1UpdjN7u66BU606z97t4HS",
				emptyUploadButton: "ndkYE2hc8Y-V3NHpSYvxA",
				transition: "_1iA7YdCRjbU9Rd_2VNGvsw",
				emptyEditableIcon: "_1h9JeZaSDxkh67Ns3QVUP2",
				emptyPlusButton: "Dh1qxsy_tIctL9f4LEzv9",
				imageUploader: "JBITiVY1zX1mMDq-sHkru",
				loadingIcon: "_3Dk8QRKhQImYqds2lSF6G4",
				loadingIconInTopBar: "_1U3KLnHX2TdXL5lNrrv4EW",
				emptyEditableIconInTopBar: "_3-i_fdY8zqHIo3CjuVzTYE",
				defaultCommunityIcon: "_1xvdfUtOPDANqHjxzxKX5b",
				mNightmode: "_1TI6C7sqGL9TRdsq1jRks"
			}
		},
		"./src/reddit/components/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/UserIcon/index.tsx"),
				u = n("./src/reddit/constants/colors.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				h = n("./src/reddit/models/Subreddit/index.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/SubredditIcon/index.m.less"),
				_ = n.n(g);

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const O = c.a.wrapped(l.a, "UserIcon", _.a),
				x = c.a.img("Image", _.a),
				E = e => {
					let {
						iconColor: t,
						...n
					} = e;
					return a.a.createElement(x, v({
						style: {
							backgroundColor: t || ""
						}
					}, n))
				},
				y = c.a.div("BackupImage", _.a),
				j = Object(m.u)();
			t.b = j(e => {
				var t;
				const n = Object(i.e)(f.db);
				let o, c, l;
				if (e.subredditOrProfile) {
					const {
						url: t,
						color: n
					} = Object(p.a)({
						shouldHideNsfwIcon: !!e.shouldHideNsfwIcon,
						subredditOrProfile: e.subredditOrProfile
					});
					Object(h.h)(e.subredditOrProfile) ? l = a.a.createElement(O, {
						className: e.className,
						iconUrl: t,
						isNSFW: e.subredditOrProfile.isNSFW,
						userName: e.subredditOrProfile.name
					}) : (o = t, c = n)
				} else o = e.shouldHideNsfwIcon ? `${s.a.assetPath}/img/avatar_over18.png` : e.iconUrl, c = e.primaryColor || u.a.alienblue;
				return o ? l = a.a.createElement(E, {
					alt: r.fbt._("Subreddit Icon", null, {
						hk: "134aM1"
					}),
					className: Object(d.a)(e.className, {
						[_.a.blur]: e.shouldBlurSubredditIcon
					}),
					iconColor: c,
					role: "presentation",
					src: o
				}) : l || (l = a.a.createElement(b.a, {
					name: "community",
					isFilled: !n,
					className: Object(d.a)(_.a.defaultCommunityIcon, e.className, {
						[_.a.mNightmode]: n,
						[_.a.blur]: e.shouldBlurSubredditIcon
					}),
					style: n ? {
						backgroundColor: e.redditStyle ? u.a.alienblue : c
					} : {
						color: e.redditStyle ? u.a.alienblue : c
					}
				})), e.linkTo ? a.a.createElement("a", v({}, null !== (t = e.linkProps) && void 0 !== t ? t : {}, {
					href: e.linkTo
				}), l) : a.a.createElement(a.a.Fragment, null, l)
			})
		},
		"./src/reddit/components/SubredditModerationSearch/index.m.less": function(e, t, n) {
			e.exports = {
				SearchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				searchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				NoResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				noResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				Container: "_3RNapyf_4ZQOEfoJhVRMEO",
				container: "_3RNapyf_4ZQOEfoJhVRMEO",
				SearchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				searchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				SearchStatus: "uTK2QKUebu8hg0gYZWTI7",
				searchStatus: "uTK2QKUebu8hg0gYZWTI7",
				Bold: "_2u65S50DJfsU-z8bR0G2DQ",
				bold: "_2u65S50DJfsU-z8bR0G2DQ"
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				d = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				u = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				m = n("./src/reddit/icons/svgs/Search/index.tsx"),
				p = n("./src/reddit/components/SubredditModerationSearch/index.m.less"),
				b = n.n(p);
			const h = a.a.wrapped(m.a, "SearchIcon", b.a),
				f = a.a.wrapped(i.a, "NoResultsContainer", b.a),
				g = a.a.div("Container", b.a),
				_ = a.a.wrapped(l.a, "SearchStatusBar", b.a),
				v = a.a.div("SearchStatus", b.a),
				O = a.a.span("Bold", b.a);

			function x(e) {
				if (e.searchPending) return null;
				const t = Object(c.a)(e.searchTerm);
				return e.noResultsFound ? o.a.createElement(f, null, o.a.createElement(h, null), o.a.createElement(i.b, null, s.fbt._("No results for {searchTerm}", [s.fbt._param("searchTerm", `u/${t}`)], {
					hk: "1nDAlG"
				})), o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				}))) : o.a.createElement(g, null, o.a.createElement(_, null, o.a.createElement(v, null, s.fbt._("1 search result for {=[searchTerm]}", [s.fbt._param("=[searchTerm]", o.a.createElement(O, {
					"data-redditstyle": !0
				}, s.fbt._("{searchTerm}", [s.fbt._param("searchTerm", `'${t}':`)], {
					hk: "1B9ZWG"
				})))], {
					hk: "iAcV5"
				})), o.a.createElement(u.a, null, o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				})))), e.children)
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.m.less": function(e, t, n) {
			e.exports = {
				topBarRow: "_3H6HwkSZ2zUC1pwaIMv-EY",
				searchBar: "_2LvB93iPopVPdhNBxBnfAH",
				searchIcon: "_1lo1uHsqx3-EkgYDL4xKEB",
				searchInput: "_1ox94KT4YX0mmZgLO51PG_",
				searchButton: "_3-3xbjG4pcuzlB7SzgBvzg"
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				d = n("./src/reddit/icons/svgs/Search/index.tsx"),
				c = n("./src/reddit/components/SubredditModerationTopBar/index.m.less"),
				l = n.n(c);
			const u = a.a.div("topBarRow", l.a);
			class m extends o.a.Component {
				constructor(e) {
					super(e), this.onSearchChange = e => {
						Object(i.a)(e.currentTarget.value).length < 21 && this.setState({
							searchInputText: e.currentTarget.value
						})
					}, this.onKeyPress = e => {
						"Enter" === e.key && this.onSearch()
					}, this.onSearch = () => {
						this.props.onSearch(this.state.searchInputText)
					}, this.state = {
						searchInputText: ""
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.props.activeSearchQuery && null === e.activeSearchQuery && this.setState({
						searchInputText: ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement("div", {
						className: l.a.topBarRow
					}, e.positionSearchRight && e.children, o.a.createElement("div", {
						className: l.a.searchBar
					}, o.a.createElement("input", {
						className: l.a.searchInput,
						onChange: this.onSearchChange,
						onKeyPress: this.onKeyPress,
						placeholder: s.fbt._("Search for a user", null, {
							hk: "1yTo6e"
						}),
						type: "text",
						value: t.searchInputText
					}), o.a.createElement("button", {
						className: l.a.searchButton,
						onClick: this.onSearch
					}, o.a.createElement(d.a, {
						className: l.a.searchIcon
					}))), !e.positionSearchRight && e.children)
				}
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.m.less": function(e, t, n) {
			e.exports = {
				Row: "_2O5kmPXewMHlCcrRWrjEB_",
				row: "_2O5kmPXewMHlCcrRWrjEB_",
				Username: "_1sIhmckJjyRyuR_z7M5kbI",
				username: "_1sIhmckJjyRyuR_z7M5kbI",
				RightAlign: "_3f00u5KR-M4rdaonscLX8k",
				rightAlign: "_3f00u5KR-M4rdaonscLX8k",
				Description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				AdditionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				additionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				ChevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				chevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				ChevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				chevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				ExpandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				expandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				Bullet: "_1VQtDRh-JtZQghS8jetaHR",
				bullet: "_1VQtDRh-JtZQghS8jetaHR",
				PlaceholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				placeholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				EmptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				emptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				EmptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				emptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				UsersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg",
				usersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg"
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return A
			}));
			var s = n("./node_modules/lodash/times.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				l = n("./src/reddit/components/UserNameAndIcon/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				p = n("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				b = n("./src/reddit/layout/row/Inline/index.tsx"),
				h = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				f = n("./src/reddit/components/SubredditModerationUserItem/index.m.less"),
				g = n.n(f);
			const {
				fbt: _
			} = n("./node_modules/fbt/lib/FbtPublic.js"), v = (e, t) => {
				const n = `UserInfoTooltip--${e}`;
				return t ? `${n}--${t}` : n
			}, O = i.a.wrapped(b.a, "Row", g.a), x = i.a.div("Username", g.a), E = i.a.wrapped(h.a, "RightAlign", g.a), y = i.a.div("Description", g.a), j = i.a.div("AdditionalText", g.a), C = i.a.wrapped(m.a, "ChevronDown", g.a), k = i.a.wrapped(p.a, "ChevronUp", g.a), I = i.a.div("ExpandoContainer", g.a), S = i.a.span("Bullet", g.a), w = i.a.div("PlaceholderItem", g.a), T = i.a.wrapped(w, "EmptyUserIcon", g.a), N = i.a.wrapped(w, "EmptyDetails", g.a), P = i.a.div("UsersLoadingContainer", g.a), R = () => a.a.createElement(O, null, a.a.createElement(T, null), a.a.createElement(N, null), a.a.createElement(N, null)), A = e => a.a.createElement(P, {
				className: e.className
			}, r()(e.rows || 10, e => a.a.createElement(R, {
				key: e
			})));
			class M extends a.a.Component {
				constructor(e) {
					super(e), this.onToggleExpandedComponent = () => {
						this.props.pageName && !this.state.isExpanded && this.props.sendEvent(c.a("more_detail", this.props.pageName)), this.setState({
							isExpanded: !this.state.isExpanded
						})
					}, this.sendHoverCardEvent = () => {
						this.props.pageName && this.props.sendEvent(c.c(this.props.pageName))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return a.a.createElement(a.a.Fragment, null, a.a.createElement(O, null, a.a.createElement(x, null, a.a.createElement(l.a, {
						username: e.username,
						userIcon: e.userIcon,
						tooltipId: v(e.username, e.moderatorType),
						subredditId: e.subredditId,
						sendHoverCardEvent: this.sendHoverCardEvent
					})), a.a.createElement(y, null, e.timeAgo, e.description && a.a.createElement(a.a.Fragment, null, a.a.createElement(S, null, ""), e.description)), a.a.createElement(E, null, e.additionalText && a.a.createElement(j, null, e.additionalText), e.primaryButton, e.secondaryButton, e.tertiaryButton, e.expandedComponent && a.a.createElement(u.r, {
						onClick: this.onToggleExpandedComponent
					}, _._("More Details", null, {
						hk: "KnMc6"
					}), t.isExpanded ? a.a.createElement(k, null) : a.a.createElement(C, null)))), t.isExpanded && a.a.createElement(I, null, e.expandedComponent))
				}
			}
			t.b = Object(d.c)(M)
		},
		"./src/reddit/components/SubredditNameLink/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditName: "_3ryJoIoycVkA88fy40qNJc",
				subredditName: "_3ryJoIoycVkA88fy40qNJc"
			}
		},
		"./src/reddit/components/SubredditNameLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				r = n("./src/reddit/components/SubredditNameLink/index.m.less"),
				o = n.n(r);
			const a = n("./src/lib/lessComponent.tsx").a.wrapped(s.a, "SubredditName", o.a);
			t.a = a
		},
		"./src/reddit/components/SubredditRules/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1fQ3jmS7djNiAnk2kVsPko",
				titleFontH2: "_39dtESYDu10VI6hZlt8jT_",
				titleFontH3: "_2_Ya84laiZ_AK4zBLZeXmE",
				titleFontH4: "_2k9S2SK_mdrMw9dXzIJka3",
				titleFontH5: "_3hrj37O_iGAZk7ssKstspL",
				titleFontH6: "_2KYRCY7gyTJjBx_Vr5pjqd",
				metadataFont: "_2hHNLn3quM7R0Znfoal7Wi",
				flairFont: "KkD9-eQEXAm_GdJAbixZ5",
				labelsFont: "_1xgXWixwTrYRf6JjxPm7ft",
				actionFont: "_1HQtdMEzh4gag8do4e9j7Z",
				smallButtonFont: "zWcRyj2-0oiXHbpM-5L1A",
				largeButtonFont: "_2PIOcp6QTxVygtl2u9ji_a",
				strongTextFont: "_2adE8ldKa4w_dETRAs-vdP",
				tabFont: "UtQUA6_scmmMeiLaweTg2",
				buttonFontXS: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontXs: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontS: "_1TFRBw_YwgrsDelv1Pi-SM",
				buttonFontM: "_2H_oQnXKALaCioWB1K9l-O",
				buttonFontL: "_2gy3VLIz6UYY1qlR5-fcVm",
				buttonFontXL: "_1drcPUSEFqtlwYnTDdJsro",
				buttonFontXl: "_1drcPUSEFqtlwYnTDdJsro",
				bodyFontH1: "_3lbK38dxFajKo78JrAEtIe",
				bodyFontH2: "_1CH0HVqZd3qMaT2gzU5mYn",
				bodyFontH3: "xk7ESbG2cmLPdln3D1fVi",
				bodyFontH4: "_29_oVfDyKoOggix5Gj6kah",
				bodyFontH5: "_1RoE8VrwOjvkyDDc-a8RZ_",
				bodyFontH6: "_3jwZ9V_jg7YZ4T-0cmGzxY",
				bodyFontH6Small: "_3WMZAYheSFIrrjKgM6FOG1",
				bodyFont: "_2iji_FM7kTNPRlaRGrPpq8",
				bodyFontSmall: "oJpqQ5hwA0NwwwlDu-EZH",
				bodyFontMono: "_2nUMbdZlQ1fQpJ_LaDNrbn",
				duplicateName: "_31Visb7b2S-tj09Ls_2Acy",
				emptyDetails: "_8PDfWWfcYPlmlmOr2Notr",
				emptyIcon: "_2tEWDkQudqJGiBAQsXSYXE",
				emptyRightIcon: "aF9GyLBXjDrRFO_7BTOYU",
				expandDetails: "_19etb4qzR1xpaHDy7AVdRr",
				header: "_2Xb_1g-T9iGzHDDy3_XpMD",
				DragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragIcon: "RR4AdUs4L9geua2bjCoqQ",
				icon: "PbUpiwMGWTjzrcYfCTdc0",
				iconButton: "_138C3cC0PAtIwsXoIAfGvJ",
				iconWrapper: "Ep3vJhfng2q2-wfiIgstP",
				loadingContainer: "ve35wYJQyEHavtRQYDY7V",
				metadata: "_1xQ_DrqnJXDZq1ptXHxYIB",
				middleMeta: "_2OWUxJA0Dhi0onvygJk3_i",
				middleMetaBlock: "n1lY8o9sGnqcqSfVzm5Vs",
				modalCloseButton: "zKQ8lyAF3pYyDoSlTpTjA",
				modalDescriptionBlock: "_26a81Mk5bsppGjI9AXbmWS",
				modalDescriptionField: "_1brIoxFWlohWpvu34OwZQP",
				modalFooter: "R-9ebJbU9igzPDfUi4Txg",
				modalRadioButton: "_1KFGHoJGHbU05yh6-sQIr5",
				modalRadioText: "_360Lh4DKj256s8RdElARFo",
				modalReasonField: "_1hdSGf--gQDRwsU96bzao1",
				modalRemoveButton: "_2yAePObDkhgZql3P1FHRu1",
				modalReportMeta: "_21sqmEi4OnC4uXlcUGDT_T",
				modalReportTitle: "_1y0X9006mE_5nlHfol1nc2",
				modalRule: "_1AlCnggMuPLxxDUbWWhG2q",
				modalRuleField: "QP-_TXfrh6G1-IRJif4Cy",
				modalRuleTitle: "_2I1A_fyvhaC7TYrYwA047Y",
				modalSubmitButton: "hHFW3BkgX7tSn5Nev-ooY",
				placeholderRow: "hv6YY1IfCww5loDzbkuMS",
				row: "_1LfPdWXylWmVTmLinhd4xl",
				rulesHeader: "_3MOq7UPqtI4o9EnAyCWkEQ",
				rulesIcon: "_29Fl8s_IvZwHxUPNV2ARiW",
				rulesInfo: "KTZ0Ir6xknUXuN4WMI7RN",
				ruleMetaText: "iVYauV_t6_ChREoxhNGsU",
				ruleMetaTitle: "ffGjaCMPoTUkhkVp6rHw5",
				emptyWrapper: "_2-xwKK1EqJlzI2dO7SIrbF",
				ruleNumber: "_3DEhjnxmn1BzXcJ_ml7kSQ",
				ruleText: "_1ZwBW5sLL75ZAZvQreMjn-",
				PrimaryButton: "_3GOmWOjCh6hPWZg1j-zPkr",
				primaryButton: "_3GOmWOjCh6hPWZg1j-zPkr"
			}
		},
		"./src/reddit/components/SubredditRules/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/config.ts"),
				o = n("./node_modules/lodash/isEqual.js"),
				a = n.n(o),
				i = n("./node_modules/lodash/times.js"),
				d = n.n(i),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				u = n("./node_modules/react-redux/es/index.js"),
				m = n("./node_modules/reselect/es/index.js"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/actions/modal.ts"),
				h = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/reddit/actions/subredditRules/constants.ts"),
				g = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/endpoints/subreddit/rules.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/subreddit.ts");
			const x = Object(h.a)(f.e),
				E = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = Object(O.U)(r(), {
							subredditId: e
						}).name,
						d = `success-block-${t.rule}`,
						c = `error-block-${t.rule}`,
						l = await Object(_.a)(a(), i, t);
					if (l.ok) {
						const t = l.body;
						n(x({
							rules: t,
							subredditId: e
						})), n(g.f({
							id: d,
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Rule added", null, {
								hk: "4D4jbP"
							})
						}))
					} else n(g.f({
						id: c,
						kind: v.b.Error,
						text: l.json.errors ? l.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "2C9b4N"
						})
					}))
				}, y = Object(h.a)(f.f), j = Object(h.a)(f.g), C = Object(h.a)(f.d), k = (e, t) => async (n, r, o) => {
					let {
						apiContext: a
					} = o;
					const i = Object(O.U)(r(), {
							subredditId: e
						}).name,
						d = Object(O.Q)(r(), {
							subredditId: e
						}),
						c = `success-block-${e}`,
						l = `error-block-${e}`,
						u = await Object(_.e)(a(), i, t);
					if (u.ok) {
						const t = u.body;
						n(C({
							rules: t,
							subredditId: e
						})), n(g.f({
							id: c,
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Rule order updated", null, {
								hk: "3bmmvl"
							}),
							buttonText: s.fbt._("Undo", null, {
								hk: "1RYWKC"
							}),
							buttonAction: k(e, d)
						}))
					} else n(g.f({
						id: l,
						kind: v.b.Error,
						text: "explanation" in u ? u.explanation : u.json && "errors" in u.json ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "1XJ2UQ"
						})
					}))
				};
			var I = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				S = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				w = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				T = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				N = n("./src/reddit/components/TrackingHelper/index.tsx"),
				P = n("./src/reddit/controls/Button/index.tsx"),
				R = n("./src/reddit/controls/Sortable/index.tsx"),
				A = n("./src/reddit/selectors/telemetry.ts");
			const M = e => ({
					subreddit: A.hb(e),
					profile: A.R(e),
					userSubreddit: A.rb(e)
				}),
				D = e => t => ({
					source: "rules",
					action: "click",
					noun: e,
					...M(t)
				}),
				L = (e, t) => n => ({
					source: "rules",
					action: "click",
					noun: e,
					actionInfo: A.d(n, {
						count: t
					}),
					...M(n)
				});
			var F = n("./src/reddit/icons/fonts/index.tsx"),
				U = n("./src/reddit/layout/row/Inline/index.tsx"),
				B = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				G = n("./src/reddit/models/Rule/index.ts"),
				H = n("./src/reddit/selectors/activeModalId.ts"),
				W = n("./src/reddit/selectors/moderatorPermissions.ts"),
				q = n("./src/reddit/components/SubredditRules/index.m.less"),
				V = n.n(q),
				z = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				K = n("./src/reddit/icons/svgs/Grapple/index.tsx");
			const Q = p.a.wrapped(z.a, "DragCard", V.a);
			var J = e => l.a.createElement(Q, {
					isDragging: e.isDragging,
					isOver: e.isOver,
					canDrop: e.canDrop
				}, l.a.createElement(U.a, {
					className: V.a.row
				}, l.a.createElement("span", {
					className: V.a.ruleNumber
				}, e.index + 1), l.a.createElement("span", {
					className: V.a.ruleText
				}, e.shortName), l.a.createElement("span", {
					className: V.a.iconWrapper
				}, l.a.createElement(K.a, {
					className: V.a.dragIcon,
					title: s.fbt._("Drag", null, {
						hk: "dBKmA"
					})
				})))),
				Y = n("./src/higherOrderComponents/asModal/index.tsx"),
				X = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				Z = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				$ = n("./src/reddit/controls/RadioInput/index.tsx"),
				ee = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				te = n("./src/reddit/controls/TextButton/index.tsx"),
				ne = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");
			const se = {
					rule: "",
					kind: "all",
					reportReason: "",
					description: ""
				},
				re = Object(u.b)(null, (e, t) => ({
					createRule: n => e(E(t.subredditId, n)),
					updateRule: (n, r) => e(((e, t, n) => async (r, o, a) => {
						let {
							apiContext: i
						} = a;
						const d = Object(O.U)(o(), {
								subredditId: e
							}).name,
							c = `success-block-${t.rule}`,
							l = `error-block-${t.rule}`,
							u = await Object(_.f)(i(), d, t, n);
						if (u.ok) {
							const t = u.body;
							r(y({
								rules: t,
								subredditId: e,
								oldName: n
							})), r(g.f({
								id: c,
								kind: v.b.SuccessCommunityGreen,
								text: s.fbt._("Rule updated", null, {
									hk: "1ljetO"
								})
							}))
						} else r(g.f({
							id: l,
							kind: v.b.Error,
							text: u.json.errors ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "2acjBM"
							})
						}))
					})(t.subredditId, n, r))
				}));
			class oe extends l.a.Component {
				constructor(e) {
					super(e), this.onRuleInputChange = e => {
						e.currentTarget.value.trim().length <= G.g && this.setState({
							rule: e.currentTarget.value
						})
					}, this.onReportReasonInputChange = e => {
						e.currentTarget.value.trim().length <= G.f && this.setState({
							reportReason: e.currentTarget.value
						})
					}, this.onDescriptionInputChange = e => {
						e.currentTarget.value.trim().length <= G.a && this.setState({
							description: e.currentTarget.value
						})
					}, this.onSave = () => {
						const {
							props: e,
							state: t
						} = this, n = {
							rule: t.rule.trim(),
							kind: t.kind,
							reason: t.reportReason.trim(),
							description: t.description.trim()
						};
						e.rule ? e.updateRule(n, e.rule.shortName) : e.createRule(n), e.toggleModal(), e.sendEvent()
					}, this.canSave = () => {
						const {
							props: e,
							state: t
						} = this, n = t.rule.trim(), s = t.reportReason.trim(), r = t.description.trim(), o = !e.ruleNames.includes(n) || e.ruleNames.includes(n) && e.rule && e.rule.shortName === n, a = !e.rule || (e.rule.shortName !== n || e.rule.violationReason !== t.reportReason || e.rule.kind !== t.kind || e.rule.description !== r);
						return o && a && n.length > 0 && n.length <= G.g && s.length <= G.f && r.length <= G.a && t.kind
					}, this.selectRuleKind = e => {
						this.setState({
							kind: e
						})
					}, this.isDuplicateRuleName = () => {
						const {
							props: e,
							state: t
						} = this, n = !e.rule || e.rule.shortName !== t.rule.trim(), s = e.ruleNames.includes(t.rule.trim());
						return 0 !== t.rule.trim().length && n && s
					}, this.state = e.rule ? {
						rule: e.rule.shortName,
						kind: e.rule.kind,
						reportReason: e.rule.violationReason || "",
						description: e.rule.description || ""
					} : se
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return l.a.createElement(Z.e, null, l.a.createElement(Z.i, null, l.a.createElement(ne.a, null, l.a.createElement(Z.q, null, e.rule ? s.fbt._("Edit rule", null, {
						hk: "2zflTO"
					}) : s.fbt._("Add rule", null, {
						hk: "1xqo5O"
					})), l.a.createElement(te.a, {
						className: V.a.modalCloseButton,
						onClick: e.toggleModal
					}, l.a.createElement(Z.b, null)))), l.a.createElement(Z.l, null, l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalRule
					}, s.fbt._("Rule", null, {
						hk: "1W7esG"
					})), l.a.createElement(Z.t, {
						className: V.a.modalRuleField,
						onChange: this.onRuleInputChange,
						placeholder: s.fbt._('Rule displayed (e.g. "No photos")', null, {
							hk: "GdEW"
						}),
						value: t.rule
					}), this.isDuplicateRuleName() && l.a.createElement("span", {
						className: V.a.duplicateName
					}, s.fbt._("You have another rule with this title. Please change.", null, {
						hk: "2EPSGv"
					})), l.a.createElement(X.a, {
						maxChars: G.g,
						text: t.rule.trim()
					})), l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalRuleTitle
					}, s.fbt._("Applies to", null, {
						hk: "Pzu3b"
					})), l.a.createElement($.a, {
						name: "RULE_KIND_PICKER",
						onChange: this.selectRuleKind,
						value: t.kind
					}, l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: G.b.all,
						value: G.b.all,
						selected: t.kind === G.b.all,
						showButton: !0,
						tabIndex: t.kind === G.b.all ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Posts & comments", null, {
						hk: "tHmQq"
					}))), l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: G.b.post,
						value: G.b.post,
						selected: t.kind === G.b.post,
						showButton: !0,
						tabIndex: t.kind === G.b.post ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Posts only", null, {
						hk: "16dDBr"
					}))), l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: G.b.comment,
						value: G.b.comment,
						selected: t.kind === G.b.comment,
						showButton: !0,
						tabIndex: t.kind === G.b.comment ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Comments only", null, {
						hk: "2V8qUA"
					}))))), l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalReportTitle
					}, s.fbt._("Report reason", null, {
						hk: "3ShjE9"
					})), l.a.createElement(Z.m, {
						className: V.a.modalReportMeta
					}, s.fbt._("Defaults to rule name if left blank", null, {
						hk: "2xObiU"
					})), l.a.createElement(Z.t, {
						className: V.a.modalReasonField,
						onChange: this.onReportReasonInputChange,
						placeholder: t.rule.trim().length > 0 && 0 === t.reportReason.trim().length ? t.rule : s.fbt._('Reason rule is broken (e.g. "This is a photo")', null, {
							hk: "2Op1SL"
						}),
						value: t.reportReason
					}), l.a.createElement(X.a, {
						maxChars: G.f,
						text: t.reportReason.trim()
					})), l.a.createElement("div", {
						className: V.a.modalDescriptionBlock
					}, l.a.createElement(Z.p, {
						className: V.a.modalRuleTitle
					}, s.fbt._("Full description", null, {
						hk: "4CTvQy"
					})), l.a.createElement(Z.t, {
						className: V.a.modalDescriptionField,
						onChange: this.onDescriptionInputChange,
						placeholder: s.fbt._("Enter the full description of the rule.", null, {
							hk: "3EyaJe"
						}),
						value: t.description
					}), l.a.createElement(X.a, {
						maxChars: G.a,
						text: t.description.trim()
					}))), l.a.createElement(Z.g, {
						className: V.a.modalFooter
					}, l.a.createElement(P.l, {
						className: V.a.modalSubmitButton,
						onClick: this.onSave,
						disabled: !this.canSave()
					}, e.rule ? s.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : s.fbt._("Add new rule", null, {
						hk: "2dy0gV"
					})), l.a.createElement(Z.a, {
						onClick: e.toggleModal
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.rule && l.a.createElement(Z.s, {
						className: V.a.modalRemoveButton,
						onClick: e.onDelete
					}, s.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var ae = Object(Y.a)(re(oe)),
				ie = n("./src/lib/timeAgo/index.ts"),
				de = n("./src/reddit/components/HumanDate/index.tsx"),
				ce = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				le = n("./src/reddit/components/RichTextJson/index.tsx"),
				ue = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				me = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				pe = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				be = n("./src/reddit/models/RichTextJson/index.ts");
			const he = {};
			class fe extends l.a.Component {
				constructor(e) {
					super(e), this.toggleExpandDetails = () => {
						this.setState(e => ({
							isExpanded: !e.isExpanded
						}))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						hasConfigPerms: e,
						index: t,
						onEdit: n,
						subredditRule: r
					} = this.props, o = r.descriptionRichText ? JSON.parse(r.descriptionRichText).document : void 0, a = Object(ie.c)(r.createdUtc) >= 1;
					return l.a.createElement(l.a.Fragment, null, l.a.createElement(U.a, {
						className: V.a.row
					}, l.a.createElement("span", {
						className: V.a.ruleNumber
					}, t + 1), l.a.createElement("span", {
						className: V.a.ruleText
					}, r.shortName), l.a.createElement("span", {
						className: V.a.iconWrapper
					}, e && l.a.createElement("button", {
						className: V.a.iconButton,
						onClick: n
					}, l.a.createElement(pe.a, {
						className: V.a.icon,
						title: s.fbt._("Edit", null, {
							hk: "1nftDt"
						})
					})), l.a.createElement("button", {
						className: V.a.iconButton,
						onClick: this.toggleExpandDetails
					}, this.state.isExpanded ? l.a.createElement(ue.a, {
						className: V.a.icon,
						title: s.fbt._("Collapse", null, {
							hk: "eGqwd"
						})
					}) : l.a.createElement(me.a, {
						className: V.a.icon,
						title: s.fbt._("Expand", null, {
							hk: "4dMVPg"
						})
					})))), this.state.isExpanded && l.a.createElement(U.a, {
						className: V.a.expandDetails
					}, l.a.createElement("span", {
						className: V.a.metadata
					}, l.a.createElement("span", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Report reason", null, {
						hk: "2RH1DJ"
					})), l.a.createElement("span", {
						className: V.a.ruleMetaText
					}, r.violationReason && 0 !== r.violationReason.length ? r.violationReason : r.shortName)), l.a.createElement("span", {
						className: V.a.middleMeta
					}, l.a.createElement("div", {
						className: V.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Applies to", null, {
						hk: "19eYpy"
					})), l.a.createElement("div", {
						className: V.a.ruleMetaText
					}, r.kind === G.b.all ? s.fbt._("Posts & comments", null, {
						hk: "34PjHx"
					}) : r.kind === G.b.post ? s.fbt._("Posts only", null, {
						hk: "3MllWy"
					}) : s.fbt._("Comments only", null, {
						hk: "StCEa"
					}))), l.a.createElement("div", {
						className: V.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Created", null, {
						hk: "gSE9w"
					})), l.a.createElement("div", {
						className: V.a.ruleMetaText
					}, a ? l.a.createElement(de.b, {
						seconds: r.createdUtc
					}) : l.a.createElement(de.d, {
						seconds: r.createdUtc
					})))), l.a.createElement("span", {
						className: V.a.metadata
					}, l.a.createElement("span", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Full description", null, {
						hk: "20Lgcg"
					})), l.a.createElement("span", {
						className: V.a.ruleMetaText
					}, o && !Object(be.G)({
						document: o
					}) ? l.a.createElement(le.b, {
						className: V.a.ruleMetaText,
						content: {
							document: o
						},
						rtJsonElementProps: he
					}) : r.descriptionHtml ? l.a.createElement(ce.a, {
						className: V.a.ruleMetaText,
						html: r.descriptionHtml
					}) : r.description))))
				}
			}
			var ge = fe;
			const _e = p.a.wrapped(P.l, "PrimaryButton", V.a),
				ve = () => l.a.createElement(U.a, {
					className: V.a.placeholderRow
				}, l.a.createElement("span", {
					className: V.a.emptyWrapper
				}, l.a.createElement("span", {
					className: V.a.emptyIcon
				})), l.a.createElement("span", {
					className: V.a.emptyDetails
				}), l.a.createElement("span", {
					className: V.a.iconWrapper
				}, l.a.createElement("span", {
					className: V.a.emptyRightIcon
				}), l.a.createElement("span", {
					className: V.a.emptyRightIcon
				}))),
				Oe = () => l.a.createElement("div", {
					className: V.a.loadingContainer
				}, d()(15, e => l.a.createElement(ve, {
					key: e
				}))),
				xe = Object(m.c)({
					hasModConfigPerms: (e, t) => Object(W.b)(B.c.config)(e, {
						subredditId: t.subreddit.id
					}),
					isConfirmModalOpen: e => "SubredditRule--Modal--DeleteConfirmation" === Object(H.a)(e),
					isRuleEditorOpen: e => "SubredditRule--Editor--Modal" === Object(H.a)(e),
					isSubredditRulesPending: e => Object(O.S)(e),
					ruleOrder: (e, t) => Object(O.Q)(e, {
						subredditId: t.subreddit.id
					}),
					subredditRules: (e, t) => Object(O.T)(e, {
						subredditId: t.subreddit.id
					})
				}),
				Ee = Object(u.b)(xe, (e, t) => ({
					removeRule: (n, r) => e(((e, t, n) => async (r, o, a) => {
						let {
							apiContext: i
						} = a;
						const d = Object(O.U)(o(), {
								subredditId: e
							}).name,
							c = Object(O.T)(o(), {
								subredditId: e
							})[n],
							l = `success-block-${t}`,
							u = `error-block-${t}`,
							m = await Object(_.d)(i(), d, t);
						if (m.ok) {
							const t = m.body;
							r(j({
								rules: t,
								subredditId: e
							})), r(g.f({
								id: l,
								kind: v.b.SuccessCommunityGreen,
								text: s.fbt._("Rule deleted", null, {
									hk: "2Kwoph"
								}),
								buttonText: s.fbt._("Undo", null, {
									hk: "1RYWKC"
								}),
								buttonAction: E(e, {
									rule: c.shortName,
									kind: c.kind,
									reason: c.violationReason,
									description: c.description
								})
							}))
						} else r(g.f({
							id: u,
							kind: v.b.Error,
							text: m.json.errors ? m.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "37ELrZ"
							})
						}))
					})(t.subreddit.id, n, r)),
					reorderRules: n => {
						e(k(t.subreddit.id, n))
					},
					toggleConfirmationModal: () => e(Object(b.i)("SubredditRule--Modal--DeleteConfirmation")),
					toggleRuleEditorModal: () => e(Object(b.i)("SubredditRule--Editor--Modal"))
				}));
			class ye extends l.a.Component {
				constructor(e) {
					super(e), this.deleteRule = () => {
						const e = this.state.ruleToEdit;
						e && this.props.removeRule(e.shortName, e.priority)
					}, this.onConfirmDeleteRule = () => {
						this.props.toggleConfirmationModal()
					}, this.onEditRule = e => {
						this.setState({
							ruleToEdit: e
						}), this.props.toggleRuleEditorModal()
					}, this.handleDrop = (e, t, n) => this.setState({
						ruleOrder: n,
						numRulesMoved: this.state.numRulesMoved + 1
					}), this.reorderRules = () => {
						this.props.reorderRules(this.state.ruleOrder), this.props.sendEvent(L("save_reorder", this.state.numRulesMoved)), this.stopReorder()
					}, this.startReorder = () => {
						this.setState({
							isReordering: !0,
							ruleOrder: this.props.ruleOrder
						})
					}, this.stopReorder = () => this.setState({
						isReordering: !1,
						numRulesMoved: 0
					}), this.toggleConfirmationModal = () => {
						this.props.toggleConfirmationModal(), this.setState({
							ruleToEdit: null
						})
					}, this.toggleEditorModal = () => {
						this.props.toggleRuleEditorModal(), this.setState({
							ruleToEdit: null
						})
					}, this.trackClick = e => this.props.sendEvent(D(e)), this.trackEdit = () => this.state.ruleToEdit ? this.trackClick("save_edit") : this.trackClick("save_new"), this.trackDelete = () => this.trackClick("delete"), this.state = {
						numRulesMoved: 0,
						ruleToEdit: null,
						ruleOrder: e.ruleOrder,
						isReordering: !1
					}
				}
				render() {
					const {
						hasModConfigPerms: e,
						isConfirmModalOpen: t,
						isRuleEditorOpen: n,
						isSubredditRulesPending: o,
						subreddit: i,
						subredditRules: d
					} = this.props;
					return l.a.createElement(l.a.Fragment, null, e && l.a.createElement(T.c, null, this.state.isReordering ? l.a.createElement(P.o, {
						onClick: this.stopReorder
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})) : l.a.createElement(P.r, {
						onClick: this.startReorder,
						disabled: d.length <= 1
					}, s.fbt._("Reorder rules", null, {
						hk: "1qh7V6"
					})), this.state.isReordering ? l.a.createElement(_e, {
						onClick: this.reorderRules,
						disabled: a()(d.map(e => e.shortName), this.state.ruleOrder)
					}, s.fbt._("Save", null, {
						hk: "4yMsMq"
					})) : l.a.createElement(_e, {
						onClick: this.toggleEditorModal,
						disabled: o || d.length >= G.e
					}, s.fbt._("Add rule", null, {
						hk: "6GEk0"
					}))), d.length ? l.a.createElement(T.a, null, l.a.createElement("div", {
						className: V.a.header
					}, l.a.createElement(T.b, {
						className: V.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(w.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					})), !this.state.isReordering && l.a.createElement("div", {
						className: V.a.rulesInfo
					}, s.fbt._("These are rules that visitors must follow to participate. They can be used as reasons to report or ban posts, comments, and users. Communities can have a maximum of 15 rules.", null, {
						hk: "1C2Vjc"
					}))), this.state.isReordering ? l.a.createElement(R.a, {
						values: this.state.ruleOrder,
						render: (e, t, n, s, r) => l.a.createElement(J, {
							isDragging: n,
							isOver: s,
							canDrop: r,
							index: t,
							shortName: e
						}),
						onDrop: this.handleDrop
					}) : d.map((t, n) => l.a.createElement(ge, {
						hasConfigPerms: e,
						index: n,
						key: `${i.name}-${t.shortName}`,
						onEdit: () => this.onEditRule(t),
						subredditRule: t
					}))) : l.a.createElement(T.a, null, l.a.createElement("div", {
						className: V.a.header
					}, l.a.createElement(T.b, {
						className: V.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(w.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					}))), o ? l.a.createElement(Oe, null) : l.a.createElement(S.c, {
						text: s.fbt._("No rules yet", null, {
							hk: "pYLkV"
						})
					}, l.a.createElement(F.a, {
						name: "rules",
						className: V.a.rulesIcon
					}))), n && l.a.createElement(ae, {
						onDelete: this.onConfirmDeleteRule,
						rule: this.state.ruleToEdit,
						ruleNames: d.map(e => e.shortName),
						sendEvent: this.trackEdit,
						subredditId: i.id,
						toggleModal: this.toggleEditorModal,
						withOverlay: !0
					}), t && this.state.ruleToEdit && l.a.createElement(I.a, {
						actionText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: s.fbt._("Delete rule", null, {
							hk: "5q2Ri"
						}),
						modalText: s.fbt._("Are you sure you want to delete this rule?", null, {
							hk: "2diD6u"
						}),
						onConfirm: this.deleteRule,
						toggleModal: this.toggleConfirmationModal,
						trackClick: this.trackDelete,
						withOverlay: !0
					}))
				}
			}
			t.a = Ee(Object(N.c)(ye))
		},
		"./src/reddit/components/SubredditSearchCarousel/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/experiments/joinOptimizations.ts");
			const d = Object(s.a)({
					resolved: {},
					chunkName: () => "SubredditSearchCarousel",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("SubredditSearchCarousel").then(n.bind(null, "./src/reddit/components/SubredditSearchCarousel/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditSearchCarousel/index.tsx"
					}
				}),
				c = e => {
					const t = Object(a.e)(i.e),
						n = Object(a.e)(i.a);
					return t || n ? o.a.createElement(d, e) : null
				}
		},
		"./src/reddit/components/SubscribeButton/Base.m.less": function(e, t, n) {
			e.exports = {
				BaseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				baseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				UnsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				unsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				UnsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW",
				unsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/reddit/controls/Button/index.tsx"),
				i = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				d = n("./src/reddit/components/SubscribeButton/Base.m.less"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts");

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const m = (e, t, n) => null != n ? n : t ? e : a.c.Plain,
				p = e => {
					let {
						border: t,
						priority: n,
						small: s,
						...r
					} = e;
					return o.a.createElement(a.t, u({}, r, {
						priority: m(a.c.Primary, t, n),
						className: Object(l.a)(r.className, c.a.BaseButton),
						size: s ? a.d.S : a.d.M
					}))
				},
				b = e => o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
					className: c.a.UnsubscribeButtonDefault
				}, "subreddit" === e ? s.fbt._("Joined", null, {
					hk: "1MTmIz"
				}) : s.fbt._("Following", null, {
					hk: "1wQlVR"
				})), o.a.createElement("span", {
					className: c.a.UnsubscribeButtonHover
				}, "subreddit" === e ? s.fbt._("Leave", null, {
					hk: "2lLnnn"
				}) : s.fbt._("Unfollow", null, {
					hk: "2b5ERD"
				}))),
				h = e => {
					let {
						buttonType: t,
						border: n,
						priority: s,
						small: r,
						...i
					} = e;
					return o.a.createElement(a.t, u({}, i, {
						priority: m(a.c.Secondary, n, s),
						className: Object(l.a)(i.className, c.a.BaseButton),
						size: r ? a.d.S : a.d.M,
						text: b(t)
					}))
				};
			class f extends o.a.Component {
				constructor() {
					super(...arguments), this.onClick = e => {
						if (this.props.userIsSubscriber ? (this.props.onUnsubscribe(), this.props.afterUnsubscribeAction && this.props.afterUnsubscribeAction()) : this.props.onSubscribe(), this.props.onClick && this.props.onClick(e), this.props.getEventFactory) {
							const e = this.props.getEventFactory(this.props.userIsSubscriber);
							e && this.props.sendEvent(e)
						}
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						border: e = !0,
						className: t,
						id: n,
						priority: s,
						small: r = !1,
						isFullWidth: a = !1,
						style: d
					} = this.props, c = {
						border: e,
						className: t,
						onClick: this.onClick,
						priority: s,
						small: r,
						isFullWidth: a,
						style: d
					};
					return this.props.userIsSubscriber ? o.a.createElement(h, u({}, c, {
						buttonType: this.props.identifier.type
					})) : o.a.createElement(p, u({}, c, {
						id: n
					}), this.props.children, Object(i.a)({
						type: this.props.identifier.type,
						key: "subscribe"
					}))
				}
			}
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				o = {
					subredditActions: {
						subscribe: () => s.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => s.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => s.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => s.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => s.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => s.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				a = e => {
					let {
						type: t,
						key: n
					} = e;
					return o[r({
						type: t
					})][n]()
				}
		},
		"./src/reddit/components/SubscribeButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx"),
				r = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				o = n("./src/reddit/components/SubscribeButton/Base.tsx");
			t.a = Object(r.a)(Object(s.c)(o.a))
		},
		"./src/reddit/components/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				blurredThumbnail: "GnWcY6GPzeZ5rzsiQ98fo",
				container: "_2MkcR85HDnYngvlVW2gMMa",
				contentType: "_2hIvPRO2xz4rn9LXAJXYDa",
				hasType: "_10qSZsDWnOBwx4bc7GJ1QF",
				hiddenImage: "_25ZOvQhQdAqwdxPd5z-KFB",
				imageThumbnail: "_33Pa96SGhFVpZeI6a7Y_Pl",
				verticallyCenterThumbnail: "Fq7oYOARH1VVCaLAuAh37",
				linkIcon: "m0n699kowSp8Wfa40lqpF",
				outboundLinkIcon: "_2rOixIHGmpfZB93ihJsw3V",
				placeholderThumbnail: "_2YO2O4rMRYYMeH_t2y8M5w",
				thumbnail: "_2c1ElNxHftd8W_nZtcG9zf",
				usePreview: "_78ohNtfA1urjgUhnN1jLi",
				LinkText: "_3HXDOeeCKnmgu_pIdoLofi",
				linkText: "_3HXDOeeCKnmgu_pIdoLofi"
			}
		},
		"./src/reddit/components/Thumbnail/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return N
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				l = n("./src/reddit/components/ImageWithFallback/index.tsx"),
				u = n("./src/reddit/controls/ContentType/index.tsx"),
				m = n("./src/reddit/controls/OutboundLink/index.tsx"),
				p = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				b = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/models/Theme/index.ts"),
				f = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				g = n("./src/telemetry/models/Outbound.ts"),
				_ = n("./src/reddit/components/Thumbnail/index.m.less"),
				v = n.n(_);

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const x = e => e.placeholderImage || Object(f.a)(e).placeholderImage,
				E = e => e.placeholderImage ? "cover" : Object(f.a)(e).placeholderImagePosition,
				y = d.a.span("LinkText", v.a),
				j = e => {
					let {
						className: t,
						onClick: n,
						children: s
					} = e;
					return o.a.createElement("div", {
						onClick: n,
						className: Object(a.a)(v.a.linkIcon, t)
					}, s)
				},
				C = e => o.a.createElement("img", {
					alt: e.alt,
					className: Object(a.a)(v.a.hiddenImage, e.className)
				}),
				k = e => {
					const t = o.a.createRef(),
						{
							src: n,
							errorSrc: s
						} = e;
					return n && s && Object(l.a)(n).catch(() => {
						t.current && (t.current.style.backgroundImage = `url(${s})`)
					}), o.a.createElement("div", {
						"aria-label": e.alt,
						className: Object(a.a)(v.a.thumbnail, v.a.imageThumbnail, e.className),
						"data-click-id": "image",
						ref: t,
						role: "img",
						style: {
							backgroundImage: `url(${e.src})`,
							borderColor: e.isOutbound ? Object(f.a)(e).button : Object(f.a)(e).line
						}
					}, e.isOutbound && o.a.createElement(j, {
						className: e.linkIconClassName
					}, o.a.createElement(p.a, {
						className: Object(a.a)(v.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(y, {
						className: e.linkTextClassName
					}, e.text)), o.a.createElement(C, {
						alt: e.alt,
						className: "hiddenImg"
					}))
				},
				I = e => e.isOutbound ? Object(f.a)(e).button : e.placeholderImage ? "transparent" : Object(f.a)(e).line,
				S = e => {
					const t = x(e),
						n = t && {
							background: Object(h.g)(Object(f.a)(e).placeholder, t, E(e))
						};
					return o.a.createElement("div", {
						className: Object(a.a)(v.a.thumbnail, v.a.placeholderThumbnail, e.className),
						"data-click-id": "image",
						style: {
							...n,
							borderColor: I(e)
						}
					}, (!e.placeholderImage || e.showContentType) && o.a.createElement(u.a, {
						className: Object(a.a)(e.contentTypeClassName, v.a.contentType, {
							[v.a.hasType]: e.type && !e.isOutbound
						}),
						type: e.isMeta || e.isPoll ? "meta" : e.type
					}), e.isOutbound && o.a.createElement(j, {
						className: e.linkIconClassName
					}, o.a.createElement(p.a, {
						className: Object(a.a)(v.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(y, {
						className: e.linkTextClassName
					}, e.text)))
				},
				w = e => o.a.createElement(k, O({}, e, {
					className: Object(a.a)(v.a.blurredThumbnail, e.className)
				})),
				T = Object(i.a)(e => {
					const {
						className: t,
						containerClassName: n,
						contentTypeClassName: r,
						crosspost: i,
						forceShowNSFW: d,
						isCommentsPage: c,
						isMeta: l,
						linkIconClassName: u,
						linkTextClassName: p,
						outboundLinkIconClassName: h,
						post: f,
						redditStyle: _,
						removeLink: O,
						showContentType: E,
						templatePlaceholderImage: y,
						text: j,
						theme: C,
						usePreview: k
					} = e, I = !C.subredditContext.shouldShowNSFWContent && (f.isNSFW || !(!i || !i.isNSFW)) && !d, S = x({
						placeholderImage: y,
						redditStyle: _,
						theme: C
					}), w = N(e), T = c ? g.SourceElement.PostImage : g.SourceElement.ListingPostImage, P = R(f, t, S, I, j, C, w, l, E, O, _, u, p, h, r), A = Object(b.D)(f);
					return Object(s.a)(A) && !O && A.indexOf("redditmedia") < 0 ? o.a.createElement("div", {
						className: Object(a.a)(v.a.container, k ? v.a.usePreview : "", n)
					}, o.a.createElement(m.b, {
						href: Object(b.D)(f),
						isSponsored: f.isSponsored,
						postId: f.id,
						source: f.source,
						sourceElement: T
					}, P)) : o.a.createElement("div", {
						className: Object(a.a)(v.a.container, k ? v.a.usePreview : "", n)
					}, P)
				}),
				N = e => {
					let {
						crosspost: t,
						post: n,
						url: s,
						usePreview: r
					} = e;
					if (s) return s;
					const {
						preview: o,
						media: a,
						thumbnail: i
					} = t || n;
					return r && o ? o.url : n.isSponsored && o && "default" === i.url ? o.url : P(a) ? a.scrubberThumbSource : i.url
				},
				P = e => !!e && e.type === b.o.LIVEVIDEO,
				R = (e, t, n, r, i, d, l, u, m, p, b, h, f, g, _) => {
					const x = (e => e.source && !e.isSponsored || !1)(e);
					if (Object(s.a)(l)) {
						const n = P(e.media),
							s = n ? {
								errorSrc: c.U
							} : {},
							u = Object(a.a)(t, {
								[v.a.verticallyCenterThumbnail]: n
							});
						return r ? o.a.createElement(w, O({
							"data-click-id": "image",
							src: l
						}, s, {
							className: u,
							isOutbound: x && !p,
							linkIconClassName: h,
							linkTextClassName: f,
							outboundLinkIconClassName: g,
							redditStyle: b,
							text: i,
							theme: d
						})) : o.a.createElement(k, O({
							alt: e.title,
							className: u,
							src: l
						}, s, {
							isOutbound: x && !p,
							linkIconClassName: h,
							linkTextClassName: f,
							outboundLinkIconClassName: g,
							redditStyle: b,
							text: i,
							theme: d
						}))
					}
					return o.a.createElement(S, {
						className: t,
						contentTypeClassName: _,
						placeholderImage: n,
						isMeta: u,
						isOutbound: x && !p,
						linkIconClassName: h,
						linkTextClassName: f,
						outboundLinkIconClassName: g,
						redditStyle: b,
						showContentType: m,
						text: i,
						theme: d,
						type: e.media ? e.media.type : null,
						isPoll: !!e.pollData
					})
				};
			t.a = T
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = r.a.createContext(() => {});

			function l(e) {
				let {
					children: t
				} = e;
				const n = Object(o.f)(),
					d = Object(s.useCallback)(e => {
						{
							const t = n.getState(),
								s = e(t);
							Object(i.a)({
								...a.n(t),
								...s
							})
						}
					}, [n]);
				return r.a.createElement(c.Provider, {
					value: d
				}, t ? r.a.Children.only(t) : null)
			}

			function u() {
				return Object(s.useContext)(c)
			}

			function m(e) {
				function t(t) {
					const n = u();
					return r.a.createElement(e, d({}, t, {
						sendEvent: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `Tracked(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/UserIcon/PresenceDot.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				i = n("./src/reddit/icons/svgs/PresenceCircle/index.tsx"),
				d = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				c = n.n(d);
			t.default = e => {
				const {
					showPresence: t,
					onceInViewport: n
				} = e, d = Object(s.useRef)(null), l = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t
						} = e;
						t && n && n()
					})
				}, [n]);
				return Object(a.a)(d, l), r.a.createElement(i.a, {
					ref: d,
					className: Object(o.a)(c.a.presenceDot, {
						[c.a.isLit]: t
					}),
					isHighlighted: e.isHighlighted,
					outlineClassName: e.outlineClassName
				})
			}
		},
		"./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				d = n.n(i);
			t.a = function(e) {
				let {
					backgroundClassName: t,
					className: n,
					headshot: r,
					hasNftBorder: i
				} = e;
				return o.a.createElement("div", {
					className: Object(a.a)(d.a.snoovatarWrapper, n, {
						[d.a.hasNftBorder]: Boolean(i)
					})
				}, o.a.createElement("div", {
					className: Object(a.a)(d.a.snoovatarBackground, t)
				}), o.a.createElement("div", {
					className: d.a.snoovatarHeadshotContainer
				}, o.a.createElement("img", {
					alt: s.fbt._("User avatar", null, {
						hk: "12gjW8"
					}),
					className: d.a.snoovatarHeadshot,
					src: r
				})))
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.m.less": function(e, t, n) {
			e.exports = {
				currentUserIconWrapper: "efdkOLo3oigH_95whTYCp",
				userIconWrapper: "_2p14AQvJBvTrEEa4csiW9v",
				isProfileIcon: "_1lxVpLf3223Gve3gRhbG-R",
				DefaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				defaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				UserIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				userIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				mNightmode: "_2aVSEFJsIE0M-4uRE-U24H",
				nftAnimation: "_3fhlcUDP9SJN47QMfuzW_j",
				nftBackground: "_3ppYbU2ZS369JSNSb8585I",
				nftBorder: "_1AX7t-EP7R4ZoVC41DG-Jx",
				snoovatarWrapper: "_1cyAeeYDGrx7MPL_jRwKZ",
				snoovatarBackground: "_2_QqG5dG916znjlVV8ZCbw",
				hasNftBorder: "_3Bn5QwbgKslkdt4UwkP9r9",
				snoovatarHeadshotContainer: "_1XJXnCAngvZLEeLpB3oa4L",
				snoovatarHeadshot: "ScrrUjzznpAqm92uwgnvO",
				presenceDot: "_2dn5Ncenn0BSD4tCSmxQhA",
				isLit: "GpWjjkZl5_kV4yZYWBaT2",
				hasHeadShotWrapper: "_1TENjLYSaj4L4uJMZa3DRe"
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/icons/svgs/SnooSilhouette/index.tsx"),
				c = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				l = n.n(c);
			const u = `${s.a.assetPath}/img/avatar_over18_square.png`,
				m = e => !e || e.includes("avatar_default_");
			t.b = e => {
				const {
					className: t,
					iconUrl: n,
					isCurrentUser: s,
					isNightMode: o,
					isNSFW: c,
					nsfwIconUrl: p,
					shouldHideNSFW: b
				} = e;
				if (s && m(n) || !s && !n) return a.a.createElement(d.a, {
					className: Object(i.a)(l.a.DefaultUserIcon, t, {
						[l.a.mNightmode]: o
					})
				});
				const h = !s && c && b ? p || u : n;
				return a.a.createElement("img", {
					alt: r.fbt._("User avatar", null, {
						hk: "X43nA"
					}),
					className: Object(i.a)(l.a.UserIcon, t),
					src: h
				})
			}
		},
		"./src/reddit/components/UserIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/realtime/GQLSubscription/async.tsx"),
				c = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				l = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				u = n("./src/reddit/models/User/index.ts"),
				m = n("./src/config.ts"),
				p = n("./src/reddit/components/LottieAnimation/index.tsx");
			var b = e => {
					let {
						className: t
					} = e;
					return o.a.createElement("svg", {
						className: t,
						fill: "none",
						viewBox: "0 0 32 32",
						xmlns: "http://www.w3.org/2000/svg"
					}, o.a.createElement("radialGradient", {
						id: "a",
						cx: "0",
						cy: "0",
						gradientTransform: "matrix(20.06268 6.0999 -3097.55815 10187.91225 -3.1 11.6)",
						gradientUnits: "userSpaceOnUse",
						r: "1"
					}, o.a.createElement("stop", {
						offset: "0",
						stopColor: "#1185b5"
					}), o.a.createElement("stop", {
						offset: ".29",
						stopColor: "#d7f7ff"
					}), o.a.createElement("stop", {
						offset: ".53",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".84",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".87",
						stopColor: "#1990b9"
					}), o.a.createElement("stop", {
						offset: "1",
						stopColor: "#3f9fc6"
					})), o.a.createElement("path", {
						d: "M13.77 1.1c.76-.41 1.7-.41 2.46 0L28 7.58c.75.42 1.2 1.17 1.2 1.96v12.94c0 .79-.45 1.54-1.2 1.95L16.23 30.9c-.76.42-1.7.42-2.46 0L2 24.42a2.25 2.25 0 0 1-1.2-1.95V9.53C.8 8.74 1.24 8 2 7.57z",
						stroke: "url(#a)",
						strokeLinejoin: "round",
						strokeWidth: "1.59"
					}))
				},
				h = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				f = n.n(h);
			var g = e => {
					let {
						iconUrl: t
					} = e;
					return Object(c.c)(t) ? o.a.createElement(p.a, {
						className: f.a.nftAnimation,
						assetUrl: `${m.a.assetPath}/img/snoovatars/comment-animations/nft_comment_animation.json`,
						loop: !0
					}) : o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: f.a.nftBackground
					}), o.a.createElement(b, {
						className: f.a.nftBorder
					}))
				},
				_ = n("./src/reddit/components/UserIcon/PresenceDot.tsx"),
				v = n("./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx"),
				O = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				x = n("./src/reddit/selectors/user.ts"),
				E = n("./src/reddit/selectors/experiments/profileAvatarChangeFix.ts");

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const j = () => {},
				C = Object(i.c)({
					currentUser: x.k,
					isNightMode: x.db,
					shouldHideNSFW: x.F,
					user: x.Ab,
					isProfileAvatarChangeFixEnabled: E.a
				}),
				k = Object(a.b)(C);
			t.a = k(e => {
				const {
					authorId: t,
					collapsed: n,
					currentUser: a,
					iconUrl: i,
					isCommentAuthorBlocked: m,
					isHighlighted: p,
					isNft: b,
					isNSFW: h,
					shouldUseOnlineOverride: x,
					isOnlineOverrideValue: E,
					isOnlineStatusLoadTest: C,
					isProfileIcon: k,
					omitResponsivePresenceWrapper: I,
					onPresenceIndicatorInViewport: S,
					shouldShowPresenceIndicator: w,
					user: T,
					userName: N,
					isProfileAvatarChangeFixEnabled: P,
					...R
				} = e, A = !!a && Object(u.e)(a) === N, M = A ? a : T, D = M && M.accountIcon || i, L = T ? T.isNSFW : h, F = Object(c.a)(D) && !m, U = F ? o.a.createElement(v.a, {
					headshot: D,
					className: e.className,
					hasNftBorder: b && Object(c.d)(i)
				}) : o.a.createElement(O.b, y({}, R, {
					iconUrl: m && n ? "https://www.redditstatic.com/avatars/defaults/v2/avatar_default_3.png" : D,
					isCurrentUser: A,
					isNSFW: L
				})), [B, G] = Object(r.useState)(!1), H = Object(r.useMemo)(() => ({
					input: {
						channel: {
							teamOwner: "CONTENT_AND_COMMUNITIES",
							category: "ONLINE_STATUS_INDICATOR",
							userID: t
						}
					}
				}), [t]), W = Object(r.useCallback)(e => {
					const {
						isOnline: t
					} = e.subscribe.data;
					G(t)
				}, []), q = Object(r.useRef)(null), [V, z] = Object(r.useState)(!1), K = Object(r.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? z(!0) : s && z(!1)
					})
				}, []), Q = Object(r.useRef)({
					rootMargin: "750px 0px 1000px 0px"
				});
				return Object(l.a)(q, K, Q.current), I ? U : o.a.createElement("div", {
					className: Object(s.a)(f.a.userIconWrapper, {
						[f.a.hasHeadShotWrapper]: F,
						[f.a.isProfileIcon]: k && P
					}),
					ref: q
				}, b && o.a.createElement(g, {
					iconUrl: i
				}), U, w && (B || x && E) && o.a.createElement(_.default, {
					showPresence: !0,
					isHighlighted: p,
					onceInViewport: S
				}), (w || C) && !x && V && o.a.createElement(d.a, {
					variables: H,
					onData: w ? W : j,
					queryKey: "isUserOnline"
				}))
			})
		},
		"./src/reddit/components/UserNameAndIcon/index.m.less": function(e, t, n) {
			e.exports = {
				UserIconContainer: "_3gyThPd4NTS21qtNdizCxE",
				userIconContainer: "_3gyThPd4NTS21qtNdizCxE",
				UserIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				userIcon: "_1utZNH6IItbNzgdnUBW-Bp",
				UserLink: "_2Q3rLIRb_ij54AEsabVm9L",
				userLink: "_2Q3rLIRb_ij54AEsabVm9L"
			}
		},
		"./src/reddit/components/UserNameAndIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				d = n("./src/reddit/components/UserIcon/index.tsx"),
				c = n("./src/reddit/controls/InternalLink/index.tsx"),
				l = n("./src/reddit/components/UserNameAndIcon/index.m.less"),
				u = n.n(l);
			const m = a.a.span("UserIconContainer", u.a),
				p = a.a.wrapped(d.a, "UserIcon", u.a),
				b = a.a.wrapped(c.default, "UserLink", u.a);
			t.a = e => o.a.createElement(b, {
				className: e.className,
				to: `${s.a.redditUrl}/user/${e.username}`
			}, o.a.createElement(i.a, {
				user: e.username,
				sendHoverCardEvent: e.sendHoverCardEvent,
				subredditId: e.subredditId,
				tooltipId: e.tooltipId
			}, o.a.createElement(m, {
				style: {
					height: e.iconSize || "32px",
					width: e.iconSize || "32px"
				}
			}, o.a.createElement(p, {
				iconUrl: e.userIcon,
				isNSFW: !1,
				userName: e.username
			})), e.username))
		},
		"./src/reddit/components/VerticalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				votesContainer: "_1E9mcoVn4MYnuBQSVDt1gC",
				bounceUp: "nmB1I04Z-G4nY3g3s_17F",
				bounceDown: "_1L6r7KisMt3CYUGWSEMGiR",
				disabledScore: "_3WPd5t8B-7mtiGONFotWAM"
			}
		},
		"./src/reddit/components/VerticalVotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/reddit/constants/elementClassNames.ts"),
				u = n("./src/reddit/controls/Score/index.tsx"),
				m = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/models/Vote/index.ts"),
				h = n("./src/reddit/selectors/posts.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/VerticalVotes/index.m.less"),
				_ = n.n(g);
			const v = Object(i.c)({
					isNightMode: f.db,
					isAnimatingUpvotePostId: h.k
				}),
				O = Object(a.b)(v),
				x = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.upvoteInactive && Object(p.a)(e).voteIcons.upvoteActive,
				E = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.downvoteInactive && Object(p.a)(e).voteIcons.downvoteActive;
			class y extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						voted: b.a.notVoted
					}, this.onUpvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.upvoted), this.setState({
							voted: e !== b.a.upvoted ? b.a.upvoted : b.a.notVoted
						})
					}, this.onDownvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.downvoted), this.setState({
							voted: e !== b.a.downvoted ? b.a.downvoted : b.a.notVoted
						})
					}
				}
				render() {
					const e = this.props,
						{
							downvoteButtonClassName: t,
							isCountAnimShadowTestEnabled: n,
							isNightMode: r,
							isAnimatingUpvotePostId: a,
							shouldShowUpvoteRatioOnHover: i,
							isVoteCountAnimation: c,
							shouldShowScore: p = !0,
							upvoteButtonClassName: h,
							containerRef: f,
							model: g,
							postId: v
						} = e,
						O = x(e),
						y = E(e),
						j = g.voteState,
						C = a === v;
					return o.a.createElement("div", {
						className: Object(d.a)(_.a.votesContainer, e.className),
						id: `vote-arrows-${g.id}`,
						ref: f
					}, O ? o.a.createElement(m.b, {
						"aria-label": s.fbt._("upvote", null, {
							hk: "G6dJB"
						}),
						"aria-pressed": j === b.a.upvoted,
						"data-click-id": "upvote",
						compact: e.compact,
						className: e.upvoteClassName,
						id: e.upvoteTooltipId,
						isNightMode: r,
						onClick: this.onUpvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("upvote", null, {
							hk: "RguWS"
						}),
						"aria-pressed": j === b.a.upvoted,
						className: Object(d.a)(l.n, h, {
							[_.a.bounceUp]: C
						}),
						onClick: this.onUpvote,
						"data-click-id": "upvote",
						id: e.upvoteTooltipId
					}, o.a.createElement(m.d, {
						compact: e.compact,
						className: e.upvoteClassName,
						voteState: j
					})), !e.compact && p && o.a.createElement(u.a, {
						className: Object(d.a)(_.a.Score, e.scoreClassName),
						flairStyleTemplate: e.flairStyleTemplate,
						light: e.light,
						score: e.model.score,
						voteState: j,
						shouldShowUpvoteRatioOnHover: i,
						isScoreHidden: e.model.isScoreHidden,
						isVoteCountAnimation: !!c,
						isCountAnimShadowTestEnabled: !!n,
						postId: v
					}), y ? o.a.createElement(m.a, {
						"aria-label": s.fbt._("downvote", null, {
							hk: "tNfDV"
						}),
						"aria-pressed": j === b.a.downvoted,
						"data-click-id": "downvote",
						className: e.downvoteClassName,
						compact: e.compact,
						isNightMode: r,
						onClick: this.onDownvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("downvote", null, {
							hk: "1mDjTw"
						}),
						"aria-pressed": j === b.a.downvoted,
						className: Object(d.a)(l.n, t),
						onClick: this.onDownvote,
						"data-click-id": "downvote"
					}, o.a.createElement(m.c, {
						className: e.downvoteClassName,
						compact: e.compact,
						voteState: j
					})))
				}
			}
			const j = Object(c.a)(O(y));
			t.a = j
		},
		"./src/reddit/components/VerticalVotes/votes.m.less": function(e, t, n) {
			e.exports = {
				customDownvote: "ceU_3ot04pOVIcrrXH9fY",
				compact: "_3sO1xEnOT_9CQBjRzczQjS",
				voted: "_8dpZTfzgKPKCUTjp9SAn1",
				customUpvote: "_2k73nZrjAYiwAj9hv7K-kq"
			}
		},
		"./src/reddit/components/VerticalVotes/votes.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return P
			})), n.d(t, "d", (function() {
				return R
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx");
			const i = (e, t, n) => s => {
				const r = e(s),
					a = t(s),
					i = !r && a;
				return Object(o.a)(n.baseClassName, s.className, {
					[n.mIsInteractive]: a,
					[n.mIsActive]: r,
					[n.mIsVoteable]: i
				})
			};
			var d = n("./src/reddit/icons/fonts/Downvote/index.tsx"),
				c = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/controls/Downvote/index.m.less"),
				u = n.n(l);
			const m = {
					...u.a,
					baseClassName: u.a.Downvote
				},
				p = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.downvoted
				},
				b = i(p, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, m);
			var h = e => r.a.createElement(d.a, {
					className: b(e),
					compact: e.compact,
					isFilled: p(e)
				}),
				f = n("./src/reddit/icons/fonts/Upvote/index.tsx"),
				g = n("./src/reddit/controls/Upvote/index.m.less"),
				_ = n.n(g);
			const v = {
					..._.a,
					baseClassName: _.a.Upvote
				},
				O = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.upvoted
				},
				x = i(O, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, v);
			var E = e => r.a.createElement(f.b, {
					className: x(e),
					compact: e.compact,
					isFilled: O(e)
				}),
				y = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				j = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				C = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				k = n("./src/reddit/components/VerticalVotes/votes.m.less"),
				I = n.n(k);

			function S() {
				return (S = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const w = e => Object(o.a)({
					[I.a.compact]: e.compact,
					[I.a.dark]: Object(j.b)(Object(y.a)(e)),
					[I.a.nightmode]: e.isNightMode
				}),
				T = Object(a.a)(e => {
					const {
						voteIcons: t
					} = Object(C.a)(e), n = {
						"--verticalvotes-customdownvote-active": `url(${t.downvoteActive})`,
						"--verticalvotes-customdownvote-inactive": `url(${t.downvoteInactive})`
					}, {
						theme: s,
						isNightMode: a,
						voteState: i,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", S({}, l, {
						className: Object(o.a)(I.a.customDownvote, w(e), {
							[I.a.voted]: e.voteState === c.a.downvoted
						}, e.className),
						style: n
					}))
				}),
				N = Object(a.a)(e => {
					const {
						voteIcons: t
					} = Object(C.a)(e), n = {
						"--verticalvotes-customupvote-active": `url(${t.upvoteActive})`,
						"--verticalvotes-customupvote-inactive": `url(${t.upvoteInactive})`
					}, {
						theme: s,
						isNightMode: a,
						voteState: i,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", S({}, l, {
						className: Object(o.a)(I.a.customUpvote, w(e), {
							[I.a.voted]: e.voteState === c.a.upvoted
						}, e.className),
						style: n
					}))
				}),
				P = h,
				R = E
		},
		"./src/reddit/components/ViewReportsDropdown/Loader.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ViewReportsDropdown-index",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ViewReportsDropdown-index").then(n.bind(null, "./src/reddit/components/ViewReportsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ViewReportsDropdown/index.tsx"
				}
			})
		},
		"./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less": function(e, t, n) {
			e.exports = {
				modalBody: "_1bgWTt9jbjzFmQBe0xzfBc",
				notice: "_19wd_7K0Gqdp6cf0Pno6jX",
				sectionTitle: "_2eB-lbdBJ7yGnpy9iCXf27",
				primaryButton: "_1Wp9oAwAZieyVMe4wA5SeL",
				dropdownContainer: "_2-waVlosIHdWwUa_OBavKm",
				dropdownTarget: "_1mcRpBQSnN5ALeKix2x4Py",
				targetText: "_3QRCCOc1SfjMkk4bZCW5lD",
				dropdown: "_1Uq_MgLQhUk4iL9iHGz3qL",
				dropdownRow: "_2UfNC6z3v6GQsT_TQn-eoZ",
				errorText: "_31tw_6Xr1vH0KRVUnoJEdv"
			}
		},
		"./src/reddit/connectors/ClassicPost/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/post.ts"),
				a = n("./src/reddit/actions/tooltip.ts"),
				i = n("./src/reddit/models/Vote/index.ts"),
				d = n("./src/reddit/contexts/InsideOverlay.tsx"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/contexts/Post/index.tsx"),
				u = n("./src/reddit/selectors/activeModalId.ts"),
				m = n("./src/reddit/selectors/chatPost.ts"),
				p = n("./src/reddit/selectors/experiments/web2x_cta.ts"),
				b = n("./src/reddit/selectors/moderatorPermissions.ts"),
				h = n("./src/reddit/selectors/postFlair.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				g = n("./src/reddit/selectors/showPromotedCTA.ts"),
				_ = n("./src/reddit/selectors/user.ts");
			const v = {
					autoplayPref: _.b,
					activeModalId: u.a,
					crosspost: f.d,
					isActive: f.j,
					isChatPost: m.d,
					isCurrentUserProfilePost: f.l,
					isExpanded: f.m,
					isLoggedIn: _.Q,
					showPromotedCTA: g.a,
					moderatorPermissions: b.m,
					modModeEnabled: c.U,
					poll: (e, t) => {
						const n = e.posts.metaMap[t.postId];
						return n ? e.polls.models[n] : null
					},
					showEditFlair: h.a,
					showMedia: c.s,
					flairStyleTemplate: c.W,
					showCTAExperimentDesign: p.a
				},
				O = Object(s.b)(() => Object(r.c)(v), (e, t) => {
					let {
						postId: n
					} = t;
					return {
						handleVote: t => {
							const s = t === i.a.upvoted ? Object(o.kb)(n) : Object(o.w)(n);
							e(s)
						},
						onIgnoreReports: () => e(Object(o.gb)(n)),
						onOpenReportsDropdown: t => e(Object(a.h)({
							tooltipId: t
						}))
					}
				}, (e, t, n) => ({
					...e,
					...t,
					...n,
					formatTitle: e => e.title
				}));
			t.a = e => Object(l.b)(O(Object(d.b)(e)))
		},
		"./src/reddit/connectors/PostViewable/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/actions/post.ts");
			t.a = (e, t) => Object(s.b)(e, function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return {
					...e,
					onPostViewable: r.Q
				}
			}(t))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/emailVerificationTooltip.ts"),
				a = n("./src/reddit/actions/subscription/index.ts"),
				i = n("./src/reddit/selectors/experiments/emailEnablement.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			t.a = Object(s.b)(() => Object(r.c)({
				userIsSubscriber: d.gb,
				emailEnablementJoinFollowVoteVariant: i.a
			}), (e, t) => {
				let {
					identifier: n
				} = t;
				return {
					onSubscribe: () => e(a.d([n], !0)),
					onSubscriptionsRequested: () => e(a.e()),
					onUnsubscribe: () => e(a.d([n], !1)),
					toggleEmailVerificationTooltip: () => e(Object(o.c)("user_follow"))
				}
			})
		},
		"./src/reddit/constants/componentSizes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "r", (function() {
				return h
			})), n.d(t, "t", (function() {
				return f
			})), n.d(t, "s", (function() {
				return g
			})), n.d(t, "u", (function() {
				return _
			})), n.d(t, "v", (function() {
				return v
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "o", (function() {
				return j
			}));
			const s = 284,
				r = 450,
				o = 800,
				a = 284,
				i = 48,
				d = 640,
				c = 1600,
				l = 40,
				u = 48,
				m = 24,
				p = 24,
				b = 312,
				h = 40,
				f = 270,
				g = 106,
				_ = 5,
				v = 16,
				O = 1250,
				x = 82,
				E = 48,
				y = 36,
				j = 40
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			}));
			const s = "comment",
				r = "comment-submission-form-markdown",
				o = "comment-submission-form-richtext",
				a = "comments-page-link-num-comments",
				i = "post-content"
		},
		"./src/reddit/constants/elementClassNames.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "k", (function() {
				return i
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "n", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return f
			}));
			const s = "DraftEditor-contentwrapper",
				r = "public-DraftStyleDefault-block",
				o = "data-offset-key",
				a = "hovered",
				i = "scrollerItem",
				d = "threadline",
				c = "header-user-dropdown",
				l = "voteButton",
				u = "RichTextJSON-root",
				m = "ImageBox-image",
				p = "content-type-link",
				b = "styled-outbound-link",
				h = "ListingLayout-backgroundContainer",
				f = "ListingLayout-outerContainer"
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			}));
			const s = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				a = "overlayScrollContainer",
				i = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/errors.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(s || (s = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(r || (r = {}))
		},
		"./src/reddit/constants/gold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			}));
			const s = "ModerationPage--Modal--AddAward",
				r = "ModerationPage--Modal--DeleteAwardConfirmation",
				o = 20,
				a = 4,
				i = 1e4,
				d = .2,
				c = .1,
				l = .1,
				u = 500
		},
		"./src/reddit/constants/graphql.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(s || (s = {}))
		},
		"./src/reddit/constants/jsapiEvents.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "reddit",
				r = "reddit.ready",
				o = "reddit.urlChanged"
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(s || (s = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Backspace = "Backspace", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(r || (r = {}))
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "PostCreation-AddEventButton",
				r = 500,
				o = "PostCreation-CollectionEducationTooltip",
				a = "PostCreation-EventEducationTooltip",
				i = 300,
				d = i,
				c = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/constants/screenWidths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = 480,
				r = 960,
				o = 1200
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "d", (function() {
					return s
				})), n.d(t, "c", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return a
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(s || (s = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				a = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			const s = 4,
				r = 60,
				o = 70,
				a = 90,
				i = 99,
				d = 100,
				c = 100
		},
		"./src/reddit/contexts/ApiContext.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const a = {
					apiContext: () => {
						throw new Error("Component attempted to make an API request with no ApiContext")
					},
					gqlContext: () => {
						throw new Error("Component attempted to make an API request with no GqlContext")
					},
					gqlRealtime2Context: () => {
						throw new Error("Component attempted to make an API request with no GqlRealtime2Context")
					}
				},
				i = Object(s.createContext)(a);

			function d(e) {
				const t = t => r.a.createElement(i.Consumer, null, n => {
					let {
						apiContext: s,
						gqlContext: a,
						gqlRealtime2Context: i
					} = n;
					return r.a.createElement(e, o({
						apiContext: s,
						gqlContext: a,
						gqlRealtime2Context: i
					}, t))
				});
				return t.displayName = `WithApiContext(${e.displayName||e.name})`, t
			}
		},
		"./src/reddit/contexts/InsideOverlay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const a = r.a.createContext(!1);

			function i(e) {
				function t(t) {
					return r.a.createElement(a.Consumer, null, n => r.a.createElement(e, o({}, t, {
						isOverlay: n
					})))
				}
				return t.displayName = `WithOverlay(${e.displayName||e.name})`, t
			}
		},
		"./src/reddit/contexts/NavbarExp.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = r.a.createContext(!1)
		},
		"./src/reddit/contexts/Post/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/constants/posts.ts"),
				i = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				d = n("./src/reddit/hooks/useUserContext.ts"),
				c = n("./src/reddit/models/User/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.createContext(null);

			function b(e) {
				const t = Object(o.e)(t => Object(l.G)(t, {
						postId: e
					})),
					{
						currentUser: n
					} = Object(d.a)(),
					s = Object(o.e)(e => t ? Object(u.M)(e, {
						identifier: t.belongsTo
					}) : null),
					r = (null == t ? void 0 : t.belongsTo.type) === a.a.SUBREDDIT ? s : null,
					m = !(!n || (null == t ? void 0 : t.author) !== Object(c.e)(n)),
					p = Object(o.e)(o => ({
						currentUser: n,
						imageGalleryCurrentItem: Object(l.i)(o, {
							postId: e
						}),
						isModerator: !(!r || !o.moderatingSubreddits[r.name]),
						post: t,
						postId: e,
						subreddit: r,
						subredditOrProfile: s,
						userIsOp: m
					}));
				return Object(i.a)(p)
			}

			function h(e) {
				const {
					postId: t,
					children: n
				} = e, s = b(t);
				return r.a.createElement(p.Provider, {
					value: s
				}, n)
			}

			function f(e) {
				const t = e.displayName || e.name;

				function n(n) {
					return r.a.createElement(p.Consumer, null, s => {
						if (!s) throw new Error(`No Post context for <${t}/>!`);
						return r.a.createElement(e, m({}, n, s))
					})
				}
				return n.displayName = `PostContext(${t})`, n
			}

			function g(e) {
				const t = e.displayName || e.name;

				function n(t) {
					const n = b(t.postId);
					return r.a.createElement(p.Provider, {
						value: n
					}, r.a.createElement(e, m({}, t, n)))
				}
				return n.displayName = `PostProvider(${t})`, n
			}
			t.c = p
		},
		"./src/reddit/contexts/User/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				i = n("./src/reddit/reducers/user/prefs/index.ts"),
				d = n("./src/reddit/selectors/user.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = r.a.createContext({
				currentUser: null,
				modModeEnabled: !1,
				nightmodeEnabled: !1,
				prefs: i.a,
				isLoggedIn: !1
			});

			function u() {
				const e = Object(o.e)(e => ({
					currentUser: Object(d.k)(e),
					modModeEnabled: e.modModeEnabled,
					nightmodeEnabled: Object(d.db)(e),
					prefs: e.user.prefs,
					isLoggedIn: Object(d.Q)(e)
				}));
				return Object(a.a)(e)
			}

			function m(e) {
				return r.a.createElement(l.Provider, {
					value: u()
				}, e.children)
			}

			function p(e) {
				const t = e.displayName || e.name;

				function n(t) {
					return r.a.createElement(l.Consumer, null, n => r.a.createElement(e, c({}, t, n)))
				}
				return n.displayName = `UserContext(${t})`, n
			}
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, n) {
			e.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "m", (function() {
				return v
			})), n.d(t, "n", (function() {
				return O
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "s", (function() {
				return C
			})), n.d(t, "r", (function() {
				return k
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "k", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "j", (function() {
				return P
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				i = n("./src/reddit/controls/Button/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = {
				role: "button",
				tabIndex: 0
			};
			var u, m, p, b;
			! function(e) {
				e.XXS = "xxsmallButtonStyles", e.XS = "xsmallButtonStyles", e.XSP = "xsmallBigPaddingButtonStyles", e.S = "smallButtonStyles", e.M = "mediumButtonStyles", e.L = "largeButtonStyles", e.XL = "xlargeButtonStyles"
			}(u || (u = {})),
			function(e) {
				e.Primary = "primary", e.Secondary = "secondary", e.Tertiary = "tertiary", e.Plain = "plain", e.PlainLink = "plainLink"
			}(m || (m = {})),
			function(e) {
				e.L = "left", e.R = "right", e.C = "center"
			}(p || (p = {})),
			function(e) {
				e.Button = "button", e.ExternalLink = "external-link", e.InternalLink = "internal-link"
			}(b || (b = {}));
			const h = e => {
					const {
						"data-redditstyle": t,
						Icon: n,
						iconClassName: s,
						iconPosition: a = p.C,
						isFullWidth: i = !1,
						isSquare: h = !1,
						children: v,
						className: O,
						kind: x = b.Button,
						priority: E = m.Primary,
						redditStyle: y,
						size: j = u.S,
						text: C,
						textClassName: k,
						...I
					} = e, S = (e => {
						let {
							baseClassName: t,
							redditStyle: n,
							dataRedditStyle: s,
							Icon: r,
							isFullWidth: a,
							isSquare: i,
							priority: c,
							size: l,
							text: u
						} = e;
						return Object(o.a)(t, d.a.Button, c && d.a[c], l && d.a[l], {
							[d.a.isFullWidth]: a,
							[d.a.isIconOnly]: !!r && !u,
							[d.a.isSquare]: i,
							[d.a.redditStyle]: !(!n && !s)
						})
					})({
						baseClassName: O,
						children: v,
						dataRedditStyle: t,
						Icon: n,
						isFullWidth: i,
						isSquare: h,
						priority: E,
						redditStyle: y,
						size: j,
						text: C
					}), w = (e => {
						let {
							children: t,
							text: n,
							Icon: s,
							iconClassName: a,
							iconPosition: i,
							priority: c,
							textClassName: l
						} = e;
						return !s && n ? r.a.createElement("span", {
							className: l
						}, n) : r.a.createElement(r.a.Fragment, null, s && (i === p.C || i === p.L) && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, a, {
								[d.a.isLeft]: i === p.L
							}),
							isFilled: c === m.Primary
						}), n && r.a.createElement("span", {
							className: Object(o.a)(d.a.Text, l)
						}, n), t && t, s && i === p.R && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, a, d.a.isRight),
							isFilled: c === m.Primary
						}))
					})({
						children: v,
						text: C,
						Icon: n,
						iconClassName: s,
						iconPosition: a,
						priority: E,
						textClassName: k
					});
					return x === b.InternalLink && (e => "to" in e)(I) ? r.a.createElement(f, c({}, l, I, {
						className: S
					}), w) : x === b.ExternalLink && (e => "href" in e)(I) ? r.a.createElement(g, c({}, l, I, {
						className: S
					}), w) : r.a.createElement(_, c({}, l, I, {
						className: S
					}), w)
				},
				f = e => r.a.createElement(a.default, e),
				g = e => r.a.createElement("a", e),
				_ = e => r.a.createElement("button", e),
				v = e => r.a.createElement(h, c({
					kind: b.ExternalLink,
					priority: m.Primary
				}, e)),
				O = e => r.a.createElement(h, c({
					kind: b.InternalLink,
					priority: m.Primary
				}, e)),
				x = e => r.a.createElement(h, c({
					kind: b.Button,
					priority: m.Primary
				}, e)),
				E = e => r.a.createElement(h, c({
					kind: b.ExternalLink,
					priority: m.Secondary
				}, e)),
				y = e => r.a.createElement(h, c({
					kind: b.InternalLink,
					priority: m.Secondary
				}, e)),
				j = e => r.a.createElement(h, c({
					kind: b.Button,
					priority: m.Secondary
				}, e)),
				C = e => r.a.createElement(h, c({
					kind: b.InternalLink,
					priority: m.Plain
				}, e)),
				k = e => r.a.createElement(h, c({
					kind: b.Button,
					priority: m.Plain
				}, e)),
				I = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						priority: m.Primary,
						className: Object(o.a)(t, d.a.DangerButtonColors)
					}, n))
				},
				S = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.GoldButtonColors)
					}, n))
				},
				w = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PremiumButtonColors)
					}, n))
				},
				T = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.ChatButton)
					}, n))
				},
				N = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.InlineTextButton)
					}, n))
				},
				P = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(h, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PlainLinkButton),
						priority: m.PlainLink
					}, n))
				};
			t.t = h
		},
		"./src/reddit/controls/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				checkboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				redditStyle: "J_lIqJrnicKj84OhD29vQ",
				disabled: "n0Me225oxRbL3aLt7kQA8"
			}
		},
		"./src/reddit/controls/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				i = n("./src/reddit/controls/Checkbox/index.m.less"),
				d = n.n(i);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isHalfCheckboxSelected ? "mixed" : e.isCheckboxSelected,
				className: e.className,
				onClick: t => {
					e.toggleCheckbox && (t.stopPropagation(), e.toggleCheckbox())
				},
				disabled: e.disabled
			}, r.a.createElement(a.a, {
				name: e.isHalfCheckboxSelected ? "checkbox_dismiss_fill" : e.isCheckboxSelected ? "checkbox_fill" : "checkbox",
				className: Object(o.a)({
					[d.a.redditStyle]: e.redditStyle,
					[d.a.disabled]: e.disabled
				}),
				style: e.checkBoxStyle
			}))
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				c = n("./src/reddit/controls/CheckboxInput/index.m.less"),
				l = n.n(c);
			t.a = e => r.a.createElement(d.a, {
				"aria-checked": !!e.value,
				"aria-disabled": e.disabled,
				"aria-labelledby": e.name,
				className: Object(o.a)(e.className, l.a.checkboxInput, e.disabled ? l.a.disabled : null),
				onClick: e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0,
				role: "checkbox"
			}, r.a.createElement("input", {
				value: e.value ? e.value.toString() : "",
				type: "hidden"
			}), e.value ? r.a.createElement(i.a, {
				className: l.a.checkboxSelected
			}) : r.a.createElement(a.a, null), e.children)
		},
		"./src/reddit/controls/CheckboxMenuItem/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxIcon: "_3Ebr0mkLD0A7HiowzExNW-",
				checkboxMenuItem: "_2eawLPCtwzvTZhWKtaUgZQ",
				expandRight: "_34Odk7t6y-rCPxPcYJa4Nw",
				postCheckboxMenuItem: "_3LyKu57c-QkPvlFvAgWop5"
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				i = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				d = n("./src/reddit/controls/CheckboxMenuItem/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = e => r.a.createElement("div", {
					className: Object(o.a)(c.a.checkboxMenuItem, e.className),
					onClick: e.onClick
				}, r.a.createElement(i.a, {
					className: c.a.expandRight
				}, r.a.createElement(a.a, {
					name: "checkbox",
					isFilled: e.isSelected,
					className: c.a.checkboxIcon
				}), e.text)),
				m = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(u, l({
						className: Object(o.a)(c.a.postCheckboxMenuItem, t)
					}, n))
				}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_21CrWSXdmd-ue61gDl6zRs",
				checkboxSelected: "_1xT_z2uw_7yX0esEUZVFwf",
				sharedIconStyles: "_1NVucoiiTLKJiKzRTPVKaW",
				checkboxLabel: "_1H6-wE3jxCdsIeXW5AMjj8",
				labelContent: "-kceiAQn0jpWOpu7qZRjD"
			}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = n("./src/reddit/controls/CheckboxWithLabel/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isSelected,
				"aria-disabled": e.disabled,
				autoFocus: e.autoFocus,
				className: Object(o.a)(c.a.checkboxLabel, e.className),
				disabled: e.disabled,
				onClick: e.onClick,
				type: "button",
				role: "checkbox"
			}, r.a.createElement("span", {
				tabIndex: -1,
				className: c.a.labelContent
			}, e.isSelected ? r.a.createElement(i.a, {
				className: c.a.checkboxSelected
			}) : r.a.createElement(a.a, {
				className: c.a.checkbox
			}), e.text))
		},
		"./src/reddit/controls/ContentType/index.m.less": function(e, t, n) {
			e.exports = {
				contentTypeIcon: "_3CquMWJ6RMh8E9D-_84AtZ"
			}
		},
		"./src/reddit/controls/ContentType/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/constants/icons.ts"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/constants/elementClassNames.ts"),
				c = n("./src/reddit/controls/ContentType/index.m.less"),
				l = n.n(c);
			const u = e => Object(o.a)(l.a.contentTypeIcon, e.className),
				m = {
					embed: a.a.embed,
					gallery: a.a.media_gallery,
					gifvideo: a.a.gif_post,
					image: a.a.image_post,
					meta: a.a.poll_post,
					rpan: a.a.video_live,
					rtjson: a.a.text_post,
					text: a.a.text_post,
					video: a.a.video_post,
					liveaudio: a.a.audio
				};

			function p(e) {
				const t = u(e),
					n = e.type && m[e.type] || a.a.link_post;
				return r.a.createElement(i.a, {
					name: n,
					className: Object(o.a)({
						[d.a]: n === a.a.link_post
					}, t)
				})
			}
		},
		"./src/reddit/controls/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				Downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				mIsInteractive: "_2fe-KdD2OM0ciaiux-G1EL",
				mIsActive: "_3emIxnIscWEPB7o5LgU_rn",
				mIsVoteable: "_3yQIOwaIuF6gn8db96Gu7y"
			}
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/lodash/throttle.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				c = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				l = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				u = n("./src/reddit/layout/row/InlineButton/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.m.less"),
				p = n.n(m),
				b = n("./src/reddit/controls/Dropdown/row.m.less"),
				h = n.n(b);

			function f() {
				return (f = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class g extends a.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = r()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, n = Object(i.a)(h.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? a.a.createElement(d.a, f({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href,
						disabled: e.disabled
					}), e.children && a.a.createElement("span", {
						className: n
					}, e.children), a.a.createElement("span", {
						className: Object(i.a)(h.a.text, e.textClassName)
					}, e.displayText)) : a.a.createElement(u.a, f({}, t, {
						id: e.id,
						className: e.className,
						disabled: e.disabled,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: r()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? a.a.createElement("div", null, e.children) : a.a.createElement("span", {
						className: n
					}, e.children)), e.displayText && a.a.createElement("span", {
						className: Object(i.a)(h.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && a.a.createElement(l.a, {
						className: h.a.checkmark
					}), e.showDropdownTriangle && a.a.createElement(c.a, {
						className: p.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				let {
					className: t,
					...n
				} = e;
				const s = Object(i.a)(h.a.row, t, {
					[h.a.mIsInteractive]: !n.noHover,
					[h.a.mIsSelected]: n.isSelected,
					[h.a.topics]: n.isTopicsStyle
				});
				return a.a.createElement(g, f({
					className: s
				}, n))
			}
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/domUtils/index.ts"),
				i = n("./src/reddit/constants/zIndex.ts"),
				d = n("./src/reddit/controls/Dropdown/index.m.less"),
				c = n.n(d);
			class l extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(a.a)(this.props.tooltipId)
				}
				render() {
					const e = this.props,
						t = {};
					return (e.isFixed || e.isOverlay) && (e.isFixed && (t.position = "fixed"), e.isOverlay && (t.zIndex = e.isFixed ? i.d + 1 : i.c)), r.a.createElement("div", {
						className: Object(o.a)(c.a.dropdown, e.className),
						id: this.props.id,
						ref: e => this.ref = e,
						role: "menu",
						style: {
							...t,
							...e.style
						},
						tabIndex: -1,
						onScroll: e.onScroll
					}, e.children)
				}
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				modNotes: "sK8_uuNiAqPNlw-HoD2HG",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownMenu: "_1PLoXiZH4WKzHTfmYIt34X",
				selector: "apk_M-7ks6NcaiMN8cotM",
				selectorContent: "Ot99igbaJ5id3P1tw6wow",
				disabled: "FVIZ8GUq5tMGZlJ7y28ll",
				compact: "_1qaMsHCBrTmejbIUPjsRVI",
				caretDown: "_2i4dyr-iTBOmkZ4fL_M70P",
				topics: "qWs3cMcSjquK-OXl-9jH5",
				loadingIcon: "_3WxhmmhQ3cYt1J7mtfcoKG",
				menuItems: "_3ssvFhIB2HAXL261eWf7G0",
				isClosed: "_3sZzbLftdYnJNnJ7m7ImmO",
				menuOption: "_1Qm1phX3yfiJHnjgi_O_9V",
				buttonIcon: "_1J0h3Uv7HEaVZiJLcCUlQw"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/DropdownSelector/index.m.less"),
				a = n.n(o),
				i = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/Dropdown/Row.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/fonts/index.tsx");
			const u = e => {
				e.preventDefault()
			};
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.dropdownButton = r.a.createRef(), this.menuItems = r.a.createRef(), this.containerRef = r.a.createRef(), this.state = {
						isOpen: !1
					}, this.handleDocumentClick = e => {
						this.containerRef && this.containerRef.current && (this.containerRef.current.contains(e.target) || this.setState({
							isOpen: !1
						}))
					}, this.onSelectOption = (e, t, n) => {
						const {
							onSelect: s
						} = this.props;
						e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopPropagation(), s(t), n && this.dropdownButton.current && this.dropdownButton.current.focus(), this.setState({
							isOpen: !1
						})
					}, this.onOptionClick = (e, t) => {
						this.onSelectOption(e, t)
					}, this.handleDropdownClick = e => {
						e.preventDefault(), e.stopPropagation(), this.props.onOpen && this.props.onOpen(), this.setState({
							isOpen: !this.state.isOpen
						})
					}, this.handleDropdownBlur = e => {
						let t = !1;
						if (e.relatedTarget === this.dropdownButton.current) t = !0;
						else {
							if (!this.menuItems.current) return;
							const n = this.menuItems.current.getElementsByClassName(a.a.menuOption);
							for (let s = 0; s < n.length; s++) e.relatedTarget === n[s] && (t = !0)
						}
						this.setState({
							isOpen: t
						})
					}, this.handleDropdownKeyDown = e => {
						if (!this.state.isOpen && [40, 32, 13].includes(e.keyCode)) return e.preventDefault(), void this.setState({
							isOpen: !0
						}, this.focusOnFirstOption);
						40 === e.keyCode && (e.preventDefault(), this.focusOnFirstOption()), 27 === e.keyCode && this.state.isOpen && (e.stopPropagation(), e.nativeEvent.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), this.setState({
							isOpen: !1
						}))
					}, this.handleOptionKeyDown = (e, t) => {
						if (32 === e.keyCode || 13 === e.keyCode) this.onSelectOption(e, t, !0);
						else if (38 === e.keyCode || 40 === e.keyCode) {
							if (e.preventDefault(), !this.menuItems.current) return;
							const t = this.menuItems.current.getElementsByClassName(a.a.menuOption);
							for (let n = 0; n < t.length; n++) t[n] === e.target && (38 === e.keyCode && n > 0 && t[n - 1].focus(), 40 === e.keyCode && n < t.length - 1 && t[n + 1].focus())
						}
					}
				}
				componentDidMount() {
					document.body.addEventListener("click", this.handleDocumentClick, !1)
				}
				componentWillUnmount() {
					document.body.removeEventListener("click", this.handleDocumentClick, !1)
				}
				focusOnFirstOption() {
					if (!this.menuItems.current) return;
					const e = this.menuItems.current.getElementsByClassName(a.a.menuOption);
					e.length && e[0].focus()
				}
				getDropdownMenuItems() {
					const {
						options: e,
						showSelectedCheckmark: t,
						isTopicsStyle: n,
						menuOptionClassName: s
					} = this.props;
					return e.map((e, o) => r.a.createElement(d.b, {
						key: o + e.displayText,
						className: Object(i.a)(a.a.menuOption, s, {
							[a.a.topics]: n
						}),
						noIcon: Boolean(e.icon),
						onKeydown: t => this.handleOptionKeyDown(t, e),
						onMouseDown: t => this.onOptionClick(t, e),
						onBlur: this.handleDropdownBlur,
						showSelectedCheckmark: t,
						isSelected: void 0 !== e.isSelected ? e.isSelected : void 0,
						isTopicsStyle: n
					}, e.icon && e.icon, e.displayText))
				}
				render() {
					const {
						buttonClassName: e,
						className: t,
						displayText: n,
						isCompactStyle: s,
						isTopicsStyle: o,
						menuItemsClassName: d,
						name: m,
						isSaving: p,
						buttonIcon: b,
						disabled: h
					} = this.props, {
						isOpen: f
					} = this.state;
					return r.a.createElement("div", {
						ref: this.containerRef,
						id: this.props.id,
						className: Object(i.a)(a.a.dropdownMenu, t, {
							[a.a.topics]: o
						})
					}, r.a.createElement("button", {
						onClick: h ? void 0 : this.handleDropdownClick,
						className: Object(i.a)(e, a.a.selector, {
							[a.a.compact]: s
						}, {
							[a.a.topics]: o
						}, {
							[a.a.disabled]: h
						}),
						name: m,
						role: "menu",
						ref: this.dropdownButton,
						onBlur: h ? void 0 : this.handleDropdownBlur,
						onKeyDown: h ? void 0 : this.handleDropdownKeyDown
					}, r.a.createElement("span", {
						className: a.a.selectorContent,
						tabIndex: -1
					}, b && r.a.createElement("span", {
						className: a.a.buttonIcon
					}, b), n), h ? null : p ? r.a.createElement(c.a, {
						sizePx: 8,
						className: a.a.loadingIcon
					}) : r.a.createElement(l.a, {
						name: "caret_down"
					})), r.a.createElement("div", {
						className: Object(i.a)(a.a.menuItems, d, {
							[a.a.topics]: o,
							[a.a.isClosed]: !f
						}),
						onMouseDown: u,
						ref: this.menuItems
					}, !h && f && this.getDropdownMenuItems()))
				}
			}
			t.b = m
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			})), n.d(t, "c", (function() {
				return x
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/uniqueId.js"),
				o = n.n(r),
				a = n("./node_modules/raf/index.js"),
				i = n.n(a),
				d = n("./node_modules/react/index.js"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/layout/row/Inline/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				h = n.n(b);
			var f = Object(u.a)(e => {
					const {
						children: t,
						title: n
					} = e;
					return c.a.createElement("div", {
						className: h.a.wrapper
					}, c.a.createElement(p.a, {
						className: h.a.titleRow
					}, n), c.a.createElement("div", {
						className: h.a.detailsContainer
					}, t), c.a.createElement(p.a, {
						className: h.a.buttonRow
					}, c.a.createElement(m.l, {
						className: h.a.confirmButton,
						onClick: e.onConfirmed
					}, s.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				g = n("./src/reddit/controls/ErrorText/index.m.less"),
				_ = n.n(g);
			class v extends c.a.Component {
				constructor(e) {
					super(e), this.spanRef = c.a.createRef(), this.toggleModal = () => {
						this.setState({
							isModalOpen: !this.state.isModalOpen
						})
					}, this.state = {
						textHasOverflowed: !1,
						modalId: `ErrorTextModal--${o()()}`,
						isModalOpen: !1
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					i()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						className: t,
						errorModalBody: n,
						errorModalTitle: r = s.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: o = s.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						textHasOverflowed: a,
						isModalOpen: i
					} = this.state;
					return c.a.createElement("div", {
						className: Object(l.a)(_.a.wrapper, t)
					}, c.a.createElement("span", {
						className: _.a.description,
						ref: this.spanRef
					}, e), a && c.a.createElement("span", {
						className: _.a.moreText,
						onClick: this.toggleModal
					}, o), i && c.a.createElement(f, {
						onConfirmed: this.toggleModal,
						title: r
					}, n || e))
				}
			}
			const O = e => {
					const {
						className: t,
						errorClassName: n,
						errorModalTitle: s,
						fallbackMessage: r,
						messages: o = []
					} = e, a = o.length ? o : r ? [r] : [];
					return a.length ? c.a.createElement("div", {
						className: t
					}, a.map((e, t) => c.a.createElement(v, {
						className: n,
						errorModalTitle: s,
						key: t
					}, e))) : null
				},
				x = e => c.a.createElement(O, {
					fallbackMessage: s.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = v
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/flow.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-dnd/lib/index.js"),
				d = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				c = n("./src/reddit/helpers/dragDropContext/index.ts");
			const l = d.NativeTypes.FILE,
				u = r()(Object(i.DropTarget)(l, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const n = t.getItem();
						n.files && e.onDrop(n.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), c.a);
			class m extends a.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(a.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = u(m)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/controls/ErrorText/index.tsx"),
				d = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				c = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				l = n("./src/reddit/controls/FormFields/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = a.a.input("input", u.a),
				b = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				h = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						className: a,
						isInvalid: i,
						...d
					} = e;
					const c = void 0 !== d.value && "" !== d.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputWrapper, a, {
							[u.a.mIsInvalid]: i
						}),
						onClick: b
					}, r.a.createElement(p, m({
						"aria-invalid": i,
						innerRef: s
					}, d)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: c
						})
					}, t), n)
				},
				f = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						isInvalid: a,
						className: i,
						redditStyle: d,
						...c
					} = e;
					const l = void 0 !== c.value && "" !== c.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputMovingLabelWrapper, i, {
							[u.a.mIsInvalid]: a,
							[u.a.mIsRedditStyle]: d
						}),
						onClick: b
					}, r.a.createElement(p, m({
						innerRef: s
					}, c)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: l
						})
					}, t), n)
				},
				g = e => r.a.createElement("div", {
					className: Object(o.a)(u.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", r.a.createElement(d.a, {
					className: u.a.plus
				}));
			var _;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(_ || (_ = {}));
			class v extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: _.ADD
						})
					}, this.updateValue = (e, t) => {
						const n = this.props.values.slice();
						n[t] = e.target.value, this.props.onChange(n)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							n = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: _.REMOVE,
							value: n,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: n,
						placeholder: s,
						errors: o = []
					} = this.props;
					return e.map((e, a) => r.a.createElement(h, {
						inputRef: e => this.setInputRef(e, a),
						isInvalid: !!o[a],
						disabled: t,
						type: "text",
						label: n,
						onChange: e => this.updateValue(e, a),
						placeholder: s,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, r.a.createElement("div", {
						className: u.a.trashContainer,
						onClick: () => this.removeValue(a)
					}, r.a.createElement(c.b, {
						className: u.a.trash
					})), !!o[a] && r.a.createElement(i.b, {
						className: u.a.errorText
					}, o[a])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: n,
						maxLength: s,
						addValueText: a,
						disabled: i
					} = this.props;
					this.focusedInput = null;
					const d = !(!!s && n.length >= s) && !i;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.multiInputWrapper, e)
					}, t && d && r.a.createElement(g, {
						onClick: this.addValue,
						text: a
					}), this.renderFields(), !t && d && r.a.createElement(g, {
						onClick: this.addValue,
						text: a
					}))
				}
			}
		},
		"./src/reddit/controls/ImageDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				imageDisplay: "_1OSym2TYADlQNpSDWNxtjB"
			}
		},
		"./src/reddit/controls/ImageDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/ImageDisplay/index.m.less"),
				i = n.n(a);
			t.a = e => {
				let {
					backgroundImage: t,
					children: n,
					className: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(i.a.imageDisplay, s),
					style: {
						backgroundImage: `url('${t}')`
					},
					children: n
				})
			}
		},
		"./src/reddit/controls/ImageInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			class o extends r.a.Component {
				constructor(e) {
					super(e), this.onFileInput = e => {
						const t = e.currentTarget.files,
							n = this.props.multiple ? [...t] : t[0];
						this.props.onChange(n), this.setState(() => ({
							value: n
						}))
					}, this.state = {
						value: e.value || ""
					}
				}
				static getDerivedStateFromProps(e, t) {
					return {
						value: t.value || e.value || ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = "string" == typeof t.value ? t.value : "", s = "object" == typeof t.value ? t.value : null, o = n || s;
					return r.a.createElement("div", {
						className: e.className
					}, n && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						readOnly: !0,
						type: "text",
						value: n,
						tabIndex: e.tabIndex
					}), (!o || e.multiple || void 0 !== e.isPending && !e.isPending) && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						type: "file",
						onChange: this.onFileInput,
						accept: "image/x-png,image/jpeg",
						multiple: e.multiple || !1,
						tabIndex: e.tabIndex
					}))
				}
			}
		},
		"./src/reddit/controls/Input/ModalInput.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/controls/Input/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.handleKeyDown = e => {
						let {
							keyCode: t
						} = e;
						t === d.a.Escape && this.props.closeModal()
					}
				}
				render() {
					const {
						className: e,
						closeModal: t,
						...n
					} = this.props;
					return r.a.createElement("input", u({
						className: Object(a.a)(l.a.input, e),
						onKeyDown: this.handleKeyDown
					}, n))
				}
			}
			t.a = Object(o.b)(null, {
				closeModal: i.f
			})(m)
		},
		"./src/reddit/controls/Input/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3eoXtlBWKbkFYoOHUIcIgK"
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/index.m.less"),
				o = n.n(r);
			t.a = s.a.input("input", o.a)
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "default", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/helpers/path/index.ts"),
				d = n("./src/reddit/controls/InternalLink/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function u(e) {
				let {
					children: t,
					className: n,
					disabled: s,
					replace: d,
					to: u,
					...m
				} = e;
				return s ? r.a.createElement("span", {
					className: Object(a.a)(c.a.disabledLink, n)
				}, t) : ("string" == typeof u && (u = Object(i.b)(u)), r.a.createElement(o.a, l({
					className: n,
					to: u
				}, m), t))
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.m.less": function(e, t, n) {
			e.exports = {
				invisibleText: "_1RIl585IYPW6cmNXwgRz0J"
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InvisibleScreenReaderText/index.m.less"),
				o = n.n(r);
			t.a = s.a.span("invisibleText", o.a)
		},
		"./src/reddit/controls/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_3LwT7hgGcSjmJ7ng7drAuq",
				spin: "ibDwUVR1CAykturOgqOS5",
				mCentered: "_2qr28EeyPvBWAsPKl-KuWN"
			}
		},
		"./src/reddit/controls/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/LoadingIcon/index.m.less"),
				i = n.n(a);
			t.a = e => {
				let {
					center: t,
					className: n,
					sizePx: s = 10
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(i.a.loadingIcon, n, {
						[i.a.mCentered]: t
					}),
					style: {
						"--sizePx": `${s}px`
					},
					"data-testid": "LoadingIcon"
				})
			}
		},
		"./src/reddit/controls/MetaData/index.m.less": function(e, t, n) {
			e.exports = {
				metaText: "_2ETuFsVzMBxiHia6HfJCTQ"
			}
		},
		"./src/reddit/controls/MetaData/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				a = n("./src/lib/lessComponent.tsx"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				d = (n("./src/lib/timeAgo/index.ts"), n("./src/reddit/controls/MetaData/index.m.less")),
				c = n.n(d);
			const l = a.a.span("metaText", c.a),
				u = e => o.a.createElement(l, e, "  "),
				m = e => {
					let {
						isScoreHidden: t,
						score: n,
						useUpvotes: r,
						...a
					} = e;
					const d = Object(i.b)(n),
						c = s.fbt._({
							"*": "{number} upvotes",
							_1: "1 upvote"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "2L3T21"
						}),
						u = t ? s.fbt._("Score hidden", null, {
							hk: "SDk6B"
						}) : r ? c : s.fbt._({
							"*": "{number} points",
							_1: "1 point"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "gf67v"
						});
					return o.a.createElement(l, a, u)
				},
				p = e => o.a.createElement(l, null, s.fbt._({
					"*": "{number} comments",
					_1: "1 comment"
				}, [s.fbt._plural(e, "number", Object(i.b)(e))], {
					hk: "3bVMk9"
				}))
		},
		"./src/reddit/controls/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return S
			})), n.d(t, "c", (function() {
				return w
			}));
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/query-string/index.js"),
				a = n.n(o),
				i = n("./node_modules/react/index.js"),
				d = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts");
			var m = (e, t) => t ? Object(u.a)(e, {
				user_id: t
			}) : e;
			var p = n("./src/lib/opener/index.ts"),
				b = n("./src/lib/redditId/index.ts"),
				h = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/constants/adEvents.ts"),
				g = n("./src/reddit/helpers/getVendorMetadata.ts"),
				_ = n("./src/reddit/helpers/pixels.ts"),
				v = n("./src/reddit/helpers/trackers/ads.ts"),
				O = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				x = n("./src/reddit/selectors/posts.ts"),
				E = n("./src/reddit/selectors/telemetry.ts"),
				y = n("./src/reddit/selectors/user.ts");

			function j() {
				return (j = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = Object(l.a)(y.a, y.k, (e, t) => {
					let {
						isSponsored: n,
						postId: s
					} = t;
					return n && s ? Object(x.b)(e, s) : null
				}, x.G, E.d, (e, t, n, s, r) => ({
					allowClickTracking: e,
					basePixelMetadata: n,
					userId: t ? Object(b.a)(t.id) : null,
					post: s,
					pageType: r.pageType
				})),
				k = Object(c.b)(C, e => ({
					fireAdPixelsOfType: (t, n) => e(Object(h.z)(t, n)),
					recordClick: (t, n, s) => {
						const r = t.events.filter(e => {
							let {
								type: t,
								url: n
							} = e;
							return t === f.a.Click && Object(_.b)(n)
						});
						Object(_.c)(r), e(Object(h.p)(String(n), {
							postId: t.id,
							vendorMetadata: s
						}))
					}
				})),
				I = (e, t, n, s) => {
					const r = t.outboundUrlExpiration && t.outboundUrlExpiration > Date.now();
					s && t.outboundUrl && r && (e.href = m(t.outboundUrl, n), e.href = function(e) {
						return Object(u.a)(e, {
							web_redirect: "true"
						})
					}(e.href))
				},
				S = (e, t, n) => {
					let s, r = null;
					if (e && t && /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(n)) {
						r = Object(g.a)(e, t, f.a.Click);
						const {
							url: o,
							query: i
						} = a.a.parseUrl(n);
						s = a.a.stringifyUrl({
							url: o,
							query: {
								...i,
								...r
							}
						})
					} else s = n;
					return {
						url: s,
						metadata: r
					}
				},
				w = (e, t, n) => {
					const s = S(t, n, e.href);
					return e.href = s.url, s.metadata
				},
				T = e => {
					let {
						isSponsored: t,
						source: n
					} = e;
					return !!(t && (null == n ? void 0 : n.outboundUrl))
				},
				N = k(e => {
					const t = Object(i.useRef)(null),
						n = Object(O.a)(),
						{
							allowClickTracking: s,
							basePixelMetadata: o,
							commentId: a,
							fireAdPixelsOfType: c,
							href: l,
							isSponsored: u,
							pageType: m,
							post: b,
							postId: h,
							recordClick: g,
							source: _,
							sourceElement: x,
							userId: E
						} = e;
					let y = r()(e, ["allowClickTracking", "basePixelMetadata", "fireAdPixelsOfType", "isSponsored", "postId", "post", "recordClick", "commentId", "source", "sourceElement", "userId", "pageType"]);
					const C = _ && _.outboundUrl && u ? _.outboundUrl : l;
					return y = {
						...y,
						href: C,
						rel: u ? p.b : p.a,
						target: p.d.BLANK
					}, !_ || (e => {
						const {
							outboundUrlCreated: t,
							outboundUrlReceived: n
						} = e;
						return !(!t || !n) && (t > n + 3e5 || t < n - 36e5)
					})(_) ? d.a.createElement("a", j({}, y, {
						onClick: () => n(l, x, a, h)
					})) : d.a.createElement("a", j({}, y, {
						onMouseDown: n => {
							if (!T(e)) return !(1 !== n.button && 2 !== n.button && !n.ctrlKey) || void I(n.currentTarget, _, E, s);
							t.current = w(n.currentTarget, h, o)
						},
						onClick: () => {
							b && (T(e) && (g(b, f.a.Click, t.current), Object(v.a)(b, m)), c(b, f.a.Click), n(l, x, a, h))
						},
						onMouseLeave: e => {
							u || ((e, t) => {
								e.href = t
							})(e.currentTarget, C)
						},
						onTouchStart: e => I(e.currentTarget, _, E, s),
						"data-testid": "outbound-link"
					}))
				});
			t.b = N
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/constants/elementClassNames.ts"),
				o = n("./src/reddit/controls/OutboundLink/index.tsx"),
				a = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				i = n.n(a);
			t.a = s.a.wrapped(o.b, "styledOutboundLink", {
				styledOutboundLink: `${i.a.styledOutboundLink} ${r.l}`
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.m.less": function(e, t, n) {
			e.exports = {
				radioOption: "_2e6fJknJ4noSygWYov8-F1",
				radioOff: "_1lzSnSABNXX12WerTnwqI3",
				radioOn: "_3PYsg_uRJ6AGptv-hi7kqu"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/constants/keycodes.ts"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/RadioInput/RadioOption/index.m.less"),
				u = n.n(l);
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.ref = null, this.onKeyPress = e => {
						const {
							props: t
						} = this;
						t.disabled || e.key !== a.b.Enter && e.key !== a.b.Space || (t.onClick && t.onClick(t.value), e.preventDefault())
					}
				}
				componentDidUpdate(e) {
					this.props.selected && !e.selected && this.ref && this.ref.focus()
				}
				render() {
					const {
						props: e
					} = this;
					return e.hidden ? null : r.a.createElement(c.a, {
						"aria-checked": e.selected,
						className: Object(o.a)(e.className, u.a.radioOption),
						innerRef: e => this.ref = e,
						onClick: e.disabled ? void 0 : e.onClick,
						onKeyPress: this.onKeyPress,
						role: "radio",
						tabIndex: e.tabIndex
					}, e.showButton && (e.selected ? r.a.createElement(d.a, {
						className: u.a.radioOn,
						role: "presentation"
					}) : r.a.createElement(i.a, {
						className: u.a.radioOff,
						role: "presentation"
					})), e.children)
				}
			}
			t.a = m
		},
		"./src/reddit/controls/RadioInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/keycodes.ts");
			class a extends r.a.Component {
				constructor(e) {
					super(e), this.handleClick = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props;
						t || this.state.value !== e && (n(e), this.setState({
							value: e
						}))
					}, this.getValues = () => {
						const e = [];
						return r.a.Children.forEach(this.props.children, t => {
							t.props.hidden || t.props.disabled || e.push(t.props.value)
						}), e
					}, this.onKeyDown = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props, {
							value: s
						} = this.state;
						if (t) return;
						const r = e.key === o.b.ArrowUp,
							a = e.key === o.b.ArrowDown;
						if (r || a) {
							const t = this.getValues();
							if (!t.length) return;
							const o = s ? t.indexOf(s) : 0,
								a = t[((r ? o - 1 : o + 1) + t.length) % t.length];
							n(a), this.setState({
								value: a
							}), e.preventDefault()
						}
					}, this.state = {
						value: e.value || null
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.value !== this.props.value && this.setState({
						value: e.value || null
					})
				}
				render() {
					const {
						props: e
					} = this, {
						value: t
					} = this.state;
					return r.a.createElement("div", {
						"aria-label": e.name,
						className: e.className,
						role: "radiogroup",
						onKeyDown: this.onKeyDown
					}, r.a.createElement("input", {
						disabled: e.disabled,
						type: "hidden",
						value: t || ""
					}), r.a.Children.map(e.children, (n, s) => {
						const o = 0 === s,
							a = n.props.value === t,
							i = null !== t ? a ? 0 : -1 : o ? 0 : -1;
						return r.a.cloneElement(n, {
							disabled: e.disabled,
							onClick: e => this.handleClick(n.props.value),
							selected: a,
							tabIndex: i
						})
					}))
				}
			}
		},
		"./src/reddit/controls/Score/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_1rZYMD_4xY3gRcSS3p8ODO",
				dot: "uFieChpcVxrPI9VvCKqZu",
				viewCount: "_3bAGP2FKe97ijgBAGQOYsk"
			}
		},
		"./src/reddit/controls/Score/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./node_modules/react/index.js"),
				d = n.n(i),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/components/CountAnimation/index.tsx"),
				m = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				p = n("./src/reddit/components/PostContent/ViewCount.tsx"),
				b = n("./src/reddit/constants/colors.ts"),
				h = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				f = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				g = n("./src/reddit/hooks/useInfoTextTooltip.ts"),
				_ = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				v = n("./src/reddit/models/Vote/index.ts"),
				O = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				x = n("./src/reddit/selectors/meta.ts"),
				E = n("./src/reddit/selectors/posts.ts"),
				y = n("./node_modules/reselect/es/index.js"),
				j = n("./src/reddit/controls/Score/index.m.less"),
				C = n.n(j);
			const k = {
					placement: "right"
				},
				I = e => e.voteState === v.a.downvoted ? Object(_.a)(e).voteText.downvote : e.voteState === v.a.upvoted ? Object(_.a)(e).voteText.upvote : Object(f.a)(Object(h.a)(e)),
				S = Object(y.c)({
					locale: e => Object(x.j)(e),
					post: (e, t) => {
						let {
							shouldShowUpvoteRatioOnHover: n,
							postId: s
						} = t;
						if (n && s) return Object(E.G)(e, {
							postId: s
						})
					}
				}),
				w = () => 0,
				T = Object(c.b)(S),
				N = Object(o.a)(e => {
					const t = {
							color: e.light ? b.a.lightboxHeaderText : I(e)
						},
						{
							score: n,
							postId: o = "",
							locale: h,
							isVoteCountAnimation: f,
							isCountAnimShadowTestEnabled: _,
							shouldShowUpvoteRatioOnHover: v,
							post: x
						} = e,
						E = Object(c.d)(),
						y = null == h ? void 0 : h.startsWith("en"),
						j = e.isScoreHidden ? y ? s.fbt._("Vote", null, {
							hk: "2TMson"
						}) : d.a.createElement("span", {
							className: C.a.dot
						}, "") : Object(a.b)(n),
						S = Object(i.useCallback)(e => {
							const {
								voteCountChange: t
							} = e.subscribe.data;
							0 !== t && E(Object(l.I)({
								postId: o,
								delta: t
							}))
						}, [E, o]),
						T = Object(i.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "VOTE_COUNT_UPDATE",
									postID: o
								}
							}
						}),
						N = !e.isScoreHidden && f && n < O.a,
						P = Object(g.a)(k),
						R = n < 0 ? 0 : n;
					return d.a.createElement("div", {
						className: Object(r.a)(C.a.score, e.className),
						style: e.disableInlineColor ? void 0 : t,
						onMouseEnter: v ? P.show : void 0,
						onMouseLeave: v ? P.hide : void 0,
						ref: v ? P.target.ref : void 0
					}, (N || _) && d.a.createElement(d.a.Fragment, null, d.a.createElement(u.b, {
						initialDisplayCount: R,
						countToUpperBound: R,
						initialDelay: w,
						subsequentRecurringDelay: w,
						incrementDelta: w,
						shouldDisjointAnimation: !0,
						postId: o,
						featureName: u.a.Vote,
						queryKey: "postVoteCount",
						queryVariables: T.current,
						onDataCB: S,
						isLoadTestOnly: _ && !N
					})), !N && j, v && x && d.a.createElement(m.a, P, d.a.createElement(p.a, {
						className: C.a.viewCount,
						post: x,
						showViewCount: !1
					})))
				});
			t.a = T(N)
		},
		"./src/reddit/controls/Select/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "DuuuuIp9EubfvJyrdxytL",
				wrapper: "DuuuuIp9EubfvJyrdxytL",
				Caret: "_8fOXBcWxu_c3tlrAKMR3R",
				caret: "_8fOXBcWxu_c3tlrAKMR3R",
				Inner: "_3-_epznhOfLDNH3-plYM6l",
				inner: "_3-_epznhOfLDNH3-plYM6l",
				active: "wFEhEmBm9HI3jG6QDUnaw",
				redditStyle: "_2PDExzXmSTOdxzNjRB1Pww"
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/helpers/dragDropContext/index.ts"),
				a = n("./node_modules/lodash/flow.js"),
				i = n.n(a),
				d = n("./node_modules/react-dnd/lib/index.js");
			class c extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? i()(e.connectDropTarget, e.connectDragSource)(r.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var l = i()(Object(d.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const n = t.getDropResult();
						e.onDrop(e.id, n.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(d.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const n = t.getItem();
					return e.id !== n.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(c);
			class u extends r.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(n => {
							const s = n.values.slice(),
								r = s.indexOf(e),
								o = s.splice(r, 1)[0];
							let a = s.indexOf(t);
							return r <= a && (a += 1), s.splice(a, 0, o), this.props.onDrop(e, t, s), {
								values: s
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: n,
						render: s
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, this.state.values.map((e, o) => r.a.createElement(l, {
						id: e,
						key: t && t(e, o),
						index: o,
						render: s,
						onDrop: this.onDrop,
						onClick: n
					})))
				}
			}
			t.a = Object(o.a)(u)
		},
		"./src/reddit/controls/TextButton/index.m.less": function(e, t, n) {
			e.exports = {
				textButton: "qYzY57HWQ8W424hj3s10-"
			}
		},
		"./src/reddit/controls/TextButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/TextButton/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("button", {
				children: e.children,
				className: Object(o.a)(i.a.textButton, e.className),
				disabled: e.disabled,
				onClick: e.onClick
			})
		},
		"./src/reddit/controls/ToggleSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				toggleDisplay: "_2FKpII1jz0h6xCAw1kQAvS",
				toggleSwitch: "_2e2g485kpErHhJQUiyvvC2",
				redditStyle: "_3kUvbpMbR21zJBboDdBH7D",
				mActive: "_1L5kUnhRYhUJ4TkMbOTKkI",
				mDisabled: "_3clF3xRMqSWmoBQpXv8U5z",
				xs: "_1asGWL2_XadHoBuUlNArOq",
				s: "_1hku5xiXsbqzLmszstPyR3",
				m: "_10hZCcuqkss2sf5UbBMCSD",
				l: "_1fCdbQCDv6tiX242k80-LO",
				xl: "_2Jp5Pv4tgpAsTcnUzTsXgO"
			}
		},
		"./src/reddit/controls/ToggleSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				i = n("./src/reddit/controls/ToggleSwitch/index.m.less"),
				d = n.n(i);
			t.a = Object(s.memo)(Object(s.forwardRef)((e, t) => {
				const n = e.size || a.d.XS;
				return r.a.createElement("button", {
					"aria-checked": e.on,
					className: Object(o.a)(d.a.toggleSwitch, e.className, d.a[n], {
						[d.a.mActive]: e.on && !e.disabled || e.forceOn && e.on,
						[d.a.mDisabled]: e.disabled,
						[d.a.redditStyle]: e.redditStyle
					}),
					style: e.on && !e.disabled && e.activeColorOverride ? {
						backgroundColor: e.activeColorOverride
					} : void 0,
					id: e.id,
					role: "switch",
					tabIndex: e.tabIndex,
					type: "button",
					onClick: () => !e.disabled && e.onToggle && e.onToggle(),
					ref: t
				}, r.a.createElement("div", {
					className: d.a.toggleDisplay
				}))
			}))
		},
		"./src/reddit/controls/Typography/index.m.less": function(e, t, n) {
			e.exports = {
				heading1: "_37JeV292IJA7_x1qej_-2H",
				heading2: "p13k-tsMcatGBlVpJBZmw",
				heading3: "_1nHvvYpmn7q9eWDAGzKcce",
				heading4: "_1-rwUWsB5F8WmYI8F66dai",
				heading5: "_22RKdGqihAj6MFumW6DuRV",
				heading6: "_4xqrI_N1UdqsK9E1RSisG",
				body1: "_2HJOIn4SJm4z1NeCv_hNFu",
				body2: "_3ImIPX9rfoPmUrZ1R8KGqS",
				actionFont: "_3uShGanwyVFBaTiPMFzfAC",
				metadata: "_2nyJGeaFJbXTqTh9OGwxfu",
				metadata3: "_3BIqvjJkJKZfH4vtC11dGF"
			}
		},
		"./src/reddit/controls/Typography/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Typography/index.m.less"),
				o = n.n(r);
			s.a.h1("heading1", o.a), s.a.h2("heading2", o.a), s.a.h3("heading3", o.a), s.a.h4("heading4", o.a);
			const a = s.a.h5("heading5", o.a),
				i = (s.a.h6("heading6", o.a), s.a.p("body1", o.a), s.a.p("body2", o.a)),
				d = (s.a.p("actionFont", o.a), s.a.p("metadata", o.a));
			s.a.p("metadata3", o.a)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InternalLink/index.tsx"),
				o = n("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				a = n.n(o);
			t.a = s.a.wrapped(r.default, "unstyledInternalLink", a.a)
		},
		"./src/reddit/controls/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				Upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				mIsInteractive: "qW0l8Af61EP35WIG6vnGk",
				mIsActive: "Z3lT0VGlALek4Q9j0ZQCr",
				mIsVoteable: "_3edNsMs0PNfyQYofMNVhsG"
			}
		},
		"./src/reddit/customMiddleware/recentSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/chat/customMiddleware/noop.ts"),
				r = n("./src/lib/cache/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/localStorageAvailable/index.ts"),
				i = n("./src/reddit/actions/recentSubreddits/constants.ts");
			const d = Object(r.c)(o.q.RECENT_SUBREDDITS, "recent_subreddits"),
				c = () => Object(a.a)() && Object(r.b)(d) || [];
			t.a = e => "undefined" == typeof window ? s.a : e => t => {
				const n = e(t);
				switch (t.type) {
					case i.e: {
						const e = c() || [],
							n = {
								...t.payload,
								lastVisited: Date.now()
							},
							{
								id: s
							} = n;
						if (s) {
							const t = e.findIndex(e => e.id === s); - 1 !== t && e.splice(t, 1), e.unshift(n), e.splice(i.c), Object(r.d)(d, e, o.pb)
						}
						break
					}
				}
				return n
			}
		},
		"./src/reddit/endpoints/comment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return _
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "k", (function() {
				return S
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "d", (function() {
				return P
			}));
			var s = n("./src/config.ts"),
				r = n("./src/redditGQL/operations/ModApprove.json"),
				o = n("./src/redditGQL/operations/ModRemove.json"),
				a = n("./src/redditGQL/operations/UpdateCommentDistinguishState.json"),
				i = n("./src/redditGQL/operations/UpdateCommentStickyState.json"),
				d = n("./src/redditGQL/types.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				h = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				f = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				g = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const _ = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/save`),
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				v = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unsave`),
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				O = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/lock`),
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unlock`),
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				E = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/approve`),
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(u.a)(e, {
					...r,
					variables: {
						input: {
							id: t
						}
					}
				}),
				j = (e, t, n) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/remove`),
					method: c.jb.POST,
					data: {
						id: t,
						spam: n
					}
				}),
				C = (e, t, n) => Object(u.a)(e, {
					...o,
					variables: {
						input: {
							id: t,
							isSpam: n
						}
					}
				}),
				k = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/ignore_reports`,
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				I = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/unignore_reports`,
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				S = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/show_comment`,
					method: c.jb.POST,
					data: {
						id: t
					}
				}),
				w = (e, t, n, r) => {
					let o = Object(b.a)(Object(g.a)(Object(f.a)(`${s.a.gatewayUrl}/desktopapi/v1/morecomments/${t}`)));
					return r && (o = Object(h.a)(o)), Object(l.a)(e, {
						data: n,
						endpoint: o,
						method: c.jb.POST,
						type: "json",
						traceRequestName: "more_comments"
					})
				},
				T = {
					[c.G.NONE]: d.i.None,
					[c.G.MODERATOR]: d.i.ModDistinguished,
					[c.G.ADMIN]: d.i.AdminDistinguished,
					[c.G.ALUMNI_ADMIN]: d.i.AlumniDistinguished
				};

			function N(e, t, n) {
				const s = function(e, t) {
					return {
						input: {
							commentId: e,
							distinguishState: t === c.G.NONE ? d.c.None : d.c.Distinguished,
							distinguishType: T[t]
						}
					}
				}(t, n);
				return Object(u.a)(e, {
					...a,
					variables: s
				})
			}

			function P(e, t, n) {
				return Object(u.a)(e, {
					...i,
					variables: {
						input: {
							commentId: t,
							sticky: n
						}
					}
				})
			}
		},
		"./src/reddit/endpoints/economics/predictions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return x
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "o", (function() {
				return T
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "h", (function() {
				return R
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "m", (function() {
				return L
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./src/redditGQL/operations/AddPredictionDrafts.json"),
				a = n("./src/redditGQL/operations/CancelPrediction.json"),
				i = n("./src/redditGQL/operations/ChangePrediction.json"),
				d = n("./src/redditGQL/operations/ChangePredictionVote.json"),
				c = n("./src/redditGQL/operations/CreatePredictionTournament.json"),
				l = n("./src/redditGQL/operations/EndPredictionTournament.json"),
				u = n("./src/redditGQL/operations/GetPredictionChipPackages.json"),
				m = n("./src/redditGQL/operations/GetPredictionCreationAllowance.json"),
				p = n("./src/redditGQL/operations/GetPredictionToken.json"),
				b = n("./src/redditGQL/operations/GetTournaments.json"),
				h = n("./src/redditGQL/operations/GetTournamentsBaseInfo.json"),
				f = n("./src/redditGQL/operations/ResolvePrediction.json"),
				g = n("./src/redditGQL/operations/SubredditTopPredictors.json"),
				_ = n("./src/redditGQL/operations/SubredditTournamentLeaderboard.json"),
				v = n("./src/redditGQL/operations/UpdatePredictionTournament.json"),
				O = n("./src/redditGQL/operations/VotePrediction.json");
			const x = async (e, t) => {
				let {
					postId: n,
					optionId: o,
					coinPackageId: a,
					price: i
				} = t;
				var d;
				const c = await Object(s.a)(e, {
					...O,
					variables: {
						input: {
							postId: n,
							optionId: o,
							coinPackageId: a,
							price: i
						}
					}
				});
				if (!Object(r.c)(c) || c.error || !(null === (d = c.body.data.votePrediction) || void 0 === d ? void 0 : d.ok)) throw new Error("Failed to make prediction");
				return c.body.data.votePrediction.poll
			}, E = (e, t) => {
				let {
					postId: n,
					optionId: r
				} = t;
				return Object(s.a)(e, {
					...f,
					variables: {
						input: {
							postId: n,
							optionId: r
						}
					}
				})
			};
			var y;
			! function(e) {
				e.AllTime = "ALL_TIME", e.Monthly = "MONTHLY"
			}(y || (y = {}));
			const j = async (e, t) => {
				let {
					subredditId: n,
					period: o = y.AllTime,
					top: a = 100,
					includeCurrentRank: i
				} = t;
				const d = await Object(s.a)(e, {
					...g,
					variables: {
						subredditId: n,
						period: o,
						top: a,
						includeCurrentRank: i
					}
				});
				if (!Object(r.c)(d) || d.error) throw new Error("Failed to fetch subreddit top predictors");
				if (!d.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return d.body.data.subredditInfoById
			}, C = async (e, t) => {
				let {
					subredditId: n,
					tournamentId: o,
					includeCurrentRank: a
				} = t;
				const i = await Object(s.a)(e, {
					..._,
					variables: {
						subredditId: n,
						tournamentId: o,
						includeCurrentRank: a
					}
				});
				if (!Object(r.c)(i) || i.error) throw new Error("Failed to fetch subreddit tournament");
				if (!i.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return i.body.data.subredditInfoById
			}, k = async (e, t) => {
				const n = await Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error || !n.body.data.createPredictionTournament.tournament) throw new Error("Failed to create tournament");
				return n.body.data.createPredictionTournament.tournament
			}, I = async (e, t) => {
				const n = await Object(s.a)(e, {
					...b,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, S = async (e, t) => {
				const n = await Object(s.a)(e, {
					...h,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, w = async (e, t) => {
				const n = await Object(s.a)(e, {
					...o,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to create prediction");
				const {
					errors: a,
					tournament: i
				} = n.body.data.addPredictionDrafts;
				if (null == a ? void 0 : a.length) throw new Error(a[0].message);
				if (!i) throw new Error("Failed to create prediction");
				return i
			}, T = async (e, t) => {
				const n = await Object(s.a)(e, {
					...v,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to update prediction tournament");
				const {
					tournament: o
				} = n.body.data.updatePredictionTournament;
				if (!o) throw new Error("Failed to update prediction tournament");
				return o
			}, N = (e, t) => Object(s.a)(e, {
				...l,
				variables: {
					input: t
				}
			}), P = (e, t) => Object(s.a)(e, {
				...u,
				variables: t
			}), R = (e, t) => Object(s.a)(e, {
				...p,
				variables: t
			}), A = async (e, t) => {
				const n = await Object(s.a)(e, {
					...i,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || !n.body.data.changePrediction.ok) throw new Error("Unable to update prediction");
				return n.body.data.changePrediction.poll
			}, M = async (e, t) => {
				let {
					postId: n
				} = t;
				var o, i;
				const d = await Object(s.a)(e, {
					...a,
					variables: {
						input: {
							postId: n
						}
					}
				});
				if (!Object(r.c)(d) || !(null === (o = d.body.data.cancelPrediction) || void 0 === o ? void 0 : o.ok) || !(null === (i = d.body.data.cancelPrediction) || void 0 === i ? void 0 : i.poll)) throw new Error("Unable to cancel prediction");
				return d.body.data.cancelPrediction.poll
			}, D = async (e, t) => {
				var n, o;
				const a = await Object(s.a)(e, {
					...d,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(a) || !(null === (n = a.body.data.changePredictionVote) || void 0 === n ? void 0 : n.ok) || !(null === (o = a.body.data.changePredictionVote) || void 0 === o ? void 0 : o.poll)) throw new Error("Unable to change prediction.");
				return a.body.data.changePredictionVote.poll
			}, L = async (e, t) => {
				const n = await Object(s.a)(e, {
					...m,
					variables: t
				});
				return !!Object(r.c)(n) && n.body.data.identity.isPredictionCreationAllowed
			}
		},
		"./src/reddit/endpoints/economics/uploadedAssets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s, r, o = n("./src/config.ts"),
				a = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t, n, s) {
				const r = `assetType=${n}&assetStatus=${s}`;
				return Object(a.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets?${r}`
				})
			}

			function d(e, t, n) {
				const r = new FormData;
				return r.append("assetType", n.assetType), r.append("assetName", n.assetName), r.append("upfile", n.imageFile), n.assetType === s.Badge && (r.append("badgeColor", n.badgeColor || ""), r.append("badgeDescription", n.badgeDescription || "")), Object(a.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets`,
					method: "post",
					type: null,
					data: r
				})
			}

			function c(e, t, n, s, r) {
				return Object(a.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets/${n}s/${s}`,
					method: "patch",
					data: r
				})
			}! function(e) {
				e.Badge = "badge", e.Emote = "emote"
			}(s || (s = {})),
			function(e) {
				e.Uploaded = "uploaded", e.Approved = "approved", e.Rejected = "rejected"
			}(r || (r = {}))
		},
		"./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SetSubredditGeoPlace.json");
			const o = e => ({
				input: {
					subredditId: e.subredditId,
					geoPlace: {
						id: e.placeId,
						source: e.source,
						sessionId: e.sessionId
					}
				}
			});
			t.a = async (e, t) => Object(s.a)(e, {
				...r,
				variables: o(t)
			})
		},
		"./src/reddit/endpoints/gold/powerups/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "i", (function() {
				return x
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/CreateCustomEmoji.json"),
				o = n("./src/redditGQL/operations/DeleteCustomEmoji.json"),
				a = n("./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json"),
				i = n("./src/redditGQL/operations/ReallocatePowerups.json"),
				d = n("./src/redditGQL/operations/RedditorPowerups.json"),
				c = n("./src/redditGQL/operations/SubredditPowerups.json"),
				l = n("./src/redditGQL/operations/SubredditPowerupsFull.json"),
				u = n("./src/redditGQL/operations/UpdatePowerupsSettings.json"),
				m = n("./src/redditGQL/operations/UserPowerups.json");
			const p = e => Object(s.a)(e, m, {
					traceRequestName: "user_powerups"
				}),
				b = (e, t) => Object(s.a)(e, {
					variables: {
						id: t
					},
					...d
				}, {
					traceRequestName: "redditor_powerups"
				}),
				h = (e, t, n) => Object(s.a)(e, {
					...c,
					variables: {
						subredditId: t,
						includeIdentity: n
					}
				}, {
					traceRequestName: "subreddit_powerups"
				}),
				f = (e, t, n) => Object(s.a)(e, {
					...l,
					variables: {
						subredditId: t,
						includeIdentity: n
					}
				}, {
					traceRequestName: "subreddit_powerups_full"
				}),
				g = (e, t) => Object(s.a)(e, {
					...i,
					variables: t
				}),
				_ = (e, t) => Object(s.a)(e, {
					...a,
					variables: t
				}),
				v = (e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}),
				O = (e, t) => Object(s.a)(e, {
					...o,
					variables: t
				}),
				x = async (e, t, n) => {
					const r = {
						input: {
							subredditId: t,
							powerupsSettings: {
								benefitSettings: n
							}
						}
					};
					return Object(s.a)(e, {
						...u,
						variables: r
					})
				}
		},
		"./src/reddit/endpoints/gold/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/TopAwardedPosts.json"),
				o = n("./src/redditGQL/operations/TopAwardersLeaderboard.json");
			const a = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						...t,
						includeListingMetadata: !!t.includeListingMetadata
					}
				}),
				i = (e, t) => Object(s.a)(e, {
					...o,
					variables: t
				})
		},
		"./src/reddit/endpoints/goodContent/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/loadWithRetries/index.ts");
			! function(e) {
				e.PopularCommunities = "Popular Communities", e.Gaming = "Gaming", e.Sports = "Sports", e.TV = "TV", e.Travel = "Travel", e.HealthAndFitness = "Health & Fitness", e.Fashion = "Fashion"
			}(s || (s = {}));
			const a = {
					[s.PopularCommunities]: () => r.fbt._("Popular Communities", null, {
						hk: "2K4vGY"
					}),
					[s.Gaming]: () => r.fbt._("Gaming", null, {
						hk: "16rFc7"
					}),
					[s.Sports]: () => r.fbt._("Sports", null, {
						hk: "1cmqIR"
					}),
					[s.TV]: () => r.fbt._("TV", null, {
						hk: "2rVWoK"
					}),
					[s.Travel]: () => r.fbt._("Travel", null, {
						hk: "35HRB5"
					}),
					[s.HealthAndFitness]: () => r.fbt._("Health & Fitness", null, {
						hk: "2vstHj"
					}),
					[s.Fashion]: () => r.fbt._("Fashion", null, {
						hk: "3mkHju"
					})
				},
				i = e => {
					const t = a[e];
					return t ? t() : e
				},
				d = async () => (await Object(o.a)(() => n.e("FrontpageLinks").then(n.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "j", (function() {
				return a
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "l", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "n", (function() {
				return _
			}));
			var s, r = n("./src/config.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function a(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "Ethereum Main Network";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}

			function i(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "https://meta-api.reddit.com/ethereum/ethereum";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "https://meta-api.reddit.com/ethereum/rinkeby";
					case s.ArbitrumRinkeby:
						return "https://meta-api.reddit.com/ethereum/ethereum:5391184";
					case s.ArbitrumNitroDevnet:
						return "https://meta-api.reddit.com/ethereum/nitroDevnet";
					default:
						return `https://meta-api.reddit.com/ethereum/${e}`
				}
			}

			function d(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "homestead";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "rinkeby";
					case s.ArbitrumRinkeby:
						return 5391184;
					case s.ArbitrumNitroDevnet:
						return 421612;
					default: {
						const [, t] = e.split(":");
						return t
					}
				}
			}

			function c(e) {
				return e === s.ArbitrumRinkeby ? 5e3 : 3e4
			}
			async function l(e, t, n) {
				return Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/challenges`,
					data: {
						challengeType: "registration-challenge-EIP712",
						address: n
					}
				})
			}
			async function u(e, t, n) {
				return await Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations`,
					data: n
				})
			}
			async function m(e, t, n) {
				return await Object(o.a)(e, {
					method: "delete",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations/${n}`
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.ArbitrumRinkeby = "ethereum:5391184", e.ArbitrumNitroDevnet = "ethereum:421612", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader"
			}(s || (s = {}));
			const p = (e, t, n) => ({
					type: "burn-link",
					subredditId: e,
					amount: t,
					burnMemo: n
				}),
				b = e => ({
					type: "convert-to-coins",
					subredditId: e
				}),
				h = e => ({
					type: "claim",
					subredditId: e
				}),
				f = e => ({
					type: "subscribe",
					subredditId: e
				}),
				g = (e, t, n, s) => ({
					type: "transfer",
					subredditId: e,
					recipient: t,
					recipientAddress: n,
					amount: s
				});
			async function _(e, t) {
				return await Object(o.a)(e, {
					method: "put",
					endpoint: `${r.a.metaUrl}/crypto/ethereum/transaction-intent`,
					data: t
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function o(e, t, n) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: `${s.a.metaUrl}/polls/${t}?postIds=${n.join(",")}`
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/makeApiRequest/index.ts");

			function r(e, t) {
				return Object(s.a)(e, {
					type: "json",
					...t
				}).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : {
							...e.body,
							code: e.status
						},
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function a(e, t) {
				return Object(o.a)(e, {
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}/me`,
					method: r.jb.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							s = {
								[t.subredditId]: n
							};
						return {
							...e,
							body: s
						}
					}
					return e
				})
			}

			function i(e, t) {
				return Object(o.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}`,
					method: r.jb.POST,
					data: t.userIds
				}).then(e => e.ok ? {
					...e,
					body: {
						wallets: e.body
					}
				} : e)
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const i = e => Object(o.a)(e, {
				endpoint: Object(a.a)(`${s.a.gatewayUrl}/desktopapi/v1/me`),
				method: r.jb.GET
			})
		},
		"./src/reddit/endpoints/messages/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/ReportMessage.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const l = (e, t) => Object(o.a)(Object(i.a)(e, [d.a]), {
					endpoint: Object(c.a)(`${e.apiUrl}/api/compose`),
					method: r.jb.POST,
					data: t
				}),
				u = (e, t) => Object(a.a)(e, {
					...s,
					variables: t
				})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/redditGQL/operations/ModQueueItems.json");
			const m = (e, t, n) => Object(o.a)(e, {
					endpoint: Object(l.a)(Object(c.a)(`${s.a.gatewayUrl}/desktopapi/v1/${t}`)),
					method: r.jb.GET,
					data: {
						moderated_limit: 25,
						...n
					}
				}),
				p = (e, t, n) => Object(o.a)(Object(i.a)(e, [d.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/${t}`,
					method: r.jb.POST,
					type: "json",
					data: n
				}),
				b = (e, t) => Object(a.a)(e, {
					...u,
					variables: t
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts");
			t.a = async e => Object(r.a)(Object(o.a)(e, [a.a]), {
				endpoint: `${e.apiUrl}/subreddit_permissions`,
				method: s.jb.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json"),
				o = n("./src/redditGQL/operations/UpdateNotificationPreferences.json");
			const a = (e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}),
				i = (e, t) => Object(s.a)(e, {
					...o,
					variables: {
						input: {
							preferences: [t]
						}
					}
				})
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/ads/session-signals.ts"),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/isAdHocMultireddit/index.ts"),
				i = n("./src/lib/isFakeSubreddit/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/performanceTimings/index.tsx"),
				u = n("./src/reddit/constants/graphql.ts"),
				m = n("./src/reddit/constants/page.ts"),
				p = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				b = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				g = n("./src/reddit/models/Subreddit/index.ts"),
				_ = n("./src/reddit/selectors/platform.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/selectors/user.ts"),
				x = n("./src/redditGQL/operations/SubredditPage.json");
			const E = (e, t, n, s) => {
					var o, d, c, l;
					const {
						after: p,
						geo_filter: h,
						isMobile: f,
						layout: g,
						limit: x,
						recentPostIds: E,
						sort: y,
						t: j
					} = n, C = Object(O.Z)(e), k = Object(_.q)(e), I = Object(a.a)(t), S = Object(i.a)(t), w = Object(v.T)(e, {
						subredditId: Object(v.F)(e, t)
					}).length > 0, T = (null === (o = e.user.account) || void 0 === o ? void 0 : o.username) || (null === (d = e.user.account) || void 0 === d ? void 0 : d.displayText), N = Object(O.o)(e), P = Object(O.nb)(e), {
						numberOfAdsSeen: R,
						numberOfPostsSeen: A
					} = Object(r.a)(), M = {
						name: t,
						includeIdentity: C && !e.user.account,
						adContext: {
							layout: g ? g.toUpperCase() : u.a.Card,
							reddaid: e.user.reddaid,
							clientSignalSessionData: {
								adsSeenCount: R,
								totalPostsSeenCount: A
							}
						},
						isFake: S,
						includeAppliedFlair: !S && C && !!T && s,
						includePowerups: s && !S,
						includeQuestions: s && C && !S,
						includeRecents: S && E && E.length > 0 || !1,
						includeRedditorKarma: s && C && !(null === (l = null === (c = e.user.account) || void 0 === c ? void 0 : c.karma) || void 0 === l ? void 0 : l.total),
						includeRules: s && !S && !w,
						includeSubredditLinks: s && !S && !C,
						includeTopicLinks: s && !S && !C,
						includeTrending: S,
						isAdHocMulti: I,
						isAll: t === m.d.All,
						isLoggedOutGatedOptedin: N,
						isLoggedOutQuarantineOptedin: P,
						isPopular: t === m.d.Popular,
						recentPostIds: E || [],
						subredditNames: I ? t.split("+") : [],
						username: C && T && s ? T : ""
					};
					return y && (M.sort = y.toUpperCase()), j && (M.range = j.toUpperCase()), f ? M.pageSize = Object(b.a)(g) : x && (M.pageSize = x), k && k.ad && (M.forceAds = {
						ad: k.ad
					}), (k && k.geo_filter || h) && (M.region = k && k.geo_filter || h), p && (M.after = btoa(p)), M
				},
				y = async (e, t, n) => {
					const s = Date.now(),
						r = await ((e, t) => Object(c.a)(e, {
							...x,
							variables: t
						}))(e, t),
						a = Date.now();
					if (!r.ok || !r.body) return r;
					const i = r.body,
						d = Date.now(),
						u = Object(h.a)(i.data),
						m = Date.now(),
						p = [{
							duration: a - s,
							logKeyType: l.a.gqlFetchTiming
						}, {
							duration: m - d,
							logKeyType: l.a.gqlNormalizationTiming
						}];
					return Object(l.h)({
						name: o.r.SUBREDDIT,
						isLoggedIn: n,
						metrics: p
					}), {
						...r,
						ok: !!i.data.subredditInfoByName && !Object(g.j)(i.data.subredditInfoByName),
						status: j(i.data),
						body: u
					}
				}, j = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(g.j)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === g.c.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === g.c.GoldOnly || e.subredditInfoByName.forbiddenReason === g.c.Private || e.subredditInfoByName.forbiddenReason === g.c.Quarantined || e.subredditInfoByName.forbiddenReason === g.c.Gated) return 403
					}
					return 200
				}, C = e => {
					let {
						recentPostIds: t,
						...n
					} = e;
					return t && t.length ? {
						...n,
						recentPostIds: t.join(",")
					} : n
				};
			t.a = (e, t, n) => Object(d.a)(e, {
				endpoint: Object(p.a)(Object(f.a)(`${s.a.gatewayUrl}/desktopapi/v1/subreddits/${t}`)),
				method: o.jb.GET,
				data: n && C(n) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/page/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditWiki.json");
			const o = (e, t) => Object(s.a)(e, {
				...r,
				variables: t
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				i = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, n) => {
				const c = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === d.i.MARKDOWN ? c.richtext_json = n : c.markdown_text = n, Object(r.a)(Object(o.a)(e, [a.a]), {
					endpoint: Object(i.a)(`${e.apiUrl}/api/convert_rte_body_format`),
					method: s.jb.POST,
					data: c
				})
			}
		},
		"./src/reddit/endpoints/post/create.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			}));
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				m = n("./src/reddit/models/Poll/index.ts"),
				p = n("./src/reddit/models/Post/index.ts"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				h = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function f(e) {
				return Math.floor(e.valueOf() / 1e3)
			}
			const g = e => {
					switch (e.kind) {
						case b.p.CROSSPOST:
							return b.p.CROSSPOST;
						case b.p.LINK:
							return b.p.LINK;
						case b.p.POLL:
							return b.p.POLL;
						case b.p.MEDIA:
							return e.makeGif ? b.p.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				_ = e => {
					switch (e.kind) {
						case b.p.RICH_TEXT:
							return {
								richtext_json: JSON.stringify({
									document: e.document
								})
							};
						case b.p.MARKDOWN:
							return {
								text: e.markdown
							};
						case b.p.LINK:
						case b.p.MEDIA:
							return {
								url: e.url
							};
						case b.p.CROSSPOST:
							return {
								crosspost_fullname: e.sourcePostId
							};
						case b.p.POLL:
							return e.poll.type === m.a.Prediction ? {
								duration: 999999,
								end_timestamp: f(e.poll.endDate),
								options: e.poll.options.map(e => e.text),
								prediction: !0,
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							} : {
								duration: Math.floor(e.poll.duration / 864e5),
								options: e.poll.options.map(e => e.text),
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							}
					}
				},
				v = e => {
					const t = Object(l.h)(e.destSubreddit.name);
					return {
						...e.destSubreddit.isProfile ? {
							sr: `u_${t}`,
							submit_type: "profile"
						} : {
							sr: t,
							submit_type: "subreddit"
						},
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? p.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW,
						...e.kind !== b.p.POLL ? {
							kind: g(e),
							original_content: e.isOC
						} : {},
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies,
						...e.gRecaptchaResponse ? {
							"g-recaptcha-response": e.gRecaptchaResponse
						} : {},
						resubmit: e.resubmit,
						..._(e),
						...e.kind === b.p.MEDIA && "video" === e.mediaType ? {
							video_poster_url: e.videoThumbnailUrl
						} : {},
						...e.kind === b.p.MEDIA && e.makeGif ? {
							make_gif: "on"
						} : {},
						...e.flair ? {
							flair_id: e.flair.templateId,
							flair_text: Object(c.g)(e.flair)
						} : {},
						...e.validate_on_submit ? {
							validate_on_submit: e.validate_on_submit
						} : {},
						...e.eventSchedule && {
							event_start: e.eventSchedule.startDate,
							event_end: e.eventSchedule.endDate,
							event_tz: e.eventSchedule.timezoneName,
							unlist: e.eventSchedule.submitTime === b.j.AtEventTime
						},
						...e.collectionId && {
							collection_id: e.collectionId
						}
					}
				},
				O = e => {
					const t = /comments\/(\w+)\/.*$/.exec(e),
						n = t && t[1];
					return n ? `${r.Ib.Post}_${n}` : ""
				},
				x = async (e, t) => {
					if (!e.ok) return Object(u.b)(e);
					const n = e.body.json.data;
					let r = n.url;
					r || t.kind !== b.p.MEDIA || (r = await ((e, t) => new Promise(n => {
						const s = new WebSocket(e),
							r = e => {
								s.close(), clearTimeout(o), n(e)
							},
							o = setTimeout(() => {
								r("")
							}, t);
						s.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							r(n)
						}, s.onerror = e => {
							r("")
						}
					}))(n.websocket_url, 3e4));
					const o = n.id || O(r),
						a = Object(s.parse)(r).path,
						i = n.drafts_count;
					return {
						...e,
						body: {
							id: o,
							path: a,
							draftsCount: i
						}
					}
				}, E = (e, t) => Object(o.a)(Object(a.a)(e, [i.a]), {
					endpoint: Object(h.a)(Object(d.a)(`${e.apiUrl}/api/submit_poll_post.json?resubmit=true`)),
					method: r.jb.POST,
					data: v(t),
					type: "json"
				}).then(e => x(e, t)), y = (e, t) => Object(o.a)(Object(a.a)(e, [i.a]), {
					endpoint: Object(h.a)(Object(d.a)(`${e.apiUrl}/api/submit_gallery_post.json?resubmit=true`)),
					method: r.jb.POST,
					data: {
						...v(t),
						items: t.galleryItems.map(e => ({
							caption: e.caption,
							outbound_url: e.url,
							media_id: e.assetId
						}))
					},
					type: "json"
				}).then(e => x(e, t));
			t.c = (e, t) => Object(o.a)(Object(a.a)(e, [i.a]), {
				endpoint: Object(h.a)(Object(d.a)(`${e.apiUrl}/api/submit?resubmit=true`)),
				method: r.jb.POST,
				data: v(t)
			}).then(async e => await x(e, t))
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/PostDraft/index.ts");
			const o = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				a = e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {},
				i = e => {
					switch (e.kind) {
						case r.b.Link:
							return "link";
						case r.b.Markdown:
							return "markdown";
						case r.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				d = e => {
					switch (e) {
						case "link":
							return r.b.Link;
						case "markdown":
							return r.b.Markdown;
						case "richtext":
							return r.b.RichText;
						default:
							return "self"
					}
				},
				c = e => e.title.substring(0, 300),
				l = e => {
					switch (e.kind) {
						case r.b.Link:
						case r.b.Markdown:
							return e.body;
						case r.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(s.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				},
				m = e => ({
					id: e.draftId || void 0,
					...a(e),
					kind: i(e),
					title: c(e),
					body: l(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC,
					...u(e.flair),
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return C
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "j", (function() {
				return M
			})), n.d(t, "a", (function() {
				return D
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/omit.js"),
				o = n.n(r),
				a = n("./src/config.ts"),
				i = n("./src/lib/addQueryParams/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/constants/headers.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/lib/makeRequest/index.ts"),
				m = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				p = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				b = n("./src/reddit/featureFlags/useProductionStreamingApi.ts"),
				h = n("./src/reddit/helpers/comment/index.ts"),
				f = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				g = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				_ = n("./src/reddit/models/PostCreationForm/index.ts"),
				v = n("./src/reddit/models/Vote/index.ts"),
				O = n("./src/redditGQL/operations/LiveVideoPosts.json");

			function x() {
				return Object(b.b)() ? "https://strapi.reddit.com" : a.a.streamingApiUrl
			}
			const E = async (e, t) => {
				let n;
				return n = t === m.R ? "/config" : `/${t}/config`, Object(u.b)({
					endpoint: `${x()}${n}`,
					method: d.jb.GET,
					headers: o()(e.headers(), [c.d, c.c, c.a]),
					timeoutMs: void 0
				}).then(R)
			}, y = (e, t) => {
				let {
					subredditId: n,
					options: s
				} = t;
				return Object(l.a)(e, {
					...O,
					variables: {
						feedContext: {
							subredditId: n
						},
						first: null == s ? void 0 : s.pageSize,
						after: null == s ? void 0 : s.cursor
					}
				})
			}, j = async (e, t) => Object(u.b)({
				endpoint: `${x()}/videos/${t}`,
				method: d.jb.GET,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), C = async (e, t, n) => {
				let s;
				s = t === m.R ? "/broadcasts" : `/${t}/broadcasts`;
				const r = Object(i.a)(s, {
					cursor: null == n ? void 0 : n.cursor,
					page_size: null == n ? void 0 : n.pageSize
				});
				return Object(u.b)({
					endpoint: `${x()}${r}`,
					method: d.jb.GET,
					headers: o()(e.headers(), [c.d, c.c, c.a])
				}).then(R)
			}, k = async e => Object(u.b)({
				endpoint: `${x()}/recommended_viewer_subreddits`,
				method: d.jb.GET,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), I = async (e, t, n) => Object(u.b)({
				endpoint: `${x()}/videos/${t}/vote/${A(n)}`,
				method: d.jb.POST,
				headers: o()(e.headers, [c.d, c.c, c.a])
			}).then(R), S = async (e, t) => Object(u.b)({
				endpoint: `${x()}/videos/${t}/heartbeat`,
				method: d.jb.POST,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), w = async (e, t, n, s) => {
				const r = P(n);
				return r ? T(e, t, r).then(e => Object(u.c)(e) && e.body && e.body.data ? {
					...e,
					body: {
						parentId: t,
						comment: {
							...Object(g.a)(e.body.data.r2_comment),
							media: N(n)
						},
						automuteLevel: e.body.data.auto_mute_status.level
					},
					error: void 0
				} : e) : Promise.reject(new Error("Cannot send empty message"))
			}, T = async (e, t, n) => Object(u.b)({
				endpoint: `${x()}/broadcasts/${t}/comment_v2`,
				method: d.jb.POST,
				headers: o()(e.headers, [c.d, c.c, c.a]),
				data: {
					text: n
				},
				type: "json"
			}).then(R), N = e => ({
				type: "rtjson",
				richtextContent: Object(h.d)(e),
				rteMode: _.i.RICH_TEXT
			}), P = e => e.rteState ? p.a.getRawText(e.rteState) : e.rtJson ? Object(f.c)(e.rtJson) : void 0, R = e => {
				if (e.ok) return {
					...e,
					error: void 0
				}; {
					const t = {
						type: 404 === e.status ? d.I.NOT_FOUND_ERROR : d.I.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: s.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), {
						...e,
						error: t
					}
				}
			}, A = e => e === v.a.upvoted ? "up" : e === v.a.downvoted ? "down" : "unset", M = async (e, t, n) => Object(u.b)({
				endpoint: `${x()}/broadcasts/${t}`,
				method: d.jb.PUT,
				headers: o()(e.headers, [c.d, c.c, c.a]),
				data: {
					data: {
						chat_disabled: n
					}
				},
				type: "json"
			}).then(R), D = async (e, t) => Object(u.b)({
				endpoint: `${x()}/broadcasts/${t}/auto_mute_status`,
				method: d.jb.GET,
				headers: o()(e.headers, [c.d, c.c, c.a])
			}).then(R)
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/reddit/helpers/flair.ts"),
				o = n("./src/reddit/helpers/richTextJson/index.ts"),
				a = n("./src/reddit/models/Post/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/ScheduledPost/index.ts"),
				c = n("./src/redditGQL/operations/CreateScheduledPost.json"),
				l = n("./src/redditGQL/operations/SubredditScheduledPosts.json");
			const u = (e, t) => Object(s.a)(e, {
					...l,
					variables: {
						...t,
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					}
				}),
				m = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const n = e.body;
					return !!(n.data && n.data.subredditInfoById && n.data.subredditInfoById.scheduledPosts && n.data.subredditInfoById.scheduledPosts[t] && n.data.subredditInfoById.scheduledPosts[t].edges)
				},
				p = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => m(e, d.g.standalonePosts))(e)) && !(t.includeRecurring && !(e => m(e, d.g.recurringPosts))(e))),
				b = e => {
					let {
						poll: t,
						schedule: n,
						submission: s,
						subredditId: o
					} = e;
					return {
						collectionId: s.collectionId || "",
						discussionType: s.isChatPost ? a.b.Chat : a.b.Comment,
						isContestMode: s.isContestMode,
						isPostAsMetaMod: s.isPostAsMetaMod,
						isSpoiler: s.isSpoiler,
						isNsfw: s.isNSFW,
						poll: t && x(t),
						title: s.title,
						isOriginalContent: s.isOC,
						flair: s.flair ? {
							id: s.flair.templateId,
							text: Object(r.g)(s.flair)
						} : {},
						sticky: s.sticky,
						subredditId: o,
						suggestedCommentSort: s.suggestedSort,
						isSendReplies: s.sendReplies,
						...h(n),
						...v(s),
						assetIds: O(s)
					}
				},
				h = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				f = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				g = e => {
					let {
						poll: t,
						schedule: n,
						scheduledPostId: s,
						submission: r,
						subredditId: o
					} = e;
					const a = b({
						poll: t,
						schedule: n,
						submission: r,
						subredditId: o
					});
					return {
						id: s,
						...a,
						flair: Object.keys(a.flair || {}).length ? {
							...a.flair
						} : {
							id: "",
							text: ""
						}
					}
				},
				_ = e => /^https?:\/\//i.test(e) ? e : `http://${e}`,
				v = e => {
					switch (e.kind) {
						case i.p.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case i.p.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case i.p.LINK:
							return {
								content: {}, link: {
									url: _(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				O = e => {
					let t = [];
					if (e.document) {
						const n = e.document || [];
						t = Object(o.d)(n)
					}
					return t
				},
				x = e => {
					if (e && e.options && e.duration && (e.options = e.options.map(e => ({
							text: e.text.trim()
						})).filter(e => !!e.text), e.options.length)) return e.duration = Math.floor(e.duration / 864e5), e
				},
				E = (e, t) => Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				})
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/redditGQL/operations/UpdateScheduledPost.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			const o = (e, t) => Object(r.a)(e, {
				...s,
				variables: {
					input: t
				}
			})
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditAbout.json");
			t.a = (e, t, n) => Object(s.a)(e, {
				...r,
				variables: {
					subredditName: t,
					includeSubreddit: n
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				r = n("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const a = (e, t) => Object(o.a)(e, {
					...s,
					variables: {
						subredditIds: [t]
					}
				}),
				i = (e, t, n) => Object(o.a)(e, {
					...r,
					variables: {
						input: {
							...n,
							subredditId: t
						}
					}
				})
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/mapKeys.js"),
				a = n.n(o),
				i = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/redditGQL/operations/SubredditRules.json"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				b = n("./src/reddit/models/Rule/index.ts");
			const h = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => ({
							...a()(e, (e, t) => r()(t)),
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				f = (e, t) => Object(c.a)(e, {
					...u,
					variables: {
						subredditName: t
					}
				}).then(e => {
					var t, n, s;
					return e.ok && e.body && (e => Object.keys(e).length > 0)(e.body) && (null === (s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit) || void 0 === s ? void 0 : s.rules) ? e.body = Object(p.a)(e.body.data.subreddit.rules) : e.body = {
						rules: []
					}, e
				}),
				g = (e, t) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/user/${t}/about/rules.json`,
					method: i.jb.GET
				}).then(e => (e.ok && e.body.rules && (e.body = h(e.body)), e)),
				_ = e => e.ok ? (e.body = Object(b.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				v = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/add_subreddit_rule`,
					method: i.jb.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), O = async (e, t, n, s) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/update_subreddit_rule`,
					method: i.jb.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						old_short_name: s,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), x = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/remove_subreddit_rule`,
					method: i.jb.POST,
					data: {
						r: t,
						short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e)), E = e => e.map(e => encodeURIComponent(e)).join(), y = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/reorder_subreddit_rules`,
					method: i.jb.POST,
					data: {
						r: t,
						new_rule_order: E(n),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => _(e))
		},
		"./src/reddit/endpoints/subreddit/subscriptions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/SubscribedSubreddits.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			t.a = e => Object(a.a)(e, s);
			const l = (e, t) => {
					let {
						subredditIds: n,
						subredditNames: s,
						subscribe: a
					} = t;
					return Object(o.a)(Object(i.a)(e, [d.a]), {
						method: r.jb.POST,
						endpoint: Object(c.a)(`${e.apiUrl}/api/subscribe`),
						data: {
							action: a ? "sub" : "unsub",
							sr: n && n.join(",") || void 0,
							sr_name: s && s.join(",") || void 0,
							api_type: "json"
						}
					})
				},
				u = (e, t, n) => Object(o.a)(Object(i.a)(e, [d.a]), {
					method: r.jb.POST,
					endpoint: `${e.apiUrl}/api/favorite`,
					data: {
						make_favorite: n ? "true" : "false",
						sr_name: t,
						api_type: "json"
					}
				})
		},
		"./src/reddit/endpoints/subredditModeration/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/AllModerators.json"),
				o = n("./src/redditGQL/operations/FetchModerationLogActions.json");
			const a = (e, t, n) => Object(s.a)(e, {
					...o,
					variables: {
						subredditName: t,
						...n
					}
				}),
				i = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						subredditName: t
					}
				})
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/featureFlags/index.ts");

			function d(e, t, n) {
				const s = Object(a.c)({
					featureEnabled: t => i.d[e](t)
				});
				return Object(o.b)(s)(e => {
					const {
						featureEnabled: s,
						...o
					} = e, a = o;
					return s ? r.a.createElement(t, a) : void 0 !== n ? r.a.createElement(n, a) : null
				})
			}
		},
		"./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/models/Subreddit/index.ts");
			const r = new Set(["goins", "gold_testing", "inthesoulstone", "lounge", "lssgoldnormal", "maymodsguide1", "maymodsguide2", "megalounge", "pan2", "pan3", "venkman_bookclub", "whatssnoo", "translation_piglatin", "translation_pirate", "translation_initials", "translation_german", "translation_british", "translation_french_fr", "translation_es_mx", "translation_br_pt", "german_translation", "lssgoldnormal_13", "test_automation_001"]),
				o = new Set([s.f.Private, s.f.User]),
				a = e => !(!e || !e.name) && (!!r.has(e.name.toLowerCase()) || !e.isNSFW && !e.isQuarantined && !o.has(e.type));
			t.a = a
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_22cerq"]),
				r = e => s.has(e);
			t.a = r
		},
		"./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_q0gj4", "t5_z5gli", "t5_22cerq", "t5_3j0kj"]),
				r = e => s.has(e)
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/WhitelistStatus/index.ts");
			const r = (e, t) => {
				const n = e.some(e => e.isNSFW),
					r = t.some(e => e.wls === s.b.NO_ADS);
				return !n && !r
			}
		},
		"./src/reddit/helpers/canAccessModerationPage/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Subreddit/index.ts");
			t.a = e => {
				let {
					pageName: t,
					moderatorPermissions: n,
					canCreateScheduledPosts: o,
					isEmployee: a,
					isStreamingEnabled: i,
					isTalkHostsEnabled: d,
					subredditType: c,
					isContributor: l
				} = e;
				switch (t) {
					case s.gc.Awards:
						return !!n;
					case s.gc.Powerups:
						return !!(null == n ? void 0 : n.config);
					case s.gc.SubredditRules:
					case s.gc.Moderators:
						return !0;
					case s.gc.Modlog:
						return !!n;
					case s.gc.Muted:
						return !!(n && n.access && n.mail);
					case s.gc.Banned:
						return !(!n || !n.access);
					case s.gc.Contributors:
						return !!(n && n.access || c === r.f.Restricted || c === r.f.Private && l);
					case s.gc.Flair:
					case s.gc.PostFlair:
					case s.gc.UserFlair:
						return !(!n || !n.flair);
					case s.gc.CommunitySettings:
						return !(!n || !n.config);
					case s.gc.Modqueue:
					case s.gc.Reports:
					case s.gc.Edited:
					case s.gc.Spam:
					case s.gc.Unmoderated:
					case s.gc.ContentControls:
					case s.gc.Removal:
						return !(!n || !n.posts);
					case s.gc.ChatSettings:
						return !!n;
					case s.gc.Badges:
					case s.gc.Emojis:
						return !!n;
					case s.gc.Emotes:
						return !(!n || !n.config);
					case s.gc.Streaming:
						return !!(n && n.all && i);
					case s.gc.Wiki:
					case s.gc.WikiBanned:
					case s.gc.WikiContributors:
						return !(!n || !n.wiki);
					case s.gc.Traffic:
						return a || !!n;
					case s.gc.EventPostContent:
					case s.gc.ScheduledPostContent:
						return !!o;
					case s.gc.Predictions:
						return !(!n || !n.posts);
					case s.gc.TalkHosts:
						return !!d && !!n;
					default:
						return !1
				}
			}
		},
		"./src/reddit/helpers/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/uuid/v4.js"),
				r = n.n(s),
				o = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				a = n("./src/reddit/constants/things.ts"),
				i = n("./src/reddit/models/Vote/index.ts");
			const d = e => e.rteState ? o.a.toRichTextJSON(e.rteState) : e.rtJson || e.text,
				c = e => {
					let t = [];
					return e.rteState ? t = o.a.toRichTextJSON(e.rteState).document : e.rtJson && (t = e.rtJson.document), {
						document: t
					}
				},
				l = e => JSON.stringify(c(e));

			function u() {
				return `${a.a}_${r()()}`
			}

			function m(e) {
				let {
					temporalId: t,
					draft: n,
					post: s,
					author: r,
					subredditId: o,
					parentId: a
				} = e;
				return {
					id: t,
					postId: s.postId,
					subredditId: o,
					author: r.displayText || "",
					authorId: r.id,
					collapsed: !1,
					collapsedBecauseCrowdControl: null,
					created: Math.floor(Date.now() / 1e3),
					distinguishType: null,
					ignoreReports: !1,
					isAdmin: !1,
					isApproved: !1,
					isDeleted: !1,
					isGildable: !1,
					isLocked: !1,
					isMod: !1,
					isOp: !1,
					isRemoved: !1,
					isScoreHidden: !1,
					isSpam: !1,
					isStickied: !1,
					isSaved: !1,
					isSystem: !1,
					media: {
						type: "rtjson",
						rteMode: n.commentMode,
						richtextContent: c(n)
					},
					parentId: a,
					permalink: "",
					postAuthor: s.author,
					postTitle: null,
					score: 1,
					sendReplies: !1,
					modReports: [],
					numReports: 0,
					voteState: i.a.notVoted,
					userReports: []
				}
			}
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/constants/comments.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts");
			const i = (e, t) => t().features.comments.models[e],
				d = e => {
					switch (e.commentLink.type) {
						case s.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case s.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case s.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				c = (e, t) => e.type === s.a.MoreComments ? t[e.id].numComments : 1,
				l = (e, t, n, s) => {
					let o = Object(r.n)(s, {
							commentLink: t,
							commentsPageKey: e
						}),
						a = t;
					for (; o && o.depth > n && o.prev && (a = o.prev, (o = Object(r.n)(s, {
							commentLink: a,
							commentsPageKey: e
						})) && !(o.depth <= n)););
					return a.id
				},
				u = (e, t, n) => {
					const {
						commentLists: s,
						comments: r
					} = e, {
						head: i
					} = s[t];
					if (i) return Object.keys(r).filter(e => {
						const t = r[e];
						return !(!t.isStickied || !((e, t) => {
							const n = Object(a.c)(e, {
								experimentEligibilitySelector: a.a,
								experimentName: o.P,
								expEventOverride: t
							});
							return !!(Object(o.Tf)(n) ? void 0 : n)
						})(n)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/counters/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/sample/index.ts"),
				o = n("./src/telemetry/helpers/sendCounter.ts");
			const a = (e, t) => {
					Object(o.b)(s.m.Redesign, {
						type: o.a.GenderCollection,
						data: {
							gender: e,
							submitSuccess: t
						}
					})
				},
				i = (e, t) => {
					Object(r.b)(10) && Object(o.b)(s.m.Redesign, {
						type: o.a.ReonboardingFlow,
						data: {
							type: e,
							variant: t
						}
					})
				}
		},
		"./src/reddit/helpers/crypto/vaultActionLink.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				return e.match(/^https:\/\/www\.reddit\.com\/vault\/burn/)
			}

			function r(e) {
				const {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} = e;
				return t && n && s && r ? {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} : (console.error("subreddit, amount, and memo query params required for vault action"), null)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/dom/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/lodash/map.js"),
				r = n.n(s),
				o = n("./src/lib/FocusTrap/index.ts");
			const a = e => "INPUT" === e.tagName.toUpperCase() || "TEXTAREA" === e.tagName.toUpperCase() || "DIV" === e.tagName.toUpperCase() && e.isContentEditable,
				i = e => {
					let t = e;
					do {
						if (a(t)) return !0
					} while (t = t.parentElement);
					return !1
				},
				d = () => {
					const e = document.getSelection();
					return !!e && (e.rangeCount > 0 && e.getRangeAt(0).toString().length > 0)
				},
				c = () => d() ? (() => {
					const e = document.getSelection();
					if (!e) return [];
					const t = e.getRangeAt(0).cloneContents().childNodes;
					return r()(t, e => e.textContent || "")
				})() : null,
				l = (e, t) => {
					const n = document.createRange();
					return n.selectNode(t), e.compareBoundaryPoints(Range.END_TO_START, n) < 0 && e.compareBoundaryPoints(Range.START_TO_END, n) > 0
				},
				u = e => {
					const t = window.getSelection();
					if (1 !== t.rangeCount) return;
					const n = t.getRangeAt(0);
					if (!l(n, e)) return;
					const {
						startContainer: s,
						startOffset: r,
						endContainer: o,
						endOffset: a
					} = n, i = document.createRange();
					i.selectNode(e);
					let d = !0;
					if (-1 === i.compareBoundaryPoints(Range.START_TO_START, n) && (i.setStart(s, r), d = !1), 1 === i.compareBoundaryPoints(Range.END_TO_END, n) && (i.setEnd(o, a), d = !1), d) return [e];
					const c = document.createElement("div");
					return c.appendChild(i.cloneContents()), [...c.childNodes]
				},
				m = (e, t, n) => {
					let s = e;
					for (; s && (!n || !n(s));) {
						if (s && t(s)) return s;
						s = s.parentElement
					}
				},
				p = e => e && e.parentElement && m(e.parentElement, e => "static" !== window.getComputedStyle(e).getPropertyValue("position")),
				b = e => {
					e.querySelectorAll(o.a).forEach(e => {
						e.tabIndex = -1
					})
				}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-dnd/lib/index.js"),
				r = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				o = n.n(r);
			t.a = Object(s.DragDropContext)(o.a)
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function r(e) {
				return [...e].sort(s)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/findLastIndex.js"),
				r = n.n(s),
				o = n("./src/reddit/models/WhitelistStatus/index.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/index.ts");
			const d = (e, t) => {
				let {
					subreddits: n,
					profiles: s
				} = t;
				const r = n[e.belongsTo.id] || s[e.belongsTo.id];
				return !e.isNSFW && r && o.a.has(r.wls || o.b.NO_ADS)
			};
			t.a = (e, t, n) => {
				let {
					postIds: s,
					posts: o,
					subreddits: c,
					profiles: l,
					...u
				} = n;
				const m = e.listings.postOrder.ids[t],
					p = (s || []).filter(e => !m || !m.includes(e)),
					b = m.map(t => e.posts.models[t]),
					h = b.length - (r()(b, e => e.isSponsored) + 1),
					f = p.map(e => o[e]);
				let g;
				const _ = [],
					v = {
						subreddits: c,
						profiles: l
					};
				for (let r = 0; r < f.length; r++) {
					const n = f[r];
					let s = !1;
					if (n.isSponsored) {
						const e = r > 0 && f[r - 1],
							t = r < f.length - 1 && f[r + 1];
						e && d(e, v) && t && d(t, v) && (s = !0)
					}
					n.isSponsored && s && (null == g && h + r >= 3 || r - g >= 3) ? (g = r, _.push(n.id)) : n.isSponsored ? n.isSponsored && Object(i.a)({
						source: "feed",
						action: "remove",
						noun: "ad",
						...a.n(e),
						listing: a.y(e, t)
					}) : _.push(n.id)
				}
				return {
					...u,
					subreddits: c,
					profiles: l,
					posts: o,
					postIds: _
				}
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.I.SERVER_ERROR,
				fields: [{
					field: "",
					msg: s.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/postLayout.ts");

			function r(e) {
				return e ? s.c[e] : s.f
			}
		},
		"./src/reddit/helpers/getSubredditErrorProps/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/ContentGate.ts");
			t.a = (e, t, n) => {
				let r, o, a, i, d, c, l, u, m, p, b;
				return e ? e.quarantinedSubreddit ? (o = s.a.QuarantinedSubreddit, i = e.quarantineMessage, d = e.quarantineMessageHtml, c = e.quarantineRequiresEmail) : e.privateSubreddit ? (o = s.a.PrivateSubreddit, a = e.subredditDescription, l = e.isContributorRequestsDisabled, u = e.isContributorRequestTimestamp) : e.goldSubreddit ? o = s.a.GoldSubreddit : e.subredditBanned ? (o = s.a.SubredditBanned, r = e.subredditBanMessage) : e.subredditDoesNotExist ? o = s.a.SubredditDoesNotExist : e.subredditBlockedForLegalReason ? o = s.a.SubredditBlockedForLegalReason : e.interstitialWarningMessage && (o = s.a.GatedSubreddit, m = e.interstitialWarningMessage, p = e.interstitialWarningMessageHtml, b = e.interstitialWarningMessageRTJson) : t && (o = s.a.Nsfw), o && n ? {
					banMessage: r,
					contentGateType: o,
					isContributorRequestsDisabled: l,
					isContributorRequestTimestamp: u,
					subredditDescription: a,
					subredditName: n,
					quarantineMessage: i,
					quarantineMessageHtml: d,
					quarantineRequiresEmail: c,
					interstitialWarningMessage: m,
					interstitialWarningMessageHtml: p,
					interstitialWarningMessageRTJson: b
				} : void 0
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(r.a)(e) ? t || s.jc : void 0
			}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function o(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : s.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}

			function a(e) {
				const t = `${e.type} (${e.code})`;
				return "message" in e ? `${t}: ${e.message}` : t
			}
		},
		"./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				id: e.id,
				name: e.name,
				topic: e.title,
				children: e.isRoot ? [] : null
			});
			t.a = e => (e => {
				let {
					edges: t,
					schemeName: n
				} = e;
				return {
					topics: t.reduce((e, t) => {
						let {
							node: n
						} = t;
						const r = n.topic.parents.map(e => e.nodeId),
							o = r.length <= 0,
							a = n.id,
							i = {
								id: a,
								isRoot: o,
								parents: r,
								title: n.topic.title,
								name: n.topic.name
							};
						return o ? (e.topics.push(s(i)), e.dict[a] = e.topics.length - 1) : r.forEach(t => {
							var n;
							const r = e.dict[t];
							if ("number" == typeof r) {
								null === (n = e.topics[r].children) || void 0 === n || n.push(s(i))
							}
						}), e
					}, {
						topics: [],
						dict: {}
					}).topics,
					schemeName: n
				}
			})(e)
		},
		"./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/graphql/helpers.ts");
			const r = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							action: e,
							actionNotes: r,
							createdAt: o,
							details: a,
							id: i,
							moderator: d,
							subredditName: c,
							target: l,
							takedownContentPreview: u
						} = n, m = {
							action: e,
							actionNotes: r,
							createdAt: Object(s.g)(o),
							details: a,
							id: i,
							moderator: d,
							subredditName: c,
							target: l,
							takedownContentPreview: u
						};
						t.push(m)
					}
					return t
				},
				o = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							id: e,
							name: s
						} = n, r = {
							id: e,
							name: s
						};
						t.push(r)
					}
					return t
				}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => ({
				...e.id && {
					id: e.id
				},
				...e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				},
				...e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				},
				...e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				},
				...e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const r = e => {
				let {
					edges: t
				} = e;
				const n = [];
				for (const {
						node: r
					} of t) n.push(Object(s.f)(r));
				return n
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			t.a = e => {
				var t;
				return {
					subreddits: (null === (t = e.data.subredditInfoById) || void 0 === t ? void 0 : t.linkedSubreddits) ? e.data.subredditInfoById.linkedSubreddits.map(s) : []
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return S
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/env/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				a = n("./src/reddit/actions/gold/powerups.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				d = n("./src/reddit/models/RichTextJson/index.ts"),
				c = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				m = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				p = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizeSubredditWidgetsFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				k = n("./src/reddit/models/Onboarding/index.ts"),
				I = n("./src/reddit/helpers/graphql/helpers.ts");
			const S = (e, t, n) => {
				const a = {
						account: null,
						appliedFlair: {},
						authorFlair: {},
						interestTopicRecommendations: void 0,
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						powerups: {},
						predictionTournaments: null,
						preferences: null,
						profiles: {},
						questions: {},
						recentPostIds: [],
						structuredStyles: {},
						subredditAboutInfo: {},
						subredditLinks: {},
						subredditPermissions: void 0,
						subredditRules: [],
						subreddits: {},
						subredditTopicLinks: void 0,
						token: "",
						trendingSubredditIds: []
					},
					d = e => {
						if (Object(i.j)(e) || Object(i.i)(e)) return null;
						if (a.posts[e.id]) return e.id;
						const t = Object(b.f)(e);
						a.posts[t.id] = t;
						const {
							crosspostRoot: n
						} = e;
						n && n.type === i.a.Post && n.postInfo && d(n.postInfo);
						let c = t.id;
						if (e.authorFlair && (a.authorFlair[t.belongsTo.id] || (a.authorFlair[t.belongsTo.id] = {}), a.authorFlair[t.belongsTo.id][t.author] = Object(l.a)(e.authorFlair)[0]), Object(i.l)(e)) a.profiles[e.profile.id] || (a.profiles[e.profile.id] = Object(f.a)(e.profile));
						else if (Object(i.n)(e)) a.subreddits[e.subreddit.id] || (a.subreddits[e.subreddit.id] = Object(_.a)(e.subreddit)), a.postFlair[e.subreddit.id] || (a.postFlair[e.subreddit.id] = Object(m.a)(e.subreddit));
						else if (Object(i.h)(e)) {
							const n = Object(b.b)(e);
							if (!n) return null;
							c = n, a.posts[n] = {
								...t,
								id: n,
								permalink: `${t.permalink}?instanceId=${encodeURIComponent(n)}`
							}, a.posts[t.id] || (a.posts[t.id] = {
								...t,
								events: []
							}), a.postInstances[e.id] || (a.postInstances[e.id] = []), a.postInstances[e.id].push(n)
						} else try {
							Object(s.a)(e)
						} catch (u) {
							const t = `Received unhandled element type when processing subreddit posts: "${e.__typename}"`;
							Object(r.b)() || console.warn(t), o.c.captureMessage(t)
						}
						return c && a.postIds.push(c), c
					};
				if (e.forEach(e => d(e)), t) {
					a.trendingSubredditIds = t.map(e => e.id);
					for (const e of t) a.subreddits[e.id] = Object(_.a)(e)
				}
				const c = a.postIds.length - 1;
				return a.token = c >= 0 ? a.postIds[c] : "", n && (a.account = Object(C.a)(n), a.preferences = n.preferences && Object(h.a)(n.preferences, n.interactions) || null), a
			};
			t.a = e => {
				let {
					adhocMultiredditByNames: t,
					all: n,
					identity: s,
					popular: m,
					recentPosts: b,
					subredditInfoByName: h,
					trendingSubreddits: f
				} = e;
				var _, T;
				if (!h) return {
					reason: c.e.NotFoundSubreddit,
					data: {
						account: s && Object(C.a)(s) || null
					}
				};
				if (Object(c.j)(h)) {
					const {
						banMessage: e,
						publicDescriptionText: t,
						quarantineMessage: n,
						isEmailRequiredForQuarantineOptin: r,
						interstitialWarningMessage: o
					} = h;
					return {
						reason: w(h.forbiddenReason),
						data: {
							account: s && Object(C.a)(s) || null,
							banMessage: e || void 0,
							description: t,
							quarantineRequiresEmailOptin: r,
							...n ? {
								quarantineMessage: n.markdown,
								quarantineMessageRTJson: Object(I.h)(n.richtext, d.i)
							} : {},
							interstitialWarningMessage: null == o ? void 0 : o.markdown,
							interstitialWarningMessageRTJson: Object(I.h)(null == o ? void 0 : o.richtext, d.i)
						}
					}
				}
				const N = {};
				let P;
				const R = h || m || n || t,
					[A, M] = R.elements.edges.reduce((e, t, n) => {
						var s, r, o, a;
						const [d, c] = e, l = t.node;
						if (Object(i.k)(l)) d.push(l), (null === (r = null === (s = l.flair) || void 0 === s ? void 0 : s.template) || void 0 === r ? void 0 : r.id) && (null === (a = null === (o = l.flair) || void 0 === o ? void 0 : o.template) || void 0 === a ? void 0 : a.postStyle) && (N[l.flair.template.id] = Object(p.a)(l.flair.template.postStyle));
						else if (Object(k.g)(l)) {
							const e = Object(u.a)(l.interestTopicRecommendations.recommendationTopics);
							e.topics.length && (P = {
								interests: e,
								index: n
							})
						} else c.push(l);
						return [d, c]
					}, [
						[],
						[]
					]);
				if (M.length) {
					const e = `Received unhandled ${M.length} elements when processing subreddit data: "${M[0].__typename}"`;
					Object(r.b)() || console.warn(e), o.c.captureMessage(e)
				}
				b && A.push(...b);
				const D = R.elements.dist,
					L = S(A, f, s);
				if (h.styles && (L.structuredStyles = {
						data: {
							style: Object(E.a)(h.styles)
						}
					}), L.structuredStyles = {
						data: {
							...h.styles ? {
								style: Object(E.a)(h.styles)
							} : {},
							content: {
								widgets: Object(j.a)(h)
							},
							flairTemplate: N
						}
					}, L.subredditAboutInfo = Object(g.a)(h), h.modPermissions && (L.subredditPermissions = Object.keys(h.modPermissions).length > 0 ? Object(O.a)(h.modPermissions) : void 0), h.rules && (L.subredditRules = Object(x.a)(h.rules).rules), ((null == h ? void 0 : h.answerableQuestions) || h.contentRatingSurvey || h.communityProgressModule) && (L.questions = {
						answerableQuestions: null == h ? void 0 : h.answerableQuestions,
						contentRatingSurvey: null == h ? void 0 : h.contentRatingSurvey,
						communityProgressModule: null == h ? void 0 : h.communityProgressModule
					}), !Object(c.j)(h)) {
					const e = {
						powerups: h.powerups,
						powerupsSettings: h.powerupsSettings,
						supporters: h.supporters,
						productOffers: h.productOffers,
						subredditAchievementFlairs: h.subredditAchievementFlairs
					};
					L.powerups = Object(a.c)(e, s)
				}
				return L.subredditLinks = Object(v.a)({
					data: {
						subredditInfoById: h
					}
				}), L.subredditTopicLinks = Object(y.a)({
					data: {
						subredditInfoById: h
					}
				}), L.appliedFlair = {
					flair: (null === (_ = h.flairedRedditorByName) || void 0 === _ ? void 0 : _.flair) ? Object(l.a)(null === (T = h.flairedRedditorByName) || void 0 === T ? void 0 : T.flair)[0] : void 0,
					displaySettings: h.authorFlairSettings
				}, P && (L.interestTopicRecommendations = P), L.predictionTournaments = h.predictionTournaments || [], {
					...L,
					...null !== D && {
						dist: D
					}
				}
			};
			const w = e => {
				switch (e) {
					case c.c.Banned:
						return c.e.BannedSubreddit;
					case c.c.GoldOnly:
						return c.e.GoldSubreddit;
					case c.c.Private:
						return c.e.PrivateSubreddit;
					case c.c.Quarantined:
						return c.e.QuarantinedSubreddit;
					case c.c.Gated:
						return c.e.GatedSubreddit;
					case c.c.Unknown:
						return c.e.ForbiddenSubreddit
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return h
			}));
			const s = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: p(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo
						}
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				r = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: u(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo
						}
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				o = e => ({
					...e,
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: {
							...s(e),
							...r(e)
						}
					}
				}),
				a = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				d = e => a(e) && i(e),
				c = e => !a(e) && i(e),
				l = e => a(e) && !i(e),
				u = e => e.map(e => m(e.node)),
				m = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					collectionId: e.collections.edges.length ? e.collections.edges[0].node.id : void 0,
					discussionType: e.discussionType,
					isContestMode: e.isContestMode,
					isPostAsMetaMod: e.isPostAsMetaMod,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					isSticky: !!e.sticky && "NONE" !== e.sticky,
					mediaAssets: e.mediaAssets,
					subreddit: {
						...e.subreddit
					},
					suggestedCommentSort: e.suggestedCommentSort,
					owner: {
						...e.owner
					},
					poll: e.poll,
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? {
						...e.flair
					} : void 0,
					sticky: e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				p = e => e.map(e => b(e.node)),
				b = e => ({
					...m(e),
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				h = e => (e => !!e.frequency && !!e.interval)(e) ? b(e) : m(e)
		},
		"./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				var t, n;
				return (null === (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.subredditInfoById) || void 0 === n ? void 0 : n.topicLinks) || void 0
			}
		},
		"./src/reddit/helpers/hasModFlairPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.flair
		},
		"./src/reddit/helpers/hasModFullPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.all
		},
		"./src/reddit/helpers/hasModPostPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.posts
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/xorWith.js"),
				a = n.n(o);
			t.a = (e, t) => {
				const n = a()(e, t, r.a);
				return !(!n || 0 !== n.length)
			}
		},
		"./src/reddit/helpers/isCrosspost.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return !!e && !!e.crosspostRootId
			}
		},
		"./src/reddit/helpers/isValidUsername/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/normalizeUsername/index.tsx");
			t.a = e => {
				const t = Object(s.a)(e.trim());
				return t.length > 2 && t.length <= 20
			}
		},
		"./src/reddit/helpers/locales.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/fbt.js"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				i = n("./node_modules/reselect/es/index.js");
			const d = e => Object.entries(e).map(e => {
					let [t, n] = e;
					return {
						value: t,
						displayName: n.displayName
					}
				}),
				c = Object.freeze({
					[s.GERMAN_LOCALE]: Object.freeze({
						bcp47: s.GERMAN_LOCALE,
						displayName: "Deutsch",
						englishName: "German",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.GERMAN_LOCALE),
						rtl: !1
					}),
					[s.DEFAULT_LOCALE]: Object.freeze({
						bcp47: s.DEFAULT_LOCALE,
						displayName: "English (US)",
						englishName: "English (US)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.DEFAULT_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_LOCALE,
						displayName: "Espaol (ES)",
						englishName: "Spanish (ES)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_MEXICAN_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_MEXICAN_LOCALE,
						displayName: "Espaol (MX)",
						englishName: "Spanish (MX)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_MEXICAN_LOCALE),
						rtl: !1
					}),
					"fr-FR": Object.freeze({
						bcp47: "fr-FR",
						displayName: "Franais",
						englishName: "French",
						fbtLocale: Object(r.isoLocaleToFbtLocale)("fr-FR"),
						rtl: !1
					}),
					[s.ITALIAN_LOCALE]: Object.freeze({
						bcp47: s.ITALIAN_LOCALE,
						displayName: "Italiano",
						englishName: "Italian",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.ITALIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_BRAZILIAN_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_BRAZILIAN_LOCALE,
						displayName: "Portugus (BR)",
						englishName: "Portuguese (BR)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_BRAZILIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_LOCALE,
						displayName: "Portugus (PT)",
						englishName: "Portuguese (PT)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_LOCALE),
						rtl: !1
					})
				}),
				l = Object.freeze({
					[s.BENGALI_BANGLADESHI_LOCALE]: Object.freeze({
						bcp47: s.BENGALI_BANGLADESHI_LOCALE,
						displayName: "",
						englishName: "Bengali",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.BENGALI_BANGLADESHI_LOCALE),
						rtl: !1
					}),
					[s.HINDI_LOCALE]: Object.freeze({
						bcp47: s.HINDI_LOCALE,
						displayName: "",
						englishName: "Hindi",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.HINDI_LOCALE),
						rtl: !1
					})
				}),
				u = Object.freeze({
					[s.PSEUDO_LOCALE]: Object.freeze({
						bcp47: s.PSEUDO_LOCALE,
						displayName: "Pseudo",
						englishName: "Pseudo",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_LOCALE),
						rtl: !1
					}),
					[s.PSEUDO_AUTO]: Object.freeze({
						bcp47: s.PSEUDO_AUTO,
						displayName: "Pseudo Auto",
						englishName: "Pseudo Auto",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_AUTO),
						rtl: !1
					})
				}),
				m = Object(i.a)(a.N, o.b, (e, t) => e || t ? {
					...c,
					...l,
					...u
				} : c);
			const p = async (e, t) => {
				0
			}
		},
		"./src/reddit/helpers/matchRedditUrls/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/env/index.ts"),
				r = n("./src/reddit/helpers/parseUrl.ts");
			const o = ["old", "new", "en", "www", "np", "m"],
				a = ["reddit.com", "reddit.local", ..."undefined" != typeof window && Object(s.a)() ? [window.location.host] : []].concat("").concat(o.map((function(e) {
					return e + ".reddit.com"
				}))).concat(o.map((function(e) {
					return e + ".reddit.local"
				}))),
				i = ["mod.reddit.com"],
				d = {
					subreddit: {
						pathnameComponents: ["subredditName"],
						pathname: /^\/r\/(\w+)\/?$/
					},
					user: {
						pathnameComponents: ["username"],
						pathname: /^\/(?:user|u)\/(\w+)\/?$/
					},
					postShortlink: {
						hostnames: a.concat("redd.it"),
						pathnameComponents: ["postID36"],
						pathname: /^\/([A-Za-z0-9]+)\/?$/
					},
					postDetail: {
						pathnameComponents: ["postID36"],
						pathname: /^\/(?:(?:r|user|u)\/.+\)?\/)?comments\/(\w+)(?:\/\w+)?\/?$/
					},
					comment: {
						pathnameComponents: ["postID36", "commentID36"],
						pathname: /^\/(?:(?:r|user|u)\/.+\)?\/)?comments\/(\w+)\/\w+\/(\w+)\/?$/
					},
					modmailConversation: {
						hostnames: i,
						pathnameComponents: ["modmailConversationId"],
						pathname: /^\/mail\/[^/]+\/(\w+)\/?$/
					},
					modmailMessage: {
						hostnames: i,
						pathnameComponents: ["modmailConversationId", "modmailMessageId"],
						pathname: /^\/mail\/[^/]+\/(\w+)\/(\w+)\/?$/
					}
				};

			function c(e, t) {
				const n = d[e];
				if (!d) throw new Error("Could not find reddit URL spec: " + e);
				const s = Object(r.a)(t);
				if (!s) return void console.error("Could not parse url", t);
				if (-1 === (n.hostnames || a).indexOf(s.hostname)) return;
				const o = s.pathname.match(n.pathname);
				if (o) {
					return {
						url: t,
						routeName: e,
						components: n.pathnameComponents.reduce((function(e, t, n) {
							return e[t] = o[n + 1], e
						}), {})
					}
				}
			}

			function l(e) {
				return (e.match(new RegExp(r.b, "g")) || []).map((function(e) {
					let t;
					return Object.keys(d).some((function(n) {
						return t = c(n, e)
					})), t
				})).filter((function(e) {
					return e
				}))
			}
		},
		"./src/reddit/helpers/onboarding/reonboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/customMiddleware/recentSubreddits.ts"),
				o = n("./src/reddit/helpers/featureThrottling/store/index.ts"),
				a = n("./src/reddit/helpers/onboarding/postsConsumedWeekly.ts"),
				i = n("./src/reddit/models/Onboarding/index.ts");
			const d = () => {
					const e = Date.now() - s.rc,
						t = Object(r.b)().filter(t => t.lastVisited >= e),
						n = Object(a.a)();
					return t.length < 3 || n < 50
				},
				c = () => !(() => !o.a.isReady || o.a.isFeatureThrottled(i.e.FeatureGate) || o.a.isFeatureThrottled(i.e.Dismissed))() && d(),
				l = () => !(() => !o.a.isReady || o.a.throttlingData[i.e.FeatureGate] || o.a.isFeatureThrottled(i.e.Triggered) || o.a.isFeatureThrottled(i.e.Dismissed))() && d(),
				u = () => {
					o.a.isFeatureThrottled(i.e.Triggered) || (o.a.throttleFeature(i.e.FeatureGate), o.a.throttleFeature(i.e.Triggered))
				},
				m = () => {
					o.a.throttleFeature(i.e.Dismissed)
				}
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					n = e % 100;
				return e + (t[(n - 20) % 10] || t[n] || t[0])
			}
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/history/esm/history.js"), n("./src/reddit/actions/platform.ts");
			var s = n("./src/config.ts");
			t.a = (e, t) => {
				const n = t.platform.currentPage && t.platform.currentPage.url;
				let r = `${s.a.accountManagerOrigin}/login/`;
				const o = window.location.origin;
				n && (r += `?dest=${encodeURIComponent(`${o}${n}`)}`), window.location.href = r
			}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/isComment.ts"),
				o = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				a = n("./src/reddit/models/Vote/index.ts"),
				i = e => !0 === e ? a.a.upvoted : !1 === e ? a.a.downvoted : a.a.notVoted,
				d = n("./src/reddit/models/Comment/index.ts");
			t.a = e => {
				const t = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedReasonCode: e.collapsed_reason_code,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					commentType: e.comment_type,
					created: e.created_utc,
					deletedBy: l(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === s.E,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: c(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: i(e.likes)
				};
				return e.all_awardings && (t.allAwardings = Object(o.a)(e.all_awardings)), e.awarders && (t.awarders = e.awarders), e.associated_award && (t.associatedAwardId = e.associated_award.id, t.associatedAward = Object(o.b)(e.associated_award)), t
			};
			const c = e => "string" == typeof e ? JSON.parse(e) : e,
				l = e => e.author !== s.E ? null : e.body === s.F ? d.c.User : e.body === s.Lb ? d.c.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/Media/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				i = n("./src/reddit/models/Vote/index.ts");
			const d = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: r.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: r.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: r.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: r.f.Nsfw
					}), t
				},
				c = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				l = e => {
					const t = e.preview && e.preview.enabled;
					let n = !1,
						s = null,
						r = {},
						i = {};
					const d = e.over_18 || e.spoiler;
					if (e.preview && (n = !!(i = e.preview.images[0].variants).mp4, r = e.preview.images[0].source, d && (s = i.obfuscated.source.url)), e.is_self) return {
						content: e.selftext_html,
						type: o.o.TEXT,
						markdownContent: e.selftext,
						obfuscated: s,
						rteMode: e.rte_mode || a.i.RICH_TEXT,
						...e.rtjson && {
							richtextContent: e.rtjson,
							type: o.o.RTJSON,
							mediaMetadata: e.media_metadata
						}
					};
					if (e.secure_media && e.secure_media.oembed || e.is_survey_ad) return {
						content: e.secure_media_embed.media_domain_url,
						type: o.o.EMBED,
						width: e.secure_media.oembed.width || 0,
						height: e.secure_media.oembed.height || 0,
						obfuscated: s,
						provider: e.secure_media.oembed.provider_name || ""
					};
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: s,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: o.o.VIDEO
						}
					}
					if (e.media && e.media.rpan_video) {
						const t = e.media.rpan_video;
						return {
							hlsUrl: t.hls_url,
							scrubberThumbSource: t.scrubber_media_url,
							type: o.o.LIVEVIDEO
						}
					}
					if (t && n) return {
						content: i.mp4.source.url,
						type: o.o.GIFVIDEO,
						width: i.mp4.source.width,
						height: i.mp4.source.height,
						gifBackgroundImage: r.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: s,
						resolutions: i.mp4.resolutions
					};
					if (t) {
						const t = i.gif ? i.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: r.url,
							type: o.o.IMAGE,
							width: r.width,
							height: r.height,
							obfuscated: s,
							resolutions: t
						}
					}
					return null
				},
				u = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const n = e.outbound_link;
							t.outboundUrl = n.url, t.outboundUrlExpiration = n.expiration, t.outboundUrlCreated = n.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					allAwardings: e.all_awardings ? Object(s.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					authorIsBlocked: e.author_is_blocked,
					audioRoom: e.audioRoom,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: d(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					impressionId: e.impression_id ? String(e.impression_id) : null,
					impressionIdStr: e.impression_id_str,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCreatedFromAdsUi: e.is_created_from_ads_ui,
					isCrosspostable: e.is_crosspostable,
					isEligibleForQASchema: !1,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isReactAllowed: !1,
					reactedFrom: null,
					attributionInfo: null,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isSurveyAd: !!e.is_survey_ad,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: l(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: `https://www.reddit.com${e.permalink}`,
					postCategories: c(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					topAwardedType: e.top_awarded_type && e.top_awarded_type.toUpperCase(),
					treatmentTags: e.treatment_tags,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: u(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(i.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case s.I.NO_STRIPE_SUBSCRIPTION:
							case s.I.USER_DOESNT_EXIST:
							case s.I.USER_REQUIRED_ERROR:
							case s.I.VALIDATION_ERROR:
								return e;
							case s.I.NO_USER:
							case s.I.NO_TEXT:
							case s.I.NO_URL:
								return s.I.VALIDATION_ERROR;
							case s.I.CREDIT_CARD_FAILURE:
							case s.I.CREDIT_CARD_FAILURE_GENERIC:
								return s.I.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return s.I.SUBMIT_VALIDATION_ERROR
						}
					}
					return s.I.VALIDATION_ERROR
				},
				o = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				a = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? {
						...e,
						error: o(e)
					} : e
				};
			t.a = o
		},
		"./src/reddit/helpers/readOnlyMode/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})), n.d(t, "c", (function() {
					return o
				})),
				function(e) {
					e.editable = "editable", e.focusableReadOnly = "focusablereadonly", e.readOnly = "readonly"
				}(s || (s = {}));
			const r = e => o(e) || e === s.focusableReadOnly,
				o = e => e === s.readOnly
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			n("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function o(e, t) {
				for (var n = arguments.length, s = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++) s[o - 2] = arguments[o];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let n = 0;
						(e = new Error(t.replace(/%s/g, () => String(s[n++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const a = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				i = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var d = function(e, t, n) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const d = e[r - 1];
					let c = e[0];
					for (let o = 1; o < r - 1; ++o) switch (n) {
						case i.SEMICOLON:
							c = s.fbt._("{previous items}; {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "4hs4xq"
							});
							break;
						default:
							c = s.fbt._("{previous items}, {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, n, r) {
						switch (n) {
							case a.AND:
								return s.fbt._("{list of items} and {last item }", [s.fbt._param("list of items", e), s.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case a.OR:
								return s.fbt._("{list of items} or {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case a.NONE:
								switch (r) {
									case i.SEMICOLON:
										return s.fbt._("{previous item}; {last item}", [s.fbt._param("previous item", e), s.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return s.fbt._("{list of items}, {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									o(!1, "Invalid conjunction %s provided to intlList", n)
						}
					}(c, d, t || a.AND, n || i.COMMA)
				},
				c = n("./src/lib/timezone/index.ts"),
				l = n("./src/reddit/helpers/isArrayEqual.ts"),
				u = n("./src/reddit/helpers/ordinal/index.ts"),
				m = n("./src/reddit/models/ScheduledPost/index.ts");
			const p = e => {
					return `${e.toLocaleDateString(void 0,{month:"numeric",day:"numeric"})} @ ${e.toLocaleTimeString(void 0,{hour:"numeric",minute:"numeric"}).replace(" ","").toLowerCase()}`
				},
				b = (e, t) => {
					if (e && t) {
						const n = Object(c.f)(f(e, t)),
							r = p(n);
						return s.fbt._("At {time}", [s.fbt._param("time", r)], {
							hk: "25s5Tg"
						})
					}
					return s.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				h = e => e.slice(0, 5),
				f = (e, t) => `${e}T${h(t)}:00`,
				g = e => {
					const [t, n] = e.split("T");
					return [t, h(n)]
				},
				_ = e => {
					const [t, n] = g(e);
					if (t && n) {
						const e = Object(c.f)(f(t, n));
						return p(e)
					}
					return ""
				},
				v = e => {
					const t = Object(c.d)(e);
					let n, s = e;
					if (t) {
						n = t.offset, s = `(GMT${Object(c.e)(t.offset)}) ${e.replace("/"," - ").replace(/_/g," ")}`
					}
					return {
						name: e,
						displayText: s,
						offset: n
					}
				},
				O = e => "string" == typeof e,
				x = e => {
					const t = new Date,
						n = e - t.getDay();
					return t.setDate(t.getDate() + n), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				E = e => {
					const t = (e => {
						const [t, n] = g(e);
						if (t && n) {
							return Object(c.f)(f(t, n)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === m.d.Hourly) return 2 === e.interval ? s.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? s.fbt._("Every {hour interval} hours", [s.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : s.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === m.d.Daily) return 2 === e.interval ? s.fbt._("Every other day at {start time}", [s.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? s.fbt._("Every {day interval} days at {start time}", [s.fbt._param("day interval", e.interval.toString()), s.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : s.fbt._("Every day at {start time}", [s.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === m.d.Weekly) {
						const n = (e => d(e.map(m.l).sort((e, t) => e - t).map(x), a.AND, i.COMMA))(e.byWeekDays);
						return 2 === e.interval ? s.fbt._("Every other week on {days of week } at {start time}", [s.fbt._param("days of week ", n), s.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? s.fbt._("Every {interval} weeks on {days of week} at {start time}", [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : s.fbt._("Every week on {days of week} at {start time}", [s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const n = (e => d(e.sort((e, t) => e - t).map(u.a), a.AND, i.COMMA))(e.byMonthDays);
					return 2 === e.interval ? s.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? s.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : s.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				y = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = m.b);
					const n = Object(c.f)(e.publishAt),
						s = Object(m.r)(n.getDay()),
						r = n.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== s && (t = m.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = m.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				j = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const n in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(n)) {
							if (Array.isArray(e[n]) && (!Array.isArray(t[n]) || !Object(l.a)(e[n], t[n]))) return !1;
							if (e[n] !== t[n]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/search/renderMedia.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/PostMedia/index.tsx");
			const a = (e, t, n, s, o, a) => s ? e.crosspostRootId ? r.a.createElement("div", {
					className: t.crosspostMediaWrapper
				}, i(e, n, o, a)) : i(e, n, o, a) : null,
				i = (e, t, n, s) => r.a.createElement(o.a, {
					isExpando: !0,
					isGalleryTileLayoutDefault: s,
					isListing: !0,
					isNotCardView: !0,
					post: e,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					shouldShowGalleryTileOption: n,
					showCentered: !0,
					showFull: !0
				})
		},
		"./src/reddit/helpers/sessionStorage/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "d", (function() {
					return o
				})), n.d(t, "b", (function() {
					return a
				})), n.d(t, "a", (function() {
					return i
				})), n.d(t, "c", (function() {
					return d
				})),
				function(e) {
					e.COMMENT_BEFORE_SIGNUP_STORAGE = "comment_before_signup_storage"
				}(s || (s = {}));
			const r = e => {
					if (window.sessionStorage) {
						const t = window.sessionStorage.getItem(e);
						if (t) return JSON.parse(t)
					}
					return null
				},
				o = e => {
					((e, t) => {
						window.sessionStorage && window.sessionStorage.setItem(e, JSON.stringify(t))
					})(s.COMMENT_BEFORE_SIGNUP_STORAGE, e)
				},
				a = () => r(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				i = () => (e => {
					window.sessionStorage && window.sessionStorage.removeItem(e)
				})(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				d = () => {
					return !!r(s.COMMENT_BEFORE_SIGNUP_STORAGE)
				}
		},
		"./src/reddit/helpers/styles/mixins/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				o = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				a = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				i = n("./src/reddit/models/Theme/index.ts"),
				d = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				c = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				l = n.n(c);
			const u = {},
				m = e => Object(i.g)(Object(d.a)(e).post, Object(d.a)(e).backgroundImage, Object(d.a)(e).backgroundImagePosition),
				p = (e, t) => {
					if (e) {
						if (e.postBackgroundImage) return {
							background: Object(i.g)(e.postBackgroundColor || Object(d.a)(t).post, e.postBackgroundImage, Object(d.a)(t).backgroundImagePosition)
						};
						if (e.postBackgroundColor) return {
							background: Object(i.g)(e.postBackgroundColor, null, null)
						}
					}
					return {
						background: m(t)
					}
				},
				b = e => Object(s.k)(.2, e),
				h = e => e && e.postBackgroundColor ? {
					backgroundColor: b(e.postBackgroundColor)
				} : u,
				f = e => e.isActive ? l.a.mIsActive : void 0,
				g = e => {
					const t = Object(o.a)(Object(r.a)(e), a.a.actionIcon, a.b.actionIcon);
					return {
						color: t,
						cursor: "pointer",
						fill: t
					}
				}
		},
		"./src/reddit/helpers/styles/mixins/loading.m.less": function(e, t, n) {
			e.exports = {
				loadingBackground: "fzTkuBRFT8iIn1XnJX_Yn",
				"m-loading": "_34yMY7-6MNnz3utfjExvIq",
				mLoading: "_34yMY7-6MNnz3utfjExvIq",
				gradientAnimation: "vnt666wwqSK5qL63sBn9P",
				loadingBar: "_3giTODNeZ-Po90u8Ghs4aI",
				loadingContainer: "VRC9QT7CgUxvhK0ceQSrn"
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/reddit/helpers/styles/mixins/loading.m.less"),
				o = n.n(r);
			const a = e => {
					let {
						isLoading: t
					} = e;
					return Object(s.a)(o.a.loadingBackground, {
						[o.a["m-loading"]]: t
					})
				},
				i = e => Object(s.a)(o.a.loadingBar, a(e))
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var s = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function r(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(s.a)(e).post
			}
		},
		"./src/reddit/helpers/styles/smartTextColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/models/NewStructuredStyles/index.ts");
			const o = e => Object(s.b)(e) < .6;

			function a(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a.bodyText,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r.b.bodyText;
				return o(e) ? n : t
			}
		},
		"./src/reddit/helpers/tabBadging/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s = n("./src/config.ts");
			const r = `${s.a.assetPath}/img/favicon/badged-favicon-32x32.png`,
				o = `${s.a.assetPath}/img/favicon/badged-favicon-16x16.png`,
				a = `${s.a.assetPath}/img/favicon/favicon-32x32.png`,
				i = `${s.a.assetPath}/img/favicon/favicon-16x16.png`,
				d = "badgeCountSync",
				c = e => window.document.querySelector(`link[href="${e}"]`),
				l = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					const t = c(e ? a : r),
						n = c(e ? i : o);
					t && n && (t.href = e ? r : a, n.href = e ? o : i)
				},
				u = e => {
					navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
						command: d,
						badgeCounts: e
					})
				}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s);
			const o = e => r()(e).sort((t, n) => {
					const s = e[t.tag.id].tag.text.toLowerCase(),
						r = e[n.tag.id].tag.text.toLowerCase();
					return s < r ? -1 : s > r ? 1 : 0
				}),
				a = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const e = document.body.dataset.previousOverflow;
					if (!e) return;
					document.body.removeAttribute("data-previous-overflow");
					const t = document.getElementById(s.d);
					document.body.style.overflow = e, document.body.style.marginRight = "", t && (t.style.marginRight = "")
				},
				a = () => {
					if (document.body.dataset.previousOverflow) return;
					const e = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = e, r || (r = d(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const t = document.getElementById(s.d);
					t && (t.style.marginRight = `${r}px`)
				},
				i = e => {
					e ? o() : a()
				},
				d = e => {
					const t = e.getBoundingClientRect();
					return window.innerWidth - (t.left + t.right)
				},
				c = e => {
					if (!e || !document.body) return 0;
					const t = d(document.body),
						n = e.offsetWidth - e.scrollWidth;
					return t || n
				}
		},
		"./src/reddit/helpers/trackers/ads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/localStorage/index.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, n) => r => ({
					source: "post",
					action: "view",
					noun: "programmatic_ad",
					...o.n(r),
					subreddit: o.hb(r),
					programmatic: {
						adUnit: null !== e && null !== t ? `DESKTOP ${e}x${t} ${n}` : `DESKTOP ${n}`,
						count: 1,
						type: s.f.SWITCH_HOUSE_AD
					}
				}),
				i = (e, t) => {
					t && (Object(r.Ab)(e.postId), Object(r.Jb)(t)), e.impressionIdStr ? Object(r.Bb)(e.impressionIdStr) : e.impressionId && Object(r.Bb)(e.impressionId)
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "k", (function() {
				return _
			}));
			var s = n("./src/reddit/constants/blade.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => n => ({
					...r.n(n),
					source: s.c.Appearance,
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: t
					}),
					subreddit: r.hb(n)
				}),
				a = e => o("save_style", e),
				i = e => o("cancel_style", e),
				d = e => t => ({
					source: s.c.Structure,
					action: "click",
					noun: e,
					screen: r.Z(t),
					subreddit: r.hb(t)
				}),
				c = e => t => ({
					source: s.c.Appearance,
					action: "click",
					noun: e,
					screen: r.Z(t),
					subreddit: r.hb(t)
				}),
				l = (e, t) => n => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: s.f[t]
					}),
					screen: r.Z(n),
					subreddit: r.hb(n)
				}),
				u = e => t => ({
					source: s.g[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(t, {
						paneName: s.f[e]
					}),
					screen: r.Z(t),
					subreddit: r.hb(t)
				}),
				m = e => ({
					screen: r.Z(e),
					subreddit: r.hb(e)
				}),
				p = () => e => ({
					source: s.c.Appearance,
					action: "view",
					noun: "blade",
					...m(e)
				}),
				b = e => t => ({
					source: s.a[e],
					action: "click",
					noun: s.b[e],
					...m(t)
				}),
				h = () => e => ({
					source: s.c.Appearance,
					action: "click",
					noun: "back",
					...m(e)
				}),
				f = e => t => ({
					source: s.c.PostFlairManagement,
					action: "click",
					noun: e,
					...m(t)
				}),
				g = (e, t) => ({
					...r.n(e),
					...f(t)(e)
				}),
				_ = e => t => ({
					source: s.c.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: r.Z(t),
					subreddit: r.hb(t),
					userSubreddit: r.rb(t)
				})
		},
		"./src/reddit/helpers/trackers/comment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => {
					let {
						state: t,
						commentId: n,
						collapsed: o
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "view",
						noun: o ? "collapsed_comment" : "comment",
						...r.n(t),
						profile: r.R(t),
						post: r.I(t, n),
						media: r.B(t, n),
						subreddit: r.hb(t),
						comment: r.h(t, n)
					})
				},
				a = e => {
					let {
						state: t,
						commentId: n,
						collapsed: o
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "consume",
						noun: o ? "collapsed_comment" : "comment",
						...r.n(t),
						profile: r.R(t),
						post: r.I(t, n),
						media: r.B(t, n),
						subreddit: r.hb(t),
						comment: r.h(t, n)
					})
				},
				i = e => t => ({
					source: "online_presence",
					action: "view",
					noun: "user",
					user: r.pb(t),
					subreddit: r.hb(t),
					post: r.I(t, e),
					actionInfo: r.d(t),
					app: r.f(t),
					referrer: r.W(t),
					session: r.db(t)
				})
		},
		"./src/reddit/helpers/trackers/commentsChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "g", (function() {
				return O
			})), n.d(t, "h", (function() {
				return x
			}));
			var s = n("./src/lib/makeCommentsPageKey/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/comments.ts"),
				a = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				d = n("./src/telemetry/models/Event.ts");
			const c = (e, t) => ({
					...Object(i.n)(e),
					subreddit: Object(i.hb)(e),
					profile: Object(i.R)(e),
					post: Object(i.I)(e, t),
					comment: Object(i.h)(e, t)
				}),
				l = (e, t) => {
					const n = Object(a.b)(e, {
							commentId: t
						}),
						r = n && Object(s.a)(n.postId);
					if (!n || !r) return null;
					const d = {
							commentId: t,
							commentsPageKey: r
						},
						c = t && r && Object(o.j)(e, d) || 0;
					return Object(i.y)(e, void 0, {
						depth: c
					})
				},
				u = e => {
					var t;
					return null !== (t = e.split("chat_reaction_")[1]) && void 0 !== t ? t : ""
				},
				m = (e, t) => n => ({
					action: "load",
					noun: e,
					post: Object(i.I)(n, t),
					source: d.b.ChatView,
					subreddit: Object(i.hb)(n)
				}),
				p = (e, t) => n => ({
					...c(n, t),
					source: "live_post",
					action: r.c.CLICK,
					noun: e,
					actionInfo: {
						reason: "live_post",
						pageType: "actions_menu"
					},
					listing: l(n, t)
				}),
				b = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "last_message"
				}),
				h = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.SUBMIT,
					noun: "reply",
					post: Object(i.I)(t, e),
					comment: Object(i.h)(t, e),
					actionInfo: Object(i.d)(t, {
						reason: "live_post",
						type: "live_post"
					})
				}),
				f = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLICK,
					noun: "comment",
					actionInfo: Object(i.d)(t, {
						pageType: "user_mention",
						reason: "live_post",
						type: "live_post"
					})
				}),
				g = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "warning",
					post: Object(i.I)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				_ = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLOSE,
					noun: "warning",
					post: Object(i.I)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				v = e => t => ({
					...c(t, e),
					source: "global",
					action: r.c.VIEW,
					noun: "screen",
					actionInfo: {
						reason: "live_post",
						pageType: "given_awards_list"
					},
					listing: l(t, e)
				}),
				O = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.CLICK,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				}),
				x = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.DELETE,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				})
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "h", (function() {
				return x
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/comments.ts"),
				i = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/index.ts");
			const l = e => {
					const t = Object(i.o)(e);
					return {
						source: "comment_composer",
						action: s.c.CLICK,
						...Object(d.n)(e),
						screen: Object(d.Z)(e),
						subreddit: Object(d.hb)(e),
						post: t ? Object(d.I)(e, t) : null,
						profile: Object(d.R)(e),
						correlationId: Object(r.c)(r.a.CommentComposer)
					}
				},
				u = async (e, t, s, r) => {
					const o = {
							commentId: r,
							commentsPageKey: s
						},
						i = r && Object(a.j)(e, o) || 0,
						{
							getFlairData: u
						} = await n.e("getFlairData").then(n.bind(null, "./src/reddit/helpers/trackers/features/getFlairData.ts"));
					return Object(c.a)({
						noun: "comment",
						...l(e),
						comment: r ? Object(d.h)(e, r) : null,
						listing: Object(d.y)(e, void 0, {
							depth: i
						}),
						commentComposer: {
							editorMode: t
						},
						userFlair: u(e)
					})
				}, m = (e, t, n, s) => {
					const r = l(e);
					return Object(c.a)({
						...r,
						actionInfo: {
							...r.actionInfo,
							reason: "karma_rate_limit"
						},
						source: "backend",
						action: "error",
						noun: "comment",
						comment: {
							bodyText: t,
							parentId: s,
							postId: n
						}
					})
				}, p = e => Object(c.a)({
					noun: "cancel",
					...l(e)
				}), b = (e, t) => {
					t === o.c.replyToPost && Object(c.a)({
						noun: "input",
						...l(e)
					})
				}, h = (e, t) => Object(c.a)({
					source: "comment",
					noun: "delete",
					action: "click",
					...Object(d.n)(t),
					screen: Object(d.Z)(t),
					subreddit: Object(d.hb)(t),
					post: Object(d.I)(t, e)
				}), f = e => Object(c.a)({
					noun: "edit",
					...l(e)
				}), g = e => Object(c.a)({
					noun: "save_edit",
					...l(e)
				}), _ = (e, t) => n => {
					const s = "image_upload" === e || "video_upload" === e;
					return {
						...l(n),
						noun: s ? e : "text_option",
						commentComposer: {
							textType: e,
							finalStatus: t ? "on" : "off"
						}
					}
				}, v = () => e => ({
					...l(e),
					action: "open",
					noun: "gif_tooltip"
				}), O = e => t => ({
					...l(t),
					action: "change",
					noun: "gif_tooltip_search",
					search: {
						query: e
					}
				}), x = () => e => ({
					...l(e),
					action: "select",
					noun: "gif_tooltip_result"
				})
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			}));
			var s = n("./src/reddit/models/Gold/Award.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				a = n("./src/reddit/helpers/trackers/gild.ts");
			const i = e => ({
					...r.n(e),
					screen: r.Z(e),
					subreddit: r.hb(e),
					userSubreddit: r.rb(e)
				}),
				d = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === s.f.Moderator,
					isTemporatyAward: !!e.endsAt,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0,
					type: Object(a.getAwardTypeFromAward)(e)
				}),
				c = () => e => ({
					...i(e),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create"
				}),
				l = e => t => ({
					...i(t),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? d(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				u = (e, t, n) => s => ({
					...i(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n
				}),
				m = (e, t, n, s) => r => ({
					...i(r),
					source: "create_award",
					action: "upload",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "image",
					actionInfo: s ? {
						reason: s
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: n,
						url: e,
						width: t.width
					} : null
				}),
				p = (e, t, n) => s => ({
					...i(s),
					source: "create_award",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: n ? d(n) : null
				}),
				b = (e, t, n) => s => ({
					...i(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n ? d(n) : null
				}),
				h = (e, t, n) => s => ({
					...i(s),
					source: "awards",
					action: "click",
					noun: n,
					goldPurchase: d(e),
					profile: r.S(s, t),
					subreddit: r.ib(s, t)
				}),
				f = (e, t) => h(e, t, "disable_in_community"),
				g = (e, t) => h(e, t, "enable_in_community")
		},
		"./src/reddit/helpers/trackers/communitySettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "c", (function() {
				return v
			}));
			var s = n("./node_modules/lodash/snakeCase.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const i = {
					contentOptions: "link_type",
					contentVisible: "allow_top",
					subredditType: "type",
					welcomeMessageText: "welcome_message"
				},
				d = {
					allowChatPostCreation: o.hc.Posts,
					allowDiscovery: o.hc.Safety,
					allowGalleries: o.hc.Posts,
					allowImages: o.hc.Posts,
					allowPolls: o.hc.Posts,
					allowPostCrossposts: o.hc.Posts,
					collapseDeletedComments: o.hc.Posts,
					commentScoreHideMins: o.hc.Posts,
					contentOptions: o.hc.Posts,
					contentVisible: o.hc.Safety,
					crowdControlChatLevel: o.hc.Safety,
					crowdControlPostLevel: o.hc.Safety,
					crowdControlLevel: o.hc.Safety,
					crowdControlFilter: o.hc.Safety,
					crowdControlMode: o.hc.Safety,
					disableContributorRequests: o.hc.Community,
					excludeBannedModqueue: o.hc.Safety,
					over18: o.hc.Community,
					publicDescription: o.hc.Community,
					restrictCommenting: o.hc.Community,
					restrictPosting: o.hc.Community,
					spamComments: o.hc.Posts,
					spamLinks: o.hc.Posts,
					spamSelfposts: o.hc.Posts,
					spoilersEnabled: o.hc.Posts,
					subredditType: o.hc.Community,
					suggestedCommentSort: o.hc.Posts,
					toxicityThresholdChatLevel: o.hc.Safety,
					welcomeMessageEnabled: o.hc.Community,
					welcomeMessageText: o.hc.Community,
					wikiEditAge: o.hc.Wikis,
					wikiEditKarma: o.hc.Wikis,
					wikimode: o.hc.Wikis
				},
				c = {
					[o.hc.Community]: "community_settings_details",
					[o.hc.Notifications]: "community_settings_notifications",
					[o.hc.Safety]: "community_settings_safety",
					[o.hc.Posts]: "community_settings_content",
					[o.hc.Wikis]: "community_settings_wiki",
					[o.hc.ContentTag]: "content_tag"
				},
				l = e => i[e] || r()(e),
				u = e => {
					const t = d[e];
					return t && c[t] || "community_settings"
				};

			function m(e) {
				return "object" == typeof e ? JSON.stringify(e) : String(e)
			}
			const p = (e, t, n) => s => ({
					source: u(e),
					action: "click",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: a.hb(s),
					...a.n(s)
				}),
				b = (e, t, n) => s => ({
					source: u(e),
					action: "save",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: a.hb(s),
					...a.n(s)
				}),
				h = e => t => ({
					source: "community_settings",
					action: "click",
					noun: c[e],
					...a.n(t)
				}),
				f = e => t => ({
					source: c[e],
					action: "click",
					noun: "r2_community_settings",
					...a.n(t)
				}),
				g = (e, t, n, s) => r => ({
					...a.n(r),
					source: "mod_tools",
					action: e,
					noun: t,
					...void 0 !== n && void 0 !== s && {
						setting: {
							value: String(n),
							oldValue: String(s)
						}
					},
					subreddit: a.hb(r),
					actionInfo: a.d(r, {
						reason: "welcome_message"
					})
				}),
				_ = (e, t) => n => {
					var s;
					return {
						...a.n(n),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "click",
						noun: e,
						subreddit: a.hb(n),
						subredditId: null === (s = a.hb(n)) || void 0 === s ? void 0 : s.id,
						actionInfo: {
							settingValue: String(t)
						}
					}
				},
				v = (e, t, n) => s => {
					var r;
					return {
						...a.n(s),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "save",
						noun: e,
						subreddit: a.hb(s),
						subredditId: null === (r = a.hb(s)) || void 0 === r ? void 0 : r.id,
						setting: {
							value: String(t),
							oldValue: String(n)
						},
						actionInfo: {
							settingValue: String(t)
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return _
			}));
			var s, r = n("./src/reddit/selectors/tags.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(s || (s = {}));
			const i = (e, t, n) => {
					const s = Object(r.x)(e, {
						subredditId: t
					});
					return !!s && s.id === n
				},
				d = (e, t) => Object(r.u)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					} = e;
					return n.push(t.tag.id), s.push(t.tag.text), r.push(t.tag.type), {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				c = (e, t, n) => {
					if (!n.id) return {
						content: n.displayText
					};
					const s = Object(r.b)(e)[n.id] || Object(r.d)(e, {
						subredditId: t
					})[n.id];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: i(e, t, s.id)
					} : null
				},
				l = (e, t, n) => {
					if (!n) return null;
					const s = Object(r.b)(e)[n] || Object(r.d)(e, {
						subredditId: t
					})[n];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: i(e, t, s.id)
					} : null
				},
				u = (e, t, n) => ({
					...o.n(e),
					subreddit: {
						...o.hb(e) || {},
						id: t,
						...d(e, t)
					},
					source: n.context,
					action: "click"
				}),
				m = (e, t, n) => {
					Object(a.a)(((e, t, n) => ({
						...u(e, t.subredditId, n),
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: l(e, t.subredditId, t.tagId)
					}))(e, t, n))
				},
				p = (e, t, n, s) => {
					Object(a.a)({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "add_related_topic"
					})
				},
				b = (e, t, n, s) => {
					return !Object(r.i)(e, {
						subredditId: t
					}) && n.id ? Object(a.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_suggest"
					}))(e, t, n, s)) : n.id ? Object(a.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_complete"
					}))(e, t, n, s)) : Object(a.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_add_new"
					}))(e, t, n, s))
				},
				h = (e, t, n, s) => Object(a.a)({
					...u(e, t, s),
					topicTag: c(e, t, n),
					noun: "topic_remove"
				}),
				f = (e, t, n) => Object(a.a)({
					...u(e, t, n),
					noun: "topic_tag_field"
				}),
				g = (e, t, n) => Object(a.a)({
					...u(e, t, n),
					noun: n.context === s.communitySettings ? "save" : "save_community_topics"
				}),
				_ = (e, t, n, s) => {
					const r = u(e, t, s);
					Object(a.a)({
						...r,
						action: "view",
						noun: "error",
						actionInfo: {
							...r.actionInfo,
							reason: n
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/contentTag.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "l", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			}));
			const s = () => () => ({
					source: "content_tag",
					action: "view",
					noun: "verify_topics_module"
				}),
				r = () => () => ({
					source: "content_tag",
					action: "click",
					noun: "verify_topics_module"
				}),
				o = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_intro",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				a = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "start",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				i = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "mature_themes_prompt",
					actionInfo: {
						pageType: "survey_mature_themes"
					}
				}),
				d = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: e,
					actionInfo: {
						pageType: e
					}
				}),
				c = e => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "survey_answer",
					actionInfo: {
						pageType: e
					}
				}),
				l = (e, t) => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "next",
					actionInfo: {
						reason: t.join(),
						pageType: e
					}
				}),
				u = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "back",
					actionInfo: {
						pageType: e
					}
				}),
				m = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_summary",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				p = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "submit_survey",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				b = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_review",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				h = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "take_survey",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				f = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "message_modsupport",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				g = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "learn_more",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				})
		},
		"./src/reddit/helpers/trackers/creatorStats.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			}));
			var s = n("./src/reddit/components/CreatorStats/helpers.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const a = e => {
					switch (e) {
						case s.b.Available:
							return "insights_shown";
						case s.b.NotAvailableYet:
							return "not_enough_views";
						case s.b.NotAvailable:
							return "post_too_old";
						case s.b.Expired:
							return "insights_expired";
						default:
							return ""
					}
				},
				i = (e, t) => n => ({
					...Object(o.n)(n),
					action: r.c.VIEW,
					noun: "aggregate_stats",
					source: "creator_stats",
					subreddit: Object(o.hb)(n),
					post: Object(o.I)(n, e),
					userSubreddit: Object(o.rb)(n),
					actionInfo: Object(o.d)(n, {
						reason: a(t)
					})
				}),
				d = (e, t) => n => ({
					...Object(o.n)(n),
					action: r.c.CLICK,
					noun: e,
					source: "creator_stats",
					post: Object(o.I)(n, t),
					subreddit: Object(o.hb)(n),
					userSubreddit: Object(o.rb)(n)
				}),
				c = e => {
					switch (e) {
						case s.b.Available:
							return "stats";
						case s.b.NotAvailableYet:
							return "not_enough_views";
						case s.b.NotAvailable:
						case s.b.Expired:
							return "no_data";
						case s.b.Quarantined:
							return "quarantined";
						default:
							return ""
					}
				},
				l = e => t => ({
					...Object(o.n)(t),
					action: r.c.CLICK,
					noun: "post_stats",
					source: "post",
					actionInfo: Object(o.d)(t, {
						pageType: "profile"
					}),
					post: Object(o.I)(t, e, void 0, 0),
					profile: Object(o.R)(t)
				}),
				u = (e, t, n) => s => ({
					...Object(o.n)(s),
					action: r.c.LOAD,
					noun: "insights",
					source: "post_stats",
					actionInfo: Object(o.d)(s, {
						reason: c(t)
					}),
					post: Object(o.I)(s, e, void 0, n)
				}),
				m = (e, t, n, s, a, i) => d => ({
					...Object(o.n)(d),
					action: r.c.CLICK,
					noun: "community",
					source: "post_stats",
					actionInfo: Object(o.d)(d, {
						pageType: "post_stats",
						reason: "stats"
					}),
					post: Object(o.I)(d, e, void 0, i),
					subreddit: Object(o.hb)(d),
					outbound: {
						postId: n,
						url: t,
						subredditId: s,
						subredditName: a
					}
				}),
				p = (e, t, n) => s => ({
					...Object(o.n)(s),
					action: r.c.CLICK,
					noun: "share",
					source: "post_stats",
					actionInfo: Object(o.d)(s, {
						pageType: "post_stats",
						reason: c(t)
					}),
					post: Object(o.I)(s, e, void 0, n),
					subreddit: Object(o.hb)(s)
				})
		},
		"./src/reddit/helpers/trackers/emailInvite.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					action: "click",
					noun: "invite_via_email",
					...r.n(t),
					subreddit: r.hb(t),
					actionInfo: r.d(t),
					correlationId: Object(s.d)(s.a.SubredditCreation, !1)
				}),
				a = () => e => ({
					source: "email_invite_painted_door",
					action: "view",
					noun: "modal",
					...r.n(e),
					subreddit: r.hb(e),
					actionInfo: r.d(e),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				i = e => t => ({
					source: "email_invite_painted_door",
					action: "click",
					noun: e,
					...r.n(t),
					subreddit: r.hb(t),
					actionInfo: r.d(t),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				})
		},
		"./src/reddit/helpers/trackers/features/powerupsFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/selectors/gold/powerups/flairs.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, n) => i => {
					const d = Object(r.e)(i, {
							commentId: e
						}),
						c = Object(o.f)(i, {
							subredditId: t,
							userId: n
						});
					return {
						source: "meta",
						action: "hover",
						noun: "achieve_flair",
						...a.n(i),
						subreddit: {
							id: t
						},
						userFlair: {
							id: null == d ? void 0 : d.templateId,
							title: d ? Object(s.g)(d) : void 0,
							achievementFlairId: null == c ? void 0 : c.type,
							achievementFlairTitle: null == c ? void 0 : c.name
						}
					}
				},
				d = () => e => ({
					source: "powerups",
					action: "click",
					noun: "view_your_achievements",
					...a.n(e)
				})
		},
		"./src/reddit/helpers/trackers/feed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/index.ts");
			const o = e => t => Object(r.a)({
					...s.n(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "load",
					noun: "serving",
					feed: s.q(t)
				}),
				a = e => t => Object(r.a)({
					...s.n(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "fail",
					noun: "serving",
					feed: s.q(t)
				})
		},
		"./src/reddit/helpers/trackers/freeAwardOffer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/trackers/goldPayment.ts"),
				o = n("./src/reddit/models/Gold/ProductOffer.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const i = e => ({
					...Object(r.h)(e, {
						offerContext: o.a.StorefrontFreeAward
					}),
					correlationId: Object(s.d)(s.a.GoldPayment, !1),
					profile: a.R(e),
					subreddit: a.hb(e)
				}),
				d = () => e => ({
					source: "free_award_offer",
					action: "view",
					noun: "page",
					...i(e)
				}),
				c = e => t => ({
					source: "free_award_offer",
					action: "click",
					noun: e,
					...i(t)
				}),
				l = () => e => ({
					source: "tooltip",
					action: "view",
					noun: "try_free_award",
					...i(e)
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return u
			})), n.d(t, "clickGildEvent", (function() {
				return b
			})), n.d(t, "clickRpanGiveAward", (function() {
				return h
			})), n.d(t, "clickAddAward", (function() {
				return f
			})), n.d(t, "clickHideAward", (function() {
				return g
			})), n.d(t, "clickConfirmHideAward", (function() {
				return _
			})), n.d(t, "clickCancelHideAward", (function() {
				return v
			})), n.d(t, "clickAwardReportFlow", (function() {
				return x
			})), n.d(t, "clickCancelAwardReportFlow", (function() {
				return E
			})), n.d(t, "clickFlagAwardUsage", (function() {
				return y
			})), n.d(t, "clickCancelFlagAwardUsage", (function() {
				return j
			})), n.d(t, "clickConfirmFlagAwardUsage", (function() {
				return C
			})), n.d(t, "clickReportAward", (function() {
				return k
			})), n.d(t, "clickCancelReportAward", (function() {
				return I
			})), n.d(t, "clickConfirmReportAward", (function() {
				return S
			})), n.d(t, "viewGildModalEvent", (function() {
				return w
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return T
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return N
			})), n.d(t, "clickMessageInputEvent", (function() {
				return P
			})), n.d(t, "typeMessageInputEvent", (function() {
				return R
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return A
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return M
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return D
			})), n.d(t, "clickGetPremiumEvent", (function() {
				return L
			})), n.d(t, "clickAddCoinsButtonEvent", (function() {
				return F
			})), n.d(t, "clickNextButtonEvent", (function() {
				return U
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return B
			})), n.d(t, "viewKarmaSuccessEvent", (function() {
				return G
			})), n.d(t, "clickFilterEvent", (function() {
				return H
			})), n.d(t, "clickNextFiltersEvent", (function() {
				return W
			})), n.d(t, "clickPreviousFiltersEvent", (function() {
				return q
			}));
			var s = n("./src/reddit/helpers/trackers/commentsChat.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/models/GoldPurchase.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/helpers/isComment.ts"),
				l = n("./src/reddit/selectors/gild.ts");
			const u = e => e.awardType === r.f.Global && e.awardSubType === r.d.Appreciation ? i.GoldPurchaseType.GidAppreciation : e.awardType === r.f.Global && e.awardSubType === r.d.Premium ? i.GoldPurchaseType.GidPremium : e.awardSubType === r.d.Group ? i.GoldPurchaseType.GidGroup : e.awardType === r.f.Community ? i.GoldPurchaseType.GidCommunity : e.awardType === r.f.Moderator ? i.GoldPurchaseType.GidMod : e.awardType === r.f.Global && e.awardSubType === r.d.Global ? i.GoldPurchaseType.GidGlobal : i.GoldPurchaseType.GidUnknown,
				m = (e, t) => ({
					awardId: e.id,
					awardName: e.name,
					isTemporaryAward: !!e.endsAt,
					numberCoinsToRecipient: e.coinReward,
					type: u(e),
					...t
				}),
				p = (e, t, n) => {
					const r = t && Object(o.f)(e, {
						commentId: t
					});
					return {
						...a.n(e),
						actionInfo: a.d(e, {
							reason: r ? "live_post" : void 0,
							...n
						}),
						comment: t ? a.h(e, t) : void 0,
						correlationId: Object(l.b)(e) || Object(d.d)(d.a.GildingFlow, !1),
						post: t ? a.I(e, t) : void 0,
						screen: a.Z(e),
						subreddit: a.hb(e),
						userSubreddit: a.rb(e),
						listing: t ? Object(s.i)(e, t) : void 0
					}
				},
				b = (e, t) => n => ({
					...p(n, e, t),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold",
					feed: a.q(n)
				}),
				h = e => t => ({
					...p(t, e),
					source: "stream_player",
					action: "click",
					noun: "give_gold"
				}),
				f = e => t => ({
					...p(t, e),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award",
					feed: a.q(t)
				}),
				g = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: m(e)
				}),
				_ = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: m(e)
				}),
				v = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: m(e)
				}),
				O = e => (t, n) => s => ({
					...p(s, n),
					source: Object(c.a)(n) ? "comment" : "post",
					action: "click",
					noun: e,
					goldPurchase: m(t)
				}),
				x = O("award_hovercard_report"),
				E = O("cancel_award_hovercard_report"),
				y = O("flag_award"),
				j = O("cancel_flag_award"),
				C = O("confirm_flag_award"),
				k = O("report_community_award"),
				I = O("cancel_report_community_award"),
				S = O("confirm_report_community_award"),
				w = (e, t, n) => s => ({
					...p(s, n),
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				T = (e, t, n) => s => ({
					...p(s, t),
					source: "give_gold",
					action: "click",
					noun: "award",
					goldPurchase: m(e, n)
				}),
				N = (e, t) => n => ({
					...p(n, t),
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				P = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				R = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				A = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				M = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				D = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				L = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				F = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "add_coins"
				}),
				U = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				B = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				G = e => {
					let {
						award: t,
						awardeeKarmaEarned: n,
						awarderKarmaEarned: s,
						numberCoins: r,
						thingId: o
					} = e;
					return e => ({
						...p(e, o),
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: {
							contentType: Object(c.a)(o) ? "comment" : "post",
							awardeeKarmaEarned: n,
							awarderKarmaEarned: s,
							numberCoins: r,
							...m(t)
						}
					})
				},
				H = e => t => ({
					...p(t),
					source: "give_gold",
					action: "click",
					noun: "filter",
					goldPurchase: {
						filterId: e.tag,
						filterName: e.content.markdown
					}
				}),
				W = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "next_filters"
				}),
				q = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "previous_filters"
				})
		},
		"./src/reddit/helpers/trackers/goldPayment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "j", (function() {
				return j
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Gold/ProductOffer.ts"),
				o = n("./src/reddit/selectors/gold/giveAwards.ts"),
				a = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				i = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/models/GoldPurchase.ts"),
				l = n("./src/telemetry/models/Payment.ts"),
				u = n("./src/reddit/helpers/trackers/gild.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/isComment.ts"),
				b = n("./src/reddit/helpers/trackers/communityAwards.ts");
			const h = (e, t) => {
					const {
						thingId: n,
						packageId: l
					} = t, h = !!n, f = o.b(e), g = f ? Object(u.getAwardTypeFromAward)(f) : null, _ = h ? g : i.o(e) ? c.GoldPurchaseType.Premium : c.GoldPurchaseType.Coins, v = n ? Object(p.a)(n) ? "comment" : "post" : void 0, O = l || i.t(e), x = [...Object(a.d)(e), ...Object(a.f)(e)].filter(e => e.mobileId === O)[0], E = t.offerContext || (f && 0 === f.coinPrice ? r.a.StorefrontFreeAward : Object(r.d)(x, h)), y = x ? Math.round(1e4 * (x.baselinePennies - x.pennies) / x.baselinePennies) / 100 : 0, j = x ? Math.round(1e4 * (x.coins - x.baselineCoins) / x.coins) / 100 : 0, C = x ? x.baselinePennies !== x.pennies ? `${y}_percent_price` : x.baselineCoins !== x.coins ? `${j}_percent_bonus` : void 0 : void 0, k = _ === c.GoldPurchaseType.Premium ? s.yb : x ? x.pennies : void 0;
					return {
						...d.n(e),
						comment: n ? d.h(e, n) : null,
						correlationId: i.r(e) || Object(m.d)(m.a.GoldPayment, !1),
						post: n ? d.I(e, n) : null,
						screen: d.Z(e),
						subreddit: n ? d.hb(e) : null,
						goldPurchase: {
							...f ? Object(b.a)(f) : null,
							type: _,
							gildedContent: h,
							contentType: v,
							numberCoins: x ? x.coins : void 0,
							offerContext: E,
							offerType: C
						},
						payment: {
							currency: "USD",
							amountInSmallestDenom: k
						},
						purchase: {
							priceMicros: k
						}
					}
				},
				f = (e, t, n) => s => ({
					...h(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					}),
					source: "gold_payment",
					action: "click",
					noun: "close"
				}),
				g = e => t => ({
					...h(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "paypal"
				}),
				_ = e => t => ({
					...h(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "continue_paypal"
				}),
				v = e => t => ({
					...h(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "credit_card"
				}),
				O = e => t => ({
					...h(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "complete_credit_card"
				}),
				x = (e, t) => n => ({
					...h(n, {
						packageId: e,
						offerContext: t
					}),
					source: "gold_payment",
					action: "click",
					noun: "confirm"
				}),
				E = e => t => ({
					...h(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "display",
					noun: "error"
				}),
				y = (e, t, n) => s => {
					const r = h(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					});
					return {
						...r,
						source: "gold_payment",
						action: "view",
						noun: "page",
						payment: {
							...r.payment,
							defaultOption: l.PaymentMethod.Paypal
						},
						goldPurchase: {
							...r.goldPurchase,
							source: e ? c.GiveGold : i.o(s) ? c.PremiumMarketing : c.CoinsMarketing
						}
					}
				},
				j = e => t => {
					var n;
					const s = h(t, {
						thingId: e
					});
					return {
						...s,
						source: "gold_payment",
						action: "view",
						noun: "success",
						payment: {
							...s.payment,
							method: (null === (n = t.platform.currentPage) || void 0 === n ? void 0 : n.queryParams.thanks) ? l.PaymentMethod.Paypal : l.PaymentMethod.CreditCard
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/hotPotato.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
					...Object(r.n)(e),
					action: s.c.CLICK,
					noun: "preview",
					source: "hot_potato"
				}),
				a = () => e => ({
					...Object(r.n)(e),
					action: s.c.CLICK,
					noun: "hot_potato",
					source: "nav"
				}),
				i = () => e => ({
					...Object(r.n)(e),
					action: s.c.CLICK,
					noun: "hot_potato",
					source: "inbox"
				})
		},
		"./src/reddit/helpers/trackers/inbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "w", (function() {
				return m
			})), n.d(t, "t", (function() {
				return p
			})), n.d(t, "r", (function() {
				return b
			})), n.d(t, "s", (function() {
				return h
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "u", (function() {
				return v
			})), n.d(t, "v", (function() {
				return O
			})), n.d(t, "y", (function() {
				return x
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "x", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "z", (function() {
				return k
			})), n.d(t, "q", (function() {
				return I
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "n", (function() {
				return w
			})), n.d(t, "j", (function() {
				return T
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "g", (function() {
				return P
			}));
			var s, r, o, a, i, d, c = n("./src/reddit/constants/tracking.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				u = n("./src/telemetry/index.ts");
			! function(e) {
				e.Activity = "activity", e.Messages = "messages"
			}(s || (s = {})),
			function(e) {
				e.HideNotifications = "hide_notification", e.HideSubreddit = "hide_subreddit", e.BlockAwarder = "block_awarder", e.DecreaseSubredditUpdates = "disable_frequent"
			}(r || (r = {})),
			function(e) {
				e.MiniInbox = "mini_inbox", e.Inbox = "inbox"
			}(o || (o = {})),
			function(e) {
				e.Inbox = "inbox", e.Nav = "nav", e.Settings = "notification_app_settings"
			}(a || (a = {})),
			function(e) {
				e[e.FIRST = 1] = "FIRST", e[e.SECOND = 2] = "SECOND"
			}(i || (i = {})),
			function(e) {
				e.Confirm = "confirm"
			}(d || (d = {}));
			const m = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.VIEW,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				},
				p = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.VIEW,
						noun: "notification",
						source: "in_app_notification",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				},
				b = () => e => ({
					...l.n(e),
					action: c.c.RECEIVE,
					noun: "notification",
					source: "in_app_notification"
				}),
				h = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => {
						Object(u.a)({
							...l.n(e),
							action: "receive",
							noun: "inbox_notification",
							source: a.Inbox,
							inbox: {
								id: t,
								isClicked: n,
								isViewed: s
							},
							notification: {
								type: r
							},
							goldPurchase: {
								awardId: o
							}
						})
					}
				},
				f = e => {
					let {
						dnPromptAction: t
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "inbox_banner",
						source: "inbox",
						banner: {
							id: "inbox_dn_banner"
						},
						actionInfo: {
							pageType: "dn_prompt",
							type: t
						}
					})
				},
				g = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o,
						position: a,
						postId: i,
						subredditId: d
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						},
						actionInfo: {
							position: a
						},
						subreddit: d ? {
							id: d
						} : null,
						post: i ? {
							id: i
						} : null
					})
				},
				_ = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o,
						position: a,
						postId: i,
						subredditId: d
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "notification",
						source: "in_app_notification",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						},
						actionInfo: {
							position: a
						},
						subreddit: d ? {
							id: d
						} : null,
						post: i ? {
							id: i
						} : null
					})
				},
				v = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.VIEW,
						noun: "inbox",
						source: a.Inbox,
						inbox: {
							badgeCount: t,
							tab: n
						}
					})
				},
				O = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.VIEW,
						noun: "mini_inbox",
						source: a.Inbox,
						inbox: {
							badgeCount: t,
							tab: s.Activity
						}
					})
				},
				x = e => {
					let {
						badgeCount: t
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "inbox",
						source: a.Nav,
						inbox: {
							badgeCount: t
						}
					})
				},
				E = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "inbox_notification_overflow",
						source: a.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						}
					})
				},
				y = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.VIEW,
						noun: "inbox_notification_overflow",
						source: a.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				};
			var j;
			! function(e) {
				e.Cats = "cats", e.Memes = "memes", e.Karma = "karma_free_subs", e.PN_perms = "pn_perms", e.Email_perms = "email_perms"
			}(j || (j = {}));
			const C = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "overflow_option",
						source: a.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				k = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.UNDO,
						noun: "overflow_option",
						source: a.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				I = e => {
					let {
						actionInfoType: t
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "empty_state_cta",
						source: a.Inbox,
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				S = e => t => ({
					...l.n(t),
					action: c.c.CLICK,
					noun: "notification_app_settings",
					source: a.Inbox,
					actionInfo: {
						...l.d(t),
						pageType: e
					}
				}),
				w = () => e => ({
					...l.n(e),
					action: c.c.CLICK,
					noun: "see_all",
					source: a.Inbox,
					actionInfo: {
						...l.d(e),
						pageType: o.MiniInbox
					}
				}),
				T = () => e => ({
					...l.n(e),
					action: c.c.CLICK,
					noun: "messages",
					source: a.Inbox
				}),
				N = e => {
					let {
						isMiniInbox: t
					} = e;
					return e => ({
						...l.n(e),
						action: c.c.CLICK,
						noun: "mark_all_as_read",
						source: a.Inbox,
						actionInfo: t ? {
							...l.d(e),
							pageType: o.MiniInbox
						} : {}
					})
				},
				P = (e, t) => n => ({
					...l.n(n),
					action: c.c.CLICK,
					noun: "policy_banner",
					source: a.Inbox,
					actionInfo: {
						...l.d(n),
						pageType: e,
						type: t
					}
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s, r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(s || (s = {}));
			const a = e => ({
					subreddit: o.hb(e),
					userSubreddit: o.rb(e)
				}),
				i = e => ({
					source: "subreddit_tooltip",
					noun: s.SubredditInlineTooltip,
					action: r.c.VIEW,
					...a(e)
				}),
				d = e => ({
					source: "id_card",
					noun: s.EditSubredditIcon,
					action: r.c.CLICK,
					...a(e)
				}),
				c = e => ({
					source: "id_card",
					noun: s.EditSubredditDescription,
					action: r.c.CLICK,
					...a(e)
				}),
				l = (e, t) => n => ({
					source: "id_card",
					noun: s.SaveDescription,
					action: r.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					},
					...a(n)
				}),
				u = (e, t) => ({
					source: "id_card",
					noun: s.Error,
					action: r.c.VIEW,
					...a(e),
					...o.n(e),
					actionInfo: o.d(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/lightbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const d = e => ({
					profile: i.R(e),
					screen: i.Z(e),
					subreddit: i.hb(e)
				}),
				c = (e, t, n) => s => ({
					source: Object(a.i)(s) || n ? "post_lightbox" : "post_detail",
					action: "click",
					noun: t,
					...d(s),
					post: i.I(s, e)
				}),
				l = (e, t, n, s) => r => {
					const a = n ? i.h(r, n) : null,
						{
							sortToUse: d
						} = Object(o.a)(r, e);
					return {
						...c(e, t, s)(r),
						comment: a,
						listing: {
							sort: d
						}
					}
				},
				u = (e, t) => n => {
					const s = i.j(n);
					return s ? c(s.id, e, t)(n) : {
						source: Object(a.i)(n) || t ? "post_lightbox" : "post_detail",
						action: "click",
						noun: e,
						...d(n)
					}
				},
				m = (e, t) => n => Object(r.a)({
					...c(e, t)(n),
					...i.n(n)
				}),
				p = e => t => ({
					source: "id_card",
					action: s.c.CLICK,
					noun: e,
					...d(t),
					post: i.j(t),
					userSubreddit: i.rb(t)
				})
		},
		"./src/reddit/helpers/trackers/marketplace/claims.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = () => e => ({
					...Object(s.n)(e),
					source: "marketplace",
					action: "view",
					noun: "claim_post_unit"
				}),
				o = () => e => ({
					...Object(s.n)(e),
					source: "marketplace",
					action: "click",
					noun: "claim_post_unit"
				}),
				a = () => e => ({
					...Object(s.n)(e),
					source: "marketplace",
					action: "close",
					noun: "claim_post_unit"
				});
			var i;
			! function(e) {
				e.Profile = "profile", e.Hovercard = "hovercard"
			}(i || (i = {}));
			const d = e => t => {
				const n = Object(s.n)(t);
				return {
					...n,
					source: "marketplace",
					action: "view",
					noun: "product_detail_page",
					actionInfo: {
						...n.actionInfo,
						reason: e,
						pageType: "product_detail_page"
					}
				}
			}
		},
		"./src/reddit/helpers/trackers/modHub.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					screen: s.Z(e),
					subreddit: s.hb(e),
					profile: s.R(e),
					userSubreddit: s.rb(e)
				}),
				o = e => t => ({
					source: "mod_hub_nav",
					action: "click",
					noun: e,
					...r(t)
				}),
				a = () => e => ({
					source: "breadcrumb",
					action: "click",
					noun: "subreddit",
					...r(e)
				}),
				i = () => e => ({
					source: "id_card",
					action: "click",
					noun: "mod_hub_nav",
					...r(e)
				})
		},
		"./src/reddit/helpers/trackers/modNote.ts": function(e, t, n) {
			"use strict";
			n.d(t, "w", (function() {
				return i
			})), n.d(t, "r", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "x", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "y", (function() {
				return E
			})), n.d(t, "s", (function() {
				return y
			})), n.d(t, "n", (function() {
				return j
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "u", (function() {
				return k
			})), n.d(t, "t", (function() {
				return I
			})), n.d(t, "v", (function() {
				return S
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "c", (function() {
				return N
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => {
					var n, s, r, o, a, i, d, c, l, u, m;
					const {
						modNote: p,
						subredditId: b,
						userId: h,
						postId: f,
						commentId: g,
						subredditSearch: _,
						filteredType: v,
						filteredSubredditId: O
					} = t, x = g || (null === (s = null === (n = p) || void 0 === n ? void 0 : n.commentInfo) || void 0 === s ? void 0 : s.id), E = f || (null === (o = null === (r = p) || void 0 === r ? void 0 : r.postInfo) || void 0 === o ? void 0 : o.id);
					return {
						modnote: {
							type: null == p ? void 0 : p.itemType,
							content: null === (a = p) || void 0 === a ? void 0 : a.note,
							label: null === (d = null === (i = p) || void 0 === i ? void 0 : i.label) || void 0 === d ? void 0 : d.toLowerCase(),
							operatorId: null === (c = null == p ? void 0 : p.operator) || void 0 === c ? void 0 : c.id,
							subredditSearch: _,
							filteredType: null == v ? void 0 : v.toLowerCase(),
							filteredSubredditId: null == O ? void 0 : O.toLowerCase()
						},
						modAction: {
							targetUserId: h || (null === (l = null == p ? void 0 : p.user) || void 0 === l ? void 0 : l.id),
							action: null === (m = null === (u = p) || void 0 === u ? void 0 : u.actionType) || void 0 === m ? void 0 : m.toLowerCase()
						},
						...x ? {
							comment: {
								id: x,
								postId: E || "none"
							}
						} : null,
						...E ? {
							post: {
								id: E
							}
						} : null,
						subreddit: {
							id: b
						}
					}
				},
				a = "moderator",
				i = e => t => ({
					source: a,
					action: "view",
					noun: "modnote_quickaccess",
					correlationId: Object(s.d)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				d = e => t => {
					const n = {
						source: a,
						action: "close",
						noun: "modnote_quickaccess",
						correlationId: Object(s.c)(s.a.ModNotes),
						...r.n(t),
						...o(0, e)
					};
					return Object(s.b)(s.a.ModNotes), n
				},
				c = e => t => ({
					source: a,
					action: "click",
					noun: "relatedcontent_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				l = e => t => ({
					source: a,
					action: "click",
					noun: "relatedcontent_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				u = e => t => ({
					source: a,
					action: "click",
					noun: "relatedcontent_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				m = e => t => ({
					source: a,
					action: "click",
					noun: "expand_modlog_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				p = e => t => ({
					source: a,
					action: "click",
					noun: "expand_modlog_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				b = e => t => ({
					source: a,
					action: "click",
					noun: "expand_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				h = e => t => ({
					source: a,
					action: "click",
					noun: "username_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				f = e => t => ({
					source: a,
					action: "click",
					noun: "mod_username_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				g = e => t => ({
					source: a,
					action: "click",
					noun: "username_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				_ = e => t => ({
					source: a,
					action: "view",
					noun: "user_profile_hovercard",
					correlationId: Object(s.d)(s.a.ModNotes, !1),
					...r.n(t),
					...o(0, e)
				}),
				v = e => t => ({
					source: a,
					action: "click",
					noun: "add_note_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				O = e => t => ({
					source: a,
					action: "click",
					noun: "user_mod_log_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				x = e => t => ({
					source: a,
					action: "click",
					noun: "send_modmail_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				E = e => t => ({
					source: a,
					action: "view",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				y = e => t => ({
					source: a,
					action: "close",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				j = e => t => ({
					source: a,
					action: "click",
					noun: "type_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				C = e => t => ({
					source: a,
					action: "click",
					noun: "subreddit_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				k = e => t => ({
					source: a,
					action: "select",
					noun: "type_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				I = e => t => ({
					source: a,
					action: "select",
					noun: "subreddit_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				S = e => t => ({
					source: a,
					action: "submit",
					noun: "submit_note_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				w = e => t => ({
					source: a,
					action: "click",
					noun: "delete_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				T = e => t => ({
					source: a,
					action: "click",
					noun: "cancel_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				}),
				N = e => t => ({
					source: a,
					action: "click",
					noun: "delete_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.n(t),
					...o(0, e)
				})
		},
		"./src/reddit/helpers/trackers/modTools.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return a
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "h", (function() {
				return v
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: Object(r.Z)(e),
					profile: Object(r.R)(e),
					subreddit: Object(r.hb)(e),
					userSubreddit: Object(r.rb)(e)
				}),
				a = e => t => ({
					source: "nav",
					action: "click",
					noun: e ? "mod_mode_on" : "mod_mode_off",
					...o(t)
				}),
				i = (e, t) => n => ({
					source: "post_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					...o(n)
				}),
				d = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					...o(n)
				}),
				c = (e, t) => n => ({
					source: "comment",
					action: s.c.CLICK,
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					actionInfo: {
						pageType: "chat_live_post"
					},
					...o(n)
				}),
				l = (e, t) => n => ({
					source: "comment",
					action: s.c.UNDO,
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					...o(n)
				}),
				u = (e, t) => n => ({
					source: "comment_overflow_menu",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					...o(n)
				}),
				m = (e, t) => n => ({
					source: "mod_distinguish_menu",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					...o(n)
				}),
				p = (e, t) => n => ({
					source: "comment_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					comment: Object(r.h)(n, t),
					...o(n)
				}),
				b = (e, t) => n => ({
					source: "comment_report_menu",
					action: "click",
					noun: e,
					comment: Object(r.h)(n, t),
					post: Object(r.I)(n, t),
					...o(n)
				}),
				h = (e, t) => n => ({
					source: "post_report_menu",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					...o(n)
				}),
				f = (e, t) => n => ({
					source: "post",
					action: "click",
					noun: e,
					post: Object(r.I)(n, t),
					subreddit: Object(r.kb)(n, t)
				}),
				g = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					comment: Object(r.h)(n, t),
					post: Object(r.I)(n, t),
					subreddit: Object(r.kb)(n, t)
				}),
				_ = (e, t, n, s) => o => ({
					source: e ? "comment" : "post",
					action: "click",
					noun: t ? "unsnooze_reporter" : "snooze_reporter",
					post: Object(r.I)(o, n),
					subreddit: Object(r.kb)(o, n),
					actionInfo: {
						reason: s
					},
					...e && {
						comment: Object(r.h)(o, n)
					}
				}),
				v = () => e => ({
					...o(e),
					source: "modqueue",
					noun: "content_type_live_post",
					action: "view",
					actionInfo: {
						pageType: "chat_live_post"
					}
				})
		},
		"./src/reddit/helpers/trackers/moderationPages.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: r.Z(e),
					profile: r.R(e),
					subreddit: r.hb(e)
				}),
				a = e => {
					switch (e) {
						case s.gc.Banned:
							return "banned";
						case s.gc.Muted:
							return "muted";
						case s.gc.Contributors:
							return "contributors";
						case s.gc.Moderators:
							return "modmanagement";
						case s.gc.Removal:
							return "set_removal_reasons";
						case s.gc.CommunitySettings:
							return "edit";
						default:
							return e
					}
				},
				i = (e, t) => n => ({
					source: a(t),
					noun: e,
					action: "click",
					...o(n)
				}),
				d = e => t => ({
					source: a(e),
					noun: "hover_user_hovercard",
					action: "view",
					...o(t)
				})
		},
		"./src/reddit/helpers/trackers/notifications.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "o", (function() {
				return y
			})), n.d(t, "h", (function() {
				return j
			})), n.d(t, "g", (function() {
				return C
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/telemetry/models/Event.ts");
			var a;
			! function(e) {
				e.FREQUENT = "frequent", e.LOW = "low", e.OFF = "off"
			}(a || (a = {}));
			const i = e => ({
					...s.n(e),
					noun: "desktop_notification_permissions"
				}),
				d = e => e ? "enable" : "disable",
				c = e => {
					Object(r.a)({
						...i(e),
						action: o.c.View,
						source: "popup"
					})
				},
				l = e => {
					Object(r.a)({
						...i(e),
						action: o.c.Allow,
						source: "popup"
					})
				},
				u = e => {
					Object(r.a)({
						...i(e),
						action: o.c.Block,
						source: "popup"
					})
				},
				m = e => {
					Object(r.a)({
						...i(e),
						action: o.c.Close,
						source: "popup"
					})
				},
				p = (e, t, n) => ({
					...s.n(e),
					actionInfo: s.d(e, {
						success: t,
						reason: n
					}),
					noun: "push_token"
				}),
				b = e => {
					Object(r.a)({
						...p(e, !0),
						action: o.c.Request,
						source: "notification"
					})
				},
				h = e => {
					Object(r.a)({
						...p(e, !0),
						action: o.c.Register,
						source: "notification"
					})
				},
				f = (e, t) => {
					Object(r.a)({
						...p(e, !1, t),
						action: o.c.Bail,
						source: "notification"
					})
				},
				g = e => ({
					...s.n(e),
					noun: "push_notification"
				}),
				_ = e => ({
					...g(e),
					notification: s.E(e, void 0, void 0),
					action: void 0,
					source: "notification",
					correlationId: void 0
				}),
				v = (e, t) => n => ({
					...s.n(n),
					action: d(e),
					email: {
						type: t
					},
					noun: "email",
					source: "email_app_settings"
				}),
				O = (e, t) => n => ({
					...s.n(n),
					action: d(e),
					notification: {
						type: t
					},
					noun: "notification",
					source: "notification_app_settings"
				}),
				x = e => t => ({
					...s.n(t),
					source: "email_app_settings",
					action: d(e),
					noun: "email",
					notification: {
						type: "all"
					}
				}),
				E = (e, t, n) => r => ({
					...s.n(r),
					action: "set_frequency",
					noun: n,
					source: "community_notifications",
					subreddit: {
						id: e,
						name: t.toLowerCase()
					}
				}),
				y = () => e => ({
					...s.n(e),
					action: o.c.View,
					noun: "screen",
					source: "global",
					actionInfo: {
						pageType: "community_alerts"
					}
				}),
				j = () => e => ({
					...s.n(e),
					action: "click",
					noun: "desktop_notification_permissions",
					source: "overlay"
				}),
				C = () => e => ({
					...s.n(e),
					action: "auto_dismiss",
					noun: "desktop_notification_permissions",
					source: "overlay"
				})
		},
		"./src/reddit/helpers/trackers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "p", (function() {
				return v
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "d", (function() {
				return k
			}));
			var s, r, o = n("./src/reddit/constants/tracking.ts"),
				a = n("./src/reddit/helpers/trackers/postEvent.ts"),
				i = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.collection = "collection", e.collectionComposer = "collection_composer", e.postComposer = "post_composer", e.postOverflowMenu = "post_overflow_menu"
			}(s || (s = {})),
			function(e) {
				e.post = "post", e.follow = "follow", e.unfollow = "unfollow", e.screen = "screen", e.eventEducation = "event_education", e.eventEducationGotIt = "event_education_got_it", e.collectionEducation = "collection_education", e.collectionEducationGotIt = "collection_education_got_it", e.collectionCancel = "cancel", e.collectionCreate = "collection_create", e.collectionSelect = "collection_select", e.collectionDelete = "collection_delete", e.collectionEdit = "collection_edit", e.collectionAddPost = "collection_add_post", e.collectionRemovePost = "remove_post_from_collection", e.startEvent = "start_event"
			}(r || (r = {}));
			const c = e => t => ({
					source: s.collection,
					noun: r.post,
					...m(t, e)
				}),
				l = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: s.collection,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				u = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: a.a.postEvent,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				m = (e, t) => {
					const n = {
						...d.n(e),
						action: o.c.CLICK,
						subreddit: d.hb(e)
					};
					return void 0 === t ? n : {
						...n,
						post: d.I(e, t),
						postCollection: d.K(e, {
							postId: t
						}),
						postEvent: d.L(e, {
							postId: t
						})
					}
				},
				p = e => ({
					...g(e),
					action: o.c.VIEW,
					noun: r.collectionEducation
				}),
				b = e => ({
					...g(e),
					action: o.c.CLICK,
					noun: r.collectionEducationGotIt
				}),
				h = e => ({
					...g(e),
					action: o.c.VIEW,
					noun: r.eventEducation
				}),
				f = e => ({
					...g(e),
					action: o.c.CLICK,
					noun: r.eventEducationGotIt
				}),
				g = e => ({
					...d.n(e),
					subreddit: d.hb(e),
					source: s.postComposer
				}),
				_ = (e, t) => n => ({
					...m(n, e),
					source: t || s.postOverflowMenu,
					noun: r.collectionAddPost
				}),
				v = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.collectionRemovePost
				}),
				O = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionCancel
				}),
				x = () => e => {
					const t = Object(i.o)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						noun: r.collectionCreate
					}
				},
				E = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionSelect
				}),
				y = e => t => ({
					...d.n(t),
					subreddit: d.hb(t),
					source: s.collectionComposer,
					action: o.c.CLICK,
					noun: r.collectionDelete,
					postCollection: d.J(t, {
						collectionId: e
					})
				}),
				j = e => t => ({
					...m(t),
					source: s.collectionComposer,
					noun: r.collectionEdit,
					postCollection: d.J(t, {
						collectionId: e
					})
				}),
				C = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.startEvent
				}),
				k = () => e => {
					const t = Object(i.o)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						action: o.c.VIEW,
						noun: r.screen
					}
				}
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "K", (function() {
				return x
			})), n.d(t, "I", (function() {
				return E
			})), n.d(t, "C", (function() {
				return y
			})), n.d(t, "z", (function() {
				return j
			})), n.d(t, "A", (function() {
				return C
			})), n.d(t, "M", (function() {
				return k
			})), n.d(t, "B", (function() {
				return I
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "E", (function() {
				return w
			})), n.d(t, "D", (function() {
				return T
			})), n.d(t, "t", (function() {
				return N
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "L", (function() {
				return R
			})), n.d(t, "p", (function() {
				return A
			})), n.d(t, "o", (function() {
				return M
			})), n.d(t, "q", (function() {
				return D
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "r", (function() {
				return B
			})), n.d(t, "j", (function() {
				return H
			})), n.d(t, "g", (function() {
				return W
			})), n.d(t, "h", (function() {
				return q
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "H", (function() {
				return z
			})), n.d(t, "i", (function() {
				return K
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "v", (function() {
				return Y
			})), n.d(t, "u", (function() {
				return X
			})), n.d(t, "G", (function() {
				return Z
			})), n.d(t, "w", (function() {
				return $
			})), n.d(t, "k", (function() {
				return ee
			})), n.d(t, "F", (function() {
				return te
			})), n.d(t, "y", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "n", (function() {
				return re
			})), n.d(t, "x", (function() {
				return oe
			})), n.d(t, "l", (function() {
				return ae
			})), n.d(t, "J", (function() {
				return ie
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/media/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				i = n("./src/reddit/models/PostDraft/index.ts"),
				d = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				c = n("./src/reddit/selectors/postDraft.ts"),
				l = n("./src/reddit/selectors/subreddit.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/telemetry/index.ts"),
				b = n("./src/telemetry/models/PostComposer.ts"),
				h = n("./src/telemetry/models/PostDraft.ts");
			const f = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				g = e => ({
					source: "post_composer",
					action: s.c.CLICK,
					...u.n(e),
					screen: u.Z(e),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				_ = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === a.i.MARKDOWN ? "markdown" : "rte"
				},
				v = e => {
					Object(p.a)({
						noun: "cancel",
						...g(e)
					})
				},
				O = e => {
					Object(p.a)({
						noun: "discard",
						...g(e)
					})
				},
				x = e => t => ({
					...g(t),
					noun: "subreddit_choice",
					subreddit: e ? u.ib(t, e) : void 0,
					actionInfo: u.g(t)
				}),
				E = () => e => ({
					...g(e),
					noun: "subreddit_selector"
				}),
				y = (e, t) => {
					Object(p.a)({
						noun: "post_type_selector",
						postComposer: {
							type: f[t]
						},
						...g(e)
					})
				},
				j = () => e => ({
					noun: "add_option",
					...g(e)
				}),
				C = () => e => ({
					noun: "voting_length",
					...g(e)
				}),
				k = (e, t, n) => {
					"image_upload" === t || "video_upload" === t ? Object(p.a)({
						noun: t,
						...g(e)
					}) : Object(p.a)({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: n ? "on" : "off"
						},
						...g(e)
					})
				},
				I = (e, t, n, s) => {
					Object(p.a)({
						noun: "post",
						subreddit: u.hb(e),
						postComposer: {
							type: t,
							..._(e, t)
						},
						post: n ? u.I(e, n) : null,
						...g(e),
						correlationId: s
					})
				},
				S = (e, t) => {
					const n = t === a.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(p.a)({
						noun: n,
						...g(e)
					})
				},
				w = (e, t) => {
					Object(p.a)({
						noun: "save",
						subreddit: u.hb(e),
						postComposer: {
							type: t,
							..._(e, t)
						},
						...g(e)
					})
				},
				T = (e, t) => {
					const n = e.uploads[t];
					n.error && Object(p.a)({
						...g(e),
						noun: "media",
						action: s.c.REJECT,
						actionInfo: {
							...u.d(e),
							reason: JSON.stringify(n.error)
						}
					})
				},
				N = (e, t) => {
					t.forEach(t => {
						const n = Object(o.g)(t.type);
						n && Object(p.a)({
							...g(e),
							action: s.c.DRAG,
							noun: n
						})
					})
				},
				P = (e, t, n) => {
					Object(p.a)({
						...g(e),
						noun: "input",
						postComposer: {
							inputType: n
						},
						action: t,
						actionInfo: u.g(e)
					})
				},
				R = (e, t, n) => {
					Object(p.a)({
						...g(e),
						noun: n,
						action: Object(b.getToggleAction)(t),
						actionInfo: u.g(e)
					})
				},
				A = e => L("input", e),
				M = () => L("add"),
				D = () => L("remove_image"),
				L = (e, t) => n => ({
					...g(n),
					noun: e,
					postComposer: {
						inputType: t,
						type: f.imageOnly
					},
					action: s.c.CLICK
				}),
				F = e => {
					Object(p.a)({
						...g(e),
						noun: "hide_oc_description",
						action: s.c.CLICK
					})
				},
				U = (e, t) => {
					if (t) {
						const n = u.ib(e, t);
						if (n) return {
							subreddit: n
						};
						const s = u.S(e, t);
						if (s) return {
							profile: s
						}
					}
				},
				B = (e, t) => {
					const {
						draftId: n,
						destSubreddit: s
					} = t, r = Object(m.k)(e), o = Object(c.d)(e, {
						draftId: n
					}), a = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: n || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case i.b.Link:
							a.type = h.DraftType.Link, a.urlLength = t.body.length;
							break;
						case i.b.Markdown:
							a.type = h.DraftType.Self, a.bodyTextLength = t.body.length;
							break;
						case i.b.RichText:
							a.type = h.DraftType.RichText, t.documentStats && (a.bodyTextLength = t.documentStats.textLength, a.numberRteImages = t.documentStats.rteImagesCount, a.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case i.b.Image:
							a.type = h.DraftType.Image;
							break;
						case i.b.Video:
							a.type = h.DraftType.Video
					}
					return {
						postDraft: a,
						...U(e, s.id)
					}
				},
				G = (e, t) => {
					const n = Object(m.k)(e),
						s = {
							authorId: n ? n.id : void 0,
							createdTimestamp: t.created,
							id: t.id,
							nsfw: t.isNSFW,
							originalContent: t.isOriginalContent,
							spoiler: t.isSpoiler,
							titleLength: t.title.length
						};
					switch (t.kind) {
						case i.b.Link:
							s.type = h.DraftType.Link, s.urlLength = (t.body || "").length;
							break;
						case i.b.Markdown:
							s.type = h.DraftType.Self, s.bodyTextLength = (t.body || "").length;
							break;
						case i.b.RichText:
							s.type = h.DraftType.RichText
					}
					return {
						postDraft: s,
						...U(e, t.subredditId)
					}
				},
				H = (e, t) => {
					Object(p.a)({
						noun: "draft_load",
						...g(e),
						...B(e, t)
					})
				},
				W = (e, t) => {
					Object(p.a)({
						noun: t.draftId ? "draft_update" : "draft_create",
						...g(e),
						...B(e, t)
					})
				},
				q = (e, t) => {
					Object(p.a)({
						noun: "draft_delete",
						...g(e),
						...G(e, t)
					})
				},
				V = e => {
					Object(p.a)({
						...g(e),
						noun: "social_connect_link",
						action: s.c.CLICK
					})
				},
				z = (e, t) => {
					Object(p.a)({
						...g(e),
						noun: "twitter_share_checkbox",
						action: Object(b.getToggleAction)(t)
					})
				},
				K = (e, t, n) => {
					Object(p.a)({
						...g(e),
						...B(e, t),
						noun: "draft_share",
						action: n ? s.c.ENABLE : s.c.DISABLE
					})
				},
				Q = e => {
					Object(p.a)({
						...g(e),
						noun: "create_community",
						actionInfo: {
							...u.d(e),
							pageType: "post_select_community"
						}
					})
				},
				J = "community_recommendation",
				Y = () => e => ({
					...g(e),
					action: s.c.VIEW,
					noun: J,
					listing: {
						links: Object(d.c)(e).map(t => Object(l.F)(e, t.name))
					}
				}),
				X = (e, t) => n => ({
					...g(n),
					action: s.c.CLICK,
					noun: J,
					actionInfo: {
						...u.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(l.F)(n, e)
					}
				}),
				Z = e => {
					Object(p.a)({
						...g(e),
						action: s.c.SKIP,
						noun: J
					})
				},
				$ = (e, t) => n => ({
					...g(n),
					action: s.c.VIEW,
					noun: `${J}_hover`,
					actionInfo: {
						...u.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(l.F)(n, e)
					}
				}),
				ee = e => t => ({
					...g(t),
					action: s.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						...u.d(t),
						count: e
					}
				}),
				te = e => t => ({
					...g(t),
					action: "add",
					noun: "flair",
					subreddit: u.ib(t, e)
				}),
				ne = () => e => ({
					...g(e),
					action: s.c.CLICK,
					noun: "flair_dropdown"
				}),
				se = () => e => ({
					...g(e),
					action: "clear",
					noun: "flair"
				}),
				re = () => e => ({
					...g(e),
					action: "search",
					noun: "flair"
				}),
				oe = e => {
					let {
						actionInfoType: t,
						subredditId: n = "",
						noun: o = "create_post"
					} = e;
					return e => ({
						...g(e),
						action: s.c.CLICK,
						noun: o,
						actionInfo: {
							...u.d(e),
							type: t
						},
						correlationId: Object(r.d)(r.a.PostComposer, !1),
						subreddit: n ? u.ib(e, n) : void 0
					})
				},
				ae = () => e => ({
					...g(e),
					action: s.c.CLICK,
					noun: "edit_post"
				}),
				ie = e => t => ({
					...g(t),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						...u.d(t),
						type: e
					}
				})
		},
		"./src/reddit/helpers/trackers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			}));
			var s, r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/eventTools/index.ts"),
				a = n("./src/lib/timezone/index.ts"),
				i = n("./src/reddit/constants/tracking.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/telemetry/index.ts");
			! function(e) {
				e.postEvent = "post_event", e.postComposer = "post_composer", e.eventComposer = "event_composer"
			}(s || (s = {}));
			const p = e => u.d(e, {
					pageType: "event_submit"
				}),
				b = e => {
					Object(m.a)({
						...u.n(e),
						source: s.postComposer,
						action: i.c.CLICK,
						noun: "event_create",
						subreddit: u.hb(e)
					})
				},
				h = e => {
					Object(m.a)({
						...u.n(e),
						source: s.postComposer,
						action: i.c.CLICK,
						noun: "event_edit",
						subreddit: u.hb(e),
						postEvent: O(e),
						postComposer: x(e)
					})
				},
				f = () => e => ({
					source: s.eventComposer,
					action: i.c.VIEW,
					noun: i.b.SCREEN,
					actionInfo: p(e),
					postEvent: O(e)
				}),
				g = e => t => ({
					...j(t, Object(c.o)(t)),
					source: s.postComposer,
					noun: "apply",
					postComposer: E(e)
				}),
				_ = () => e => ({
					...j(e, Object(c.o)(e)),
					noun: "cancel",
					actionInfo: p(e)
				}),
				v = e => t => ({
					...j(t, Object(c.o)(t)),
					noun: "delete",
					actionInfo: p(t),
					postComposer: x(t),
					postEvent: y(e)
				}),
				O = e => {
					const t = Object(l.p)(e);
					return t && y(t)
				},
				x = e => E(Object(l.p)(e)),
				E = e => {
					return {
						postScheduled: !!e,
						submitScheduledTime: e && e.submitTime === d.j.AtEventTime ? Object(a.f)(e.startDate).getTime() / r.Sb : void 0
					}
				},
				y = e => {
					const t = Object(a.f)(e.startDate).getTime() / r.Sb,
						n = Object(a.f)(e.endDate).getTime() / r.Sb;
					return {
						eventStartTimestamp: t,
						eventEndTimestamp: n,
						eventState: Object(o.e)(t, n)
					}
				},
				j = (e, t) => {
					const n = {
						source: s.eventComposer,
						action: i.c.CLICK,
						subreddit: u.hb(e)
					};
					return t ? {
						...n,
						post: u.I(e, t),
						postEvent: u.L(e, {
							postId: t
						}),
						postCollection: u.K(e, {
							postId: t
						})
					} : n
				}
		},
		"./src/reddit/helpers/trackers/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/reddit/helpers/flair.ts"),
				i = n("./src/reddit/helpers/search/searchImpressionId.ts");
			const d = (e, t) => n => {
					const a = `flair_name:'${t.postFlairName}'`;
					return {
						source: "post",
						action: "click",
						noun: "post_flair",
						...o.n(n),
						actionInfo: o.d(n),
						correlationId: Object(s.c)(s.a.SearchResults),
						post: o.I(n, e),
						search: {
							...o.M(n, t),
							query: a,
							queryId: o.bb(n, r.a.SERP),
							impressionId: i.a.get(r.a.SERP)
						},
						subreddit: o.hb(n)
					}
				},
				c = e => t => ({
					source: "post_flair_widget",
					action: "click",
					noun: "post_flair_search",
					...o.n(t),
					actionInfo: o.d(t),
					correlationId: Object(s.c)(s.a.SearchResults),
					search: o.M(t, e),
					subreddit: o.hb(t)
				}),
				l = e => t => {
					const n = Object(a.g)(e);
					return {
						...o.n(t),
						action: "click",
						noun: "post_flair",
						source: "post_flair_widget",
						subreddit: o.hb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				u = () => e => ({
					...o.n(e),
					action: "click",
					noun: "overflow",
					source: "post_flair_widget",
					subreddit: o.hb(e)
				}),
				m = e => t => {
					const n = Object(a.g)(e);
					return {
						...o.n(t),
						action: "click",
						noun: "clear",
						source: "post_flair_widget",
						subreddit: o.hb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				p = (e, t) => n => {
					const s = Object(a.g)(e),
						d = o.I(n, t),
						c = `flair_name:'${s}'`;
					return {
						...o.n(n),
						action: "click",
						noun: "post_flair",
						source: "post",
						subreddit: o.hb(n),
						postFlair: {
							id: e.templateId,
							title: s
						},
						post: d,
						search: {
							query: c,
							subredditId: d ? d.subredditId : void 0,
							subredditName: d ? d.subredditName : void 0,
							postFlairName: s,
							originElement: "post_flair",
							queryId: o.bb(n, r.a.SERP),
							impressionId: i.a.get(r.a.SERP),
							originPageType: n.platform.currentPage ? o.u(n.platform.currentPage) : void 0
						},
						feed: o.q(n)
					}
				}
		},
		"./src/reddit/helpers/trackers/powerups.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return a
			})), n.d(t, "m", (function() {
				return i
			})), n.d(t, "o", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "i", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "n", (function() {
				return x
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t, n) => ({
					...r.n(e),
					correlationId: Object(s.d)(s.a.PowerupsFlow, !1),
					profile: r.R(e),
					subreddit: r.hb(e),
					powerups: {
						...r.mb(e),
						freeCount: t,
						paidCount: n
					}
				}),
				a = () => e => ({
					source: "postlist_supporters_cta",
					action: "click",
					noun: "powerups_become_hero",
					...o(e),
					correlationId: Object(s.d)(s.a.PowerupsFlow, !0)
				}),
				i = () => e => ({
					source: "postlist_supporters_cta",
					action: "click",
					noun: "powerups_see_all_heroes",
					...o(e),
					correlationId: Object(s.d)(s.a.PowerupsFlow, !0)
				}),
				d = e => (t, n) => s => ({
					source: e,
					action: "click",
					noun: "powerup_supporter",
					...o(s),
					profile: {
						id: t,
						name: n,
						type: "default"
					}
				}),
				c = d("postlist_supporters_cta"),
				l = d("comm_heroes_modal"),
				u = e => t => ({
					source: "powerups",
					action: "click",
					noun: "join_supporters",
					...o(t),
					actionInfo: r.d(t, {
						reason: e
					})
				}),
				m = e => t => ({
					source: "powerups_modal",
					action: "view",
					noun: "marketing_step",
					...o(t),
					actionInfo: r.d(t, {
						reason: e
					})
				}),
				p = e => t => ({
					source: "powerups",
					action: "click",
					noun: "benefit",
					...o(t),
					powerups: {
						...r.mb(t),
						benefit: e
					}
				}),
				b = (e, t) => n => ({
					source: "powerups_modal",
					action: "view",
					noun: "purchase_step",
					...o(n, e, t)
				}),
				h = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...o(n, e, t),
					actionInfo: {
						pageType: "community_heroes_modal"
					}
				}),
				f = () => e => ({
					source: "meta",
					action: "open",
					noun: "emote_picker",
					...o(e)
				}),
				g = (e, t) => n => ({
					source: t,
					action: "click",
					noun: "add_custom_emojis",
					...o(n),
					powerups: {
						...r.mb(n),
						emojiCount: e
					}
				}),
				_ = (e, t) => n => ({
					source: t,
					action: "save",
					noun: "custom_emojis",
					...o(n),
					powerups: {
						...r.mb(n),
						emojiCount: e
					}
				}),
				v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 ? arguments[1] : void 0;
					return n => ({
						source: t,
						action: "delete",
						noun: "custom_emojis",
						...o(n),
						powerups: {
							...r.mb(n),
							emojiCount: e
						}
					})
				},
				O = (e, t) => n => ({
					source: "meta",
					action: "open",
					noun: "gif_tooltip",
					subreddit: t ? r.ib(n, t) : void 0,
					...o(n),
					correlationId: e
				}),
				x = (e, t, n) => s => ({
					source: "powerups_settings",
					action: "click",
					noun: e,
					setting: {
						value: String(t),
						oldValue: String(n)
					},
					subreddit: r.hb(s),
					...r.n(s)
				})
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "y", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "p", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "r", (function() {
				return h
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "t", (function() {
				return j
			})), n.d(t, "j", (function() {
				return C
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "x", (function() {
				return I
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "s", (function() {
				return T
			})), n.d(t, "v", (function() {
				return N
			})), n.d(t, "w", (function() {
				return P
			}));
			var s = n("./src/reddit/models/ScheduledPost/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					...r.n(e),
					screen: r.Z(e),
					subreddit: r.hb(e),
					userSubreddit: r.rb(e)
				}),
				a = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(s.q)(e)
				}),
				i = () => e => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post",
					...o(e)
				}),
				d = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer",
					...o(e)
				}),
				c = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date",
					...o(e)
				}),
				l = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time",
					...o(e)
				}),
				u = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone",
					...o(e)
				}),
				m = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply",
					...o(e)
				}),
				p = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				b = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit",
					...o(t),
					scheduledPost: a(e)
				}),
				h = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit",
					...o(t),
					scheduledPost: a(e)
				}),
				f = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts",
					...o(e)
				}),
				g = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts",
					...o(e)
				}),
				_ = () => e => ({
					source: "post",
					action: "click",
					noun: "edit_post",
					...o(e)
				}),
				v = () => e => ({
					source: "post",
					action: "click",
					noun: "submit_post_now",
					...o(e)
				}),
				O = e => t => ({
					source: "post",
					action: "click",
					noun: "overflow_menu",
					...o(t),
					actionInfo: r.d(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				x = {
					[s.d.Hourly]: "hourly_frequency",
					[s.d.Daily]: "daily_frequency",
					[s.d.Weekly]: "weekly_frequency",
					[s.d.Monthly]: "monthly_frequency",
					[s.b]: "custom_frequency"
				},
				E = e => t => ({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: null === e ? "one_time_frequency" : x[e],
					...o(t)
				}),
				y = () => e => ({
					source: "post",
					action: "click",
					noun: "start_event_now",
					...o(e)
				}),
				j = (e, t, n) => a => ({
					source: "post",
					action: "click",
					noun: Object(s.m)(e),
					...o(a),
					actionInfo: r.d(a, {
						settingValue: t ? "true" : "false",
						pageType: n ? "recurring_posts" : "scheduled_posts"
					})
				}),
				C = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta",
					...o(e)
				}),
				k = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post",
					...o(e)
				}),
				I = () => e => ({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer",
					...o(e)
				}),
				S = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "update",
					...o(e),
					scheduledPost: a(t)
				}),
				w = () => e => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				T = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete",
					...o(e),
					scheduledPost: a(t)
				}),
				N = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer",
					...o(e)
				}),
				P = () => (e, t) => {
					const n = o(e);
					return {
						source: "post",
						action: "view",
						noun: "error",
						...n,
						actionInfo: {
							...n.actionInfo,
							reason: "failed_post"
						},
						scheduledPost: a(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/screenview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return k
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "q", (function() {
				return w
			})), n.d(t, "r", (function() {
				return T
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "l", (function() {
				return A
			})), n.d(t, "p", (function() {
				return M
			})), n.d(t, "i", (function() {
				return D
			})), n.d(t, "j", (function() {
				return L
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "a", (function() {
				return H
			})), n.d(t, "n", (function() {
				return W
			})), n.d(t, "m", (function() {
				return q
			})), n.d(t, "t", (function() {
				return K
			})), n.d(t, "x", (function() {
				return Q
			})), n.d(t, "e", (function() {
				return J
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "v", (function() {
				return ee
			})), n.d(t, "u", (function() {
				return te
			})), n.d(t, "w", (function() {
				return ne
			})), n.d(t, "h", (function() {
				return se
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makePostDraftPageKey/index.ts"),
				i = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/reddit/constants/tracking.ts"),
				c = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				l = n("./src/reddit/helpers/routeKey/index.ts"),
				u = n("./src/reddit/helpers/trackers/postComposer.ts"),
				m = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				p = n("./src/reddit/models/Comment/index.ts"),
				b = n("./src/reddit/models/Post/index.ts"),
				h = n("./src/reddit/routes/subreddit/index.ts"),
				f = n("./src/reddit/selectors/profile.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				_ = n("./src/lib/makePostCreationPageKey/index.ts"),
				v = n("./src/lib/makeSearchKey/index.ts"),
				O = n("./src/reddit/helpers/correlationIdTracker.ts"),
				x = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				E = n("./src/reddit/helpers/trackers/searchResults.ts"),
				y = n("./src/reddit/selectors/postDraft.ts"),
				j = n("./src/reddit/selectors/telemetry.ts"),
				C = n("./src/telemetry/index.ts");
			const k = (e, t, n, s, d, u) => {
					const {
						route: f
					} = e, {
						name: g
					} = f.meta;
					if (!g) return;
					const O = t.platform.currentPage;
					switch (g) {
						case o.Nb.COMMENTS: {
							const {
								partialCommentId: r,
								partialPostId: o
							} = e.match.params, a = Object(b.u)(o), i = Object(l.a)(e, t, t.posts.models[a]);
							if (!i) return;
							const d = r && Object(p.h)(r),
								{
									sortToUse: u
								} = Object(c.a)(t, a);
							Object(C.a)(R(i, a, d, n, s, u)(t));
							break
						}
						case o.Nb.INDEX:
						case o.Nb.LISTING:
						case o.Nb.MULTIREDDIT:
						case o.Nb.SUBREDDIT: {
							const r = Object(l.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: a,
								queryParams: i,
								path: d
							} = e.match, {
								sort: c = (r.sort ? r.sort : o.W.HOT)
							} = a, u = i.t, m = d === h.a;
							Object(C.a)(S({
								key: r.listingKey,
								sort: c,
								timerType: n,
								timerMillis: s,
								timeSort: u,
								isPredictionsPage: m
							})(t));
							break
						}
						case o.Nb.TOPIC: {
							const r = Object(l.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: a
							} = e.match, i = r.sort ? r.sort : o.X, {
								sort: d = i
							} = a;
							Object(C.a)(S({
								key: r.listingKey,
								sort: d,
								timerType: n,
								timerMillis: s
							})(t));
							break
						}
						case o.Nb.PROFILE_OVERVIEW: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								params: a,
								queryParams: i
							} = e.match, {
								sort: d = o.Eb
							} = a, c = i.t;
							Object(C.a)(w(r, d, n, s, c)(t));
							break
						}
						case o.Nb.PROFILE_POSTS: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								queryParams: a
							} = e.match, {
								sort: i = o.Eb,
								t: d = o.Fb
							} = a;
							Object(C.a)(T(r, i, n, s, d)(t));
							break
						}
						case o.Nb.PROFILE_COMMENTS: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								queryParams: a
							} = e.match, {
								sort: i = o.Eb,
								t: d = o.Fb
							} = a;
							Object(C.a)(N(r, i, n, s, d)(t));
							break
						}
						case o.Nb.PROFILE_PRIVATE: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							Object(C.a)(P(r)(s, n)(t));
							break
						}
						case o.Nb.FOLLOWERS:
							U(t);
							break;
						case o.Nb.PROFILE_MODERATION:
							u && M(t, !0);
							break;
						case o.Nb.SETTINGS: {
							const r = e;
							Object(C.a)(z(n, s)(t)), r.match.params.page === o.dc.Profile && Object(m.l)(t);
							break
						}
						case o.Nb.POST_CREATION:
							if (u && d) {
								const e = Object(_.a)(d);
								Object(C.a)(A(e, n, s)(t))
							}
							break;
						case o.Nb.POST_DRAFT: {
							const {
								draftId: r
							} = e.match.params, o = Object(a.a)(e.match.params);
							if (!o) return;
							B(t, o, r, n, s);
							break
						}
						case o.Nb.SUBREDDIT_WIKI:
							Object(C.a)(Y(n, s)(t));
							break;
						case o.Nb.COINS:
							Object(C.a)(G(n, s)(t)), Object(C.a)(H()(t));
							break;
						case o.Nb.PREMIUM:
							Object(C.a)(W(n, s)(t)), Object(C.a)(q()(t));
							break;
						case o.Nb.APPEAL:
							Object(C.a)(V(n, s)(t));
							break;
						case o.Nb.INBOX_PAGES:
							u && F(t);
							break;
						case o.Nb.MODERATION_PAGES:
							u && D(t, !0, d ? d.subredditName : null, d ? d.profileName : null);
							break;
						case o.Nb.COLLECTION_COMMENTS:
							u && ne(t, !0);
							break;
						case o.Nb.MODQUEUE_PAGES:
							u && L(t, d ? d.subredditName : null, d ? d.profileName : null);
							break;
						case o.Nb.SUBREDDIT_LEADERBOARD:
							u && Object(C.a)(J()(t));
							break;
						case o.Nb.SEARCH_RESULTS:
							if (u) {
								const o = Object(l.e)(e);
								if (!o) return;
								Object(C.a)(ee(o, Object(v.e)(r()(O && O.queryParams || {}, i.t)), n, s, O)(t))
							}
							break;
						case o.Nb.PUBLIC_ACCESS_NETWORK:
							u && Object(C.a)(K()(t));
							break;
						case o.Nb.GEOTAGGING:
							u && Object(C.a)(X()(t));
							break;
						case o.Nb.SUBREDDIT_CREATION:
							u && Object(C.a)(Q()(t));
							break;
						case o.Nb.MOD_LISTING:
							u && se(t, !0)
					}
				},
				I = e => ({
					...j.n(e),
					userPreferences: j.qb(e)
				}),
				S = e => {
					let {
						key: t,
						sort: n,
						timerType: s,
						timerMillis: r,
						timeSort: o,
						flairTitle: a,
						isPredictionsPage: i
					} = e;
					return e => {
						const {
							api: d
						} = e.listings.postOrder, c = !d.error[t] && !d.pending[t], l = i ? {
							paneName: "predictions",
							reason: "predictions_tournament"
						} : {};
						return {
							source: "global",
							action: "view",
							noun: "screen",
							...I(e),
							actionInfo: j.d(e, {
								success: c,
								...l
							}),
							customFeed: j.l(e),
							listing: j.y(e, t, {
								sort: n,
								sortTime: o
							}),
							subreddit: j.hb(e),
							timer: j.nb(s, r),
							userSubreddit: j.rb(e),
							adblock: j.e(e),
							postFlair: {
								title: a
							},
							predictions: i ? Object(j.P)(e) : void 0
						}
					}
				},
				w = (e, t, n, s, r) => o => {
					const a = j.y(o, e);
					a && (a.sort = t, r && (a.sortTime = r));
					const {
						api: i
					} = o.listings.postOrder, d = !i.error[e] && !i.pending[e];
					return {
						listing: a,
						source: "global",
						action: "view",
						noun: "screen",
						...I(o),
						actionInfo: j.d(o, {
							success: d
						}),
						profile: j.R(o),
						snoovatar: j.eb(o),
						subreddit: j.hb(o),
						timer: j.nb(n, s),
						userSubreddit: j.rb(o),
						adblock: j.e(o)
					}
				},
				T = (e, t, n, s, r) => o => {
					const a = j.y(o, e);
					a && (a.sort = t, r && (a.sortTime = r));
					const {
						api: i
					} = o.listings.postOrder, d = !i.error[e] && !i.pending[e];
					return {
						listing: a,
						source: "global",
						action: "view",
						noun: "screen",
						...I(o),
						actionInfo: j.d(o, {
							success: d
						}),
						profile: j.R(o),
						subreddit: j.hb(o),
						timer: j.nb(n, s),
						userSubreddit: j.rb(o),
						adblock: j.e(o)
					}
				},
				N = (e, t, n, s, r) => o => {
					const a = j.U(o, e);
					a && (a.sort = t, r && (a.sortTime = r));
					const {
						api: i
					} = o.profileCommentsPage, d = !i.error[e] && !i.pending[e];
					return {
						listing: a,
						source: "global",
						action: "view",
						noun: "screen",
						...I(o),
						actionInfo: j.d(o, {
							success: d
						}),
						profile: j.R(o),
						subreddit: j.hb(o),
						timer: j.nb(n, s),
						userSubreddit: j.rb(o),
						adblock: j.e(o)
					}
				},
				P = e => (t, n) => s => {
					const r = !s.profilePrivatePage.api.error[e] && !s.profilePrivatePage.api.pending[e];
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...I(s),
						actionInfo: j.d(s, {
							success: r
						}),
						profile: j.R(s),
						subreddit: j.hb(s),
						timer: j.nb(n, t),
						userSubreddit: j.rb(s),
						adblock: j.e(s)
					}
				},
				R = (e, t, n, s, r, o) => a => {
					const {
						api: i
					} = a.pages.comments, d = !i.error[e] && !i.pending[e], c = {
						source: "global",
						action: "view",
						noun: "screen",
						...I(a),
						actionInfo: j.d(a, {
							success: d
						}),
						post: j.I(a, t),
						profile: j.R(a),
						subreddit: j.hb(a),
						timer: j.nb(s, r),
						userSubreddit: j.rb(a),
						adblock: j.e(a),
						postEvent: j.L(a, {
							postId: t
						}),
						postCollection: j.K(a, {
							postId: t
						}),
						listing: j.y(a, void 0, {
							sort: o
						})
					};
					return n && (c.comment = j.h(a, n)), c
				},
				A = (e, t, n) => s => {
					const r = s.creations.api.page.fetched[e],
						o = s.platform.currentPage ? s.platform.currentPage.queryParams.source_id : void 0;
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...I(s),
						actionInfo: j.d(s, {
							success: r
						}),
						post: o ? j.I(s, o) : void 0,
						subreddit: j.hb(s),
						timer: j.nb(t, n),
						userSubreddit: j.rb(s),
						adblock: j.e(s)
					}
				},
				M = (e, t) => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e, {
							success: t
						})
					})
				},
				D = (e, t, n, s) => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e, {
							success: t
						}),
						profile: j.S(e, Object(f.m)(e, s)),
						subreddit: j.ib(e, Object(g.F)(e, n)),
						userSubreddit: j.rb(e),
						adblock: j.e(e)
					})
				},
				L = (e, t, n) => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						profile: j.S(e, Object(f.m)(e, n)),
						subreddit: j.ib(e, Object(g.F)(e, t)),
						userSubreddit: j.rb(e),
						adblock: j.e(e)
					})
				},
				F = e => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e)
					})
				},
				U = e => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e)
					})
				},
				B = (e, t, n, s, r) => {
					const o = e.creations.api.page.pending[t],
						a = !e.creations.api.page.error[t] && !o && !!n,
						i = Object(y.h)(e, n);
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e, {
							success: a
						}),
						subreddit: j.hb(e),
						timer: j.nb(s, r),
						userSubreddit: j.rb(e),
						adblock: j.e(e),
						...i ? Object(u.r)(e, i) : {}
					})
				},
				G = (e, t) => n => ({
					source: "coins_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(O.c)(O.a.GoldPayment),
					...I(n),
					timer: j.nb(e, t),
					adblock: j.e(n)
				}),
				H = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(e)
				}),
				W = (e, t) => n => ({
					source: "premium_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(O.c)(O.a.GoldPayment),
					...I(n),
					timer: j.nb(e, t),
					adblock: j.e(n)
				}),
				q = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(e)
				}),
				V = (e, t) => n => ({
					source: "appeal",
					action: "view",
					noun: "page",
					...I(n),
					timer: j.nb(e, t)
				}),
				z = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(n),
					timer: j.nb(e, t)
				}),
				K = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					subreddit: j.hb(e),
					...I(e)
				}),
				Q = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(e)
				}),
				J = () => e => ({
					action: "view",
					source: "global",
					noun: "screen",
					...I(e)
				}),
				Y = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(n),
					customFeed: j.l(n),
					subreddit: j.hb(n),
					timer: j.nb(e, t),
					userSubreddit: j.rb(n),
					adblock: j.e(n)
				}),
				X = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...I(e)
				}),
				Z = {
					source: "global",
					action: d.c.VIEW,
					noun: "screen"
				},
				$ = e => !!e && {
					correlationId: Object(O.c)(O.a.SearchResults)
				},
				ee = (e, t, n, s, r, a) => i => {
					var d, c;
					let l = !0;
					if (t.type.indexOf(o.cc.Posts) > -1) {
						const {
							api: t
						} = i.listings.listingOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(o.cc.Subreddits) > -1 || t.type.indexOf(o.cc.Users) > -1) {
						const {
							api: t
						} = i.listings.postOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					const u = j.G(i, r);
					return {
						...E.g(i, t),
						...Z,
						...j.n(i),
						actionInfo: j.d(i, {
							success: l,
							paneName: u
						}),
						timer: j.nb(n, s),
						search: {
							...j.ab(i, t, x.a.SERP, !0, r || void 0),
							sort: null !== (d = t.sort) && void 0 !== d ? d : o.Qb,
							range: null !== (c = t.t) && void 0 !== c ? c : o.Rb
						},
						...$(a),
						userPreferences: j.cb(i)
					}
				},
				te = (e, t, n) => s => ({
					...j.n(s),
					...Z,
					actionInfo: {
						...j.d(s),
						pageType: "search_dropdown"
					},
					search: {
						...j.ab(s, e, x.a.Typeahead, !0, t || void 0)
					},
					...$(n),
					userPreferences: j.cb(s)
				}),
				ne = (e, t) => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e, {
							success: t
						})
					})
				},
				se = (e, t) => {
					Object(C.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...I(e),
						actionInfo: j.d(e, {
							success: t
						})
					})
				}
		},
		"./src/reddit/helpers/trackers/shareToChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
				...Object(r.n)(e),
				source: "post",
				action: s.c.CLICK,
				noun: "share_chat",
				subreddit: Object(r.hb)(e)
			})
		},
		"./src/reddit/helpers/trackers/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "q", (function() {
				return g
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "p", (function() {
				return C
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "o", (function() {
				return w
			}));
			var s = n("./src/reddit/models/Gold/ProductOffer.ts"),
				r = n("./src/reddit/selectors/avatarMarketing.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = {
					goldPurchase: {
						offerContext: s.a.AvatarNewGear
					}
				},
				d = e => t => {
					const n = {
						source: e,
						action: "click",
						noun: "edit_snoovatar",
						...o.n(t)
					};
					return Object(r.a)(t) && Object.assign(n, i), n
				},
				c = (e, t) => n => {
					const {
						id: s
					} = Object(a.Ab)(n, {
						userName: t
					});
					return {
						source: e,
						action: "click",
						noun: "copy_avatar",
						...o.n(n),
						snoovatar: {
							userGenerated: s
						}
					}
				},
				l = e => ({
					...o.n(e),
					source: "avatar",
					action: "click",
					noun: "try_this_look_post",
					snoovatar: o.fb(e)
				}),
				u = e => ({
					...o.n(e),
					source: "global",
					action: "view",
					noun: "screen",
					actionInfo: {
						pageType: "snoovatar_builder"
					},
					snoovatar: o.fb(e)
				}),
				m = e => ({
					...o.n(e),
					source: "avatar_builder",
					action: "click",
					noun: "close",
					snoovatar: o.fb(e)
				}),
				p = e => ({
					source: "nav",
					action: "view",
					noun: "avatar_marketing",
					...o.n(e),
					...i
				}),
				b = e => ({
					source: "nav",
					action: "click",
					noun: "avatar_marketing",
					...o.n(e),
					...i
				}),
				h = e => t => ({
					...o.n(t),
					source: "snoovatar",
					action: "set_to_profile",
					noun: "snoovatar",
					snoovatar: {
						userGeneratedSource: e
					}
				}),
				f = e => t => n => ({
					source: "avatar",
					action: e,
					noun: "community_spaces",
					...o.n(n),
					snoovatar: o.fb(n),
					actionInfo: {
						paneName: "avatar_community_spaces" + (t ? "_control" : "")
					}
				}),
				g = f("view"),
				_ = f("click"),
				v = f("dismiss"),
				O = (e, t, n) => () => s => ({
					source: e,
					action: t,
					noun: n,
					...o.n(s),
					snoovatar: o.fb(s)
				}),
				x = O("anniversary_achievement", "view", "anniversary_achievement"),
				E = O("anniversary_achievement", "click", "close"),
				y = O("anniversary_achievement", "click", "equip"),
				j = e => () => t => ({
					...o.n(t),
					source: "gold_top_nav",
					action: e,
					noun: "quick_create_cta"
				}),
				C = j("view"),
				k = j("click"),
				I = (e, t, n) => s => ({
					source: e,
					action: t,
					noun: n,
					...o.n(s),
					actionInfo: {
						pageType: "onboarding"
					},
					snoovatar: o.fb(s)
				}),
				S = e => I("onboarding", "click", e),
				w = () => I("avatar", "view", "onboarding")
		},
		"./src/reddit/helpers/trackers/socialLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => {
					let {
						socialLinkType: t,
						outboundUrl: n,
						name: s,
						position: r,
						isNew: o,
						currentList: a
					} = e;
					return {
						socialLink: {
							type: t.toLowerCase(),
							url: n,
							name: s,
							position: r,
							isNew: o,
							currentList: a
						}
					}
				},
				a = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "add_social_link",
					source: e
				}),
				i = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "add_social_link",
					...o({
						socialLinkType: e
					})
				}),
				d = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "save",
					source: "add_social_link",
					...o(e)
				}),
				c = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "edit_social_link",
					source: "profile_settings",
					...o(e)
				}),
				l = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "delete_social_link",
					source: "profile_settings",
					...o(e)
				}),
				u = e => t => ({
					...Object(r.n)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "profile",
					profile: Object(r.R)(t),
					...o(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					noun: "create_community_button",
					action: "click",
					...r.n(t),
					actionInfo: r.d(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					}),
					correlationId: Object(s.d)(s.a.SubredditCreation, !0)
				}),
				a = (e, t, n) => o => ({
					source: "community_form",
					noun: "save_community_button",
					action: "click",
					...r.n(o),
					actionInfo: r.d(o, {
						settingValue: e
					}),
					subreddit: {
						id: n,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags,
						topicTagPrimaryId: t.primaryTagId
					},
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				i = () => e => ({
					source: "community_form",
					noun: "cancel",
					action: "click",
					...r.n(e),
					actionInfo: r.d(e),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				d = (e, t) => n => ({
					source: "community_form",
					noun: "error_message",
					action: "view",
					...r.n(n),
					actionInfo: r.d(n, {
						reason: e,
						settingValue: t
					}),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				c = () => e => ({
					source: "user_dropdown",
					noun: "create_community",
					action: "click",
					...r.n(e),
					actionInfo: r.d(e)
				}),
				l = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "view",
					...r.n(e),
					actionInfo: r.d(e)
				}),
				u = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "click",
					...r.n(e),
					actionInfo: r.d(e)
				}),
				m = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "dismiss",
					...r.n(e),
					actionInfo: r.d(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditForking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "click",
					...s.n(e),
					actionInfo: s.d(e, {
						settingValue: e.user.account && e.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				o = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "dismiss",
					...s.n(e),
					actionInfo: s.d(e)
				}),
				a = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "view",
					...s.n(e),
					actionInfo: s.d(e)
				})
		},
		"./src/reddit/helpers/trackers/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/gold/powerups/index.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const a = () => e => ({
					source: "id_card",
					action: "click",
					noun: "user_flair_picker",
					...o.n(e)
				}),
				i = e => t => {
					const n = o.hb(t),
						a = Object(r.t)(t, {
							subredditId: null == n ? void 0 : n.id
						}),
						{
							userFlair: i,
							achievementFlair: d,
							supporterFlair: c
						} = e,
						l = d || c;
					return {
						source: "user_flair_picker",
						action: "click",
						noun: "user_flair",
						...o.n(t),
						subreddit: n,
						userFlair: {
							id: null == i ? void 0 : i.id,
							title: i ? Object(s.g)(i) : void 0,
							isActive: !!i || void 0,
							achievementFlairId: null == d ? void 0 : d.type,
							achievementFlairTitle: null == d ? void 0 : d.name,
							isLocked: null == l ? void 0 : l.isLocked,
							supporterFlairId: null == c ? void 0 : c.type,
							supporterFlairTitle: null == c ? void 0 : c.name,
							isSupporter: a
						}
					}
				},
				d = () => e => ({
					source: "user_flair_picker",
					action: "click",
					noun: "edit_user_flair",
					...o.n(e)
				}),
				c = e => t => ({
					source: "user_flair_picker",
					action: "click",
					noun: "enable_powerups_flair",
					setting: {
						value: e ? "0" : "1",
						oldValue: e ? "1" : "0"
					},
					subreddit: o.hb(t),
					...o.n(t)
				})
		},
		"./src/reddit/helpers/validateFlairCssClass.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/reddit/constants/flair.ts");
			const o = new RegExp(`^[a-zA-Z0-9-]{1,${r.f}}$`);
			t.a = e => {
				if (!e) return;
				const t = e.split(" ").filter(Boolean);
				if (t.length > r.c) return s.fbt._("Too many class names", null, {
					hk: "musK5"
				});
				const n = t.find(e => !e.match(o));
				return n ? n.length > r.f ? s.fbt._("Class name should not be longer than 100 characters", null, {
					hk: "2nBmgP"
				}) : s.fbt._("Class name contains an invalid character", null, {
					hk: "4kdVCU"
				}) : void 0
			}
		},
		"./src/reddit/helpers/wiki/buildWikiPagesTree.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/sortBy.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/wiki.ts");
			const a = e => {
				return r()(e, e => `${e.path}/`.startsWith(`${o.i}/`) ? `\0${e.path}` : e.path).filter(e => !o.l.includes(e.path))
			};
			t.a = e => {
				const t = new Map,
					n = [];
				return a(e).forEach(e => {
					const s = {
							...e,
							children: []
						},
						r = s.parent ? t.get(s.parent) : null;
					r ? r.children.push(s) : n.push(s), t.set(s.path, s)
				}), n
			}
		},
		"./src/reddit/helpers/wiki/makeComparisonDiffKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const {
					comparisonRevisionId: t,
					revisionId: n,
					subredditName: s,
					wikiPageName: r
				} = e;
				return `[${s}]--[${r}]--[rev1:${n}]--[rev2:${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeRevisionsListingKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const t = e.isRecent ? "(recent)" : e.wikiPageName;
				return `[${e.subredditName}]--[${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeWikiPageKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				let t = `[${e.subredditName}]--[${e.wikiPageName}]`;
				return e.revisionId && (t += `--[rev:${e.revisionId}]`), t.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/validatePageName.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/wiki.ts");
			const r = new RegExp(`^[-\\w]+(?:\\/[-\\w]+){0,${s.c}}$`),
				o = /^[-\w]+$/;
			var a;
			! function(e) {
				e[e.InvalidPageName = 1] = "InvalidPageName", e[e.RestrictedPageName = 2] = "RestrictedPageName", e[e.MaxLengthExceed = 3] = "MaxLengthExceed", e[e.PageAlreadyExists = 4] = "PageAlreadyExists"
			}(a || (a = {}));
			const i = e => {
					if (!o.test(e.toLowerCase())) return a.InvalidPageName
				},
				d = (e, t) => {
					const n = e.toLowerCase(),
						o = n.split("/")[0],
						i = s.b.has(o),
						d = s.f.has(o) && n !== s.h && n !== s.k;
					if (i || d) return a.RestrictedPageName;
					if (!r.test(n)) return a.InvalidPageName;
					if (t) {
						if (t.some(e => e.path.toLowerCase() === n)) return a.PageAlreadyExists
					}
					return n.length > s.d ? a.MaxLengthExceed : void 0
				}
		},
		"./src/reddit/helpers/wiki/wikiRevision.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.startsWith("WikiRevision_") ? e : "WikiRevision_" + e,
				r = e => e.startsWith("WikiRevision_") ? e.slice("WikiRevision_".length) : e
		},
		"./src/reddit/hooks/useClickSourceData.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/helpers/clickSourceData/index.ts");

			function a() {
				const e = Object(r.e)(e => e.platform.currentPage),
					[t, n] = Object(s.useState)({});
				return Object(s.useEffect)(() => {
					n(Object(o.b)(e))
				}, [e]), t
			}
		},
		"./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");

			function o(e) {
				const [t, n] = Object(s.useState)(Object(r.s)(e));
				return [t, Object(s.useCallback)(() => {
					n(!0), Object(r.ob)(e)
				}, [])]
			}
		},
		"./src/reddit/hooks/useExperimentVariant.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");

			function o(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a;
				return Object(s.e)(n => Object(r.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: t
				}))
			}
		},
		"./src/reddit/hooks/useGqlContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/contexts/ApiContext.tsx");

			function o() {
				const {
					gqlContext: e
				} = Object(s.useContext)(r.a);
				return e
			}
		},
		"./src/reddit/hooks/useInboxPrivacyPolicyBannerSeen.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");

			function o(e) {
				const [t, n] = Object(s.useState)(() => Object(r.t)(e));
				return [t, Object(s.useCallback)(() => {
					n(!0), Object(r.yb)(e)
				}, [e])]
			}
		},
		"./src/reddit/hooks/useInfoTextTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/lib/hooks/useTooltip.ts");
			const a = Object(s.freeze)({
				name: "offset",
				options: {
					offset: [0, 6]
				}
			});

			function i(e) {
				const t = Object(r.useMemo)(() => {
					const t = Object(o.a)(e);
					return Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, a))
				}, [e]);
				return Object(o.b)(t)
			}
		},
		"./src/reddit/hooks/useIntersectionObserver.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js");
			t.a = function(e, t, n) {
				Object(s.useEffect)(() => {
					const s = e && e.current;
					if (!s || "undefined" == typeof IntersectionObserver) return;
					const r = new IntersectionObserver(t, n);
					return r.observe(s), () => {
						r.unobserve(s)
					}
				}, [e, t, n])
			}
		},
		"./src/reddit/hooks/useIsRemovedOrDeletedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/selectors/removedPosts.ts");
			const o = () => Object(s.e)(e => Object(r.d)(e))
		},
		"./src/reddit/hooks/useLocale.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/meta.ts");
			const i = "undefined" == typeof document ? function() {
				const e = Object(o.e)(a.j) || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			} : function() {
				const e = document.documentElement.lang || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			};
			t.a = i;
			const d = () => {
				const e = i(),
					t = Object(o.e)(a.b);
				return t ? e.replace(/([a-z]+-)([A-Z]+)/, `$1${t}`) : e
			}
		},
		"./src/reddit/hooks/useMemoShallowEqual.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js");

			function o(e) {
				const t = Object(s.useRef)(e);
				return t.current === e || Object(r.c)(t.current, e) || (t.current = e), t.current
			}
		},
		"./src/reddit/hooks/useMounted.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r() {
				const [e, t] = Object(s.useState)(!1);
				return Object(s.useEffect)(() => t(!0), []), e
			}
		},
		"./src/reddit/hooks/useOutboundClickTracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			const r = /^https?:\/\/([\w\.\-]+\.)?(reddit(media|static)?\.com|redd\.it)(\/|$)/;
			var o = n("./src/reddit/helpers/trackers/socialLinks.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, n, s, r) => i => {
				const d = {
					noun: "outbound_link",
					action: "click",
					source: "link",
					...Object(a.n)(i),
					actionInfo: Object(a.d)(i),
					geo: Object(a.s)(i),
					screen: Object(a.Z)(i),
					subreddit: Object(a.hb)(i),
					outbound: Object(a.F)(i, e, t, s, n)
				};
				return n && (d.comment = Object(a.h)(i, n)), s && (d.post = Object(a.I)(i, s)), r && (d.socialLink = Object(o.g)({
					socialLinkType: r
				}).socialLink), d
			};
			var d = n("./src/lib/serviceWorker/index.ts"),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/telemetry/helpers/getSerializedThriftJSON.ts"),
				u = n("./src/telemetry/helpers/getSignatureHeader.ts"),
				m = n("./src/telemetry/models/Event.ts");
			const p = () => {
				const e = Object(c.f)();
				return t => {
					const n = t(e.getState()),
						s = m.g(n),
						r = Object(l.a)(s),
						o = Object(u.b)(r);
					Object(d.b)("sendV2EventsData", {
						data: r,
						headers: o
					})
				}
			};

			function b() {
				const e = Object(s.b)(),
					t = p();
				return (n, s, o, a, d) => {
					var c, l;
					if (s && function(e) {
							return !e.startsWith("/") && null == e.match(r)
						}(n)) {
						const r = i(n, s, o, a, d);
						(null === (l = null === (c = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === c ? void 0 : c.serviceWorker) || void 0 === l ? void 0 : l.controller) ? t(r): e(r)
					}
				}
			}
		},
		"./src/reddit/hooks/usePostContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/sentry/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/reddit/contexts/Post/index.tsx");

			function a() {
				const e = Object(r.useContext)(o.c);
				return e || s.c.captureMessage("No post context provided"), e
			}
		},
		"./src/reddit/hooks/useTheme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/lib/CSSVariableProvider/index.tsx");

			function o() {
				return Object(s.useContext)(r.b)
			}
		},
		"./src/reddit/hooks/useTracking.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = s.b
		},
		"./src/reddit/hooks/useUserContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/contexts/User/index.tsx");

			function o() {
				return Object(s.useContext)(r.a)
			}
		},
		"./src/reddit/icons/fonts/Comment/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("i", c({
					className: Object(o.a)(Object(a.b)("comment", n.isFilled), d.a.commentIcon, t)
				}, n))
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactDownvote: "_2GCoZTwJW7199HSwNZwlHk",
				compactDownvoteWrapper: "jR747Vd1NbfaLusf5bHre",
				downvote: "ZyxIIl4FP5gHGrJDzNpUC",
				downvoteWrapper: "_1iKd82bq_nqObFvSH1iC_Q"
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Downvote/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(a.b)("downvote", e.isFilled), d.a.downvote, e.className)
			});
			t.a = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactDownvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactDownvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.downvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("caret_down",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less": function(e, t, n) {
			e.exports = {
				CollapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI",
				collapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less"),
				i = n.n(a);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("collapse",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "CollapseIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less": function(e, t, n) {
			e.exports = {
				ExpandIcon: "QOwFub52NskNmv0MdMa2_",
				expandIcon: "QOwFub52NskNmv0MdMa2_"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less"),
				i = n.n(a);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("expand",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "ExpandIcon", i.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/IgnoreReport/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("ignore_reports",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("info",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/ModActions/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("i", c({}, e, {
				className: Object(o.a)(Object(a.b)("mod", e.isFilled), d.a.modActions, e.className)
			}))
		},
		"./src/reddit/icons/fonts/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("external_link",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Premium/index.m.less": function(e, t, n) {
			e.exports = {
				PremiumIcon: "dLp3R7pmxclGjLS87yr5S",
				premiumIcon: "dLp3R7pmxclGjLS87yr5S"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Premium/index.m.less"),
				i = n.n(a);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				title: e.title,
				className: `${Object(o.b)("premium",e.isFilled)} ${e.className}`
			}), "PremiumIcon", i.a)
		},
		"./src/reddit/icons/fonts/Share/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(i);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(a.b)("share", e.isFilled), d.a.shareIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("tag",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactUpvote: "_39UOLMgvssWenwbRxz_iEn",
				compactUpvoteWrapper: "_3wVayy5JvIMI67DheMYra2",
				upvote: "_2Jxk822qXs4DaXwsN7yyHA",
				upvoteWrapper: "_2q7IQ0BUOWeEZoeAxN555e"
			}
		},
		"./src/reddit/icons/fonts/Upvote/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Upvote/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(a.b)("upvote", e.isFilled), d.a.upvote, e.className)
			});
			t.b = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactUpvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactUpvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.upvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/helpers.m.less": function(e, t, n) {
			e.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.m.less"),
				a = n.n(o),
				i = n("./src/lib/constants/icons.ts"),
				d = n("./src/lib/lessComponent.tsx");
			const c = (e, t) => `icon icon-${e}${t&&!e.includes("fill")&&i.a[`${e}_fill`]?"_fill":""}`,
				l = d.a.wrapped(e => r.a.createElement("span", {
					className: e.className
				}, e.children), "TooltipDesc", a.a)
		},
		"./src/reddit/icons/fonts/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/fonts/helpers.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const d = e => {
				let {
					className: t,
					isFilled: n,
					name: s,
					...d
				} = e;
				return r.a.createElement("i", i({
					className: Object(o.a)(t, Object(a.b)(s, n))
				}, d))
			};
			d.displayName = "Icon";
			const c = (e, t) => n => r.a.createElement(d, i({
				name: e
			}, t, n, {
				isFilled: (null == t ? void 0 : t.isFilled) || (null == n ? void 0 : n.isFilled),
				className: Object(o.a)(null == t ? void 0 : t.className, null == n ? void 0 : n.className)
			}));
			t.a = d
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, r.a.createElement("defs", null, r.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), r.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#svg-add-collection",
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/Admin/index.m.less": function(e, t, n) {
			e.exports = {
				admin: "_1PeZajQI0Wm8P3B45yshR",
				mEnabled: "_3axV0unm-cpsxoKWYwKh2x"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Admin/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, i.a.admin, {
					[i.a.mEnabled]: e.enabled
				}),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 -0.75 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M19.99,9.3125 C19.99,8.104375 19.010625,7.125 17.8025,7.125 C17.213125,7.125 16.67875,7.359375 16.285625,7.73875 C14.8075,6.6725 12.776875,5.98 10.514375,5.886875 L11.491875,1.2875 L14.695625,1.96875 C14.775,2.756875 15.433125,3.375 16.2425,3.375 C17.105625,3.375 17.805,2.675625 17.805,1.8125 C17.805,0.949375 17.105625,0.25 16.2425,0.25 C15.6575,0.25 15.154375,0.575 14.88625,1.050625 L11.228125,0.273125 C11.10625,0.24625 10.98,0.270625 10.875625,0.338125 C10.77125,0.40625 10.698125,0.5125 10.6725,0.63375 L9.556875,5.8825 C7.26,5.960625 5.1975,6.65625 3.7,7.735 C3.306875,7.358125 2.775,7.125 2.1875,7.125 C0.979375,7.125 0,8.104375 0,9.3125 C0,10.20125 0.530625,10.965 1.2925,11.306875 C1.25875,11.524375 1.24,11.745 1.24,11.96875 C1.24,15.334375 5.1575,18.0625 9.99,18.0625 C14.8225,18.0625 18.74,15.334375 18.74,11.96875 C18.74,11.746875 18.721875,11.5275 18.68875,11.31125 C19.455,10.97125 19.99,10.205 19.99,9.3125"
			})), r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("polygon", {
				points: "0 20 20 20 20 0 0 0"
			}), r.a.createElement("g", {
				transform: "translate(0 1)"
			})))
		},
		"./src/reddit/icons/svgs/ArrowRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 11.4 11.4",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "m11.17929,5.99479c0.08081,-0.19519 0.08081,-0.41599 0,-0.61118c-0.0408,-0.0984 -0.0992,-0.1864 -0.17361,-0.2608l-4.79963,-4.79911c-0.31283,-0.3128 -0.81847,-0.3128 -1.1313,0c-0.31283,0.31279 -0.31283,0.81918 0,1.13118l3.43471,3.43433l-7.66949,0c-0.44244,0 -0.80007,0.3584 -0.80007,0.79999c0,0.44159 0.35763,0.79999 0.80007,0.79999l7.66949,0l-3.43471,3.43433c-0.31283,0.3128 -0.31283,0.81919 0,1.13118c0.15601,0.156 0.36083,0.2344 0.56565,0.2344c0.20482,0 0.40964,-0.0784 0.56565,-0.2344l4.79963,-4.79911c0.07441,-0.0744 0.13281,-0.1624 0.17361,-0.2608"
			})))
		},
		"./src/reddit/icons/svgs/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_1vmueUAOJJg7fhS7wxztWa"
			}
		},
		"./src/reddit/icons/svgs/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.m.less"),
				i = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("svg", d({
					xmlns: "http://www.w3.org/2000/svg",
					width: "20",
					height: "20",
					viewBox: "0 0 20 20",
					className: Object(o.a)(i.a.checkbox, t)
				}, n), r.a.createElement("path", {
					fill: "inherit",
					d: "M1.66666667,3.34755033 L1.66666667,16.6524497 C1.66666667,17.5781756 2.42112363,18.3333333 3.34755033,18.3333333 L16.6524497,18.3333333 C17.5781756,18.3333333 18.3333333,17.5788764 18.3333333,16.6524497 L18.3333333,3.34755033 C18.3333333,2.42182438 17.5788764,1.66666667 16.6524497,1.66666667 L3.34755033,1.66666667 C2.42182438,1.66666667 1.66666667,2.42112363 1.66666667,3.34755033 Z M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z"
				}))
			}
		},
		"./src/reddit/icons/svgs/CheckboxSelected/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				xmlns: "http://www.w3.org/2000/svg",
				width: "20",
				height: "20",
				viewBox: "0 0 20 20"
			}, e), r.a.createElement("path", {
				fill: "inherit",
				d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M8.50575,15.1995 L15.797625,7.907625 C16.25325,7.452625 16.25325,6.71325 15.797625,6.25825 C15.342,5.802625 14.602625,5.802625 14.147625,6.25825 L7.7295,12.676375 L5.635125,10.327625 C5.20575,9.846375 4.46825,9.805125 3.987625,10.23325 C3.506375,10.662625 3.4645,11.400125 3.89325,11.88075 L6.810125,15.151375 C7.023875,15.39075 7.327,15.531375 7.647625,15.54075 C7.658875,15.54075 7.6695,15.541375 7.68075,15.541375 C7.990125,15.541375 8.287,15.41825 8.50575,15.1995 Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkmark/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 22",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/CheckmarkFitted/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "3 4 14 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/ChevronDown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/Circle/index.m.less": function(e, t, n) {
			e.exports = {
				circle: "_17IuRdA-NY8vFk-Tt991sn"
			}
		},
		"./src/reddit/icons/svgs/Circle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Circle/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(i.a.circle, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 8 8"
			}, r.a.createElement("g", {
				fill: "inherit",
				stroke: "none"
			}, r.a.createElement("circle", {
				r: "4",
				cy: "4",
				cx: "4"
			})))
		},
		"./src/reddit/icons/svgs/ClearFilled/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				onClick: e.onClick,
				onMouseUp: e.onMouseUp,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("path", {
				d: "M20 2.5C10.3 2.5 2.5 10.3 2.5 20c0 9.7 7.8 17.5 17.5 17.5S37.5 29.7 37.5 20C37.5 10.3 29.7 2.5 20 2.5zM24.2 27.7L20 23.5l-4.2 4.2c-1.1 1.1-2.5 1.1-3.5 0-1.1-1.1-1.1-2.4 0-3.5l4.2-4.2-4.2-4.2c-1.1-1.1-1.1-2.5 0-3.5 1.1-1.1 2.4-1.1 3.5 0l4.2 4.2 4.2-4.2c1.1-1.1 2.5-1.1 3.5 0 1.1 1.1 1.1 2.4 0 3.5L23.5 20l4.2 4.2c1.1 1.1 1.1 2.5 0 3.5C26.7 28.8 25.3 28.8 24.2 27.7z"
			}))
		},
		"./src/reddit/icons/svgs/Clock/index.m.less": function(e, t, n) {
			e.exports = {
				clock: "_3dezPhiKJXkVFXj94zLKcs"
			}
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Clock/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(i.a.clock, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), r.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/icons/svgs/Collection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M14 0H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 2h12c.77 0 1.468.301 2 .78V2a2 2 0 0 0-2-2zm0 3H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 5h12c.77 0 1.468.301 2 .78V5a2 2 0 0 0-2-2zM2 6h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z"
			})))
		},
		"./src/reddit/icons/svgs/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "XHbKeEqnW58ib9mTN6jnS",
				mRedditStyle: "u_kypUXmB-k1A5TcC8MI9"
			}
		},
		"./src/reddit/icons/svgs/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Dropdown/index.m.less"),
				i = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
				let {
					className: t,
					isSubreddit: n,
					...s
				} = e;
				return r.a.createElement("svg", d({
					className: Object(o.a)(i.a.dropdown, {
						[i.a.mRedditStyle]: !n
					}, t),
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, s), r.a.createElement("path", {
					d: "M14.17,9.35,10,13.53,5.83,9.35a.5.5,0,0,1,.35-.85h7.64a.5.5,0,0,1,.35.85"
				}))
			};
			t.b = c
		},
		"./src/reddit/icons/svgs/Event/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M4 16h12V9H4v7zM17 4h-2V3a1 1 0 0 0-2 0v1H7V3a1 1 0 0 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"
			})))
		},
		"./src/reddit/icons/svgs/Eye/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o(e) {
				return r.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 40 40"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					d: "M20,8C9.1,8,0.5,14,0.5,21.7h4c0-3.6,3.4-6.9,8.2-8.5C11,15,10,17.4,10,20c0,5.5,4.5,10,10,10s10-4.5,10-10c0-2.6-1-5-2.7-6.8c4.8,1.7,8.2,4.9,8.2,8.5h4C39.5,14,30.9,8,20,8z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Gild/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("g", {
				stroke: "none",
				strokeWidth: "1",
				fillRule: "evenodd"
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "m15.1275768 8.9935-2.059 2.204.371 2.992c.022.181-.055.359-.203.466-.087.064-.19.096-.294.096-.072 0-.144-.016-.211-.047l-2.73200003-1.277-2.731 1.277c-.164.076-.359.059-.506-.049-.148-.107-.225-.285-.202-.466l.37-2.992-2.059-2.204c-.124-.133-.166-.323-.11-.496s.202-.302.381-.336l2.96-.573 1.46-2.639c.175-.318.69900003-.318.87500003 0l1.46 2.639 2.959.573c.179.034.325.163.381.336s.014.363-.11.496m2.911-2.985-6.586-4.786c-.869-.63-2.03700003-.63-2.90600003 0v.001l-6.586 4.785c-.869.631-1.23 1.742-.898 2.764l2.515 7.743c.332 1.021 1.278 1.708 2.352 1.708h8.14000003c1.075 0 2.02-.687 2.352-1.708l2.516-7.743c.332-1.022-.03-2.133-.899-2.764"
			}))))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, n) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Grapple/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, i.a.grapple, {
					[i.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/HotPotato/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 32 32",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "#ff4500"
			}, r.a.createElement("path", {
				d: "m6.4 0h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m12.8 0h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m19.2 0h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m25.6 0h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m32 6.4h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m32 12.8h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m32 19.2h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m32 25.6h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m19.2 25.6h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m25.6 25.6h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m6.4 25.6h-6.4v6.4h6.4z"
			})), r.a.createElement("path", {
				d: "m19.2 12.8h-6.4v6.4h6.4z",
				fill: "#000"
			}), r.a.createElement("g", {
				fill: "#ff4500"
			}, r.a.createElement("path", {
				d: "m6.4 19.2h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m6.4 12.8h-6.4v6.4h6.4z"
			}), r.a.createElement("path", {
				d: "m6.4 6.4h-6.4v6.4h6.4z"
			})), r.a.createElement("path", {
				d: "m19.2 6.4h-12.8v25.6h6.4v-6.4h12.8v-19.2zm0 12.8h-6.4v-6.4h6.4z",
				fill: "#fff"
			}))
		},
		"./src/reddit/icons/svgs/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2irXdPA4C5flwkupsFkN9-"
			}
		},
		"./src/reddit/icons/svgs/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/ImageUpload/index.m.less"),
				i = n.n(a);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(i.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				opacity: "0",
				points: "0.610673352 20 20.625 20 20.625 0 0.610673352 0"
			}), r.a.createElement("path", {
				d: "M17.451,9.14823765 C17.03,5.40791696 13.8555,2.5 10,2.5 C6.1445,2.5 2.97,5.40791696 2.549,9.14823765 C1.0455,9.84024195 0,11.3551568 0,13.1173944 C0,15.531665 1.959,17.4892627 4.375,17.4892627 L7.8125,17.4892627 L7.8125,12.8051181 L5,12.8051181 C4.8735,12.8051181 4.7595,12.7291725 4.7115,12.6122563 C4.6625,12.49534 4.6895,12.3614359 4.779,12.272 L9.779,7.2755791 C9.901,7.15366643 10.099,7.15366643 10.221,7.2755791 L15.187,12.2375247 C15.2665,12.2944839 15.3185,12.3874173 15.3185,12.4928418 C15.3185,12.6652183 15.1785,12.8051181 15.006,12.8051181 L15,12.8051181 L12.1875,12.8051181 L12.1875,17.4892627 L15.625,17.4892627 C18.041,17.4892627 20,15.531665 20,13.1173944 C20,11.3551568 18.954,9.84024195 17.451,9.14823765",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Location/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 13 16",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "m10.4442 10.9445c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5m0-8.944c-3.554 0-6.444 2.891-6.444 6.444 0 3.32 5.143 8.658 5.73 9.256.189.192.446.3.714.3.269 0 .526-.108.714-.3.587-.598 5.73-5.936 5.73-9.256 0-3.553-2.89-6.444-6.444-6.444",
				fill: "inherit",
				fillRule: "evenodd",
				transform: "translate(-4 -2)"
			}))
		},
		"./src/reddit/icons/svgs/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 40 40",
				xmlns: "http://www.w3.org/2000/svg",
				fill: e.fill
			}, r.a.createElement("g", null, r.a.createElement("rect", {
				x: "7.5",
				y: "12.5",
				width: "0",
				height: "0"
			}), r.a.createElement("path", {
				fill: "inherit",
				d: "M32.5,17.5v-2.6c0-6.8-5.6-12.4-12.4-12.4h-0.2c-6.8,0-12.4,5.6-12.4,12.4v2.6C6.1,17.5,5,18.6,5,20v10c0,5.5,4.5,10,10,10h10c5.5,0,10-4.5,10-10V20C35,18.6,33.9,17.5,32.5,17.5z M12.5,17.5v-2.6c0-4.1,3.3-7.4,7.4-7.4h0.2c4.1,0,7.4,3.3,7.4,7.4v2.6H12.5z"
			})))
		},
		"./src/reddit/icons/svgs/ModLogPosts/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M15.5,7.75 L12.5,7.75 C12.224,7.75 12,7.526 12,7.25 C12,6.974 12.224,6.75 12.5,6.75 L15.5,6.75 C15.776,6.75 16,6.974 16,7.25 C16,7.526 15.776,7.75 15.5,7.75 Z M15.5,10.5 L12.5,10.5 C12.224,10.5 12,10.276 12,10 C12,9.724 12.224,9.5 12.5,9.5 L15.5,9.5 C15.776,9.5 16,9.724 16,10 C16,10.276 15.776,10.5 15.5,10.5 Z M15.5,13.25 L4.5,13.25 C4.224,13.25 4,13.026 4,12.75 C4,12.474 4.224,12.25 4.5,12.25 L15.5,12.25 C15.776,12.25 16,12.474 16,12.75 C16,13.026 15.776,13.25 15.5,13.25 Z M4.5,16 C4.224,16 4,15.776 4,15.5 C4,15.224 4.224,15 4.5,15 L15.5,15 C15.776,15 16,15.224 16,15.5 C16,15.776 15.776,16 15.5,16 L4.5,16 Z M4,4.5 C4,4.224 4.224,4 4.5,4 L9.813,4 C10.089,4 10.313,4.224 10.313,4.5 L10.313,10 C10.313,10.276 10.089,10.5 9.813,10.5 L4.5,10.5 C4.224,10.5 4,10.276 4,10 L4,4.5 Z M3,2 C2.447,2 2,2.447 2,3 L2,17 C2,17.553 2.447,18 3,18 L17,18 C17.553,18 18,17.553 18,17 L18,3 C18,2.447 17.553,2 17,2 L3,2 Z"
			})))
		},
		"./src/reddit/icons/svgs/Moderate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/colors.ts");
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("path", {
				d: "M1.88,3.32V9a11.53,11.53,0,0,0,8,11L10,20l.08,0a11.53,11.53,0,0,0,8-11V3.32A11.57,11.57,0,0,1,10,0,11.57,11.57,0,0,1,1.88,3.32"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "5",
				fill: e.isUnread ? "white" : "none"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "4",
				fill: e.isUnread ? o.a.orangered : "none"
			}))
		},
		"./src/reddit/icons/svgs/Negative/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 10 10"
			}, r.a.createElement("path", {
				d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M6.2103,5.78636 C6.3275,5.90356 6.3275,6.09356 6.2103,6.21076 C6.1519,6.26916 6.0751,6.29836 5.9983,6.29836 C5.9211,6.29836 5.8447,6.26916 5.7859,6.21076 L4.9983,5.42276 L4.2103,6.21076 C4.1519,6.26916 4.0751,6.29836 3.9983,6.29836 C3.9211,6.29836 3.8447,6.26916 3.7859,6.21076 C3.6687,6.09356 3.6687,5.90356 3.7859,5.78636 L4.5739,4.99836 L3.7859,4.21076 C3.6687,4.09356 3.6687,3.90356 3.7859,3.78636 C3.9031,3.66916 4.0931,3.66916 4.2103,3.78636 L4.9983,4.57436 L5.7859,3.78636 C5.9031,3.66916 6.0931,3.66916 6.2103,3.78636 C6.3275,3.90356 6.3275,4.09356 6.2103,4.21076 L5.4223,4.99836 L6.2103,5.78636 Z M7.4023,2.59436 C6.0767,1.26836 3.9195,1.26916 2.5939,2.59436 C1.2687,3.91996 1.2687,6.07716 2.5939,7.40276 C3.2567,8.06556 4.1275,8.39676 4.9983,8.39676 C5.8687,8.39676 6.7395,8.06556 7.4023,7.40276 C8.7279,6.07716 8.7279,3.91996 7.4023,2.59436 Z"
			}))
		},
		"./src/reddit/icons/svgs/Nsfw/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 40 40",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M38.5,16.5l-15-15c-2-2-5.1-2-7.1,0l-15,15c-2,2-2,5.1,0,7.1l15,15c2,2,5.1,2,7.1,0l15-15 C40.5,21.6,40.5,18.4,38.5,16.5z M17.7,8.3C17.7,7,18.7,6,20,6s2.3,1,2.3,2.3v14.3c0,1.3-1,2.3-2.3,2.3s-2.3-1-2.3-2.3V8.3z M20,33.7c-1.7,0-3.1-1.4-3.1-3.1c0-1.7,1.4-3.1,3.1-3.1s3.1,1.4,3.1,3.1C23.1,32.4,21.7,33.7,20,33.7z"
			})))
		},
		"./src/reddit/icons/svgs/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M15.75,7.834625 L12,4.084625 L12.808,3.276625 C13.8435,2.241125 15.5225,2.241125 16.558,3.276625 C17.5935,4.312125 17.5935,5.991125 16.558,7.026625 L15.75,7.834625 Z M11.366,5 L15.116,8.75 L7.25,16.616 L3.5,12.866 L11.366,5 Z M2.5035,13.5 L6.1125,17.109 L1,18.6125 L2.5035,13.5 Z"
			})))
		},
		"./src/reddit/icons/svgs/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1"
			}, r.a.createElement("g", {
				stroke: "none"
			}, r.a.createElement("g", {
				transform: "translate(-34.000000, -136.000000)",
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M45.2,147.2 L48.8,147.2 C49.46272,147.2 50,146.66272 50,146 C50,145.33728 49.46272,144.8 48.8,144.8 L45.2,144.8 L45.2,141.2 C45.2,140.53728 44.66272,140 44,140 C43.33728,140 42.8,140.53728 42.8,141.2 L42.8,144.8 L39.2,144.8 C38.53728,144.8 38,145.33728 38,146 C38,146.66272 38.53728,147.2 39.2,147.2 L42.8,147.2 L42.8,150.8 C42.8,151.46272 43.33728,152 44,152 C44.66272,152 45.2,151.46272 45.2,150.8 L45.2,147.2 Z"
			}))))
		},
		"./src/reddit/icons/svgs/Positive/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 10 10"
			}, r.a.createElement("path", {
				d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M8.0828,3.27736 L7.5232,2.71736 C7.448,2.64216 7.3464,2.60016 7.2404,2.60016 C7.134,2.60016 7.0324,2.64216 6.9576,2.71736 L4.16,5.51456 L3.0428,4.39736 C2.8868,4.24096 2.6336,4.24096 2.4772,4.39736 L1.9172,4.95736 C1.7608,5.11376 1.7608,5.36696 1.9172,5.52296 L3.8772,7.48296 C3.9556,7.56096 4.0576,7.60016 4.16,7.60016 C4.2624,7.60016 4.3648,7.56096 4.4428,7.48296 L8.0828,3.84296 C8.2392,3.68656 8.2392,3.43376 8.0828,3.27736 Z"
			}))
		},
		"./src/reddit/icons/svgs/Post/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M5,15a1,1,0,0,1-1-1V11.17a1,1,0,0,1,.29-.7l8.09-8.09a1,1,0,0,1,1.41,0l2.83,2.83a1,1,0,0,1,0,1.41L8.54,14.71a1,1,0,0,1-.71.29Zm12,1a1,1,0,0,1,0,2H3a1,1,0,0,1,0-2Z"
			}))
		},
		"./src/reddit/icons/svgs/Premium/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M13.535 15.785c-1.678.244-2.883.742-3.535 1.071v-5.113a2 2 0 0 0-2-2H4.217c.044-.487.076-1.016.076-1.629 0-1.692-.489-2.968-.884-3.722L4.8 3.001H10v4.742a2 2 0 0 0 2 2h3.783c.06.67.144 1.248.22 1.742.097.632.182 1.177.182 1.745 0 1.045-.829 2.291-2.65 2.555m5.028-12.249l-2.242-2.242a1 1 0 0 0-.707-.293H4.386a1 1 0 0 0-.707.293L1.436 3.536a1 1 0 0 0-.069 1.337c.009.011.926 1.2.926 3.241 0 1.304-.145 2.24-.273 3.065-.106.684-.206 1.33-.206 2.051 0 1.939 1.499 4.119 4.364 4.534 2.086.304 3.254 1.062 3.261 1.065a1.016 1.016 0 0 0 1.117.004c.011-.007 1.18-.765 3.266-1.069 2.864-.415 4.363-2.595 4.363-4.534 0-.721-.099-1.367-.206-2.051-.128-.825-.272-1.761-.272-3.065 0-2.033.893-3.199.926-3.241a.999.999 0 0 0-.07-1.337"
			}))
		},
		"./src/reddit/icons/svgs/PremiumCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("rect", {
				width: "20",
				height: "20",
				rx: "10",
				fill: "url(#gradient)"
			}), r.a.createElement("path", {
				d: "M12.121 13.471c-1.007.146-1.73.445-2.121.643v-3.068a1.2 1.2 0 00-1.2-1.2H6.53c.027-.292.046-.61.046-.978 0-1.015-.294-1.78-.53-2.233l.834-.834H10v2.845a1.2 1.2 0 001.2 1.2h2.27c.036.402.086.749.132 1.045.058.38.109.706.109 1.047 0 .627-.497 1.375-1.59 1.533zm3.017-7.35l-1.345-1.345a.6.6 0 00-.425-.175H6.632a.6.6 0 00-.425.175L4.862 6.122a.6.6 0 00-.042.802c.006.006.556.72.556 1.944 0 .783-.087 1.344-.164 1.84-.064.41-.124.797-.124 1.23 0 1.163.9 2.471 2.619 2.72 1.251.183 1.952.638 1.956.64a.61.61 0 00.67.002c.007-.004.709-.46 1.96-.642 1.719-.249 2.618-1.557 2.618-2.72 0-.433-.06-.82-.124-1.23a11.026 11.026 0 01-.163-1.84c0-1.22.536-1.919.556-1.944a.6.6 0 00-.042-.802z",
				fill: "#fff"
			}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
				id: "gradient",
				x1: "0",
				y1: "20",
				x2: "20.021",
				y2: "19.979",
				gradientUnits: "userSpaceOnUse"
			}, r.a.createElement("stop", {
				stopColor: "#EC0623"
			}), r.a.createElement("stop", {
				offset: "1",
				stopColor: "#FF8717"
			}))))
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.m.less": function(e, t, n) {
			e.exports = {
				defaultInactiveState: "_1g3Xfh9mljLHWv24M9A3Rw",
				outline: "_3SlBAJb2MbUHwgBZFH8eL7",
				highlighted: "_1-JQy00VxG8hpTxxdxV32y"
			}
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/PresenceCircle/index.m.less"),
				i = n.n(a);
			t.a = Object(s.forwardRef)((e, t) => {
				let {
					className: n,
					isHighlighted: s,
					outlineClassName: a
				} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(i.a.defaultInactiveState, n),
					viewBox: "0 0 12 12",
					xmlns: "http://www.w3.org/2000/svg",
					width: "12",
					height: "12",
					ref: t
				}, r.a.createElement("circle", {
					cx: "6",
					cy: "6",
					r: "4"
				}), r.a.createElement("path", {
					className: Object(o.a)(i.a.outline, a, {
						[i.a.highlighted]: s
					}),
					fillRule: "evenodd",
					clipRule: "evenodd",
					d: "M12 6C12 9.31371 9.31371 12 6 12C2.68629 12 0 9.31371 0 6C0 2.68629 2.68629 0 6 0C9.31371 0 12 2.68629 12 6ZM6 10C8.20914 10 10 8.20914 10 6C10 3.79086 8.20914 2 6 2C3.79086 2 2 3.79086 2 6C2 8.20914 3.79086 10 6 10Z"
				}))
			})
		},
		"./src/reddit/icons/svgs/RadioOff/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11Rht_b1e-kmk12gkz7Lug"
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.m.less"),
				i = n.n(a);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", d({}, e, {
				className: Object(o.a)(i.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,1.66666667 C5.39762708,1.66666667 1.66666667,5.39762708 1.66666667,10 C1.66666667,14.6023729 5.39762708,18.3333333 10,18.3333333 C14.6023729,18.3333333 18.3333333,14.6023729 18.3333333,10 C18.3333333,5.39762708 14.6023729,1.66666667 10,1.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/RadioOn/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,6.66666667 C8.15905083,6.66666667 6.66666667,8.15905083 6.66666667,10 C6.66666667,11.8409492 8.15905083,13.3333333 10,13.3333333 C11.8409492,13.3333333 13.3333333,11.8409492 13.3333333,10 C13.3333333,8.15905083 11.8409492,6.66666667 10,6.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/Redditor/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 250 250",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M146.8 142.6h-37.6c-31.1 0-56.5 25.3-56.5 56.5 0 5.2 4.2 9.4 9.4 9.4h131.8c5.2 0 9.4-4.2 9.4-9.4 0-31.2-25.3-56.5-56.5-56.5zM128 130.7c20.1 0 36.4-16.3 36.4-36.4v-9.4c0-20.1-16.3-36.4-36.4-36.4S91.6 64.8 91.6 84.9v9.4c0 20.1 16.3 36.4 36.4 36.4z"
			})))
		},
		"./src/reddit/icons/svgs/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				tabIndex: e.tabIndex,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fillRule: "evenodd",
				d: "M13.5559061,14.5 C13.5559061,14.776 13.3283409,15 13.0479481,15 C12.7675552,15 12.53999,14.776 12.53999,14.5 L12.53999,9 C12.53999,8.724 12.7675552,8.5 13.0479481,8.5 C13.3283409,8.5 13.5559061,8.724 13.5559061,9 L13.5559061,14.5 Z M10.508158,14.5 C10.508158,14.776 10.2805928,15 10.0002,15 C9.71980718,15 9.49224199,14.776 9.49224199,14.5 L9.49224199,9 C9.49224199,8.724 9.71980718,8.5 10.0002,8.5 C10.2805928,8.5 10.508158,8.724 10.508158,9 L10.508158,14.5 Z M7.46040996,14.5 C7.46040996,14.776 7.23284477,15 6.95245195,15 C6.67205913,15 6.44449394,14.776 6.44449394,14.5 L6.44449394,9 C6.44449394,8.724 6.67205913,8.5 6.95245195,8.5 C7.23284477,8.5 7.46040996,8.724 7.46040996,9 L7.46040996,14.5 Z M15.492242,6 C15.7736507,6 16.0002,6.224 16.0002,6.5 L16.0002,16.5 C16.0002,17.327 15.3164885,18 14.476326,18 L5.52407403,18 C4.68391148,18 4.0002,17.327 4.0002,16.5 L4.0002,6.5 C4.0002,6.224 4.22674927,6 4.50815801,6 L15.492242,6 Z M15.491585,3 C15.7719541,3 15.9995,3.224 15.9995,3.5 L15.9995,4.5 C15.9995,4.776 15.7719541,5 15.491585,5 L4.50741501,5 C4.22704592,5 3.9995,4.776 3.9995,4.5 L3.9995,3.5 C3.9995,3.224 4.22704592,3 4.50741501,3 L7.51325603,3 L8.26598607,2.167 C8.36248993,2.061 8.50064281,2 8.6459065,2 L11.3541093,2 C11.4983572,2 11.6365101,2.061 11.7340298,2.167 L12.485744,3 L15.491585,3 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Search/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M15.59,13.91l2.78,2.69a1.25,1.25,0,1,1-1.74,1.8l-2.82-2.73a8,8,0,1,1,1.78-1.76ZM14.64,9.2A5.45,5.45,0,1,0,9.2,14.64,5.45,5.45,0,0,0,14.64,9.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Settings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M7.03093403,10 C7.03093403,8.36301971 8.36301971,7.03093403 10,7.03093403 C11.6369803,7.03093403 12.9679409,8.36301971 12.9679409,10 C12.9679409,11.6369803 11.6369803,12.969066 10,12.969066 C8.36301971,12.969066 7.03093403,11.6369803 7.03093403,10 M16.4016617,8.49127796 C16.2362761,7.79148295 15.9606334,7.13669084 15.5916096,6.5437777 L16.5231696,5.06768276 C16.7526843,4.70315931 16.7684353,4.22387849 16.5231696,3.83572852 C16.1833977,3.29794393 15.4712269,3.13593351 14.9323172,3.47683044 L13.4562223,4.40839036 C12.8633092,4.03936662 12.208517,3.76259882 11.508722,3.59833825 L11.1250724,1.89947899 C11.0294412,1.47982699 10.7020452,1.12992949 10.2542664,1.02867298 C9.63322641,0.888038932 9.01556168,1.27843904 8.87492764,1.89947899 L8.49127796,3.59833825 C7.79148295,3.76259882 7.13669084,4.03936662 6.54265263,4.40726528 L5.06768276,3.47683044 C4.70315931,3.24731568 4.22387849,3.23156466 3.83572852,3.47683044 C3.29794393,3.81660229 3.13593351,4.5287731 3.47683044,5.06768276 L4.40726528,6.54265263 C4.03936662,7.13669084 3.76259882,7.79148295 3.59721318,8.49127796 L1.89947899,8.87492764 C1.47982699,8.97055879 1.12992949,9.29795485 1.02867298,9.74573365 C0.888038932,10.3667736 1.27843904,10.9844383 1.89947899,11.1250724 L3.59721318,11.508722 C3.76259882,12.208517 4.03936662,12.8633092 4.40726528,13.4573474 L3.47683044,14.9323172 C3.24731568,15.2968407 3.23156466,15.7761215 3.47683044,16.1642715 C3.81660229,16.7020561 4.5287731,16.8640665 5.06768276,16.5231696 L6.54265263,15.5927347 C7.13669084,15.9606334 7.79148295,16.2374012 8.49127796,16.4016617 L8.87492764,18.100521 C8.97055879,18.520173 9.29795485,18.8700705 9.74573365,18.971327 C10.3667736,19.1119611 10.9844383,18.721561 11.1250724,18.100521 L11.508722,16.4016617 C12.208517,16.2374012 12.8633092,15.9606334 13.4562223,15.5916096 L14.9323172,16.5231696 C15.2968407,16.7526843 15.7749964,16.7684353 16.1631464,16.5231696 C16.7020561,16.1833977 16.8629414,15.4712269 16.5231696,14.9323172 L15.5916096,13.4562223 C15.9606334,12.8633092 16.2362761,12.208517 16.4016617,11.508722 L18.100521,11.1250724 C18.520173,11.0294412 18.8700705,10.7020452 18.971327,10.2542664 C19.1119611,9.63322641 18.721561,9.01556168 18.100521,8.87492764 L16.4016617,8.49127796 Z"
			})))
		},
		"./src/reddit/icons/svgs/Show/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M17.71,10.29,14.95,7.54a7,7,0,0,0-9.9,0L2.29,10.29a1,1,0,0,0,1.41,1.41L6.46,8.95c.07-.07.14-.11.21-.17a4,4,0,1,0,6.65,0c.07.06.15.11.21.17l2.76,2.76a1,1,0,0,0,1.41-1.41Z"
			}))
		},
		"./src/reddit/icons/svgs/SnooHappy/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 24 25",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				fill: "#000",
				d: "M19.7 9.4c-.6.2-1.1 0-1.6-.3-1.3-.8-2.6-1.4-4.2-1.5-1.2-.1-1.8-.1-2.3 0-1.1.2-2.2.4-3.2.7-.6.2-1.1.6-1.7.8-.2.1-.5.2-.7.2-2.3-.6-4.1.2-5.4 2.2-1.1 1.7-.4 4.4.9 5.3.2.2.5.5.5.8.1 2.1 1.2 3.6 2.7 4.8.1.1.2.1.3.2.6.4 1.9 1.2 3 1.5 1.5.5 3 .7 4.5.7 1.5-.1 3-.1 4.4-.6.4-.2 2.3-1.1 3.4-2.2 1.2-1.5 2.3-3 2.5-4.9.1-1 .4-1.8.9-2.7.2-.3.2-.6.3-.9.4-2.5-2-5-4.3-4.1z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M20.9 10c-.4-.1-.8 0-1.4 0 1 1.1 1.8 2.1 2.2 3.4-2.2-3.2-5.3-5.1-9.1-5.1s-7 1.6-9.2 4.9c-.1-.3-.3-.6-.2-.7.5-1 1.2-1.9 2.3-2.5-1.7-.5-3.5.4-4.4 2.2-.7 1.4-.3 3.3.9 4.1l.3-1.2c.1-.4.4-.7.6-1 .1.2.1.3 0 .4-.5 1.5-.3 3 .2 4.5.5 1 1.1 2 2.1 2.8 3.9 2.9 9.4 3.6 13.8.5 1.9-1.3 2.9-3.3 3.1-5.7.1-.6.1-1.2.1-1.8.1 0 .1.1.2.1.2-.2.6-.3.7-.5.7-1.7-.4-3.9-2.2-4.4z"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M10.1 15.4s-.3-.1-.4-.2l-.6-.6c-.8-.5-1.6-.3-2.2.5-.2.3-.3.5-.5.8-.1.1-.3.2-.5.3-.1-.2-.2-.4-.2-.6.1-.4.3-.7.3-.9 1.1-1.7 3.3-1.8 4.1-.3.1.2.2.3.2.5s-.1.4-.2.5zm3.1 6.5c-2.3 0-4-1.6-4.4-3.4 0-.1.3-.4.6-.5 2-.8 5-1.1 7.2-.4.2.1.5.2.5.3 0 .1-.3.2-.3.3-.4 1.7-1.5 3.7-3.6 3.7zm5.9-6.5c-.1 0-.3-.1-.4-.2-.1 0-.1-.1-.1-.2-.6-.9-1.4-1-2.2-.3-.2.2-.5.2-.7.4.1-.3 0-.7.2-.9.7-.9 1.8-1.1 2.7-.5.2.2.6.9.8 1.4-.1.1-.2.3-.3.3zM16.6.5c-.5-.4-1.4-.7-2.3-.2-.4.2-.7.5-.8.7-.2.7-.2 1.1-.1 1.5-1 1-2.2 1.6-3.6 1.7-.2 0-.4.2-.4.4-.1.5.1.9.4 1.4.5.7.7 1.2.9 1.9V8c.1.2.2.2.4.2.1 0 .2-.1.3-.1.1-.1.1-.2.1-.3v-.2c0-.1-.1-.3-.1-.4-.1-.3-.2-.6-.3-.8-.1-.2-.2-.3-.3-.4-.1-.3-.3-.8-.3-1.1.5-.1 1.1-.2 1.6-.5.4-.2.7-.5 1-.8.2-.2.3-.3.5-.4.4.5.8.7 1.6.8h.2c.4 0 .9-.2 1.3-.5s.6-.8.6-1.4c.1-.6-.2-1.2-.7-1.6z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M14 1.9c-.1-.6.4-1.1 1.1-1.2.8-.1 1.4.3 1.5 1 .1.7-.5 1.5-1.1 1.6-.7.1-1.4-.6-1.5-1.4z"
			}))
		},
		"./src/reddit/icons/svgs/SnooSilhouette/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 320 320",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "m124.91 237.79c-53.47 32.9-28.3 109.77-9.81 76.9"
			}), r.a.createElement("path", {
				d: "m115.13 314.7a9.86 9.86 0 0 1 -1.44 3l-.85 1.22c-.34.4-.68.85-1.09 1.28a11.46 11.46 0 0 1 -3 2.34 7.26 7.26 0 0 1 -4.16.82 8.13 8.13 0 0 1 -3.86-1.63 14 14 0 0 1 -2.64-2.62 26.58 26.58 0 0 1 -1.7-2.45c-3.11-5.09-4.59-11.37-5.16-17.65a66.18 66.18 0 0 1 6.12-33.55 69 69 0 0 1 3.7-6.66 68.22 68.22 0 0 1 4.3-5.93 62.51 62.51 0 0 1 9.65-9.4 61.54 61.54 0 0 1 9.62-6.13c-2.15 2.3-5.35 5.36-8.11 8.41s-5.19 6-6.61 7.42a56.91 56.91 0 0 0 -7.33 9.28 58.25 58.25 0 0 0 -5 10 60.67 60.67 0 0 0 -4 20 53 53 0 0 0 2.33 17.65 28.76 28.76 0 0 0 3.32 7.14c1.39 2 3.15 3.76 5.17 4.28a5.79 5.79 0 0 0 3.36-.19 11.09 11.09 0 0 0 3.45-2.14 29.87 29.87 0 0 0 3.93-4.49z"
			}), r.a.createElement("path", {
				d: "m194.69 240.89c45.74 25.85 23.37 107.54 4.1 73.8"
			}), r.a.createElement("path", {
				d: "m198.81 314.67a17 17 0 0 1 2 2.41 16.1 16.1 0 0 0 4.54 4.16 6.1 6.1 0 0 0 3.23.79 5.88 5.88 0 0 0 3-1.15 12.67 12.67 0 0 0 3.58-4.37c2.39-4.65 3.64-10.3 4.24-16a71.58 71.58 0 0 0 -.3-17 66.16 66.16 0 0 0 -9-25.89 54.68 54.68 0 0 0 -15.7-16.28 30.16 30.16 0 0 1 10.19 5 29.29 29.29 0 0 1 7.11 7.13 68.35 68.35 0 0 1 8.62 21.25 81.56 81.56 0 0 1 2 19.91 58.88 58.88 0 0 1 -2.83 17.4 27.36 27.36 0 0 1 -3.67 7.28 13.8 13.8 0 0 1 -2.85 2.86 7.81 7.81 0 0 1 -3.8 1.51 6.82 6.82 0 0 1 -4.21-1 11.92 11.92 0 0 1 -3.25-3 24.69 24.69 0 0 1 -2.9-5.01z"
			}), r.a.createElement("path", {
				d: "m125.46 236.86c32.07-45.32 77.78-13.73 79.92 56.7-.5 46.56-23 35.27-51.14 35.27s-42.05 9.17-44.66-24.83c-1.5-19.46-.66-20.87 3.28-33"
			}), r.a.createElement("path", {
				d: "m112.89 271a23.38 23.38 0 0 1 -.68 2.76c-.41 1.47-1 3.44-1.61 5.81a38.08 38.08 0 0 0 -1.14 8.22c-.12 3.08.07 6.43.29 9.9.51 6.92 1 14.41 3.16 20.71a16.43 16.43 0 0 0 4.9 7.54 13.56 13.56 0 0 0 6.7 2.65 56.37 56.37 0 0 0 11.6-.1c4-.32 8-.71 12.18-.92a124.9 124.9 0 0 1 12.55-.09c4.2.16 8.4.49 12.56.7 2.08.1 4.15.18 6.2.15a40.17 40.17 0 0 0 6.05-.44 22.51 22.51 0 0 0 5.6-1.55 14.89 14.89 0 0 0 4.6-3.17 17.38 17.38 0 0 0 3.27-4.6l.33-.64.29-.67.56-1.34c.3-.93.65-1.84.9-2.79a62.06 62.06 0 0 0 1.9-11.66 108.3 108.3 0 0 0 -.63-20.6 130.55 130.55 0 0 0 -3.86-20 94.18 94.18 0 0 0 -7.15-18.4 59.18 59.18 0 0 0 -11-15.23c-4.38-4.24-9.48-7.58-15-9a27.57 27.57 0 0 0 -16.33.49 39.21 39.21 0 0 0 -13.41 7.9 74.8 74.8 0 0 0 -9.76 10.58 61.55 61.55 0 0 1 8.78-11.74 39.25 39.25 0 0 1 14.45-9.6 31.64 31.64 0 0 1 8.59-1.83h2.12a13 13 0 0 1 2.08.09 28.29 28.29 0 0 1 3.93.63 31.93 31.93 0 0 1 11.28 5.06 50.46 50.46 0 0 1 12 12.46 74.93 74.93 0 0 1 7.89 14.59 117.86 117.86 0 0 1 7.81 30.35c.15 1.25.31 2.5.46 3.75s.22 2.49.32 3.73c.26 2.48.3 5 .43 7.41a34.56 34.56 0 0 1 0 3.67c0 1.22-.07 2.44-.16 3.64s-.14 2.41-.28 3.6-.23 2.38-.43 3.56-.34 2.36-.6 3.52-.51 2.32-.82 3.46a16.49 16.49 0 0 1 -.52 1.69c-.19.56-.36 1.12-.57 1.68a32.08 32.08 0 0 1 -1.48 3.21 19.92 19.92 0 0 1 -4.28 5.58 18.29 18.29 0 0 1 -6 3.5 37.52 37.52 0 0 1 -13.18 1.66c-4.33-.07-8.53-.42-12.65-.67s-8.17-.43-12.14-.36-7.88.29-11.73.58-7.66.61-11.47.63a34.51 34.51 0 0 1 -5.73-.4 17.16 17.16 0 0 1 -5.52-1.82 13.8 13.8 0 0 1 -4.34-3.84 19.11 19.11 0 0 1 -2.64-4.9 44.16 44.16 0 0 1 -2.39-10.24c-.44-3.22-.63-7-.81-11a93.65 93.65 0 0 1 .09-12 37.54 37.54 0 0 1 .92-5.5c.42-1.71.94-3.25 1.4-4.62.96-2.66 1.74-4.74 2.12-5.74z"
			}), r.a.createElement("path", {
				d: "m229 74.81c-1 .47-5.78-2.28-11.24-5.44s-11.7-6.6-15.42-7.94c-3.26-1.22-6.62-2.41-10-3.36a43 43 0 0 0 -4.93-1.07 13.89 13.89 0 0 0 -4.19-.08 3.6 3.6 0 0 0 -1.2.4c-.13.08-.17.17-.27.22s-.12.11-.14.24l-1 1.75c-.42.78-.91 1.53-1.29 2.34-.8 1.58-1.62 3.14-2.3 4.75s-1.34 3.2-2 4.78c-4.19 11.17-6.17 23.06-7.52 34.18s-2.05 21.46-3.05 29.85a36 36 0 0 1 -3.83-6.41 58 58 0 0 1 -2.89-7.72c-1.5-5.24-2.06-10.33-1.53-13a266.73 266.73 0 0 1 7.37-29.3 114.2 114.2 0 0 1 10.81-24.11l.39-.67.2-.33.09-.17.16-.2a8.58 8.58 0 0 1 1.33-1.56l.78-.69.86-.53a9.4 9.4 0 0 1 1.8-.83 15.64 15.64 0 0 1 6.86-.52 44.74 44.74 0 0 1 11.26 3.14 87 87 0 0 1 17.63 9.78c4.93 3.27 11.92 10.94 13.26 12.5z"
			}), r.a.createElement("path", {
				d: "m105.63 128c-43.28-20.15-74.18 36.54-30.75 61.74"
			}), r.a.createElement("path", {
				d: "m74.86 189.75c-.5 0-4.4-2-8.31-5.22-.94-.85-2-1.65-2.88-2.59s-1.82-1.86-2.61-2.82-1.51-1.9-2.15-2.77-1.13-1.7-1.57-2.38a32.77 32.77 0 0 1 -5-17.32 36.58 36.58 0 0 1 1.3-9.37c.22-.76.5-1.49.74-2.24l.39-1.1.47-1.07c.33-.7.62-1.42 1-2.11s.76-1.33 1.13-2a34 34 0 0 1 24.86-16.35 36.14 36.14 0 0 1 13.32.9 42.71 42.71 0 0 1 10.39 4.17c-3.08-.41-7.27-1.42-11.25-1.59a81.76 81.76 0 0 0 -9.48-.06 29.42 29.42 0 0 0 -11 2.08 30.48 30.48 0 0 0 -9.21 5.75 31.36 31.36 0 0 0 -8.27 34 38.69 38.69 0 0 0 7.82 12.76 66.35 66.35 0 0 0 5.7 5.64 36 36 0 0 0 2.84 2.34z"
			}), r.a.createElement("path", {
				d: "m254.61 176.52c30.45-26.89-2.76-71.55-39.71-54.67"
			}), r.a.createElement("path", {
				d: "m214.89 121.83a9.6 9.6 0 0 1 2.48-1.41 20.3 20.3 0 0 1 2.51-1l1.47-.51c.5-.18 1.05-.27 1.59-.42a28.32 28.32 0 0 1 3.37-.69 28.71 28.71 0 0 1 3.38-.39 46.61 46.61 0 0 1 5.63 0 34.21 34.21 0 0 1 15.32 4.6l1.79 1.09c.59.37 1.13.81 1.7 1.22a35.6 35.6 0 0 1 8.53 8.92 32.62 32.62 0 0 1 5.34 12.84 30.43 30.43 0 0 1 -.56 13.24 31.13 31.13 0 0 1 -5.33 10.68 36.88 36.88 0 0 1 -7.12 7c1.37-2.44 3.58-5.54 5.05-8.73.43-.76.7-1.59 1-2.31.16-.38.35-.73.49-1.09l.38-1c.24-.68.53-1.28.72-1.84a13.79 13.79 0 0 1 .52-1.42 26.43 26.43 0 0 0 .49-19 31.61 31.61 0 0 0 -4.13-8 35.33 35.33 0 0 0 -5.79-6.19c-.52-.45-1.08-.83-1.62-1.24a15 15 0 0 0 -1.64-1.14l-1.68-1-1.72-.88-.85-.44c-.28-.13-.58-.24-.87-.36l-1.73-.71c-.58-.21-1.17-.37-1.74-.56a17.9 17.9 0 0 0 -1.73-.5 40.08 40.08 0 0 0 -13.23-.93c-.49.06-1 .1-1.6.14l-1.76.27c-.6.09-1.23.15-1.84.26l-1.81.39c-.59.13-1.17.22-1.7.37l-1.46.41z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z",
				fill: "none"
			}), r.a.createElement("path", {
				d: "m159.25 111.2a100.82 100.82 0 0 1 14.86.32 130.39 130.39 0 0 1 30.18 6.06 97.07 97.07 0 0 1 16.43 7.17 78.93 78.93 0 0 1 14.49 10.25 63.78 63.78 0 0 1 16.79 23.82 67.61 67.61 0 0 1 4.45 19.57c.13 1.7.15 3.4.22 5.11v3.89l-.11 1.3-.22 2.61-.42 2.6a23.2 23.2 0 0 1 -.54 2.58c-.22.85-.37 1.72-.67 2.56a49.79 49.79 0 0 1 -4.15 9.79 56.7 56.7 0 0 1 -6.2 8.74 68 68 0 0 1 -7.75 7.43 78.42 78.42 0 0 1 -8.81 6.14c-12.32 7.38-26.19 11.74-40.07 14.24a168.29 168.29 0 0 1 -41.54 2.05 148 148 0 0 1 -34.89-6.69c-11.22-3.67-22-9-31-16.58a56.52 56.52 0 0 1 -11.6-13.16 48.93 48.93 0 0 1 -6.51-16.08 50.29 50.29 0 0 1 -.46-17 66.24 66.24 0 0 1 4.18-16 70.76 70.76 0 0 1 18.09-25.69 90.75 90.75 0 0 1 24.8-15.93 101.47 101.47 0 0 1 13.06-4.78 112.2 112.2 0 0 1 12.93-3c2.12-.41 4.24-.65 6.32-1s4.15-.47 6.2-.57c4.08-.33 8.06-.33 11.91-.29a142.44 142.44 0 0 0 -24.22 3.34 117.79 117.79 0 0 0 -26.52 9.42 92.75 92.75 0 0 0 -21.58 14.9 77.13 77.13 0 0 0 -12.25 14.6 62.07 62.07 0 0 0 -9.53 25.39 45.71 45.71 0 0 0 3.46 25.86 53.67 53.67 0 0 0 16.28 19.83 87.52 87.52 0 0 0 22.14 12.14 129.68 129.68 0 0 0 23.75 6.56 160.17 160.17 0 0 0 23.78 2.47 157.94 157.94 0 0 0 45.17-5.1 113.68 113.68 0 0 0 20.3-7.54 86.22 86.22 0 0 0 9.16-5.19 73.68 73.68 0 0 0 8.22-6.24 52.36 52.36 0 0 0 12.26-15.71l.56-1.09.48-1.13c.3-.76.64-1.5.92-2.26a44.84 44.84 0 0 0 1.41-4.63 46.94 46.94 0 0 0 1.37-9.46c0-1.59.08-3.16 0-4.75s-.07-3.17-.26-4.72l-.21-2.34c-.09-.77-.23-1.54-.34-2.3s-.22-1.54-.37-2.3l-.49-2.25a58.73 58.73 0 0 0 -6.56-16.8 63.59 63.59 0 0 0 -10.77-13.72 74.79 74.79 0 0 0 -13.46-10.24 100.84 100.84 0 0 0 -16.3-7.81 122.86 122.86 0 0 0 -19-5.41 160 160 0 0 0 -27.37-2.98z"
			}), r.a.createElement("circle", {
				cx: "238.47",
				cy: "80.13",
				r: "22.93"
			}), r.a.createElement("path", {
				d: "m261.37 80.13a5.12 5.12 0 0 1 -.27-1.29c-.06-.34-.08-.75-.17-1.2s-.19-1-.3-1.5a23.88 23.88 0 0 0 -3.12-7.61 22.56 22.56 0 0 0 -6.59-6.71 20 20 0 0 0 -7.06-2.93 22.12 22.12 0 0 0 -19.67 5.49 21.36 21.36 0 0 0 -5.7 9 20.88 20.88 0 0 0 -.7 10.29 21.16 21.16 0 0 0 9.47 14.18 21.55 21.55 0 0 0 16.06 2.92 21.77 21.77 0 0 0 12.8-8.08 23.8 23.8 0 0 0 3.39-6.16 26 26 0 0 0 1.32-6.35 19.06 19.06 0 0 1 .12 6.81 21.83 21.83 0 0 1 -8.21 13.51 18.67 18.67 0 0 1 -5.13 2.82 24.34 24.34 0 0 1 -8.2 1.31 24.84 24.84 0 0 1 -7.83-1.26 25.86 25.86 0 0 1 -6.77-3.5 25 25 0 0 1 -5.2-5.16 23.4 23.4 0 0 1 -3.35-6.21 25 25 0 0 1 -1-3.32c-.13-.56-.18-1.12-.28-1.68l-.12-.84c0-.28 0-.56-.05-.84 0-.56 0-1.12-.07-1.68s.05-1.11.08-1.66a11.26 11.26 0 0 1 .17-1.64c.09-.54.15-1.09.26-1.62a25.58 25.58 0 0 1 2.15-6 24.56 24.56 0 0 1 5.71-7.24c.37-.34.79-.62 1.18-.93a11.19 11.19 0 0 1 1.21-.87 23.57 23.57 0 0 1 21.4-2.45 23 23 0 0 1 8.39 5.48 22 22 0 0 1 6.08 14.14c.11 1.26 0 2.29 0 2.78z"
			})))
		},
		"./src/reddit/icons/svgs/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M5.14293863,3.38188919 C5.75317178,3.99212234 5.75317178,4.98136473 5.14293863,5.59159788 C4.53270548,6.20183104 3.54346309,6.20183104 2.93322994,5.59159788 C2.32299679,4.98136473 2.32299679,3.99212234 2.93322994,3.38188919 C3.54346309,2.77165604 4.53270548,2.77165604 5.14293863,3.38188919 Z M1.01449569,2.94595786 L1,9.03662212 C1.00035355,9.55457784 1.19162594,10.0654625 1.55790725,10.4317438 L9.89929239,18.7731289 C10.6622606,19.5360972 11.8989904,19.5360972 12.661605,18.7734825 L18.7381272,12.6969604 C19.5007418,11.9343457 19.5007418,10.697616 18.7377736,9.93464773 L10.3963885,1.59326259 C10.0301071,1.22698128 9.54786032,1.00707107 9.02955105,1.00707107 L2.96045355,1 C1.8814086,1 1.01414214,1.86726647 1.01449569,2.94595786 Z"
			})))
		},
		"./src/reddit/icons/svgs/Trash/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("g", null, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("polygon", {
				points: "10,38.8 30,38.8 31.2,10.9 8.7,10.9"
			}), r.a.createElement("path", {
				d: "M27.5,3.8H25c0-1.4-1.1-2.5-2.5-2.5h-5c-1.4,0-2.5,1.1-2.5,2.5h-2.5c-2.8,0-5,2.2-5,5h25C32.5,6,30.3,3.8,27.5,3.8z"
			}))))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/icons/svgs/Trash2/index.m.less"),
				i = n.n(a);
			const d = e => r.a.createElement("svg", {
				className: Object(o.a)(i.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), r.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = d
		},
		"./src/reddit/icons/svgs/User/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M12,11 C15.309,11 18,13.691 18,17 C18,17.553 17.552,18 17,18 L3,18 C2.448,18 2,17.553 2,17 C2,13.691 4.691,11 8,11 L12,11 Z M10,9.7334 C7.868,9.7334 6.133,7.9994 6.133,5.8664 L6.133,4.8664 C6.133,2.7344 7.868,1.0004 10,1.0004 C12.132,1.0004 13.867,2.7344 13.867,4.8664 L13.867,5.8664 C13.867,7.9994 12.132,9.7334 10,9.7334 Z"
			}))
		},
		"./src/reddit/icons/svgs/Wiki/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M13.8711,6 L5.8711,6 C5.5951,6 5.3711,5.776 5.3711,5.5 C5.3711,5.224 5.5951,5 5.8711,5 L13.8711,5 C14.1471,5 14.3711,5.224 14.3711,5.5 C14.3711,5.776 14.1471,6 13.8711,6 M13.8711,9 L5.8711,9 C5.5951,9 5.3711,8.776 5.3711,8.5 C5.3711,8.224 5.5951,8 5.8711,8 L13.8711,8 C14.1471,8 14.3711,8.224 14.3711,8.5 C14.3711,8.776 14.1471,9 13.8711,9 M13.8711,12 L5.8711,12 C5.5951,12 5.3711,11.776 5.3711,11.5 C5.3711,11.224 5.5951,11 5.8711,11 L13.8711,11 C14.1471,11 14.3711,11.224 14.3711,11.5 C14.3711,11.776 14.1471,12 13.8711,12 M13.8711,15 L5.8711,15 C5.5951,15 5.3711,14.776 5.3711,14.5 C5.3711,14.224 5.5951,14 5.8711,14 L13.8711,14 C14.1471,14 14.3711,14.224 14.3711,14.5 C14.3711,14.776 14.1471,15 13.8711,15 M16.0001,2 L4.0001,2 C3.4471,2 3.0001,2.448 3.0001,3 L3.0001,17 C3.0001,17.552 3.4471,18 4.0001,18 L16.0001,18 C16.5531,18 17.0001,17.552 17.0001,17 L17.0001,3 C17.0001,2.448 16.5531,2 16.0001,2"
			})))
		},
		"./src/reddit/layout/row/Inline/index.m.less": function(e, t, n) {
			e.exports = {
				inlineRow: "XZK-LTFT5CgGo9MvPQQsy"
			}
		},
		"./src/reddit/layout/row/Inline/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/Inline/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("inlineRow", o.a)
		},
		"./src/reddit/layout/row/InlineButton/index.m.less": function(e, t, n) {
			e.exports = {
				inlineButton: "_10K5i7NW6qcm-UoCtpB3aK"
			}
		},
		"./src/reddit/layout/row/InlineButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/InlineButton/index.m.less"),
				o = n.n(r);
			t.a = s.a.button("inlineButton", o.a)
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, n) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/RightAlign/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("rightAligned", o.a)
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_5gAwSCo7K8G413IoE78Ml",
				right: "_2ghjBMFIsORwdO3oh2Kq6g",
				exapndLeftContainer: "_1zTJo0Ndih4fp__5DjbClN"
			}
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/layout/twoCol/ExpandLeft/index.m.less"),
				d = n.n(i);
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: Object(a.a)(d.a.exapndLeftContainer, e.className)
			}, r.a.createElement("div", {
				className: d.a.left
			}, Array.isArray(e.children) && e.children[0]), r.a.createElement("div", {
				className: d.a.right,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[1])), 2)
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_3YRHtGWABKh4OVO3s5gJwt",
				right: "_1IPWlMFPB_zPPajVPKk5Dy",
				expandRightContainer: "_2CUZHyZpRYmdvLE9tOI-2L"
			}
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				a = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/layout/twoCol/ExpandRight/index.m.less"),
				d = n.n(i);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(o.a)(e => {
				const {
					className: t,
					children: n,
					heightLeft: s,
					widthLeft: o,
					gutter: i,
					...l
				} = e;
				return r.a.createElement("div", c({
					className: Object(a.a)(d.a.expandRightContainer, t)
				}, l), r.a.createElement("div", {
					className: d.a.left,
					style: {
						flexBasis: o,
						height: s,
						marginRight: i
					}
				}, Array.isArray(n) && n[0]), r.a.createElement("div", {
					className: d.a.right
				}, Array.isArray(n) && n[1]))
			}, 2)
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return a
			}));
			var s, r = n("./node_modules/uuid/v4.js"),
				o = n.n(r);
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(s || (s = {}));
			const a = () => o()()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r, o, a = n("./src/config.ts");

			function i(e) {
				return "userId" in e
			}

			function d(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function c(e, t, n) {
				const s = n.media[0],
					r = Object.keys(s);
				if (s["0x0"]) return s["0x0"];
				let o = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (r.forEach(n => {
						const r = s[n],
							[a, i] = n.split("x").map(e => parseInt(e));
						(a < o.width && a >= e || i < o.height && i >= t) && (o = {
							height: i,
							width: a,
							url: r
						})
					}), !o.url && r.length) {
					const e = Object.keys(s)[0],
						t = s[e],
						[n, r] = e.split("x").map(e => parseInt(e));
					o = {
						height: r,
						width: n,
						url: t
					}
				}
				return o.url
			}

			function l(e) {
				return e.startsWith("https") ? e : `${a.a.assetPath}/${e}`
			}

			function u(e, t, n) {
				const s = c(e, t, n),
					r = c(2 * e, 2 * t, n);
				return {
					url: l(s),
					url2x: l(r)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(s || (s = {})),
			function(e) {
				e.ActivityTab = "activityTab", e.ChatTab = "chatTab", e.MessageTab = "messageTab", e.ChatHasNewMessages = "chatHasNewMessages", e.ChatUnreadMessages = "chatUnreadMessages"
			}(r || (r = {})),
			function(e) {
				e.Numbered = "NUMBERED", e.Filled = "FILLED"
			}(o || (o = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			}));
			var s, r, o = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(s || (s = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const a = {
					[s.Loyalty]: o.a.First,
					[s.Achievement]: o.a.Second,
					[s.Cosmetic]: void 0
				},
				i = e => e === o.a.First ? s.Loyalty : e === o.a.Second ? s.Achievement : s.Cosmetic
		},
		"./src/reddit/models/ChatSettingsPage/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "c", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})),
				function(e) {
					e.Unknown = "unknown", e.Toggle = "BOOLEAN"
				}(s || (s = {}));
			const r = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return e && Array.isArray(e) && e.length ? e.reduce((e, r) => {
						if (r && r.id && r.type && r.title && r.hasOwnProperty("state")) switch (r.type) {
							case s.Toggle:
								e.push({
									settingType: s.Toggle,
									settingId: r.id,
									subredditId: t,
									description: r.description,
									descriptionUrl: r.descriptionUrl,
									groupName: r.groupName,
									isEditable: !n && r.isEditable,
									state: "true" === String(r.state).toLowerCase(),
									title: r.title
								});
								break;
							default:
								e.push({
									settingType: s.Unknown,
									settingId: r.id,
									subredditId: t,
									description: r.description,
									descriptionUrl: r.descriptionUrl,
									groupName: r.groupName,
									isEditable: !n && r.isEditable,
									state: r.state,
									title: r.title
								})
						}
						return e
					}, []) : []
				},
				o = e => e.reduce((e, t) => (t.isEditable && e.push({
					id: t.settingId,
					state: String(t.state)
				}), e), [])
		},
		"./src/reddit/models/ContentGate.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.CustomFeedDoesNotExist = "CustomFeedDoesNotExist", e.GoldSubreddit = "GoldSubreddit", e.Nsfw = "Nsfw", e.NsfwCustomFeed = "NsfwCustomFeed", e.PrivateSubreddit = "PrivateSubreddit", e.ProfileDoesNotExist = "ProfileDoesNotExist", e.ProfileDeleted = "ProfileDeleted", e.ProfileSuspended = "ProfileSuspended", e.ProfileBlockedForLegalReason = "ProfileBlockedForLegalReason", e.QuarantinedSubreddit = "QuarantinedSubreddit", e.GatedSubreddit = "GatedSubreddit", e.SubredditBanned = "SubredditBanned", e.SubredditBlockedForLegalReason = "SubredditBlockedForLegalReason", e.SubredditDoesNotExist = "SubredditDoesNotExist", e.PostBlockedForLegalReason = "PostBlockedForLegalReason"
				}(s || (s = {}))
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return `${e}-sort[${t.sort}]-crossposts_only[${t.crossposts_only}]`
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			}));
			const s = 24,
				r = 64e3,
				o = 128,
				a = 128,
				i = (e, t, n, s) => ({
					name: e,
					url: t,
					subredditId: n,
					...s
				})
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Twitter = "twitter"
				}(s || (s = {}))
		},
		"./src/reddit/models/Gold/Powerups/powerupsFlair/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "b", (function() {
					return r
				})), n.d(t, "a", (function() {
					return o
				})),
				function(e) {
					e.Supporter = "SUPPORTER", e.Achievement = "ACHIEVEMENT"
				}(s || (s = {}));
			const r = e => e.category === s.Supporter,
				o = e => e.category === s.Achievement
		},
		"./src/reddit/models/HatefulContentFilters/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Off = "OFF", e.Lenient = "LENIENT", e.Moderate = "MODERATE", e.Strict = "STRICT"
				}(s || (s = {}))
		},
		"./src/reddit/models/ModQueueTrigger/index.ts": function(e, t, n) {
			"use strict";
			var s;

			function r(e, t) {
				var n;
				return null === (n = e.modQueueTriggers) || void 0 === n ? void 0 : n.find(e => e.type === t)
			}
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.USER_REPORTS = "USER_REPORTS", e.AUTOMOD = "AUTOMOD", e.MOD = "MOD", e.ADMIN = "ADMIN", e.SHADOWBANNED_SUBMITTER = "SHADOWBANNED_SUBMITTER", e.HATEFUL_CONTENT = "HATEFUL_CONTENT", e.CROWD_CONTROL = "CROWD_CONTROL", e.BAN_EVASION = "BAN_EVASION"
				}(s || (s = {}))
		},
		"./src/reddit/models/NotificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Email = "EMAIL", e.Push = "PUSH", e.CommunityAlerts = "COMMUNITY_ALERTS", e.ModCommunityAlerts = "MOD_COMMUNITY_ALERTS"
				}(s || (s = {}))
		},
		"./src/reddit/models/Option/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const s = e => !e.id,
				r = e => !!e.id,
				o = (e, t) => s(e) && s(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!r(e) || !r(t)) && e.id === t.id
		},
		"./src/reddit/models/RemovalReason/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/isPost.ts");
			const r = 50,
				o = 50,
				a = 1e4,
				i = 100;
			var d, c;
			! function(e) {
				e.Private = "private", e.PrivateExposed = "private_exposed", e.Public = "public", e.PublicSubreddit = "public_subreddit"
			}(d || (d = {})),
			function(e) {
				e.Bulk = "bulk", e.Comment = "comment", e.Post = "link"
			}(c || (c = {}));
			const l = e => 1 === e.length ? Object(s.a)(e[0]) ? c.Post : c.Comment : c.Bulk,
				u = (e, t) => {
					return {
						[t === c.Bulk ? "item_ids" : "item_id"]: e.itemId,
						message: e.message,
						title: e.title,
						type: e.type === d.PublicSubreddit ? d.Public : e.type,
						use_proxy: e.type === d.PublicSubreddit
					}
				}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "r", (function() {
				return g
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "m", (function() {
				return C
			})), n.d(t, "q", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/reddit/models/GqlTopLevelField.ts"),
				o = n("./src/reddit/models/User/index.ts");
			const a = "scheduledposts";
			var i, d, c;
			! function(e) {
				e.LINK = "LINK", e.POLL = "POLL", e.SELF = "SELF"
			}(i || (i = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(d || (d = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(c || (c = {}));
			const l = e => {
					return new Set(["links", "text", "polls"]).has(e)
				},
				u = e => e.__typename === o.c.AvailableRedditor,
				m = e => e.__typename === r.a.Subreddit;
			var p, b, h, f;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(b || (b = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(h || (h = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(f || (f = {}));
			const g = e => b[f[e]],
				_ = e => f[b[e]],
				v = e => h[b[e]],
				O = e => b[h[e]],
				x = e => f[h[e]];
			var E;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(E || (E = {}));
			const y = e => {
					switch (e) {
						case E.Hourly:
						case E.Daily:
						case E.Weekly:
						case E.Monthly:
							return !0
					}
					return !1
				},
				j = "custom",
				C = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						case "isPostAsMetaMod":
							return "post_as_meta_mod";
						default:
							return Object(s.a)(e)
					}
				},
				k = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/models/SubredditModeration/ModerationLog/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t, n) => `${e}-${((e,t)=>t||e||"1")(n,t)}`
		},
		"./src/reddit/models/SubredditWikiPage/index.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.MayNotView = "MAY_NOT_VIEW", e.PageNotCreated = "PAGE_NOT_CREATED", e.PageNotFound = "PAGE_NOT_FOUND", e.RestrictedPage = "RESTRICTED_PAGE", e.Unknown = "UNKNOWN", e.Valid = "VALID", e.WikiDisabled = "WIKI_DISABLED"
				}(s || (s = {})),
				function(e) {
					e.Inherit = "INHERIT_SUBREDDIT_PERMS", e.Contributors = "CONTRIBUTORS", e.Mods = "MODS"
				}(r || (r = {}))
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			}));
			const s = 25,
				r = 64;
			var o;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(o || (o = {}));
			const a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				i = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return a(e.tag, t)
				};
			var d;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(d || (d = {}))
		},
		"./src/reddit/models/TrafficStats/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = 97,
				r = 57,
				o = 12;
			var a;
			! function(e) {
				e.TOTAL = "total", e.DESKTOP = "desktop", e.OLD_REDDIT = "oldReddit", e.IOS = "apps", e.ANDROID = "apps", e.MOBILE_WEB = "mWeb"
			}(a || (a = {}))
		},
		"./src/reddit/pages/ModHub/Header.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_3moWGMnbR8K4S0yEul07nr",
				titleFontH2: "_2oI68wVKNMPkDrFs5iv-mT",
				titleFontH3: "_2SjfolwDVVvPkTR19n53-N",
				titleFontH4: "_2PCswqdAkej43QrI3i2XD6",
				titleFontH5: "_2ClzPN9iMLeouYjBczMuak",
				titleFontH6: "-Ys2BgGuQrEY2uMl3yymz",
				metadataFont: "_13D6uHC3HmU2n303ICkc2Z",
				flairFont: "jd22g-ATlzm80vQJWeapy",
				labelsFont: "_1UxIO379jfzGXKK-UTji0l",
				actionFont: "_33izYXQ9DA6aVnhOiSApGv",
				smallButtonFont: "_3gTmhpwBqqacn2Fbh1nFPi",
				largeButtonFont: "_18NraFj-4C_LqHvfoVPar1",
				strongTextFont: "_3tRumE3gvvS_0BYlnDtcIA",
				tabFont: "_1DLPo8qhiBT00GYX1ng3ad",
				buttonFontXS: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontXs: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontS: "_3DmXGTGm5YD5IApa9MyBNq",
				buttonFontM: "_32Yvll-0lWSj_SZKU0TKRR",
				buttonFontL: "_1wDiG7XcGSvunA559KlfGG",
				buttonFontXL: "xpxpmGAZ5HYQvDSsMNvp8",
				buttonFontXl: "xpxpmGAZ5HYQvDSsMNvp8",
				bodyFontH1: "_1ygLn4-Vtd31oQv6zylo5z",
				bodyFontH2: "_1btDxE6K9AP_wtfakdg11l",
				bodyFontH3: "cMjXJNdI0iac3nSCHtBrq",
				bodyFontH4: "_3ZsC5lxE3Dnw9-duolQiN3",
				bodyFontH5: "_3gWD0dGAav6VxMQZ2iY4qc",
				bodyFontH6: "_2yKCC1d-C1qheMkCr5CedW",
				bodyFontH6Small: "_1AyCUR1VQn-opitbpGpNcf",
				bodyFont: "_1RI3wkzuynRc_Bqno__Uom",
				bodyFontSmall: "_2MlCobLFb0alel2wzuIFVK",
				bodyFontMono: "_3RdMKJzgzPT9lgXHEf0XZB",
				header: "_3u9on6H92JkZNRumczPd67",
				subredditLink: "_3EIUrhztcaaHcqMILEsnBq",
				subredditIcon: "_3uA1he5X3WeG6mpoUWdcXy"
			}
		},
		"./src/reddit/pages/ModHub/Header.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/pages/ModHub/Header.m.less"),
				a = n.n(o),
				i = n("./src/reddit/components/SubredditIcon/index.tsx"),
				d = n("./src/reddit/controls/InternalLink/index.tsx");
			t.a = e => {
				var t, n;
				return r.a.createElement("div", {
					className: a.a.header
				}, r.a.createElement(i.b, {
					className: a.a.subredditIcon,
					subredditOrProfile: e.subredditOrProfile
				}), r.a.createElement(d.default, {
					className: a.a.subredditLink,
					to: (null === (t = e.subredditOrProfile) || void 0 === t ? void 0 : t.url) || "",
					onClick: e.onClick
				}, null === (n = e.subredditOrProfile) || void 0 === n ? void 0 : n.displayText), e.pageName && `/ ${e.pageName}`)
			}
		},
		"./src/reddit/pages/ModHub/index.m.less": function(e, t, n) {
			e.exports = {
				contentWrapper: "_2Z3MiFrgj2rofHXrH1YVKn",
				isModerator: "_1haViLcso0RRPvkDGZgDLJ",
				BackgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				backgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				Body: "_3hAOyl8ThaUgCBqiNvN_sN",
				body: "_3hAOyl8ThaUgCBqiNvN_sN"
			}
		},
		"./src/reddit/pages/ModHub/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/lodash/fromPairs.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				a = n.n(o),
				i = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/extractQueryParams/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/components/ContentGate/index.tsx"),
				p = n("./node_modules/fbt/lib/FbtPublic.js"),
				b = n("./src/lib/assertNever.ts"),
				h = n("./src/lib/constants/index.ts");
			const f = e => {
				switch (e) {
					case h.gc.Awards:
						return p.fbt._("Awards", null, {
							hk: "EiSXW"
						});
					case h.gc.Powerups:
						return p.fbt._("Powerups", null, {
							hk: "3SZBhK"
						});
					case h.gc.Banned:
						return p.fbt._("Banned", null, {
							hk: "35R8OD"
						});
					case h.gc.Muted:
						return p.fbt._("Muted", null, {
							hk: "f2nJu"
						});
					case h.gc.ContentControls:
						return p.fbt._("Content controls", null, {
							hk: "H1yxv"
						});
					case h.gc.Contributors:
						return p.fbt._("Approved", null, {
							hk: "180AS9"
						});
					case h.gc.Moderators:
						return p.fbt._("Moderators", null, {
							hk: "4qdV8t"
						});
					case h.gc.SubredditRules:
						return p.fbt._("Rules", null, {
							hk: "2SNdd8"
						});
					case h.gc.Removal:
						return p.fbt._("Removal reasons", null, {
							hk: "1smDUM"
						});
					case h.gc.Modqueue:
						return p.fbt._("Mod queue", null, {
							hk: "yEBGb"
						});
					case h.gc.Reports:
						return p.fbt._("Reports", null, {
							hk: "4Ctcb1"
						});
					case h.gc.Spam:
						return p.fbt._("Spam", null, {
							hk: "1D73Vp"
						});
					case h.gc.Unmoderated:
						return p.fbt._("Unmoderated", null, {
							hk: "3TOaeD"
						});
					case h.gc.Edited:
						return p.fbt._("Edited", null, {
							hk: "OLtvW"
						});
					case h.gc.ChatSettings:
						return p.fbt._("Chat settings", null, {
							hk: "3gycCw"
						});
					case h.gc.Modlog:
						return p.fbt._("Mod log", null, {
							hk: "3uy7LL"
						});
					case h.gc.Flair:
						return p.fbt._("Grant user flair", null, {
							hk: "2B8sTJ"
						});
					case h.gc.CommunitySettings:
						return p.fbt._("Community settings", null, {
							hk: "XbHzi"
						});
					case h.gc.Emojis:
						return p.fbt._("Emojis", null, {
							hk: "3mPnxe"
						});
					case h.gc.UserFlair:
						return p.fbt._("User flair", null, {
							hk: "3kleCv"
						});
					case h.gc.PostFlair:
						return p.fbt._("Post flair", null, {
							hk: "2Y1FKb"
						});
					case h.gc.Badges:
						return p.fbt._("Badges", null, {
							hk: "3vM0lt"
						});
					case h.gc.Emotes:
						return p.fbt._("Emotes", null, {
							hk: "2Ivxxq"
						});
					case h.gc.Wiki:
					case h.gc.WikiContributors:
					case h.gc.WikiBanned:
						return p.fbt._("Wiki pages", null, {
							hk: "WdSXv"
						});
					case h.gc.Traffic:
						return p.fbt._("Traffic stats", null, {
							hk: "3mcw71"
						});
					case h.gc.ScheduledPostContent:
					case h.gc.SubredditContent:
						return p.fbt._("Scheduled posts", null, {
							hk: "19KZjq"
						});
					case h.gc.EventPostContent:
						return p.fbt._("Event posts", null, {
							hk: "3ejc42"
						});
					case h.gc.Streaming:
						return p.fbt._("Broadcasting", null, {
							hk: "1Cz44z"
						});
					case h.gc.Predictions:
						return p.fbt._("Predictions", null, {
							hk: "1yASCC"
						});
					case h.gc.TalkHosts:
						return p.fbt._("Talk hosts", null, {
							hk: "3BAjFt"
						});
					default:
						return Object(b.a)(e)
				}
			};
			var g = n("./src/reddit/components/TrackingHelper/index.tsx"),
				_ = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				O = n("./src/reddit/helpers/getSubredditErrorProps/index.ts"),
				x = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				E = n("./src/reddit/helpers/trackers/modHub.ts"),
				y = n("./src/reddit/models/ModQueue/index.ts"),
				j = n("./src/reddit/selectors/experiments/econ/index.ts"),
				C = n("./src/reddit/selectors/moderatorPermissions.ts"),
				k = n("./src/reddit/selectors/postCreations.ts"),
				I = n("./src/reddit/selectors/profile.ts"),
				S = n("./src/reddit/selectors/streamingModSettings.ts"),
				w = n("./src/reddit/selectors/subreddit.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				N = n("./src/reddit/components/ModHub/Content/index.tsx"),
				P = n("./src/reddit/components/ModHub/Content/NoPermissions.tsx"),
				R = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				A = n("./src/reddit/components/ModHub/Content/WelcomeMessage.m.less"),
				M = n.n(A);
			const D = u.a.wrapped(R.a, "ModerateIcon", M.a),
				L = u.a.div("ModHubWelcomeMessage", M.a);
			var F = e => a.a.createElement(L, null, a.a.createElement(D, null), p.fbt._("Welcome to the mod tools for {subredditName}", [p.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "7Usff"
				})),
				U = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				B = n("./node_modules/react-router-redux/es/index.js"),
				G = n("./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx"),
				H = n("./src/reddit/components/EmailInvitePaintedDoor/loader.tsx"),
				W = n("./src/reddit/contexts/NavbarExp.ts"),
				q = n("./src/reddit/featureFlags/index.ts"),
				V = n("./src/reddit/helpers/localStorage/index.ts"),
				z = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				K = n("./src/reddit/helpers/trackers/emailInvite.ts"),
				Q = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				J = n("./src/reddit/icons/fonts/index.tsx"),
				Y = n("./src/reddit/routes/moderationPages/index.ts"),
				X = n("./src/reddit/selectors/experiments/emailInvite.ts"),
				Z = n("./src/reddit/selectors/gold/powerups/index.ts"),
				$ = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx"),
				ee = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				te = n.n(ee);

			function ne() {
				return (ne = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var se = e => a.a.createElement("div", ne({
					className: Object(c.a)(te.a.breadcrumb, e.className)
				}, e), a.a.createElement("button", {
					className: te.a.breadcrumbButton
				}, a.a.createElement($.a, null), p.fbt._("Back to mod tools", null, {
					hk: "4udiKO"
				}))),
				re = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				oe = n("./src/reddit/actions/modal.ts"),
				ae = n("./src/higherOrderComponents/asModal/index.tsx"),
				ie = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				de = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				ce = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				le = n("./src/reddit/constants/wiki.ts"),
				ue = n("./src/reddit/controls/Button/index.tsx"),
				me = n("./src/reddit/controls/TextButton/index.tsx"),
				pe = n("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				be = n("./src/reddit/helpers/wiki/validatePageName.ts"),
				he = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				fe = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				ge = n("./src/reddit/controls/Dropdown/index.tsx"),
				_e = n("./src/reddit/controls/Dropdown/Row.tsx"),
				ve = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				Oe = n("./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less"),
				xe = n.n(Oe);
			class Ee extends a.a.Component {
				constructor(e) {
					super(e), this.onToggleDropdown = () => {
						this.setState({
							isDropdownOpen: !this.state.isDropdownOpen
						})
					}, this.onSelectParentPage = e => {
						this.props.onSelectParentPage(e), this.onToggleDropdown()
					}, this.state = {
						isDropdownOpen: !1
					}
				}
				render() {
					const {
						pageTree: e,
						parentPageName: t
					} = this.props, {
						isDropdownOpen: n
					} = this.state, s = p.fbt._("None", null, {
						hk: "3FT0YQ"
					});
					return a.a.createElement("div", {
						className: xe.a.dropdownContainer
					}, a.a.createElement("button", {
						className: xe.a.dropdownTarget,
						onClick: this.onToggleDropdown
					}, a.a.createElement("div", {
						className: xe.a.targetText
					}, t || s), a.a.createElement(ve.b, null)), n && a.a.createElement(ge.a, {
						className: xe.a.dropdown
					}, a.a.createElement(_e.b, {
						className: xe.a.dropdownRow,
						displayText: s,
						onClick: () => this.onSelectParentPage(void 0)
					}), e.map(e => e.depth >= le.c ? null : le.f.has(e.path.split("/")[0]) ? null : a.a.createElement(_e.b, {
						className: xe.a.dropdownRow,
						displayText: e.path,
						key: e.path,
						onClick: () => this.onSelectParentPage(e.path)
					}))))
				}
			}
			var ye = Ee;
			const je = e => {
				switch (e) {
					case be.a.InvalidPageName:
						return p.fbt._("Invalid page name", null, {
							hk: "1gQvCb"
						});
					case be.a.MaxLengthExceed:
						return p.fbt._("Name exceeds character limit", null, {
							hk: "RDoIC"
						});
					case be.a.PageAlreadyExists:
						return p.fbt._("That page already exists", null, {
							hk: "xEyyR"
						});
					case be.a.RestrictedPageName:
						return p.fbt._("Restricted page name", null, {
							hk: "Bjv5o"
						})
				}
			};
			class Ce extends a.a.Component {
				constructor(e) {
					super(e), this.onChangePageName = e => {
						this.setState({
							partialPageName: e.currentTarget.value
						})
					}, this.onSelectParentPage = e => {
						this.setState({
							parentPageName: e
						})
					}, this.getNewPagePath = () => {
						let e = "";
						return this.state.parentPageName && (e += `${this.state.parentPageName}/`), (e += `${this.state.partialPageName}`).toLowerCase()
					}, this.state = {
						partialPageName: "",
						parentPageName: void 0
					}
				}
				hasError() {
					const {
						pageTree: e
					} = this.props, {
						partialPageName: t
					} = this.state;
					return Object(be.c)(t) || Object(be.b)(this.getNewPagePath(), e)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = this.hasError();
					return a.a.createElement(de.e, {
						className: xe.a.modalBody
					}, a.a.createElement(de.i, null, a.a.createElement(fe.a, null, a.a.createElement(de.q, null, p.fbt._("Create a new wiki page", null, {
						hk: "V7Jnm"
					})), a.a.createElement(me.a, {
						onClick: e.toggleModal
					}, a.a.createElement(de.b, null)))), a.a.createElement("div", {
						className: xe.a.notice
					}, a.a.createElement(he.a, null), p.fbt._("Parent page and page URL cannot be edited once created", null, {
						hk: "20D6uz"
					})), a.a.createElement(de.l, null, a.a.createElement("div", {
						className: xe.a.sectionTitle
					}, p.fbt._("Parent page", null, {
						hk: "1FeKiT"
					})), a.a.createElement(ye, {
						onSelectParentPage: this.onSelectParentPage,
						pageTree: Object(pe.b)(e.pageTree || []),
						parentPageName: t.parentPageName
					}), a.a.createElement("div", {
						className: xe.a.sectionTitle
					}, p.fbt._("Page URL", null, {
						hk: "WL8sn"
					})), a.a.createElement(ce.d, {
						placeholder: p.fbt._("ex: rules", null, {
							hk: "J0qH1"
						}),
						onChange: this.onChangePageName,
						value: t.partialPageName
					}), a.a.createElement(ie.a, {
						text: this.getNewPagePath(),
						maxChars: le.d
					}), a.a.createElement("div", {
						className: xe.a.errorText
					}, t.partialPageName && n ? je(n) : null)), a.a.createElement(de.g, null, a.a.createElement(de.a, {
						onClick: e.toggleModal
					}, p.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), a.a.createElement(ue.n, {
						disabled: !t.partialPageName || !!n,
						className: xe.a.primaryButton,
						to: `${e.subredditUrl}about/wiki/create/${this.getNewPagePath()}`
					}, p.fbt._("Create", null, {
						hk: "2W0PL1"
					}))))
				}
			}
			var ke = Object(ae.a)(Ce),
				Ie = n("./src/reddit/selectors/activeModalId.ts"),
				Se = n("./src/reddit/selectors/subredditWiki.ts"),
				we = n("./node_modules/lodash/times.js"),
				Te = n.n(we),
				Ne = n("./src/reddit/controls/InternalLink/index.tsx"),
				Pe = n("./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less"),
				Re = n.n(Pe);
			class Ae extends a.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = a.a.createRef()
				}
				componentDidMount() {
					this.scrollToActiveItemIfNeeded()
				}
				scrollToActiveItemIfNeeded() {
					const e = this.containerRef.current,
						t = e && e.getElementsByClassName(Re.a.mActive)[0];
					if (!e || !t) return;
					const n = e.getBoundingClientRect(),
						s = t.getBoundingClientRect();
					s.top >= n.top && s.bottom <= n.bottom || t.scrollIntoView()
				}
				render() {
					const {
						activePageName: e,
						baseUrl: t,
						directory: n
					} = this.props, s = Object(pe.b)(n && n.pageTree || []);
					return a.a.createElement("div", {
						ref: this.containerRef,
						className: Re.a.contentTree
					}, s.map(n => {
						const s = n.path === e;
						return a.a.createElement(Ne.default, {
							key: n.path,
							className: Re.a.pageNavLink,
							to: `${t}/${n.path}`
						}, a.a.createElement("div", {
							className: Object(c.a)(Re.a.pageNavItem, {
								[Re.a.mActive]: s,
								[Re.a.mExists]: n.isPagePresent
							})
						}, Te()(n.depth, () => a.a.createElement("div", {
							className: Re.a.indentLine
						})), a.a.createElement("span", {
							className: Re.a.itemText
						}, `/${n.name}`)))
					}))
				}
			}
			const Me = Object(d.c)({
				directory: (e, t) => Object(Se.b)(e, {
					subredditName: t.subreddit.name
				}),
				isCreateWikiPageModalOpen: e => "CreateWikiPageModal" === Object(Ie.a)(e)
			});
			class De extends a.a.Component {
				constructor() {
					super(...arguments), this.onToggleCreateWikiModal = () => {
						this.props.toggleCreateWikiModal()
					}
				}
				render() {
					const {
						directory: e,
						isCreateWikiPageModalOpen: t,
						subreddit: n,
						toggleCreateWikiModal: s,
						pageLayer: r
					} = this.props;
					if (!r) return null;
					const {
						urlParams: o
					} = r, {
						wikiPageName: i,
						wikiSubRoute: d,
						pageName: c
					} = o;
					return a.a.createElement("div", {
						className: Re.a.wikiNavPanel
					}, a.a.createElement(ue.l, {
						className: Re.a.primaryButton,
						onClick: this.onToggleCreateWikiModal
					}, p.fbt._("Create new page", null, {
						hk: "35WDuL"
					})), a.a.createElement(Ae, {
						activePageName: i,
						baseUrl: `${n.url}about/wiki`,
						directory: e
					}), a.a.createElement("div", {
						className: Re.a.footer
					}, a.a.createElement(re.b, {
						isActive: d === le.m.Revisions && !i,
						label: p.fbt._("Recent wiki revisions", null, {
							hk: "278VnD"
						}),
						path: `${n.url}about/wiki/revisions`
					}), a.a.createElement(re.b, {
						isActive: c === h.gc.WikiContributors,
						label: p.fbt._("Add wiki contributors", null, {
							hk: "1XHd90"
						}),
						path: `${n.url}about/wikicontributors`
					}), a.a.createElement(re.b, {
						isActive: c === h.gc.WikiBanned,
						label: p.fbt._("Ban wiki contributors", null, {
							hk: "3IVNKp"
						}),
						path: `${n.url}about/wikibanned`
					}), a.a.createElement(re.b, {
						label: p.fbt._("Wiki settings", null, {
							hk: "1Jctxf"
						}),
						path: `${n.url}about/edit?page=wikis`
					})), t && a.a.createElement(ke, {
						pageTree: e && e.pageTree,
						subredditUrl: n.url,
						toggleModal: s,
						withOverlay: !0
					}))
				}
			}
			var Le = Object(_.u)()(Object(i.b)(Me, e => ({
				toggleCreateWikiModal: () => e(Object(oe.i)("CreateWikiPageModal"))
			}))(De));
			const Fe = Object(d.c)({
				isBadgesAndEmotesEnabled: q.d.spCustomBadgesAndEmotes,
				isContentTagEnabled: (e, t) => !!e.subreddits.survey[t.subreddit.id],
				isEligibleForScheduledPosts: q.d.scheduledPosts,
				isEmailInviteExperimentEnabled: X.a,
				isBroadcastingEnabled: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(S.c)(e, n.id)
				},
				isTournamentsEnabled: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(w.O)(e, {
						subredditId: n.id
					})
				},
				isPowerupsTabVisible: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(Z.f)(e, {
						subredditId: n.id
					})
				},
				isTalkHostsExperimentEnabled: j.s
			});
			class Ue extends a.a.Component {
				constructor(e, t) {
					super(e, t), this.trackClick = e => this.props.sendEvent(E.c(e)), this.trackCommunitySettingsNavItemClick = e => this.props.sendEvent(Object(z.b)(e)), this.onClickAwards = () => this.trackClick("awards"), this.onClickPowerups = () => this.trackClick("powerups"), this.onClickStreaming = () => this.trackClick("streaming"), this.onClickModQueue = () => this.trackClick("mod_queue"), this.onClickReports = () => this.trackClick("reports"), this.onClickSpam = () => this.trackClick("spam"), this.onClickEdited = () => this.trackClick("edited"), this.onClickUnmoderated = () => this.trackClick("unmoderated"), this.onClickBannedUsers = () => this.trackClick("ban_users"), this.onClickMutedUsers = () => this.trackClick("mute_users"), this.onClickApprovedSubmitters = () => this.trackClick("approved_submitters"), this.onClickApprovedTalkHosts = () => this.trackClick("talk_hosts"), this.onClickEmojis = () => this.trackClick("emoji"), this.onClickModerators = () => this.trackClick("moderators"), this.onClickChatSettings = () => this.trackClick("chat_settings"), this.onClickCommunitySettings = () => this.trackClick("community_settings"), this.onClickCommunityAppearance = () => this.trackClick("community_appearance"), this.onClickModMail = () => this.trackClick("mod_mail"), this.onClickRemovalReasons = () => this.trackClick("removal_reasons"), this.onClickRules = () => this.trackClick("rules"), this.onClickPostRequirements = () => this.trackClick("post_requirements"), this.onClickAutomodConfig = () => this.trackClick("automod_config"), this.onClickWikiPages = () => this.trackClick("wiki"), this.onClickTraffic = () => this.trackClick("traffic"), this.onClickModLog = () => this.trackClick("mod_log"), this.onClickModSupport = () => this.trackClick("r_mod_support"), this.onClickModHelp = () => this.trackClick("mod_help"), this.onClickContactReddit = () => this.trackClick("contact_reddit"), this.onClickModGuidelines = () => this.trackClick("mod_guidelines"), this.onClickModHelpCenter = () => this.trackClick("mod_help_center"), this.onClickPostFlair = () => this.trackClick("post_flair"), this.onClickUserFlair = () => this.trackClick("user_flair"), this.onClickGrantUserFlair = () => this.trackClick("grant_user_flair"), this.onClickBadges = () => this.trackClick("badges"), this.onClickEmotes = () => this.trackClick("emotes"), this.onClickScheduledPosts = () => this.props.sendEvent(Object(Q.k)()), this.onClickEventPosts = () => this.props.sendEvent(Object(Q.f)()), this.onClickPredictions = () => this.trackClick("predictions"), this.onGoToModHub = () => {
						const e = this.props.moderatorPermissions && this.props.moderatorPermissions.posts,
							t = `${this.props.subreddit.url}about/`,
							n = e ? `${t}modqueue` : t;
						this.props.pushUrl(n)
					}, this.onClickInviteViaEmail = () => {
						const {
							sendEvent: e
						} = this.props;
						e(Object(K.a)("mod_hub_nav")), this.setState({
							showEmailInvitePaintedDoor: !0
						})
					}, this.onCloseInviteViaEmailModal = () => {
						this.setState({
							showEmailInvitePaintedDoor: !1
						})
					}, this.getFlairSectionName = () => this.props.isBadgesAndEmotesEnabled ? p.fbt._("Badges, flair & emojis", null, {
						hk: "1FuDnm"
					}) : this.props.isPowerupsTabVisible ? p.fbt._("Flair", null, {
						hk: "1fYKUf"
					}) : p.fbt._("Flair & emojis", null, {
						hk: "42b2AJ"
					}), this.state = {
						locationSettingSeen: !0,
						showEmailInvitePaintedDoor: !1
					}
				}
				componentDidMount() {
					this.setState({
						locationSettingSeen: Object(V.F)("location")
					})
				}
				render() {
					const {
						props: e
					} = this, t = e.isEligibleForScheduledPosts && !e.isProfile || e.isTournamentsEnabled;
					switch (e.pageName) {
						case h.gc.CommunitySettings: {
							const t = !e.subpageName || !Object.values(h.hc).includes(e.subpageName);
							return e.isProfile ? null : a.a.createElement(W.a.Consumer, null, n => a.a.createElement("div", {
								className: Object(c.a)(te.a.navContainer, {
									[te.a.navContainerExp]: n
								})
							}, a.a.createElement(se, {
								onClick: this.onGoToModHub
							}), a.a.createElement(re.b, {
								label: p.fbt._("Community", null, {
									hk: "1EIoJe"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.Community),
								path: `${e.subreddit.url}about/edit?page=community`,
								isActive: t || e.subpageName === h.hc.Community
							}), a.a.createElement(re.b, {
								label: p.fbt._("Safety and Privacy", null, {
									hk: "3E0TnI"
								}),
								isNew: e.showCrowdControlCampaign,
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.Safety),
								path: `${e.subreddit.url}about/edit?page=safety`,
								isActive: e.subpageName === h.hc.Safety
							}), a.a.createElement(re.b, {
								label: p.fbt._("Posts and Comments", null, {
									hk: "2jt4ea"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.Posts),
								path: `${e.subreddit.url}about/edit?page=posts`,
								isActive: e.subpageName === h.hc.Posts
							}), a.a.createElement(re.b, {
								label: p.fbt._("Wikis", null, {
									hk: "2X1iz1"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.Wikis),
								path: `${e.subreddit.url}about/edit?page=wikis`,
								isActive: e.subpageName === h.hc.Wikis
							}), e.isContentTagEnabled && a.a.createElement(re.b, {
								label: p.fbt._("Content Tag", null, {
									hk: "VuxaQ"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.ContentTag),
								path: `${e.subreddit.url}about/edit?page=content_tag`,
								isActive: e.subpageName === h.hc.ContentTag
							}), a.a.createElement(re.b, {
								label: p.fbt._("Notifications", null, {
									hk: "SRNLx"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(h.hc.Notifications),
								path: `${e.subreddit.url}about/edit?page=notifications`,
								isActive: e.subpageName === h.hc.Notifications
							})))
						}
						case h.gc.Wiki:
						case h.gc.WikiContributors:
						case h.gc.WikiBanned:
							return e.isProfile ? null : a.a.createElement(W.a.Consumer, null, t => a.a.createElement("div", {
								className: Object(c.a)(te.a.navContainer, te.a.wikiNavContainer, {
									[te.a.navContainerExp]: t
								})
							}, a.a.createElement(se, {
								onClick: this.onGoToModHub
							}), e.moderatorPermissions.wiki && a.a.createElement(Le, {
								subreddit: e.subreddit
							})));
						default:
							return a.a.createElement(W.a.Consumer, null, n => a.a.createElement("div", {
								className: Object(c.a)(te.a.navContainer, {
									[te.a.navContainerExp]: n
								})
							}, e.moderatorPermissions.posts && !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "mod_queue",
								className: te.a.iconStyles
							}), p.fbt._("Queues", null, {
								hk: "2BbIZV"
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Modqueue,
								label: f(h.gc.Modqueue),
								onClick: this.onClickModQueue,
								path: `${e.subreddit.url}about/modqueue`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Reports,
								label: f(h.gc.Reports),
								onClick: this.onClickReports,
								path: `${e.subreddit.url}about/reports`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Spam,
								label: f(h.gc.Spam),
								onClick: this.onClickSpam,
								path: `${e.subreddit.url}about/spam`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Edited,
								label: f(h.gc.Edited),
								onClick: this.onClickEdited,
								path: `${e.subreddit.url}about/edited`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Unmoderated,
								label: f(h.gc.Unmoderated),
								onClick: this.onClickUnmoderated,
								path: `${e.subreddit.url}about/unmoderated`
							})), !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "user",
								className: te.a.iconStyles
							}), p.fbt._("User management", null, {
								hk: "3G4BgD"
							})), e.moderatorPermissions.access && a.a.createElement(a.a.Fragment, null, a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Banned,
								label: f(h.gc.Banned),
								onClick: this.onClickBannedUsers,
								path: `${e.subreddit.url}about/banned`
							}), e.moderatorPermissions.mail && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Muted,
								label: f(h.gc.Muted),
								onClick: this.onClickMutedUsers,
								path: `${e.subreddit.url}about/muted`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Contributors,
								label: f(h.gc.Contributors),
								onClick: this.onClickApprovedSubmitters,
								path: `${e.subreddit.url}about/contributors`
							}), e.isTalkHostsExperimentEnabled && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.TalkHosts,
								label: f(h.gc.TalkHosts),
								onClick: this.onClickApprovedTalkHosts,
								path: `${e.subreddit.url}about/talkhosts`
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Moderators,
								label: f(h.gc.Moderators),
								onClick: this.onClickModerators,
								path: `${e.subreddit.url}about/moderators`
							}), e.isEmailInviteExperimentEnabled && a.a.createElement(re.b, {
								label: p.fbt._("Bulk Email Invite", null, {
									hk: "3GTIEm"
								}),
								isNew: !0,
								onClick: this.onClickInviteViaEmail
							}), this.state.showEmailInvitePaintedDoor && a.a.createElement(H.a, {
								onClose: this.onCloseInviteViaEmailModal,
								sendEvent: e.sendEvent
							})), (e.moderatorPermissions.flair || e.moderatorPermissions.config) && !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "tag",
								className: te.a.iconStyles
							}), this.getFlairSectionName()), e.moderatorPermissions.flair && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Flair,
								label: f(h.gc.Flair),
								onClick: this.onClickGrantUserFlair,
								path: `${e.subreddit.url}about/flair`
							}), e.moderatorPermissions.config && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Emojis,
								label: f(h.gc.Emojis),
								onClick: this.onClickEmojis,
								path: `${e.subreddit.url}about/emojis`
							}), e.moderatorPermissions.flair && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.UserFlair,
								label: f(h.gc.UserFlair),
								onClick: this.onClickUserFlair,
								path: `${e.subreddit.url}about/userflair`
							}), e.moderatorPermissions.flair && e.moderatorPermissions.config && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.PostFlair,
								label: f(h.gc.PostFlair),
								onClick: this.onClickPostFlair,
								path: `${e.subreddit.url}about/postflair`
							}), e.isBadgesAndEmotesEnabled && a.a.createElement(a.a.Fragment, null, a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Badges,
								label: f(h.gc.Badges),
								onClick: this.onClickBadges,
								path: `${e.subreddit.url}about/badges`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Emotes,
								label: f(h.gc.Emotes),
								onClick: this.onClickEmotes,
								path: `${e.subreddit.url}about/emotes`
							}))), (e.moderatorPermissions.config || e.moderatorPermissions.posts) && !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "rules",
								className: te.a.iconStyles
							}), p.fbt._("Rules and regulations", null, {
								hk: "QAksk"
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.SubredditRules,
								label: f(h.gc.SubredditRules),
								onClick: this.onClickRules,
								path: `${e.subreddit.url}about/rules`
							}), e.moderatorPermissions.posts && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Removal,
								label: f(h.gc.Removal),
								onClick: this.onClickRemovalReasons,
								path: `${e.subreddit.url}about/removal`
							}), e.moderatorPermissions.config && a.a.createElement(a.a.Fragment, null, a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.ContentControls,
								label: f(h.gc.ContentControls),
								onClick: this.onClickPostRequirements,
								path: `${e.subreddit.url}about/settings`
							}), a.a.createElement(re.b, {
								label: p.fbt._("Automod", null, {
									hk: "1IngsO"
								}),
								onClick: this.onClickAutomodConfig,
								path: `${e.subreddit.url}about/wiki/config/automoderator`
							}))), t && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "list_bulleted",
								className: te.a.iconStyles
							}), p.fbt._("Content", null, {
								hk: "IAh5R"
							})), e.isEligibleForScheduledPosts && !e.isProfile && a.a.createElement(a.a.Fragment, null, a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.ScheduledPostContent,
								label: p.fbt._("Scheduled posts", null, {
									hk: "11S6dN"
								}),
								onClick: this.onClickScheduledPosts,
								path: Object(Y.e)(e.subreddit.url)
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.EventPostContent,
								label: p.fbt._("Event posts", null, {
									hk: "3D98hc"
								}),
								onClick: this.onClickEventPosts,
								path: Object(Y.b)(e.subreddit.url)
							})), e.isTournamentsEnabled && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Predictions,
								label: p.fbt._("Predictions", null, {
									hk: "Serjr"
								}),
								onClick: this.onClickPredictions,
								path: Object(Y.d)(e.subreddit.url),
								isNew: !0
							})), (e.moderatorPermissions.config || e.moderatorPermissions.wiki) && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "settings",
								className: te.a.iconStyles
							}), p.fbt._("Other", null, {
								hk: "ST5RE"
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Awards,
								label: p.fbt._("Awards", null, {
									hk: "48U4Du"
								}),
								onClick: this.onClickAwards,
								path: `${e.subreddit.url}about/awards`
							}), e.moderatorPermissions.config && e.isPowerupsTabVisible && a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Powerups,
								label: p.fbt._("Powerups", null, {
									hk: "1fgdwA"
								}),
								onClick: this.onClickPowerups,
								path: `${e.subreddit.url}about/powerups`,
								isNew: !0
							}), e.moderatorPermissions.config && !e.isProfile && e.isBroadcastingEnabled && a.a.createElement(re.b, {
								label: f(h.gc.Streaming),
								onClick: this.onClickStreaming,
								path: `${e.subreddit.url}about/broadcasting`,
								isNew: !0
							}), e.moderatorPermissions.wiki && !e.isProfile && a.a.createElement(re.b, {
								label: p.fbt._("Wiki pages", null, {
									hk: "wShFl"
								}),
								onClick: this.onClickWikiPages,
								path: `${U.a.redditUrl}${e.subreddit.url}about/wiki/index`
							}), e.moderatorPermissions.config && !e.isProfile && a.a.createElement(re.b, {
								label: p.fbt._("Community settings", null, {
									hk: "2xOUK6"
								}),
								onClick: this.onClickCommunitySettings,
								isNew: !this.state.locationSettingSeen || e.showCrowdControlCampaign,
								path: `${e.subreddit.url}about/edit?page=community`,
								showInboundArrow: !0
							}), e.moderatorPermissions.config && !e.isProfile && a.a.createElement(re.b, {
								label: p.fbt._("Community appearance", null, {
									hk: "3AHttA"
								}),
								path: `${e.subreddit.url}?styling=true`,
								onClick: this.onClickCommunityAppearance,
								showInboundArrow: !0
							})), e.moderatorPermissions.mail && !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "mod_mail",
								className: te.a.iconStyles
							}), p.fbt._("Modmail", null, {
								hk: "Eh4Vu"
							})), a.a.createElement(re.b, {
								isExternal: !0,
								label: p.fbt._("Modmail", null, {
									hk: "3Xkgqo"
								}),
								onClick: this.onClickModMail,
								path: "https://mod.reddit.com"
							})), e.moderatorPermissions.config && !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "chat",
								className: te.a.iconStyles
							}), p.fbt._("Chat", null, {
								hk: "4mJ2vR"
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.ChatSettings,
								label: f(h.gc.ChatSettings),
								onClick: this.onClickChatSettings,
								path: `${e.subreddit.url}about/chat`
							})), !e.isProfile && a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "statistics",
								className: te.a.iconStyles
							}), p.fbt._("Community activity", null, {
								hk: "1vGSer"
							})), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Traffic,
								label: p.fbt._("Traffic stats", null, {
									hk: "vw5CU"
								}),
								onClick: this.onClickTraffic,
								path: `${e.subreddit.url}about/traffic`
							}), a.a.createElement(re.b, {
								isActive: e.pageName === h.gc.Modlog,
								label: f(h.gc.Modlog),
								onClick: this.onClickModLog,
								path: `${e.subreddit.url}about/log`
							})), a.a.createElement("div", {
								className: te.a.navSection
							}, a.a.createElement("div", {
								className: te.a.sectionHeader
							}, a.a.createElement(J.a, {
								name: "help",
								className: te.a.iconStyles
							}), p.fbt._("Mod help center", null, {
								hk: "256YE"
							})), a.a.createElement(re.b, {
								isExternal: !0,
								label: p.fbt._("Mod help center", null, {
									hk: "4dCwWU"
								}),
								onClick: this.onClickModHelpCenter,
								path: U.a.redditModHelpUrl
							}), a.a.createElement(re.b, {
								isExternal: !0,
								label: p.fbt._("Moderator guidelines", null, {
									hk: "3marKI"
								}),
								onClick: this.onClickModGuidelines,
								path: "https://www.reddit.com/help/healthycommunities/"
							}), a.a.createElement(re.b, {
								isExternal: !0,
								label: "r/ModSupport",
								onClick: this.onClickModSupport,
								path: "/r/ModSupport/"
							}), a.a.createElement(re.b, {
								isExternal: !0,
								label: "r/ModHelp",
								onClick: this.onClickModHelp,
								path: "/r/modhelp/"
							}), a.a.createElement(re.b, {
								isExternal: !0,
								label: p.fbt._("Contact Reddit", null, {
									hk: "2NRBBx"
								}),
								onClick: this.onClickContactReddit,
								path: "https://www.reddithelp.com/hc/en-us/requests/new"
							}))))
					}
				}
			}
			var Be = Object(i.b)(Fe, e => ({
					pushUrl: t => e(Object(B.b)(t))
				}))(Object(g.c)(Object(G.c)(Ue))),
				Ge = n("./src/reddit/pages/ModHub/Header.tsx"),
				He = n("./src/reddit/pages/ModHub/index.m.less"),
				We = n.n(He);
			const qe = u.a.div("BackgroundContainer", We.a),
				Ve = u.a.div("Body", We.a),
				ze = Object(d.c)({
					contentGateInfo: (e, t) => Object(T.f)(e, t.match.params.subredditName)
				}),
				Ke = Object(d.c)({
					queryParams: (e, t) => {
						let {
							location: n
						} = t;
						return r()([...Object(l.a)(n.search)])
					}
				}),
				Qe = Object(d.c)({
					moderatorPermissions: (e, t) => {
						var n;
						const {
							subredditName: s,
							profileName: r
						} = t.match.params, o = s ? Object(w.F)(e, s) : null === (n = Object(I.j)(e, {
							profileName: r
						})) || void 0 === n ? void 0 : n.id;
						if (o) return Object(C.n)(e, {
							subredditId: o
						})
					}
				}),
				Je = Object(d.c)({
					isContributor: (e, t) => {
						const {
							subredditName: n
						} = t.match.params;
						if (n) {
							const t = Object(w.w)(e, {
								subredditName: n
							});
							if (t) return t.userIsContributor
						}
						return !1
					}
				}),
				Ye = Object(d.c)({
					subreddit: (e, t) => t.match.params.subredditName ? Object(w.z)(e, {
						subredditName: t.match.params.subredditName
					}) : Object(I.j)(e, {
						profileName: t.match.params.profileName
					})
				}),
				Xe = Object(i.b)(() => Object(d.a)(ze, T.N, _.S, Qe, T.kb, k.jb, Ye, Je, Ke, (e, t) => t.match.params.pageName, e => e, (e, t, n, s, r, o, a, i, d, c, l) => {
					let {
						contentGateInfo: u
					} = e, {
						moderatorPermissions: m
					} = s, {
						subreddit: p
					} = a, {
						isContributor: b
					} = i, {
						queryParams: h
					} = d;
					const {
						after: f,
						afterEditable: g,
						before: _,
						beforeEditable: v,
						only: O,
						page: x,
						sort: E
					} = h;
					return {
						contentGateInfo: u,
						isBroadcastingEnabled: !!p && Object(S.c)(l, p.id),
						isTalkHostsEnabled: Object(j.s)(l),
						isContributor: b,
						isEmployee: t,
						layout: n,
						moderatorPermissions: m,
						isScheduledPostsEnabled: o,
						subreddit: p,
						renderNSFWContentGate: !!p && p.isNSFW && !r,
						page: `${x||y.b}`,
						pageName: c,
						postTypeFilter: O,
						after: f || "",
						afterEditable: g,
						before: _,
						postSort: E,
						beforeEditable: v
					}
				})),
				Ze = Object(_.u)();
			class $e extends a.a.Component {
				constructor() {
					super(...arguments), this.sendEventWithName = e => () => {
						this.props.sendEvent(t => ({
							source: e.includes("modqueue_sort") ? "moderator" : Object(x.b)(this.props.pageName),
							action: "click",
							noun: e,
							...E.b(t)
						}))
					}, this.onClickSubredditLink = () => {
						this.props.sendEvent(E.d())
					}
				}
				componentDidUpdate(e) {
					(this.props.pageName && this.props.pageName !== e.pageName || this.props.page && this.props.page !== e.page) && (document.documentElement.scrollTop = document.body.scrollTop = 0)
				}
				render() {
					const {
						props: e
					} = this;
					if (!e.subreddit) {
						const t = Object(O.a)(e.contentGateInfo, e.renderNSFWContentGate, e.match.params.subredditName);
						return t ? a.a.createElement(m.default, t) : null
					}
					const t = !!e.moderatorPermissions;
					return a.a.createElement(qe, null, a.a.createElement(Ge.a, {
						onClick: this.onClickSubredditLink,
						subredditOrProfile: e.subreddit,
						pageName: e.pageName ? f(e.pageName) : void 0
					}), a.a.createElement(Ve, null, e.moderatorPermissions && a.a.createElement(Be, {
						moderatorPermissions: e.moderatorPermissions,
						pageName: e.pageName,
						subpageName: e.page,
						subreddit: e.subreddit,
						isProfile: !!e.match.params.profileName
					}), a.a.createElement("div", {
						className: Object(c.a)(We.a.contentWrapper, t && We.a.isModerator)
					}, e.pageName && Object(v.a)({
						pageName: e.pageName,
						moderatorPermissions: e.moderatorPermissions,
						canCreateScheduledPosts: e.isScheduledPostsEnabled,
						isEmployee: e.isEmployee,
						isStreamingEnabled: e.isBroadcastingEnabled,
						isTalkHostsEnabled: e.isTalkHostsEnabled,
						subredditType: e.subreddit.type,
						isContributor: e.isContributor
					}) ? a.a.createElement(N.a, {
						after: e.after,
						afterEditable: e.afterEditable,
						before: e.before,
						beforeEditable: e.beforeEditable,
						layout: e.layout,
						moderatorPermissions: e.moderatorPermissions,
						page: e.page,
						pageName: e.pageName,
						postSort: e.postSort,
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: this.sendEventWithName,
						subpageName: e.page,
						subreddit: e.subreddit
					}) : e.moderatorPermissions ? a.a.createElement(F, {
						subredditDisplayText: e.subreddit.displayText
					}) : a.a.createElement(P.a, {
						isModerator: t,
						subredditDisplayText: e.subreddit.displayText
					}))))
				}
			}
			t.default = Ze(Xe(Object(g.c)($e)))
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/helpers/trackers/inbox.ts"),
				i = n("./src/reddit/hooks/useTracking.ts"),
				d = n("./node_modules/fbt/lib/FbtPublic.js"),
				c = n("./src/config.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var h = e => {
					let {
						inTooltip: t
					} = e;
					const n = {
						to: "/r/cats/top/",
						kind: u.b.InternalLink
					};
					return r.a.createElement("div", {
						className: Object(l.a)(p.a.emptyState, p.a.karmaView, {
							[p.a.inNotificationsPage]: !t
						})
					}, r.a.createElement("div", {
						className: Object(l.a)(p.a.catsImageWrapper, {
							[p.a.inTooltip]: t
						})
					}, r.a.createElement("img", {
						src: `${c.a.assetPath}/img/notifications/bottom_cat.png`,
						alt: d.fbt._("cats picture", null, {
							hk: "27dboq"
						}),
						className: Object(l.a)(p.a.cat, p.a.bottom)
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}/img/notifications/top_cat.png`,
						alt: d.fbt._("cats picture", null, {
							hk: "27dboq"
						}),
						className: Object(l.a)(p.a.cat, p.a.top)
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}/img/notifications/cloud.png`,
						alt: d.fbt._("cats picture", null, {
							hk: "45gHNS"
						}),
						className: p.a.cloud
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}/img/notifications/yummy.png`,
						alt: d.fbt._("cats picture", null, {
							hk: "27dboq"
						}),
						className: p.a.yummy
					})), r.a.createElement("h1", {
						className: Object(l.a)(p.a.emptyTitle, {
							[p.a.inTooltip]: t
						})
					}, d.fbt._("You dont have any activity yet", null, {
						hk: "2GNaV0"
					})), r.a.createElement("p", {
						className: p.a.emptyDescription
					}, d.fbt._("Thats ok, maybe you just need the right inspiration. Have you had your daily cat fix yet today?", null, {
						hk: "3tmgZE"
					})), r.a.createElement(u.t, b({
						className: p.a.emptyStateButton
					}, n), d.fbt._("See todays Top Cats in r/cats", null, {
						hk: "Um68y"
					})))
				},
				f = n("./src/lib/lessComponent.tsx"),
				g = n("./src/reddit/actions/login.ts");
			var _ = e => r.a.createElement("svg", {
				className: e.className,
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 21"
			}, r.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M18.4 14.788c-.662 0-1.2-.537-1.2-1.202l-.012-5.998C17.188 3.625 13.963.4 10 .4 6.037.4 2.811 3.625 2.811 7.586l-.01 6.002c0 .663-.54 1.2-1.2 1.2a1.199 1.199 0 100 2.4h16.8a1.2 1.2 0 100-2.4zm-9.6 3.6H7.6c0 1.324 1.076 2.4 2.4 2.4 1.323 0 2.4-1.076 2.4-2.4H8.8zm-3.6-4.797c0 .422-.087.822-.22 1.197H15.02a3.554 3.554 0 01-.22-1.2l-.013-5.997A4.794 4.794 0 0010 2.8a4.794 4.794 0 00-4.789 4.787l-.01 6.003z"
			}));
			const v = f.a.wrapped(_, "BellOutline", p.a),
				O = e => {
					let {
						isBannerEnabled: t,
						isLoggedIn: n
					} = e;
					const s = Object(o.d)();
					return r.a.createElement("div", {
						className: Object(l.a)(p.a.emptyState, {
							[p.a.emptyStateWithBanner]: Boolean(t),
							[p.a.loggedOutState]: !n
						})
					}, r.a.createElement(v, null), r.a.createElement("h1", {
						className: p.a.emptyTitle
					}, d.fbt._("Be the first to know", null, {
						hk: "2mNJO0"
					})), r.a.createElement("p", {
						className: p.a.emptyDescription
					}, d.fbt._("This is where you get updates on your activity and recommendations", null, {
						hk: "27V2PG"
					})), !n && r.a.createElement("div", {
						className: p.a.emptyStateLoggedOutContainer
					}, r.a.createElement(u.j, {
						onClick: () => s(Object(g.openLoginModal)())
					}, d.fbt._("Log In", null, {
						hk: "ZR3pC"
					})), r.a.createElement("span", {
						className: p.a.emptyStateDivider
					}), r.a.createElement(u.j, {
						onClick: () => s(Object(g.openRegisterModal)())
					}, d.fbt._("Sign Up", null, {
						hk: "3Jd0SI"
					}))))
				};
			var x = n("./src/reddit/controls/InternalLink/index.tsx");

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = ["r/somethingimade", "r/CasualConversation", "r/DoesAnybodyElse", "r/Old_Recipes"][Math.floor(100 * Math.random()) % 4];
			var j = e => {
				let {
					inTooltip: t,
					isPopular: n,
					onBtnClick: s
				} = e;
				const o = n ? "r/popular" : y,
					a = `/${o}`,
					i = {
						to: a,
						kind: u.b.InternalLink
					},
					m = r.a.createElement(x.default, {
						to: a,
						target: "_blank",
						rel: "noopener noreferrer",
						className: p.a.subredditLinkR,
						onClick: s
					}, o);
				return r.a.createElement("div", {
					className: Object(l.a)(p.a.emptyState, p.a.karmaView, {
						[p.a.inNotificationsPage]: !t
					})
				}, r.a.createElement("img", {
					src: `${c.a.assetPath}/img/wrappedreddit/default_avatar.png`,
					alt: d.fbt._("default user avatar", null, {
						hk: "1VMTKf"
					}),
					className: Object(l.a)(p.a.avatarImage, {
						[p.a.inTooltip]: t
					})
				}), r.a.createElement("h1", {
					className: Object(l.a)(p.a.emptyTitle, {
						[p.a.inTooltip]: t
					})
				}, d.fbt._("You dont have any activity yet", null, {
					hk: "43tvWW"
				})), r.a.createElement("p", {
					className: p.a.emptyDescription
				}, n ? d.fbt._("Thats ok, maybe you just need the right inspiration. Try browsing {Link: to r/popular}, for new communities to join.", [d.fbt._param("Link: to r/popular", m)], {
					hk: "VSBWM"
				}) : d.fbt._("Thats ok, maybe you just need the right inspiration. Try posting in {Link: to popular subreddit} , a popular community for discussion.", [d.fbt._param("Link: to popular subreddit", m)], {
					hk: "1WOK4T"
				})), r.a.createElement(u.t, E({
					className: p.a.emptyStateButton,
					onClick: s,
					text: `Visit ${o}`
				}, i)))
			};

			function C() {
				return (C = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const k = "/img/notifications/star.png";
			var I = e => {
					let {
						inTooltip: t,
						onBtnClick: n
					} = e;
					const s = {
						to: "/r/memes/top/",
						kind: u.b.InternalLink
					};
					return r.a.createElement("div", {
						className: Object(l.a)(p.a.emptyState, p.a.karmaView, {
							[p.a.inNotificationsPage]: !t
						})
					}, r.a.createElement("div", {
						className: Object(l.a)(p.a.memesImageWrapper, {
							[p.a.inTooltip]: t
						})
					}, r.a.createElement("img", {
						src: `${c.a.assetPath}/img/notifications/shrek.png`,
						alt: d.fbt._("memes picture", null, {
							hk: "3e3S9E"
						}),
						className: p.a.shrek
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}${k}`,
						alt: d.fbt._("memes picture", null, {
							hk: "2bHwq2"
						}),
						className: Object(l.a)(p.a.star, p.a.inBottom)
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}${k}`,
						alt: d.fbt._("memes picture", null, {
							hk: "2bHwq2"
						}),
						className: Object(l.a)(p.a.star, p.a.inCenter)
					}), r.a.createElement("img", {
						src: `${c.a.assetPath}${k}`,
						alt: d.fbt._("memes picture", null, {
							hk: "2bHwq2"
						}),
						className: Object(l.a)(p.a.star, p.a.inTop)
					})), r.a.createElement("h1", {
						className: Object(l.a)(p.a.emptyTitle, {
							[p.a.inTooltip]: t
						})
					}, d.fbt._("You dont have any activity yet", null, {
						hk: "2GNaV0"
					})), r.a.createElement("p", {
						className: p.a.emptyDescription
					}, d.fbt._("Thats ok, maybe you just need the right inspiration. Lets get some more lolz in your life.", null, {
						hk: "10HMFI"
					})), r.a.createElement(u.t, C({
						className: p.a.emptyStateButton,
						onClick: n
					}, s), d.fbt._("See todays Top Memes in r/Memes", null, {
						hk: "42zwJz"
					})))
				},
				S = n("./src/lib/notifications/index.ts"),
				w = n("./src/lib/notifications/constants.ts"),
				T = n("./src/redditGQL/types.ts"),
				N = n("./src/reddit/actions/modal.ts"),
				P = n("./src/reddit/actions/notifications/index.ts"),
				R = n("./src/reddit/actions/notificationSettingsLayout/index.ts"),
				A = n("./src/reddit/actions/toaster.ts"),
				M = n("./src/reddit/components/Settings/modalIds.ts"),
				D = n("./src/reddit/models/NotificationSettingsLayout/index.ts"),
				L = n("./src/reddit/models/Toast/index.ts"),
				F = n("./src/reddit/selectors/notificationPrefs.ts"),
				U = n("./src/reddit/selectors/user.ts");

			function B() {
				return (B = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const G = [T.j.PrivateMessage, T.j.ChatMessage, T.j.ChatRequest, T.j.UsernameMention, T.j.PostReply, T.j.UpvotePost, T.j.UpvoteComment, T.j.CommentReply, T.j.ThreadReplies, T.j.TopLevelComment, T.j.NewPostActivity, T.j.UserNewFollower, T.j.PostFlairAdded, T.j.UserFlairAdded, T.j.NewPinnedPost, T.j.AwardReceived, T.j.PostFollow, T.j.TalkLive, T.j.CommentFollow, T.j.LifecyclePostSuggestions, T.j.BroadcastRecommendation, T.j.SubredditRecommendation, T.j.RedditLore, T.j.OneOff, T.j.CakeDay, T.j.ModeratedSrEngagement];
			var H;
			! function(e) {
				e[e.TURN_ON_PN = 0] = "TURN_ON_PN", e[e.TURN_ON_PN_APP = 1] = "TURN_ON_PN_APP", e[e.VERIFY_EMAIL = 2] = "VERIFY_EMAIL", e[e.TURN_ON_DAYLY_DIGEST = 3] = "TURN_ON_DAYLY_DIGEST", e[e.DONE = 4] = "DONE"
			}(H || (H = {}));
			var W = e => {
					let {
						inTooltip: t,
						isBannerEnabled: n,
						isLoggedIn: i,
						onBtnClick: m,
						hideTooltip: b
					} = e;
					const h = Object(o.d)(),
						f = Object(o.e)(U.n),
						g = Object(o.e)(U.D),
						_ = Object(s.useRef)(f),
						[v, x] = Object(s.useState)(H.TURN_ON_PN),
						E = Object(o.e)(e => e.user.accountSettings.changeEmail.api.pending),
						y = Object(s.useCallback)(() => {
							h(async (e, t) => {
								var n, s;
								let r = Object(U.fb)(t());
								r.allIds.length || await e(Object(R.a)(D.a.Email));
								const o = null === (s = null === (n = (r = Object(U.fb)(t())).byId) || void 0 === n ? void 0 : n.EMAIL_DIGEST) || void 0 === s ? void 0 : s.isEnabled;
								x(o ? H.DONE : H.TURN_ON_DAYLY_DIGEST)
							})
						}, [h]),
						j = Object(s.useCallback)(() => {
							g ? y() : x(H.VERIFY_EMAIL)
						}, [g, y]),
						C = Object(s.useCallback)(() => {
							h(async (e, t) => {
								const n = t();
								Object(U.hb)(n).allIds.length || await e(Object(R.a)(D.a.Push)), Object(F.c)(t(), G) ? x(H.TURN_ON_PN_APP) : j()
							})
						}, [h, j]),
						k = Object(s.useCallback)(() => {
							(() => Object(S.a)() === w.a.Granted)() ? C(): x(H.TURN_ON_PN)
						}, [C]),
						I = Object(s.useCallback)(() => {
							m(a.b.Email_perms)(), t && b && b(), h(Object(N.h)(M.a))
						}, [h, m, t, b]);
					if (Object(s.useEffect)(() => {
							k()
						}, [k]), Object(s.useEffect)(() => {
							if (f !== _.current && v === H.VERIFY_EMAIL) {
								const e = Object(A.e)(d.fbt._("Email successfully updated!", null, {
									hk: "3iPlUp"
								}), L.b.SuccessCommunityGreen);
								h(Object(A.f)(e)), y()
							}
						}, [f, v, y]), Object(s.useEffect)(() => {
							E && h(Object(N.g)(M.a))
						}, [E, h]), v === H.DONE) return r.a.createElement(O, {
						isLoggedIn: i,
						isBannerEnabled: n
					});
					const T = {
							to: "/settings/notifications",
							kind: u.b.InternalLink,
							onClick: v === H.TURN_ON_PN_APP ? m(a.b.PN_perms) : m(a.b.Email_perms)
						},
						W = {
							onClick: v === H.TURN_ON_PN ? async () => {
								m(a.b.PN_perms)(), t && b && b(), await h(Object(P.requestBrowserNotificationPermissionPromptByUser)(M.f)), k()
							} : I
						},
						q = v === H.TURN_ON_PN || v === H.TURN_ON_PN_APP,
						V = v === H.TURN_ON_PN_APP || v === H.TURN_ON_DAYLY_DIGEST;
					return r.a.createElement("div", {
						className: Object(l.a)(p.a.emptyState, p.a.karmaView, {
							[p.a.inNotificationsPage]: !t
						})
					}, r.a.createElement("img", {
						src: `${c.a.assetPath}/img/wrappedreddit/default_avatar.png`,
						alt: d.fbt._("default user avatar", null, {
							hk: "1VMTKf"
						}),
						className: Object(l.a)(p.a.avatarImage, {
							[p.a.inTooltip]: t
						})
					}), r.a.createElement("h1", {
						className: Object(l.a)(p.a.emptyTitle, {
							[p.a.inTooltip]: t
						})
					}, q ? d.fbt._("Turn on notifications", null, {
						hk: "3qFpFu"
					}) : d.fbt._("Turn on email digest", null, {
						hk: "obBF8"
					})), r.a.createElement("p", {
						className: p.a.emptyDescription
					}, q ? d.fbt._("Stay in the loop on content from communities you love right on your phone.", null, {
						hk: "1gwnbO"
					}) : d.fbt._("Stay in the loop on content from communities you love right on your email inbox.", null, {
						hk: "1rs4kD"
					})), r.a.createElement(u.t, B({
						className: p.a.emptyStateButton
					}, V ? T : W, {
						text: d.fbt._("OK", null, {
							hk: "rhf0"
						})
					})))
				},
				q = n("./src/reddit/constants/experiments.ts"),
				V = n("./src/reddit/helpers/chooseVariant/index.ts");
			const z = e => Object(V.c)(e, {
					experimentEligibilitySelector: V.a,
					experimentName: q.Db
				}) === q.Ed.MemesNoBadge,
				K = e => Object(V.c)(e, {
					experimentEligibilitySelector: V.a,
					experimentName: q.Db
				}) === q.Ed.PnEmailNoBadge,
				Q = e => Object(V.c)(e, {
					experimentEligibilitySelector: V.a,
					experimentName: q.Db
				}) === q.Ed.KarmaNoBadge,
				J = e => Object(V.c)(e, {
					experimentEligibilitySelector: V.a,
					experimentName: q.Db
				}) === q.Ed.PopularNoBadge,
				Y = e => Object(V.c)(e, {
					experimentEligibilitySelector: V.a,
					experimentName: q.Db
				}) === q.Ed.CatsNoBadge;
			t.a = e => {
				let {
					isBannerEnabled: t,
					isLoggedIn: n,
					inTooltip: s,
					hideTooltip: d
				} = e;
				const c = Object(i.a)(),
					l = e => () => c(Object(a.q)({
						actionInfoType: e
					})),
					u = Object(o.e)(z),
					m = Object(o.e)(K),
					p = Object(o.e)(Q),
					b = Object(o.e)(J),
					f = Object(o.e)(Y);
				return u ? r.a.createElement(I, {
					inTooltip: s,
					onBtnClick: l(a.b.Memes)
				}) : m ? r.a.createElement(W, {
					isBannerEnabled: t,
					isLoggedIn: n,
					inTooltip: s,
					onBtnClick: l,
					hideTooltip: d
				}) : p || b ? r.a.createElement(j, {
					inTooltip: s,
					isPopular: b,
					onBtnClick: l(a.b.Karma)
				}) : f ? r.a.createElement(h, {
					inTooltip: s
				}) : r.a.createElement(O, {
					isBannerEnabled: t,
					isLoggedIn: n
				})
			}
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less": function(e, t, n) {
			e.exports = {
				emptyState: "_3B_EfQMwEiEzc_9vEdVplz",
				emptyStateLoggedOutContainer: "_3AcDG0KjCxs3H1UW_4ajNf",
				emptyStateDivider: "bfJNAfRJ7wvCVMJIHbVa-",
				karmaView: "_3eBLRjkIDT-8Hobfrj_UTz",
				inNotificationsPage: "_2upiES-f8azWSz_UdoeHE7",
				avatarImage: "mGm_bo7f-d7T6Ax_UEs_l",
				inTooltip: "JBKRJW6IC_gf5qQ_mqb4A",
				catsImageWrapper: "odMqhFpc4xkpus4jHz_9f",
				cat: "_13uS-SsNmI2cGGsq2rpP8O",
				top: "_29krHC0w9xxlGw1mBpwNHU",
				bottom: "_3VkvX9EbwQAVQJ3qEl_wzw",
				cloud: "_3yAL94u5AxUY-JhhHIPNuU",
				yummy: "_2TY8uYFieKTHl7jN_vmcYR",
				memesImageWrapper: "jaQ0krPJ6FkjLU-VDMGNq",
				shrek: "_1f1-1KlOtH3uQKPHzkGdDI",
				star: "_2mEU_pG_y9L4CaC7zihby0",
				inBottom: "_1kfecAwlZWu6be_WDfvh-P",
				inCenter: "_4DkJv1On5ORUXrwzznhqE",
				inTop: "_1lJAHwdJYzqn-69JkG-HJQ",
				emptyStateButton: "_1_kVxSQ5_eQNTfI-Y89mu4",
				loggedOutState: "_3uw_OsQCi8zOpS3fha4JEF",
				emptyStateWithBanner: "_1L4nSUqK39ZB-E1-MXtBve",
				emptyTitle: "_36brOzjH6sE_rgnTt-hcL1",
				emptyDescription: "Ae79bDDbZ2U_G-wqwA71z",
				subredditLinkR: "_9DV1fqkU31oi8pfSQxzjw",
				BellOutline: "_23NDu_VaLgaSWVzKHs-Gfa",
				bellOutline: "_23NDu_VaLgaSWVzKHs-Gfa"
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./src/reddit/actions/economics/paymentSystems/constants.ts");
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(s || (s = {}));
			const o = {
				status: s.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === s.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								{
									[n]: s,
									...r
								} = e.data.stripe.sources;
							return {
								...e,
								data: {
									...e.data,
									stripe: {
										...e.data.stripe,
										sources: r
									}
								}
							}
						}
						return e;
					case r.e:
						if (e.status === s.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								{
									[n]: s,
									...r
								} = e.data.braintree.sources;
							return {
								...e,
								data: {
									...e.data,
									braintree: {
										...e.data.braintree,
										sources: r
									}
								}
							}
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: s.Failure
						};
					case r.c:
						return {
							data: t.payload, status: s.Fetched
						};
					case r.d:
						return {
							status: s.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./src/lib/constants/specialMembership.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				a = n("./src/reddit/helpers/economics/sortBadges.ts"),
				i = n("./src/reddit/models/Badge/index.ts"),
				d = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(s || (s = {}));
			const c = {};

			function l(e) {
				return "userId" in e
			}

			function u(e, t, n, s) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let o;
						(o = e.placement ? e.placement === i.a.First ? s[d.a.Loyalty][r] : s[d.a.Achievement][r] : l(e) ? s[d.a.Cosmetic][d.c.MyBadges][r] : s[d.a.Cosmetic][d.c.Gallery][r]) && (l(e) ? n.has(e.id) && o.unlocked.push(e) : t.has(e.id) || o.locked.push(e))
					})
				})
			}

			function m(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						s = parseInt(t.price || "0");
					return n === s ? Object(a.b)(e, t) : n - s
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(m).sort((e, n) => {
					const s = t[e.id],
						r = t[n.id];
					return Object(a.b)(s, r)
				})
			}

			function b(e) {
				const t = {
					[d.a.Loyalty]: {},
					[d.a.Achievement]: {},
					[d.a.Cosmetic]: {
						[d.c.Gallery]: {},
						[d.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const s = e.collections[n],
						r = {
							description: s.description,
							highlight: s.extra && s.extra.style && s.extra.style.color,
							id: s.id,
							locked: [],
							title: s.title,
							unlocked: []
						};
					t[d.a.Loyalty][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Achievement][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.Gallery][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.MyBadges][n] = {
						...r,
						locked: [],
						unlocked: []
					}
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const s = e.badges[t];
					s && n.add(s.type)
				});
				const s = new Set(e.userOwnedBadges);
				return u(Object.keys(e.badges).map(t => e.badges[t]), n, s, t), u(Object.keys(e.products).map(t => e.products[t]), n, s, t), {
					collections: {
						[d.a.Loyalty]: p(t[d.a.Loyalty], e.collections),
						[d.a.Achievement]: p(t[d.a.Achievement], e.collections),
						[d.a.Cosmetic]: {
							[d.c.Gallery]: p(t[d.a.Cosmetic][d.c.Gallery], e.collections),
							[d.c.MyBadges]: p(t[d.a.Cosmetic][d.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data
								},
								raw: {
									...r.raw
								}
							}
						} : e
					}
					case o.h: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data,
									subscription: {
										...r.data.subscription || {},
										settings: {
											renew: !1
										}
									}
								},
								raw: {
									...r.raw,
									subscription: {
										...r.raw.subscription || {},
										settings: {
											renew: !1
										}
									}
								}
							}
						} : e
					}
					case o.i: {
						const n = t.payload;
						return {
							...e,
							[n.subredditId]: {
								raw: n,
								data: b(n),
								status: s.Fetched
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/avatar/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o = n("./node_modules/redux/es/redux.js"),
				a = n("./src/reddit/actions/snoovatar.ts");
			! function(e) {
				e.PREMIUM = "PREMIUM"
			}(s || (s = {})),
			function(e) {
				e[e.BACKGROUND = 0] = "BACKGROUND", e[e.ACCESSORY_BACK = 1] = "ACCESSORY_BACK", e[e.HAIR_BACK = 2] = "HAIR_BACK", e[e.BODY_BOTTOM = 3] = "BODY_BOTTOM", e[e.BODY = 4] = "BODY", e[e.ACCESSORY = 5] = "ACCESSORY", e[e.FACE_LOWER = 6] = "FACE_LOWER", e[e.FACE_UPPER = 7] = "FACE_UPPER", e[e.HAIR = 8] = "HAIR", e[e.HEAD_ACCESSORY = 9] = "HEAD_ACCESSORY"
			}(r || (r = {}));
			const i = {
				id: "",
				csrf_token: "",
				snoovatar: null,
				websocketsUrls: {
					renderer: "",
					download: ""
				},
				capabilities: [s.PREMIUM],
				hasActiveClosetSubscription: !1
			};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.b:
						return {
							...t.payload
						};
					default:
						return e
				}
			};
			const c = {
					marketingEvent: {
						active: !1,
						assetUrls: null,
						experimentRequired: null
					},
					quickCreateV1: {
						id: "-1",
						active: !1,
						text: "",
						min_days_on_reddit: 0,
						should_have_avatar: !1,
						max_event_views: 0,
						min_days_since_last_event_interaction: 0,
						webAssetUrls: []
					}
				},
				l = "avatar_quick_create_event",
				u = "avatar_marketing_event",
				m = "avatar_promo_archived",
				p = e => {
					const t = {};
					return e.forEach(e => {
						if (e.startsWith("targeting:")) {
							const n = e.split(":");
							if (!n.length && n.length < 3) return null;
							try {
								t[n[1]] = JSON.parse(n[2])
							} catch {
								t[n[1]] = n[2]
							}
						}
					}), t
				};

			function b(e) {
				if (!e) return c;
				const t = c;
				return e.forEach(e => {
					var n;
					const {
						startsAt: s,
						endsAt: r,
						webAssetUrls: o,
						tags: a
					} = e, i = s && new Date(s) <= new Date, d = !!r && new Date(r) < new Date, c = !!i && !d, b = (a || []).includes(m);
					if (a && a.includes(l) && !b) {
						const {
							text: n,
							id: s
						} = e, r = o || null, i = p(a);
						t && (t.quickCreateV1 = {
							...i,
							id: s,
							text: n,
							active: c && !!r,
							webAssetUrls: r
						})
					}
					if (a && a.includes(u) && !b) {
						const e = o || null,
							s = (null === (n = a.find(e => e.startsWith("feature:") && e.includes("web"))) || void 0 === n ? void 0 : n.split("feature:")[1]) || null;
						t && (t.marketingEvent = {
							active: c && !!e,
							assetUrls: e,
							experimentRequired: s
						})
					}
				}), t
			}
			var h = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				f = n("./src/reddit/actions/modal.ts"),
				g = n("./src/reddit/constants/modals.ts");
			var _ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case h.s:
						const {
							avatarMarketingEvents: s
						} = t.payload;
						return s ? b(s) : c;
					case f.c:
						return (null === (n = t.payload) || void 0 === n ? void 0 : n.id) === g.a.SNOOVATAR_MODAL ? c : e;
					default:
						return e
				}
			};
			var v = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.a: {
						const {
							image: e,
							accessory_ids: n
						} = t.payload;
						return {
							image: e,
							accessoryIds: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(o.c)({
				marketing: _,
				avatarUser: d,
				randomAvatar: v
			})
		},
		"./src/reddit/reducers/features/creatorStats/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/creatorStats/constants.ts");
			const o = {};
			var a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postOtherDiscussions: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const i = {};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postStats: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const c = {};
			var l = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							subredditKarma: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				postOtherDiscussions: a,
				postStats: d,
				subredditKarma: l
			})
		},
		"./src/reddit/reducers/features/crypto/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/economics/claims/constants.ts")),
				o = n("./src/reddit/actions/economics/me/constants.ts");
			const a = {};
			var i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case o.a: {
							const n = t.payload.claimPoints || {},
								s = Object.keys(n).reduce((t, s) => (t[s] = {
									...e[s],
									availableClaims: n[s]
								}, t), {});
							return Object.keys(e).forEach(t => {
								var n;
								(null === (n = e[t]) || void 0 === n ? void 0 : n.isClaiming) && (s[t] = s[t] || {
									availableClaims: []
								}, s[t].isClaiming = !0)
							}), s
						}
						case r.b:
						case r.a:
							const {
								subredditId: n
							} = t.payload;
							return {
								...e, [n]: {
									...e[n],
									isClaiming: t.type === r.b
								}
							};
						default:
							return e
					}
				},
				d = n("./src/reddit/actions/governance/constants.ts");
			const c = 15e4,
				l = {},
				u = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				};

			function m(e) {
				var t, n, s, r, o;
				const a = null === (t = e.walletProvider) || void 0 === t ? void 0 : t.extra,
					i = null == a ? void 0 : a.contracts,
					d = null == i ? void 0 : i.unlocked,
					l = null !== (s = null === (n = e.walletProvider) || void 0 === n ? void 0 : n.provider) && void 0 !== s ? s : e.provider,
					m = !!(null === (r = e.walletProvider) || void 0 === r ? void 0 : r.inTransition),
					p = null == a ? void 0 : a.metaTransactions,
					b = (null == p ? void 0 : p.allowedContractMethods) || {},
					h = (null == p ? void 0 : p.gasLimit) || c,
					f = (null == d ? void 0 : d.decimals) || 0,
					g = "1" + "0".repeat(f);
				return {
					allowedContractMethods: b,
					blockchainProvider: l,
					contractAddress: (null == d ? void 0 : d.address) || "",
					contracts: i,
					decimals: f,
					displayConversion: g,
					gasLimit: h,
					images: e.images || u,
					inTransition: m,
					name: e.name,
					nomenclature: null === (o = e.extra) || void 0 === o ? void 0 : o.nomenclature,
					polls: e.polls,
					symbol: (null == d ? void 0 : d.token) || ""
				}
			}
			var p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: n,
							meta: s
						} = t.payload;
						return {
							...e,
							[n]: m(s)
						}
					}
					default:
						return e
				}
			};
			const b = {};
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.n: {
						const {
							subredditId: n,
							wallets: s
						} = t.payload, r = Object.keys(s).reduce((t, r) => {
							return {
								...t,
								[r]: {
									...e[r] || {},
									[n]: s[r]
								}
							}
						}, {});
						return {
							...e,
							...r
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				claims: i,
				points: p,
				publicWallets: h
			})
		},
		"./src/reddit/reducers/features/modUserNotes/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U:
						case r.T:
							return null;
						case r.S:
							return t.payload;
						default:
							return e
					}
				},
				a = n("./src/reddit/models/SubredditModeration/index.ts");
			const i = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(a.d)(n, s, r);
							return {
								...e,
								[o]: !0
							}
						}
						case r.T:
						case r.S: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(a.d)(n, s, r);
							return {
								...e,
								[o]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: n,
								userId: s,
								filter: r,
								fetchedToken: o
							} = t.payload, i = Object(a.d)(n, s, r, o);
							return {
								...e,
								[i]: !0
							}
						}
						default:
							return e
					}
				},
				m = n("./src/redditGQL/types.ts");
			const p = {};
			var b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(a.d)(n, s.user.id, m.m.All);
						return {
							...e,
							[r]: s.id
						}
					}
					case r.H: {
						const {
							subredditId: s,
							lastAuthorModNote: r
						} = t.payload, o = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id, i = Object(a.d)(s, o, m.m.All);
						return {
							...e,
							[i]: r.id
						}
					}
					case r.G: {
						const {
							subredditId: n,
							lastAuthorModNotes: s
						} = t.payload, r = {};
						return s.forEach(e => {
							var t;
							const s = null === (t = null == e ? void 0 : e.user) || void 0 === t ? void 0 : t.id,
								o = Object(a.d)(n, s, m.m.All);
							r[o] = e.id
						}), {
							...e,
							...r
						}
					}
					default:
						return e
				}
			};
			const h = {};
			var f = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: e,
								userId: n,
								filter: s,
								loadMoreToken: r
							} = t.payload;
							return {
								[Object(a.d)(e, n, s)]: r
							}
						}
						default:
							return e
					}
				},
				g = n("./node_modules/icepick/icepick.js");
			const _ = {};
			var v = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Q: {
							const {
								newModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.H: {
							const {
								lastAuthorModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.G: {
							const {
								lastAuthorModNotes: n
							} = t.payload;
							return Object(g.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.T: {
							const {
								notes: n
							} = t.payload;
							return Object(g.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.R: {
							const {
								noteId: n
							} = t.payload, s = {
								...e
							};
							return delete s[n], s
						}
						default:
							return e
					}
				},
				O = n("./node_modules/lodash/uniq.js"),
				x = n.n(O);
			const E = {};
			var y = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: s,
							newModNote: r,
							filter: o
						} = t.payload;
						if (o !== m.m.All && o !== m.m.Note) return e;
						const i = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id,
							d = Object(a.d)(s, i, o),
							c = o === m.m.All ? m.m.Note : m.m.All,
							l = Object(a.d)(s, i, c);
						return {
							...e,
							[d]: e[d] ? [r.id, ...e[d]] : [r.id],
							[l]: e[l] ? [r.id, ...e[l]] : [r.id]
						}
					}
					case r.T: {
						const {
							notes: n,
							subredditId: s,
							userId: r,
							filter: o
						} = t.payload, i = Object(a.d)(s, r, o), d = n.map(e => e.id);
						return e[i] ? {
							...e,
							[i]: x()([...e[i], ...d])
						} : {
							...e,
							[i]: d
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s,
							noteId: r
						} = t.payload, o = Object(a.d)(n, s, m.m.All), i = Object(a.d)(n, s, m.m.Note), d = e[o] ? e[o].filter(e => e !== r) : [], c = e[i] ? e[i].filter(e => e !== r) : [];
						return {
							...e,
							...e[o] ? {
								[o]: d
							} : null,
							...e[i] ? {
								[i]: c
							} : null
						}
					}
					default:
						return e
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const j = {};
			var C = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : j,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(a.d)(n, s.user.id, m.m.All);
						return {
							...e,
							[r]: {
								...e[r],
								[m.m.All]: (e[r][m.m.All] || 0) + 1,
								[m.m.Note]: (e[r][m.m.Note] || 0) + 1
							}
						}
					}
					case r.lb: {
						const {
							subredditId: n,
							userId: s,
							totalCounts: r
						} = t.payload, o = Object(a.d)(n, s, m.m.All);
						return {
							...e,
							[o]: Object.keys(r).reduce((e, t) => (e[t] = r[t].totalCount, e), {})
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s
						} = t.payload, r = Object(a.d)(n, s, m.m.All);
						return {
							...e,
							...void 0 !== e[r] ? {
								[r]: {
									...e[r],
									[m.m.All]: (e[r][m.m.All] || 1) - 1,
									[m.m.Note]: (e[r][m.m.Note] || 1) - 1
								}
							} : null
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: c,
				fetchedTokens: u,
				lastAuthorModNotes: b,
				loadMore: f,
				models: v,
				order: y,
				totalCount: C
			})
		},
		"./src/reddit/reducers/features/powerups/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/gold/constants.ts"),
				o = n("./src/reddit/models/Gold/Powerups/powerupsFlair/index.ts");
			const a = {};
			var i = n("./node_modules/icepick/icepick.js"),
				d = n("./src/reddit/actions/economics/powerups/constants.ts");
			const c = {},
				l = e => {
					var t, n;
					return (null === (t = e.find(e => {
						let {
							isPreferred: t
						} = e;
						return t
					})) || void 0 === t ? void 0 : t.type) || (null === (n = e[0]) || void 0 === n ? void 0 : n.type)
				},
				u = {};
			t.a = Object(s.c)({
				subredditPowerupsFlairs: function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.mb:
							const {
								subredditId: n, subredditAchievementFlairs: s
							} = t.payload;
							if (!(null == s ? void 0 : s.length)) return e;
							const a = s.reduce((e, t) => ({
									...e,
									[t.type]: t
								}), {}),
								i = s.filter(o.a).map(e => e.type),
								d = s.filter(o.b).map(e => e.type);
							return {
								...e, [n]: {
									flairsByType: a,
									achievementTypes: i,
									supporterTypes: d
								}
							};
						default:
							return e
					}
				},
				subredditUserPowerupsFlairs: function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.d: {
							const {
								id: n,
								userAchievementFlairsByRedditorIds: s
							} = t.payload;
							let r = e[n] || {};
							for (const {
									redditorId: e,
									isHidden: t,
									userAchievementFlairs: a
								} of s) {
								const n = a.filter(o.a),
									s = n.map(e => {
										let {
											type: t
										} = e;
										return t
									}),
									i = a.filter(o.b),
									d = i.map(e => {
										let {
											type: t
										} = e;
										return t
									}),
									c = l(n),
									u = l(i);
								r = {
									...r,
									[e]: {
										achievementTypes: s,
										supporterTypes: d,
										preferredAchievementType: c,
										preferredSupporterType: u,
										isHidden: t
									}
								}
							}
							return {
								...e,
								[n]: r
							}
						}
						case d.f: {
							const {
								subredditId: n,
								userId: s,
								achievementFlairType: r,
								supporterFlairType: o
							} = t.payload;
							return Object(i.updateIn)(e, [n, s], e => ({
								...e,
								pendingAchievementType: r,
								pendingSupporterType: o
							}))
						}
						case d.g: {
							const {
								subredditId: n,
								userId: s,
								achievementFlairType: r,
								supporterFlairType: o
							} = t.payload;
							return Object(i.updateIn)(e, [n, s], e => ({
								...e,
								preferredAchievementType: r,
								preferredSupporterType: o,
								pendingAchievementType: void 0,
								pendingSupporterType: void 0
							}))
						}
						case d.e: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return Object(i.updateIn)(e, [n, s], e => ({
								...e,
								pendingAchievementType: void 0,
								pendingSupporterType: void 0
							}))
						}
						case d.h: {
							const {
								subredditId: n,
								userId: s,
								isHidden: r
							} = t.payload;
							return Object(i.updateIn)(e, [n, s], e => ({
								...e,
								isHidden: r
							}))
						}
						default:
							return e
					}
				},
				usersSupportedSubreddits: function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case d.i: {
							let n = {};
							return t.payload.forEach(e => {
								const t = e.id,
									s = e.powerups;
								if (!t || !s) return;
								const r = s.supportedSubreddits.filter(e => {
									let {
										subredditInfo: t
									} = e;
									return null == t ? void 0 : t.id
								}).map(e => {
									let {
										subredditInfo: t
									} = e;
									return t.id
								});
								n = {
									...n,
									[t]: r.reduce((e, t) => (e[t] = !0, e), {})
								}
							}), {
								...e,
								...n
							}
						}
						default:
							return e
					}
				}
			})
		},
		"./src/reddit/reducers/features/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./src/reddit/actions/grantUserFlair/constants.ts"),
				a = n("./src/reddit/actions/modQueue/constants.ts"),
				i = n("./src/reddit/actions/pages/constants.ts"),
				d = n("./src/reddit/actions/pages/postCreation.ts"),
				c = n("./src/reddit/actions/pages/postDraft.ts"),
				l = n("./src/reddit/actions/pages/subreddit.ts"),
				u = n("./src/reddit/actions/userFlair/constants.ts");
			const m = {};
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n, s, p, b, h;
				switch (t.type) {
					case l.SUBREDDIT_LOADED:
					case d.PAGE_LOADED:
					case c.PAGE_LOADED:
					case i.b:
					case i.f:
					case u.k:
						return {
							...e, ...t.payload.userFlair
						};
					case a.i:
					case a.f:
					case a.m:
					case a.p:
					case a.v: {
						const {
							response: n
						} = t.payload, {
							userFlair: s
						} = n, r = {
							...e
						};
						return Object.keys(s).forEach(e => {
							r[e] || (r[e] = s[e])
						}), r
					}
					case u.r: {
						const {
							subredditId: n,
							applied: s,
							displaySettings: r
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s && {
									applied: s
								},
								displaySettings: r
							}
						}
					}
					case o.h: {
						const {
							subredditId: n,
							applied: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								applied: s
							}
						}
					}
					case u.j: {
						const {
							subredditId: n,
							isEnabled: s
						} = t.payload, r = {
							...e[n].displaySettings,
							isEnabled: s
						};
						return {
							...e,
							[n]: {
								...e[n],
								displaySettings: r
							}
						}
					}
					case u.d: {
						const {
							subredditId: s,
							canAssignOwn: r
						} = t.payload, o = {
							...null === (n = e[s]) || void 0 === n ? void 0 : n.permissions,
							canAssignOwn: r
						};
						return {
							...e,
							[s]: {
								...e[s],
								permissions: o
							}
						}
					}
					case u.q: {
						const n = t.payload,
							r = e[n.subredditId],
							o = null === (s = e[n.subredditId]) || void 0 === s ? void 0 : s.templates,
							a = null === (p = e[n.subredditId]) || void 0 === p ? void 0 : p.templateIds,
							i = (null === (b = n.template) || void 0 === b ? void 0 : b.id) || (null === (h = n.template) || void 0 === h ? void 0 : h.templateId);
						if (!i) return;
						const d = {
								...o,
								[i]: n.template
							},
							c = [...a];
						return c.includes(i) || c.push(i), {
							...e,
							[n.subredditId]: {
								...r,
								templates: d,
								templateIds: c
							}
						}
					}
					case u.g: {
						const n = t.payload,
							s = e[n.subredditId],
							o = e[n.subredditId].templates,
							a = e[n.subredditId].templateIds,
							i = r()(o, n.templateId),
							d = a.filter(e => e !== n.templateId);
						return {
							...e,
							[n.subredditId]: {
								...s,
								templates: {
									...i
								},
								templateIds: d
							}
						}
					}
					case u.m:
					case u.l: {
						const n = t.payload,
							s = e[n.subredditId];
						return {
							...e,
							[n.subredditId]: {
								...s,
								templateIds: n.templateIds
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/pages/comments/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/ads/constants.ts");
			const o = [];
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.u:
							return t.payload;
						case r.v:
						default:
							return e
					}
				},
				i = n("./src/reddit/actions/pages/constants.ts");
			const d = {};
			var c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.d:
					case i.b:
					case i.h:
					case i.f: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					case i.a:
					case i.e: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s || {}
						}
					}
					default:
						return e
				}
			};
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.c:
					case i.g: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !0
						}
					}
					case i.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !1
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.d:
						case i.h:
						case i.i: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !0
							}
						}
						case i.b:
						case i.a:
						case i.f:
						case i.e: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !1
							}
						}
						default:
							return e
					}
				},
				b = Object(s.c)({
					error: c,
					fullyLoaded: u,
					pending: p
				}),
				h = n("./src/reddit/actions/comment/constants.ts");
			const f = [];
			var g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case h.H:
							return e.find(e => t.payload.id === e.id) ? [...e.filter(e => t.payload.id !== e.id)] : [...e, t.payload];
						case h.b:
							return [...e.filter(e => e.expiresAt > Date.now())];
						case h.w:
							return [...t.payload.comments];
						default:
							return e
					}
				},
				_ = n("./src/reddit/actions/comment/websocket/constants.ts"),
				v = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/uniqBy.js")),
				O = n.n(v);

			function x(e) {
				return O()(e, "id").sort((e, t) => e.created - t.created)
			}

			function E(e, t) {
				return x([...t || [], e])
			}

			function y(e, t) {
				return t && t.length > 0 ? t.filter(t => t.id !== e) : []
			}

			function j(e, t) {
				const n = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
				return {
					id: e.id,
					created: n,
					stickied: e.isStickied,
					authorId: e.authorId
				}
			}

			function C(e, t) {
				return Object.values(e).map(e => j(e, t))
			}
			const k = {};
			var I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case i.f:
						case h.y:
						case i.b: {
							const {
								comments: n,
								key: s
							} = t.payload, r = e[s] ? e[s] : [], o = C(n, r.find(e => e.stickied)), a = x([...r, ...o]);
							return {
								...e,
								[s]: [...a]
							}
						}
						case _.b:
						case _.c:
						case _.d: {
							const {
								comment: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: E(j(n), e[s])
							}
						}
						case h.M:
						case h.L: {
							const {
								draftKey: n,
								comment: s,
								commentsPageKey: r
							} = t.payload;
							return {
								...e,
								[r]: y(n, E(j(s), e[r]))
							}
						}
						case h.K: {
							const {
								optimisticComment: n,
								commentsPageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: E(j(n), e[s])
							} : e
						}
						case h.G: {
							const {
								commentId: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: y(n, e[s])
							}
						}
						default:
							return e
					}
				},
				S = n("./node_modules/lodash/mapValues.js"),
				w = n.n(S),
				T = n("./src/reddit/helpers/commentList/index.ts"),
				N = n("./src/reddit/models/Comment/index.ts");
			const P = {};

			function R(e) {
				const t = e;
				return w()(t, e => {
					let {
						depth: t,
						next: n,
						prev: s
					} = e;
					return {
						depth: t,
						next: n,
						prev: s
					}
				})
			}
			var A = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case h.y: {
						const {
							comments: n,
							commentLists: s,
							continueThreads: r,
							key: o,
							moreCommentsItem: a,
							moreComments: i
						} = t.payload, d = s[a.postId], c = e[o], l = {}, u = c[a.id];
						if (u && u.prev) {
							const {
								id: e
							} = u.prev;
							l[e] = {
								...c[e],
								next: d.head || u.next
							}
						}
						if (u && u.next) {
							const {
								id: e
							} = u.next;
							l[e] = {
								...c[e],
								prev: d.tail || u.prev
							}
						}
						if (d.head && d.tail) {
							const e = Object(T.c)({
									commentLink: d.head,
									commentsDict: n,
									moreCommentsDict: i,
									continueThreadDict: r
								}),
								t = Object(T.c)({
									commentLink: d.tail,
									commentsDict: n,
									moreCommentsDict: i,
									continueThreadDict: r
								});
							u && (e.prev = u.prev, t.next = u.next)
						}
						return {
							...e,
							[o]: {
								...e[o],
								...R(n),
								...R(r),
								...R(i),
								...l
							}
						}
					}
					case i.b:
					case i.f: {
						const {
							comments: n,
							continueThreads: s,
							key: r,
							moreComments: o
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r],
								...R(n),
								...R(s),
								...R(o)
							}
						}
					}
					case _.b:
					case h.M: {
						const {
							comment: n,
							commentsPageKey: s,
							headCommentId: r
						} = t.payload, o = e[s], a = {};
						let i = null;
						return r && (a[r] = {
							...o[r],
							prev: Object(N.i)(n.id)
						}, i = Object(N.i)(r)), {
							...e,
							[s]: {
								...e[s],
								...a,
								[n.id]: {
									depth: 0,
									next: i,
									prev: null
								}
							}
						}
					}
					case h.L: {
						const {
							comment: n,
							commentsPageKey: s,
							parentCommentId: r,
							depth: o
						} = t.payload, a = e[s], i = {};
						let d = null;
						if (!a[r]) return e;
						const c = a[r].next;
						return c && (i[c.id] = {
							...a[c.id],
							prev: Object(N.i)(n.id)
						}, d = c), i[r] = {
							...a[r],
							next: Object(N.i)(n.id)
						}, {
							...e,
							[s]: {
								...e[s],
								...i,
								[n.id]: {
									depth: o,
									next: d,
									prev: Object(N.i)(r)
								}
							}
						}
					}
					default:
						return e
				}
			};
			const M = {};
			var D = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case _.b:
					case _.c:
					case h.M: {
						const {
							comment: n,
							commentsPageKey: s
						} = t.payload;
						return {
							...e,
							[s]: n.id
						}
					}
					case i.b:
					case i.f: {
						const {
							commentLists: n,
							key: s,
							postId: r
						} = t.payload;
						return {
							...e,
							[s]: n[r] && n[r].head ? n[r].head.id : null
						}
					}
					case i.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					default:
						return e
				}
			};
			const L = {};
			var F = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : L,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.d:
					case i.b:
					case i.c:
					case i.h: {
						const {
							key: n,
							postId: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case h.M: {
						const {
							parentId: n,
							commentsPageKey: s
						} = t.payload;
						return e[s] ? e : {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: b,
				followed: g,
				keyToChatCommentLinks: I,
				keyToCommentThreadLinkSets: A,
				keyToHeadCommentId: D,
				keyToPostId: F,
				ads: a
			})
		},
		"./src/reddit/reducers/pages/modHub/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g:
						case r.f:
							return null;
						case r.e:
							return t.payload;
						default:
							return e
					}
				},
				a = n("./src/reddit/models/SubredditModeration/index.ts");
			const i = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.f:
						case r.e: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.f: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(a.e)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				b = n("./node_modules/icepick/icepick.js");
			const h = {};
			var f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.d:
					case r.f: {
						const {
							subredditId: n,
							approvedSubmitters: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.k: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var g = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.j:
					case r.i:
						return null;
					case r.h:
						return t.payload;
					default:
						return e
				}
			};
			var _ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return !0;
						case r.i:
						case r.h:
							return !1;
						default:
							return e
					}
				},
				v = Object(s.c)({
					error: g,
					pending: _
				});
			var O = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return null;
						case r.i: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				x = Object(s.c)({
					api: v,
					result: O
				});
			const E = {};
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.k: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				j = Object(s.c)({
					api: c,
					fetchedTokens: u,
					loadMore: p,
					models: f,
					search: x,
					userOrder: y
				});
			var C = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.n:
					case r.m:
						return null;
					case r.l:
						return t.payload;
					default:
						return e
				}
			};
			const k = {};
			var I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.n: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.f)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.m:
						case r.l: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.f)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				S = Object(s.c)({
					error: C,
					pending: I
				});
			const w = {};
			var T = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(a.f)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const N = {};
			var P = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							subredditId: e,
							loadMoreToken: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const R = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								subredditId: n,
								approvedTalkHosts: s,
								forceRefresh: r
							} = t.payload, o = {
								[n]: [...r ? [] : e[n] || [], ...s]
							};
							return Object(b.merge)(e, o)
						}
						case r.o: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								[n]: e[n].filter(e => e.redditor.id !== s)
							};
							return Object(b.merge)(e, r)
						}
						default:
							return e
					}
				},
				M = Object(s.c)({
					api: S,
					fetchedTokens: T,
					loadMore: P,
					models: A
				}),
				D = n("./src/reddit/actions/grantUserFlair/constants.ts");
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case D.g:
					case D.i:
						return null;
					case D.f:
						return t.payload;
					default:
						return e
				}
			};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case D.i:
							return !0;
						case D.g:
						case D.f:
							return !1;
						default:
							return e
					}
				},
				U = Object(s.c)({
					error: L,
					pending: F
				}),
				B = n("./node_modules/lodash/merge.js"),
				G = n.n(B),
				H = n("./node_modules/lodash/omit.js"),
				W = n.n(H);
			const q = {};
			var V = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : q,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case D.g:
					case D.k: {
						const {
							subredditId: n,
							flairedUsers: s
						} = t.payload;
						return G()({
							...e
						}, {
							[n]: s
						})
					}
					case D.c: {
						const {
							subredditId: n,
							userName: s
						} = t.payload, r = W()(e[n], s);
						return {
							...e,
							[n]: r
						}
					}
					case D.a:
					case D.b:
					case D.h:
						const {
							subredditId: n, userName: s, applied: r
						} = t.payload;
						return r ? {
							...e,
							[n]: {
								...e[n],
								[s]: r
							}
						} : e;
					default:
						return e
				}
			};
			const z = {};
			var K = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case D.g: {
						const {
							key: n,
							pageInfo: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			var Q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case D.l:
					case D.k:
						return null;
					case D.j:
						return t.payload;
					default:
						return e
				}
			};
			var J = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case D.l:
							return !0;
						case D.k:
						case D.j:
							return !1;
						default:
							return e
					}
				},
				Y = Object(s.c)({
					error: Q,
					pending: J
				});
			var X = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case D.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case D.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Z = Object(s.c)({
					api: Y,
					result: X
				});
			const $ = {};
			var ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case D.g: {
							const {
								key: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case D.a: {
							const {
								key: n,
								userName: s
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(s)) {
								const t = [...e[n], s];
								return {
									...e,
									[n]: t
								}
							}
							return e
						}
						case D.c: {
							const {
								userName: n
							} = t.payload, s = {};
							for (const t in e) s[t] = e[t].filter(e => e !== n);
							return s
						}
						default:
							return e
					}
				},
				te = Object(s.c)({
					api: U,
					models: V,
					pageInfo: K,
					search: Z,
					userOrder: ee
				}),
				ne = n("./src/reddit/actions/moderationLog/constants.ts");
			const se = {};
			var re = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							actionIds: n,
							key: s,
							subredditId: r
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r] || {},
								[s]: n
							}
						}
					}
					default:
						return e
				}
			};
			const oe = {};
			var ae = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.b: {
							const {
								normalizedModerationLog: n,
								subredditId: s
							} = t.payload, r = {};
							n.forEach(e => {
								r[e.id] = e
							});
							const o = {
								[s]: r
							};
							return G()({
								...e
							}, o)
						}
						default:
							return e
					}
				},
				ie = Object(s.c)({
					itemOrder: re,
					models: ae
				});
			var de = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const ce = {};
			var le = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ce,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							hasNextPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			const ue = {};
			var me = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ue,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							hasPreviousPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			const pe = [];
			var be = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							normalizedModerators: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			var he = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.b: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				fe = Object(s.c)({
					actions: ie,
					endCursor: de,
					hasNextPage: le,
					hasPreviousPage: me,
					moderators: be,
					startCursor: he
				});
			const ge = {};
			var _e = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.O:
					case r.y: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload.response || t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.C: {
						const {
							subredditId: n,
							userId: s,
							permissions: r
						} = t.payload;
						return Object(b.setIn)(e, [n, s, "modPermissions"], r)
					}
					case r.jb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			const ve = {};
			var Oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ve,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.z:
					case r.y: {
						const {
							key: n,
							subredditId: s
						} = t.payload;
						return s ? {
							...e,
							[n]: null
						} : e
					}
					case r.x: {
						const {
							error: n,
							key: s,
							subredditId: r
						} = t.payload;
						return r ? {
							...e,
							[s]: n
						} : e
					}
					default:
						return e
				}
			};
			const xe = {};
			var Ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.x:
						case r.y: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.z: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				ye = Object(s.c)({
					error: Oe,
					pending: Ee
				});
			const je = {};
			var Ce = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : je,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.y: {
							const {
								subredditId: n,
								response: s,
								key: r
							} = t.payload;
							return Object(b.setIn)(e, [n, r], s.moderatorIds)
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s,
								key: r
							} = t.payload, o = e[n][r].filter(e => e !== s);
							return Object(b.setIn)(e, [n, r], o)
						}
						default:
							return e
					}
				},
				ke = Object(s.c)({
					data: Ce,
					api: ye
				});
			var Ie = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.F:
					case r.E:
						return null;
					case r.D:
						return t.payload;
					default:
						return e
				}
			};
			var Se = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E:
						case r.D:
							return !1;
						case r.F:
							return !0;
						default:
							return e
					}
				},
				we = Object(s.c)({
					error: Ie,
					pending: Se
				});
			const Te = {};
			var Ne = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Te,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.E: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload;
						return Object(b.set)(e, n, s)
					}
					case r.gb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					case r.c: {
						const n = t.payload,
							{
								subredditId: s,
								moderators: r
							} = n,
							o = {
								[s]: r
							};
						return Object(b.merge)(e, o)
					}
					default:
						return e
				}
			};
			const Pe = {};
			var Re = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E: {
							const {
								subredditId: n,
								moderatorIds: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case r.gb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = e[n].filter(e => e !== s);
							return {
								...e,
								[n]: r
							}
						}
						case r.c: {
							const n = t.payload,
								{
									subredditId: s,
									moderatorIds: r
								} = n,
								o = [...e[s] || [], ...r];
							return {
								...e,
								[s]: o
							}
						}
						default:
							return e
					}
				},
				Ae = Object(s.c)({
					api: we,
					models: Ne,
					userOrder: Re
				});
			const Me = {};
			var De = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							invitePending: r
						} = s, o = {
							[n]: r
						};
						return Object(b.merge)(e, o)
					}
					case r.I:
					case r.J: {
						const {
							subredditId: n
						} = t.payload;
						return Object(b.unset)(e, n)
					}
					default:
						return e
				}
			};
			const Le = {};
			var Fe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.y: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Ue = {};
			var Be = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ue,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Ge = {};
			var He = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: n
						} = t.payload, s = {
							[n.subredditId]: n.moderators
						};
						return Object(b.merge)({
							...e
						}, s)
					}
					case r.C: {
						const n = t.payload,
							{
								subredditId: s,
								userId: r,
								permissions: o
							} = n;
						return e[s] && e[s][r] ? Object(b.setIn)(e, [s, r, "modPermissions"], o) : e
					}
					default:
						return e
				}
			};
			var We = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.P:
					case r.O:
						return null;
					case r.N:
						return t.payload;
					default:
						return e
				}
			};
			var qe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
							return !0;
						case r.O:
						case r.N:
							return !1;
						default:
							return e
					}
				},
				Ve = Object(s.c)({
					error: We,
					pending: qe
				}),
				ze = n("./node_modules/lodash/isEqual.js"),
				Ke = n.n(ze);
			var Qe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
						case r.N:
						case r.jb:
							return null;
						case r.O: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case r.C: {
							const {
								userId: n,
								permissions: s
							} = t.payload;
							return e && e.id === n && !Ke()(e.modPermissions, s) ? {
								...e,
								modPermissions: s
							} : e
						}
						default:
							return e
					}
				},
				Je = Object(s.c)({
					api: Ve,
					result: Qe
				});
			const Ye = {};
			var Xe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ye,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.M:
					case r.L: {
						const {
							subredditId: n,
							key: s
						} = t.payload;
						return n ? {
							...e,
							[s]: null
						} : e
					}
					case r.K: {
						const {
							error: n,
							subredditId: s,
							key: r
						} = t.payload;
						return s ? {
							...e,
							[r]: n
						} : e
					}
					default:
						return e
				}
			};
			const Ze = {};
			var $e = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ze,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.K:
						case r.L: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.M: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				et = Object(s.c)({
					error: Xe,
					pending: $e
				});
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const tt = {};
			var nt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.L: {
							const {
								response: n,
								subredditId: s,
								key: r
							} = t.payload, {
								moderatorIds: o
							} = n;
							return Object(b.merge)(e, {
								[s]: {
									[r]: o
								}
							})
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								...e[n]
							};
							return Object.keys(e[n]).forEach(t => {
								const o = e[n][t].filter(e => e !== s);
								r[t] = o
							}), Object(b.set)(e, n, r)
						}
						default:
							return e
					}
				},
				st = Object(s.c)({
					data: nt,
					api: et
				}),
				rt = Object(s.c)({
					editableModerators: _e,
					editableUserOrder: ke,
					invitedModerators: Ae,
					invitePending: De,
					loadMoreModerators: Be,
					loadMoreEditableModerators: Fe,
					models: He,
					search: Je,
					userOrder: st
				}),
				ot = n("./src/reddit/actions/bulkActions/constants.ts");
			var at = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ot.c:
						case ot.b:
							return null;
						case ot.a:
							return t.payload;
						default:
							return e
					}
				},
				it = n("./src/reddit/actions/modQueue/constants.ts");
			var dt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ot.c:
							return !0;
						case ot.b:
						case ot.a:
						case it.s:
						case it.r:
							return !1;
						default:
							return e
					}
				},
				ct = Object(s.c)({
					error: at,
					pending: dt
				});
			const lt = {};
			var ut = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.a: {
							const {
								ids: n
							} = t.payload, s = {};
							return n.forEach(e => s[e] = !0), {
								...e,
								...s
							}
						}
						case it.d: {
							const {
								ids: n
							} = t.payload;
							return W()(e, n)
						}
						case it.c: {
							const {
								ids: e
							} = t.payload, n = {};
							return e.forEach(e => n[e] = !0), n
						}
						default:
							return e
					}
				},
				mt = n("./src/reddit/models/ModQueue/index.ts");
			const pt = {};
			var bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ot.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? pt : {
								[mt.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				ht = Object(s.c)({
					api: ct,
					selectedItems: ut,
					undoLastAction: bt
				});
			var ft = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.g:
					case it.f:
						return null;
					case it.e:
						return t.payload;
					default:
						return e
				}
			};
			var gt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.g:
							return !0;
						case it.f:
						case it.e:
							return !1;
						default:
							return e
					}
				},
				_t = Object(s.c)({
					error: ft,
					pending: gt
				});
			const vt = {};
			var Ot = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.f: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const xt = {};
			var Et = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.f: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				yt = Object(s.c)({
					api: _t,
					itemOrder: Ot,
					loadMore: Et
				}),
				jt = n("./src/reddit/actions/pages/modListing/constants.ts");
			var Ct = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case jt.e: {
						const n = t.payload,
							{
								moderatingSubreddits: s
							} = n;
						return s ? null : e
					}
					case it.i:
					case it.f:
					case it.m:
					case it.p:
					case it.v: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case it.k: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const kt = [];
			var It = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : kt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.i:
					case it.f:
					case it.m:
					case it.p:
					case it.v: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case it.k: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return [...e, ...s]
					}
					case jt.e: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return s || e
					}
					default:
						return e
				}
			};
			var St = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.b:
						return !0;
					default:
						return e
				}
			};
			var wt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.k:
							return !0;
						case it.b:
							return !1;
						default:
							return e
					}
				},
				Tt = Object(s.c)({
					after: Ct,
					data: It,
					loaded: St,
					pending: wt
				});
			var Nt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.j:
					case it.i:
						return null;
					case it.h:
						return t.payload;
					default:
						return e
				}
			};
			var Pt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.j:
							return !0;
						case it.i:
						case it.h:
							return !1;
						default:
							return e
					}
				},
				Rt = Object(s.c)({
					error: Nt,
					pending: Pt
				});
			const At = {};
			var Mt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : At,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.i: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Dt = {};
			var Lt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.i: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				Ft = Object(s.c)({
					api: Rt,
					itemOrder: Mt,
					loadMore: Lt
				});
			var Ut = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.n:
					case it.m:
						return null;
					case it.l:
						return t.payload;
					default:
						return e
				}
			};
			var Bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.n:
							return !0;
						case it.m:
						case it.l:
							return !1;
						default:
							return e
					}
				},
				Gt = Object(s.c)({
					error: Ut,
					pending: Bt
				});
			const Ht = {};
			var Wt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ht,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.m: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const qt = {};
			var Vt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.m: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				zt = Object(s.c)({
					api: Gt,
					itemOrder: Wt,
					loadMore: Vt
				});
			var Kt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.q:
					case it.p:
						return null;
					case it.o:
						return t.payload;
					default:
						return e
				}
			};
			var Qt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.q:
							return !0;
						case it.p:
						case it.o:
							return !1;
						default:
							return e
					}
				},
				Jt = Object(s.c)({
					error: Kt,
					pending: Qt
				});
			const Yt = {};
			var Xt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Yt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.p: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Zt = {};
			var $t = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.p: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				en = Object(s.c)({
					api: Jt,
					itemOrder: Xt,
					loadMore: $t
				});
			var tn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.w:
					case it.v:
						return null;
					case it.u:
						return t.payload;
					default:
						return e
				}
			};
			var nn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.w:
							return !0;
						case it.v:
						case it.u:
							return !1;
						default:
							return e
					}
				},
				sn = Object(s.c)({
					error: tn,
					pending: nn
				});
			const rn = {};
			var on = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case it.v: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const an = {};
			var dn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : an,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case it.v: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				cn = Object(s.c)({
					api: sn,
					itemOrder: on,
					loadMore: dn
				}),
				ln = Object(s.c)({
					bulkAction: ht,
					edited: yt,
					moderatedCommunitiesOrder: Tt,
					modqueue: Ft,
					reports: zt,
					spam: en,
					unmoderated: cn
				});
			var un = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Y:
					case r.W:
						return null;
					case r.V:
						return t.payload;
					default:
						return e
				}
			};
			const mn = {};
			var pn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : mn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Y: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.W:
						case r.V: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(a.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				bn = Object(s.c)({
					error: un,
					pending: pn
				});
			const hn = {};
			var fn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(a.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				gn = n("./src/reddit/actions/inContextModeration.ts");
			var _n = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case gn.b:
						return t.payload;
					default:
						return e
				}
			};
			const vn = {};
			var On = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.W: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const xn = {};
			var En = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.X:
					case r.W: {
						const {
							subredditId: n,
							mutedUsers: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.cb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var yn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.bb:
					case r.ab:
						return null;
					case r.Z:
						return t.payload;
					default:
						return e
				}
			};
			var jn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
							return !0;
						case r.ab:
						case r.Z:
							return !1;
						default:
							return e
					}
				},
				Cn = Object(s.c)({
					error: yn,
					pending: jn
				});
			var kn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
						case r.Z:
							return null;
						case r.ab: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				In = Object(s.c)({
					api: Cn,
					result: kn
				});
			const Sn = {};
			var wn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.cb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.X: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Tn = Object(s.c)({
					api: bn,
					fetchedTokens: fn,
					inContext: _n,
					loadMore: On,
					models: En,
					search: In,
					userOrder: wn
				});
			t.a = Object(s.c)({
				approvedSubmitters: j,
				approvedTalkHosts: M,
				flairedUsers: te,
				moderationLog: fe,
				moderators: rt,
				modQueue: ln,
				muted: Tn
			})
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/uniqWith.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/values.js"),
				i = n.n(a),
				d = n("./src/reddit/actions/tags/constants.ts"),
				c = n("./src/reddit/models/Option/index.ts"),
				l = n("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(s || (s = {}));
			const u = {
				selectedPrimaryTagId: {},
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.w:
					case d.r: {
						const {
							subredditId: n,
							itemTags: s,
							suggestedItemTags: r,
							primaryTag: a
						} = t.payload, d = o()([...(e.selectedOptions[n] || []).map(e => {
							if (!e.id) {
								const t = i()(s[n] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return {
									...Object(l.e)(t, !0),
									action: null
								}
							}
							return e
						}), ...i()(s[n] || {}).map(e => ({
							...Object(l.e)(e, !0),
							action: null
						}))], c.a);
						let u = e.selectedPrimaryTagId;
						return a && (u = {
							...u,
							[n]: a.tag.id
						}), {
							...e,
							selectedOptions: {
								...e.selectedOptions,
								[n]: d.map(e => ({
									...e,
									action: e.id ? null : e.action
								}))
							},
							selectedSuggestedOptions: {
								...e.selectedSuggestedOptions,
								[n]: i()(r[n] || {}).map(e => ({
									...Object(l.e)(e, !0),
									action: null
								}))
							},
							deselectedOptions: {
								...e.deselectedOptions,
								[n]: []
							},
							selectedPrimaryTagId: u
						}
					}
					case d.D:
					case d.z: {
						const {
							subredditId: n,
							option: r
						} = t.payload, a = t.type === d.z ? "selectedOptions" : "selectedSuggestedOptions", i = t.type === d.z ? "deselectedOptions" : "deselectedSuggestedOptions", l = (e[i][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						let m = s.ADD;
						return u > -1 && (m = null, l.splice(u, 1)), {
							...e,
							[a]: {
								...e[a],
								[n]: o()([...e[a][n] || [], {
									...r,
									action: m
								}], c.a)
							},
							[i]: {
								...e[i],
								[n]: l
							}
						}
					}
					case d.C:
					case d.y: {
						const {
							subredditId: n,
							option: r
						} = t.payload, o = t.type === d.y ? "selectedOptions" : "selectedSuggestedOptions", a = t.type === d.y ? "deselectedOptions" : "deselectedSuggestedOptions", i = (e[a][n] || []).slice(), l = (e[o][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						return u > -1 && (null === l[u].action && i.push({
							...l[u],
							action: s.REMOVE
						}), l.splice(u, 1)), {
							...e,
							[o]: {
								...e[o],
								[n]: l
							},
							[a]: {
								...e[a],
								[n]: i
							}
						}
					}
					case d.A: {
						const {
							itemTagsState: n
						} = t.payload, s = Object.keys(n);
						if (!s.length) return e;
						const r = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							o = s.reduce((e, t) => (e.selectedOptions[t] = i()(n[t]).map(e => ({
								...Object(l.e)(e, !0),
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), r);
						return {
							...e,
							inputByItemId: {
								...e.inputByItemId,
								...o.inputByItemId
							},
							selectedOptions: {
								...e.selectedOptions,
								...o.selectedOptions
							},
							deselectedOptions: {
								...e.deselectedOptions,
								...o.deselectedOptions
							}
						}
					}
					case d.B:
					case d.x: {
						const {
							subredditId: n,
							input: s
						} = t.payload, r = t.type === d.x ? "inputByItemId" : "suggestedInputByItemId";
						return {
							...e,
							[r]: {
								...e[r],
								[n]: s
							}
						}
					}
					case d.i:
					case d.h: {
						const {
							subredditId: n,
							primaryTagId: s
						} = t.payload;
						if (!s || !n) return e;
						const r = {
								...e,
								selectedPrimaryTagId: {
									...e.selectedPrimaryTagId,
									[n]: s
								}
							},
							o = e.selectedOptions[n];
						if (o) {
							const t = o.findIndex(e => e.id === s),
								a = [...o];
							return t >= 0 && a.splice(t, 1), {
								...r,
								selectedOptions: {
									...e.selectedOptions,
									[n]: a
								}
							}
						}
						return r
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return H
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/isEqual.js"),
				o = n.n(r),
				a = n("./node_modules/lodash/merge.js"),
				i = n.n(a),
				d = n("./node_modules/lodash/pick.js"),
				c = n.n(d),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/comment/constants.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/frontpage/constants.ts"),
				b = n("./src/reddit/actions/header.ts"),
				h = n("./src/reddit/actions/modQueue/constants.ts"),
				f = n("./src/reddit/actions/pages/constants.ts"),
				g = n("./src/reddit/actions/pages/modListing/constants.ts"),
				_ = n("./src/reddit/actions/pages/multireddit/constants.ts"),
				v = n("./src/reddit/actions/pages/postCreation.ts"),
				O = n("./src/reddit/actions/pages/postDraft.ts"),
				x = n("./src/reddit/actions/pages/profileComments/constants.ts"),
				E = n("./src/reddit/actions/pages/profileOverview/constants.ts"),
				y = n("./src/reddit/actions/pages/profilePosts.ts"),
				j = n("./src/reddit/actions/pages/search/index.ts"),
				C = n("./src/reddit/actions/pages/subreddit.ts"),
				k = n("./src/reddit/actions/pages/topic.ts"),
				I = n("./src/reddit/actions/postCreation/constants.ts"),
				S = n("./src/reddit/actions/postDraft.ts"),
				w = n("./src/reddit/actions/preferences.ts"),
				T = n("./src/reddit/actions/redditEmbed.ts"),
				N = n("./src/reddit/actions/search.ts"),
				P = n("./src/reddit/actions/structuredStyles/constants.ts"),
				R = n("./src/reddit/actions/subreddit.ts"),
				A = n("./src/reddit/actions/users.ts"),
				M = n("./src/reddit/constants/postLayout.ts"),
				D = n("./src/reddit/constants/preferences.ts"),
				L = n("./src/reddit/constants/theme.ts"),
				F = n("./src/reddit/models/PostCreationForm/index.ts"),
				U = n("./src/reddit/models/PostDraft/index.ts"),
				B = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(s || (s = {}));
			const G = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "enableFollowers", "feedRecommendationsEnabled", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", "showPresence", ...D.a, "loginOtpEnabled"],
				H = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: B.a,
					commentMode: F.i.RICH_TEXT,
					countryCode: "",
					badCommentAutocollapse: l.l.OFF,
					layout: M.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: l.t.CONFIDENCE,
					editorMode: F.i.RICH_TEXT,
					enableFollowers: !0,
					geopopular: void 0,
					globalTheme: L.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					reduceAnimationsFromAwards: !1,
					rpanDuDismissalTime: void 0,
					showActiveCommunities: !0,
					showPresence: !1,
					showRpanDu: !0,
					showTwitter: !1,
					sort: l.Y.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					surveyLastSeenTime: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartyPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					showLocationBasedRecommendations: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1,
					gatedSubredditOptIn: !1,
					quarantineOptIn: !1
				},
				W = {
					rpanDuDismissalTime: void 0,
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				q = (e, t) => {
					if (!t) return e;
					const n = c()({
							...t.account,
							...t
						}, G),
						s = t.subreddit,
						r = {
							...e.subreddit
						};
					Object.keys(s || {}).forEach(e => {
						r[e] = {
							...W,
							...s && s[e]
						}
					});
					const a = {
						...e,
						...n,
						subreddit: r
					};
					if (a.useMarkdown !== e.useMarkdown) {
						const e = a.useMarkdown ? F.i.MARKDOWN : F.i.RICH_TEXT;
						a.editorMode = e, a.commentMode = e
					}
					return o()(a, e) ? e : a
				},
				V = (e, t, n) => q(e, {
					subreddit: {
						[t]: {
							...W,
							...e.subreddit[t],
							...n
						}
					}
				});
			t.c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : H,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case u.o:
					case u.v: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							commentMode: n
						}
					}
					case I.s:
					case I.Q: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							editorMode: n
						}
					}
					case b.d:
						return {
							...e, subscriptionsPinned: !0
						};
					case b.e:
						return {
							...e, subscriptionsPinned: !1
						};
					case S.g: {
						const {
							kind: n
						} = t.payload;
						return {
							...e,
							editorMode: n === U.b.Markdown ? F.i.MARKDOWN : F.i.RICH_TEXT
						}
					}
					case w.h: {
						const {
							layout: n
						} = t.payload;
						return e.layout === n ? e : {
							...e,
							layout: n
						}
					}
					case w.o:
						return void 0 !== t.payload ? {
							...e,
							rpanDuDismissalTime: t.payload
						} : e;
					case w.p: {
						const {
							layout: n,
							subredditId: s
						} = t.payload;
						return V(e, s, {
							layout: n
						})
					}
					case w.f:
						return {
							...e, hasSeenCustomizeFlyout: !0
						};
					case w.m:
						return e.profileLayout === t.payload.profileLayout ? e : {
							...e,
							profileLayout: t.payload.profileLayout
						};
					case m.i:
						return {
							...e, over18: !0
						};
					case w.c:
						return void 0 !== t.payload ? {
							...e,
							autoplayVideo: t.payload.autoplayVideo
						} : e;
					case w.i:
						return void 0 !== t.payload ? {
							...e,
							nightmode: t.payload.nightmode
						} : e;
					case m.h:
						return {
							...e, gatedSubredditOptIn: t.payload
						};
					case m.j:
						return {
							...e, quarantineOptIn: t.payload
						};
					case w.r:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							} = t.payload;
							return {
								...e,
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							}
						}
						return e;
					case P.d:
						return t.payload.isNightmodeOn ? {
							...e,
							nightmode: !1,
							nightmodeTempUpdated: !0
						} : e;
					case P.e:
						return t.payload.nightmodeTempUpdated ? {
							...e,
							nightmode: !0,
							nightmodeTempUpdated: !1
						} : e;
					case w.g:
						return void 0 !== t.payload ? {
							...e,
							hamburgerTray: t.payload.set
						} : {
							...e,
							hamburgerTray: !e.hamburgerTray
						};
					case w.d:
						return void 0 !== t.payload ? {
							...e,
							collapsedTraySections: i()({}, e.collapsedTraySections, t.payload)
						} : e;
					case m.b:
					case m.c:
					case m.k:
					case m.l:
					case m.g:
					case m.a:
					case m.m:
					case g.e:
					case g.h:
					case f.a:
					case f.e:
					case f.b:
					case f.f:
					case f.d:
					case f.h:
					case p.b:
					case C.SUBREDDIT_LOADED:
					case _.b:
					case _.a:
					case x.e:
					case E.e:
					case E.b:
					case y.PROFILE_POSTS_LOADED:
					case p.f:
					case R.i:
					case N.e:
					case T.b:
					case v.PAGE_LOADED:
					case O.PAGE_LOADED:
					case w.j:
					case w.b:
					case j.c:
					case w.a:
					case A.c:
					case k.TOPIC_DATA_LOADED:
						return t.payload && t.payload.preferences ? q(e, t.payload.preferences) : e;
					case w.q: {
						const {
							subredditId: n,
							prefs: s
						} = t.payload;
						return V(e, n, s)
					}
					case x.d:
					case E.d:
					case E.a:
					case y.PROFILE_POSTS_FAILED: {
						let n = e;
						if (t.payload && t.payload.account) {
							const {
								nightmode: s,
								showPresence: r
							} = t.payload.account;
							e.nightmode !== s && (n = {
								...n,
								nightmode: s
							}), e.showPresence !== r && (n = {
								...n,
								showPresence: r
							})
						}
						return n
					}
					case h.h:
					case h.j:
					case h.i:
					case h.g:
					case h.f:
					case h.n:
					case h.m:
					case h.p:
					case h.q:
					case h.w:
					case h.v:
						return t.payload && t.payload.response && t.payload.response.preferences ? q(e, t.payload.preferences) : e;
					case w.n: {
						const n = t.payload,
							{
								enableFollowers: s,
								showActiveCommunities: r
							} = n.additional;
						let o = e;
						return e.enableFollowers !== s && (o = {
							...o,
							enableFollowers: s
						}), e.showActiveCommunities !== r && (o = {
							...o,
							showActiveCommunities: r
						}), o
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/loadableAction/index.ts"),
				a = n("./src/reddit/routes/postCreation/constants.ts");
			const i = [a.b, a.c, a.a],
				d = Object(s.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Mem~c8b748a6"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("CollectionCommentsPage~CommentsPage~ModerationPages~PostCreation~ProfileComments~ProfileOverview~Pro~d39c0d57"), n.e("PostCreation~Reddit~StandalonePostPage~reddit-components-ClassicPost~reddit-components-CompactPost~r~4c415e24"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				c = e => `/${e}/submit`,
				l = (e, t) => {
					return a.c.replace(/:subredditName/, e) + (t ? `?collection=${t}` : "")
				},
				u = e => a.a.replace(/:profileName/, e),
				m = {
					action: Object(o.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Mem~c8b748a6"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("CollectionCommentsPage~CommentsPage~ModerationPages~PostCreation~ProfileComments~ProfileOverview~Pro~d39c0d57"), n.e("PostCreation~Reddit~StandalonePostPage~reddit-components-ClassicPost~reddit-components-CompactPost~r~4c415e24"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/actions/pages/postCreation.ts")).then(e => e.postCreationPageRequested)),
					component: d,
					chunk: r.r.POST_CREATION,
					exact: !0,
					meta: {
						name: r.Nb.POST_CREATION
					},
					path: i,
					prefetches: [r.r.COMMENTS_PAGE]
				};
			t.a = m
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "m", (function() {
				return b
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "j", (function() {
				return y
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/objectSelector/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				a = n("./src/reddit/helpers/publicAccessNetwork/index.ts");
			const i = e => e.publicAccessNetwork.api.config,
				d = (e, t) => !!t && !!e.publicAccessNetwork.api.error[Object(a.g)(t)],
				c = e => d(e, o.b),
				l = (e, t) => !!t && !!e.publicAccessNetwork.api.pending[Object(a.g)(t)] && e.publicAccessNetwork.api.pending[Object(a.g)(t)].isPending,
				u = e => l(e, o.b),
				m = e => e.publicAccessNetwork.api.pending[o.b] && e.publicAccessNetwork.api.pending[o.b].fetchedUtcTimeStamp,
				p = Object(s.a)(i, e => e.global),
				b = Object(s.a)((e, t) => {
					let {
						subreddit: n
					} = t;
					return n
				}, i, (e, t) => {
					const n = e.toLowerCase();
					return t.subreddits[n]
				}),
				h = Object(s.a)(i, e => e.global.rpan_intro_video_url),
				f = Object(s.a)(i, e => e.global.url_to_show_for_unavailable_video),
				g = Object(s.a)(i, e => !1),
				_ = Object(s.a)(i, e => e.isError),
				v = Object(s.a)(i, e => e.global.max_chat_comment_length),
				O = e => e.publicAccessNetwork.api.recommendedViewerSubreddits,
				x = (Object(s.a)(O, e => e.isError), Object(s.a)(O, e => e.isPending)),
				E = Object(r.a)(Object(s.a)(O, e => e.subreddits)),
				y = Object(s.a)(E, e => [{
					name: "All",
					prefixedName: "All",
					path: Object(a.e)()
				}, ...e.map(e => ({
					name: e,
					prefixedName: `r/${e}`,
					path: Object(a.f)(e)
				}))])
		},
		"./src/reddit/selectors/appBadges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js");
			const r = e => e.appBadges.badges,
				o = Object(s.a)(r, e => {
					var t;
					return (null === (t = e.chatUnreadMessages) || void 0 === t ? void 0 : t.count) || 0
				}),
				a = Object(s.a)(r, e => e && e.chatRooms && e.chatRooms.count || 0),
				i = Object(s.a)(r, e => e && e.chatRoomMentions && e.chatRoomMentions.count || 0),
				d = Object(s.a)(o, r, (e, t) => {
					var n;
					return 0 === e && !!(null === (n = t.chatHasNewMessages) || void 0 === n ? void 0 : n.isShowing)
				}),
				c = Object(s.a)(r, e => e && e.activityTab && e.activityTab.count || 0),
				l = Object(s.a)(r, e => e && e.messageTab && e.messageTab.count || 0),
				u = Object(s.a)(c, l, (e, t) => e + t),
				m = Object(s.a)(o, u, (e, t) => e + t)
		},
		"./src/reddit/selectors/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						post: n
					} = t;
					const s = n.belongsTo.id;
					if (!s) return null;
					const r = e.authorFlair.models[s];
					if (!r) return null;
					const o = n.author;
					return o && r[o] || null
				},
				r = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.authorFlair && e.authorFlair.inContext && e.authorFlair.inContext.username;
					if (!s) return null;
					if (!n) return null;
					const r = e.authorFlair.models[n];
					return r ? r[s] : null
				},
				o = e => e.authorFlair.inContext
		},
		"./src/reddit/selectors/avatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const o = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser
				},
				a = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser.csrf_token
				},
				i = e => {
					var t, n;
					return (null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.randomAvatar) || null
				}
		},
		"./src/reddit/selectors/avatarMarketing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts"),
				o = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const a = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing)
				},
				i = e => {
					var t, n, s, r;
					const a = null === (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing) || void 0 === s ? void 0 : s.marketingEvent;
					if (!(null == a ? void 0 : a.active) || !(null === (r = null == a ? void 0 : a.assetUrls) || void 0 === r ? void 0 : r.length)) return null;
					const i = a.assetUrls[0];
					return !a.experimentRequired || Object(o.a)(a.experimentRequired)(e) ? i : null
				}
		},
		"./src/reddit/selectors/bannedUser.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/components/InboxTooltip/Component.tsx"),
				o = n("./src/reddit/models/SubredditModeration/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.models[n]
				},
				d = (e, t) => {
					let {
						subredditId: n,
						username: s
					} = t;
					const r = Object(a.Ab)(e, {
						userName: s
					});
					if (!r) return;
					const o = i(e, {
						subredditId: n
					});
					return o ? o[r.id] : void 0
				},
				c = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.features.banned.userOrder[n];
					return s ? s.map(t => e.features.banned.models[n][t]) : r.a
				}),
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(o.e)(n);
					return e.features.banned.api.pending[s]
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.loadMore[n]
				},
				m = e => e.features.banned.search.api.pending,
				p = e => e.features.banned.search.result,
				b = e => e.features.banned.inContext
		},
		"./src/reddit/selectors/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts");
			Object(s.a)(e => e.chat.unread.count, e => e.unreadMessages);
			const a = e => !(e.chat.isInited || e.chat.unread.api.pending),
				i = (e, t) => {
					const {
						chatConfig: n
					} = r.c;
					return Object(o.b)(n)(e, t)
				}
		},
		"./src/reddit/selectors/chatSettingsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/models/ChatSettingsPage/index.ts");
			const r = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.chat.subredditSettingsPage.api.fetch.pending[n]
				},
				o = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.chat.subredditSettingsPage.models[n] || []).filter(e => e && e.settingType !== s.a.Unknown)
				}
		},
		"./src/reddit/selectors/comments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "u", (function() {
				return O
			})), n.d(t, "w", (function() {
				return x
			})), n.d(t, "x", (function() {
				return E
			})), n.d(t, "k", (function() {
				return j
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "I", (function() {
				return k
			})), n.d(t, "n", (function() {
				return I
			})), n.d(t, "o", (function() {
				return S
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "l", (function() {
				return T
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "a", (function() {
				return P
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "q", (function() {
				return A
			})), n.d(t, "m", (function() {
				return M
			})), n.d(t, "t", (function() {
				return D
			})), n.d(t, "z", (function() {
				return L
			})), n.d(t, "K", (function() {
				return F
			})), n.d(t, "s", (function() {
				return U
			})), n.d(t, "E", (function() {
				return B
			})), n.d(t, "F", (function() {
				return G
			})), n.d(t, "G", (function() {
				return H
			})), n.d(t, "r", (function() {
				return W
			})), n.d(t, "e", (function() {
				return q
			})), n.d(t, "M", (function() {
				return V
			})), n.d(t, "v", (function() {
				return z
			})), n.d(t, "L", (function() {
				return K
			})), n.d(t, "f", (function() {
				return Q
			})), n.d(t, "i", (function() {
				return J
			})), n.d(t, "H", (function() {
				return Y
			})), n.d(t, "D", (function() {
				return X
			})), n.d(t, "J", (function() {
				return Z
			})), n.d(t, "p", (function() {
				return $
			})), n.d(t, "N", (function() {
				return ee
			})), n.d(t, "y", (function() {
				return te
			})), n.d(t, "A", (function() {
				return ne
			})), n.d(t, "C", (function() {
				return se
			})), n.d(t, "B", (function() {
				return re
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/objectSelector/index.ts"),
				i = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/constants/comments.ts"),
				c = n("./src/reddit/models/Comment/index.ts"),
				l = n("./src/reddit/models/Post/index.ts"),
				u = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/commentSelector.ts"),
				b = n("./src/lib/initializeClient/installReducer.ts"),
				h = n("./src/reddit/reducers/features/comments/index.ts"),
				f = n("./src/reddit/reducers/pages/comments/index.ts"),
				g = n("./src/redditGQL/types.ts");
			Object(b.a)({
				features: {
					comments: h.a
				},
				pages: {
					comments: f.a
				}
			});
			const _ = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.error[n]
				},
				v = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.pending[n]
				},
				O = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.fullyLoaded[n]
				},
				x = (e, t) => e.pages.comments.keyToHeadCommentId[t.commentsPageKey],
				E = (e, t) => {
					const n = x(e, t);
					if (n) return Object(p.b)(e, {
						commentId: n
					})
				},
				y = [],
				j = Object(a.a)((e, t) => {
					const n = E(e, t),
						s = n && n.id;
					if (!s) return y;
					const {
						commentsPageKey: r
					} = t, o = e.pages.comments.keyToCommentThreadLinkSets[r], a = [];
					let i = {
						id: s,
						type: d.a.Comment
					};
					do {
						a.push(i), i = o[i.id].next
					} while (i);
					return a
				}),
				C = (e, t) => x(e, t) ? e.pages.comments.keyToChatCommentLinks[t.commentsPageKey] : [],
				k = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					return s ? e.posts.models[s] : null
				},
				I = (e, t) => {
					let {
						commentId: n,
						commentLink: s,
						commentsPageKey: r
					} = t;
					const o = e.pages.comments.keyToCommentThreadLinkSets[r];
					return o ? s ? o[s.id] : n ? o[n] : null : null
				},
				S = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.keyToCommentThreadLinkSets[n]
				},
				w = (e, t) => {
					const n = t.commentsPageKey ? I(e, t) : null;
					return n ? n.depth : null
				},
				T = (e, t) => {
					let {
						commentLink: n
					} = t;
					const {
						id: s,
						type: r
					} = n;
					switch (r) {
						case d.a.Comment:
							return e.features.comments.models[s];
						case d.a.MoreComments:
							return e.moreComments.models[s];
						case d.a.ContinueThread:
							return e.continueThreads.models[s];
						default:
							return null
					}
				},
				N = (e, t) => {
					if (e.platform.currentPage && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.partialPostId) {
						const {
							partialPostId: t
						} = e.platform.currentPage.urlParams, n = Object(l.u)(t);
						return Array.from(new Set(Object.keys(e.features.comments.models).filter(t => e.features.comments.models[t].postId === n && e.features.comments.models[t].author !== o.E).map(t => e.features.comments.models[t].author)))
					}
					return []
				},
				P = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.features.comments.collapsed[n]
				},
				R = e => e.moreComments.models,
				A = e => e.features.comments.models,
				M = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = Object(p.b)(e, {
						commentId: n
					});
					return s ? Object(p.a)(e, s) : ""
				},
				D = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!(n && e.features.comments.focused && e.features.comments.focused[n])
				},
				L = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.isEditing[s] && e.features.comments.isEditing[s][n])
				},
				F = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.replyFormOpen[s] && e.features.comments.replyFormOpen[s][n])
				},
				U = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = n && e.features.comments.replyFormOpen[n] || {},
						r = Object.keys(s).find(e => s[e]),
						o = r && Object(p.b)(e, {
							commentId: r
						}),
						a = o && w(e, {
							commentId: o.id,
							commentLink: void 0,
							commentsPageKey: n
						});
					if (o && "number" == typeof a) return {
						...o,
						depth: a
					}
				},
				B = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return e.moreComments.models[n]
				},
				G = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return !!e.moreComments.api.pending[n]
				},
				H = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					if (s) {
						const t = r()(e.moreComments.models).find(t => t.postId === s && 0 === t.depth && !(void 0 !== e.moreComments.api.pending[t.id]));
						if (t) return {
							moreCommentId: t.id,
							pending: !!e.moreComments.api.pending[t.id]
						}
					}
					return null
				},
				W = (e, t) => {
					let {
						id: n
					} = t;
					return e.continueThreads.models[n]
				},
				q = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.models[n] : void 0;
					if (!s) return null;
					const r = e.authorFlair.models[s.subredditId];
					return r ? r[s.author] : null
				},
				V = (e, t) => {
					let {
						draftKey: n
					} = t;
					var s, r, o;
					return (null === (o = null === (r = null === (s = e.features.comments.submit) || void 0 === s ? void 0 : s.error) || void 0 === r ? void 0 : r[n]) || void 0 === o ? void 0 : o.type) || null
				},
				z = (e, t) => {
					let {
						draftKey: n
					} = t;
					return !!e.features.comments.submit.error[n]
				},
				K = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.submit.error[n];
					return s && s.fields ? s.fields.map(e => e.msg) : []
				},
				Q = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.drafts[n];
					return !!s && s.autofocusDisabled
				},
				J = (e, t) => {
					let {
						draftKey: n
					} = t;
					return e.features.comments.drafts[n]
				},
				Y = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.submit.error[n] : void 0;
					return s && s.fields ? s.fields.map(e => e.msg) : void 0
				},
				X = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.submit.pending[n]
				},
				Z = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.models[n].sendReplies
				},
				$ = e => e.features.comments.visitHighlightFilter,
				ee = (e, t) => {
					const n = Object(p.b)(e, t);
					if (n) return Object(m.Z)(e, n)
				},
				te = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					return !!((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n)
				},
				ne = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					const o = ((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n);
					return !!(o && o.expiresAt < Date.now())
				},
				se = (e, t) => {
					let {
						commentId: n
					} = t, s = Object(p.b)(e, {
						commentId: n
					});
					for (; s && s.parentId;) {
						if (Object(c.g)(s)) return !0;
						if ((s = Object(p.b)(e, {
								commentId: s.parentId
							})) && Object(c.g)(s)) return !0
					}
					return !1
				},
				re = Object(i.a)(u.a, m.v, (e, t) => {
					var n;
					return e && (null === (n = null == t ? void 0 : t.allowedMediaInComments) || void 0 === n ? void 0 : n.includes(g.d.Giphy)) || !1
				})
		},
		"./src/reddit/selectors/creatorStats.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/creatorStats/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/selectors/posts.ts"),
				i = n("./src/reddit/selectors/user.ts");
			Object(s.a)({
				features: {
					creatorStats: r.a
				}
			});
			const d = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postOtherDiscussions[t]
				},
				c = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postStats[t]
				},
				l = (e, t) => {
					var n, s, r;
					const o = null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.subredditKarma[t]) || void 0 === r ? void 0 : r.karma;
					if (!o) return;
					const {
						fromComments: a,
						fromPosts: i
					} = o;
					return {
						fromComments: a,
						fromPosts: i
					}
				},
				u = (e, t, n) => {
					const s = Object(a.G)(e, {
						postId: t
					});
					if (!s || s.isSponsored || s.removedByCategory) return !1;
					const r = Object(a.V)(e, {
						postId: t
					});
					if (r && r.isQuarantined) return !1;
					const d = !n && !!Object(o.m)(e, {
						postId: t
					});
					return Object(i.Db)(e, {
						postId: t
					}) || d
				}
		},
		"./src/reddit/selectors/crypto/points.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/contexts/PageLayer/index.tsx"),
				o = n("./src/reddit/endpoints/governance/crypto.ts"),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/features/crypto/index.ts");
			Object(a.a)({
				features: {
					crypto: i.a
				}
			});
			const d = (e, t) => {
				var n, s, r;
				return t ? null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.crypto) || void 0 === s ? void 0 : s.points) || void 0 === r ? void 0 : r[t] : void 0
			};

			function c() {
				const e = Object(r.fb)(),
					t = Object(s.e)(t => Object(r.r)(t, {
						pageLayer: e
					})),
					n = Object(s.e)(e => d(e, null == t ? void 0 : t.id));
				return {
					subreddit: t,
					pointsDetails: n
				}
			}
			const l = (e, t) => {
				var n;
				const s = null === (n = d(e, t)) || void 0 === n ? void 0 : n.blockchainProvider;
				return s === o.a.Ethereum || s === o.a.Rinkeby || s === o.a.EthTraderEthereum || s === o.a.EthTraderRinkeby || s === o.a.ArbitrumRinkeby
			}
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/constants/index.ts"), n("./src/lib/makeListingKey/index.ts"), n("./src/lib/objectSelector/index.ts");
			var s = n("./src/reddit/helpers/name/index.ts"),
				r = n("./src/reddit/models/DiscoveryUnit/index.ts");
			n("./src/reddit/selectors/category.ts"), n("./src/reddit/selectors/listings.ts"), n("./src/reddit/selectors/posts.ts"), n("./src/reddit/selectors/subreddit.ts");
			const o = e => e.discoveryUnits.api.list.loaded,
				a = e => e.discoveryUnits.api.list.pending,
				i = (e, t) => {
					let {
						unitName: n
					} = t;
					const r = e.discoveryUnits.nameToId[Object(s.h)(n)];
					return e.discoveryUnits.models[r]
				},
				d = e => i(e, {
					unitName: r.b
				}),
				c = new Set(["sequence"]),
				l = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: n
						} = t, s = e && e.name || "", r = n && n.subredditName || "", o = "subreddit" === s, a = c.has(r.toLowerCase());
						return o && a
					}
					return !1
				}
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/models/Flair/index.ts"),
				i = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.emojis.models,
				u = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => {
					const n = e[t];
					return n ? [...r()(n.emojis), ...r()(n.snoomojis)] : c
				}),
				m = Object(o.a)(u, i.c, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, n, s) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !n) && (!(!e.userFlairAllowed && s === a.d.UserFlair) && !(!e.postFlairAllowed && s === a.d.LinkFlair)))),
				p = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				b = (e, t) => Object(d.w)(e, {
					subredditName: t
				}).emojisEnabled,
				h = {
					emojis: {},
					snoomojis: {}
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return l(e)[n] || h
				},
				g = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/eventPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeListingKey/index.ts"),
				r = n("./src/reddit/selectors/posts.ts");
			const o = (e, t) => {
					let {
						subredditName: n
					} = t;
					return Object(s.a)("ModhubPage-EventPosts", "timeline", {
						subredditName: n
					})
				},
				a = (e, t) => {
					const n = o(e, t);
					return Object(r.N)(e, {
						listingKey: n
					}) || []
				},
				i = (e, t) => {
					const n = o(e, t);
					return !!e.listings.postOrder.api.pending[n]
				},
				d = (e, t) => {
					const n = o(e, t);
					return !!(e.listings.postOrder.ids[n] || []).length
				},
				c = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return !(!s || !s.hasNextPage)
				},
				l = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return s && s.endCursor || null
				}
		},
		"./src/reddit/selectors/experiments/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			const o = Object(r.a)(s.K),
				a = Object(r.a)(s.I),
				i = Object(r.a)(s.he),
				d = Object(r.a)(s.L),
				c = Object(r.a)(s.N),
				l = Object(r.a)(s.H),
				u = Object(r.a)(s.J),
				m = Object(r.a)(s.M)
		},
		"./src/reddit/selectors/experiments/contributeBeforeSignUp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/experiments/utils.ts");
			const i = ["au", "br", "ca", "de", "fr", "gb", "in", "mx", "us", "row"],
				d = Object(s.a)((e, t) => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: `d2x_start_comment_before_sign_up_${t}`
				}), a.a),
				c = e => i.find(t => !!Object(a.a)(d(e, t))),
				l = Object(s.a)(c, e => !!e),
				u = e => {
					const t = c(e);
					return !!t && d(e, t) === r.fb.SkipOnboarding
				},
				m = e => {
					const t = c(e);
					return !!t && d(e, t) === r.fb.RegOnboarding
				}
		},
		"./src/reddit/selectors/experiments/crosspostRecommendations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return f
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./src/reddit/components/CrosspostRecommendationsModal/constants.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/helpers/isCrosspost.ts"),
				d = n("./src/reddit/models/Media/index.ts"),
				c = n("./src/reddit/selectors/activeModal.ts"),
				l = n("./src/reddit/selectors/experiments/index.ts"),
				u = n("./src/reddit/selectors/posts.ts");
			const m = e => {
					return Object(a.c)(e, {
						experimentEligibilitySelector: l.e,
						experimentName: o.Ce
					}) === o.xd
				},
				p = e => !e.media || e.media.type !== d.o.RTJSON && e.media.type !== d.o.TEXT ? "" : e.media.markdownContent,
				b = e => !e.media && e.source && Object(s.a)(e.source.url) ? e.source.displayText : "",
				h = (e, t) => {
					const n = Object(u.G)(e, {
						postId: t
					});
					return n && !n.isSponsored && n.isCrosspostable && !Object(i.a)(n) && Object(c.c)(r.a)(e)
				},
				f = e => {
					var t;
					return !!(null === (t = e.features) || void 0 === t ? void 0 : t.shouldTryToShowCrosspostModal)
				}
		},
		"./src/reddit/selectors/experiments/econ/marketplace.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
					return !(Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.ce
					}) === s.xd)
				},
				a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.de
				}) === s.xd
		},
		"./src/reddit/selectors/experiments/econ/powerupsAward.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = e => Object(o.c)(e, {
					experimentName: r.ed,
					experimentEligibilitySelector: a.Q
				}),
				d = Object(s.a)(i, e => e === r.Cd.Community || e === r.Cd.Supporter)
		},
		"./src/reddit/selectors/experiments/emailInvite.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				const t = Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.wd
				});
				return !(!t || Object(s.Tf)(t))
			}
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Mb
				}) === s.Fc.Enabled,
				a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Lb
				}) === s.Ec.Enabled
		},
		"./src/reddit/selectors/experiments/hotPotato.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/helpers/matchRedditUrls/index.ts"),
				d = n("./src/reddit/selectors/platform.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const l = () => !0,
				u = Object(s.a)(c.X, c.O, (e, t) => !(e || t)),
				m = e => {
					if (!u(e)) return;
					const t = Object(a.c)(e, {
						experimentEligibilitySelector: l,
						experimentName: o.Qd,
						expEventOverride: !1
					});
					return null == t ? void 0 : t.toLocaleLowerCase()
				},
				p = e => {
					var t;
					const n = m(e);
					if (!n) return !1;
					let s = Object(d.r)(e),
						o = Object(d.d)(e);
					if ("undefined" != typeof window && !o) {
						const e = Object(i.a)("subreddit", window.location.href);
						(o = null === (t = null == e ? void 0 : e.components) || void 0 === t ? void 0 : t.subredditName) && (s = r.Nb.SUBREDDIT)
					}
					if (o && n) {
						const e = (null == o ? void 0 : o.toLocaleLowerCase()) === n;
						return s === r.Nb.SUBREDDIT && e
					}
					return !1
				},
				b = e => !!m(e) && Object(a.c)(e, {
					experimentEligibilitySelector: u,
					experimentName: o.Rd,
					expEventOverride: !1
				}) !== o.Sd.Readonly
		},
		"./src/reddit/selectors/experiments/joinOptimizations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/experiments/index.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Vb,
					experimentEligibilitySelector: a.e
				}), e => e === r.hb.Enabled),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Wb,
					experimentEligibilitySelector: a.e
				}), e => e === r.ib.Enabled),
				c = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Xb,
					experimentEligibilitySelector: a.e
				}), e => e === r.jb.Enabled),
				l = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Yb,
					experimentEligibilitySelector: a.e
				}), e => e === r.kb.Enabled),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.ac,
					experimentEligibilitySelector: a.e
				}), e => e === r.mb.Enabled),
				m = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Zb,
					experimentEligibilitySelector: a.e
				}), e => e === r.lb.Enabled)
		},
		"./src/reddit/selectors/experiments/loggedOutOneFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/countrySites.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts"),
				d = n("./src/reddit/selectors/experiments/utils.ts");
			const c = Object(s.a)(i.f, a.f, (e, t) => e && !t),
				l = e => Object(o.c)(e, {
					experimentEligibilitySelector: c,
					experimentName: r.dc
				}),
				u = e => !!Object(d.a)(l(e))
		},
		"./src/reddit/selectors/experiments/mediaInComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.ge
				}) === s.xd,
				a = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.fe
				}) === s.xd
		},
		"./src/reddit/selectors/experiments/newCommunityProgressV3.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "b", (function() {
				return f
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/constants/posts.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				d = n("./src/reddit/selectors/experiments/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				l = n("./src/reddit/selectors/moderatorPermissions.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const b = e => e.subreddits.progressModule,
				h = e => {
					const t = Object(u.c)(e);
					if (!t) return;
					if (!Object(l.n)(e, {
							subredditId: t
						})) return;
					if (Object(p.N)(e)) return f(e);
					const n = Object(m.I)(e, {
						identifier: {
							id: t,
							type: a.a.SUBREDDIT
						}
					});
					if (!n || !n.created) return;
					const s = n.created;
					return s ? s * r.Sb < 1639443600180 ? void 0 : f(e) : void 0
				},
				f = Object(s.a)(e => Object(i.c)(e, {
					experimentName: o.pe,
					experimentEligibilitySelector: d.e
				}), c.a)
		},
		"./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "b", (function() {
				return j
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "e", (function() {
				return S
			})), n.d(t, "d", (function() {
				return w
			}));
			var s, r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/selectors/subreddit.ts"),
				a = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/index.ts"),
				l = n("./src/reddit/selectors/meta.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/profile.ts");
			! function(e) {
				e.Blurred = "blurred", e.NoPreview = "noPreview"
			}(s || (s = {}));
			const p = Object(r.a)(l.h, l.d, c.e, (e, t, n) => !e && !t && !n);

			function b(e, t) {
				return n => Object(d.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: p,
					expEventOverride: t
				})
			}
			const h = b(a.gc, !0),
				f = b(a.gc, !1),
				g = b(a.ic, !0),
				_ = (b(a.ic, !1), b(a.hc, !0)),
				v = b(a.hc, !1),
				O = b(a.jc, !0),
				x = b(a.jc, !1),
				E = Object(r.a)(h, g, (e, t) => e === a.Gc.Enabled || t === a.Hc.Enabled),
				y = Object(r.a)(_, O, (e, t) => e === a.sb.BlurredPreview || e === a.sb.NoPreview || t === a.sb.BlurredPreview || t === a.sb.NoPreview),
				j = Object(r.a)(v, x, (e, t) => e === a.sb.BlurredPreview || t === a.sb.BlurredPreview),
				C = Object(r.a)(_, O, (e, t) => e === a.sb.NoPreview || t === a.sb.NoPreview),
				k = Object(r.a)(E, C, j, (e, t, n) => (e || t) && !n),
				I = e => {
					const t = j(e),
						n = k(e);
					return t ? s.Blurred : n ? s.NoPreview : null
				},
				S = e => {
					const t = j(e),
						n = Object(o.k)(e);
					return t && n
				},
				w = e => {
					var t;
					const n = j(e),
						s = Object(u.b)(e),
						r = null === (t = null == s ? void 0 : s.routeMatch) || void 0 === t ? void 0 : t.match;
					if (r) {
						const t = Object(m.j)(e, {
								profileName: r.params.profileName
							}),
							o = !!(t && (null == t ? void 0 : t.isNSFW)),
							a = Object(i.E)(e, {
								pageLayer: s
							});
						return n && o && !a
					}
					return !1
				}
		},
		"./src/reddit/selectors/experiments/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/experiments/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const d = Object(s.a)(a.e, i.J, (e, t) => e && !t),
				c = e => Object(o.c)(e, {
					experimentEligibilitySelector: d,
					experimentName: r.vc
				}),
				l = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.uc
				}), e => e),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.Qb
				}), e => e === r.xd)
		},
		"./src/reddit/selectors/experiments/postActionBarAnimation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return h
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/experiments/index.ts"),
				a = n("./src/reddit/selectors/experiments/presence.ts"),
				i = n("./src/reddit/selectors/userPrefs.ts");
			const d = 1e4,
				c = e => {
					if (Object(a.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.s
					});
					return t === s.x.VoteCountOnly || t === s.x.CommentCountOnly || t === s.x.VoteAndCommentCount
				},
				l = e => {
					if (Object(i.c)(e) || Object(a.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.s
					});
					return t === s.x.VoteCountOnly || t === s.x.VoteAndCommentCount
				},
				u = e => {
					if (Object(i.c)(e) || Object(a.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.s
					});
					return t === s.x.CommentCountOnly || t === s.x.VoteAndCommentCount
				},
				m = (e, t) => {
					let {
						post: n
					} = t;
					return p(e, {
						postId: n.id
					})
				},
				p = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(i.c)(e) || !r || r.isSponsored || r.isScoreHidden || r.score >= d || Object(a.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.s
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.x.VoteCountOnly || l === s.x.VoteAndCommentCount
				},
				b = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(i.c)(e) || !r || r.isSponsored || r.numComments >= d || Object(a.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.s
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.x.CommentCountOnly || l === s.x.VoteAndCommentCount
				},
				h = e => {
					if (Object(a.a)(e)) return !1;
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.rc
					}) === s.Jc.Enabled
				}
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "m", (function() {
				return j
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				c = n("./src/reddit/selectors/subreddit.ts");
			const l = 3,
				u = e => m(e) ? 1 : (p(e), .5),
				m = e => {
					return Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: o.Be
					}) === o.De.ContentMatch
				},
				p = e => {
					return Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: o.Be
					}) === o.De.ConfidenceAndSuccess
				},
				b = e => {
					const t = Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: o.Be
					});
					return t === o.De.ContentMatch || t === o.De.ConfidenceAndSuccess || t === o.cb.Control1 || t === o.cb.Control2
				},
				h = e => {
					const t = Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: o.Be
					});
					return t === o.cb.Control1 || t === o.cb.Control2
				},
				f = e => {
					const t = Object(a.c)(e, {
						experimentEligibilitySelector: a.a,
						experimentName: o.Be
					});
					return t === o.De.ContentMatch || t === o.De.ConfidenceAndSuccess
				},
				g = e => e.creations.subredditRec.api.pending,
				_ = e => e.creations.subredditRec.api.error,
				v = e => {
					return e.creations.subredditRec.order.length > 0
				},
				O = e => {
					const t = e.creations.subredditRec.order,
						n = [];
					return t.forEach(t => {
						const s = Object(c.w)(e, {
								subredditName: t
							}),
							r = Object(c.z)(e, {
								subredditName: t
							});
						if (r && s) {
							const e = {
								iconUrl: r.icon.url,
								name: r.name,
								primaryColor: r.primaryColor,
								subscribers: s.subscribers,
								type: d.a.OTHER_SUBREDDIT
							};
							n.push(e)
						}
					}), n
				},
				x = e => e.creations.subredditRec.isInputChanged,
				E = e => {
					if (!(e.creations.formData.submissionType === s.Wb.POST)) return "";
					const t = e.creations.formState.editorMode === i.i.RICH_TEXT || null === e.creations.formState.editorMode,
						n = e.creations.formState.editorMode === i.i.MARKDOWN;
					if (t) {
						const t = e.creations.formData.body.rte;
						return r.a.getRawText(t, " ") || ""
					}
					return n && e.creations.formData.body.markdown || ""
				},
				y = e => {
					return e.creations.formData.submissionType === s.Wb.LINK_ONLY && e.creations.formData.body.link || ""
				},
				j = e => b(e) && (!_(e) || _(e) && x(e)) && (e => {
					const t = e.creations.formData.title,
						n = y(e),
						s = E(e);
					return !!(t || n || s)
				})(e) && (e.creations.formData.submissionType === s.Wb.POST || e.creations.formData.submissionType === s.Wb.LINK_ONLY || e.creations.formData.submissionType === s.Wb.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/presence.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ie
				}) === s.xd
			}
		},
		"./src/reddit/selectors/experiments/profileAvatarChangeFix.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			const o = Object(r.a)(s.v)
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => s.Ue.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.bf
				}),
				a = e => s.Ue.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ne
				}),
				i = (e, t, n) => {
					const o = n(e, t);
					return !(!o || !o.meter) && (o.meter.enabled && s.If.Enabled === Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.Hf
					}))
				},
				d = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.af
				}),
				c = e => {
					switch (e) {
						case s.ff.Five:
							return .05;
						case s.ff.Ten:
							return .1;
						case s.ff.Fifty:
							return .5;
						default:
							return .01
					}
				},
				l = e => s.Ue.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.cf
				}),
				u = e => s.Ue.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ye
				}),
				m = e => s.Ue.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ze
				})
		},
		"./src/reddit/selectors/experiments/reportingRevampDesktop.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = e => !!Object(o.b)(e) || Object(r.c)(e, {
				experimentEligibilitySelector: a.Q,
				experimentName: s.n
			}) === s.g.Enabled
		},
		"./src/reddit/selectors/experiments/shareToChatButton.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
				experimentEligibilitySelector: a.Q,
				experimentName: r.xc
			}), e => e === r.xd)
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const d = Object(s.a)(i.Q, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.A)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.O)(n)
				}, (e, t, n) => !e && !t && n),
				c = Object(s.a)((e, t) => Object(a.c)(e, {
					experimentName: r.Qc,
					experimentEligibilitySelector: e => d(e, t)
				}), e => e),
				l = e => e === r.Df.NoCommunityWidgets,
				u = e => e === r.Df.NoRulesModerators,
				m = e => e === r.Df.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/web2x_cta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts");
			const a = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Kf,
					experimentEligibilitySelector: o.a
				}), e => e),
				i = Object(s.a)(a, e => e === r.Cf)
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/models/ExternalAccount/index.ts"),
				r = n("./src/reddit/models/User/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const a = (e, t) => {
					let {
						username: n
					} = t;
					return !!e.externalAccount.api.user.pending[n]
				},
				i = (e, t) => {
					let {
						username: n
					} = t;
					return e.externalAccount.user[n]
				},
				d = e => {
					const t = Object(o.k)(e);
					if (!t) return;
					const n = Object(r.e)(t),
						s = i(e, {
							username: n
						});
					return s ? s.twitter : void 0
				},
				c = e => !!e.externalAccount.api.connect.pending[s.a.Twitter],
				l = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const a = i(e, {
						username: n
					});
					if (!a) return null;
					const d = a[s.a.Twitter];
					if (!d) return null;
					const c = Object(o.k)(e);
					if (!(c && Object(r.e)(c).toLowerCase() === n.toLowerCase())) return d;
					const l = Object(o.Ab)(e, {
						userName: n
					});
					return l ? l.prefShowTwitter ? d : null : d
				}
		},
		"./src/reddit/selectors/features/predictions/creation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts"),
				o = n("./src/reddit/selectors/postCreations.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const a = e => {
					const t = (e => {
						var t, n;
						return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation
					})(e);
					return (null == t ? void 0 : t.length) ? null == t ? void 0 : t.map(t => {
						const n = Object(o.eb)({
								...e,
								creations: {
									...e.creations,
									formData: t.formData,
									formState: t.formState
								}
							}, {}),
							s = t.formData.polls,
							r = s.options.map(e => ({
								text: e.text
							})),
							a = {};
						return n.document ? a.richText = JSON.stringify({
							document: n.document
						}) : n.markdown && (a.markdown = n.markdown), {
							title: n.title,
							isLiveChat: n.isChatPost,
							isNsfw: n.isNSFW,
							isSpoiler: n.isSpoiler,
							votingEndsAt: s.endDate.toISOString(),
							body: a,
							options: r
						}
					}) : []
				},
				i = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation.length)
				}
		},
		"./src/reddit/selectors/features/predictions/leaderboards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const o = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				a = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				i = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.error) || !1
				},
				d = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.data) || null
				},
				c = (e, t) => {
					var n, s;
					return (null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.tournamentsLeaderboards[t.tournamentId]) || null
				},
				l = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				u = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				m = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.error) || !1
				}
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			}));
			const s = e => e.gild.gildModalThingId,
				r = e => e.gild.correlationId || void 0,
				o = e => e.gild.isAnonymous,
				a = e => e.gild.isIframed,
				i = e => e.gild.message,
				d = e => e.gild.api.pending,
				c = e => e.gild.api.error
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				a = n("./src/reddit/selectors/gold/giveAwards.ts"),
				i = n("./src/reddit/selectors/posts.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				c = n("./src/reddit/selectors/userPrefs.ts");
			const l = [32, 48, 64, 128],
				u = (e, t, n) => {
					const s = t ? e[`staticIcon${n}`] : e[`icon${n}`];
					return (null == s ? void 0 : s.url) ? s.url : t ? e.staticIcon.url : e.icon.url
				},
				m = e => {
					let {
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					} = e;
					return t.awardSubType === r.d.Group ? (e => {
						let {
							award: t,
							size: n,
							prefersReducedMotion: s,
							postOrComment: r
						} = e, o = t;
						if ((null == r ? void 0 : r.awardCountsById) && r.awardCountsById[t.id] && t.tiers) {
							const e = r.awardCountsById[t.id];
							o = t.tiers.reduce((t, n) => e >= n.awardingsRequired ? n : t)
						}
						return u(o, s, n)
					})({
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					}) : u(t, s, n)
				},
				p = Object(s.a)((e, t) => {
					let {
						awards: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					const a = Object(c.c)(e),
						d = l.find(e => e >= s),
						u = r ? Object(i.G)(e, {
							postId: r
						}) || Object(o.b)(e, {
							commentId: r
						}) : void 0;
					return n.reduce((e, t) => (t && (e[t.id] = m({
						award: t,
						size: d,
						prefersReducedMotion: a,
						postOrComment: u
					})), e), {})
				}),
				b = (e, t) => {
					let {
						award: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					return n ? p(e, {
						awards: [n],
						minSize: s,
						postOrCommentId: r
					})[n.id] : void 0
				},
				h = (e, t) => {
					let {
						minSize: n,
						userName: s
					} = t;
					const r = Object(d.Ab)(e, {
						userName: s
					});
					if (r && r.awardedLastMonth && r.awardedLastMonth.topAward) return b(e, {
						award: r.awardedLastMonth.topAward,
						minSize: n
					})
				},
				f = e => {
					const t = Object(a.b)(e),
						n = Object(a.a)(e);
					return b(e, {
						award: t,
						postOrCommentId: n || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = e => e.gild.selectedAward,
				r = e => e.gild.gildedThing
		},
		"./src/reddit/selectors/gold/powerups/benefitSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/reddit/models/Gold/Powerups/index.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/actions/gold/constants.ts");
			const a = {};
			var i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					var n, s;
					switch (t.type) {
						case o.mb:
						case o.nb: {
							const {
								benefitStatuses: s,
								subredditId: r
							} = t.payload;
							if (!s) return e;
							const o = null !== (n = e[r]) && void 0 !== n ? n : {},
								a = {};
							return s.forEach(e => {
								let {
									benefit: t,
									isEnabled: n
								} = e;
								a[t] = n
							}), {
								...e,
								[r]: {
									...o,
									...a
								}
							}
						}
						case o.M: {
							const {
								benefitStatuses: n,
								subredditId: r
							} = t.payload, o = null !== (s = e[r]) && void 0 !== s ? s : {}, a = {};
							return n.forEach(e => {
								let {
									benefit: t,
									isEnabled: n
								} = e;
								a[t] = n
							}), {
								...e,
								[r]: {
									...o,
									...a
								}
							}
						}
						default:
							return e
					}
				},
				d = n("./node_modules/reselect/es/index.js");
			Object(r.a)({
				features: {
					powerupsBenefitSettings: i
				}
			});
			const c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return n ? e.features.powerupsBenefitSettings[n] : null
				},
				l = (e => Object(d.a)(c, t => !!(null == t ? void 0 : t[e])))(s.a.CommentsWithGifs)
		},
		"./src/reddit/selectors/gold/powerups/flairs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "a", (function() {
				return _
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/selectors/commentSelector.ts"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/powerups/index.ts");
			Object(o.a)({
				features: {
					powerups: a.a
				}
			});
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s;
					return n ? null === (s = e.features.powerups.subredditPowerupsFlairs) || void 0 === s ? void 0 : s[n] : null
				},
				d = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, r;
					return n ? null === (r = null === (s = e.features.powerups.subredditPowerupsFlairs) || void 0 === s ? void 0 : s[n]) || void 0 === r ? void 0 : r.flairsByType : null
				},
				c = (e, t) => {
					let {
						subredditId: n,
						userId: s
					} = t;
					var r, o;
					return n && s ? null === (o = null === (r = e.features.powerups.subredditUserPowerupsFlairs) || void 0 === r ? void 0 : r[n]) || void 0 === o ? void 0 : o[s] : null
				},
				l = Object(s.a)(c, e => (null == e ? void 0 : e.pendingAchievementType) || (null == e ? void 0 : e.preferredAchievementType)),
				u = Object(s.a)([d, l], (e, t) => e && t ? e[t] : null),
				m = Object(s.a)(c, e => null == e ? void 0 : e.preferredSupporterType),
				p = Object(s.a)([d, m], (e, t) => e && t ? e[t] : null),
				b = Object(s.a)([i, c], (e, t) => {
					if (!e || !t) return null;
					const {
						supporterTypes: n,
						achievementTypes: s,
						flairsByType: r
					} = e, {
						supporterTypes: o,
						achievementTypes: a,
						preferredSupporterType: i,
						preferredAchievementType: d,
						pendingSupporterType: c,
						pendingAchievementType: l
					} = t;
					return {
						supporterFlairs: g(n, o, r, c || i),
						achievementFlairs: g(s, a, r, l || d)
					}
				}),
				h = Object(s.a)([c], e => !!e && e.isHidden),
				f = Object(s.a)([i, c, p], (e, t, n) => {
					if (!e || !t) return [];
					const s = t.achievementTypes.map(t => e.flairsByType[t]);
					return n ? [n, ...s] : s
				}),
				g = (e, t, n, s) => e.map(e => ({
					...n[e],
					isLocked: !t.includes(e),
					isPreferred: e === s
				})).sort((e, t) => e.isLocked === t.isLocked ? 0 : e.isLocked ? 1 : -1),
				_ = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = Object(r.b)(e, {
							commentId: n
						}),
						o = null == s ? void 0 : s.subredditId,
						a = null == s ? void 0 : s.authorId;
					return !(!o || !a) && !!((e, t) => {
						let {
							subredditId: n,
							userId: s
						} = t;
						var r, o, a;
						return n && s ? null === (a = null === (o = null === (r = e.features.powerups) || void 0 === r ? void 0 : r.usersSupportedSubreddits) || void 0 === o ? void 0 : o[s]) || void 0 === a ? void 0 : a[n] : null
					})(e, {
						subredditId: o,
						userId: a
					})
				}
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "q", (function() {
				return a
			})), n.d(t, "s", (function() {
				return i
			})), n.d(t, "r", (function() {
				return d
			})), n.d(t, "u", (function() {
				return c
			})), n.d(t, "t", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "x", (function() {
				return O
			})), n.d(t, "v", (function() {
				return x
			})), n.d(t, "y", (function() {
				return E
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "d", (function() {
				return T
			}));
			var s = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/reducers/features/goldPurchase/index.ts");
			Object(r.a)({
				features: {
					goldPurchase: o.a
				}
			});
			const a = e => e.features.goldPurchase.purchaseModal.activePage,
				i = e => e.features.goldPurchase.purchaseModal.gildThingId || void 0,
				d = e => e.features.goldPurchase.purchaseModal.correlationId || void 0,
				c = e => e.features.goldPurchase.purchaseModal.showModal,
				l = e => e.features.goldPurchase.purchaseModal.packageId,
				u = e => e.features.goldPurchase.packageOfferModal.packageId,
				m = e => e.features.goldPurchase.premiumPurchaseModal.renewInterval,
				p = e => {
					const t = Object(s.l)(e),
						n = (e => e.features.goldPurchase.premiumPurchaseModal.packageId)(e);
					return t.length && n && t.find(e => e.mobileId === n) || null
				},
				b = e => e.features.goldPurchase.premiumPurchaseModal.activePage,
				h = e => e.features.goldPurchase.premiumPurchaseModal.showModal,
				f = e => e.features.goldPurchase.payment.paymentMethod,
				g = e => e.features.goldPurchase.payment.cardName,
				_ = e => e.features.goldPurchase.payment.postalCode,
				v = e => e.features.goldPurchase.payment.savedCardsPending,
				O = e => e.features.goldPurchase.payment.savedCards,
				x = e => e.features.goldPurchase.payment.rememberCard,
				E = e => e.features.goldPurchase.payment.useSavedCard,
				y = e => e.features.goldPurchase.payment.cardValidation.cardCvc,
				j = e => e.features.goldPurchase.payment.cardValidation.cardExpiry,
				C = e => e.features.goldPurchase.payment.cardValidation.cardNumber,
				k = e => e.features.goldPurchase.payment.cardValidation.nameOnCard,
				I = e => e.features.goldPurchase.payment.stripeToken.errorMessage,
				S = e => e.features.goldPurchase.payment.stripeToken.pending,
				w = e => e.features.goldPurchase.payment.paypal.passthrough,
				T = e => e.features.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/reddit/featureFlags/index.ts"),
				r = n("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!s.d.subredditInlineEditing(e)) return !1;
					const o = n ? Object(r.n)(e, {
						subredditId: n
					}) : null;
					return !!o && (e => !!e && e.config)(o)
				},
				a = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/redditGQL/types.ts"),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			Object(a.a)({
				features: {
					modUserNotes: i.a
				}
			});
			const d = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const a = Object(r.d)(n, s, o),
						i = e.features.modUserNotes.order[a];
					return i ? i.map(t => e.features.modUserNotes.models[t]) : []
				}),
				c = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const a = Object(r.d)(n, s, o);
					return e.features.modUserNotes.api.pending[a]
				},
				l = e => e.features.modUserNotes.api.error,
				u = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const a = Object(r.d)(n, s, o);
					return e.features.modUserNotes.loadMore[a]
				},
				m = (e, t, n) => {
					if (!t || !n) return;
					const s = e.features.modUserNotes.lastAuthorModNotes[Object(r.d)(n, t, o.m.All)];
					return s ? e.features.modUserNotes.models[s] : void 0
				},
				p = (e, t, n) => {
					if (!t || !n) return;
					return e.features.modUserNotes.totalCount[Object(r.d)(n, t, o.m.All)]
				},
				b = (e, t, n, s) => {
					if (!s) return;
					const r = p(e, t, n);
					return r && r[s] || 0
				}
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					if (!n) return !1;
					if (e.features.comments.collapsed[s] && n in e.features.comments.collapsed[s]) return !!e.features.comments.collapsed[s][n];
					const r = e.features.comments.models[n];
					return !!r && ("computedCollapsed" in r ? !!r.computedCollapsed : r.collapsedBecauseCrowdControl ? !e.modModeEnabled : r.collapsed)
				},
				r = (e, t) => {
					let {
						commentId: n
					} = t;
					if (!n) return !1;
					const s = e.features.comments.models[n];
					return !(!s || !s.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/muted.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/pages/modHub/index.ts");
			Object(o.a)({
				pages: {
					modHub: a.a
				}
			});
			const i = [],
				d = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.muted.userOrder[n];
					return s ? s.map(t => e.pages.modHub.muted.models[n][t]) : i
				}),
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(r.e)(n);
					return !!e.pages.modHub.muted.api.pending[s]
				},
				l = (e, t, n) => !!e.pages.modHub.muted.models[t] && !!e.pages.modHub.muted.models[t][n],
				u = e => !!e.pages.modHub.muted.search.api.pending,
				m = e => e.pages.modHub.muted.search.result,
				p = e => {
					var t, n, s;
					return null === (s = null === (n = null === (t = e.pages) || void 0 === t ? void 0 : t.modHub) || void 0 === n ? void 0 : n.muted) || void 0 === s ? void 0 : s.inContext
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.muted.loadMore[n]
				}
		},
		"./src/reddit/selectors/notificationPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "g", (function() {
				return o
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			const s = e => e.user.notificationPrefs.api.getPreferences.loaded,
				r = e => e.user.notificationPrefs.api.getPreferences.pending,
				o = e => e.user.notificationPrefs.api.setPreferences.pending,
				a = e => e.user.notificationPrefs.preferences,
				i = e => e.user.notificationPrefs.isNotificationPromptVisible,
				d = (e, t) => {
					var n, s;
					const r = (e => e.user.notificationPrefs.pushSettingsLayout)(e),
						o = null === (n = null == r ? void 0 : r.rows) || void 0 === n ? void 0 : n.byId;
					return o && (null === (s = o[t]) || void 0 === s ? void 0 : s.isEnabled)
				},
				c = (e, t) => !t.some(t => d(e, t))
		},
		"./src/reddit/selectors/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "e", (function() {
				return v
			}));
			var s = n("./src/lib/safeJSONParse/index.ts"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				i = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				d = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				c = n("./src/reddit/selectors/activeModal.ts"),
				l = n("./src/reddit/selectors/emailVerification.ts"),
				u = n("./src/reddit/selectors/experiments/onboarding.ts"),
				m = n("./src/reddit/selectors/platform.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const b = e => {
					const t = Object(m.q)(e);
					return Boolean((null == t ? void 0 : t[a.w]) && Object(s.a)(t[a.w]))
				},
				h = e => e.onboarding.shouldSkipOnboardingState,
				f = Object(r.a)(p.Q, p.P, b, h, (e, t, n, s) => (e || t) && n && !s),
				g = e => {
					const {
						genderUpdateState: t
					} = e.onboarding;
					if (t.success || t.failure) return t
				},
				_ = Object(r.a)(u.c, e => e.onboarding.interestTopicRecommendationsState, (e, t) => e && !Object(o.Tf)(e) ? t : null),
				v = Object(r.a)(u.c, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(i.I)(n) || Object(i.J)(n) || Object(i.y)(n)
				}, c.b, l.a, h, (e, t, n, s, r) => e === o.ub.PopoverFeed15 && t && Object(d.c)() && !n && !s && !r)
		},
		"./src/reddit/selectors/removalReasons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (e.features.removalReasons.reasonOrder[n]) {
						return e.features.removalReasons.reasonOrder[n].map(t => e.features.removalReasons.models[t])
					}
					return []
				},
				r = e => e.features.removalReasons.removedItemIds && e.features.removalReasons.removedItemIds.itemIds.length ? e.features.removalReasons.removedItemIds : null,
				o = e => e.features.removalReasons.api.pending
		},
		"./src/reddit/selectors/removedPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return f
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				a = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				i = n("./src/reddit/models/Media/index.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const l = new Set([d.g.AntiEvilOps, d.g.AutomodFiltered, d.g.CommunityOps, d.g.ContentTakedown, d.g.CopyrightTakedown, d.g.Moderator, d.g.Reddit]),
				u = new Set([d.g.Author, d.g.AuthorDeleted]),
				m = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return l.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[removed]", null, {
						hk: "2CBRa4"
					}).toString();
					let r = Object(a.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== i.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				p = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[deleted]", null, {
						hk: "12mOne"
					}).toString();
					let r = Object(a.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== i.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				b = Object(r.a)(o.a, e => {
					if (!e) return !1;
					if (e && e.isSpam) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					return !(e.created > Date.UTC(2019, 0))
				}),
				h = Object(r.a)(c.k, o.a, (e, t) => !!((null == e ? void 0 : e.id) && (null == t ? void 0 : t.authorId)) && e.id === t.authorId),
				f = Object(r.a)(o.a, e => !(!e || !1 !== e.isRobotIndexable))
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "o", (function() {
				return C
			})), n.d(t, "b", (function() {
				return k
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/ScheduledPost/index.ts");
			const a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return ((e, t) => {
						let {
							subredditId: n,
							type: s
						} = t;
						return !!e.posts.scheduledPosts[s].models[n]
					})(e, {
						subredditId: n,
						type: o.g.standalonePosts
					})
				},
				i = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return !!e.posts.scheduledPosts[s].pageInfo[n] && e.posts.scheduledPosts[s].pageInfo[n].hasNextPage
				},
				d = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return e.posts.scheduledPosts[s].pageInfo[n] ? e.posts.scheduledPosts[s].pageInfo[n].endCursor : null
				},
				c = e => e.posts.scheduledPosts.api.pending,
				l = e => e.posts.scheduledPosts.api.pendingUpdate,
				u = e => e.posts.scheduledPosts.api.error,
				m = {},
				p = [],
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[n][t])
				},
				f = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[n] || m)[s] || void 0
				},
				g = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return f(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.standalonePosts
					})
				},
				_ = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					const r = f(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.recurringPosts
					});
					return r || r
				},
				v = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return g(e, {
						subredditId: n,
						scheduledPostId: s
					}) || _(e, {
						subredditId: n,
						scheduledPostId: s
					})
				},
				O = e => e.creations.formData.scheduledPostId,
				x = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: o,
							isOriginalContent: a
						} = e;
						const i = [];
						return a && i.push({
							text: "OC",
							type: r.f.Oc
						}), t && i.push(...Object(s.b)(t)), o && i.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), n && i.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), i
					})(t)
				},
				E = e => {
					let {
						scheduledPost: t
					} = e;
					const n = x({
							scheduledPost: t
						}),
						s = n.find(e => e.type === r.f.Richtext);
					return s || (n.find(e => e.type === r.f.Text) || null)
				},
				y = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.scheduledPostId,
				j = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.subredditId,
				C = e => e.posts.scheduledPosts.api.pendingUpdate,
				k = e => e.posts.scheduledPosts.api.creationToken
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/selectors/user.ts");
			const o = e => !Object(r.Q)(e) && e.seo.linksModule.frontpage || null,
				a = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				i = Object(s.a)(o, e => e ? e.map(e => ({
					...e,
					links: e.links.map(e => ({
						...e,
						title: a(e.url)
					})).filter(e => e.title)
				})) : null),
				d = Object(s.a)(i, e => e ? e.map(e => ({
					...e,
					links: e.links.filter(e => e.visible)
				})) : null),
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = ((e, t) => {
						let {
							subredditId: n
						} = t;
						return e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[n]
					})(e, {
						subredditId: n
					});
					return s && s.subreddits
				}
		},
		"./src/reddit/selectors/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => {
				let {
					subredditId: n
				} = t;
				return e.seo.topicLinks.subreddits && e.seo.topicLinks.subreddits[n]
			}
		},
		"./src/reddit/selectors/showPromotedCTA.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/posts.ts");
			const i = e => Object(o.c)(e, {
					experimentName: r.Le,
					experimentEligibilitySelector: o.a
				}),
				d = (e, t) => t === r.Te.Enabled && (null == e ? void 0 : e.isCreatedFromAdsUi) || (null == e ? void 0 : e.isSponsored),
				c = Object(s.a)(a.G, i, (e, t) => d(e, t));
			Object(s.a)((e, t) => t, i, (e, t) => d(e, t))
		},
		"./src/reddit/selectors/streamingModSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			}));
			const s = {
					startTime: "",
					endTime: ""
				},
				r = {
					isLiveStreamingEnabled: !1,
					maxLiveStreams: void 0,
					minKarma: void 0,
					minAccountAgeDays: void 0,
					durationLimitSeconds: void 0,
					schedule: {
						sunday: s,
						monday: s,
						tuesday: s,
						wednesday: s,
						thursday: s,
						friday: s,
						saturday: s
					},
					whitelistedUsers: [],
					broadcasterPrompt: "",
					isDiscoveryUnitShown: !1,
					inSubMinKarma: void 0
				},
				o = (e, t) => {
					const n = e.streaming.modSettings[t.subredditId];
					return n ? {
						isLiveStreamingEnabled: n.isLiveStreamingEnabled,
						maxLiveStreams: n.maxLiveStreams,
						minKarma: n.minKarma,
						minAccountAgeDays: n.minAccountAgeDays,
						durationLimitSeconds: n.durationLimitSeconds,
						schedule: {
							sunday: c(n.weeklySchedule.sunday),
							monday: c(n.weeklySchedule.monday),
							tuesday: c(n.weeklySchedule.tuesday),
							wednesday: c(n.weeklySchedule.wednesday),
							thursday: c(n.weeklySchedule.thursday),
							friday: c(n.weeklySchedule.friday),
							saturday: c(n.weeklySchedule.saturday)
						},
						whitelistedUsers: n.whitelistedRedditors,
						broadcasterPrompt: n.broadcasterPrompt,
						isDiscoveryUnitShown: n.isDiscoveryUnitShown,
						inSubMinKarma: n.inSubMinKarma
					} : r
				},
				a = (e, t) => !!e.streaming.modSettings[t],
				i = e => !!e.streaming.api.pending,
				d = (e, t) => !!e.streaming.modSettings[t] && e.streaming.modSettings[t].isLiveStreamingEnabled,
				c = e => ({
					...s,
					...e[0]
				}),
				l = (e, t) => {
					const n = e.streaming.modSettings[t.subredditId];
					if (!n) return !1;
					const s = new Date;
					return u(s, n.weeklySchedule)
				},
				u = (e, t) => {
					const n = m(e);
					return p(n, t).some(t => b(e, t))
				},
				m = e => {
					return ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"][e.getUTCDay()]
				},
				p = (e, t) => t[e],
				b = (e, t) => {
					const n = e.getUTCHours(),
						s = e.getUTCMinutes(),
						{
							startTime: r,
							endTime: o
						} = t,
						[a, i] = r.split(":").map(Number),
						[d, c] = o.split(":").map(Number);
					let l = 60 * a + i,
						u = 60 * d + c;
					const m = 60 * n + s;
					return 1439 === u && u++, 1439 === l && l++, m >= l && m < u
				}
		},
		"./src/reddit/selectors/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return a
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "o", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return O
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts");
			const o = [],
				a = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						before: s,
						after: o
					} = t;
					const a = Object(r.e)(n, o, s),
						i = e.pages.modHub.moderators.userOrder.data[n] && e.pages.modHub.moderators.userOrder.data[n][a];
					return i ? i.map(t => e.pages.modHub.moderators.models[n][t]) : []
				}),
				i = (e, t, n) => !!e.pages.modHub.moderators.models[t] && !!e.pages.modHub.moderators.models[t][n],
				d = (e, t) => {
					let {
						subredditId: n,
						beforeEditable: s,
						afterEditable: o
					} = t;
					const a = Object(r.e)(n, o, s),
						i = e.pages.modHub.moderators.editableUserOrder.data[n] && e.pages.modHub.moderators.editableUserOrder.data[n][a];
					return i ? i.map(t => e.pages.modHub.moderators.editableModerators[n][t]) : []
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.editableModerators[n] || null
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.models[n] || null
				},
				u = e => !!e.pages.modHub.moderators.search.api.pending,
				m = e => e.pages.modHub.moderators.search.result,
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.pages.modHub.moderators.invitePending[n]
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].after
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].before
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].after
				},
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].before
				},
				_ = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.after, t.before);
					return !!e.pages.modHub.moderators.userOrder.api.pending[n]
				},
				v = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.afterEditable, t.beforeEditable);
					return !!e.pages.modHub.moderators.editableUserOrder.api.pending[n]
				},
				O = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.moderators.invitedModerators.userOrder[n];
					return s ? s.map(t => e.pages.modHub.moderators.invitedModerators.models[n][t]) : o
				})
		},
		"./src/reddit/selectors/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "p", (function() {
				return c
			})), n.d(t, "q", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts");
			const o = [],
				a = (e, t) => {
					var n;
					const {
						subredditName: s
					} = t;
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.directory[s.toLowerCase()]
				},
				i = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.subreddits.api.wiki.pending[n.toLowerCase()]
				},
				d = (e, t) => {
					var n;
					const s = Object(r.a)(t);
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.pages[s]
				},
				c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.pages.subredditWiki.revisions.listings[n]
				},
				l = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.pending[n]
				},
				u = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.error[n]
				},
				m = (e, t) => {
					return (e => e.pages.subredditWiki.revisions.models)(e)[t.revisionId]
				},
				p = (e, t) => {
					let {
						key: n
					} = t;
					return e.pages.subredditWiki.diff[n]
				},
				b = (e, t) => {
					const n = Object(r.a)(t);
					return e.pages.subredditWiki.pageSettings[n]
				},
				h = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiContributors.listing.api.pending[n.toLowerCase()]
				},
				f = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiContributors.listing,
						a = r.userOrder[s],
						i = r.models[s];
					return a ? a.map(e => i[e]) : o
				}),
				g = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.listing.afterToken[n.toLowerCase()]
				},
				_ = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.search[n.toLowerCase()]
				},
				v = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiBannedContributors.listing.api.pending[n.toLowerCase()]
				},
				O = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiBannedContributors.listing,
						a = r.userOrder[s],
						i = r.models[s];
					return a ? a.map(e => i[e]) : o
				}),
				x = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.listing.afterToken[n.toLowerCase()]
				},
				E = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.search[n.toLowerCase()]
				}
		},
		"./src/reddit/selectors/tags.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "A", (function() {
				return h
			})), n.d(t, "B", (function() {
				return f
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "p", (function() {
				return k
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "z", (function() {
				return R
			})), n.d(t, "y", (function() {
				return A
			})), n.d(t, "u", (function() {
				return M
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "q", (function() {
				return L
			})), n.d(t, "C", (function() {
				return F
			})), n.d(t, "w", (function() {
				return U
			})), n.d(t, "s", (function() {
				return G
			})), n.d(t, "x", (function() {
				return H
			})), n.d(t, "h", (function() {
				return W
			})), n.d(t, "v", (function() {
				return q
			})), n.d(t, "D", (function() {
				return V
			})), n.d(t, "m", (function() {
				return z
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/values.js"),
				a = n.n(o),
				i = n("./src/lib/objectSelector/index.ts"),
				d = n("./src/reddit/helpers/tags/index.ts"),
				c = n("./src/reddit/models/Tags/index.ts");
			const l = e => e.tags.creation.selectedOptions || [],
				u = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id && t.push(l(e)[n].id);
					return t || []
				},
				m = e => (l(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				p = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id || t.push(l(e)[n].displayText);
					return t || []
				},
				b = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				h = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				f = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.inputByItemId[n] || ""
				},
				_ = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.suggestedInputByItemId[n] || ""
				},
				v = [],
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return r()(x(e, {
						subredditId: n
					}), e => !!e.action) || r()(y(e, {
						subredditId: n
					}), e => !!e.action)
				},
				x = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedOptions[n] || v
				},
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedSuggestedOptions[n] || v
				},
				y = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.deselectedOptions[n] || v
				},
				j = {},
				C = {},
				k = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				I = e => e.tags.models.globalSubredditTags,
				S = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				w = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditScopedTags[n] || C
				},
				T = (e, t) => {
					const n = a()(t);
					for (let s = 0; s < n.length; s++)
						if (n[s].text.toLowerCase().trim() === e.toLowerCase().trim()) return n[s];
					return null
				},
				N = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.itemTags[n] || j
				},
				P = (e, t) => {
					let {
						itemId: n
					} = t;
					return !!e.tags.models.itemTags[n]
				},
				R = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.suggestedItemTags[n] || j
				},
				A = (e, t) => {
					let {
						itemId: n
					} = t;
					return a()(R(e, {
						itemId: n
					})).filter(e => e.isRelevant).map(e => Object(c.e)(e, !0))
				},
				M = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.sortedItemTags[n] || []
				},
				D = Object(i.a)((e, t) => {
					let {
						thingId: n,
						suggested: s = !1
					} = t;
					const r = U(e, {
						subredditId: n
					});
					return a()(((e, t) => {
						let {
							thingId: n,
							suggested: s = !1
						} = t;
						const r = (s ? _(e, {
								subredditId: n
							}) : g(e, {
								subredditId: n
							})) ? S(e) : k(e),
							o = s ? E(e, {
								subredditId: n
							}) : x(e, {
								subredditId: n
							}),
							a = r.reduce((e, t) => (e[t.id] = Object(c.f)(t), e), {});
						return o.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), a)
					})(e, {
						thingId: n,
						suggested: s
					})).filter(e => !e.selected && e.id !== r)
				}),
				L = (e, t) => {
					let {
						subredditId: n
					} = t;
					return x(e, {
						subredditId: n
					}).concat(y(e, {
						subredditId: n
					}))
				},
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					return x(e, {
						subredditId: n
					}).filter(d.b).map(e => ({
						text: e.displayText,
						type: c.c.CLASSIFICATION
					}))
				},
				U = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditPrimaryTagId[n] || null
				},
				B = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				G = (e, t) => {
					const n = e.tags.selected.selectedPrimaryTagId[t.subredditId] || null;
					return B(e, n)
				},
				H = (e, t) => {
					const n = U(e, t);
					return B(e, n)
				},
				W = e => e.tags.creation.selectedPrimaryTagId || null,
				q = e => {
					const t = W(e);
					return B(e, t)
				},
				V = e => e.tags.api.updatePrimaryTag.pending,
				z = (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object.keys(N(e, {
						itemId: n
					})).length > 0
				}
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = e => e.tooltip.tooltipId,
				r = e => t => t.tooltip.tooltipId === e,
				o = e => e.tooltip.params
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/selectors/gold/powerups/index.ts"),
				a = n("./src/reddit/selectors/moderatorPermissions.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				d = n("./src/reddit/reducers/features/userFlair/index.ts");
			Object(i.a)({
				features: {
					userFlair: d.a
				}
			});
			const c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.userFlair[n]
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, r;
					return null === (s = e.features.userFlair[n]) || void 0 === s || !s.displaySettings || !!(null === (r = e.features.userFlair[n].displaySettings) || void 0 === r ? void 0 : r.isEnabled)
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, o;
					return (null === (s = e.features.userFlair[n]) || void 0 === s ? void 0 : s.displaySettings) ? null === (o = e.features.userFlair[n].displaySettings) || void 0 === o ? void 0 : o.position : r.b.Right
				},
				m = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = c(e, {
						subredditId: n
					});
					if (s && s.displaySettings && s.permissions) return {
						type: r.d.UserFlair,
						displaySettings: s.displaySettings,
						permissions: s.permissions
					}
				}),
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = l(e, {
							subredditId: n
						}),
						r = m(e, {
							subredditId: n
						}),
						o = c(e, {
							subredditId: n
						});
					if (!s || !r || !o) return !1;
					if (o.applied) return !0;
					const i = Object(a.g)(e, {
							subredditId: n
						}),
						{
							canUserChange: d
						} = r.permissions;
					return !!(o.templateIds || []).find(e => {
						return !o.templates[e].modOnly || i
					}) && d
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!n) return !1;
					const s = p(e, {
							subredditId: n
						}),
						r = Object(o.f)(e, {
							subredditId: n
						});
					return s || r
				}
		},
		"./src/reddit/selectors/userPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/experiments/loggedOutOneFeed.ts");
			const o = e => {
					if (a(e)) return !1;
					const {
						subscriptionsPinned: t
					} = e.user.prefs;
					return !(void 0 !== t || !Object(r.a)(e)) || !!t
				},
				a = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== s.Nb.MODERATION_PAGES),
				i = e => e.user.prefs.reduceAnimationsFromAwards
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "b", (function() {
				return O
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/name/index.ts"),
				a = n("./src/reddit/helpers/widgets/index.tsx"),
				i = n("./src/reddit/selectors/profile.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.widgets.models,
				u = Object(s.a)((e, t) => Object(a.l)(t) ? e.widgets.models[t.widgetId] : Object(a.f)(t.widgetKind)),
				m = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let n = t.subredditId;
					if (!n && t.subredditName && (n = Object(d.F)(e, t.subredditName)), n) {
						const t = m(e, {
							subredditId: n
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				b = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				h = (e, t) => e.widgets.menuIds[t.subredditId],
				f = (e, t) => {
					const n = h(e, t);
					return n ? e.widgets.models[n] : null
				},
				g = (e, t) => {
					const n = e.widgets.sidebar[t.subredditId];
					return Array.isArray(n) ? n.reduce((t, n) => {
						const s = e.widgets.models[n];
						return s && t.push(s.kind), t
					}, []) : c
				},
				_ = (e, t) => {
					const n = b(e, t);
					for (const s of n) {
						const t = e.widgets.models[s];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				v = (e, t) => {
					const n = b(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return n.length ? n : null
				},
				O = Object(s.a)((e, t) => {
					if (t.type === r.a.PROFILE) {
						const n = Object(i.j)(e, {
							profileName: t.name
						});
						return n ? {
							profile: {
								id: n.id,
								name: Object(o.h)(n.name)
							}
						} : {}
					}
					const n = Object(d.z)(e, {
							subredditName: t.name
						}),
						s = Object(d.w)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: s ? s.contentCategory : null,
							id: n.id,
							name: Object(o.h)(n.name)
						}
					}
				})
		},
		"./src/reddit/singleton/EventSystem.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/actions/jsApi.ts");
			const a = "JSAPI customEvent.detail.name is deprecated. Please upgrade to <meta>",
				i = "jsapi.consumer",
				d = "/r/redesign/wiki/jsapi";
			var c = n("./src/reddit/constants/jsapiEvents.ts");
			const l = 100;
			const u = new class {
				constructor() {
					if (this.queue = [], this.active = !1, "undefined" == typeof document) return;
					let e;
					this.store = new Promise(t => e = t), this.attachStore = t => e(t);
					const t = document.querySelectorAll(`meta[name="${i}"]`);
					t.length && (t.forEach(e => {
						const t = e.content;
						this.store.then(e => e.dispatch(o.b(t)))
					}), this.store.then(() => this.fireEventsQueue())), document.addEventListener(c.b, e => this.onReadyEvent(e), !0)
				}
				onReadyEvent(e) {
					let t;
					if (this.active = !0, e.target && e.target instanceof HTMLMetaElement && e.target.name === i && (t = e.target.content), !t) try {
						e.detail && (t = e.detail.name, console.warn(a, `${s.a.redditUrl}${d}`, e))
					} catch (n) {
						return void console.error(a, `${s.a.redditUrl}${d}`, n)
					}
					this.store.then(e => {
						e.dispatch(o.b(t || "")), this.fireEventsQueue()
					})
				}
				publish(e, t, n) {
					const s = {
						name: e,
						props: t,
						element: n
					};
					this.queue.push(s), this.queue.length > l && this.queue.shift(), this.active && this.fireEvent(s)
				}
				fireEvent(e) {
					e.element.dispatchEvent(new CustomEvent(e.name, {
						detail: e.props
					}))
				}
				fireEventsQueue() {
					r.a.read(() => {
						for (let e = 0; e < this.queue.length; e++) {
							const t = this.queue[e];
							this.fireEvent(t)
						}
					})
				}
			};
			t.a = u
		},
		"./src/redditGQL/operations/AddApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"84b1688a0244"}')
		},
		"./src/redditGQL/operations/AddPredictionDrafts.json": function(e) {
			e.exports = JSON.parse('{"id":"e77b2360963c"}')
		},
		"./src/redditGQL/operations/AllModerators.json": function(e) {
			e.exports = JSON.parse('{"id":"e29846f6d98c"}')
		},
		"./src/redditGQL/operations/BadgeIndicators.json": function(e) {
			e.exports = JSON.parse('{"id":"9d105ce5d71a"}')
		},
		"./src/redditGQL/operations/CancelPrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"fac88c91fec8"}')
		},
		"./src/redditGQL/operations/ChangePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"614dbb8a54d2"}')
		},
		"./src/redditGQL/operations/ChangePredictionVote.json": function(e) {
			e.exports = JSON.parse('{"id":"90c7b71fa93f"}')
		},
		"./src/redditGQL/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"1b7d106afc6c"}')
		},
		"./src/redditGQL/operations/CreateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"edd5d18f5e93"}')
		},
		"./src/redditGQL/operations/CreateCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"e443629d50b0"}')
		},
		"./src/redditGQL/operations/CreateModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"10ad38be41ae"}')
		},
		"./src/redditGQL/operations/CreatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"ec74ef5afe19"}')
		},
		"./src/redditGQL/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"1e0a4bfe5ac9"}')
		},
		"./src/redditGQL/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/redditGQL/operations/DeleteCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"c13d195ee7ca"}')
		},
		"./src/redditGQL/operations/DeleteModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"c44e6467c4d7"}')
		},
		"./src/redditGQL/operations/DeleteScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"dea861ad7f0d"}')
		},
		"./src/redditGQL/operations/EndPredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"a141637b546a"}')
		},
		"./src/redditGQL/operations/EventPostsBySubredditName.json": function(e) {
			e.exports = JSON.parse('{"id":"5ee520f9aa60"}')
		},
		"./src/redditGQL/operations/FetchContentControls.json": function(e) {
			e.exports = JSON.parse('{"id":"c822b1f9fc9b"}')
		},
		"./src/redditGQL/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/redditGQL/operations/FetchModerationLogActions.json": function(e) {
			e.exports = JSON.parse('{"id":"6243efcbc61d"}')
		},
		"./src/redditGQL/operations/FetchSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"df4f7fe92d1f"}')
		},
		"./src/redditGQL/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/redditGQL/operations/FetchSubredditTrafficStats.json": function(e) {
			e.exports = JSON.parse('{"id":"d2b39ab0293a"}')
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json": function(e) {
			e.exports = JSON.parse('{"id":"cbcafcbff9c6"}')
		},
		"./src/redditGQL/operations/GeoPlaceAutocomplete.json": function(e) {
			e.exports = JSON.parse('{"id":"8a89fd7c7db1"}')
		},
		"./src/redditGQL/operations/GetModUserNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"0eb0efc0bf02"}')
		},
		"./src/redditGQL/operations/GetPredictionChipPackages.json": function(e) {
			e.exports = JSON.parse('{"id":"5ce83e513fa5"}')
		},
		"./src/redditGQL/operations/GetPredictionCreationAllowance.json": function(e) {
			e.exports = JSON.parse('{"id":"d9fb5ec5128f"}')
		},
		"./src/redditGQL/operations/GetPredictionToken.json": function(e) {
			e.exports = JSON.parse('{"id":"26b911e67a5f"}')
		},
		"./src/redditGQL/operations/GetSubredditChatSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"63d6a697b823"}')
		},
		"./src/redditGQL/operations/GetSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"abd8b9be540b"}')
		},
		"./src/redditGQL/operations/GetSubredditQuestions.json": function(e) {
			e.exports = JSON.parse('{"id":"15c4ad40a0bc"}')
		},
		"./src/redditGQL/operations/GetSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ba4eb4e2972f"}')
		},
		"./src/redditGQL/operations/GetTotalModNoteCount.json": function(e) {
			e.exports = JSON.parse('{"id":"bb325c103c55"}')
		},
		"./src/redditGQL/operations/GetTournaments.json": function(e) {
			e.exports = JSON.parse('{"id":"17f4fcd0e341"}')
		},
		"./src/redditGQL/operations/GetTournamentsBaseInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"cebfc8734cec"}')
		},
		"./src/redditGQL/operations/LiveVideoPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"b3343d9362cd"}')
		},
		"./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/redditGQL/operations/ModQueueItems.json": function(e) {
			e.exports = JSON.parse('{"id":"95d8c0b32743"}')
		},
		"./src/redditGQL/operations/ModQueueTriggers.json": function(e) {
			e.exports = JSON.parse('{"id":"de8696c3b5fd"}')
		},
		"./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json": function(e) {
			e.exports = JSON.parse('{"id":"d03522f8a8d4"}')
		},
		"./src/redditGQL/operations/OpenAISubRecWithDetail.json": function(e) {
			e.exports = JSON.parse('{"id":"e61106627ea9"}')
		},
		"./src/redditGQL/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/redditGQL/operations/ReallocatePowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"d02bf38ca840"}')
		},
		"./src/redditGQL/operations/RedditorIdByName.json": function(e) {
			e.exports = JSON.parse('{"id":"a24cf5c8adf7"}')
		},
		"./src/redditGQL/operations/RedditorPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"e2bcd0fbaace"}')
		},
		"./src/redditGQL/operations/RegisterWebPushToken.json": function(e) {
			e.exports = JSON.parse('{"id":"197650c1946c"}')
		},
		"./src/redditGQL/operations/RemoveApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"e016564e243a"}')
		},
		"./src/redditGQL/operations/ReportMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ae01229e1caa"}')
		},
		"./src/redditGQL/operations/ResolvePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"d742e3019cfe"}')
		},
		"./src/redditGQL/operations/SetSubredditGeoPlace.json": function(e) {
			e.exports = JSON.parse('{"id":"ece6b91ed02d"}')
		},
		"./src/redditGQL/operations/SubmitScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"6f9e584d390a"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"c7c6cf422c4a"}')
		},
		"./src/redditGQL/operations/SubredditApprovedTalkHosts.json": function(e) {
			e.exports = JSON.parse('{"id":"86107f5fbae2"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"11aba1560164"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"d343c3cad2d0"}')
		},
		"./src/redditGQL/operations/SubredditInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"29aee4089528"}')
		},
		"./src/redditGQL/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"0d6990e443b8"}')
		},
		"./src/redditGQL/operations/SubredditPageExtra.json": function(e) {
			e.exports = JSON.parse('{"id":"f8a28e97ccd1"}')
		},
		"./src/redditGQL/operations/SubredditPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"8d2145ac1ec5"}')
		},
		"./src/redditGQL/operations/SubredditPowerupsFull.json": function(e) {
			e.exports = JSON.parse('{"id":"5ef02d19b2e0"}')
		},
		"./src/redditGQL/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"c398abb500f1"}')
		},
		"./src/redditGQL/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"de72339b938a"}')
		},
		"./src/redditGQL/operations/SubredditTopPredictors.json": function(e) {
			e.exports = JSON.parse('{"id":"a9f7697930b7"}')
		},
		"./src/redditGQL/operations/SubredditTournamentLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"e14e6d1892e6"}')
		},
		"./src/redditGQL/operations/SubredditWiki.json": function(e) {
			e.exports = JSON.parse('{"id":"5834be60ee7a"}')
		},
		"./src/redditGQL/operations/SubredditWikiBannedContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"9b728f1ed735"}')
		},
		"./src/redditGQL/operations/SubredditWikiContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"6ff60c2af7f1"}')
		},
		"./src/redditGQL/operations/SubredditWikiPageSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"03acb455993d"}')
		},
		"./src/redditGQL/operations/SubscribedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"13af47cf5fb3"}')
		},
		"./src/redditGQL/operations/TopAwardedPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"227597709dbb"}')
		},
		"./src/redditGQL/operations/TopAwardersLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"750ff4a757de"}')
		},
		"./src/redditGQL/operations/UpdateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"3954b4d4b89c"}')
		},
		"./src/redditGQL/operations/UpdateCommentDistinguishState.json": function(e) {
			e.exports = JSON.parse('{"id":"e1f407c8ceba"}')
		},
		"./src/redditGQL/operations/UpdateCommentFollowState.json": function(e) {
			e.exports = JSON.parse('{"id":"0a2ed51664c5"}')
		},
		"./src/redditGQL/operations/UpdateCommentStickyState.json": function(e) {
			e.exports = JSON.parse('{"id":"236938d65d55"}')
		},
		"./src/redditGQL/operations/UpdateHatefulContentFilters.json": function(e) {
			e.exports = JSON.parse('{"id":"0f2f2af43b20"}')
		},
		"./src/redditGQL/operations/UpdateNotificationPreferences.json": function(e) {
			e.exports = JSON.parse('{"id":"129085be0500"}')
		},
		"./src/redditGQL/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/redditGQL/operations/UpdatePowerupsSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"699ae1616006"}')
		},
		"./src/redditGQL/operations/UpdatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"871996bf9044"}')
		},
		"./src/redditGQL/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"f5276d63e133"}')
		},
		"./src/redditGQL/operations/UpdateSubredditChatSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"bdb05b8c7a65"}')
		},
		"./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c21fac68db2d"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/redditGQL/operations/UpdateSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"1f690708b8b1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"1e4c7b58a2a4"}')
		},
		"./src/redditGQL/operations/UserPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"5460e33eb672"}')
		},
		"./src/redditGQL/operations/UserSubredditsNotificationsLevel.json": function(e) {
			e.exports = JSON.parse('{"id":"8404d1f9e84d"}')
		},
		"./src/redditGQL/operations/ValidateCreateSubreddit.json": function(e) {
			e.exports = JSON.parse('{"id":"4c43ed06b3c2"}')
		},
		"./src/redditGQL/operations/VotePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"484780ada6a2"}')
		},
		"./src/redditGQL/operations/WhereToPostSubRec.json": function(e) {
			e.exports = JSON.parse('{"id":"645c3c962b55"}')
		},
		"./src/redditGQL/operations/WikiComparisonDiff.json": function(e) {
			e.exports = JSON.parse('{"id":"37afdc03bbf6"}')
		},
		"./src/redditGQL/operations/WikiRevisions.json": function(e) {
			e.exports = JSON.parse('{"id":"83e11ebf7cbf"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/ModerationPages.b4d1ca8f5da0ae048485.js.map