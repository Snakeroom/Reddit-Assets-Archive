// https://www.redditstatic.com/desktop2x/ModerationPages.1399f664bab18b1d2a17.js
// Retrieved at 11/10/2022, 1:20:05 PM by Reddit Dataminer v1.0.0
(window.__LOADABLE_LOADED_CHUNKS__ = window.__LOADABLE_LOADED_CHUNKS__ || []).push([
	["ModerationPages", "CollectionCommentsPage~CommentsPage~ProfileComments~ProfileOverview~ProfilePrivate~RpanListingUnit~S~5809214e", "CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81", "Governance~Reddit~Subreddit~reddit-components-BlankPost~reddit-components-ClassicPost~reddit-compone~3b56c92e", "CollectionCommentsPage~ProfileComments~ProfileOverview~ProfilePrivate~StandalonePostPage~reddit-comp~2f7e159a", "Governance~ModListing~Reddit~ReportFlow~Subreddit", "Reddit~RpanListingUnit~StandalonePostPage~reddit-components-LargePost~reddit-components-MediumPost", "Governance~ModListing~Reddit", "Governance~Reddit~SubredditForkingCTA", "Settings~SubredditWiki"], {
		"./src/chat/controls/Svg/index.m.less": function(e, t, n) {
			e.exports = {
				Component: "_2Qq40Mz_DMe0iARkTh8cZn",
				component: "_2Qq40Mz_DMe0iARkTh8cZn",
				disable: "_2xw21QiaL_ouF76MONf7hF",
				active: "_2dOhVJ6aPS9cbx0JfiKCW8",
				hover: "_1eWUKX11coBa2dErvWkP1q"
			}
		},
		"./src/chat/controls/Svg/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/chat/controls/Svg/index.m.less"),
				d = n.n(a);
			t.a = i.a.wrapped(e => {
				const t = {
						height: e.height || void 0,
						width: e.width || void 0
					},
					{
						disable: n,
						active: s,
						hover: i
					} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(e.className, {
						[d.a.disable]: n,
						[d.a.active]: s,
						[d.a.hover]: !!i
					}),
					viewBox: e.viewBox,
					style: t,
					onClick: e.onClick
				}, e.children)
			}, "Component", d.a)
		},
		"./src/devPlatform/components/ContextActions/ContextActionsLoader.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				a = n("./src/reddit/selectors/experiments/devPlatform.ts");
			const d = Object(i.a)({
				resolved: {},
				chunkName: () => "devPlatform-components-ContextActions",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("vendors~devPlatform-components-AdminPanel-Utilities-DevPlatformConfig~devPlatform-components-ContextActions"), n.e("devPlatform-components-ContextActions")]).then(n.bind(null, "./src/devPlatform/components/ContextActions/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/devPlatform/components/ContextActions/index.tsx"
				}
			}, {
				ssr: !1
			});

			function c(e) {
				return Object(o.e)(e => Object(a.a)(e)) ? r.a.createElement(d, {
					contextType: e.contextType,
					contextData: e.contextData,
					moderator: e.moderator
				}) : null
			}
		},
		"./src/devPlatform/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			const s = "devvit-gateway-url",
				r = "devvit-mock-metadata",
				o = "devvit-debug-logging",
				i = "DEV_PLAT__OPEN_USER_INPUT_MODAL";
			var a;
			! function(e) {
				e[e.POST = 0] = "POST", e[e.COMMENT = 1] = "COMMENT", e[e.SUBREDDIT = 2] = "SUBREDDIT", e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED"
			}(a || (a = {}))
		},
		"./src/higherOrderComponents/asModal/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			const r = () => {
					const e = document.getElementById(s.a);
					e && (e.style.filter = "blur(10px)")
				},
				o = () => {
					const e = document.getElementById(s.a);
					e && e.style.removeProperty("filter")
				}
		},
		"./src/higherOrderComponents/asModal/index.m.less": function(e, t, n) {
			e.exports = {
				overlay: "_1DK52RbaamLOWw5UPaht_S",
				mIsVisible: "_1acwN_tUhJ8w-n7oCp-Aw3",
				mIsBlurred: "_3Tq-_9917Q-o0iyzcNAeZn",
				modal: "_2Bejocqb-InO8686E2ehf"
			}
		},
		"./src/higherOrderComponents/asModal/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/helpers.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/FocusTrap/index.ts"),
				d = n("./src/lib/portal/index.tsx"),
				c = n("./src/reddit/actions/shortcuts/utils.ts"),
				l = n("./src/reddit/constants/shortcuts.ts"),
				u = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				m = n("./src/higherOrderComponents/asModal/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const f = e => {
				let {
					className: t,
					shouldBlurBackground: n,
					isVisible: s,
					...o
				} = e;
				return r.a.createElement("div", b({
					className: Object(i.a)(p.a.overlay, t, {
						[p.a.mIsVisible]: s,
						[p.a.mIsBlurred]: n
					})
				}, o))
			};

			function h(e) {
				class t extends s.Component {
					constructor(e) {
						super(e), this.getRef = e => this.ref = e, this.onClick = e => e.stopPropagation(), this.onOverlayClick = e => {
							this.props.onOverlayClick && this.props.onOverlayClick(), e.stopPropagation()
						}, this.state = {
							mounted: !1
						}
					}
					componentDidMount() {
						this.props.ignoreDefaultFocus || this.ref && this.ref.focus(), this.setState({
							mounted: !0
						}), Object(u.a)(), this.ref && (this.focusTrap = new a.b(this.ref), this.focusTrap.activate()), this.props.shouldBlurBackground && Object(o.a)()
					}
					componentWillUnmount() {
						this.setState({
							mounted: !1
						}), Object(u.b)(), Object(c.d)(), this.focusTrap && this.focusTrap.deactivate(), this.props.shouldBlurBackground && Object(o.b)()
					}
					render() {
						const {
							props: t
						} = this, {
							className: n,
							ignoreDefaultFocus: s,
							onOverlayClick: o,
							overlayClassName: a,
							overlayCustomStyles: c,
							shouldBlurBackground: u,
							withOverlay: m,
							...b
						} = t, h = b;
						return r.a.createElement(d.a, {
							container: document.getElementById(l.b)
						}, r.a.createElement(f, {
							className: a,
							isVisible: m,
							onClick: this.onOverlayClick,
							shouldBlurBackground: u,
							style: c
						}, r.a.createElement("div", {
							"aria-modal": !0,
							className: Object(i.a)(p.a.modal, n),
							onClick: this.onClick,
							ref: this.getRef,
							role: "dialog",
							tabIndex: -1
						}, r.a.createElement(e, h))))
					}
				}
				return t
			}
		},
		"./src/higherOrderComponents/warnOnChildrenCount/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			n("./src/lib/logs/console.ts");
			t.a = function(e, t) {
				return t => r.a.createElement(e, t)
			}
		},
		"./src/higherOrderComponents/withAdClickLocation/Locations.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.UNKNOWN = "unknown", e.TITLE = "title", e.TOP_BAR = "top_bar", e.MEDIA = "media", e.BODY = "body", e.BACKGROUND = "background", e.CTA_URL = "cta_url", e.CTA_BUTTON = "cta_button", e.CTA_WHITESPACE = "cta_whitespace", e.CTA_CAPTION = "cta_caption", e.SUBREDDIT = "subreddit", e.TIMESTAMP = "timestamp", e.USER = "user"
				}(s || (s = {})),
				function(e) {
					e.COMMENTS = "comments", e.FLATLIST_SHARE = "fl_share", e.FLATLIST_AWARD = "fl_award", e.FLATLIST_SAVE = "fl_save", e.FLATLIST_GENERAL = "fl_unknown", e.OVERFLOW_MENU = "overflow_menu", e.UPVOTE = "upvote", e.DOWNVOTE = "downvote"
				}(r || (r = {}))
		},
		"./src/higherOrderComponents/withAdClickLocation/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = e => (e, t, n) => ({
				...i.o(e),
				source: "post",
				action: "click",
				noun: "ad",
				adClick: {
					location: t
				},
				actionInfo: i.d(e),
				adblock: i.e(e),
				app: i.f(e),
				feed: i.r(e),
				geo: i.t(e),
				platform: i.I(e),
				referrer: i.Z(e),
				request: i.ab(e),
				screen: i.cb(e),
				session: i.gb(e),
				user: i.sb(e),
				media: n ? i.C(e, n) : null,
				post: n ? i.K(e, n) : null
			});
			var d = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				c = n("./src/telemetry/index.ts");
			const l = new Set;

			function u(e) {
				function t(t) {
					const n = Object(o.f)().getState(),
						{
							post: s
						} = {
							...t
						};
					return s && s.isSponsored ? r.a.createElement("div", {
						onClickCapture: function(e, s) {
							var r, o;
							if (l.has(e.timeStamp)) return;
							l.add(e.timeStamp);
							const i = function(e) {
								if (e.dataset.adclicklocation) return e.dataset.adclicklocation;
								const t = e.closest(".PostContainer, [data-adclicklocation]");
								return t ? t.dataset.adclicklocation : d.a.UNKNOWN
							}(e.target);
							i && (! function(e, t) {
								return Object.values(t).some(t => t === e)
							}(i, d.b) ? Object(c.a)(a(s)(n, i, null === (o = t.post) || void 0 === o ? void 0 : o.postId)) : Object(c.a)(a(s)(n, d.a.UNKNOWN, null === (r = t.post) || void 0 === r ? void 0 : r.postId)))
						}
					}, r.a.createElement(e, t)) : r.a.createElement(e, t)
				}
				const n = e.name || e.displayName;
				return t.displayName = `WithAdClickLocation(${n})`, t
			}
		},
		"./src/higherOrderComponents/withImageUploads.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/imageUploads.ts"),
				i = n("./src/reddit/models/Image/index.tsx"),
				a = n("./src/reddit/selectors/imageUploads.ts");
			const d = Object(r.c)({
				_imageUploads: a.b
			});

			function c(e, t) {
				return Object(s.b)(d, e => ({
					uploadImage: n => e(t(n)),
					cancelUpload: t => e(Object(o.h)(t))
				}), (function(e, t, n) {
					return {
						...n,
						...t,
						getImageUploadsIfModified: function(t) {
							return function(e, t) {
								const n = [];
								let s = !1;
								for (const r of t)
									if (Object(i.i)(r) || e[r.id])
										if (e[r.id]) {
											const t = e[r.id];
											n.push(t), s = s || t !== r
										} else s = !0;
								else n.push(r);
								return s ? n : null
							}(e._imageUploads, t)
						}
					}
				}))(e)
			}
		},
		"./src/lib/CSSVariableProvider/withTheme.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/CSSVariableProvider/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function a(e) {
				const t = t => r.a.createElement(o.b.Consumer, null, n => r.a.createElement(e, i({
					theme: n
				}, t)));
				return t.displayName = `WithTheme(${e.displayName||e.name})`, t
			}
		},
		"./src/lib/FocusTrap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = ['input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", "a[href]", "button:not([disabled])", '[tabindex]:not([tabindex="-1"]):not([disabled])', "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join();
			class r {
				constructor(e) {
					this.active = !1, this.onKeyDown = e => {
						if ("Tab" === e.key || 9 === e.keyCode) {
							const [t, n] = this.getTabbableNodes();
							if (!t || !n) return;
							e.shiftKey && e.target === t ? (e.preventDefault(), this.tryToFocusNode(n)) : e.shiftKey || e.target !== n || (e.preventDefault(), this.tryToFocusNode(t))
						}
					}, this.container = e
				}
				activate() {
					this.active || (this.active = !0, document.addEventListener("keydown", this.onKeyDown, !0))
				}
				deactivate() {
					this.active && (document.removeEventListener("keydown", this.onKeyDown, !0), this.active = !1)
				}
				getTabbableNodes() {
					const e = this.container.querySelectorAll(s);
					return [e[0], e[e.length - 1]]
				}
				tryToFocusNode(e) {
					e !== document.activeElement && e.focus && e.focus()
				}
			}
		},
		"./src/lib/LinkedListMap/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			class s {
				constructor(e) {
					this.value = e, this.next = void 0, this.prev = void 0
				}
			}
			class r {
				constructor(e) {
					this.key = e, this.tail = void 0, this.head = void 0, this.length = 0, this.itemsByKey = {}
				}
				static fromArray(e, t) {
					const n = new r(t);
					return e.forEach(e => n.push(e)), n
				}
				first() {
					if (this.tail) return this.tail.value
				}
				firstNode() {
					if (this.tail) return this.tail
				}
				forEach(e) {
					let t = this.tail;
					for (; t;) e(t.value), t = t.next
				}
				get(e) {
					const t = this.getNode(e);
					if (t) return t.value
				}
				getNode(e) {
					return this.itemsByKey[e]
				}
				has(e) {
					return e in this.itemsByKey
				}
				insertAfter(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.prev = r, n.next = r.next, r.next = n, n.next && (n.next.prev = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				insertBefore(e, t) {
					const n = t instanceof s ? t : new s(t),
						r = this.getNode(e);
					if (!r) throw new Error(`Cannot find item with key ${e}`);
					n.next = r, n.prev = r.prev, r.prev = n, n.prev && (n.prev.next = n);
					const o = t instanceof s ? t.value[this.key] : t[this.key];
					this.itemsByKey[o] = n, this.length++
				}
				last() {
					if (this.head) return this.head.value
				}
				lastNode() {
					if (this.head) return this.head
				}
				pop() {
					if (!this.head) return;
					return this.removeNode(this.head).value
				}
				push(e) {
					const t = e instanceof s ? e : new s(e);
					t.prev = this.head, this.head ? this.head.next = t : this.tail = t, this.head = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
				remove(e) {
					const t = this.getNode(e);
					if (t) return this.removeNode(t).value
				}
				removeNode(e) {
					return e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e === this.tail && (this.tail = e.next), e === this.head && (this.head = e.prev), e.next = void 0, e.prev = void 0, this.itemsByKey[e.value[this.key]] = void 0, this.length--, e
				}
				shift() {
					if (!this.tail) return;
					return this.removeNode(this.tail).value
				}
				toArray() {
					const e = [];
					return this.forEach(t => e.push(t)), e
				}
				unshift(e) {
					const t = e instanceof s ? e : new s(e);
					t.next = this.tail, this.tail ? this.tail.prev = t : this.head = t, this.tail = t;
					const n = e instanceof s ? t.value[this.key] : e[this.key];
					this.itemsByKey[n] = t, this.length++
				}
			}
		},
		"./src/lib/LiveChatActiveUsers/index.m.less": function(e, t, n) {
			e.exports = {
				liveChatActiveUsers: "_25wqhmS87KWZppCM1ZHphX"
			}
		},
		"./src/lib/LiveChatActiveUsersWithLiveLabel/index.m.less": function(e, t, n) {
			e.exports = {
				liveParticipation: "_3qjBuOjYOffFET145CIGgi"
			}
		},
		"./src/lib/LiveLabel/index.m.less": function(e, t, n) {
			e.exports = {
				LiveLabel: "_1-nQNZpTU7wWajQDxaSGx8",
				liveLabel: "_1-nQNZpTU7wWajQDxaSGx8"
			}
		},
		"./src/lib/addAllowQuarantinedParam/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/addQueryParams/index.ts");
			t.a = e => Object(s.a)(e, {
				allow_quarantined: !0
			})
		},
		"./src/lib/assertNever.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				throw new Error(`Unexpected object: ${e}`)
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/bigNumberUtils/percent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/bignumber.js/bignumber.js");

			function r(e, t) {
				const n = new s.BigNumber(e),
					r = new s.BigNumber(t),
					o = new s.BigNumber(n.dividedBy(r)),
					i = new s.BigNumber("100").multipliedBy(o);
				return new s.BigNumber(i).toNumber()
			}
		},
		"./src/lib/combineRefs/index.tsx": function(e, t, n) {
			"use strict";
			t.a = function() {
				for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
				return e => {
					t.forEach(t => {
						if (t) return "function" == typeof t ? t(e) : void(t.current = e)
					})
				}
			}
		},
		"./src/lib/constants/icons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = {
				activity: "activity",
				activity_fill: "activity_fill",
				add: "add",
				add_fill: "add_fill",
				add_media: "add_media",
				add_media_fill: "add_media_fill",
				add_to_feed: "add_to_feed",
				add_to_feed_fill: "add_to_feed_fill",
				admin: "admin",
				admin_fill: "admin_fill",
				all: "all",
				all_fill: "all_fill",
				appearance: "appearance",
				appearance_fill: "appearance_fill",
				approve: "approve",
				approve_fill: "approve_fill",
				archived: "archived",
				archived_fill: "archived_fill",
				aspect_ratio: "aspect_ratio",
				aspect_ratio_fill: "aspect_ratio_fill",
				aspect_rectangle: "aspect_rectangle",
				aspect_rectangle_fill: "aspect_rectangle_fill",
				attach: "attach",
				attach_fill: "attach_fill",
				audio: "audio",
				audio_fill: "audio_fill",
				author: "author",
				author_fill: "author_fill",
				avatar_style: "avatar_style",
				avatar_style_fill: "avatar_style_fill",
				award: "award",
				award_fill: "award_fill",
				back: "back",
				back_fill: "back_fill",
				ban: "ban",
				ban_fill: "ban_fill",
				best: "best",
				best_fill: "best_fill",
				block: "block",
				block_fill: "block_fill",
				bold: "bold",
				bold_fill: "bold_fill",
				bot: "bot",
				bot_fill: "bot_fill",
				bounce: "bounce",
				bounce_fill: "bounce_fill",
				browse: "browse",
				browse_fill: "browse_fill",
				browser: "browser",
				browser_fill: "browser_fill",
				cake: "cake",
				cake_fill: "cake_fill",
				calendar: "calendar",
				camera: "camera",
				camera_fill: "camera_fill",
				campaign: "campaign",
				caret_down: "caret_down",
				caret_down_fill: "caret_down_fill",
				caret_left: "caret_left",
				caret_left_fill: "caret_left_fill",
				caret_right: "caret_right",
				caret_right_fill: "caret_right_fill",
				caret_up: "caret_up",
				caret_up_fill: "caret_up_fill",
				chat: "chat",
				chat_fill: "chat_fill",
				chat_group: "chat_group",
				chat_group_fill: "chat_group_fill",
				chat_new: "chat_new",
				chat_new_fill: "chat_new_fill",
				checkbox: "checkbox",
				checkbox_dismiss: "checkbox_dismiss",
				checkbox_dismiss_fill: "checkbox_dismiss_fill",
				checkbox_fill: "checkbox_fill",
				checkmark: "checkmark",
				checkmark_fill: "checkmark_fill",
				chrome: "chrome",
				chrome_fill: "chrome_fill",
				clear: "clear",
				clear_fill: "clear_fill",
				close: "close",
				close_fill: "close_fill",
				closed_captioning: "closed_captioning",
				closed_captioning_fill: "closed_captioning_fill",
				code_block: "code_block",
				code_block_fill: "code_block_fill",
				code_inline: "code_inline",
				code_inline_fill: "code_inline_fill",
				coins: "coins",
				coins_fill: "coins_fill",
				coins_outline_color: "coins_outline_color",
				collapse: "collapse",
				collapse_fill: "collapse_fill",
				collection: "collection",
				collection_fill: "collection_fill",
				comment: "comment",
				comment_fill: "comment_fill",
				comments: "comments",
				comments_fill: "comments_fill",
				community: "community",
				community_fill: "community_fill",
				controversial: "controversial",
				controversial_fill: "controversial_fill",
				crop: "crop",
				crop_fill: "crop_fill",
				crosspost: "crosspost",
				crosspost_fill: "crosspost_fill",
				crowd_control: "crowd_control",
				crowd_control_fill: "crowd_control_fill",
				custom_feed: "custom_feed",
				custom_feed_fill: "custom_feed_fill",
				customize: "customize",
				customize_fill: "customize_fill",
				day: "day",
				day_fill: "day_fill",
				delete: "delete",
				delete_fill: "delete_fill",
				discover: "discover",
				discover_fill: "discover_fill",
				dismiss_all: "dismiss_all",
				dismiss_all_fill: "dismiss_all_fill",
				distinguish: "distinguish",
				distinguish_fill: "distinguish_fill",
				down: "down",
				down_fill: "down_fill",
				download: "download",
				download_fill: "download_fill",
				downvote: "downvote",
				downvote_fill: "downvote_fill",
				downvotes: "downvotes",
				downvotes_fill: "downvotes_fill",
				drag: "drag",
				duplicate: "duplicate",
				duplicate_fill: "duplicate_fill",
				edit: "edit",
				edit_fill: "edit_fill",
				effect: "effect",
				effect_fill: "effect_fill",
				embed: "embed",
				embed_fill: "embed_fill",
				emoji: "emoji",
				emoji_fill: "emoji_fill",
				expand: "expand",
				expand_fill: "expand_fill",
				external_link: "external_link",
				external_link_fill: "external_link_fill",
				feed_posts: "feed_posts",
				feed_posts_fill: "feed_posts_fill",
				feed_video: "feed_video",
				feed_video_fill: "feed_video_fill",
				filter: "filter",
				filter_fill: "filter_fill",
				format: "format",
				format_fill: "format_fill",
				forward: "forward",
				forward_fill: "forward_fill",
				gif_post: "gif_post",
				gif_post_fill: "gif_post_fill",
				heart: "heart",
				heart_fill: "heart_fill",
				help: "help",
				help_fill: "help_fill",
				hide: "hide",
				hide_fill: "hide_fill",
				history: "history",
				history_fill: "history_fill",
				home: "home",
				home_fill: "home_fill",
				hot: "hot",
				hot_fill: "hot_fill",
				ignore_reports: "ignore_reports",
				ignore_reports_fill: "ignore_reports_fill",
				image_post: "image_post",
				image_post_fill: "image_post_fill",
				info: "info",
				info_fill: "info_fill",
				italic: "italic",
				italic_fill: "italic_fill",
				join: "join",
				join_fill: "join_fill",
				joined: "joined",
				joined_fill: "joined_fill",
				jump_down: "jump_down",
				jump_down_fill: "jump_down_fill",
				jump_up: "jump_up",
				jump_up_fill: "jump_up_fill",
				karma: "karma",
				karma_fill: "karma_fill",
				keyboard: "keyboard",
				keyboard_fill: "keyboard_fill",
				kick: "kick",
				kick_fill: "kick_fill",
				leave: "leave",
				leave_fill: "leave_fill",
				left: "left",
				left_fill: "left_fill",
				link_post: "link_post",
				link_post_fill: "link_post_fill",
				list_bulleted: "list_bulleted",
				list_bulleted_fill: "list_bulleted_fill",
				list_numbered: "list_numbered",
				list_numbered_fill: "list_numbered_fill",
				live: "live",
				live_fill: "live_fill",
				load: "load",
				location: "location",
				location_fill: "location_fill",
				lock: "lock",
				lock_fill: "lock_fill",
				logout: "logout",
				logout_fill: "logout_fill",
				loop: "loop",
				loop_fill: "loop_fill",
				mark_read: "mark_read",
				mark_read_fill: "mark_read_fill",
				mask: "mask",
				mask_fill: "mask_fill",
				media_gallery: "media_gallery",
				media_gallery_fill: "media_gallery_fill",
				meme: "meme",
				meme_fill: "meme_fill",
				menu: "menu",
				menu_fill: "menu_fill",
				message: "message",
				message_fill: "message_fill",
				mod: "mod",
				mod_fill: "mod_fill",
				mod_mail: "mod_mail",
				mod_mail_fill: "mod_mail_fill",
				mod_mode: "mod_mode",
				mod_mode_fill: "mod_mode_fill",
				mod_mute: "mod_mute",
				mod_mute_fill: "mod_mute_fill",
				mod_overflow: "mod_overflow",
				mod_overflow_fill: "mod_overflow_fill",
				mod_queue: "mod_queue",
				mod_queue_fill: "mod_queue_fill",
				mod_unmute: "mod_unmute",
				mod_unmute_fill: "mod_unmute_fill",
				new: "new",
				new_fill: "new_fill",
				night: "night",
				night_fill: "night_fill",
				notification: "notification",
				notification_fill: "notification_fill",
				notification_frequent: "notification_frequent",
				notification_frequent_fill: "notification_frequent_fill",
				notification_off: "notification_off",
				notification_off_fill: "notification_off_fill",
				nsfw: "nsfw",
				nsfw_fill: "nsfw_fill",
				nsfw_language: "nsfw_language",
				nsfw_language_fill: "nsfw_language_fill",
				nsfw_violence: "nsfw_violence",
				nsfw_violence_fill: "nsfw_violence_fill",
				original: "original",
				original_fill: "original_fill",
				overflow_carat: "overflow_carat",
				overflow_carat_fill: "overflow_carat_fill",
				overflow_horizontal: "overflow_horizontal",
				overflow_vertical: "overflow_vertical",
				pause: "pause",
				pause_fill: "pause_fill",
				payment: "payment",
				payment_fill: "payment_fill",
				peace: "peace",
				peace_fill: "peace_fill",
				pending_posts: "pending_posts",
				pending_posts_fill: "pending_posts_fill",
				pin: "pin",
				pin_fill: "pin_fill",
				play: "play",
				play_fill: "play_fill",
				poll_post: "poll_post",
				poll_post_fill: "poll_post_fill",
				popular: "popular",
				popular_fill: "popular_fill",
				prediction: "prediction",
				prediction_fill: "prediction_fill",
				premium: "premium",
				premium_fill: "premium_fill",
				privacy: "privacy",
				privacy_fill: "privacy_fill",
				profile: "profile",
				profile_fill: "profile_fill",
				quarantined: "quarantined",
				quarantined_fill: "quarantined_fill",
				quote: "quote",
				quote_fill: "quote_fill",
				r_slash: "r_slash",
				r_slash_fill: "r_slash_fill",
				radio_button: "radio_button",
				radio_button_fill: "radio_button_fill",
				random: "random",
				random_fill: "random_fill",
				rating_drugs: "rating_drugs",
				rating_everyone: "rating_everyone",
				rating_mature: "rating_mature",
				rating_nsfw: "rating_nsfw",
				rating_violence: "rating_violence",
				refresh: "refresh",
				refresh_fill: "refresh_fill",
				remove: "remove",
				remove_fill: "remove_fill",
				reply: "reply",
				reply_fill: "reply_fill",
				report: "report",
				report_fill: "report_fill",
				reverse: "reverse",
				reverse_fill: "reverse_fill",
				right: "right",
				right_fill: "right_fill",
				rising: "rising",
				rising_fill: "rising_fill",
				rotate: "rotate",
				rotate_fill: "rotate_fill",
				rpan: "rpan",
				rpan_fill: "rpan_fill",
				rules: "rules",
				rules_fill: "rules_fill",
				safari: "safari",
				safari_fill: "safari_fill",
				save: "save",
				save_fill: "save_fill",
				saved: "saved",
				saved_fill: "saved_fill",
				scheduled: "scheduled",
				scheduled_fill: "scheduled_fill",
				search: "search",
				search_fill: "search_fill",
				self: "self",
				self_fill: "self_fill",
				send: "send",
				send_fill: "send_fill",
				settings: "settings",
				settings_fill: "settings_fill",
				share: "share",
				share_android: "share_android",
				share_android_fill: "share_android_fill",
				share_fill: "share_fill",
				share_ios: "share_ios",
				share_ios_fill: "share_ios_fill",
				show: "show",
				show_fill: "show_fill",
				side_menu: "side_menu",
				side_menu_fill: "side_menu_fill",
				skipback10: "skipback10",
				skipback10_fill: "skipback10_fill",
				skipforward10: "skipforward10",
				skipforward10_fill: "skipforward10_fill",
				sort: "sort",
				sort_fill: "sort_fill",
				spam: "spam",
				spam_fill: "spam_fill",
				spoiler: "spoiler",
				spoiler_fill: "spoiler_fill",
				sponsored: "sponsored",
				sponsored_fill: "sponsored_fill",
				star: "star",
				star_fill: "star_fill",
				statistics: "statistics",
				statistics_fill: "statistics_fill",
				sticker: "sticker",
				sticker_fill: "sticker_fill",
				strikethrough: "strikethrough",
				strikethrough_fill: "strikethrough_fill",
				subtract: "subtract",
				subtract_fill: "subtract_fill",
				superscript: "superscript",
				superscript_fill: "superscript_fill",
				swipe_back: "swipe_back",
				swipe_back_fill: "swipe_back_fill",
				swipe_down: "swipe_down",
				swipe_down_fill: "swipe_down_fill",
				swipe_forward: "swipe_forward",
				swipe_forward_fill: "swipe_forward_fill",
				swipe_up: "swipe_up",
				swipe_up_fill: "swipe_up_fill",
				table: "table",
				table_fill: "table_fill",
				tag: "tag",
				tag_fill: "tag_fill",
				tap: "tap",
				tap_fill: "tap_fill",
				text_post: "text_post",
				text_post_fill: "text_post_fill",
				text_size: "text_size",
				text_size_fill: "text_size_fill",
				top: "top",
				top_fill: "top_fill",
				topic: "topic",
				topic_activism: "topic_activism",
				topic_addiction_support: "topic_addiction_support",
				topic_advice: "topic_advice",
				topic_animals: "topic_animals",
				topic_anime: "topic_anime",
				topic_art: "topic_art",
				topic_beauty: "topic_beauty",
				topic_business: "topic_business",
				topic_careers: "topic_careers",
				topic_cars: "topic_cars",
				topic_celebrity: "topic_celebrity",
				topic_crafts: "topic_crafts",
				topic_crypto: "topic_crypto",
				topic_culture: "topic_culture",
				topic_diy: "topic_diy",
				topic_entertainment: "topic_entertainment",
				topic_ethics: "topic_ethics",
				topic_family: "topic_family",
				topic_fashion: "topic_fashion",
				topic_fitness: "topic_fitness",
				topic_food: "topic_food",
				topic_funny: "topic_funny",
				topic_gender: "topic_gender",
				topic_health: "topic_health",
				topic_help: "topic_help",
				topic_history: "topic_history",
				topic_internet: "topic_internet",
				topic_law: "topic_law",
				topic_learning: "topic_learning",
				topic_lifestyle: "topic_lifestyle",
				topic_mature: "topic_mature",
				topic_mensfashion: "topic_mensfashion",
				topic_menshealth: "topic_menshealth",
				topic_meta: "topic_meta",
				topic_military: "topic_military",
				topic_movies: "topic_movies",
				topic_music: "topic_music",
				topic_news: "topic_news",
				topic_other: "topic_other",
				topic_outdoors: "topic_outdoors",
				topic_pets: "topic_pets",
				topic_photography: "topic_photography",
				topic_places: "topic_places",
				topic_politics: "topic_politics",
				topic_programming: "topic_programming",
				topic_reading: "topic_reading",
				topic_reading_fill: "topic_reading_fill",
				topic_religion: "topic_religion",
				topic_science: "topic_science",
				topic_sexorientation: "topic_sexorientation",
				topic_sports: "topic_sports",
				topic_style: "topic_style",
				topic_tabletop: "topic_tabletop",
				topic_technology: "topic_technology",
				topic_television: "topic_television",
				topic_traumasupport: "topic_traumasupport",
				topic_travel: "topic_travel",
				topic_videogaming: "topic_videogaming",
				topic_womenshealth: "topic_womenshealth",
				trim: "trim",
				trim_fill: "trim_fill",
				trophy: "trophy",
				trophy_fill: "trophy_fill",
				u_slash: "u_slash",
				u_slash_fill: "u_slash_fill",
				unban: "unban",
				unban_fill: "unban_fill",
				undo: "undo",
				undo_fill: "undo_fill",
				unheart: "unheart",
				unlock: "unlock",
				unlock_fill: "unlock_fill",
				unmod: "unmod",
				unmod_fill: "unmod_fill",
				unpin: "unpin",
				unpin_fill: "unpin_fill",
				unverified: "unverified",
				unverified_fill: "unverified_fill",
				up: "up",
				up_fill: "up_fill",
				upload: "upload",
				upload_fill: "upload_fill",
				upvote: "upvote",
				upvote_fill: "upvote_fill",
				upvotes: "upvotes",
				upvotes_fill: "upvotes_fill",
				user: "user",
				user_fill: "user_fill",
				user_note: "user_note",
				user_note_fill: "user_note_fill",
				vault: "vault",
				vault_fill: "vault_fill",
				verified: "verified",
				verified_fill: "verified_fill",
				video_camera: "video_camera",
				video_camera_fill: "video_camera_fill",
				video_live: "video_live",
				video_live_fill: "video_live_fill",
				video_post: "video_post",
				video_post_fill: "video_post_fill",
				view_card: "view_card",
				view_card_fill: "view_card_fill",
				view_classic: "view_classic",
				view_classic_fill: "view_classic_fill",
				view_compact: "view_compact",
				view_compact_fill: "view_compact_fill",
				view_grid_fill: "view_grid_fill",
				view_grid_fill_1: "view_grid_fill_1",
				views: "views",
				views_fill: "views_fill",
				volume: "volume",
				volume_fill: "volume_fill",
				volume_mute: "volume_mute",
				volume_mute_fill: "volume_mute_fill",
				wiki: "wiki",
				wiki_fill: "wiki_fill",
				wiki_ban: "wiki_ban",
				wiki_ban_fill: "wiki_ban_fill",
				wiki_unban: "wiki_unban",
				wiki_unban_fill: "wiki_unban_fill",
				world: "world",
				world_fill: "world_fill"
			}
		},
		"./src/lib/constants/specialMembership.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "custom"
		},
		"./src/lib/forceHttps/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return e.startsWith("http") || e.startsWith("blob") ? e.replace(/^http:\/\//i, "https://") : `https://${e}`
			}
		},
		"./src/lib/formatApiError/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");

			function o(e, t) {
				return e ? e.fields && e.fields.length ? e.fields.map(e => e.msg).join(", ") : e.type && i[e.type] ? i[e.type]() : 401 === t ? s.fbt._("There was an authentication error", null, {
					hk: "2KZTRv"
				}) : s.fbt._("Something went wrong", null, {
					hk: "3i6szH"
				}) : ""
			}
			const i = {
				[r.l]: () => s.fbt._("you're not allowed to do that", null, {
					hk: "1jGKQw"
				}),
				[r.O]: () => s.fbt._("GIF size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.eb / r.mb).toString())], {
					hk: "1zzsdM"
				}),
				[r.W]: () => s.fbt._("Image size must be less than {max file size}MB", [s.fbt._param("max file size", Math.floor(r.gb / r.mb).toString())], {
					hk: "3H6bF8"
				}),
				[r.Y]: () => s.fbt._("Sorry, we accept only images (.png, .jpeg, .gif) and videos (.mp4, .mov)", null, {
					hk: "1hw868"
				}),
				[r.vc]: () => s.fbt._("Video size must be less than {max file size}GB", [s.fbt._param("max file size", (r.kb / r.mb / 1024).toFixed(1))], {
					hk: "4FkABU"
				})
			}
		},
		"./src/lib/getShortenedLink.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/Media/index.ts"),
				r = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				o = n.n(r);
			t.a = function(e) {
				var t;
				const {
					source: n,
					isSponsored: r,
					domainOverride: i,
					callToAction: a
				} = e;
				let d = "";
				if (r) {
					if (n && n.displayText) {
						const e = 36 - (null !== (t = null == a ? void 0 : a.length) && void 0 !== t ? t : 0);
						return n.displayText.length > e ? n.displayText.substring(0, e - 3) + "..." : n.displayText
					}
					d = i || Object(s.D)(e)
				} else d = Object(s.D)(e);
				const c = o.a.parse(d),
					l = c.path || "",
					u = l.length > 7 ? l.substring(0, 7) + "..." : l;
				return (c.hostname ? c.hostname.replace("www.", "") : "") + u
			}
		},
		"./src/lib/hooks/useOnClickOutside.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e, t) {
				const n = Object(s.useCallback)(n => {
					if (!t) return;
					const s = document.getElementById(e);
					s && (s.contains(n.target) || t(n))
				}, [e, t]);
				Object(s.useEffect)(() => {
					if (t) return window.addEventListener("click", n), () => {
						window.removeEventListener("click", n)
					}
				}, [t, n])
			}
		},
		"./src/lib/hooks/usePrevious.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/react/index.js");

			function r(e) {
				const t = Object(s.useRef)();
				return Object(s.useEffect)(() => {
					t.current = e
				}), t.current
			}
		},
		"./src/lib/hooks/useTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./node_modules/react-popper/lib/esm/usePopper.js");
			const i = Object(s.freeze)({
				modifiers: []
			});

			function a(e) {
				let t = "object" == typeof e ? e : i;
				return Array.isArray(t.modifiers) || (t = Object(s.assoc)(t, "modifiers", i.modifiers)), t
			}

			function d(e) {
				const [t, n] = Object(r.useState)(null), [i, d] = Object(r.useState)(null), [c, l] = Object(r.useState)(null), [u, m] = Object(r.useState)(!1), p = Object(r.useCallback)(async () => m(!0), []), b = Object(r.useCallback)(() => m(!1), []), f = Object(r.useCallback)(() => m(!u), [u]), h = Object(r.useMemo)(() => {
					const t = a(e);
					return c ? Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, {
						name: "arrow",
						options: {
							element: c
						}
					})) : t
				}, [c, e]), {
					attributes: _,
					styles: g,
					update: v
				} = Object(o.a)(t, i, h);
				return Object(r.useMemo)(() => ({
					arrowProps: {
						ref: l,
						style: g.arrow,
						..._.arrow
					},
					hide: b,
					popperProps: {
						ref: d,
						style: g.popper,
						..._.popper
					},
					show: p,
					target: {
						element: t,
						ref: n
					},
					toggle: f,
					visible: u,
					update: v
				}), [l, _, d, b, p, g, t, n, f, u, v])
			}
		},
		"./src/lib/humanizeDate/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/intlSupport.ts");

			function i(e) {
				let {
					showDay: t,
					useUtc: n,
					shortMonths: i,
					locale: a = s.DEFAULT_LOCALE
				} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				const d = new Date(e * r.Xb);
				return o.a ? new Intl.DateTimeFormat(a, {
					month: i ? "short" : "long",
					day: t ? "numeric" : void 0,
					year: "numeric",
					timeZone: n ? "UTC" : void 0
				}).format(d) : d.toLocaleString()
			}
		},
		"./src/lib/humanizeUTCDate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js");
			t.a = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s.DEFAULT_LOCALE;
				const n = e.toString().length > 10,
					r = new Date(e * (n ? 1 : 1e3));
				return r.toLocaleString(t, {
					weekday: "short",
					month: "short",
					year: "numeric",
					day: "2-digit",
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
					timeZoneName: "short",
					timeZone: "UTC"
				})
			}
		},
		"./src/lib/linkMatchers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "h", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			}));
			var s = n("./node_modules/linkify-it/index.js"),
				r = n.n(s),
				o = n("./node_modules/tlds/index.js"),
				i = n.n(o),
				a = n("./src/lib/linkMatchers/customLinks.ts"),
				d = n("./node_modules/lodash/values.js"),
				c = n.n(d);
			const l = e => c()(a.b).includes(e.substring(1)),
				u = ["//", "ftp:", "http:", "https:", "mailto:"],
				m = e => ((e, t) => (t.forEach(t => e.add(t, null)), e))(e, u),
				p = r()().tlds(i.a).set({
					fuzzyIP: !0
				}),
				b = r()().set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.mention.prefix, a.g.mention.config),
				f = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config),
				h = m(r()()).set({
					fuzzyLink: !1,
					fuzzyEmail: !1
				}).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config),
				_ = r()().tlds(i.a).set({
					fuzzyIP: !0
				}).add(a.g.subreddit.prefix, a.g.subreddit.config).add(a.g.subredditFull.prefix, a.g.subreddit.config).add(a.g.profile.prefix, a.g.profile.config).add(a.g.profileFull.prefix, a.g.profile.config).add(a.g.mention.prefix, a.g.mention.config),
				g = r()().tlds(i.a).set({
					fuzzyIP: !0,
					fuzzyEmail: !1
				}).add(a.g.subreddit.prefix, a.g.subredditFullUrl.config).add(a.g.subredditFull.prefix, a.g.subredditFullUrl.config),
				v = p.normalize;
			p.normalize = e => {
				v.call(p, e), !e.schema && e.url.startsWith("http:") && (e.url = `https:${e.url.slice(5)}`)
			};
			const x = (e, t) => {
					return (_.match(e) || []).filter(e => {
						const n = l(e.text);
						return !n || n && t
					})
				},
				O = e => {
					return [...h.match(e) || [], ...b.match(e) || []].map(e => !l(e.text) && e.text.replace(a.a, "")).filter(e => e)
				},
				E = (e, t) => {
					const n = e.match(t);
					if (n && 1 === n.length && 0 === n[0].index && n[0].lastIndex === t.length) return n[0]
				},
				y = e => {
					const t = p.match(e);
					if (t && 1 === t.length && 0 === t[0].index) {
						const n = t[0];
						return n.lastIndex === e.length ? n : ((e, t) => {
							const n = e.substring(t.lastIndex);
							if (/.*\/\/.*\/.*/.test(t.url) && /^(\?|\!)+$/.test(n)) return t.lastIndex += n.length, t.url += n, t
						})(e, n)
					}
				}
		},
		"./src/lib/loginHref/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/history/esm/history.js");
			t.a = (e, t, n) => {
				const o = Object(r.e)(e),
					i = encodeURIComponent(`${t}${o}`);
				return `${s.a.accountManagerOrigin}${n||"/login"}?dest=${i}`
			}
		},
		"./src/lib/makePostDraftPageKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let t = "PostDraftPage";
				return e.draftId && (t += `--[draftId:${e.draftId}]`), t
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/memoizeByReference/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/lodash/every.js"),
				r = n.n(s);

			function o(e) {
				let t = null,
					n = null;
				return function() {
					for (var s = arguments.length, o = new Array(s), i = 0; i < s; i++) o[i] = arguments[i];
					return null !== t && o.length === t.length && r()(o, (e, n) => e === t[n]) || (t = o, n = e(...o)), n
				}
			}
		},
		"./src/lib/name/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/reddit/helpers/name/index.ts");
			const r = /^u_[\w-]+$/;

			function o(e) {
				return r.test(Object(s.i)(e))
			}

			function i(e) {
				return `u_${Object(s.i)(e)}`
			}

			function a(e, t) {
				return Object(s.i)(e) === Object(s.i)(t)
			}
		},
		"./src/lib/omitKey/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (t in e) {
					const {
						[t]: n, ...s
					} = e;
					return s
				}
				return e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/onFocusAndVisibilityChange/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/brcast/dist/brcast.es.js");
			const r = () => "undefined" != typeof document,
				o = () => r() && "visible" === document.visibilityState,
				i = () => ({
					documentInFocus: o()
				}),
				{
					subscribe: a,
					unsubscribe: d,
					setState: c
				} = Object(s.a)(i()),
				l = {
					hidden: "visibilitychange",
					webkitHidden: "webkitvisibilitychange",
					mozHidden: "mozvisibilitychange",
					msHidden: "msvisibilitychange"
				},
				u = () => c(i());
			(() => {
				const e = (() => {
					if (!r()) return;
					const e = Object.keys(l).find(e => e in document);
					return e ? l[e] : void 0
				})();
				e && document.addEventListener(e, u)
			})(), t.a = {
				isDocumentHidden: () => !o(),
				isDocumentVisible: o,
				subscribe: a,
				unsubscribe: d
			}
		},
		"./src/lib/pageTitle/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/@reddit/reddit-country-url-redirects/dist/esm/index.js"),
				i = n("./src/reddit/selectors/countrySites.ts"),
				a = n("./src/reddit/selectors/meta.ts");
			const d = (e, t, n) => {
				const {
					languageCode: d
				} = Object(i.c)(e), c = n || (Object(a.j)(e) || r.DEFAULT_LOCALE), l = Object(s.isPseudoLocale)(c) ? r.DEFAULT_LOCALE : c;
				if (d) {
					const e = Object(o.d)(d, l.substring(0, 2));
					return t + (e ? ` - ${e}` : "")
				}
				return t
			}
		},
		"./src/lib/scroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/domUtils/index.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/components/CommentSort/index.tsx"),
				i = n("./src/reddit/constants/elementIds.ts");
			const a = () => {
					r.a.write(() => {
						const e = document.getElementById(i.e);
						e ? Object(s.c)(e, 0) : Object(s.c)(document, 0)
					})
				},
				d = e => {
					r.a.read(() => {
						const t = e ? document.getElementById(i.e) : window,
							n = document.getElementById(o.a);
						if (t && n) {
							const s = e ? n.offsetTop : n.offsetTop - 50;
							r.a.write(() => t.scrollTo({
								top: s,
								behavior: "smooth"
							}))
						}
					})
				}
		},
		"./src/lib/stringInterpolate/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return e && t ? e.replace(/%\{(\w+)\}/g, (e, n) => {
					const s = t[n];
					return null == s ? n : String(s)
				}) : e
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/lib/stripQueryParams/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n.n(s);
			t.a = e => {
				const t = r.a.parse(e);
				return t.search = void 0, t.query = null, r.a.format(t)
			}
		},
		"./src/lib/timeUntil/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			const o = [r.yc, r.ub, r.E, r.U, r.pb, r.Xb],
				i = {
					[r.Xb]: e => s.fbt._({
						"*": "{number} seconds",
						_1: "1 second"
					}, [s.fbt._plural(e, "number")], {
						hk: "3pTp9Z"
					}),
					[r.pb]: e => s.fbt._({
						"*": "{number} minutes",
						_1: "1 minute"
					}, [s.fbt._plural(e, "number")], {
						hk: "2gB3sf"
					}),
					[r.U]: e => s.fbt._({
						"*": "{number} hours",
						_1: "1 hour"
					}, [s.fbt._plural(e, "number")], {
						hk: "2w4n8B"
					}),
					[r.E]: e => s.fbt._({
						"*": "{number} days",
						_1: "1 day"
					}, [s.fbt._plural(e, "number")], {
						hk: "3zIGRH"
					}),
					[r.ub]: e => s.fbt._({
						"*": "{number} months",
						_1: "1 month"
					}, [s.fbt._plural(e, "number")], {
						hk: "28DQqD"
					}),
					[r.yc]: e => s.fbt._({
						"*": "{number} years",
						_1: "1 year"
					}, [s.fbt._plural(e, "number")], {
						hk: "Gqzh3"
					})
				},
				a = {
					[r.Xb]: e => s.fbt._("{amount}s", [s.fbt._param("amount", String(e))], {
						hk: "F4qog"
					}),
					[r.pb]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "43tM5H"
					}),
					[r.U]: e => s.fbt._("{amount}h", [s.fbt._param("amount", String(e))], {
						hk: "19NsxU"
					}),
					[r.E]: e => s.fbt._("{amount}d", [s.fbt._param("amount", String(e))], {
						hk: "39MDc9"
					}),
					[r.ub]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					}),
					[r.ub]: e => s.fbt._("{amount}m", [s.fbt._param("amount", String(e))], {
						hk: "28feBj"
					}),
					[r.yc]: e => s.fbt._("{amount}y", [s.fbt._param("amount", String(e))], {
						hk: "10bv8G"
					})
				};

			function d(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
					n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				const d = Date.now(),
					c = new Date(e).getTime(),
					l = {
						[r.yc]: "",
						[r.ub]: "",
						[r.E]: "",
						[r.U]: "",
						[r.pb]: "",
						[r.Xb]: ""
					};
				let u = c - d;
				if (u <= 0) return s.fbt._("a moment", null, {
					hk: "3QLaye"
				}).toString();
				for (const s of o) {
					const e = Math.floor(u / s);
					e && (l[s] = (t ? a : i)[s](e).toString()), u -= e * s
				}
				const m = o.map(e => l[e]).filter(Boolean).slice(0, 2).join(" ");
				return t || n ? m : s.fbt._("{amount of time left} left", [s.fbt._param("amount of time left", m)], {
					hk: "7VjAI"
				}).toString()
			}
		},
		"./src/reddit/actions/apiRequestState.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/models/ApiRequestState/index.ts");
			const o = "API_REQUEST_STATE__STARTED",
				i = "API_REQUEST_STATE__COMPLETED",
				a = "API_REQUEST_STATE__FAILED",
				d = "API_REQUEST_STATE__RELEASED";

			function c(e) {
				return {
					type: o,
					payload: {
						apiRequestStatus: r.a.Pending,
						apiRequestId: e
					}
				}
			}

			function l(e) {
				return {
					type: i,
					payload: {
						apiRequestStatus: r.a.Complete,
						apiRequestId: e
					}
				}
			}

			function u(e, t) {
				return {
					type: a,
					payload: {
						apiRequestStatus: r.a.Failed,
						apiRequestId: e,
						apiError: t
					}
				}
			}
			const m = Object(s.a)(d)
		},
		"./src/reddit/actions/appBadgeIndicators/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			const s = "APP_BADGES__PENDING",
				r = "APP_BADGES__LOADED",
				o = "APP_BADGES__UPDATED",
				i = "APP_BADGES__FAILED"
		},
		"./src/reddit/actions/appBadgeIndicators/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "b", (function() {
				return _
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/appBadgeIndicators/constants.ts"),
				o = n("./src/reddit/actions/tabBadging.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/BadgeIndicators.json"),
				d = e => Object(i.a)(e, {
					...a
				}),
				c = n("./src/reddit/models/Badge/index.ts");
			const l = Object(s.a)(r.c),
				u = Object(s.a)(r.b),
				m = Object(s.a)(r.d),
				p = Object(s.a)(r.a),
				b = e => {
					let {
						key: t,
						count: n
					} = e;
					return {
						[t]: {
							count: n,
							style: c.b.Numbered
						}
					}
				},
				f = (e, t) => ({
					[c.c.ChatUnreadMessages]: {
						count: e,
						style: c.b.Numbered
					},
					[c.c.ChatHasNewMessages]: {
						isShowing: t,
						style: c.b.Filled
					}
				}),
				h = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					e(l());
					const r = await async function(e) {
						const t = await d(e());
						if (t.ok && t.body) {
							return function(e) {
								var t;
								const n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.badgeIndicators;
								if (n) return {
									...n,
									chatUnreadMessages: {
										count: (Number(n.chatUnreadMessages.count) || 0) + (Number(n.chatUnacceptedInvites.count) || 0) + (Number(n.chatUnreadMentions.count) || 0)
									}
								}
							}(t.body)
						}
					}(s);
					r ? (e(u(r)), e(Object(o.d)())) : e(p())
				};
			const _ = () => async e => {
				const t = b({
					key: c.c.MessageTab,
					count: 0
				});
				e(m(t))
			}
		},
		"./src/reddit/actions/bulkActions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/bulkActions/constants.ts");
			const o = Object(s.a)(r.c),
				i = Object(s.a)(r.b),
				a = Object(s.a)(r.a)
		},
		"./src/reddit/actions/comment/authoring.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return fe
			})), n.d(t, "r", (function() {
				return ge
			})), n.d(t, "p", (function() {
				return ve
			})), n.d(t, "t", (function() {
				return Ee
			})), n.d(t, "w", (function() {
				return ye
			})), n.d(t, "q", (function() {
				return Ce
			})), n.d(t, "v", (function() {
				return Ie
			})), n.d(t, "o", (function() {
				return Se
			})), n.d(t, "m", (function() {
				return Te
			})), n.d(t, "b", (function() {
				return Pe
			})), n.d(t, "c", (function() {
				return Me
			})), n.d(t, "s", (function() {
				return Le
			})), n.d(t, "g", (function() {
				return De
			})), n.d(t, "h", (function() {
				return Fe
			})), n.d(t, "k", (function() {
				return Ue
			})), n.d(t, "e", (function() {
				return qe
			})), n.d(t, "d", (function() {
				return Ve
			})), n.d(t, "a", (function() {
				return ze
			})), n.d(t, "j", (function() {
				return Ke
			})), n.d(t, "i", (function() {
				return Xe
			})), n.d(t, "l", (function() {
				return Ze
			})), n.d(t, "u", (function() {
				return $e
			})), n.d(t, "n", (function() {
				return et
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeDraftKey/index.ts"),
				i = n("./src/lib/scroll/index.ts"),
				a = n("./src/reddit/actions/changeUsername.ts"),
				d = n("./src/reddit/actions/login.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/onboarding/index.ts"),
				u = n("./src/reddit/actions/post.ts"),
				m = n("./src/reddit/actions/postCreation/editorContent.ts"),
				p = n("./src/reddit/actions/publicAccessNetwork/automute.ts"),
				b = n("./src/reddit/actions/shortcuts/utils.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/constants/adEvents.ts"),
				_ = n("./src/reddit/constants/localStorage.ts"),
				g = n("./src/redditGQL/operations/CommentToxicity.json"),
				v = n("./src/lib/constants/index.ts"),
				x = n("./src/lib/makeApiRequest/index.ts"),
				O = n("./src/lib/makeGqlRequest/index.ts"),
				E = n("./src/lib/omitHeaders/index.ts"),
				y = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				C = n("./src/reddit/constants/headers.ts"),
				j = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				k = n("./src/reddit/helpers/genericServerError/index.ts"),
				I = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				S = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				w = n("./src/reddit/models/PostCreationForm/index.ts"),
				T = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				N = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				P = n("./src/reddit/helpers/graphql/helpers.ts"),
				R = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				A = n("./src/redditGQL/operations/CreateComment.json");
			const M = (e, t, n, s) => {
					let r, o;
					if (s === w.i.MARKDOWN) r = n.text, o = null;
					else {
						r = null;
						let e = null;
						n.rteState && (e = y.a.toRichTextJSON(n.rteState).document), o = JSON.stringify({
							document: e
						})
					}
					return Object(O.a)(e, {
						...g,
						variables: {
							subredditName: t,
							markdown: r,
							richText: o
						}
					}).then(e => !e.ok || e.body.data.isValidComment)
				},
				L = async (e, t, n, s) => {
					const r = {
						api_type: "json",
						return_rtjson: !0,
						thing_id: t
					};
					return n.commentMode === w.i.MARKDOWN ? r.text = n.text : (r.text = null, r.richtext_json = s), Object(x.a)(Object(E.a)(e, [C.a]), {
						method: v.ob.POST,
						endpoint: Object(j.a)(Object(T.a)(Object(N.a)(`${e.apiUrl}/api/comment.json`))),
						data: r
					}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(S.a)(e)
					} : {
						...e,
						body: {
							comment: Object(I.a)(e.body.json.data.things[0].data)
						}
					} : {
						...e,
						body: {
							comment: Object(I.a)(e.body)
						}
					} : {
						...e,
						error: e.error || Object(k.a)()
					})
				}, D = async (e, t, n, s, r) => {
					const o = s.commentMode === w.i.MARKDOWN,
						i = {
							postId: t || null,
							parentId: n || null,
							content: {
								markdown: o ? s.text : null,
								richText: o ? null : r
							}
						};
					return Object(O.a)(e, {
						...A,
						variables: {
							input: i
						}
					}).then(e => {
						if (e.ok) {
							const t = e.body.data.createComment;
							if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
								...e,
								ok: !1,
								error: Object(P.e)(t.fieldErrors)
							};
							if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
								...e,
								ok: !1,
								error: Object(P.f)(t.errors)
							};
							if (t.ok) return {
								...e,
								body: {
									comment: Object(R.a)(t.commentInfo)
								}
							}
						}
						return {
							...e,
							ok: !1,
							error: e.error || Object(k.a)()
						}
					})
				};
			var F = n("./src/redditGQL/operations/UpdateComment.json");
			var U = n("./src/redditGQL/operations/UpdateCommentFollowState.json");
			var B = n("./src/reddit/endpoints/post/index.tsx"),
				q = n("./src/reddit/endpoints/post/convert.ts"),
				G = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				H = n("./src/reddit/featureFlags/index.ts"),
				W = n("./src/reddit/helpers/comment/index.ts"),
				V = n("./src/reddit/helpers/correlationIdTracker.ts"),
				z = n("./src/reddit/helpers/dom/index.ts"),
				K = n("./src/reddit/helpers/localStorage/index.ts"),
				Q = n("./src/reddit/helpers/sessionStorage/index.ts"),
				Y = n("./src/reddit/helpers/trackers/commentsPage.ts"),
				J = n("./src/reddit/models/Comment/index.ts"),
				X = n("./src/reddit/models/PostDraft/index.ts"),
				Z = n("./src/reddit/models/RichTextJson/index.ts"),
				$ = n("./src/reddit/models/RichTextJson/nodeMakers.ts"),
				ee = n("./src/reddit/models/Toast/index.ts"),
				te = n("./src/reddit/selectors/chatPost.ts"),
				ne = n("./src/reddit/selectors/comments.ts"),
				se = n("./src/reddit/selectors/commentSelector.ts"),
				re = n("./src/reddit/constants/experiments.ts"),
				oe = n("./src/reddit/helpers/chooseVariant/index.ts"),
				ie = n("./node_modules/reselect/es/index.js");
			const ae = Object(ie.a)(e => Object(oe.c)(e, {
				experimentEligibilitySelector: oe.a,
				experimentName: re.Cb
			}), e => e === re.Kd);
			var de = n("./src/reddit/selectors/experiments/contributeBeforeSignUp.ts"),
				ce = n("./src/reddit/selectors/platform.ts"),
				le = n("./src/reddit/selectors/posts.ts"),
				ue = n("./src/reddit/selectors/user.ts"),
				me = n("./src/reddit/actions/comment/index.ts"),
				pe = n("./src/reddit/actions/comment/constants.ts");
			const be = Object(r.a)(pe.m),
				fe = e => {
					let {
						hasFocus: t,
						draftKey: n
					} = e;
					return async (e, s) => {
						const r = s();
						if (!!r.features.comments.drafts[n])
							if (Object(ue.T)(r) && t) {
								const s = be({
									hasFocus: t,
									draftKey: n
								});
								e(Object(a.startChangeUsernameFlow)(s))
							} else e(be({
								hasFocus: t,
								draftKey: n
							}))
					}
				},
				he = Object(r.a)(pe.L),
				_e = Object(r.a)(pe.H),
				ge = Object(r.a)(pe.N),
				ve = Object(r.a)(pe.M),
				xe = Object(r.a)(pe.K),
				Oe = async (e, t, n, s, r) => {
					const o = s.ok && s.body,
						i = o && o.comment && o.comment.id;
					await Y.g(e, n, t, r, i)
				}, Ee = "Toxicity_Warning__Modal", ye = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(ce.e)(o);
					let a = "";
					i && (a = i.name);
					const {
						formData: d,
						editorMode: l
					} = e;
					if (H.d.enableToxicityWarning(o)) {
						if (!(await M(r(), a, d, l))) return void t(Object(c.i)(Ee))
					}
					t(Ce(e))
				}, Ce = e => async (t, n) => {
					t(Object(c.g)(Ee));
					const s = n(),
						r = Object(de.a)(s),
						o = Object(de.c)(s);
					if (!s.user.account && r) {
						const n = Object(W.e)(e.formData, s.uploads),
							r = Object(W.c)(e.formData, s.uploads);
						t(Object(c.k)({
							actionSource: c.a.Reply
						})), t(Object(d.openRegisterModal)()), Object(Q.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: o
						})
					} else t(ke(e, !1))
				};

			function je(e, t) {
				return e === w.i.MARKDOWN && ae(t)
			}
			const ke = (e, t, n, r) => {
					let {
						postId: o,
						commentsPageKey: a,
						draftKey: d,
						formData: c,
						editorMode: l,
						disableAutofocus: m,
						isLiveStreaming: _
					} = e;
					return async (e, g, v) => {
						let {
							apiContext: x,
							gqlContext: O
						} = v;
						var E;
						const y = g(),
							C = Object(te.d)(y, {
								postId: o
							}),
							j = C ? Object(W.a)() : d,
							k = Object(se.e)(y, {
								commentId: j
							}),
							I = Object(ue.l)(y);
						if (!I) return;
						if (k && !C) return;
						t || e(he({
							draftKey: j,
							draft: c,
							commentsPageKey: a,
							optimisticComment: C ? Object(W.b)({
								temporalId: j,
								draft: c,
								post: Object(le.G)(y, {
									postId: o
								}),
								author: I,
								subredditId: (null === (E = Object(ce.e)(y)) || void 0 === E ? void 0 : E.id) || ""
							}) : void 0
						}));
						const S = I.displayText,
							T = c.commentMode;
						let N;
						const P = _ ? "" : t && n ? n : Object(W.e)(c, y.uploads),
							R = Object(W.f)(P, y.uploads);
						if (_ ? (N = await Object(G.i)(x(), o, c, S), e(Object(p.a)({
								streamId: o,
								level: N.body.automuteLevel
							}))) : N = je(T, y) ? await D(O(), o, null, c, P) : await L(x(), o, c, P), N.ok) {
							let n;
							if (n = N.body, e(ge({
									...n,
									headCommentId: Object(ne.w)(y, {
										commentsPageKey: a
									}),
									commentsPageKey: a,
									draftKey: j,
									upload: R
								})), t) {
								const e = Object(ce.j)(y);
								Object(i.a)(!!e)
							}
							const s = Object(le.G)(g(), {
								postId: o
							});
							e(Object(u.y)(s, h.a.CommentSubmitted))
						} else {
							if (N.error) {
								const e = t && r ? r : Object(W.c)(c, y.uploads);
								Y.f({
									state: y,
									bodyText: e,
									postId: o,
									error: N.error,
									uploadMetadata: null == R ? void 0 : R.metadata
								})
							}
							const n = N.error && N.error.fields && N.error.fields[0] ? N.error.fields[0].msg : s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							});
							e(xe({
								draftKey: j,
								error: N.error
							})), C || e(Object(f.f)({
								duration: f.a,
								kind: ee.b.Error,
								text: n
							}))
						}
						Oe(g(), a, l, N, null == R ? void 0 : R.metadata).then(() => N.ok && l === w.i.RICH_TEXT ? Object(V.b)(V.a.CommentComposer) : void 0), m || Object(b.d)(), t && Object(Q.a)()
					}
				},
				Ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const {
						parentCommentId: o,
						commentsPageKey: i,
						parentCommentDepth: a,
						draftKey: d,
						formData: l,
						editorMode: u
					} = e, m = n(), p = Object(ce.e)(m);
					let b = "";
					if (p && (b = p.name), H.d.enableToxicityWarning(m)) {
						if (!(await M(r(), b, l, u))) return void t(Object(c.i)(Ee))
					}
					t(Se({
						commentsPageKey: i,
						draftKey: d,
						parentCommentDepth: a,
						parentCommentId: o,
						formData: l,
						editorMode: u
					}))
				}, Se = e => async (t, n) => {
					t(Object(c.g)(Ee));
					const s = n(),
						r = Object(de.a)(s),
						o = Object(de.c)(s);
					if (!s.user.account && r) {
						const n = Object(W.e)(e.formData, s.uploads),
							r = Object(W.c)(e.formData, s.uploads);
						t(Object(c.k)({
							actionSource: c.a.Reply
						})), t(Object(d.openRegisterModal)()), Object(Q.d)({
							comment: {
								...e,
								richTextJSONData: n,
								commentBodyText: r
							},
							isSkipOnboarding: o
						})
					} else t(we(e, !1))
				}, we = (e, t, n, s) => async (r, o, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					var l;
					const {
						parentCommentId: u,
						commentsPageKey: m,
						parentCommentDepth: p,
						draftKey: f,
						formData: h,
						editorMode: _
					} = e, g = o(), v = Object(se.b)(g, {
						commentId: u
					}), x = v && Object(te.d)(g, {
						postId: v.postId
					}), O = x ? Object(W.a)() : f, E = Object(se.e)(g, {
						commentId: O
					}), y = Object(ue.l)(g);
					if (!y) return;
					if (E && !x) return;
					t || r(he({
						draftKey: O,
						draft: h,
						commentsPageKey: m,
						optimisticComment: x && v ? Object(W.b)({
							temporalId: O,
							draft: h,
							post: Object(le.G)(g, {
								postId: v.postId
							}),
							author: y,
							subredditId: (null === (l = Object(ce.e)(g)) || void 0 === l ? void 0 : l.id) || "",
							parentId: v.id
						}) : void 0
					})), r(Pe({
						parentCommentId: u,
						commentsPageKey: m
					}));
					const C = h.commentMode,
						j = t && n ? n : Object(W.e)(h, g.uploads),
						k = Object(W.f)(j, g.uploads);
					let I;
					if ((I = je(C, g) ? await D(c(), null, u, h, j) : await L(d(), u, h, j)).ok) {
						if (r(ve({
								...I.body,
								parentCommentId: u,
								commentsPageKey: m,
								draftKey: O,
								depth: p + 1,
								upload: k
							})), t) {
							const e = Object(ce.j)(g);
							Object(i.a)(!!e)
						}
					} else {
						if (I.error) {
							if (!v) return;
							const e = t && s ? s : Object(W.c)(h, g.uploads);
							Y.f({
								state: g,
								bodyText: e,
								postId: v.postId,
								parentId: u,
								error: I.error,
								uploadMetadata: null == k ? void 0 : k.metadata
							})
						}
						r(xe({
							draftKey: O,
							error: I.error
						}))
					}
					Oe(o(), m, _, I, null == k ? void 0 : k.metadata), Object(b.d)(), t && Object(Q.a)()
				}, Te = () => async e => {
					const t = Object(Q.b)();
					if (t) {
						const {
							comment: {
								parentCommentDepth: n,
								parentCommentId: s,
								postId: r,
								richTextJSONData: o,
								commentBodyText: i
							},
							isSkipOnboarding: a
						} = t;
						a && e(Object(l.skipOnboardingModal)()), r ? await e(ke({
							...t.comment,
							postId: r
						}, !0, o, i)) : s && void 0 !== n && await e(we({
							...t.comment,
							parentCommentId: s,
							parentCommentDepth: n
						}, !0, o, i))
					}
				}, Ne = Object(r.a)(pe.s), Pe = Object(r.a)(pe.r), Re = Object(r.a)(pe.n), Ae = (Object(r.a)(pe.i), Object(r.a)(pe.o)), Me = (Object(r.a)(pe.v), (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					const d = e === w.i.RICH_TEXT;
					if (!t || "object" == typeof t && Object(Z.H)(t)) r(Ae({
						editorMode: e,
						draftKey: n,
						content: d ? Z.i : ""
					})), r(Object(m.c)(e));
					else {
						r(Object(m.b)(n));
						const o = await Object(q.a)(a(), e, d ? t : JSON.stringify(t));
						if (o.ok) {
							const t = o.body.output;
							r(Object(m.a)(n)), r(Ae({
								editorMode: e,
								draftKey: n,
								content: t
							})), r(Object(m.c)(e))
						} else r(Object(m.a)(n)), r(Object(f.f)({
							duration: f.a,
							kind: ee.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "LWFS0"
							})
						}))
					}
				}), Le = e => {
					let {
						commentsPageKey: t,
						parentCommentId: n,
						singleOpen: s
					} = e;
					return async (e, r) => {
						const i = r(),
							l = Object(o.a)(X.c.replyToComment, n);
						if (!Object(ue.R)(r()) && !Object(de.a)(i)) return e(Object(d.openRegisterModal)()), void e(Object(c.k)({
							actionSource: c.a.Reply,
							redirectUrl: Object(ne.m)(r(), {
								commentId: n
							})
						}));
						const u = i.features.comments.replyFormOpen[t],
							m = u && u[n];
						if ((m || u && s) && (Object.keys(u).forEach(n => u[n] && e(Pe({
								parentCommentId: n,
								commentsPageKey: t
							}))), m)) return;
						let p = "",
							b = null;
						const f = i.user.prefs.commentMode,
							h = Object(z.d)();
						if (h) {
							const e = h.filter(e => !!e && 10 !== e.charCodeAt(0));
							if (f === w.i.MARKDOWN) p = e.map(e => `> ${e}\n`).join("");
							else {
								const t = e.map(e => $.s(e, null)).map(e => $.l([e])),
									n = $.s("", null),
									s = $.l([n]);
								b = {
									document: [$.c(t), s]
								}
							}
						}
						const _ = i.features.comments.drafts[l];
						let g;
						if (g = h ? {
								commentMode: f,
								draftType: X.c.replyToComment,
								rtJson: b,
								text: `${p}\n`
							} : _ || {
								commentMode: f,
								draftType: X.c.replyToComment,
								rtJson: b,
								text: ""
							}, Object(ue.T)(i)) {
							const s = Ne({
								parentCommentId: n,
								commentsPageKey: t,
								draftKey: l,
								formData: g
							});
							e(Object(a.startChangeUsernameFlow)(s))
						} else e(Ne({
							parentCommentId: n,
							commentsPageKey: t,
							draftKey: l,
							formData: g
						}))
					}
				}, De = e => async t => {
					t(Object(me.r)(e)), t(qe(e))
				}, Fe = e => {
					let {
						parentCommentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(Pe({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Le({
							parentCommentId: t,
							commentsPageKey: n
						})), e(Object(me.r)({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, Ue = (e, t) => n => n(Re({
					draftKey: e,
					formData: t
				})), Be = Object(r.a)(pe.u), qe = e => {
					let {
						commentId: t,
						commentMode: n,
						commentsPageKey: s,
						draftKey: r,
						text: o
					} = e;
					return async (e, i) => {
						const a = i();
						a.user.account && (Y.c(a), e(Be({
							commentId: t,
							commentsPageKey: s,
							draftKey: r,
							formData: {
								text: o,
								commentMode: n,
								rteState: null,
								draftType: X.c.edit,
								hasFocus: !0
							}
						})))
					}
				}, Ge = Object(r.a)(pe.F), He = Object(r.a)(pe.E), We = Object(r.a)(pe.G), Ve = Object(r.a)(pe.j), ze = Object(r.a)(pe.f), Ke = e => {
					let {
						id: t,
						commentsPageKey: n,
						draftKey: s,
						formData: r
					} = e;
					return async (e, o, i) => {
						let {
							apiContext: a,
							gqlContext: d
						} = i;
						const c = o();
						if (!c.user.account) return;
						e(Ge({
							draftKey: s
						})), Y.d(c);
						const l = Object(W.e)(r, c.uploads),
							u = r.commentMode;
						let m;
						if ((m = je(u, c) ? await (async (e, t, n, s, r) => {
								const o = r === w.i.MARKDOWN,
									i = {
										commentId: t,
										content: {
											markdown: o ? n.text : null,
											richText: o ? null : s
										}
									};
								return Object(O.a)(e, {
									...F,
									variables: {
										input: i
									}
								}).then(e => {
									if (e.ok) {
										const t = e.body.data.updateComment;
										if ((null == t ? void 0 : t.fieldErrors) && t.fieldErrors.length > 0) return {
											...e,
											ok: !1,
											error: Object(P.e)(t.fieldErrors)
										};
										if ((null == t ? void 0 : t.errors) && t.errors.length > 0) return {
											...e,
											ok: !1,
											error: Object(P.f)(t.errors)
										};
										if (t.ok) return {
											...e,
											body: {
												comment: {
													...Object(R.c)(t.content)
												}
											}
										}
									}
									return {
										...e,
										ok: !1,
										error: e.error || Object(k.a)()
									}
								})
							})(d(), t, r, l, u) : await (async (e, t, n, s, r) => {
								const o = {
									api_type: "json",
									return_rtjson: !0,
									thing_id: t
								};
								return r === w.i.MARKDOWN ? o.text = n.text : (o.text = null, o.richtext_json = s), Object(x.a)(Object(E.a)(e, [C.a]), {
									endpoint: Object(j.a)(Object(N.a)(Object(T.a)(`${e.apiUrl}/api/editusertext`))),
									method: v.ob.POST,
									data: o
								}).then(e => e.ok ? e.body.json ? e.body.json.errors.length ? {
									...e,
									ok: !1,
									error: Object(S.a)(e)
								} : {
									...e,
									body: {
										comment: Object(I.a)(e.body.json.data.things[0].data)
									}
								} : {
									...e,
									body: {
										comment: Object(I.a)(e.body)
									}
								} : {
									...e,
									error: e.error || Object(k.a)()
								})
							})(a(), t, r, l, u)).ok) {
							const r = m.body;
							e(We({
								commentId: t,
								commentsPageKey: n,
								draftKey: s
							})), e(Object(me.j)({
								[t]: {
									...r.comment
								}
							}))
						} else e(He({
							draftKey: s,
							error: m.error
						}))
					}
				}, Qe = Object(r.a)(pe.C), Ye = Object(r.a)(pe.B), Je = Object(r.a)(pe.D), Xe = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s();
					n(Qe({
						id: e
					})), Y.a(e, i);
					const a = await ((e, t) => Object(x.a)(Object(E.a)(e, [C.a]), {
						endpoint: Object(j.a)(`${e.apiUrl}/api/del`),
						method: v.ob.POST,
						data: {
							id: t
						}
					}).then(e => e.ok ? e.body.json && e.body.json.errors.length ? {
						...e,
						ok: !1,
						error: Object(S.a)(e)
					} : {
						...e,
						body: {}
					} : {
						...e,
						error: e.error || Object(k.a)()
					}))(o(), e);
					a.ok ? n(Je({
						id: e,
						postId: t
					})) : n(Ye({
						id: e,
						error: a.error
					}))
				}, Ze = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = !n().features.comments.models[e].sendReplies;
					t(Object(me.j)({
						[e]: {
							sendReplies: o
						}
					})), (await Object(B.q)(r(), e, o)).ok || t(Object(me.j)({
						[e]: {
							sendReplies: !o
						}
					}))
				}, $e = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					var a, d, c, l, u, m;
					n(Object(me.c)());
					const p = e => Object(f.f)(Object(f.e)(e, ee.b.Error));
					if (((null === (d = null === (a = r().pages) || void 0 === a ? void 0 : a.comments) || void 0 === d ? void 0 : d.followed) || []).length === _.a) n(p(s.fbt._("You've reached your post follow limit", null, {
						hk: "3ebRql"
					})));
					else {
						const o = t === J.a.FOLLOWED,
							a = {
								id: e,
								expiresAt: Date.now() + 6048e5
							};
						if (n(Object(me.p)(a)), (await ((e, t) => Object(O.a)(e, {
								...U,
								variables: {
									input: t
								}
							}))(i(), {
								commentId: e,
								followState: t
							})).ok) {
							Object(K.yb)(null !== (u = null === (l = null === (c = r().pages) || void 0 === c ? void 0 : c.comments) || void 0 === l ? void 0 : l.followed) && void 0 !== u ? u : [], null === (m = r().user.account) || void 0 === m ? void 0 : m.id);
							const e = o ? s.fbt._("Followed! You’ll get updates when there’s new activity.", null, {
								hk: "2O1Ou3"
							}) : s.fbt._("Unfollowed. You won’t get updates on this comment anymore.", null, {
								hk: "4EAz6O"
							});
							n(Object(f.f)({
								kind: ee.b.SuccessCommunityGreen,
								text: e
							}))
						} else n(Object(me.p)(a)), n(p(s.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "2N0vVk"
						})))
					}
				};

			function et(e) {
				let {
					commentId: t,
					commentsPageKey: n,
					isLivestreaming: s = !1
				} = e;
				return async (e, r) => {
					const o = r(),
						i = Object(se.b)(o, {
							commentId: t
						});
					if (!i) return;
					e(_e({
						commentId: t,
						commentsPageKey: n
					}));
					const a = {
						commentMode: i.media.rteMode,
						draftType: i.parentId ? X.c.replyToComment : X.c.replyToPost,
						rtJson: i.media.richtextContent,
						hasFocus: !0,
						text: ""
					};
					if (i.parentId) {
						const t = Object(se.b)(o, {
								commentId: i.parentId
							}),
							s = Object(ne.j)(o, {
								commentId: i.parentId,
								commentLink: void 0,
								commentsPageKey: n
							});
						if (!t || null === s) return;
						await e(Se({
							commentsPageKey: n,
							draftKey: i.id,
							parentCommentDepth: s,
							parentCommentId: t.id,
							formData: a,
							editorMode: i.media.rteMode
						}))
					} else await e(Ce({
						postId: i.postId,
						commentsPageKey: n,
						draftKey: i.id,
						formData: a,
						editorMode: i.media.rteMode,
						disableAutofocus: !0,
						isLiveStreaming: s
					}))
				}
			}
		},
		"./src/reddit/actions/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return R
			})), n.d(t, "o", (function() {
				return A
			})), n.d(t, "f", (function() {
				return D
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "n", (function() {
				return G
			})), n.d(t, "s", (function() {
				return H
			})), n.d(t, "k", (function() {
				return W
			})), n.d(t, "h", (function() {
				return V
			})), n.d(t, "g", (function() {
				return z
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "r", (function() {
				return J
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "a", (function() {
				return $
			})), n.d(t, "b", (function() {
				return ee
			})), n.d(t, "p", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ne
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "e", (function() {
				return re
			})), n.d(t, "l", (function() {
				return ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/economics/helpers/async.ts"),
				d = n("./src/lib/loadableAction/index.ts");
			const c = Object(d.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditUserCommentsPowerupsInfoFromCommentCollection));
			Object(d.a)(() => n.e("AchievementsActions").then(n.bind(null, "./src/reddit/actions/economics/powerups/flairs/index.ts")).then(e => e.getSubredditCurrentUserPowerupsFlairs));
			var l = n("./src/reddit/actions/login.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = n("./src/reddit/actions/shortcuts/utils.ts"),
				b = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				f = n("./src/reddit/actions/toaster.ts"),
				h = n("./src/reddit/actions/vote.ts"),
				_ = n("./src/reddit/endpoints/comment/index.tsx"),
				g = n("./src/reddit/helpers/commentList/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				x = n("./src/reddit/helpers/trackers/comment.ts"),
				O = n("./src/reddit/models/Comment/index.ts"),
				E = n("./src/reddit/models/Post/index.ts"),
				y = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/models/Vote/index.ts"),
				j = n("./src/reddit/selectors/comments.ts"),
				k = n("./src/reddit/selectors/commentSelector.ts"),
				I = n("./src/reddit/selectors/experiments/avatarsInComments.ts"),
				S = n("./src/reddit/selectors/moderatingComments.ts"),
				w = n("./src/reddit/selectors/moderatorPermissions.ts"),
				T = n("./src/reddit/selectors/user.ts"),
				N = n("./src/reddit/actions/comment/constants.ts");
			const P = {},
				R = Object(i.a)(N.q),
				A = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					if (!Object(T.R)(n())) return t(Object(l.openRegisterModal)()), void t(Object(u.k)({
						actionSource: u.a.Save,
						redirectUrl: Object(j.m)(n(), {
							commentId: e
						})
					}));
					const i = n().features.comments.models[e];
					if (!i) return;
					const a = i.isSaved ? _.m : _.i;
					if (t(R({
							[e]: {
								isSaved: !i.isSaved
							}
						})), (await a(o(), e)).ok) {
						const n = i.isSaved ? r.fbt._("Comment unsaved successfully", null, {
								hk: "UGKHZ"
							}) : r.fbt._("Comment saved successfully", null, {
								hk: "1BZqMx"
							}),
							s = r.fbt._("Undo", null, {
								hk: "46OwLP"
							});
						t(Object(f.f)({
							text: n,
							kind: y.b.Undo,
							buttonText: s,
							buttonAction: A(e)
						}))
					} else t(R({
						[e]: {
							isSaved: i.isSaved
						}
					}))
				}, M = e => `viewing-comment-${e}`, L = s.a.telemetry.commentConsumedThreshold, D = e => async (t, n) => {
					const r = n(),
						i = Object(k.b)(r, {
							commentId: e
						});
					if (!i || Math.random() > s.a.telemetry.commentSampleRate) return;
					x.d({
						state: r,
						commentId: e,
						collapsed: i.collapsed
					}), o.c.start(M(e));
					const a = setTimeout(() => x.a({
						state: r,
						commentId: e,
						collapsed: i.collapsed
					}), L);
					P[e] = a
				}, F = (e, t) => async (n, s) => {
					const r = s(),
						i = M(e);
					if (Object(k.b)(r, {
							commentId: e
						}) && o.c.has(i)) {
						const n = o.c.end(i);
						!t && n < L && (clearTimeout(P[e]), delete P[e])
					}
				}, U = Object(i.a)(N.z), B = Object(i.a)(N.y), q = Object(i.a)(N.x), G = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						d = i.moreComments.models[t],
						l = i.platform.currentPage,
						u = l && l.routeMatch,
						p = u && u.match,
						{
							partialPostId: f
						} = p ? p.params : null;
					if (!f) return;
					const h = Object(E.z)(f);
					n(U({
						moreCommentsId: d.id
					}));
					const v = await Object(_.g)(o(), h, {
						token: d.token
					}, Object(I.a)(i));
					if (v.ok) {
						const t = v.body,
							r = Object(g.a)(t, h, i);
						n(B({
							key: e,
							moreCommentsItem: d,
							shouldCollapse: r,
							...t
						}));
						const o = i.posts.models[h];
						let l;
						o && "subreddit" === o.belongsTo.type && t.comments && (l = o.belongsTo.id, await n(Object(a.a)({
							commentIds: Object.keys(v.body.comments),
							postIds: [o.id],
							skip: ["communityDetails", "subscription"],
							subredditId: l
						})), Object(w.i)(i, l) && n(Object(b.c)(h, !0, d.token)));
						const u = v.body.comments;
						await n(c(l, u)), Object(w.h)(s(), {
							subredditId: o.belongsTo.id
						}) && n(Object(m.a)({
							commentIds: Object.keys(t.comments)
						}))
					} else n(q({
						moreCommentsItem: d,
						...v.error
					}))
				}, H = Object(h.a)(g.b, C.a.upvoted), W = Object(h.a)(g.b, C.a.downvoted), V = Object(i.a)(N.l), z = Object(i.a)(N.k), K = Object(i.a)(N.g), Q = Object(i.a)(N.h), Y = (Object(i.a)(N.c), Object(i.a)(N.d), e => {
					let {
						commentId: t,
						commentsPageKey: n,
						scrollToAndRemeasure: s
					} = e;
					return async (e, r) => {
						const o = r(),
							i = Object(O.i)(t),
							a = Object(j.n)(o, {
								commentLink: i,
								commentsPageKey: n
							}),
							d = Object(S.b)(o, {
								commentId: t,
								commentsPageKey: n
							}),
							c = a.depth;
						e(K({
							commentId: t,
							commentsPageKey: n,
							isCollapsed: d
						})), d || 0 !== c || s(t, !0), Object(p.d)()
					}
				}), J = e => {
					let {
						commentId: t,
						commentsPageKey: n
					} = e;
					return async e => {
						e(Q({
							commentId: t,
							commentsPageKey: n
						}))
					}
				}, X = e => {
					let {
						commentLink: t,
						commentsPageKey: n,
						lineDepth: s,
						scrollToAndRemeasure: r
					} = e;
					return async (e, o) => {
						const i = o(),
							a = Object(g.e)(n, t, s, i),
							d = Object(S.b)(i, {
								commentId: t.id,
								commentsPageKey: n
							});
						e(K({
							commentId: a,
							commentsPageKey: n,
							isCollapsed: d
						})), 0 === s && r(a, !0), Object(p.d)()
					}
				}, Z = Object(i.a)(N.t), $ = e => t => t(Z({
					draftKey: e
				})), ee = Object(i.a)(N.a), te = Object(i.a)(N.I), ne = Object(i.a)(N.b), se = Object(i.a)(N.w), re = Object(i.a)(N.e), oe = Object(i.a)(N.A), ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, i;
					if (e) {
						const n = await Object(_.b)(r(), e);
						if (n.ok) {
							const s = n.body;
							"Comment" === (null === (o = s.data.commentById) || void 0 === o ? void 0 : o.__typename) && t(oe({
								commentId: e,
								media: Object(v.b)(null === (i = s.data.commentById) || void 0 === i ? void 0 : i.content)
							}))
						}
					}
				}
		},
		"./src/reddit/actions/comment/moderation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return x
			})), n.d(t, "c", (function() {
				return O
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "h", (function() {
				return k
			})), n.d(t, "b", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeCommentsPageKey/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/shortcuts/utils.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/modals.ts"),
				u = n("./src/reddit/endpoints/comment/index.tsx"),
				m = n("./src/reddit/endpoints/moderator/snoozableReport.ts"),
				p = n("./src/reddit/models/Reportable/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/selectors/commentSelector.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/reddit/actions/comment/index.ts"),
				g = n("./src/reddit/actions/comment/constants.ts");
			const v = Object(o.a)(g.p),
				x = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().features.comments.models[e] && (await Object(u.j)(r(), e)).ok && t((e => async t => {
						t(v({
							commentId: e
						}))
					})(e))
				}, O = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (!Object(h.R)(n())) return void t(Object(a.i)(l.a.LOGIN_MODAL_ID));
					const i = n().features.comments.models[e];
					if (!i) return;
					const d = i.isLocked ? u.l : u.f;
					t(Object(_.j)({
						[e]: {
							isLocked: !i.isLocked
						}
					})), (await d(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: i.isLocked ? s.fbt._("comment has been unlocked", null, {
							hk: "BYjts"
						}) : s.fbt._("comment has been locked", null, {
							hk: "1pBDQl"
						})
					})) : t(Object(_.j)({
						[e]: {
							isLocked: i.isLocked
						}
					}))
				}, E = Object(o.a)(g.J), y = e => async (t, n, r) => {
					let {
						apiContext: o,
						gqlContext: i
					} = r;
					const a = n(),
						l = a.features.comments.models[e],
						m = a.user.account ? a.user.account.displayText : null;
					l && m && (t(Object(_.j)({
						[e]: {
							isApproved: !0,
							approvedBy: m,
							approvedAtUTC: Date.now(),
							bannedBy: null,
							isRemoved: !1,
							isSpam: !1,
							modNote: null,
							modReasonBy: null,
							modRemovalReason: null,
							numReports: 0
						}
					})), (await Object(u.a)(i(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("comment has been approved", null, {
							hk: "4GfKQi"
						})
					})) : t(Object(_.j)({
						[e]: {
							isApproved: l.isApproved,
							approvedBy: null,
							bannedBy: l.bannedBy,
							isRemoved: l.isRemoved,
							isSpam: l.isSpam,
							modNote: l.modNote,
							modReasonBy: l.modReasonBy,
							modRemovalReason: l.modRemovalReason,
							numReports: l.numReports || null
						}
					})), Object(d.d)())
				}, C = (e, t) => async (n, r, o) => {
					let {
						apiContext: i,
						gqlContext: a
					} = o;
					const l = r(),
						m = l.features.comments.models[e],
						p = l.user.account ? l.user.account.displayText : null;
					m && p && (n(Object(_.j)({
						[e]: {
							approvedBy: null,
							bannedBy: p,
							bannedAtUTC: Date.now(),
							isApproved: !1,
							isRemoved: !t,
							isSpam: t
						}
					})), (await Object(u.h)(a(), e, t)).ok ? n(Object(c.f)({
						kind: b.b.SuccessMod,
						text: t ? s.fbt._("comment has been marked as spam", null, {
							hk: "4fQaFM"
						}) : s.fbt._("comment has been removed", null, {
							hk: "1qNTrD"
						})
					})) : n(Object(_.j)({
						[e]: {
							approvedBy: m.approvedBy,
							bannedBy: m.bannedBy,
							isApproved: m.isApproved,
							isRemoved: m.isRemoved,
							isSpam: m.isSpam
						}
					})), Object(d.d)())
				}, j = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = n().features.comments.models[e];
					if (!i) return;
					const a = i.ignoreReports ? u.k : u.e;
					t(Object(_.j)({
						[e]: {
							ignoreReports: !i.ignoreReports
						}
					})), (await a(o(), e)).ok ? t(Object(c.f)({
						kind: b.b.SuccessMod,
						text: i.ignoreReports ? s.fbt._("comment has had its reports un-ignored", null, {
							hk: "HcpVV"
						}) : s.fbt._("comment has had its reports ignored", null, {
							hk: "2q4sCp"
						})
					})) : t(Object(_.j)({
						[e]: {
							ignoreReports: i.ignoreReports
						}
					}))
				}, k = (e, t, n) => async (o, i, a) => {
					let {
						gqlContext: d
					} = a;
					const l = Object(f.b)(i(), {
						commentId: e
					});
					if (!l) return;
					const u = n === r.kc.Snoozed,
						h = {
							itemId: e,
							reportText: t,
							isSnoozed: u
						};
					if ((await Object(m.a)(d(), {
							input: h
						})).ok) o(Object(_.j)({
						[e]: {
							userReports: Object(p.a)(l.userReports, t, u)
						}
					}));
					else {
						const e = Object(c.e)(s.fbt._("Sorry, that snooze failed. Try that again", null, {
							hk: "7ToJC"
						}), b.b.Error);
						o(Object(c.f)(e))
					}
				}, I = (e, t, n) => async (s, o, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					const l = o(),
						m = l.features.comments.models[e];
					if (!m) return;
					const p = m.postId,
						b = l.postStickiedComments.data[p];
					s(Object(_.j)({
						[e]: {
							distinguishType: t,
							isAdmin: t === r.J.ADMIN,
							isMod: t === r.J.MODERATOR,
							isStickied: !!n
						}
					})), n && b && b !== e && s(Object(_.j)({
						[b]: {
							isStickied: !1
						}
					}));
					const f = Object(u.c)(c(), e, t),
						h = Object(u.d)(c(), e, !!n),
						g = [f];
					(n || !n && e === b) && g.push(h), (await Promise.all(g)).every(e => e.ok) ? n && s(E({
						id: e,
						postId: p,
						commentsPageKey: Object(i.a)(p, null, {
							sort: r.w.CONFIDENCE,
							...l.platform.currentPage.queryParams
						})
					})) : (s(Object(_.j)({
						[e]: {
							distinguishType: m.distinguishType,
							isAdmin: m.isAdmin,
							isMod: m.isMod,
							isStickied: m.isStickied
						}
					})), s(Object(_.j)({
						[b]: {
							isStickied: l.features.comments.models[b].isStickied
						}
					})))
				}
		},
		"./src/reddit/actions/contentControls/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = "CONTENT_CONTROLS_FAILED",
				r = "CONTENT_CONTROLS_LOADED",
				o = "CONTENT_CONTROLS_PENDING",
				i = "CONTENT_CONTROLS_UPDATED"
		},
		"./src/reddit/actions/contentControls/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return S
			})), n.d(t, "b", (function() {
				return T
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/camelCase.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/lib/sentry/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/HatefulContentFilters/index.ts"),
				m = n("./src/redditGQL/operations/FetchContentControls.json");
			const p = e => {
				switch (e) {
					case "LENIENT":
						return u.a.Lenient;
					case "MODERATE":
						return u.a.Moderate;
					case "STRICT":
						return u.a.Strict;
					default:
						return u.a.Off
				}
			};
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var b = n("./node_modules/lodash/isEmpty.js"),
				f = n.n(b),
				h = n("./src/redditGQL/operations/UpdateHatefulContentFilters.json"),
				_ = n("./src/redditGQL/operations/UpdatePostRequirements.json"),
				g = n("./src/reddit/endpoints/subreddit/about.ts"),
				v = n("./src/reddit/featureFlags/index.ts"),
				x = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/contentControls.ts"),
				E = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/actions/contentControls/constants.ts");
			const j = Object(a.a)(C.b),
				k = Object(a.a)(C.c),
				I = Object(a.a)(C.a),
				S = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = {
							subredditName: e.toLowerCase()
						},
						a = v.d.hatefulContentFiltersEnabled(n());
					if (Object(O.a)(n(), o)) return;
					t(k(o));
					let c = Object(y.I)(n(), e);
					if (!c) {
						const n = await Object(g.a)(r(), e, !1);
						if (n.ok) {
							c = n.body.data.subreddit.id
						}
						if (!c) {
							const e = n.error || {
								type: i.L.NOT_FOUND_ERROR
							};
							return void t(I({
								...o,
								error: e
							}))
						}
					}
					const u = Object(E.c)(n(), {
						subredditId: c
					});
					let b = null;
					const f = await ((e, t) => Object(l.a)(e, {
						...m,
						variables: t
					}).then(e => {
						var t, n;
						if (e.ok) {
							const s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit;
							return {
								...e,
								body: {
									data: {
										subreddit: {
											hatefulContentFilters: {
												hatefulContentThresholdAbuse: p(null == s ? void 0 : s.hatefulContentThresholdAbuse),
												hatefulContentThresholdIdentity: p(null == s ? void 0 : s.hatefulContentThresholdIdentity),
												permittedTerms: (null == s ? void 0 : s.hatefulContentPermittedTerms) || []
											},
											postRequirements: null == s ? void 0 : s.postRequirements
										}
									}
								}
							}
						}
						return e
					}))(r(), {
						subredditId: c,
						includeHatefulFilters: u && a
					});
					if (f.ok) {
						const e = f.body;
						b = e.data.subreddit && e.data.subreddit
					}
					if (b) t(j({
						...o,
						...b
					}));
					else {
						const n = f.error || {
							type: i.L.UNKNOWN_ERROR
						};
						t(I({
							...o,
							error: n
						})), d.c.withScope(t => {
							t.setExtra("info", {
								subredditName: e,
								responseBody: f.body,
								responseOk: f.ok
							}), d.c.captureMessage("Missing post requirements data!")
						})
					}
				}, w = Object(a.a)(C.d), T = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = e.toLowerCase(),
						d = Object(y.I)(r(), e);
					if (!d) return {
						success: !1
					};
					const u = await ((e, t, n) => {
						const s = [Promise.resolve(null), Promise.resolve(null)];
						if (n.postRequirements && !f()(n.postRequirements)) {
							const r = {
								subredditId: t,
								...n.postRequirements
							};
							s[0] = Object(l.a)(e, {
								..._,
								variables: {
									input: r
								}
							})
						}
						if (n.hatefulContentFilters && !f()(n.hatefulContentFilters)) {
							const r = {
									subredditId: t,
									hatefulContentThresholdAbuse: n.hatefulContentFilters.hatefulContentThresholdAbuse,
									hatefulContentThresholdIdentity: n.hatefulContentFilters.hatefulContentThresholdIdentity
								},
								o = !(!r.hatefulContentThresholdAbuse && !r.hatefulContentThresholdIdentity),
								i = {
									subredditId: t,
									permittedTerms: n.hatefulContentFilters.permittedTerms
								},
								a = !!i.permittedTerms;
							s[1] = Object(l.a)(e, {
								...h,
								variables: {
									includeThresholds: o,
									includePermittedTerms: a,
									thresholdInput: r,
									permittedTermsInput: i
								}
							})
						}
						return Promise.all(s).then(e => {
							let [t, n] = e, s = !0, r = [];
							if (t) {
								const e = t.body,
									n = e.data.updatePostRequirements.fieldErrors;
								s = s && e.data.updatePostRequirements.ok, n && (r = r.concat(n))
							}
							if (n) {
								const {
									data: {
										updateHatefulContentSettings: e,
										updateSubredditSettings: t
									}
								} = n.body;
								t && (s = s && t.ok), e && (s = s && e.ok);
								const o = null == t ? void 0 : t.fieldErrors,
									i = null == e ? void 0 : e.fieldErrors;
								o && (r = r.concat(o)), i && (r = r.concat(i))
							}
							return {
								ok: s,
								fieldErrors: r.length ? r : null
							}
						})
					})(i(), d, t);
					if (u.ok) return n(w({
						subredditName: a,
						partialUpdates: t
					})), n(Object(c.f)({
						kind: x.b.SuccessCommunity,
						text: s.fbt._("Subreddit content controls updated successfully", null, {
							hk: "1n6QIQ"
						})
					})), {
						success: !0
					}; {
						const r = N(u.fieldErrors);
						return n(Object(c.f)({
							kind: x.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: T(e, t)
						})), {
							success: !1,
							errors: r || void 0
						}
					}
				}, N = e => e && e.map(e => ({
					...e,
					field: o()(e.field)
				}))
		},
		"./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "d", (function() {
				return C
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "f", (function() {
				return k
			}));
			var s = n("./node_modules/@sentry/minimal/esm/index.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/GetSubredditCountrySiteSettings.json"),
				a = n("./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json");
			const d = e => ({
				input: {
					subredditId: e.subredditId,
					countryCode: e.countryCode || "",
					languageCode: e.languageCode || ""
				}
			});
			var c = async (e, t) => Object(o.a)(e, {
				...a,
				variables: d(t)
			}), l = n("./node_modules/fbt/lib/FbtPublic.js"), u = n("./src/reddit/models/Toast/index.ts"), m = n("./node_modules/reselect/es/index.js"), p = n("./src/reddit/constants/experiments.ts"), b = n("./src/reddit/helpers/chooseVariant/index.ts"), f = n("./src/reddit/selectors/user.ts");
			const h = Object(m.a)(e => Object(b.c)(e, {
				experimentEligibilitySelector: f.R,
				experimentName: p.Wb
			}), e => e === p.Kd);
			var _ = n("./src/reddit/actions/toaster.ts");
			const g = "SUBREDDIT_COUNTRY_SITE__LOADED",
				v = "SUBREDDIT_COUNTRY_SITE__CHANGED",
				x = "SUBREDDIT_COUNTRY_SITE__UPDATE_SUCCESS",
				O = Object(r.a)(g),
				E = Object(r.a)(x),
				y = Object(r.a)(v),
				C = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var a;
					if (!e) return;
					const d = await (async (e, t) => Object(o.a)(e, {
							...i,
							variables: {
								subredditId: t
							}
						}))(r(), e),
						c = d.body;
					d && d.ok && c && t(O({
						subredditId: e,
						subredditCountrySite: null === (a = c.data) || void 0 === a ? void 0 : a.subredditInfoById.countrySiteSettings
					}))
				}, j = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!e) return;
					const i = await c(o(), {
						subredditId: e,
						countryCode: t.countryCode,
						languageCode: t.languageCode
					});
					if (!i.ok) return n(Object(_.f)({
						kind: u.b.Error,
						text: l.fbt._("Something went wrong", null, {
							hk: "2PnKbu"
						}),
						duration: 5e3
					}));
					const a = i.body;
					n(E({
						subredditId: e,
						subredditCountrySite: a.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
					}))
				}, k = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e || !h(r())) return;
					const a = {
							subredditId: e,
							countryCode: "",
							languageCode: t
						},
						d = await c(i(), a);
					if (d.ok) {
						const t = d.body;
						n(E({
							subredditId: e,
							subredditCountrySite: t.data.updateSubredditCountrySiteSettings.subreddit.countrySiteSettings
						}))
					} else s.l(e => {
						e.setExtra("subredditCountryLanginfo", a), s.c(d.error)
					})
				}
		},
		"./src/reddit/actions/creatorStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "CREATOR_STATS_PENDING",
				r = "CREATOR_STATS_LOADED"
		},
		"./src/reddit/actions/crosspostSubredditRec/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/postCreation/general.ts"),
				o = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts");
			var i = n("./src/lib/initializeClient/installReducer.ts");
			var a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER":
						return !0;
					case "CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER":
						return !1;
					default:
						return e
				}
			};
			Object(i.a)({
				features: {
					shouldTryToShowCrosspostModal: a
				}
			});
			const d = Object(s.a)("CROSSPOST_RECOMMENDATIONS__SHOULD_TRY_TO_RENDER"),
				c = Object(s.a)("CROSSPOST_RECOMMENDATIONS__STOP_TRYING_TO_RENDER"),
				l = e => async (t, n) => {
					const s = n();
					if (!Object(o.b)(s)) return;
					const i = e.title,
						a = Object(o.d)(e),
						d = Object(o.c)(e);
					t(Object(r.j)(i, a, d, t => {
						const n = e.belongsTo.id === t.id,
							s = "isCrosspostDestination" in t && t.isCrosspostDestination;
						return n || !s
					}))
				}
		},
		"./src/reddit/actions/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			n("./src/lib/constants/index.ts");
			var s = n("./src/lib/makeActionCreator/index.ts");
			n("./src/lib/makeListingKey/index.ts"), n("./src/lib/addQueryParams/index.ts"), n("./src/lib/makeApiRequest/index.ts"), n("./src/lib/omitHeaders/index.ts"), n("./src/lib/stringInterpolate/index.ts"), n("./src/reddit/constants/headers.ts"), n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"), n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			var r = n("./src/reddit/selectors/discoveryUnit.ts");
			n("./src/reddit/selectors/listings.ts");
			const o = "DISCOVERY_UNIT__LIST_PENDING",
				i = "DISCOVERY_UNIT__LIST_LOADED",
				a = "DISCOVERY_UNIT__LIST_FAILED",
				d = Object(s.a)(o),
				c = Object(s.a)(i),
				l = Object(s.a)(a),
				u = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const o = t(),
						i = Object(r.d)(o),
						a = Object(r.c)(o);
					if (i || a) return;
					e(d());
					const u = await (e => Promise.resolve({
						ok: !0,
						error: null,
						status: 200,
						headers: {},
						details: "",
						body: {
							global: {
								discovery_config_v1: {
									discovery_units: [{
										id: "xd_66",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_hero",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_67",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_hero",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_68",
										enabled: !0,
										layout: "large",
										parameters: {
											sort: "hot"
										},
										surface: "explore",
										unit_name: "posts_in_category_rails_small",
										unit_type: "listing",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_69",
										enabled: !0,
										layout: "large",
										surface: "explore",
										unit_name: "posts_in_subreddit_small",
										unit_type: "listing",
										url: "/r/%{subredditName}/hot.json"
									}, {
										id: "xd_70",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_posts",
										unit_type: "community_category",
										url: "/api/posts_in_category.json"
									}, {
										id: "xd_71",
										enabled: !0,
										layout: "large",
										surface: "search",
										unit_name: "search_subreddits",
										unit_type: "community_category",
										url: "/api/subreddits_in_category.json"
									}, {
										id: "xd_72",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "community_banner_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_83",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "best_of_community",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_91",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in subreddit %{subredditName}",
										unit_name: "posts_in_subreddit_vertical",
										unit_type: "listing"
									}, {
										id: "xd_92",
										enabled: !0,
										layout: "large",
										surface: "comments",
										title: "Posts in recommended home",
										unit_name: "posts_in_rec_home",
										unit_type: "listing"
									}, {
										id: "xd_96",
										enabled: !0,
										layout: "small",
										surface: "subreddit_listing",
										unit_name: "top_week_posts",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}, {
										id: "xd_97",
										enabled: !0,
										layout: "large",
										surface: "subreddit_listing",
										unit_name: "top_week_posts_large",
										unit_type: "subreddit_listing",
										url: "/r/%{subredditName}/top.json"
									}]
								}
							}
						}
					}))(s());
					if (u.ok) {
						const {
							discoveryUnits: t
						} = (e => {
							return {
								discoveryUnits: e.global.discovery_config_v1.discovery_units.reduce((e, t) => {
									const n = {
										enabled: t.enabled,
										experiment: t.experiment,
										id: t.id,
										index: t.index,
										layout: t.layout,
										options: t.options,
										parameters: t.parameters,
										subtitle: t.subtitle,
										subtitleIcon: t.subtitle_icon,
										surface: t.surface,
										title: t.title,
										unitName: t.unit_name,
										unitType: t.unit_type,
										url: t.url
									};
									return e[n.id] = n, e
								}, {})
							}
						})(u.body);
						e(c({
							discoveryUnits: t
						}))
					} else e(l({
						error: u.error
					}))
				}, m = "DISCOVERY_UNIT__UNIT_DATA_PENDING", p = "DISCOVERY_UNIT__UNIT_DATA_LOADED", b = "DISCOVERY_UNIT__UNIT_DATA_FAILED";
			Object(s.a)(m), Object(s.a)(p), Object(s.a)(b)
		},
		"./src/reddit/actions/economics/claims/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = "ECONOMICS__CLAIMS__CLAIM_PENDING",
				r = "ECONOMICS__CLAIMS__CLAIM_COMPLETED"
		},
		"./src/reddit/actions/economics/helpers/async.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => async t => {
				const s = await (() => n.e("EconHelperActions").then(n.bind(null, "./src/reddit/actions/economics/helpers/index.ts")).then(e => e.fetchAll))();
				await t(s(e))
			}
		},
		"./src/reddit/actions/economics/me/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "ECONOMICS__ME__ME_DATA_SUCCESS",
				r = "ECONOMICS__ME__POINTS_COPY_REQUESTED",
				o = "ECONOMICS__ME__POINTS_COPY_SUCCESS"
		},
		"./src/reddit/actions/economics/paymentSystems/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			const s = "ECONOMICS__PAYMENT_SYSTEM__CARD_DELETE_SUCCESS",
				r = "ECONOMICS__PAYMENT_SYSTEM__PAYPAL_DELETE_SUCCESS",
				o = "ECONOMICS__PAYMENT_SYSTEM__INFO_FAILURE",
				i = "ECONOMICS__PAYMENT_SYSTEM__INFO_FETCHED",
				a = "ECONOMICS__PAYMENT_SYSTEM__INFO_PENDING"
		},
		"./src/reddit/actions/economics/powerups/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => (null == e ? void 0 : e.map(e => e.message).join(", ")) || ""
		},
		"./src/reddit/actions/economics/powerups/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/lib/uploadToS3/index.ts"),
				a = n("./src/reddit/endpoints/gold/powerups/index.ts"),
				d = n("./src/reddit/helpers/media/index.ts"),
				c = n("./src/reddit/selectors/user.ts"),
				l = n("./src/reddit/actions/economics/powerups/constants.ts"),
				u = n("./src/reddit/actions/economics/powerups/helpers.ts");
			const m = Object(r.a)(l.b),
				p = Object(r.a)(l.c),
				b = e => {
					let {
						subredditId: t,
						file: n
					} = e;
					return async (e, r) => {
						var i;
						try {
							const o = r(),
								a = null === (i = Object(c.l)(o)) || void 0 === i ? void 0 : i.id;
							if (!a) throw new Error("Failed to get current user during emoji upload");
							const u = await Object(d.h)(n);
							if (!u) throw new Error("Cannot determine file mimeType");
							const {
								file: m,
								width: p,
								height: b
							} = await Object(d.p)(n, l.a), g = await e(f({
								subredditId: t,
								mimeType: u
							}, {
								userId: a
							})), v = await _({
								file: m,
								s3UploadLease: g
							}, {
								subredditId: t,
								userId: a
							});
							return await e(h({
								subredditId: t,
								mimeType: u,
								url: v,
								x: p,
								y: b,
								nonce: Object(s.a)()
							}))
						} catch (a) {
							throw o.c.captureException(a), a
						}
					}
				},
				f = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(a.c)(o(), {
						input: e
					});
					if (i.error || !i.ok) throw new Error(`Failed to get emoji upload lease. subredditId: ${e.subredditId}; userId: ${t.userId}`);
					const {
						ok: d,
						errors: c,
						s3UploadLease: l
					} = i.body.data.generateCustomEmojiUploadLease;
					if (!d || c) throw new Error(`Failed to get emoji upload lease: ${Object(u.a)(c)}. subredditId: ${e.subredditId}; userId: ${t.userId}`);
					return l
				}, h = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(a.a)(r(), {
						input: e
					});
					if (o.error || !o.ok) throw new Error("Failed to create custom emoji");
					const {
						ok: i,
						errors: c,
						emoji: l
					} = o.body.data.createCustomEmoji;
					if (!i || c) throw new Error(`Failed to create custom emoji: ${Object(u.a)(c)}`);
					const p = l.emojiIcon.url;
					await Object(d.o)(p);
					const {
						subredditId: b
					} = e;
					return t(m({
						subredditId: b,
						emoji: l
					})), l
				}, _ = async (e, t) => {
					let {
						file: n,
						s3UploadLease: s
					} = e, {
						subredditId: r,
						userId: o
					} = t;
					const a = await Object(i.a)(n, s);
					if (!a.ok) throw new Error(`Failed to upload custom emoji to S3. subredditId: ${r}; userId: ${o}`);
					const d = a.body.PostResponse;
					return `https://${d.Bucket}.s3.amazonaws.com/${d.Key}`
				}, g = e => {
					let {
						emojiId: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: i
						} = r;
						const d = await Object(a.b)(i(), {
							input: {
								id: t
							}
						});
						if (d.error || !d.ok) {
							const e = new Error("Failed to delete custom emoji");
							throw o.c.captureException(e), e
						}
						const {
							ok: c,
							errors: l
						} = d.body.data.deleteCustomEmoji;
						if (!c || l) {
							const e = new Error(`Failed to delete custom emoji: ${Object(u.a)(l)}`);
							throw o.c.captureException(e), e
						}
						return e(p({
							subredditId: n,
							emojiId: t
						})), c
					}
				}
		},
		"./src/reddit/actions/economics/predictions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return V
			})), n.d(t, "k", (function() {
				return z
			})), n.d(t, "o", (function() {
				return K
			})), n.d(t, "r", (function() {
				return Q
			})), n.d(t, "q", (function() {
				return Y
			})), n.d(t, "l", (function() {
				return ee
			})), n.d(t, "m", (function() {
				return te
			})), n.d(t, "n", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "v", (function() {
				return oe
			})), n.d(t, "g", (function() {
				return ie
			})), n.d(t, "a", (function() {
				return ae
			})), n.d(t, "w", (function() {
				return ce
			})), n.d(t, "p", (function() {
				return le
			})), n.d(t, "i", (function() {
				return ue
			})), n.d(t, "j", (function() {
				return me
			})), n.d(t, "s", (function() {
				return pe
			})), n.d(t, "t", (function() {
				return be
			})), n.d(t, "f", (function() {
				return fe
			})), n.d(t, "c", (function() {
				return he
			})), n.d(t, "d", (function() {
				return _e
			})), n.d(t, "h", (function() {
				return ge
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/features/predictions/index.ts"),
				a = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/makeRequest/index.ts")),
				d = n("./src/lib/uploadToS3/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/redditGQL/operations/CreateMediaUploadLease.json"),
				u = n("./src/redditGQL/operations/SubmitMediaUpload.json");
			var m = n("./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts"),
				p = n("./src/reddit/helpers/media/index.ts"),
				b = n("./src/redditGQL/types.ts");
			const f = new Map([
					["image/png", b.u.Png],
					["image/gif", b.u.Gif],
					["image/jpeg", b.u.Jpeg]
				]),
				h = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(p.h)(t) || t.type,
						b = f.get(i);
					if (!b) throw new Error("Unacceptable file type");
					const {
						mediaId: h,
						uploadLease: _
					} = await (async (e, t) => {
						const n = await Object(c.a)(e, {
							...l,
							variables: {
								input: t
							}
						});
						if (!Object(a.c)(n) || n.error) throw new Error("Failed to create upload lease");
						return n.body.data.createMediaUploadLease
					})(o(), {
						mimetype: b
					}), g = Object(m.a)(_), v = await Object(d.a)(t, g);
					if (!Object(a.c)(v)) throw new Error("Failed to upload file to S3");
					return await (async (e, t) => {
						const n = await Object(c.a)(e, {
							...u,
							variables: {
								input: t
							}
						});
						if (!Object(a.c)(n) || n.error) throw new Error("Failed to submit media")
					})(o(), {
						mediaId: h,
						redditId: e
					}), {
						mediaId: h,
						mimeType: b
					}
				};
			var _ = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/lib/delay/index.ts"),
				x = n("./src/lib/makeActionCreator/index.ts"),
				O = n("./src/reddit/endpoints/economics/predictions.ts");

			function E(e) {
				let {
					topPredictorsRank: t,
					currentRank: n
				} = e;
				return {
					currentRank: n ? y(n) : null,
					topPredictorsRank: t.map(y)
				}
			}

			function y(e) {
				let {
					score: t,
					rank: n,
					redditor: s,
					redditorInfo: r
				} = e;
				var o, i;
				return {
					score: t,
					rank: n,
					redditor: s ? {
						...s,
						icon: null !== (o = s.icon) && void 0 !== o ? o : null,
						profile: null !== (i = s.profile) && void 0 !== i ? i : null
					} : null,
					redditorInfo: r
				}
			}
			var C = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizePredictionTournamentFromGql/index.ts"),
				k = n("./src/reddit/actions/login.ts"),
				I = n("./src/reddit/actions/modal.ts"),
				S = n("./src/reddit/constants/modals.ts"),
				w = n("./src/reddit/selectors/features/predictions/leaderboards/index.ts"),
				T = n("./src/reddit/selectors/subreddit.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/selectors/features/predictions/creation/index.ts"),
				R = n("./src/reddit/selectors/features/predictions/tournaments/index.ts"),
				A = n("./src/reddit/actions/economics/predictions/constants.ts");
			Object(o.a)({
				features: {
					predictions: i.a
				}
			});
			const M = Object(x.a)(A.d),
				L = Object(x.a)(A.c),
				D = Object(x.a)(A.e),
				F = Object(x.a)(A.f),
				U = Object(x.a)(A.i),
				B = Object(x.a)(A.h),
				q = Object(x.a)(A.j),
				G = Object(x.a)(A.p),
				H = Object(x.a)(A.s),
				W = Object(x.a)(A.o),
				V = Object(x.a)(A.b),
				z = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = Object(N.R)(r());
					if (!Object(w.c)(r(), {
							subredditId: e
						})) {
						s(M({
							subredditId: e
						}));
						try {
							const {
								predictionTournaments: r,
								predictionWinners: o
							} = await Object(O.i)(i(), {
								subredditId: e,
								period: n,
								top: t,
								includeCurrentRank: a
							}), d = E(o);
							s(D({
								subredditId: e,
								leaderboard: d
							})), r && (s(ne(e, r)), null == r || r.forEach(e => {
								let {
									tournamentId: t,
									winners: n
								} = e;
								s(F({
									tournamentId: t,
									leaderboard: E(n)
								}))
							}))
						} catch {
							s(L({
								subredditId: e
							}))
						}
					}
				}, K = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(N.R)(s());
					if (!Object(w.g)(s(), {
							tournamentId: t
						})) {
						n(U({
							tournamentId: t
						}));
						try {
							const {
								predictionWinners: s
							} = await Object(O.j)(o(), {
								subredditId: e,
								tournamentId: t,
								includeCurrentRank: i
							}), r = E(s);
							n(q({
								tournamentId: t,
								leaderboard: r
							}))
						} catch {
							n(B({
								tournamentId: t
							}))
						}
					}
				}, Q = e => {
					let {
						coinPackageId: t,
						optionId: n,
						postId: s,
						price: r
					} = e;
					return async (e, o, i) => {
						let {
							gqlContext: a
						} = i;
						const d = await Object(O.p)(a(), {
							coinPackageId: t,
							optionId: n,
							postId: s,
							price: r
						});
						return e(G({
							pollId: s,
							prediction: d,
							price: r
						})), d
					}
				}, Y = e => {
					let {
						optionId: t,
						postId: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = await Object(O.n)(o(), {
								optionId: t,
								postId: n
							}),
							{
								resolvePrediction: a
							} = i.body.data;
						if (!(null == a ? void 0 : a.poll)) throw new Error("Failed to resolve prediction");
						return e(W({
							pollId: n,
							prediction: a.poll
						})), a.poll
					}
				}, J = Object(x.a)(A.k), X = Object(x.a)(A.m), Z = Object(x.a)(A.l), $ = Object(x.a)(A.n), ee = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(T.I)(o, e);
					if (Object(R.k)(o, {
							subredditId: i
						})) return Object(R.g)(o, {
						subredditId: i
					});
					t(J({
						subredditId: i
					}));
					const a = await Object(O.k)(r(), {
							subredditName: e,
							isLatestOnly: !0,
							isIncludingPredictions: !0,
							isIncludingParticipants: !0,
							isIncludingCancelledPredictions: !0
						}),
						d = {};
					a.forEach(e => {
						var n;
						if ((null === (n = e.predictionPosts) || void 0 === n ? void 0 : n.length) && e.predictionPosts.forEach(e => {
								e && (d[e.id] = Object(C.f)(e))
							}), e.winners) {
							const n = E(e.winners);
							t(F({
								tournamentId: e.tournamentId,
								leaderboard: n
							}))
						}
					});
					const c = a.map(e => Object(j.a)(e));
					return t(Z({
						subredditId: i,
						tournaments: c
					})), t(X({
						subredditId: i,
						tournaments: c
					})), t($({
						posts: d,
						meta: o.meta
					})), c
				}, te = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = Object(T.I)(o, e),
						a = await Object(O.l)(r(), {
							subredditName: e,
							isLatestOnly: !0
						});
					t(ne(i, a))
				}, ne = (e, t) => n => {
					const s = t.map(e => Object(j.a)(e));
					n(X({
						subredditId: e,
						tournaments: s
					}))
				}, se = Object(x.a)(A.a), re = Object(x.a)(A.q), oe = Object(x.a)(A.r), ie = (e, t, n, s) => async (r, o, i) => {
					let {
						gqlContext: a
					} = i;
					const d = o(),
						c = Object(P.b)(d);
					let l = null;
					if (!c) throw new Error("Failed to create tournament, no prediction drafts attached");
					if (s instanceof File) {
						const {
							mediaId: t,
							mimeType: n
						} = await r(h(`icon_pred_${e}`, s));
						await Object(v.a)(3e3), l = {
							mediaId: t,
							width: 1,
							height: 1,
							mimeType: n.toLowerCase()
						}
					} else s && (l = {
						url: s,
						width: 1,
						height: 1,
						mimeType: ""
					});
					const u = await Object(O.e)(a(), {
							tournamentId: null,
							name: t,
							themeId: n,
							isStartImmediately: !0,
							subredditId: e,
							predictionDrafts: c,
							currency: b.R.Tokens,
							tokenIcon: l
						}),
						m = Object(j.a)(u);
					r(de(m))
				}, ae = (e, t) => async (n, s, o) => {
					let {
						gqlContext: i
					} = o;
					const a = Object(P.b)(s());
					if (!a) throw new Error("Failed to create prediction post, no prediction drafts attached");
					const d = await Object(O.a)(i(), {
							tournamentId: e,
							isStartImmediately: !0,
							iKey: `add-dfts-${Object(r.a)()}`,
							subredditId: t,
							predictionDrafts: a
						}),
						c = Object(j.a)(d);
					n(de(c))
				}, de = Object(x.a)(A.g), ce = (e, t, n) => async (t, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(O.o)(o(), {
							tournamentId: e,
							name: n
						}),
						a = Object(j.a)(i);
					t(de(a))
				}, le = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.f)(r(), {
							tournamentId: e
						}),
						{
							endPredictionTournament: i
						} = o.body.data;
					if (!i.tournament) throw new Error("Failed to update prediction name");
					return t(de(i.tournament)), i.tournament
				}, ue = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.g)(r(), {
						postId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch prediction chip packages");
					const {
						postInfoById: i
					} = o.body.data;
					if (!i.predictionChipPackages) throw new Error("Failed to fetch prediction chip packages");
					return i.predictionChipPackages
				}, me = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = await Object(O.h)(r(), {
						tournamentId: e
					});
					if (!o.ok || o.error) throw new Error("Failed to fetch token balance");
					const {
						identity: i
					} = o.body.data;
					if (!i.hasOwnProperty("predictionTokens")) throw new Error("Failed to fetch token balance");
					return i.predictionTokens
				}, pe = e => {
					let {
						coinPackageId: t,
						selectedOptionId: n,
						price: s,
						pollId: r,
						tournamentId: o,
						tournamentPostId: i
					} = e;
					return async e => {
						const a = await e(Q({
							coinPackageId: t,
							optionId: n,
							postId: r,
							price: s
						}));
						return e(H({
							predictionId: r,
							selectedOptionId: n,
							tournamentId: o,
							tournamentPostId: i
						})), a
					}
				}, be = e => async (t, n) => {
					const s = n();
					Object(N.R)(s) ? await t(Object(I.h)(S.a.ECON_PREDICTIONS_PREMIUM_UPSELL, {
						feature: e
					})) : await t(Object(k.openLoginModal)())
				}, fe = () => Object(I.g)(S.a.ECON_PREDICTIONS_PREMIUM_UPSELL), he = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					try {
						const n = await Object(O.b)(o(), {
							postId: e
						});
						t(V({
							postId: e,
							prediction: n
						}));
						const r = Object(_.e)(s.fbt._("Prediction has been cancelled", null, {
							hk: "3Bh9Fw"
						}), g.b.SuccessMod);
						t(Object(_.f)(r))
					} catch {
						const e = Object(_.e)(s.fbt._("Unable to cancel prediction", null, {
							hk: "2wkeKy"
						}), g.b.Error);
						t(Object(_.f)(e))
					}
				};

			function _e(e, t) {
				return async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = await Object(O.c)(o(), {
						postId: e,
						...t
					});
					return n(V({
						postId: e,
						prediction: i
					})), i
				}
			}
			const ge = e => async (t, n, s) => {
				let {
					gqlContext: r
				} = s;
				return Object(O.m)(r(), {
					subredditId: e
				})
			}
		},
		"./src/reddit/actions/economics/subredditPremium/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			}));
			const s = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_APPLIED",
				r = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_BADGE_TYPE_CHANGED",
				o = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_MODAL_OPENED",
				i = "ECONOMICS__SUBREDDIT_PREMIUM__BADGE_MANAGEMENT_VIEW_CHANGED",
				a = "ECONOMICS__SUBREDDIT_PREMIUM__EDITOR_PRODUCTS_FETCH_SUCCESS",
				d = "ECONOMICS__SUBREDDIT_PREMIUM__ORDER_SUCCESS",
				c = "ECONOMICS__SUBREDDIT_PREMIUM__SUBREDDIT_INFO_SUCCESS",
				l = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_CANCEL_SUCCESS",
				u = "ECONOMICS__SUBREDDIT_PREMIUM__SUBSCRIPTION_DATA_SUCCESS"
		},
		"./src/reddit/actions/emoji.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "o", (function() {
				return F
			})), n.d(t, "n", (function() {
				return B
			})), n.d(t, "k", (function() {
				return q
			})), n.d(t, "l", (function() {
				return G
			})), n.d(t, "i", (function() {
				return H
			})), n.d(t, "j", (function() {
				return W
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "m", (function() {
				return K
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/forEach.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/omitHeaders/index.ts"),
				c = n("./src/lib/uploadToS3/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			const u = async (e, t) => Object(a.a)(Object(d.a)(e, [l.a]), {
				endpoint: `${e.apiUrl}/api/v1/${t}/emojis/all`,
				method: i.ob.GET,
				type: "json"
			}).then(e => (e.ok && (e.body = (e => {
				let t;
				const n = o()(e, (e, n) => ("snoomojis" !== n && (t = n), o()(e, (t, n) => {
					e[n] = {
						name: n,
						userFlairAllowed: t.user_flair_allowed,
						postFlairAllowed: t.post_flair_allowed,
						modFlairOnly: t.mod_flair_only,
						url: t.url
					}
				})));
				return {
					[t]: {
						emojis: n[t],
						snoomojis: n.snoomojis
					}
				}
			})(e.body)), e));
			var m = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/reddit/actions/imageUploads.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/helpers/getGenericUploadError.ts"),
				h = n("./src/reddit/helpers/getS3KeyFromUrl/index.ts"),
				_ = n("./src/reddit/helpers/media/index.ts"),
				g = n("./src/reddit/models/Emoji/index.ts"),
				v = n("./src/reddit/models/Image/index.tsx"),
				x = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/emojis.ts"),
				E = n("./src/reddit/selectors/subreddit.ts");
			const y = "STRUCTURED_STYLES__NEW_EMOJI_ADDED",
				C = Object(m.a)(y),
				j = "STRUCTURED_STYLES__EMOJI_DELETE_LOADED",
				k = "STRUCTURED_STYLES__EMOJI_DELETE_FAILED",
				I = Object(m.a)(j),
				S = Object(m.a)(k),
				w = "GET_ALL_EMOJIS_PENDING",
				T = "GET_ALL_EMOJIS_LOADED",
				N = "GET_ALL_EMOJIS_FAILED",
				P = Object(m.a)(w),
				R = Object(m.a)(T),
				A = Object(m.a)(N),
				M = "STRUCTURED_STYLES__EMOJIS_ENABLED_SETTING_LOADED",
				L = Object(m.a)(M),
				D = e => ({
					text: s.fbt._("Failed to save emoji", null, {
						hk: "3i6FC2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "1XMjgA"
					}),
					buttonAction: B(e)
				}),
				F = e => {
					let {
						imageData: t,
						subredditId: n
					} = e;
					return async (e, s, r) => {
						const o = s(),
							u = Object(E.Y)(o, {
								subredditId: n
							}).name;
						e(Object(p.k)(t));
						const m = t.file,
							b = await Object(_.h)(m),
							f = await (async (e, t, n, s) => Object(a.a)(Object(d.a)(e, [l.a]), {
								endpoint: `${e.apiUrl}/api/v1/${t}/emoji_asset_upload_s3.json`,
								method: i.ob.POST,
								data: {
									filepath: n,
									mimetype: s
								}
							}))(r.apiContext(), u, m.name, b);
						let h = !1;
						if (f.ok) {
							const n = await (async (e, t, n) => Object(c.a)(n, t))(r.apiContext(), f.body.s3UploadLease, m);
							if (n.ok) {
								if (!s().imageUploads[t.id]) return Object(v.d)(t), !1;
								const r = decodeURIComponent(n.body.PostResponse.Location),
									o = f.body.websocketUrl,
									i = Object(v.n)(t, r, o);
								e(Object(p.j)(i)), h = !0
							} else {
								const s = Object(v.k)(t, n.error);
								e(Object(p.i)(s))
							}
						} else {
							const n = Object(v.k)(t, f.error);
							e(Object(p.i)(n))
						}
						return h
					}
				},
				U = (e, t) => async (n, s, r) => {
					const {
						imageData: o,
						subredditId: c,
						emojiName: u,
						settings: m
					} = e, f = Object(h.a)(o.url), _ = s(), g = Object(E.Y)(_, {
						subredditId: c
					}).name, x = await (async (e, t, n, s, r) => Object(a.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/emoji.json`,
						method: i.ob.POST,
						data: {
							s3_key: n,
							name: s,
							mod_flair_only: r.modFlairOnly,
							post_flair_allowed: r.postFlairAllowed,
							user_flair_allowed: r.userFlairAllowed
						}
					}))(r.apiContext(), g, f, u, m);
					if (!x.ok) {
						const s = Object(v.k)(o, x.error);
						n(Object(p.i)(s)), n(Object(b.f)(D(e))), t && t.close()
					}
					return x.ok
				}, B = e => async (t, n, r) => {
					const {
						imageData: o,
						subredditId: i,
						emojiName: a,
						settings: d
					} = e;
					if (t(Object(p.k)(o)), !o.websocketUrl) return t(Object(b.f)({
						text: s.fbt._("Could not upload emoji", null, {
							hk: "29nzfh"
						})
					}));
					let c;
					const l = new WebSocket(o.websocketUrl);
					return l.onopen = async () => {
						c = await U(e, l)(t, n, r)
					}, l.onmessage = n => {
						const s = JSON.parse(n.data);
						if ("success" === s.type) {
							c = !0;
							const e = s.payload.emoji_url,
								n = Object(v.o)(o, e);
							t(Object(p.l)(n));
							const r = Object(g.e)(a, n.url, i, d);
							t(C(r)), t(q(i))
						} else {
							const n = Object(f.a)(a),
								s = Object(v.k)(o, n);
							t(Object(p.i)(s)), t(Object(b.f)(D(e)))
						}
						l.close()
					}, l.onerror = n => {
						c = !1;
						const s = Object(f.a)(a),
							r = Object(v.k)(o, s);
						t(Object(p.i)(r)), t(Object(b.f)(D(e))), l.close()
					}, c
				}, q = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n();
					if (Object(O.a)(o, e)) return;
					const i = Object(E.Y)(o, {
						subredditId: e
					}).name;
					t(P(e));
					const a = await u(r(), i);
					if (a.ok) {
						const n = a.body;
						t(R({
							subredditId: e,
							data: n
						}))
					} else t(A({
						subredditId: e,
						error: a.error
					}))
				}, G = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					n().emojis[e] || await t(q(e))
				}, H = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(E.Y)(u, {
							subredditId: t
						}).name,
						p = await (async (e, t, n) => Object(a.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/v1/${n}/emoji/${t}`,
							method: i.ob.DELETE,
							type: "json"
						}))(c(), e, m);
					if (p.ok) {
						n(I({
							emojiName: e,
							subredditId: t
						})), n(b.f({
							kind: x.b.SuccessCommunityGreen,
							text: s.fbt._("Emoji successfully deleted", null, {
								hk: "1zMXEe"
							})
						}))
					} else n(S(p.error)), n(b.f({
						kind: x.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, W = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const u = r(),
						m = Object(E.Y)(u, {
							subredditId: e
						}).name;
					if ((await (async (e, t, n) => Object(a.a)(Object(d.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}/api/enable_emojis_in_sr.json`,
							method: i.ob.POST,
							data: {
								subreddit: t,
								enable: n
							}
						}))(c(), m, t)).ok) {
						n(L({
							subredditId: e,
							emojisEnabled: t
						}))
					} else n(b.f({
						kind: x.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "22u7ha"
						})
					}))
				}, V = "EMOJI_PERMISSIONS_UPDATED", z = Object(m.a)(V), K = (e, t, n, r) => async (o, c, u) => {
					let {
						apiContext: m
					} = u;
					const p = c(),
						f = Object(E.Y)(p, {
							subredditId: r
						}).name;
					(await (async (e, t, n, s) => Object(a.a)(Object(d.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/api/v1/${n}/emoji_permissions.json`,
						method: i.ob.POST,
						data: {
							name: t,
							post_flair_allowed: s.postFlairAllowed,
							user_flair_allowed: s.userFlairAllowed,
							mod_flair_only: s.modFlairOnly
						}
					}))(m(), e, f, n)).ok ? (o(z({
						emojiName: e,
						isSnoomoji: t,
						settings: n,
						subredditId: r
					})), o(b.f({
						kind: x.b.SuccessCommunityGreen,
						text: s.fbt._("Emoji permissions updated", null, {
							hk: "4b2RIU"
						})
					}))) : o(b.f({
						kind: x.b.Error,
						text: s.fbt._("Try again later", null, {
							hk: "4dziDF"
						})
					}))
				}
		},
		"./src/reddit/actions/eventPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			const s = "MOD_PAGE_EVENT_POSTS_LOADED",
				r = "MOD_PAGE_EVENT_POSTS_FAILED",
				o = "MOD_PAGE_EVENT_POSTS_PENDING",
				i = "MOD_PAGE_EVENT_POSTS_MORE_LOADED",
				a = "START_EVENT_NOW_SUCCESS",
				d = "EDIT_EVENT_TIME_SUCCESS"
		},
		"./src/reddit/actions/eventPosts/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "fetchEventPostsPending", (function() {
				return x
			})), n.d(t, "fetchEventPostsSuccess", (function() {
				return O
			})), n.d(t, "fetchEventPostsFailure", (function() {
				return E
			})), n.d(t, "fetchMoreEventPostsSuccess", (function() {
				return y
			})), n.d(t, "eventPostsRequested", (function() {
				return C
			})), n.d(t, "startEventNowSuccess", (function() {
				return j
			})), n.d(t, "startEventNowRequested", (function() {
				return k
			})), n.d(t, "editEventTimeSuccess", (function() {
				return I
			})), n.d(t, "editEventTimeRequested", (function() {
				return S
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/eventPosts/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/EventPostsBySubredditName.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts");
			var p = (e, t, n, s, o) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/api/event_post_time.json`,
				method: r.ob.POST,
				data: {
					id: t,
					event_start: n,
					event_end: s,
					event_tz: o
				}
			});
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/start_event_post.json`,
					method: r.ob.POST,
					data: {
						id: t
					}
				}),
				f = n("./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/eventPosts.ts"),
				g = n("./src/reddit/selectors/posts.ts");
			const v = () => s.fbt._("Something went wrong. Just don't panic.", null, {
					hk: "4onxm1"
				}),
				x = Object(o.a)(i.e),
				O = Object(o.a)(i.c),
				E = Object(o.a)(i.b),
				y = Object(o.a)(i.d),
				C = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s, o = n();
					const i = Object(_.d)(o, {
							subredditName: e
						}),
						l = Object(_.b)(o, {
							subredditName: e
						}),
						u = Object(_.c)(o, {
							subredditName: e
						}),
						m = Object(_.a)(o, {
							subredditName: e
						}),
						p = l && u;
					if (i) return;
					const b = {
						name: e,
						pageSize: 25,
						nonInclusiveCursor: null
					};
					if (p) b.nonInclusiveCursor = m;
					else if (l && !u) return;
					const g = Object(_.e)(o, {
						subredditName: e
					});
					t(x({
						key: g
					}));
					const C = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), b);
					if (C.ok) {
						const {
							subredditInfoByName: e
						} = C.body.data, {
							eventPosts: s
						} = e, r = Object(f.a)(s);
						let i = [],
							a = {};
						const d = s.pageInfo || {
							hasNextPage: !1,
							endCursor: null,
							hasPreviousPage: !1,
							startCursor: null
						};
						r.length > 0 && (i = r.map(e => e.id), a = r.reduce((e, t) => (e[t.id] = t, e), {})), o = n(), t((p ? y : O)({
							key: g,
							postIds: i,
							meta: o.meta,
							posts: a,
							pageInfo: d
						}))
					} else t(E({
						error: C.error,
						key: g
					})), t(Object(a.f)({
						kind: h.b.Error,
						text: v()
					}))
				}, j = Object(o.a)(i.f), k = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if ((await b(o(), e)).ok) {
						const r = () => s.fbt._("Following event has started successfully: {title}", [s.fbt._param("title", d)], {
							hk: "e9iz9"
						});
						t(j({
							postId: e
						}));
						const o = n(),
							i = Object(g.G)(o, {
								postId: e
							}),
							d = i && i.title || "";
						t(Object(a.f)({
							kind: h.b.SuccessMod,
							text: r()
						}))
					} else t(Object(a.f)({
						kind: h.b.Error,
						text: v()
					}))
				}, I = Object(o.a)(i.a), S = (e, t) => async (n, o, i) => {
					let {
						apiContext: d
					} = i;
					const c = await p(d(), e, t.startDate, t.endDate, t.timezoneName);
					if (c.ok) {
						const t = c.body,
							i = 14400,
							d = Math.round(t.event_start / r.Xb);
						let l = t.event_end;
						const u = {
							eventStart: d,
							eventEnd: l = l && Math.round(l / r.Xb) || d + i,
							eventIsLive: t.event_is_live
						};
						n(I({
							postId: e,
							eventInfo: u
						}));
						const m = o(),
							p = Object(g.G)(m, {
								postId: e
							}),
							b = p && p.title || "",
							f = () => s.fbt._("Following event time is updated successfully: {title}", [s.fbt._param("title", b)], {
								hk: "1m1w1c"
							});
						n(Object(a.f)({
							kind: h.b.SuccessMod,
							text: f()
						}))
					} else n(Object(a.f)({
						kind: h.b.Error,
						text: v()
					}))
				}
		},
		"./src/reddit/actions/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return x
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "g", (function() {
				return j
			})), n.d(t, "o", (function() {
				return P
			})), n.d(t, "p", (function() {
				return R
			})), n.d(t, "b", (function() {
				return A
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "n", (function() {
				return B
			})), n.d(t, "e", (function() {
				return q
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "d", (function() {
				return H
			})), n.d(t, "m", (function() {
				return K
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/addQueryParams/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = e => {
				return e.reduce((e, t) => (e[t.provider] = t, e), {})
			};
			var b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/models/User/index.ts"),
				h = n("./src/reddit/selectors/externalAccount.ts"),
				_ = n("./src/reddit/selectors/platform.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/selectors/user.ts");
			const x = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				O = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				E = "USER_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				y = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_PENDING",
				C = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_LOADED",
				j = "SUBREDDIT_EXTERNAL_ACCOUNT_ACCOUNTS_FAILED",
				k = Object(r.a)(x),
				I = Object(r.a)(O),
				S = Object(r.a)(E),
				w = Object(r.a)(y),
				T = Object(r.a)(C),
				N = Object(r.a)(j),
				P = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						i = Object(v.l)(o),
						a = e || i && Object(f.e)(i);
					if (!a) return;
					if (Object(h.d)(o, {
							username: a
						})) return;
					t(k(a));
					const b = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/user/${t}.json`),
						traceRequestName: "get_external_accounts",
						method: d.ob.GET
					}))(r(), a);
					if (b.ok) {
						const e = p(b.body);
						t(I({
							username: a,
							accountsData: e
						}))
					} else t(S(b.error))
				}, R = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t(),
						o = Object(_.d)(r);
					if (!o) return;
					const i = r.externalAccount.api.subreddit.fetched[o],
						a = r.externalAccount.api.subreddit.pending[o];
					if (i || a) return;
					const b = Object(g.z)(r, {
						subredditName: o
					});
					if (!(b && b.hasExternalAccount)) return;
					e(w(o));
					const f = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/subreddit/${t}.json`),
						method: d.ob.GET
					}))(s(), o);
					if (f.ok) {
						const t = p(f.body);
						e(T({
							subredditName: o,
							accountsData: t
						}))
					} else e(N(f.error))
				}, A = "EXTERNAL_ACCOUNT_DISCONNECT_PENDING", M = "EXTERNAL_ACCOUNT_DISCONNECT_SUCCESS", L = "EXTERNAL_ACCOUNT_DISCONNECT_FAILED", D = Object(r.a)(A), F = Object(r.a)(M), U = Object(r.a)(L), B = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(D({
						provider: e
					}));
					const o = Object(v.l)(n()),
						i = Object(f.e)(o),
						a = await ((e, t) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/disconnect.json`),
							method: d.ob.POST
						}))(r(), e);
					a.ok ? t(F({
						provider: e,
						username: i
					})) : t(U({
						provider: e,
						error: a.error
					}))
				}, q = "OAUTH_FLOW_URL_PENDING", G = "OAUTH_FLOW_URL_SUCCESS", H = "OAUTH_FLOW_URL_FAILED", W = Object(r.a)(q), V = Object(r.a)(G), z = Object(r.a)(H), K = e => async (t, n, r) => {
					let {
						apiContext: p
					} = r;
					t(W({
						provider: e
					}));
					const f = Object(o.a)(window.location.href, {
							[a.e]: e
						}),
						h = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: Object(m.a)(`${e.apiUrl}/api/v1/external_account/${t}/connect.json`),
							method: d.ob.POST,
							data: {
								redirect_url: n
							}
						}))(p(), e, f);
					if (h.ok) {
						const {
							redirect_url: n
						} = h.body;
						t(V({
							provider: e
						})), window.location.href = n
					} else t(z({
						provider: e,
						error: h.error
					})), t(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "196FiB"
						})
					}))
				}
		},
		"./src/reddit/actions/gold/achievementFlairs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/SubredditAchievementFlairs.json");
			const c = (e, t) => Object(a.a)(e, {
				...d,
				variables: {
					subredditId: t
				}
			}, {
				traceRequestName: "subreddit_achievement_flairs"
			});
			var l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/gold/powerups/flairs.ts"),
				m = n("./src/reddit/actions/gold/constants.ts");
			const p = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, i) => {
						let {
							gqlContext: a
						} = i;
						const d = r();
						if (!(null != Object(u.c)(d, {
								subredditId: e
							})) || t.forceLoad) {
							n(h());
							try {
								const t = await c(a(), e);
								if (!t.ok) return;
								const {
									errors: s,
									data: r
								} = t.body;
								if (null == s ? void 0 : s.length) return void(await n(v(s[0].message)));
								const o = b(r.subredditInfoById);
								f(n, e, o)
							} catch (l) {
								o.c.captureException(l), await n(v(s.fbt._("Something went wrong", null, {
									hk: "1IJNeH"
								})))
							}
						}
					}
				},
				b = e => {
					const {
						achievementFlairsStatus: t = {
							isEnabled: !1
						},
						subredditAchievementFlairs: n = []
					} = e || {};
					return {
						achievementFlairsStatus: t,
						subredditAchievementFlairs: n
					}
				},
				f = (e, t, n) => e(_({
					subredditId: t,
					...n
				})),
				h = Object(r.a)(m.hb),
				_ = Object(r.a)(m.gb),
				g = Object(r.a)(m.fb),
				v = e => async t => {
					await t(g(e)), t(Object(i.f)({
						kind: l.b.Error,
						duration: i.a,
						text: e
					}))
				}
		},
		"./src/reddit/actions/gold/communityAwards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = e => () => n.e("CommunityAwards").then(n.bind(null, "./src/reddit/actions/gold/communityAwards/communityAwards.ts")).then(t => t[e]),
				o = Object(s.a)(r("awardSheetInfoRequested")),
				i = Object(s.a)(r("manageableAwardsRequested")),
				a = Object(s.a)(r("createCommunityAward")),
				d = Object(s.a)(r("createGlobalAward")),
				c = Object(s.a)(r("createModAward")),
				l = Object(s.a)(r("createAwardFailed")),
				u = Object(s.a)(r("createAwardSuccessful")),
				m = Object(s.a)(r("removeCommunityAward")),
				p = Object(s.a)(r("disableAwardinCommunity")),
				b = Object(s.a)(r("enableAwardinCommunity"))
		},
		"./src/reddit/actions/gold/customEmojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/gold/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/SubredditCustomEmojis.json");
			const l = (e, t) => Object(d.a)(e, {
				...c,
				variables: {
					subredditId: t
				}
			}, {
				traceRequestName: "subreddit_custom_emojis"
			});
			var u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/experiments/econ/index.ts"),
				p = n("./src/reddit/selectors/gold/powerups/index.ts");
			const b = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, r, i) => {
						let {
							gqlContext: a
						} = i;
						const d = r();
						if (!(!Object(m.d)(d) || null != Object(p.a)(d, {
								subredditId: e
							})) || t.forceLoad) {
							n(_());
							try {
								const t = await l(a(), e);
								if (!t.ok) return;
								const {
									errors: s,
									data: r
								} = t.body;
								if (null == s ? void 0 : s.length) return void(await n(x(s[0].message)));
								const o = f(r.subredditInfoById);
								h(n, e, o)
							} catch (c) {
								o.c.captureException(c), await n(x(s.fbt._("Something went wrong", null, {
									hk: "1IJNeH"
								})))
							}
						}
					}
				},
				f = e => {
					const {
						customEmojisStatus: t = {
							isEnabled: !1
						},
						customEmojis: n = {}
					} = e || {};
					return {
						customEmojisStatus: t,
						customEmojis: n
					}
				},
				h = (e, t, n) => e(g({
					subredditId: t,
					...n
				})),
				_ = Object(r.a)(i.kb),
				g = Object(r.a)(i.jb),
				v = Object(r.a)(i.ib),
				x = e => async t => {
					await t(v(e)), t(Object(a.f)({
						kind: u.b.Error,
						duration: a.a,
						text: e
					}))
				}
		},
		"./src/reddit/actions/gold/modals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "c", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "f", (function() {
				return C
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/postParentMessage/index.ts"),
				o = n("./src/reddit/helpers/isPost.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				a = n("./src/reddit/selectors/gild.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/selectors/communityAwards.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				b = n("./src/telemetry/index.ts"),
				f = n("./src/reddit/actions/gold/constants.ts");
			const h = Object(s.a)(f.J),
				_ = Object(s.a)(f.f),
				g = () => async (e, t) => {
					const s = t();
					e(_()), Object(d.b)(d.a.GiftPremiumFlow);
					const {
						clickCloseModalEvent: r
					} = await n.e("givePremiumTrackers").then(n.bind(null, "./src/reddit/helpers/trackers/givePremium.ts"));
					Object(b.a)(r()(s))
				}, v = Object(s.a)(f.I), x = e => {
					let {
						awardId: t,
						correlationId: n,
						thingId: s
					} = e;
					return async (e, r) => {
						const a = r(),
							d = t ? Object(u.a)(a, t) : void 0;
						e(v({
							award: d && d.isEnabled ? d : void 0,
							thingId: s,
							correlationId: n
						})), e(Object(l.h)(i.a.GOLD_GILD_MODAL));
						const b = Object(p.O)(a, {
							thingId: s
						});
						let f = null;
						if (b) f = b.id;
						else if (Object(o.a)(s)) {
							const e = Object(m.G)(a, {
								postId: s
							});
							e && (f = e.belongsTo.id)
						}
						f && Object(c.a)(f, s)
					}
				}, O = Object(s.a)(f.e), E = Object(s.a)(f.H), y = () => async (e, t) => {
					const s = t(),
						o = Object(a.d)(s);
					if (Object(a.g)(s)) {
						const e = "close.gild";
						Object(r.a)({
							type: e
						})
					}
					e(O()), e(Object(l.g)(i.a.GOLD_GILD_MODAL));
					const {
						clickCloseGildModalEvent: c
					} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
					Object(b.a)(c(o)(s)), Object(d.b)(d.a.GildingFlow)
				}, C = () => async () => {
					Object(r.a)({
						type: "login.gild"
					})
				}
		},
		"./src/reddit/actions/gold/powerups.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return _
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "f", (function() {
				return D
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/login.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/constants/modals.ts"),
				l = n("./src/reddit/endpoints/gold/powerups/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/experiments/econ/index.ts"),
				p = n("./src/reddit/selectors/gold/powerups/index.ts"),
				b = n("./src/reddit/selectors/gold/powerups/benefitSettings.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				h = n("./src/reddit/actions/gold/constants.ts");
			const _ = e => async (t, n, r) => {
				let {
					gqlContext: i
				} = r;
				if (!!n().user.powerups.fetched && !e) return;
				t(g());
				const a = s.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const e = await Object(l.g)(i());
					if (e.ok) {
						const n = e.body;
						if (n.errors && n.errors.length) return void(await t(O(a)));
						if (!n.data.identity) return void(await t(x(a)));
						await t(v({
							powerups: n.data.identity.powerups
						}))
					}
				} catch (d) {
					o.c.captureException(d), await t(O(a))
				}
			}, g = Object(r.a)(h.zb), v = Object(r.a)(h.yb), x = Object(r.a)(h.xb), O = e => async (t, n) => {
				await t(x(e)), t(Object(d.f)({
					kind: u.b.Error,
					duration: d.a,
					text: e
				}))
			}, E = (e, t) => async (e, n, r) => {
				let {
					gqlContext: i
				} = r;
				var a;
				if (!!n().users.powerups.fetched) return;
				e(y());
				const d = s.fbt._("Something went wrong", null, {
					hk: "1IJNeH"
				});
				try {
					const n = await Object(l.d)(i(), t);
					if (n.ok) {
						const s = n.body;
						if (s.errors && s.errors.length) return void(await e(k(d)));
						if (!s.data.redditorInfoById) return void(await e(j(d)));
						const r = (null === (a = s.data.redditorInfoById.powerups) || void 0 === a ? void 0 : a.supportedSubreddits) || [];
						await e(C({
							supportedSubreddits: r,
							userId: t
						}))
					}
				} catch (c) {
					o.c.captureException(c), await e(k(d))
				}
			}, y = Object(r.a)(h.Z), C = Object(r.a)(h.Y), j = Object(r.a)(h.X), k = e => async (t, n) => {
				await t(j(e)), t(Object(d.f)({
					kind: u.b.Error,
					duration: d.a,
					text: e
				}))
			}, I = function(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				return async (n, r, i) => {
					let {
						gqlContext: a
					} = i;
					var d;
					const c = r();
					if (Object(p.e)(c, {
							subredditId: e
						}) && Object(b.a)(c, {
							subredditId: e
						}) && !t.forceLoad) return;
					n(T());
					const u = t.fullData ? l.f : l.e;
					try {
						const s = await u(a(), e, !!t.includeIdentity, Object(m.d)(c));
						if (s.ok) {
							const r = s.body;
							if (null === (d = r.errors) || void 0 === d ? void 0 : d.length) return void(await n(A(r.errors[0].message)));
							if (t.fullData) {
								const {
									data: t
								} = r, s = S(t.subredditInfoById, t.identity);
								w(n, e, s)
							} else {
								const {
									powerups: t = null,
									powerupsSettings: s = null
								} = r.data.subredditInfoById || {};
								await n(N({
									powerups: t,
									subredditId: e,
									benefitStatuses: null == s ? void 0 : s.benefitStatuses
								}))
							}
						}
					} catch (f) {
						o.c.captureException(f), await n(A(s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})))
					}
				}
			}, S = (e, t) => {
				var n, s, r;
				const {
					powerups: o = null,
					powerupsSettings: i = null,
					supporters: a = null,
					productOffers: d = null,
					subredditAchievementFlairs: c
				} = e || {}, l = null == t ? void 0 : t.powerups;
				return {
					powerups: o,
					benefitStatuses: null == i ? void 0 : i.benefitStatuses,
					productOffers: null !== (n = null == d ? void 0 : d.offers) && void 0 !== n ? n : [],
					recentSupporters: null !== (s = null == a ? void 0 : a.recentSupporters) && void 0 !== s ? s : [],
					topSupporters: null !== (r = null == a ? void 0 : a.topSupporters) && void 0 !== r ? r : [],
					userPowerups: l,
					subredditAchievementFlairs: null != c ? c : []
				}
			}, w = (e, t, n) => e(P({
				subredditId: t,
				...n
			})), T = Object(r.a)(h.pb), N = Object(r.a)(h.ob), P = Object(r.a)(h.nb), R = Object(r.a)(h.mb), A = e => async (t, n) => {
				await t(R(e)), t(Object(d.f)({
					kind: u.b.Error,
					duration: d.a,
					text: e
				}))
			}, M = () => async (e, t) => {
				const n = t();
				return Object(f.l)(n) ? e(Object(a.h)(c.a.ACHIEVEMENT_FLAIR)) : e(Object(i.openLoginModal)())
			}, L = Object(r.a)(h.L), D = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const i = await Object(l.h)(o(), e, (e => Object.keys(e).map(t => ({
					benefit: t,
					isEnabled: e[t]
				})))(t));
				if (i.ok) {
					const t = i.body.data.updatePowerupsSettings.powerupsSettings.benefitStatuses;
					return n(L({
						subredditId: e,
						benefitStatuses: t
					})), !0
				}
				return !1
			}
		},
		"./src/reddit/actions/governance/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "n", (function() {
				return h
			})), n.d(t, "o", (function() {
				return _
			})), n.d(t, "p", (function() {
				return g
			})), n.d(t, "q", (function() {
				return v
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "s", (function() {
				return O
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "u", (function() {
				return y
			})), n.d(t, "v", (function() {
				return C
			})), n.d(t, "w", (function() {
				return j
			})), n.d(t, "x", (function() {
				return k
			}));
			const s = "GOVERNANCE__COMMUNITY_DETAILS_SUCCESS",
				r = "GOVERNANCE__NEW_SUBREDDIT_SUGGESTED",
				o = "GOVERNANCE__NEW_TOP_MOD_SUGGESTED",
				i = "GOVERNANCE__OPT_OUT_MODAL_OPENED",
				a = "POLL_VOTE_SUCCESS",
				d = "GOVERNANCE__PROPOSAL_CREATION_FAILURE",
				c = "GOVERNANCE__PROPOSAL_CREATION_PENDING",
				l = "GOVERNANCE__PROPOSAL_CREATION_SUCCESS",
				u = "GOVERNANCE__PROPOSAL_OPTION_VOTE_FAILURE",
				m = "GOVERNANCE__PROPOSAL_OPTION_VOTE_PENDING",
				p = "GOVERNANCE__PROPOSAL_OPTION_VOTE_SUCCESS",
				b = "GOVERNANCE__PUBLIC_WALLET_INFO_FAILURE",
				f = "GOVERNANCE__PUBLIC_WALLET_INFO_PENDING",
				h = "GOVERNANCE__PUBLIC_WALLET_INFO_SUCCESS",
				_ = "GOVERNANCE__RELEASE_NOTES_MODAL_OPENED",
				g = "GOVERNANCE__RELEASE_NOTES_SUCCESS",
				v = "GOVERNANCE__TRANSFER_FAILURE",
				x = "GOVERNANCE__TRANSFER_MODAL_OPENED",
				O = "GOVERNANCE__TRANSFER_PENDING",
				E = "GOVERNANCE__TRANSFER_SUCCESS",
				y = "GOVERNANCE__WALLETS_FETCH_FAILURE",
				C = "GOVERNANCE__WALLETS_FETCH_PENDING",
				j = "GOVERNANCE__WALLETS_FETCH_SUCCESS",
				k = "GOVERNANCE__WALLET_REGISTRATION_MODAL_OPENED"
		},
		"./src/reddit/actions/governance/errorToast.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/actions/toaster.ts"),
				r = n("./src/reddit/helpers/governanceErrorText/index.ts"),
				o = n("./src/reddit/models/Toast/index.ts");

			function i(e, t) {
				e(Object(s.f)({
					duration: 5e3,
					kind: o.b.Error,
					text: Object(r.a)(t)
				}))
			}
		},
		"./src/reddit/actions/governance/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return y
			})), n.d(t, "f", (function() {
				return S
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "d", (function() {
				return M
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "h", (function() {
				return D
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/prettyPrintNumber/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/config.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/reddit/models/Poll/index.ts"),
				m = n("./src/redditGQL/operations/PollVote.json"),
				p = n("./src/reddit/endpoints/governance/requester.ts");
			var b = n("./src/reddit/endpoints/governance/wallet.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/models/Vote/index.ts"),
				_ = n("./src/reddit/selectors/crypto/points.ts"),
				g = n("./src/reddit/actions/governance/constants.ts"),
				v = n("./src/reddit/actions/governance/errorToast.ts");
			const x = Object(r.a)(g.b),
				O = Object(r.a)(g.c),
				E = Object(r.a)(g.e),
				y = (Object(r.a)(g.f), Object(r.a)(g.g), Object(r.a)(g.h)),
				C = Object(r.a)(g.i),
				j = Object(r.a)(g.j),
				k = Object(r.a)(g.k),
				I = Object(r.a)(g.q),
				S = Object(r.a)(g.r),
				w = Object(r.a)(g.s),
				T = Object(r.a)(g.t),
				N = Object(r.a)(g.u),
				P = Object(r.a)(g.v),
				R = Object(r.a)(g.w),
				A = Object(r.a)(g.x),
				M = (e, t) => async (n, s, r) => {
					let o, {
							apiContext: i,
							gqlContext: d
						} = r,
						b = s().polls.models[e];
					if (n(j({
							pollId: e
						})), (o = b.type === u.a.GA ? await ((e, t, n) => Object(l.a)(e, {
								...m,
								variables: {
									input: {
										postId: t,
										optionId: n
									}
								}
							}))(d(), e, t) : await
							function(e, t, n, s) {
								return Object(p.a)(e, {
									method: "put",
									endpoint: `${c.a.metaUrl}/polls/${t}/${n}/votes/me/${s}`
								})
							}(i(), b.subredditId, e, t)).ok) {
						if (b.type === u.a.GA) {
							const {
								options: e
							} = o.body.data.updatePostPollVoteState.poll;
							n(E({
								pollId: b.id,
								optionId: t,
								options: e
							}))
						} else n(k(o.body));
						const r = s();
						if ((b = r.polls.models[e]) && Object(u.d)(b)) {
							const {
								postId: e
							} = b, t = r.posts.models[e];
							t && t.voteState === h.a.notVoted && n(Object(a.jb)(e))
						}
					} else n(C({
						pollId: e,
						error: o.error || o.errors[0].message
					})), Object(v.a)(n, o.error || o.errors[0].messsage)
				}, L = (e, t) => async (n, r, a) => {
					let {
						apiContext: l
					} = a;
					var u;
					n(w());
					const m = r().transfers.communityPoints.contentId || void 0,
						b = await
					function(e, t) {
						return Object(p.a)(e, {
							data: {
								amount: t.amount,
								contentId: t.contentId,
								description: t.message,
								receiveUserName: t.recipient
							},
							endpoint: `${c.a.metaUrl}/wallets/me/${t.subredditId}/transfers`,
							method: "post"
						})
					}(l(), {
						...e,
						contentId: m
					});
					b.ok ? (n(T({
						...b.body,
						subredditId: e.subredditId
					})), n(Object(d.f)({
						kind: f.b.SuccessCommunity,
						text: s.fbt._("Success! You just transferred {amount} {tokenName} to {recipient}", [s.fbt._param("amount", Object(o.a)(e.amount)), s.fbt._param("tokenName", (null === (u = Object(_.b)(r(), e.subredditId)) || void 0 === u ? void 0 : u.name) || ""), s.fbt._param("recipient", e.recipient)], {
							hk: "3klrhq"
						})
					})), t && n(Object(i.f)())) : (n(I({
						error: b.error
					})), Object(v.a)(n, b.error))
				}, D = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(P());
					const o = await Object(b.a)(r(), e);
					o.ok ? t(R(o.body)) : t(N({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/grantUserFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			const s = "SUBREDDIT__FLAIRED_USERS_PENDING",
				r = "SUBREDDIT__FLAIRED_USERS_LOADED",
				o = "SUBREDDIT__FLAIRED_USERS_FAILED",
				i = "SUBREDDIT__FLAIRED_USERS_SEARCH_PENDING",
				a = "SUBREDDIT__FLAIRED_USERS_SEARCH_LOADED",
				d = "SUBREDDIT__FLAIRED_USERS_SEARCH_FAILED",
				c = "SUBREDDIT__FLAIRED_USERS_OWNFLAIR_CHANGED",
				l = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_ADDED",
				u = "SUBREDDIT__FLAIRED_USERS_AUTHORFLAIR_CHANGED",
				m = "SUBREDDIT__FLAIRED_USERS_DELETE_PENDING",
				p = "SUBREDDIT__FLAIRED_USERS_DELETE_COMPLETED",
				b = "SUBREDDIT__FLAIRED_USERS_DELETE_FAILED"
		},
		"./src/reddit/actions/grantUserFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return E
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "c", (function() {
				return A
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/SubredditFlairedRedditorByName.json"),
				a = n("./src/redditGQL/operations/SubredditFlairedRedditors.json");
			var d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts");
			var m = e => {
				const {
					subreddit: t,
					redditorInfoByName: n
				} = e.data, {
					id: s,
					flairedRedditorByName: r
				} = t, o = {};
				let i = null;
				if (!n) return {
					subredditId: s,
					searchResult: i,
					flairedUsers: o
				};
				const {
					name: a
				} = n;
				if (i = a, r) {
					const {
						flair: e,
						redditor: t
					} = r, {
						name: n
					} = t;
					e && (o[n] = Object(u.a)(e)[0])
				}
				return {
					subredditId: s,
					searchResult: i,
					flairedUsers: o
				}
			};
			var p = e => {
					const {
						subreddit: t
					} = e.data, {
						id: n,
						flairedRedditors: s
					} = t, {
						pageInfo: r,
						edges: o
					} = s, i = [], a = {};
					return o.forEach(e => {
						const {
							node: t
						} = e, {
							flair: n,
							redditor: {
								name: s
							}
						} = t;
						if (i.push(s), n) {
							const e = Object(u.a)(n)[0];
							a[s] = e
						}
					}), {
						subredditId: n,
						flairedUsers: a,
						userOrder: i,
						pageInfo: r
					}
				},
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/models/User/index.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/grantUserFlair/constants.ts");
			const v = Object(r.a)(g.i),
				x = Object(r.a)(g.g),
				O = Object(r.a)(g.f),
				E = (e, t) => async (n, r, i) => {
					let {
						gqlContext: d
					} = i;
					const l = t && t.after || "",
						u = t && t.before || "",
						m = Object(_.I)(r(), e),
						h = Object(b.e)(m, l, u);
					if (!!r().pages.modHub.flairedUsers.userOrder[h]) return;
					n(v());
					const g = await ((e, t, n) => Object(o.a)(e, {
						...a,
						variables: {
							subredditName: t,
							...n
						}
					}))(d(), e, t);
					if (g.ok) {
						const e = {
							...p(g.body),
							key: h
						};
						n(x(e))
					} else {
						const e = g.error;
						n(O(e)), n(Object(c.f)({
							kind: f.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1IJNeH"
							})
						}))
					}
				}, y = Object(r.a)(g.l), C = Object(r.a)(g.k), j = Object(r.a)(g.j), k = (e, t) => async (n, r, a) => {
					let {
						gqlContext: d
					} = a;
					const l = Object(_.Y)(r(), {
						subredditId: e
					}).name;
					n(y());
					const u = await ((e, t, n) => Object(o.a)(e, {
						...i,
						variables: {
							subredditName: t,
							name: n
						}
					}))(d(), l, t);
					if (u.ok) {
						const e = m(u.body);
						n(C(e))
					} else n(j(u.error)), n(Object(c.f)({
						kind: f.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						})
					}))
				}, I = Object(r.a)(g.e), S = Object(r.a)(g.c), w = Object(r.a)(g.d), T = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r(),
						l = Object(_.Y)(a, {
							subredditId: t
						}).name;
					n(I());
					const u = await Object(d.a)(i(), e, l);
					if (u.ok) {
						n(S({
							userName: e,
							subredditId: t
						}));
						const r = Object(c.e)(s.fbt._("User flair cleared", null, {
							hk: "4yyH00"
						}), f.b.SuccessMod);
						n(Object(c.f)(r))
					} else {
						n(w());
						const r = Object(c.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "uG2KO"
						}), f.b.Error, s.fbt._("Retry", null, {
							hk: "3oiY99"
						}), T(e, t));
						n(Object(c.f)(r))
					}
					return u.ok || u.error
				}, N = Object(r.a)(g.h), P = Object(r.a)(g.b), R = Object(r.a)(g.a), A = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					const u = o(),
						m = u.pages.modHub.flairedUsers.search.result === e && !u.pages.modHub.flairedUsers.models[e],
						p = {
							userName: e,
							subredditId: t,
							applied: n
						},
						b = n && n.templateId,
						g = Object(_.Y)(u, {
							subredditId: t
						}),
						v = n && Object(l.g)(n),
						x = n ? n.cssClass : void 0,
						O = await Object(d.g)(a(), e, g.name, b, v, x);
					if (O.ok) {
						if (m) {
							let e;
							Object.keys(u.pages.modHub.flairedUsers.userOrder).forEach(t => {
								!1 === u.pages.modHub.flairedUsers.pageInfo[t].hasNextPage && u.pages.modHub.flairedUsers.userOrder[t].length < 50 && (e = t)
							});
							const t = {
								...p,
								key: e
							};
							r(R(t))
						}
						e === (u.user.account && Object(h.e)(u.user.account)) ? r(N(p)) : m || r(P(p))
					} else {
						const e = Object(c.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "4hXQvr"
						}), f.b.Error);
						r(Object(c.f)(e))
					}
					return O.ok || O.error
				}
		},
		"./src/reddit/actions/inContextModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "INCONTEXT__BANNED",
				o = "INCONTEXT__MUTED",
				i = Object(s.a)(r),
				a = Object(s.a)(o)
		},
		"./src/reddit/actions/inboxBanner/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "INBOX_NOTIFICATIONS__BANNER_DISMISS",
				r = "INBOX_NOTIFICATIONS__BANNER_RECEIVED"
		},
		"./src/reddit/actions/inboxBanner/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/inboxBanner/constants.ts");
			const o = Object(s.a)(r.a),
				i = Object(s.a)(r.b)
		},
		"./src/reddit/actions/jsApi.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "JSAPI__CONSUMER_SUBSCRIBED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/meta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "h", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "g", (function() {
				return h
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "i", (function() {
				return O
			})), n.d(t, "j", (function() {
				return E
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				l = n("./src/reddit/selectors/user.ts");
			const u = "META__GEO_CHANGED",
				m = Object(o.a)(u),
				p = "META__META_RECEIVED",
				b = (Object(o.a)(p), "META__SET_LOCALE"),
				f = Object(o.a)(b),
				h = e => async (t, n, o) => {
					let {
						apiContext: u
					} = o;
					if (!e) return;
					const m = n(),
						p = u();
					let b;
					if (t(f(e)), Object(s.isPseudoLocale)(e) ? (Object(l.O)(m) || Object(c.b)(m)) && (b = e) : b = Object(s.isoLocaleToR2Language)(e), !b) return;
					const h = new URL(window.location.href);
					Object(l.R)(m) ? Object(s.isPseudoLocale)(b) ? h.searchParams.set("locale", b) : (await Object(i.a)(Object(a.a)(p, [d.a]), {
						data: {
							lang: b
						},
						endpoint: `${p.apiUrl}/api/v1/me/prefs`,
						method: r.ob.PATCH,
						type: "json"
					}), h.searchParams.delete("locale")) : h.searchParams.delete("locale"), window.location.href = h.toString()
				}, _ = "META__SET_POPULAR_GEO_FILTER", g = Object(o.a)(_), v = "META__PWA_ENTERED", x = "META__PWA_LEFT", O = Object(o.a)(v), E = Object(o.a)(x)
		},
		"./src/reddit/actions/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return ie
			})), n.d(t, "d", (function() {
				return ce
			})), n.d(t, "f", (function() {
				return pe
			})), n.d(t, "a", (function() {
				return be
			})), n.d(t, "b", (function() {
				return fe
			})), n.d(t, "c", (function() {
				return he
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/bulkActions/index.ts"),
				a = n("./src/reddit/actions/removalReasons/index.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/modQueue/index.ts"),
				l = n("./src/reddit/endpoints/user/index.ts"),
				u = n("./src/reddit/helpers/correlationIdTracker.ts"),
				m = n("./src/reddit/helpers/flair.ts"),
				p = n("./node_modules/Base64/base64.js"),
				b = n("./src/reddit/components/ModQueueList/PostSortDropdown.tsx"),
				f = n("./src/reddit/helpers/isPost.ts"),
				h = n("./src/reddit/selectors/commentSelector.ts"),
				_ = n("./src/reddit/selectors/posts.ts"),
				g = n("./src/reddit/models/Flair/index.ts"),
				v = n("./src/reddit/selectors/experiments/realtimeMQUpdates.ts"),
				x = n("./src/redditGQL/types.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeCommentFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeModActivityFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const k = {
					[r.wb.Edited]: x.E.Edited,
					[r.wb.Modqueue]: x.E.Mod,
					[r.wb.Reports]: x.E.Reported,
					[r.wb.Spam]: x.E.Removed,
					[r.wb.Unmoderated]: x.E.Unmoderated
				},
				I = {
					comments: x.C.Comment,
					links: x.C.Post,
					chat_comments: x.C.ChatComment
				};

			function S(e) {
				let {
					getState: t,
					queueType: n,
					options: s
				} = e;
				var o, i;
				const a = t();
				let d;
				s.only && (d = I[s.only]);
				const c = {};
				s.after && (c[s.sort === b.a.OldestFirst ? "before" : "after"] = function(e, t) {
					const n = Object(f.a)(t) ? Object(_.G)(e, {
						postId: t
					}) : Object(h.b)(e, {
						commentId: t
					});
					if (n) return Object(p.btoa)(`${n.id}|${n.created}`)
				}(a, s.after));
				const l = {};
				s.sort === b.a.OldestFirst ? l.last = 25 : l.first = 25;
				const u = Object(v.a)(a),
					m = s.subreddit ? [s.subreddit] : [],
					g = (null == a ? void 0 : a.platform) && (null === (o = null == a ? void 0 : a.platform) || void 0 === o ? void 0 : o.currentPage),
					O = (null === (i = null == g ? void 0 : g.meta) || void 0 === i ? void 0 : i.name) === r.Sb.MODQUEUE_PAGES;
				return {
					queueType: k[n],
					moderatedAfter: s.moderatedAfter,
					...l,
					...!!d && {
						itemTypes: d
					},
					subredditNames: m,
					...!!s.profile && {
						subredditIds: [s.profile]
					},
					sort: s.sort === b.a.MostReportedFirst ? x.D.SortReports : x.D.SortDate,
					...c,
					includeAllModActivitySummaries: u && O,
					includeModActivitySummariesByNames: u && !O,
					isModqueueListing: 0 === m.length
				}
			}
			var w;
			! function(e) {
				e.Comment = "ModQueueItemComment", e.Post = "ModQueueItemPost", e.ChatComment = "ModQueueItemChatComment"
			}(w || (w = {}));
			const T = e => ({
					access: (null == e ? void 0 : e.isAccessEnabled) || !1,
					all: (null == e ? void 0 : e.isAllAllowed) || !1,
					chatConfig: (null == e ? void 0 : e.isChatConfigEditingAllowed) || !1,
					chatOperator: (null == e ? void 0 : e.isChatOperator) || !1,
					config: (null == e ? void 0 : e.isConfigEditingAllowed) || !1,
					flair: (null == e ? void 0 : e.isFlairEditingAllowed) || !1,
					mail: (null == e ? void 0 : e.isMailEditingAllowed) || !1,
					posts: (null == e ? void 0 : e.isPostEditingAllowed) || !1,
					wiki: (null == e ? void 0 : e.isWikiEditingAllowed) || !1
				}),
				N = e => {
					let {
						id: t,
						icon: n,
						profile: s,
						snoovatarIcon: r,
						isAcceptingFollowers: o,
						displayName: i,
						prefixedName: a,
						name: d
					} = e;
					return {
						accountIcon: null == n ? void 0 : n.url,
						displayName: i,
						displayNamePrefixed: a,
						displayText: d,
						enableFollowers: o,
						id: t,
						profileId: null == s ? void 0 : s.id,
						snoovatarFullBodyAsset: (null == r ? void 0 : r.url) || null,
						username: d
					}
				};

			function P(e) {
				let {
					modQueueItems: t,
					identity: n,
					moderatedSubredditActivityByNames: s
				} = e;
				var r, o, i, a, d;
				const c = {
					posts: {},
					comments: {},
					reports: {},
					modActivitySummaries: {},
					modqueue: [],
					authorFlair: {},
					moderatedAfter: (null === (r = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === r ? void 0 : r.pageInfo.hasNextPage) ? null === (o = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === o ? void 0 : o.pageInfo.endCursor : null,
					moderatingProfiles: {},
					profiles: {},
					listingOrder: [],
					subreddits: {},
					moderatingSubreddits: {},
					postFlair: {},
					userFlair: {},
					users: {}
				};
				if (!t) return c;
				if (!t.edges) return c;
				const l = null === (i = null == n ? void 0 : n.redditor.moderatedSubredditActivity) || void 0 === i ? void 0 : i.edges.reduce((e, t) => {
						var n;
						if (!(null === (n = null == t ? void 0 : t.node) || void 0 === n ? void 0 : n.moderation)) return e;
						const {
							subreddit: s,
							summary: r
						} = Object(y.a)(t.node);
						return e.summaries[t.node.id] = r, e.subreddits[t.node.id] = s, e
					}, {
						subreddits: {},
						summaries: {}
					}),
					u = null == s ? void 0 : s.reduce((e, t) => {
						if (!(t && "modPermissions" in t && (null == t ? void 0 : t.modPermissions))) return e;
						if (e.moderatingSubreddits[t.id] = T(t.modPermissions), !(null == t ? void 0 : t.moderation)) return e;
						const {
							subreddit: n,
							summary: s
						} = Object(y.a)(t);
						return e.summaries[t.id] = s, e.subreddits[t.id] = n, e
					}, {
						subreddits: {},
						summaries: {},
						moderatingSubreddits: {}
					});
				c.modActivitySummaries = {
					...null == l ? void 0 : l.summaries,
					...null == u ? void 0 : u.summaries
				};
				const m = null === (d = null === (a = null == n ? void 0 : n.redditor.moderatedSubreddits) || void 0 === a ? void 0 : a.edges) || void 0 === d ? void 0 : d.reduce((e, t) => {
					var n;
					if (!(null === (n = null == t ? void 0 : t.node) || void 0 === n ? void 0 : n.modPermissions)) return e;
					const s = t.node.modPermissions;
					return e.moderatingSubreddits[t.node.id] = T(s), e.subreddits[t.node.id] = Object(j.a)(t.node), e
				}, {
					subreddits: {},
					moderatingSubreddits: {}
				});
				return c.moderatingSubreddits = {
					...null == m ? void 0 : m.moderatingSubreddits,
					...null == u ? void 0 : u.moderatingSubreddits
				}, c.subreddits = {
					...null == l ? void 0 : l.subreddits,
					...null == m ? void 0 : m.subreddits
				}, t.edges.forEach(e => {
					var t, n, s, r, o, i, a;
					if (!e) return;
					const {
						node: d
					} = e;
					if (!d) return;
					const {
						__typename: l,
						subredditInfo: u
					} = d;
					if (!u) return;
					const {
						id: m
					} = u;
					if (c.subreddits[m] = Object(j.a)(u), c.moderatingSubreddits[m] || "Subreddit" !== (null == u ? void 0 : u.__typename) || (c.moderatingSubreddits[m] = T(u.modPermissions)), !c.postFlair[m] && "Subreddit" === u.__typename) {
						const {
							position: e,
							isEnabled: n
						} = (null == u ? void 0 : u.postFlairSettings) || {};
						c.postFlair[m] = {
							displaySettings: {
								position: null == e ? void 0 : e.toLowerCase(),
								isEnabled: n
							},
							...(null === (t = null == u ? void 0 : u.postFlairTemplates) || void 0 === t ? void 0 : t.reduce((e, t) => {
								let {
									id: n,
									text: s,
									isEditable: r,
									richtext: o,
									type: i,
									textColor: a,
									backgroundColor: d,
									isModOnly: c,
									cssClass: l,
									maxEmojis: u,
									allowableContent: m
								} = t;
								return n ? (e.templateIds.push(n), e.templates[n] = {
									id: n,
									text: s || "",
									textEditable: r,
									type: i || g.f.Text,
									textColor: (null == a ? void 0 : a.toLowerCase()) || void 0,
									backgroundColor: (null == d ? void 0 : d.toLowerCase()) || void 0,
									richtext: JSON.parse(o || "[]"),
									modOnly: c,
									cssClass: l,
									maxEmojis: u,
									allowableContent: null == m ? void 0 : m.toLowerCase()
								}, e) : e
							}, {
								templates: {},
								templateIds: []
							})) || {}
						}
					}
					if (l === w.Comment || l === w.ChatComment) {
						const {
							commentInfo: e
						} = d;
						if (!e) return;
						const t = Object(O.a)(e);
						if (null === (n = e.moderationInfo) || void 0 === n ? void 0 : n.verdictBy) {
							const t = N(null === (s = e.moderationInfo) || void 0 === s ? void 0 : s.verdictBy);
							t.username && (c.users[null == t ? void 0 : t.username] = t)
						}
						c.comments[t.id] = t, c.listingOrder.push({
							id: t.id,
							type: "comment"
						}), c.modqueue.push(t.id);
						const {
							authorInfo: o,
							authorFlair: i
						} = e, a = i ? null === (r = Object(E.a)(i)) || void 0 === r ? void 0 : r[0] : null;
						c.authorFlair[m] = {
							...c.authorFlair[m],
							...(null == o ? void 0 : o.name) ? {
								[null == o ? void 0 : o.name]: a
							} : {}
						};
						const l = [];
						t.modReports.forEach(e => {
							l.push({
								type: "moderator",
								reason: e[0],
								reporter: e[1]
							})
						}), t.userReports.forEach(e => {
							l.push({
								type: "user",
								reason: e[0]
							})
						}), c.reports[t.id] = l
					}
					if (l === w.Post) {
						const {
							postInfo: e
						} = d;
						if (null === (o = null == e ? void 0 : e.moderationInfo) || void 0 === o ? void 0 : o.verdictBy) {
							const t = N(null === (i = e.moderationInfo) || void 0 === i ? void 0 : i.verdictBy);
							t.username && (c.users[null == t ? void 0 : t.username] = t)
						}
						if (!e) return;
						const t = Object(C.f)(e);
						c.posts[t.id] = t, c.listingOrder.push({
							id: t.id,
							type: "post"
						}), c.modqueue.push(t.id);
						const {
							authorInfo: n,
							authorFlair: s
						} = e, r = s ? null === (a = Object(E.a)(s)) || void 0 === a ? void 0 : a[0] : null;
						c.authorFlair[m] = {
							...c.authorFlair[m],
							...(null == n ? void 0 : n.name) ? {
								[null == n ? void 0 : n.name]: r
							} : {}
						};
						const l = [];
						t.modReports.forEach(e => {
							l.push({
								type: "moderator",
								reason: e[0],
								reporter: e[1]
							})
						}), t.userReports.forEach(e => {
							l.push({
								type: "user",
								reason: e[0]
							})
						}), c.reports[t.id] = l
					}
				}), c
			}
			var R = n("./src/reddit/models/ModQueue/index.ts"),
				A = n("./src/reddit/models/Toast/index.ts"),
				M = n("./src/reddit/selectors/modQueue.ts"),
				L = n("./src/reddit/selectors/subreddit.ts"),
				D = n("./src/reddit/selectors/telemetry.ts"),
				F = n("./src/telemetry/index.ts"),
				U = n("./src/lib/initializeClient/installReducer.ts"),
				B = n("./src/reddit/reducers/features/modActivitySummaries/index.ts"),
				q = n("./src/reddit/reducers/features/realtimeModqueue/index.ts"),
				G = n("./src/reddit/reducers/pages/modHub/index.ts"),
				H = n("./src/reddit/actions/modQueue/constants.ts");
			Object(U.a)({
				pages: {
					modHub: G.a
				}
			}), Object(U.a)({
				features: {
					modActivitySummaries: B.a
				}
			}), Object(U.a)({
				features: {
					realtimeModqueue: q.a
				}
			});
			const W = Object(o.a)(H.k),
				V = Object(o.a)(H.j),
				z = Object(o.a)(H.i),
				K = Object(o.a)(H.h),
				Q = Object(o.a)(H.g),
				Y = Object(o.a)(H.f),
				J = Object(o.a)(H.e),
				X = Object(o.a)(H.s),
				Z = Object(o.a)(H.r),
				$ = Object(o.a)(H.q),
				ee = Object(o.a)(H.v),
				te = Object(o.a)(H.u),
				ne = Object(o.a)(H.t),
				se = Object(o.a)(H.B),
				re = Object(o.a)(H.A),
				oe = Object(o.a)(H.z),
				ie = (e, t, n) => async (o, i, a) => {
					let {
						apiContext: u,
						gqlContext: m
					} = a;
					var p;
					let b, f, h;
					switch (t) {
						case r.wb.Edited:
							b = Q, f = J, h = Y;
							break;
						case r.wb.Modqueue:
							b = V, f = K, h = z;
							break;
						case r.wb.Reports:
							b = X, f = $, h = Z;
							break;
						case r.wb.Spam:
							b = ee, f = ne, h = te;
							break;
						case r.wb.Unmoderated:
							b = se, f = oe, h = re;
							break;
						default:
							throw new Error("Invalid modqueue requested")
					}
					if (o(b()), n.profile) {
						const e = null === (p = (await Object(l.b)(u(), n.profile)).body[n.profile]) || void 0 === p ? void 0 : p.profileId;
						n.profile = e
					}
					const _ = S({
							getState: i,
							queueType: t,
							options: n
						}),
						g = await Object(c.b)(m(), _);
					if (!g.ok) return o(f(g.error)), void o(Object(d.f)({
						kind: A.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}));
					const {
						users: v,
						...x
					} = P(g.body.data);
					Object(M.b)(i()) && o(W(v)), o(h({
						listingKey: e,
						page: `${n.page||R.b}`,
						response: x
					}))
				}, ae = Object(o.a)(H.n), de = Object(o.a)(H.b), ce = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const i = n(),
						a = i.pages.modHub.modQueue.moderatedCommunitiesOrder.after,
						l = i.pages.modHub.modQueue.moderatedCommunitiesOrder.pending,
						u = i.pages.modHub.modQueue.moderatedCommunitiesOrder.loaded,
						{
							pageName: m
						} = i.platform.currentPage.urlParams;
					if (e && l || u || !a) return;
					const p = S({
							getState: n,
							queueType: m,
							options: {
								moderatedAfter: a
							}
						}),
						b = await Object(c.b)(o(), p);
					if (!b.ok) return void t(Object(d.f)({
						kind: A.b.Error,
						text: s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						})
					}));
					const f = P(b.body.data);
					t(ae(f)), f.moderatedAfter ? t(ce()) : t(de())
				}, le = Object(o.a)(H.y), ue = Object(o.a)(H.x), me = Object(o.a)(H.w), pe = (e, t, n) => async (r, o, l) => {
					let {
						apiContext: p
					} = l;
					r(Object(i.c)());
					const b = o(),
						h = Object(M.i)(b),
						_ = b.user.account && b.user.account.displayText;
					Object(u.d)(u.a.ModQueue);
					const g = Object(u.c)(u.a.ModQueue);
					Object(F.a)({
						source: "bulk_mod_action_menu",
						action: "click",
						noun: e,
						...D.o(b),
						actionInfo: D.d(b, {
							count: h.length,
							paneName: b.platform.currentPage ? b.platform.currentPage.urlParams.pageName : void 0
						}),
						screen: D.cb(b),
						correlationId: g
					});
					for (let t = 0; t < h.length; t++) {
						const n = h[t];
						let s = e;
						[R.a.Approve, R.a.Remove, R.a.Spam].includes(e) && (Object(f.a)(n) ? s += "_link" : s += "_comment"), Object(F.a)({
							source: "bulk_mod_action",
							action: "click",
							noun: s,
							...D.o(b),
							actionInfo: D.d(b, {
								count: h.length,
								paneName: b.platform.currentPage ? b.platform.currentPage.urlParams.pageName : void 0
							}),
							comment: D.h({
								state: b,
								commentId: n
							}),
							post: D.K(b, n),
							profile: D.V(b, n),
							screen: D.cb(b),
							subreddit: D.nb(b, n),
							correlationId: g
						})
					}
					Object(u.b)(u.a.ModQueue);
					const v = {
						ids: h
					};
					t && (v.text = Object(m.g)(t) || "", v.flairTemplateId = ""), n && (v.cssClass = n, v.flairTemplateId = n);
					const x = await Object(c.a)(p(), e, v);
					if (x.ok) {
						r(Object(i.b)({
							...x.body,
							operation: e,
							ids: h,
							username: _,
							options: {
								flair: t
							}
						}));
						const n = function(e, t) {
							switch (e) {
								case R.a.Approve:
									return s.fbt._({
										"*": "{number} posts/comments have been approved",
										_1: "1 post/comment has been approved"
									}, [s.fbt._plural(t, "number")], {
										hk: "2kKhSf"
									});
								case R.a.Flair:
									return s.fbt._({
										"*": "{number} posts/comments have had flair applied",
										_1: "1 post/comment has had flair applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "3syB5O"
									});
								case R.a.IgnoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports ignored",
										_1: "1 post/comment has had their reports ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "2WfE4g"
									});
								case R.a.Lock:
									return s.fbt._({
										"*": "{number} posts/comments have been locked",
										_1: "1 post/comment has been locked"
									}, [s.fbt._plural(t, "number")], {
										hk: "45oMbv"
									});
								case R.a.MarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been marked NSFW",
										_1: "1 post/comment has been marked NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "oPsQr"
									});
								case R.a.RemovalReason:
									return s.fbt._({
										"*": "{number} posts/comments have had removal reasons applied",
										_1: "1 post/comment has had removal reasons applied"
									}, [s.fbt._plural(t, "number")], {
										hk: "35Tosn"
									});
								case R.a.Remove:
									return s.fbt._({
										"*": "{number} posts/comments have been removed",
										_1: "1 post/comment has been removed"
									}, [s.fbt._plural(t, "number")], {
										hk: "B1ZbE"
									});
								case R.a.Spam:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spam",
										_1: "1 post/comment has been marked as spam"
									}, [s.fbt._plural(t, "number")], {
										hk: "3OoNfp"
									});
								case R.a.Spoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been marked as spoilers",
										_1: "1 post/comment has been marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "1DFW5M"
									});
								case R.a.UnignoreReports:
									return s.fbt._({
										"*": "{number} posts/comments have had their reports un-ignored",
										_1: "1 post/comment has had their reports un-ignored"
									}, [s.fbt._plural(t, "number")], {
										hk: "303Hpb"
									});
								case R.a.Unlock:
									return s.fbt._({
										"*": "{number} posts/comments have been unlocked",
										_1: "1 post/comment has been unlocked"
									}, [s.fbt._plural(t, "number")], {
										hk: "5gUht"
									});
								case R.a.UnmarkNSFW:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as NSFW",
										_1: "1 post/comment has been un-marked as NSFW"
									}, [s.fbt._plural(t, "number")], {
										hk: "3oSSST"
									});
								case R.a.Unspoiler:
								case R.a.Unspoiler:
									return s.fbt._({
										"*": "{number} posts/comments have been un-marked as spoilers",
										_1: "1 post/comment has been un-marked as spoilers"
									}, [s.fbt._plural(t, "number")], {
										hk: "3lHoNI"
									})
							}
						}(e, h.length);
						if (e !== R.a.Approve && e !== R.a.Flair) {
							let t, o;
							const l = b.platform.currentPage && b.platform.currentPage.queryParams && b.platform.currentPage.queryParams.subreddit,
								u = l && Object(L.I)(b, l);
							e === R.a.Remove && u && h.length > 1 && (t = s.fbt._("Add a removal reason", null, {
								hk: "3gGDCl"
							}), o = Object(a.fetchReasonsAndOpenModal)(u, h));
							const m = Object(d.e)(n, A.b.Undo, s.fbt._("UNDO", null, {
								hk: "49SEAI"
							}), (() => async (e, t, n) => {
								let {
									apiContext: r
								} = n;
								e(le());
								const o = t(),
									a = Object.keys(o.pages.modHub.modQueue.bulkAction.undoLastAction)[0],
									l = o.pages.modHub.modQueue.bulkAction.undoLastAction[a],
									u = o.user.account && o.user.account.displayText;
								e(Object(i.c)());
								const m = await Object(c.a)(r(), a, {
									ids: l
								});
								m.ok ? e(ue({
									...m.body,
									operation: a,
									ids: l,
									username: u
								})) : (e(me(m.error)), e(Object(d.f)({
									kind: A.b.Error,
									text: s.fbt._("Oh no! Something went wrong!", null, {
										hk: "16O2Sk"
									})
								})))
							})(), t, o);
							r(Object(d.f)(m))
						} else {
							const e = Object(d.e)(n, A.b.SuccessMod);
							r(Object(d.f)(e))
						}
					} else {
						r(Object(i.a)(x.error));
						const e = Object(d.e)(s.fbt._("Oh no! Something went wrong!", null, {
							hk: "16O2Sk"
						}), A.b.Error);
						r(Object(d.f)(e))
					}
				}, be = Object(o.a)(H.a), fe = Object(o.a)(H.c), he = Object(o.a)(H.d)
		},
		"./src/reddit/actions/modQueueTriggers/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/actions/comment/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/lib/makeGqlRequest/index.ts"),
				i = n("./src/redditGQL/operations/ModQueueTriggers.json");
			const a = e => {
				let {
					commentIds: t = [],
					postIds: n = []
				} = e;
				return async (e, a, d) => {
					let {
						gqlContext: c
					} = d;
					var l, u;
					if (!t.length && !n.length) return;
					const m = await ((e, t) => Object(o.a)(e, {
						...i,
						variables: t
					}))(c(), {
						commentIds: t,
						postIds: n
					});
					if (m.ok) {
						const t = m.body;
						if (t.data.commentsByIds) {
							const n = Object.fromEntries(null === (l = t.data.commentsByIds) || void 0 === l ? void 0 : l.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(s.j)(n))
						}
						if (t.data.postsInfoByIds) {
							const n = Object.fromEntries(null === (u = t.data.postsInfoByIds) || void 0 === u ? void 0 : u.filter(e => {
								var t;
								return null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
							}).map(e => {
								var t;
								return [null == e ? void 0 : e.id, {
									modQueueTriggers: null === (t = null == e ? void 0 : e.moderationInfo) || void 0 === t ? void 0 : t.modQueueTriggers
								}]
							}));
							e(Object(r.R)(n))
						}
					}
				}
			}
		},
		"./src/reddit/actions/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/profile/index.ts"),
				o = (n("./src/reddit/endpoints/moderator/moderatingSubreddits.ts"), n("./src/reddit/models/User/index.ts")),
				i = n("./src/reddit/selectors/user.ts");
			const a = "MOD_PERMS__REQUEST_LOADED",
				d = (Object(s.a)("MOD_PERMS__REQUEST_PENDING"), Object(s.a)(a), Object(s.a)("MOD_PERMS__REQUEST_FAILED"), () => async (e, t) => {
					const n = Object(i.l)(t());
					if (n) {
						const t = Object(o.e)(n);
						await e(Object(r.b)(t))
					}
				})
		},
		"./src/reddit/actions/moderationLog/allModerators.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				o = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts"),
				a = n("./src/reddit/actions/moderationLog/constants.ts");
			const d = Object(s.a)(a.a),
				c = e => async (t, n, s) => {
					let {
						gqlContext: a
					} = s;
					const c = n(),
						l = Object(i.I)(c, e);
					if (c.pages.modHub.moderationLog.moderators[l]) return;
					const u = await Object(r.d)(a(), e);
					if (u.body) {
						const e = u.body.data.subreddit.moderators;
						if (e) {
							const n = Object(o.a)(e);
							t(d({
								normalizedModerators: n,
								subredditId: l
							}))
						}
					}
				}
		},
		"./src/reddit/actions/moderationLog/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "SUBREDDIT__MODERATION_LOG_LOADED",
				r = "SUBREDDIT__ALL_MODERATORS_LOADED",
				o = "SUBREDDIT__MODERATION_CATEGORY_ACTIONS_LOADED"
		},
		"./src/reddit/actions/notificationSettingsLayout/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "i", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			}));
			const s = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__FAILED",
				r = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__LOADED",
				o = "NOTIFICATION_EMAIL_SETTINGS_LAYOUT__PENDING",
				i = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__FAILED",
				a = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__LOADED",
				d = "NOTIFICATION_PUSH_SETTINGS_LAYOUT__PENDING",
				c = "NOTIFICATION_SETTINGS_LAYOUT_UPDATED",
				l = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_FAILED",
				u = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_LOADED",
				m = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_PENDING",
				p = "NOTIFICATION_SUBSCRIBED_SUBREDDITS_UPDATED"
		},
		"./src/reddit/actions/notificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "c", (function() {
				return C
			})), n.d(t, "b", (function() {
				return k
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/notificationSettingsLayout/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/UserSubredditsNotificationsLevel.json");
			var l = n("./src/reddit/models/NotificationSettingsLayout/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(o.c),
				p = Object(r.a)(o.b),
				b = Object(r.a)(o.a),
				f = Object(r.a)(o.f),
				h = Object(r.a)(o.e),
				_ = Object(r.a)(o.d),
				g = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					e === l.a.Push ? t(f()) : t(m()), await async function(e, t, n) {
						const s = await Object(a.a)(e(), {
							channel: t
						});
						if (s.ok && s.body) {
							const e = function(e) {
								const t = e && e.data,
									n = t && t.notificationSettingsLayoutByChannel,
									s = n && n.sections;
								if (s) return function(e) {
									const t = {},
										n = [];
									let s = {},
										r = [];
									const o = e => {
										const {
											rowIds: o,
											rowsCollection: i
										} = function(e) {
											const t = [],
												n = {};
											if (e.rows)
												for (let s = 0; s < e.rows.length; s++) {
													const r = e.rows[s],
														o = r.messageType;
													t.push(o), n[o] = r
												}
											return {
												rowsCollection: n,
												rowIds: t
											}
										}(e);
										s = {
											...s,
											...i
										}, r = [...r, ...o];
										const a = e.id;
										n.push(a), t[a] = {
											...e,
											rows: o
										}
									};
									for (let i = 0; i < e.length; i++) o(e[i]);
									return {
										sections: {
											byId: t,
											allIds: n
										},
										rows: {
											byId: s,
											allIds: r
										}
									}
								}(s)
							}(s.body);
							t === l.a.Push ? n(h(e)) : n(p(e))
						} else t === l.a.Push ? n(_({
							error: s.error
						})) : n(b({
							error: s.error
						}))
					}(r, e, t)
				};
			const v = Object(r.a)(o.g),
				x = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					(await Object(a.b)(o(), e)).ok ? (O(t, e), function(e) {
						e(Object(i.f)({
							kind: u.b.SuccessCommunity,
							text: s.fbt._("Changes saved", null, {
								hk: "UBoVR"
							})
						}))
					}(t)) : function(e) {
						e(Object(i.f)({
							kind: u.b.Error,
							text: s.fbt._("We had some issues saving your changes. Please try again.", null, {
								hk: "1OvQi6"
							})
						}))
					}(t)
				};

			function O(e, t) {
				e(v({
					isEnabled: t.isEnabled,
					messageType: t.messageType
				}))
			}
			const E = Object(r.a)(o.j),
				y = Object(r.a)(o.i),
				C = Object(r.a)(o.k),
				j = Object(r.a)(o.h),
				k = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, a;
					t(E());
					const l = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(r(), e);
					if (null === (a = null === (o = l.error) || void 0 === o ? void 0 : o.fields) || void 0 === a ? void 0 : a.length) return t(j({
						error: l.error
					})), void t(Object(i.d)());
					if (l.ok && l.body) {
						const e = l.body,
							n = e && e.data,
							s = n && n.identity && n.identity.subscribedSubreddits,
							r = s && s.pageInfo,
							o = (s && s.edges).map(e => e.node);
						t(y({
							nodes: o,
							pageInfo: r
						}))
					}
				}
		},
		"./src/reddit/actions/notifications/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/notifications/index.ts"),
				r = n("./src/lib/notifications/constants.ts"),
				o = n("./src/lib/notifications/featureFlags.ts"),
				i = n("./src/reddit/featureFlags/index.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts");
			const d = e => i.d.pushNotificationsBrowserSupported(e) ? Object(o.a)() : r.c.BrowserUnsupported,
				c = e => {
					switch (e) {
						case r.a.Denied:
							a.rb(!1), Object(s.c)();
							break;
						case r.a.Default:
						case r.a.Granted:
							a.rb(!0), Object(s.c)();
							break;
						case r.a.Closed:
							a.rb(!0)
					}
				}
		},
		"./src/reddit/actions/notificationsInbox/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			const s = "INBOX_NOTIFICATIONS__PENDING",
				r = "INBOX_NOTIFICATIONS__LOADED",
				o = "INBOX_NOTIFICATIONS__FAILED",
				i = "INBOX_NOTIFS_SET_OVERFLOW_MENU_ID",
				a = "INBOX_NOTIFICATIONS__REMOVE_NOTIFICATION",
				d = "INBOX_NOTIFS__MARK_AS_READ",
				c = "INBOX_NOTIFS__SET_EARLIER_DIVIDER_INDEX",
				l = "INBOX_NOTIFS_MARK_ALL_AS_READ"
		},
		"./src/reddit/actions/notificationsInbox/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return R
			})), n.d(t, "e", (function() {
				return A
			})), n.d(t, "b", (function() {
				return B
			})), n.d(t, "i", (function() {
				return q
			})), n.d(t, "f", (function() {
				return G
			})), n.d(t, "c", (function() {
				return H
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "h", (function() {
				return z
			})), n.d(t, "j", (function() {
				return K
			})), n.d(t, "g", (function() {
				return Y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/appBadgeIndicators/index.ts"),
				i = n("./src/reddit/actions/inboxBanner/index.ts"),
				a = (n("./src/reddit/actions/notificationSettingsLayout/index.ts"), n("./src/reddit/actions/notificationsInbox/constants.ts")),
				d = n("./src/reddit/actions/tabBadging.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/redditGQL/operations/BlockAwarder.json");
			var m = (e, t) => Object(l.a)(e, {
					...u,
					variables: t
				}),
				p = n("./src/lib/constants/index.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/redditGQL/operations/NotificationInboxFeed.json"),
				_ = n("./src/redditGQL/operations/NotificationInboxFeedSlimmed.json"),
				g = n("./src/reddit/constants/headers.ts"),
				v = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			var x;
			! function(e) {
				e.Activity = "activity", e.Messages = "messages"
			}(x || (x = {}));
			var O = n("./src/redditGQL/operations/DeleteInboxNotifications.json");
			n("./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts");
			var E = n("./src/redditGQL/operations/UpdateInboxActivitySeenState.json");
			var y = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				C = n("./src/reddit/helpers/trackers/inbox.ts"),
				j = n("./src/reddit/models/Badge/index.ts"),
				k = n("./src/reddit/models/NotificationInbox/index.ts"),
				I = n("./src/reddit/models/Toast/index.ts"),
				S = n("./src/reddit/selectors/appBadges.ts"),
				w = (n("./src/reddit/selectors/notificationPrefs.ts"), n("./src/reddit/selectors/notificationsInbox.tsx"));
			const T = Object(r.a)(a.e),
				N = Object(r.a)(a.b),
				P = Object(r.a)(a.a),
				R = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var o, a;
					const d = n(),
						u = Object(w.a)(d);
					t(T());
					const m = await ((e, t) => Object(l.a)(e, {
						...h,
						variables: t
					}))(r(), e);
					if (null === (a = null === (o = m.error) || void 0 === o ? void 0 : o.fields) || void 0 === a ? void 0 : a.length) return t(P({
						error: m.error
					})), void t(Object(c.d)());
					const p = m && m.body,
						b = M(p);
					if (null === u) {
						const e = Object(w.f)(d);
						t(D(b.notifications, e.length))
					}
					t(N(b)), t(Object(i.b)(b.banners))
				}, A = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					var r, o;
					const i = await (e => Object(l.a)(e, {
						..._
					}))(s());
					if (null === (o = null === (r = i.error) || void 0 === r ? void 0 : r.fields) || void 0 === o ? void 0 : o.length) return;
					const a = i && i.body,
						d = L(a).nodes.filter(e => !e.viewedAt);
					d.length && d.forEach(e => {
						var n;
						Object(C.u)({
							id: e.id,
							isClicked: !1,
							isViewed: Boolean(e.viewedAt),
							type: null === (n = e.context) || void 0 === n ? void 0 : n.messageType
						})(t())
					})
				}, M = e => {
					const t = [],
						n = [],
						s = e && e.data,
						r = s && s.notificationInbox,
						o = r && r.elements,
						i = o && o.pageInfo,
						a = o && o.edges;
					if (a)
						for (const d of a) Object.keys(d.node).length && (d.node.hasOwnProperty("notificationName") ? n.push(d.node) : t.push(d.node));
					return {
						notifications: t,
						banners: n,
						pageInfo: i
					}
				}, L = e => {
					var t, n;
					return {
						nodes: null === (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.notificationInbox) || void 0 === n ? void 0 : n.elements.edges.map(e => e.node)
					}
				}, D = (e, t) => async (n, s) => {
					const r = s(),
						o = Object(w.a)(r),
						i = ((e, t) => {
							let n, s = 0;
							const r = new Date,
								o = r.getDate(),
								i = r.getMonth(),
								a = r.getFullYear();
							for (; s < e.length && !n;) {
								const r = e[s],
									d = new Date(r.sentAt),
									c = d.getDate(),
									l = d.getMonth(),
									u = d.getFullYear();
								if ((c !== o || l !== i || u !== a) && !n) {
									n = ((t || 0) + s).toString()
								} else s++
							}
							return n
						})(e, t);
					i && i !== o && n(F({
						index: i
					}))
				}, F = Object(r.a)(a.g), U = (Object(r.a)(a.h), Object(r.a)(a.f)), B = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const i = [e];
					if ((await ((e, t) => Object(l.a)(e, {
							...O,
							variables: {
								input: t
							}
						}))(o(), {
							notificationIds: i
						})).ok) {
						t(U({
							id: e
						}));
						const r = Object(w.f)(n());
						t(D(r)), t(Object(c.f)(Object(c.e)(s.fbt._("Notification hidden", null, {
							hk: "1jfPqO"
						}), I.b.SuccessCommunityGreen)))
					} else t(Object(c.f)(Object(c.e)(s.fbt._("Failed to hide notification, please try again.", null, {
						hk: "fL7uB"
					}), I.b.Error)))
				}, q = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e) return;
					(await Object(y.b)(i(), e, {
						isSubredditUpdatesInterestingPostEnabled: !0,
						isUpdateFromSubredditEnabled: !0
					})).ok ? (t && t(), n(Object(c.f)(Object(c.e)(s.fbt._("Success! Undone hiding notifications from this community.", null, {
						hk: "1na0NP"
					}), I.b.SuccessCommunityGreen)))) : n(Object(c.f)(Object(c.e)(s.fbt._("Failed to undo hiding notifications, please try again.", null, {
						hk: "4jo7Pf"
					}), I.b.Error)))
				}, G = (e, t) => async (n, r, o) => {
					let {
						gqlContext: i
					} = o;
					if (!e) return;
					(await Object(y.b)(i(), e, {
						isSubredditUpdatesInterestingPostEnabled: !1,
						isUpdateFromSubredditEnabled: !1
					})).ok ? n((() => {
						const n = s.fbt._("Success! You won't see notifications from this community in the future.", null, {
							hk: "2tkhbk"
						});
						return Object(c.f)(Object(c.e)(n, I.b.Undo, s.fbt._("Undo", null, {
							hk: "4zFGDk"
						}), q(e, t)))
					})()) : n(Object(c.f)(Object(c.e)(s.fbt._("Failed to hide notifications, please try again.", null, {
						hk: "KEGcB"
					}), I.b.Error)))
				}, H = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					if (!e) return;
					(await ((e, t) => Object(b.a)(Object(f.a)(e, [g.a]), {
						endpoint: Object(v.a)(`${e.apiUrl}/api/sendreplies`),
						method: p.ob.POST,
						data: {
							id: t
						}
					}))(o(), e)).ok ? t(Object(c.f)(Object(c.e)(s.fbt._("Success! You won't see updates on this in the future", null, {
						hk: "wtDa4"
					}), I.b.SuccessCommunityGreen))) : t(Object(c.f)(Object(c.e)(s.fbt._("Failed to turn off updates on this, please try again", null, {
						hk: "1zhpEy"
					}), I.b.Error)))
				}, W = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					if (!e) return;
					(await m(o(), {
						awardingId: e
					})).ok ? t(Object(c.f)(Object(c.e)(s.fbt._("Success! Awarder has been blocked", null, {
						hk: "2D5PUk"
					}), I.b.SuccessCommunityGreen))) : t(Object(c.f)(Object(c.e)(s.fbt._("Failed to block awarder, please try again", null, {
						hk: "2dxeA8"
					}), I.b.Error)))
				}, V = Object(r.a)(a.d), z = (e, t) => async (n, s, r) => {
					let i, {
						apiContext: a
					} = r;
					if (t === k.a.CommentReply || t === k.a.PostReply || t === k.a.PrivateMessage || t === k.a.UsernameMention) {
						if ((i = await ((e, t) => Object(b.a)(Object(f.a)(e, [g.a]), {
								endpoint: Object(v.a)(`${e.apiUrl}/api/read_message`),
								method: p.ob.POST,
								data: {
									id: t
								}
							}))(a(), e)).ok) {
							let e = Object(S.a)(s());
							if (e > 0) {
								e--;
								const t = Object(o.e)({
									count: e,
									key: j.c.ActivityTab
								});
								n(Object(o.a)(t)), n(Object(d.e)())
							}
						}
					} else i = await ((e, t) => Object(b.a)(Object(f.a)(e, [g.a]), {
						endpoint: Object(v.a)(`${e.apiUrl}/api/read_notification`),
						method: p.ob.POST,
						data: {
							id: t
						}
					}))(a(), e);
					if (i.ok) {
						const t = (new Date).toISOString();
						n(V({
							id: e,
							now: t
						}))
					}
				}, K = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = (new Date).toLocaleDateString(),
						i = await ((e, t) => Object(l.a)(e, {
							...E,
							variables: {
								input: t
							}
						}))(s(), {
							lastSentAt: r
						});
					if (i.ok) {
						const t = i.body,
							n = t && t.data && t.data.updateInboxActivitySeenState && t.data.updateInboxActivitySeenState.badgeIndicators;
						n && (e(Object(o.a)(n)), e(Object(d.d)()))
					}
				}, Q = Object(r.a)(a.c), Y = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const {
						notificationsInbox: {
							markAllAsReadTimestamp: i
						}
					} = t(), a = new Date;
					if (!i || a.getTime() - new Date(i).getTime() > 15e3) {
						if ((await ((e, t) => Object(b.a)(Object(f.a)(e, [g.a]), {
								endpoint: Object(v.a)(`${e.apiUrl}/api/read_all_messages`),
								method: p.ob.POST,
								data: {
									filter_types: null == t ? void 0 : t.join(",")
								}
							}))(r(), [x.Activity, x.Messages])).ok) {
							const t = Object(o.e)({
									count: 0,
									key: j.c.MessageTab
								}),
								n = Object(o.e)({
									count: 0,
									key: j.c.ActivityTab
								});
							e(Object(o.a)({
								...t,
								...n
							})), e(Q({
								now: a.toISOString()
							}))
						} else e(Object(c.f)(Object(c.e)(s.fbt._("Sorry, we had trouble doing that. Please try again.", null, {
							hk: "VW7c3"
						}), I.b.Error)))
					}
				}
		},
		"./src/reddit/actions/nsfwBlocking/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => n.e("NsfwBlockingActions").then(n.bind(null, "./src/reddit/actions/nsfwBlocking/index.ts")).then(e => e.default))
		},
		"./src/reddit/actions/onboarding/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = "RESET_GENDER_UPDATE_STATE",
				r = "SUBREDDIT_INTEREST_TOPICS",
				o = "SKIP_ONBOARDING_MODAL"
		},
		"./src/reddit/actions/onboarding/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "openReonboardingModalIfNeeded", (function() {
				return u
			})), n.d(t, "resetGenderUpdateState", (function() {
				return m
			})), n.d(t, "subredditInterestTopicsLoaded", (function() {
				return p
			})), n.d(t, "skipOnboardingModal", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/login.ts"),
				o = n("./src/reddit/actions/onboarding/constants.ts"),
				i = n("./src/reddit/helpers/counters/onboarding.ts"),
				a = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				d = n("./src/reddit/models/Onboarding/index.ts"),
				c = n("./src/reddit/selectors/experiments/onboarding.ts"),
				l = n("./src/reddit/selectors/onboarding.ts");
			const u = () => async (e, t) => {
				const n = t(),
					s = n.platform.currentPage;
				if (Object(l.e)(n, {
						pageLayer: s
					})) {
					e(Object(r.openD2xOnboardingModal)({
						type: d.d.REONBOARDING,
						selectedInterests: {}
					})), Object(a.d)();
					const t = Object(c.i)(n);
					Object(i.b)(d.f.FirstPopover, t)
				}
			}, m = Object(s.a)(o.a), p = Object(s.a)(o.c), b = Object(s.a)(o.b);
			t.default = () => async (e, t) => {
				const n = t();
				Object(l.d)(n) && e(Object(r.openD2xOnboardingModal)())
			}
		},
		"./src/reddit/actions/pages/modListing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "k", (function() {
				return p
			})), n.d(t, "j", (function() {
				return b
			}));
			const s = "PAGE__MOD_LISTING_PAGE_PENDING",
				r = "PAGE__MOD_LISTING_PAGE_LOADED",
				o = "PAGE__MOD_LISTING_PAGE_FAILED",
				i = "MOD_LISTING_MORE_POSTS_PENDING",
				a = "MOD_LISTING_MORE_POSTS_LOADED",
				d = "MOD_LISTING_MORE_POSTS_FAILED",
				c = "MOD_LISTING_HIDE_SUBREDDIT_SUCCESS",
				l = "MOD_LISTING_HIDE_SUBREDDIT_PENDING",
				u = "MOD_LISTING_HIDE_SUBREDDIT_FAILED",
				m = "MOD_LISTING_UNHIDE_SUBREDDIT_SUCCESS",
				p = "MOD_LISTING_UNHIDE_SUBREDDIT_PENDING",
				b = "MOD_LISTING_UNHIDE_SUBREDDIT_FAILED"
		},
		"./src/reddit/actions/pages/moderationPages/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "moderationPageRequested", (function() {
				return Ee
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/assertNever.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/lib/makeListingKey/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				l = n("./src/reddit/helpers/makeModQueueListingKey/index.ts"),
				u = n("./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts"),
				m = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				p = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				b = n("./src/reddit/helpers/trackers/screenview.ts"),
				f = n("./src/reddit/actions/contentControls/index.ts"),
				h = n("./src/reddit/actions/emoji.ts"),
				_ = n("./src/reddit/actions/eventPosts/index.ts"),
				g = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				v = n("./src/reddit/actions/gold/powerups.ts"),
				x = n("./src/reddit/actions/grantUserFlair/index.ts"),
				O = n("./src/lib/makeActionCreator/index.ts"),
				E = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts"),
				C = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts"),
				j = n("./src/reddit/selectors/subreddit.ts"),
				k = n("./src/reddit/actions/moderationLog/constants.ts");
			const I = Object(O.a)(k.c),
				S = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var i, a;
					const d = await Object(E.b)(o(), e, t);
					if (!d.body) return;
					const c = null === (a = null === (i = d.body.data) || void 0 === i ? void 0 : i.subreddit) || void 0 === a ? void 0 : a.moderation;
					if (!c || !c.actions) return;
					const l = s(),
						u = Object(y.b)(c.actions),
						m = Object(j.I)(l, e),
						{
							hasNextPage: p,
							hasPreviousPage: b,
							endCursor: f,
							startCursor: h
						} = c.actions.pageInfo,
						_ = Object(C.a)(m, f, h),
						g = [];
					u.forEach(e => {
						g.push(e.id)
					}), n(I({
						approximateCount: c.actions.approximateCount,
						hasNextPage: p,
						hasPreviousPage: b,
						endCursor: f,
						key: _,
						startCursor: h,
						normalizedModerationLog: u,
						actionIds: g,
						subredditId: m
					}))
				}, w = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var i, a;
					const d = await Object(E.c)(o(), e, t);
					if (!d.body) return;
					const c = null === (a = null === (i = d.body.data) || void 0 === i ? void 0 : i.subredditInfoByName) || void 0 === a ? void 0 : a.moderation;
					if (!c || !c.actions) return;
					const l = s(),
						u = Object(y.b)(c.actions),
						m = Object(j.I)(l, e),
						{
							hasNextPage: p,
							hasPreviousPage: b,
							endCursor: f,
							startCursor: h
						} = c.actions.pageInfo,
						_ = Object(C.a)(m, f, h),
						g = u.map(e => e.id);
					n(I({
						approximateCount: c.actions.approximateCount,
						hasNextPage: p,
						hasPreviousPage: b,
						endCursor: f,
						key: _,
						startCursor: h,
						normalizedModerationLog: u,
						actionIds: g,
						subredditId: m
					}))
				};
			var T = n("./src/reddit/actions/modQueue/index.ts"),
				N = n("./src/reddit/actions/pages/subreddit.ts"),
				P = n("./src/reddit/actions/pages/subredditWiki/index.ts"),
				R = n("./src/reddit/actions/platform.ts"),
				A = n("./src/reddit/actions/profile/index.ts"),
				M = n("./src/reddit/actions/removalReasons/index.ts"),
				L = n("./src/reddit/actions/streaming/modSettings.ts"),
				D = n("./src/reddit/actions/subreddit.ts"),
				F = n("./src/reddit/actions/subreddit/questions.ts"),
				U = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				B = n("./src/reddit/actions/subredditModeration/index.ts"),
				q = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				G = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				H = n("./src/reddit/actions/subredditModeration/ban.ts"),
				W = n("./src/reddit/actions/subredditModeration/mute.ts"),
				V = n("./src/reddit/actions/subredditSettings.ts"),
				z = n("./src/reddit/actions/tags/index.ts"),
				K = n("./node_modules/fbt/lib/FbtPublic.js"),
				Q = n("./src/reddit/actions/toaster.ts"),
				Y = n("./src/reddit/actions/trafficStats/constants.ts"),
				J = n("./src/lib/makeGqlRequest/index.ts"),
				X = n("./src/redditGQL/operations/FetchSubredditTrafficStats.json");
			var Z = n("./node_modules/lodash/forEach.js"),
				$ = n.n(Z),
				ee = n("./src/reddit/helpers/graphql/helpers.ts"),
				te = n("./src/reddit/models/TrafficStats/index.ts");
			const ne = e => ({
					desktop: new Array(e).fill(0),
					oldReddit: new Array(e).fill(0),
					mWeb: new Array(e).fill(0),
					apps: new Array(e).fill(0),
					total: new Array(e).fill(0)
				}),
				se = (e, t) => {
					return Object(ee.g)(e.startsAt) > Object(ee.g)(t.startsAt) ? 1 : -1
				},
				re = (e, t, n) => {
					const s = {
							pageViews: ne(t),
							uniqueUsers: ne(t)
						},
						r = Object(ee.g)(e[0].startsAt);
					return e.map(e => {
						const o = Object(ee.g)(e.startsAt),
							i = new Date(o),
							a = t === te.c ? i.getMonth() : Math.round((o - r) / n) % t,
							d = te.d[e.client];
						s.pageViews[d][a] += e.pageViews, s.uniqueUsers[d][a] += e.uniqueUsers
					}), s
				};
			var oe = n("./src/reddit/models/Toast/index.ts");
			const ie = Object(O.a)(Y.b),
				ae = Object(O.a)(Y.c),
				de = Object(O.a)(Y.a),
				ce = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const i = Object(j.Y)(n(), {
						subredditId: e
					}).name;
					t(ae({
						subredditId: e
					}));
					const a = await ((e, t) => Object(J.a)(e, {
						...X,
						variables: t
					}))(r(), {
						subredditName: i
					});
					if (a.ok) {
						const n = a.body.data.subreddit.moderation;
						if (n && n.trafficStats) {
							const s = (e => {
								const t = $()(e, (e, t) => e.sort(se)),
									n = t.subscriptionData,
									s = n.map(e => e.subscribers),
									r = n.map(e => e.unsubscribers),
									i = re(t.hourStats, te.b, o.U),
									a = re(t.dayStats, te.a, o.E),
									d = re(t.monthStats, te.c, o.ub);
								return {
									pageViews: {
										byHour: i.pageViews,
										byDay: a.pageViews,
										byMonth: d.pageViews
									},
									uniqueUsers: {
										byHour: i.uniqueUsers,
										byDay: a.uniqueUsers,
										byMonth: d.uniqueUsers
									},
									subscribers: s,
									unsubscribers: r
								}
							})(n.trafficStats);
							t(ie({
								subredditId: e,
								trafficStats: s
							}))
						}
					} else t(de({
						subredditId: e
					})), t(Q.f({
						id: "error-block-trafficStats",
						kind: oe.b.Error,
						text: K.fbt._("Try again later", null, {
							hk: "41Goel"
						})
					}))
				};
			var le = n("./src/reddit/models/ModQueue/index.ts"),
				ue = n("./src/reddit/models/ScheduledPost/index.ts"),
				me = n("./src/reddit/reducers/pages/modHub/index.ts"),
				pe = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				be = n("./src/reddit/selectors/experiments/econ/index.ts"),
				fe = n("./src/reddit/selectors/moderatorPermissions.ts"),
				he = n("./src/reddit/selectors/modQueue.ts"),
				_e = n("./src/reddit/selectors/platform.ts"),
				ge = n("./src/reddit/selectors/postCreations.ts"),
				ve = n("./src/reddit/selectors/profile.ts"),
				xe = n("./src/reddit/selectors/streamingModSettings.ts"),
				Oe = n("./src/reddit/selectors/user.ts");
			Object(i.a)({
				pages: {
					modHub: me.a
				}
			});
			const Ee = e => async (t, n, i) => {
				const {
					params: O
				} = e, {
					pageName: E,
					profileName: y,
					subredditName: C
				} = O;
				if (E === o.mc.Wiki) {
					if (await t(Object(P.handleWikiRedirects)(e))) return
				}
				if (E === o.mc.SubredditContent) return void t(Object(s.c)(ue.s));
				const k = e.queryParams,
					I = k.page || le.b,
					K = n();
				if (C) {
					const e = Object(a.a)(C, o.bb.HOT),
						n = K.listings.postOrder.ids[e],
						s = K.listings.postOrder.api.error[e],
						r = K.listings.postOrder.api.pending[e];
					if (s) return;
					r || n && !s || await t(Object(N.subredditDataRequested)(e, C, {}))
				} else y && await t(Object(A.e)(y));
				if (!Object(Oe.R)(n()) && E !== o.mc.SubredditRules && E !== o.mc.Contributors) return void Object(m.a)(t, n());
				if (Object(b.i)(n(), !0, C, y), !E) return;
				const Q = Object(pe.d)(K);
				let Y, J, X, Z, $, ee, te, ne, se, re;
				switch (E) {
					case o.mc.Awards:
						Y = g.i;
						break;
					case o.mc.Powerups:
						Y = v.e;
						break;
					case o.mc.Muted:
						Y = W.b;
						break;
					case o.mc.Contributors:
						Y = q.b;
						break;
					case o.mc.Banned:
						Y = H.c;
						break;
					case o.mc.Moderators:
						X = !0;
						break;
					case o.mc.Removal:
						Y = M.removalReasonsRequested;
						break;
					case o.mc.ContentControls:
						Y = f.a, ee = !0;
						break;
					case o.mc.CommunitySettings:
						Y = V.h, te = !0;
						break;
					case o.mc.Flair:
						Y = x.b, $ = !0;
						break;
					case o.mc.UserFlair:
					case o.mc.PostFlair:
						Y = void 0;
						break;
					case o.mc.Emojis:
						Y = h.k;
						break;
					case o.mc.Badges:
					case o.mc.Emotes:
					case o.mc.SubredditRules:
						Y = void 0;
						break;
					case o.mc.Traffic:
						Y = ce;
						break;
					case o.mc.Modlog:
						Y = Q ? w : S, Z = !0;
						break;
					case o.mc.Streaming:
						Y = L.g;
						break;
					case o.mc.Modqueue:
					case o.mc.Reports:
					case o.mc.Spam:
					case o.mc.Edited:
					case o.mc.Unmoderated:
						J = E;
						break;
					case o.mc.Wiki:
					case o.mc.WikiContributors:
					case o.mc.WikiBanned:
						await t(Object(P.subredditWikDataRequested)(O, k, !0));
						break;
					case o.mc.ScheduledPostContent:
						ne = !0, Y = d.i;
						break;
					case o.mc.EventPostContent:
						se = !0;
						break;
					case o.mc.Predictions:
						break;
					case o.mc.TalkHosts:
						re = !0;
						break;
					default:
						return Object(r.a)(E)
				}
				const oe = n(),
					ie = !!C && Object(ge.mb)(oe),
					ae = Object(Oe.O)(oe),
					de = C ? Object(j.bb)(oe, {
						subredditName: C.toLowerCase()
					}) : Object(ve.s)(oe, {
						profileName: y.toLowerCase()
					}),
					me = C && Object(j.I)(oe, C),
					Ee = y && Object(ve.o)(oe, y),
					ye = me || Ee;
				me && !Object(xe.b)(K, me) && await t(Object(L.g)(me));
				const Ce = !!me && Object(xe.c)(oe, me),
					je = Object(be.p)(K),
					ke = Object(fe.n)(oe, {
						subredditId: ye
					}),
					Ie = C && Object(j.z)(oe, {
						subredditName: C
					}),
					Se = !(!Ie || !Ie.userIsContributor),
					we = Object(j.db)(oe, {
						subredditId: ye
					});
				if (Object(c.a)({
						canCreateScheduledPosts: ie,
						isContributor: Se,
						isEmployee: ae,
						isStreamingEnabled: Ce,
						isTalkHostsEnabled: je,
						moderatorPermissions: ke,
						pageName: E,
						subredditType: we
					})) {
					if (J && C) {
						const e = Object(l.a)({
								onlyOfType: k.only,
								sort: k.sort,
								subreddit: C
							}),
							s = !!Object(he.f)(K, {
								pageName: J,
								page: `${I}`,
								subredditName: C,
								queryParams: k
							}),
							r = K.pages.modHub.modQueue[J].api.error;
						if (Object(he.e)(K, {
								pageName: J
							}) || s && !r) return;
						if (!Object(_e.q)(K)) {
							const s = Object(T.e)(e, J, {
								...k,
								subreddit: C
							});
							await s(t, n, i)
						}
					} else if (X && me) {
						if (await Object(B.g)(me, k)(t, n, i), K.moderatingSubreddits[me]) {
							await Object(B.e)(me, k)(t, n, i), K.pages.modHub.moderators.invitedModerators.userOrder[me] || await Object(B.f)(me)(t, n, i)
						}
					} else if (re && me) await Object(G.b)({
						subredditId: me
					})(t, n, i);
					else if (ee && C) await Y(C)(t, n, i);
					else if (te && me) await Promise.all([Y(C, me)(t, n, i), Object(z.g)(me, p.a.communitySettings)(t, n, i), Object(F.b)(me)(t, n, i), Object(U.d)(me)(t, n, i)]);
					else if ($) await Y(C, k)(t, n, i);
					else if (Z) {
						const e = {
							...k
						};
						e.endDate && (e.endDate = `${e.endDate} 23:59:59`), await Y(C, Q ? Object(u.b)(C, e) : k)(t, n, i)
					} else ne && me ? await Object(d.i)({
						subredditId: me
					})(t, n, i) : se && C ? await Object(_.eventPostsRequested)(C)(t, n, i) : Y && await Y(ye, k)(t, n, i);
					C && me && !K.subreddits.rules[me] && await D.o(C)(t, n, i), t(R.m({
						title: de
					}))
				}
			}
		},
		"./src/reddit/actions/pages/multireddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__MULTIREDDIT_FEED_PENDING",
				r = "PAGE__MULTIREDDIT_FEED_LOADED",
				o = "PAGE__MULTIREDDIT_FEED_FAILED"
		},
		"./src/reddit/actions/pages/postCreation.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return A
			})), n.d(t, "PAGE_LOADED", (function() {
				return M
			})), n.d(t, "PAGE_FAILED", (function() {
				return L
			})), n.d(t, "pagePending", (function() {
				return D
			})), n.d(t, "pageLoaded", (function() {
				return F
			})), n.d(t, "pageFailed", (function() {
				return U
			})), n.d(t, "postCreationPageDataRequested", (function() {
				return q
			})), n.d(t, "postCreationPageRequested", (function() {
				return G
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/filterQueryParams/index.ts"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/makePostCreationPageKey/index.ts"),
				d = n("./src/lib/pageTitle/index.ts"),
				c = n("./src/reddit/actions/contentControls/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/externalAccount.ts"),
				m = n("./src/reddit/actions/gold/powerups.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/post.ts"),
				f = n("./src/reddit/actions/postCreation/general.ts"),
				h = n("./src/reddit/actions/profile/index.ts"),
				_ = n("./src/reddit/actions/subreddit.ts"),
				g = n("./src/reddit/actions/subredditDuplicates.ts"),
				v = n("./src/config.ts"),
				x = n("./src/lib/constants/index.ts"),
				O = n("./src/lib/makeApiRequest/index.ts"),
				E = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				y = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				C = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				j = n("./src/reddit/models/User/index.ts"),
				k = n("./src/reddit/selectors/contentControls.ts"),
				I = n("./src/reddit/selectors/postCollection.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				w = n("./src/reddit/selectors/posts.ts"),
				T = n("./src/reddit/selectors/profile.ts"),
				N = n("./src/reddit/selectors/subreddit.ts"),
				P = n("./src/reddit/selectors/user.ts");
			const R = e => {
					const t = e.platform.currentPage;
					let n = "Reddit";
					if (t && t.urlParams.subredditName) {
						const {
							subredditName: s
						} = t.urlParams, r = Object(N.C)(e, {
							subredditName: s
						});
						r && (n = r.name)
					}
					return Object(d.q)(n)
				},
				A = "POST_CREATION__PAGE_PENDING",
				M = "POST_CREATION__PAGE_LOADED",
				L = "POST_CREATION__PAGE_FAILED",
				D = Object(i.a)(A),
				F = Object(i.a)(M),
				U = Object(i.a)(L),
				B = () => async (e, t) => {
					const n = t(),
						s = Object(S.a)(n);
					s !== Object(S.pb)(n) && e(Object(f.g)({
						submissionType: s
					}))
				}, q = e => async (t, n, s) => {
					const {
						collectionId: r,
						profileName: i,
						subredditName: d
					} = e, l = Object(a.a)(e), p = n(), b = p.creations.api.page.pending[l], f = p.creations.api.page.fetched[l], g = p.creations.api.page.error[l];
					if (b) return;
					if (f && !g) return void t(B());
					const y = [];
					t(D({
						key: l
					}));
					let I = d;
					!d && i && (I = `u_${i}`), y.push(((e, t) => Object(O.a)(e, {
						method: x.ob.GET,
						endpoint: Object(E.a)(`${v.a.gatewayUrl}/desktopapi/v1/submitpage`),
						data: {
							subreddit: t.subredditName,
							collection_id: t.collectionId
						}
					}))(s.apiContext(), {
						subredditName: I,
						collectionId: r
					})), i && (y.push(t(h.d(i))), y.push(t(h.b(i))));
					const [S] = await Object(C.a)("postCreation", () => Promise.all(y));
					if (S.ok) {
						const e = S.body,
							{
								posts: s = {},
								subredditAboutInfo: r
							} = e;
						if (t(F({
								key: l,
								meta: p.meta,
								...e,
								posts: s
							})), !Object(P.R)(n())) return;
						if (r) {
							const e = Object.keys(r)[0];
							await t(Object(m.e)(e, {
								fullData: !0,
								includeIdentity: !1
							}))
						}
						t(B());
						const i = [];
						i.push(t(u.o()));
						const a = Object(P.l)(n());
						if (a && a.hasUserProfile && i.push(t(h.d(Object(j.e)(a)))), d && !Object(o.a)(d)) {
							i.push(t(_.o(d))), !!Object(k.b)(n(), {
								subredditName: d
							}) || i.push(t(Object(c.a)(d)))
						}
						await Promise.all(i)
					} else t(U({
						error: S.error,
						key: l
					}))
				}, G = e => async (t, n) => {
					const {
						subredditName: o,
						profileName: i
					} = e.params, a = e.queryParams, d = a.collection;
					if (await t(q({
							collectionId: d,
							profileName: i,
							subredditName: o
						})), !Object(P.R)(n())) return void Object(y.a)(t, n());
					let c;
					if (o ? (c = Object(N.C)(n(), {
							subredditName: o
						}), await t(Object(l.a)({
							subredditName: o
						}))) : i && (c = Object(T.k)(n(), {
							profileName: i
						})), a.source_id) await t(((e, t) => async (n, s) => {
						const {
							subredditName: r,
							profileName: o
						} = e, i = [];
						let a;
						r ? a = Object(N.I)(s(), r) : o && (a = Object(P.nb)(s(), {
							userName: o
						})), a && i.push(n(Object(g.b)(a, t))), i.push(n(Object(b.Q)(t))), await Promise.all(i);
						const d = Object(w.f)(s(), {
							postId: t
						});
						n(Object(f.m)({
							postId: t,
							postTitle: d ? d.title : ""
						}))
					})(e.params, a.source_id));
					else if (d) {
						const o = Object(I.q)(n(), {
							collectionId: d
						});
						c && o && o.subredditId === c.id || t(Object(s.c)(Object(r.a)(e.url, ["collection"])))
					}
					t(p.m({
						title: R(n())
					}))
				}
		},
		"./src/reddit/actions/pages/postDraft.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PAGE_PENDING", (function() {
				return p
			})), n.d(t, "PAGE_LOADED", (function() {
				return b
			})), n.d(t, "PAGE_FAILED", (function() {
				return f
			})), n.d(t, "pagePending", (function() {
				return h
			})), n.d(t, "pageLoaded", (function() {
				return _
			})), n.d(t, "pageFailed", (function() {
				return g
			})), n.d(t, "postDraftPageDataRequested", (function() {
				return v
			})), n.d(t, "postDraftRequested", (function() {
				return x
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/makePostDraftPageKey/index.ts"),
				o = n("./src/reddit/actions/profile/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				m = n("./src/reddit/helpers/timeApiRoute/index.ts");
			const p = "POST_DRAFT__PAGE_PENDING",
				b = "POST_DRAFT__PAGE_LOADED",
				f = "POST_DRAFT__PAGE_FAILED",
				h = Object(s.a)(p),
				_ = Object(s.a)(b),
				g = Object(s.a)(f),
				v = e => async (t, n, s) => {
					const {
						draftId: p,
						profileName: b
					} = e, f = Object(r.a)(e), h = n(), v = h.creations.api.page.pending[f], x = h.creations.api.page.fetched[f], O = h.creations.api.page.error[f];
					if (v || x && !O || !p) return;
					t(o.d(b));
					const E = await Object(m.a)("postDraft", () => ((e, t, n) => Object(d.a)(e, {
						endpoint: Object(c.a)(Object(l.a)(`${i.a.gatewayUrl}/desktopapi/v1/draftpreviewpage/${n}/${t}`)),
						method: a.ob.GET
					}))(s.apiContext(), p, b));
					if (E.ok) {
						const e = E.body;
						e.drafts[p].kind = Object(u.b)(e.drafts[p].kind), t(_({
							...e,
							key: f
						}))
					} else t(g({
						error: E.error,
						key: f
					}))
				}, x = e => async (t, n, s) => {
					await t(v(e.params))
				}
		},
		"./src/reddit/actions/pages/profilePosts.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "PROFILE_POSTS_PENDING", (function() {
				return ne
			})), n.d(t, "PROFILE_POSTS_LOADED", (function() {
				return se
			})), n.d(t, "PROFILE_POSTS_FAILED", (function() {
				return re
			})), n.d(t, "profilePostsPending", (function() {
				return oe
			})), n.d(t, "profilePostsLoaded", (function() {
				return ie
			})), n.d(t, "profilePostsFailed", (function() {
				return ae
			})), n.d(t, "profilePostsRequested", (function() {
				return de
			})), n.d(t, "MORE_POSTS_PENDING", (function() {
				return ce
			})), n.d(t, "MORE_POSTS_LOADED", (function() {
				return le
			})), n.d(t, "MORE_POSTS_FAILED", (function() {
				return ue
			})), n.d(t, "morePostsPending", (function() {
				return me
			})), n.d(t, "morePostsLoaded", (function() {
				return pe
			})), n.d(t, "morePostsFailed", (function() {
				return be
			})), n.d(t, "morePostsRequested", (function() {
				return fe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/lib/makeListingKey/index.ts"),
				a = n("./src/lib/safeGet/index.ts"),
				d = n("./src/reddit/actions/contentGate.ts"),
				c = n("./src/reddit/actions/externalAccount.ts"),
				l = n("./src/reddit/actions/moderatingSubreddits.ts"),
				u = n("./src/reddit/actions/pages/profileShared.ts"),
				m = n("./src/reddit/actions/pinnedPost.ts"),
				p = n("./src/reddit/actions/platform.ts"),
				b = n("./src/reddit/actions/profile/index.ts"),
				f = n("./src/reddit/actions/subreddit.ts"),
				h = n("./src/reddit/constants/errors.ts"),
				_ = n("./src/reddit/constants/parameters.ts"),
				g = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/lib/makeGqlRequest/index.ts"),
				x = n("./src/redditGQL/operations/ProfileFeed.json");
			const O = async (e, t) => await Object(v.a)(e, {
				...x,
				variables: t
			}), E = e => {
				let {
					username: t,
					profileSort: n,
					filter: s,
					loadMoreData: r,
					shouldUseGqlCursor: o
				} = e;
				const i = {
					username: t,
					sort: n.toUpperCase(),
					filter: s
				};
				if (r) {
					const {
						token: e
					} = r;
					i.after = o ? e : btoa(e)
				}
				return i
			};
			var y = n("./src/config.ts"),
				C = n("./src/lib/addAllowQuarantinedParam/index.ts"),
				j = n("./src/lib/constants/index.ts"),
				k = n("./src/lib/makeApiRequest/index.ts"),
				I = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				S = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const w = (e, t, n) => Object(k.a)(e, {
				data: n,
				endpoint: Object(I.a)(Object(C.a)(Object(S.a)(`${y.a.gatewayUrl}/desktopapi/v1/user/${t}/posts`))),
				method: j.ob.GET
			}).then(e => "pinned" in e.body ? e : "postIds" in e.body ? {
				...e,
				body: {
					...e.body,
					pinned: e.body.postIds.filter(t => e.body.posts[t] && e.body.posts[t].isPinned).reverse()
				}
			} : e);
			var T = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				N = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				P = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				R = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				M = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				L = n("./src/reddit/models/Post/index.ts");
			const D = (e, t) => {
				if (!Object(L.l)(t) && !Object(L.n)(t)) return null;
				if (e.posts[t.id]) return t.id;
				const n = Object(R.f)(t),
					{
						id: s
					} = n;
				e.posts[s] = n;
				const {
					crosspostRoot: r
				} = t;
				r && r.type === L.a.Post && r.postInfo && D(e, r.postInfo);
				const {
					authorFlair: o
				} = t;
				if (o) {
					const t = n.belongsTo.id;
					e.authorFlair[t] || (e.authorFlair[t] = {}), e.authorFlair[t][n.author] = Object(N.a)(o)[0]
				}
				if (Object(L.l)(t)) {
					const {
						profile: n
					} = t;
					e.profiles[n.id] || (e.profiles[n.id] = Object(A.a)(n))
				} else if (Object(L.n)(t)) {
					const {
						subreddit: n
					} = t;
					e.subreddits[n.id] || (e.subreddits[n.id] = Object(M.a)(n)), e.postFlair[n.id] || (e.postFlair[n.id] = Object(P.a)(n))
				}
				return s
			};
			var F = n("./src/reddit/models/Comment/index.ts"),
				U = (e, t) => {
					var n, s, r;
					const o = {
							authorFlair: {},
							pinned: [],
							postIds: [],
							posts: {},
							postFlair: {},
							profiles: {},
							subreddits: {},
							token: ""
						},
						i = null === (n = null == e ? void 0 : e.redditorInfoByName) || void 0 === n ? void 0 : n.elements;
					if (!i) return o;
					const {
						edges: a
					} = i;
					for (const {
							node: c
						} of a) {
						if (!c || c.__typename === F.d.Comment) continue;
						const e = D(o, c);
						e && o.postIds.push(e)
					}
					const d = null === (r = null === (s = null == e ? void 0 : e.redditorInfoByName) || void 0 === s ? void 0 : s.profile) || void 0 === r ? void 0 : r.stickyPosts;
					if (d && (o.pinned = d.map(e => e.id)), t) o.token = i.pageInfo.endCursor || "";
					else {
						const {
							postIds: e
						} = o, t = e[e.length - 1];
						t && (o.token = t)
					}
					return o
				},
				B = n("./node_modules/@sentry/minimal/esm/index.js"),
				q = n("./node_modules/deep-diff/index.js"),
				G = n("./src/lib/env/index.ts");
			const H = new Set(["authorFlair.cssClass", "posts.adSupplementaryText", "posts.allAwardings", "posts.approvedAtUTC", "posts.approvedBy", "posts.attributionInfo", "posts.audioRoom", "posts.bannedAtUTC", "posts.bannedBy", "posts.collapsedBecauseCrowdControl", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForLinkedPosts", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isReactAllowed", "posts.isRemoved", "posts.isSpam", "posts.lastAuthorModNote", "posts.modQueueTriggers", "posts.modReportsDismissed", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.modReports", "posts.numReports", "posts.reactedFrom", "posts.removedBy", "posts.removedByCategory", "posts.topAwardedType", "posts.userReports", "posts.userReportsDismissed", "posts.modReasonBy", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "authorFlair.richtext", "authorFlair.text", "posts.collectionIds", "posts.liveCommentsWebsocket", "posts.thumbnail.url", "posts.discussionType", "posts.eventsOnRender", "posts.flair", "posts.gildings", "posts.media", "posts.goldCount", "posts.sendReplies", "posts.score", "posts.sendReplies", "posts.source.url", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "profiles.acceptFollowers", "profiles.communityIcon", "profiles.icon.url", "posts.upvoteRatio", "subreddits.acceptFollowers", "subreddits.allowChatPostCreation", "subreddits.communityIcon", "subreddits.icon.url", "subreddits.isChatPostFeatureEnabled", "subreddits.primaryColor", "subreddits.subscribers"]),
				W = (e, t) => {
					const n = {},
						s = {};
					Object.keys(e).forEach(r => {
						const o = e[r] || {},
							i = t[r] || {};
						n[r] = {}, s[r] = 0, Object.keys(o).forEach(e => {
							const t = o[e],
								a = i[e],
								d = Object(q.diff)(t, a, {
									prefilter: (e, t) => H.has(`${r}.${e.length?`${e.join(".")}.`:""}${t}`) || H.has(`${r}.${t}`),
									normalize: (e, t, n, s) => n || s ? [n, s] : [n, n]
								});
							s[r] = d ? s[r] + d.length : (null == s ? void 0 : s[r]) || 0, d && (n[r][e] = {
								gatewayThing: t,
								gqlThing: a,
								diffResult: d
							})
						})
					});
					const r = Object.keys(s).reduce((e, t) => e += s[t], 0);
					return {
						allDiffs: n,
						issueCounts: s,
						totalIssues: r
					}
				};

			function V(e) {
				let {
					gatewayResponse: t,
					normalizedGqlResponse: n,
					rawGqlResponse: s
				} = e;
				if (Object(G.a)()) {
					console.group("GQL Profiles Shadowtest"), console.groupCollapsed("raw gql response"), console.log(s), console.groupEnd(), console.groupCollapsed("normalized gql response"), console.log(n), console.groupEnd(), console.groupCollapsed("gateway response"), console.log(t), console.groupEnd();
					const {
						allDiffs: e,
						issueCounts: r,
						totalIssues: o
					} = W(t, n);
					console.groupCollapsed(`diff: ${o} issues`), console.log("lhs = gateway\nrhs = gql");
					for (const t in e) {
						if (console.groupCollapsed(`${t}: ${r[t]} issues`), r[t] > 0)
							for (const n in e[t]) {
								const s = e[t][n].diffResult;
								console.groupCollapsed(`${n}: ${s.length||0} issues`), console.log(s), console.log({
									gql: e[t][n].gqlThing,
									gateway: e[t][n].gatewayThing
								}), console.groupEnd()
							}
						console.groupEnd()
					}
					console.groupEnd()
				}
				if (Object(G.b)()) {
					const {
						allDiffs: e,
						issueCounts: s,
						totalIssues: r
					} = W(t, n);
					if (r <= 0) return;
					B.l(t => {
						t.setExtra("info", {
							allDiffs: e,
							issueCounts: s,
							totalIssues: r
						}), t.setExtra("bypassSampling", !0), B.d("GQL Profiles Shadowtest Diff")
					})
				}
			}
			var z = n("./src/reddit/helpers/post/index.ts"),
				K = n("./src/reddit/helpers/timeApiRoute/index.ts"),
				Q = n("./src/reddit/models/User/index.ts"),
				Y = n("./src/reddit/constants/experiments.ts"),
				J = n("./src/reddit/helpers/chooseVariant/index.ts");
			const X = e => {
					return Object(J.c)(e, {
						experimentEligibilitySelector: J.a,
						experimentName: Y.uc
					}) === Y.Kd
				},
				Z = e => {
					return Object(J.c)(e, {
						experimentEligibilitySelector: J.a,
						experimentName: Y.vc
					}) === Y.Kd
				};
			var $ = n("./src/reddit/selectors/listings.ts"),
				ee = n("./src/reddit/selectors/profile.ts"),
				te = n("./src/redditGQL/types.ts");
			const ne = "PAGE__PROFILE_POSTS_PENDING",
				se = "PAGE__PROFILE_POSTS_LOADED",
				re = "PAGE__PROFILE_POSTS_FAILED",
				oe = Object(o.a)(ne),
				ie = Object(o.a)(se),
				ae = Object(o.a)(re),
				de = e => async (t, n, s) => {
					var o, v, x;
					const {
						queryParams: y,
						params: C
					} = e, {
						sort: j,
						t: k
					} = Object(u.b)(y), {
						profileName: I
					} = C, S = Object(i.a)(`u_${I}`, j, y), N = n(), P = Object(a.a)(N.listings.postOrder.ids, S), R = Object($.c)(N, {
						listingKey: S
					}), A = Object($.d)(N, {
						listingKey: S
					});
					if (await t(b.d(I)), A || P && !R) {
						if (P) {
							const e = Object(ee.s)(n(), {
								profileName: I
							});
							t(p.m({
								title: e
							}))
						}
						return
					}
					t(oe({
						key: S
					}));
					const M = Z(N);
					let L, D, F;
					if (M) {
						const e = E({
							username: I,
							profileSort: j,
							filter: te.M.Posts,
							shouldUseGqlCursor: !0
						});
						D = null === (x = null === (v = null === (o = null == (L = await Object(K.a)("profilePosts", () => O(s.gqlContext(), e))) ? void 0 : L.body) || void 0 === o ? void 0 : o.data) || void 0 === v ? void 0 : v.redditorInfoByName) || void 0 === x ? void 0 : x.__typename
					} else {
						const t = {
							...r()(e.queryParams, [..._.q, ..._.p, _.l]),
							layout: Object(g.U)(N, {}).toLowerCase(),
							sort: j,
							t: Object(T.a)(j, k)
						};
						L = await Object(K.a)("profilePosts", () => w(s.apiContext(), I, t))
					}
					if (!L.ok || M && D !== Q.c.AvailableRedditor) return t(ae({
						account: !M && L.body.data ? L.body.data.account : null,
						error: L.body.reason ? {
							type: L.body.reason
						} : L.error,
						key: S
					})), L.body.reason === h.a.DeletedProfile || D === Q.c.DeletedRedditor ? t(Object(d.u)({
						profileName: I
					})) : D === Q.c.UnavailableRedditor ? t(Object(d.A)({
						profileName: I
					})) : M && !D && t(Object(d.o)({
						profileName: I
					})), void t(p.n(L.status));
					if (M) {
						const {
							data: e
						} = L.body;
						F = U(e, !0)
					} else F = L.body, await Object(z.a)(s.gqlContext, F.posts).then(e => F.posts = e);
					if (!M && X(N)) {
						const e = E({
								username: I,
								profileSort: j,
								filter: te.M.Posts
							}),
							t = await O(s.gqlContext(), e);
						if (t.ok && t.body) {
							const {
								data: e
							} = t.body, n = U(e);
							V({
								gatewayResponse: {
									authorFlair: F.authorFlair,
									pinned: F.pinned,
									postIds: F.postIds,
									posts: F.posts,
									postFlair: F.postFlair,
									profiles: F.profiles,
									subreddits: F.subreddits,
									token: F.token
								},
								normalizedGqlResponse: n,
								rawGqlResponse: e
							})
						}
					}
					t(ie({
						key: S,
						meta: n().meta,
						...F
					}));
					const B = Object(ee.o)(n(), I),
						{
							pinned: q
						} = F;
					t(Object(m.h)({
						profileId: B,
						pinned: q
					})), await Promise.all([t(Object(u.c)(I)), t(Object(f.q)()), t(Object(l.b)()), t(c.o(I))])
				}, ce = "PROFILE_POSTS__MORE_POSTS_PENDING", le = "PROFILE_POSTS__MORE_POSTS_LOADED", ue = "PROFILE_POSTS__MORE_POSTS_FAILED", me = Object(o.a)(ce), pe = Object(o.a)(le), be = Object(o.a)(ue), fe = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: o
					} = n;
					const a = t(),
						{
							currentPage: d
						} = a.platform;
					if (!d || !d.routeMatch) return;
					const {
						queryParams: c,
						params: l
					} = d.routeMatch.match, {
						sort: m,
						t: p
					} = Object(u.b)(c), {
						profileName: b
					} = l, f = Object(i.a)(`u_${b}`, m, c), h = Object($.g)(a, {
						listingKey: f
					});
					if (!h) return;
					const v = Object($.d)(a, {
							listingKey: f
						}),
						x = Object($.e)(a, {
							listingKey: f,
							token: h.token
						});
					if (v || x) return;
					e(me({
						key: f,
						fetchedToken: h.token
					}));
					const y = Z(a);
					let C, j;
					if (y) {
						const e = E({
							username: b,
							profileSort: m,
							filter: te.M.Posts,
							loadMoreData: h,
							shouldUseGqlCursor: !0
						});
						C = await O(o(), e)
					} else {
						const e = {
							after: h.token,
							dist: h.dist,
							sort: m,
							t: p,
							...r()(c, _.q),
							layout: Object(g.U)(a, {}).toLowerCase()
						};
						C = await w(s(), b, e)
					}
					if (!C.ok) return void e(be({
						account: !y && C.body.data ? C.body.data.account : null,
						error: C.error,
						fetchedToken: h.token,
						key: f
					}));
					if (y) {
						const {
							data: e
						} = C.body;
						j = U(e, !0)
					} else j = C.body, await Object(z.a)(o, j.posts).then(e => j.posts = e);
					const k = a.listings.postOrder.ids[f],
						I = j.postIds || [],
						S = {
							...j,
							postIds: I.filter(e => !k || !k.includes(e))
						};
					if (X(a)) {
						const e = E({
								username: b,
								profileSort: m,
								filter: te.M.Posts,
								loadMoreData: h
							}),
							t = await O(o(), e);
						if (t.ok && t.body) {
							const {
								data: e
							} = t.body, n = U(e);
							V({
								gatewayResponse: {
									authorFlair: S.authorFlair,
									pinned: S.pinned,
									postIds: S.postIds,
									posts: S.posts,
									postFlair: S.postFlair,
									profiles: S.profiles,
									subreddits: S.subreddits,
									token: S.token
								},
								normalizedGqlResponse: n,
								rawGqlResponse: e
							})
						}
					}
					e(pe({
						fetchedToken: h.token,
						key: f,
						meta: a.meta,
						...S
					})), await e(Object(u.c)(b))
				}
		},
		"./src/reddit/actions/pages/shared.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				r = n("./src/reddit/helpers/routeKey/index.ts"),
				o = n("./src/reddit/helpers/trackers/screenview.ts"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/telemetry/models/Timer.ts");
			const d = () => async (e, t) => {
				const n = t(),
					{
						currentPage: d
					} = n.platform;
				if (!d) return;
				const c = d.routeMatch,
					l = Object(s.a)(n),
					u = Object(r.b)(c, n, l);
				u && i.c.has(u) && Object(o.k)(c, n, a.TimerType.InApp, i.c.end(u))
			}
		},
		"./src/reddit/actions/pages/subreddit.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "isGQLSubredditPageExtra", (function() {
				return _t
			})), n.d(t, "handleSubredditPageApiError", (function() {
				return gt
			})), n.d(t, "SUBREDDIT_PENDING", (function() {
				return vt
			})), n.d(t, "SUBREDDIT_LOADED", (function() {
				return xt
			})), n.d(t, "SUBREDDIT_FAILED", (function() {
				return Ot
			})), n.d(t, "subredditPending", (function() {
				return Et
			})), n.d(t, "subredditLoaded", (function() {
				return yt
			})), n.d(t, "subredditFailed", (function() {
				return Ct
			})), n.d(t, "addAdditionalInformationForAGatewayResponse", (function() {
				return jt
			})), n.d(t, "subredditDataRequested", (function() {
				return kt
			})), n.d(t, "subredditDataFirstChunkRequested", (function() {
				return It
			})), n.d(t, "makeSubredditPageKey", (function() {
				return wt
			})), n.d(t, "subredditRequested", (function() {
				return Tt
			})), n.d(t, "SUBREDDIT_INVALIDATE_LISTING", (function() {
				return Nt
			})), n.d(t, "subredditInvalidateListing", (function() {
				return Pt
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./node_modules/lodash/find.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/pick.js"),
				d = n.n(a),
				c = n("./node_modules/react-router-redux/es/index.js"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/countrySites/index.ts"),
				m = n("./src/lib/isAdHocMultireddit/index.ts"),
				p = n("./src/lib/isFakeSubreddit/index.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/lib/makeListingKey/index.ts"),
				h = n("./src/lib/makeSearchKey/index.ts"),
				_ = n("./src/lib/pageTitle/index.ts"),
				g = n("./src/lib/pageTitle/helpers.ts"),
				v = n("./src/lib/performanceTimings/index.tsx"),
				x = n("./src/lib/safeGet/index.ts"),
				O = n("./src/reddit/actions/ads/index.ts"),
				E = n("./src/reddit/actions/communityFlairs/index.ts"),
				y = n("./src/reddit/actions/contentGate.ts"),
				C = n("./src/reddit/actions/discoveryUnit.ts"),
				j = n("./src/reddit/actions/economics/helpers/async.ts"),
				k = n("./src/reddit/actions/economics/predictions/index.ts"),
				I = n("./src/reddit/actions/externalAccount.ts"),
				S = n("./src/reddit/actions/gold/achievementFlairs.ts"),
				w = n("./src/reddit/actions/gold/customEmojis.ts"),
				T = n("./src/reddit/actions/gold/powerups.ts"),
				N = n("./src/reddit/actions/meta.ts"),
				P = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				R = n("./src/reddit/actions/nsfwBlocking/async.tsx"),
				A = n("./src/reddit/actions/onboarding/index.ts"),
				M = n("./src/reddit/actions/pages/search/index.ts"),
				L = n("./src/reddit/actions/platform.ts"),
				D = n("./src/reddit/actions/publicAccessNetwork/api.ts"),
				F = n("./src/reddit/actions/seo/linksModule.ts"),
				U = n("./src/reddit/actions/seo/topicLinks.ts"),
				B = n("./src/lib/makeGqlRequest/index.ts"),
				q = (n("./src/redditGQL/operations/SubredditInfo.json"), n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts")),
				G = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				H = (n("./src/reddit/selectors/seo/linksModule.ts"), n("./src/reddit/selectors/seo/topicLinks.ts"), n("./src/reddit/selectors/subreddit.ts")),
				W = n("./src/reddit/selectors/widgets.ts");
			const V = (e, t) => async (n, s) => {
				const r = s(),
					o = Object(H.Y)(r, {
						subredditId: e
					}),
					i = Object(W.j)(r, {
						subredditId: e
					});
				o.isNSFW || (null == i ? void 0 : i.length) > 0 && i.some(e => "community-list" === e) || n(Object(F.e)({
					id: e,
					data: t
				}))
			}, z = (e, t) => async n => {
				t && n(Object(U.b)({
					id: e,
					data: t
				}))
			};
			var K = n("./src/reddit/actions/structuredStyles/index.ts"),
				Q = n("./src/reddit/actions/subreddit.ts"),
				Y = n("./src/reddit/actions/toaster.ts"),
				J = n("./src/reddit/helpers/localStorage/index.ts"),
				X = n("./src/reddit/models/Subreddit/index.ts"),
				Z = n("./src/reddit/models/Toast/index.ts"),
				$ = n("./src/reddit/routes/postCreation/constants.ts"),
				ee = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				te = n("./src/reddit/selectors/platform.ts"),
				ne = n("./src/reddit/selectors/user.ts");
			const se = () => async (e, t, n) => {
				const s = t(),
					r = Object(te.e)(s);
				if (!r || r.type !== X.g.Public) return;
				const o = r.name,
					i = Object(te.n)(s),
					a = Object(H.z)(s, {
						subredditName: o
					});
				if (!a) return;
				const {
					activity7Day: d
				} = a, l = !!d && d >= 51 && d <= 100, u = !o || Object(p.a)(o), m = i && i.urlParams.subredditName === o, b = Object(ne.R)(s), f = Object(ee.c)(s, {
					subredditId: Object(H.I)(s, o)
				});
				if (u || m || Object(J.E)() || !l || !b || f) return;
				const h = Object(W.d)(t(), {
					subredditName: o
				});
				if (!h || !h.currentlyViewingCount) return;
				const _ = (24 * h.currentlyViewingCount * 7).toString(),
					g = _[0].padEnd(_.length, "0");
				e(Object(Y.f)({
					buttonAction: async () => e(Object(c.b)(`/r/${o}${$.b}`)),
					buttonText: "Create Post",
					duration: -1,
					id: "createPostCta",
					kind: Z.b.Modal,
					name: "createPostCta",
					secondButtonAction: async () => Object(J.Jb)(),
					secondButtonText: "Dismiss",
					text: `There have been over ${g} visits to r/${o} in the past week. Create a new post and start the next conversation.`
				}))
			};
			var re = n("./src/reddit/actions/subreddit/questions.ts"),
				oe = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				ie = n("./src/reddit/actions/subredditSettings.ts"),
				ae = n("./src/reddit/actions/tags/index.ts"),
				de = n("./src/reddit/constants/history.ts"),
				ce = n("./src/reddit/constants/page.ts"),
				le = n("./src/reddit/constants/parameters.ts"),
				ue = n("./src/reddit/constants/postLayout.ts"),
				me = n("./src/reddit/contexts/PageLayer/index.tsx"),
				pe = n("./src/reddit/endpoints/gold/topAwarded.ts"),
				be = n("./src/reddit/endpoints/governance/posts.ts"),
				fe = n("./src/reddit/endpoints/page/subredditPage.ts"),
				he = n("./src/lib/base64/index.ts"),
				_e = n("./src/reddit/constants/experiments.ts"),
				ge = n("./src/reddit/constants/graphql.ts"),
				ve = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				xe = n("./src/reddit/selectors/adsSignals.ts"),
				Oe = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				Ee = n("./src/reddit/selectors/experiments/econ/index.ts"),
				ye = n("./src/reddit/selectors/experiments/onboarding.ts"),
				Ce = n("./src/redditGQL/operations/SubredditPageExtra.json");
			var je = n("./src/reddit/endpoints/profile/info.ts"),
				ke = n("./src/reddit/helpers/canonicalUrls.ts"),
				Ie = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				Se = n("./src/reddit/helpers/getTimeSortForListing/index.ts"),
				we = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts");

			function Te(e) {
				let {
					econLeaderboards: t,
					identity: n,
					trendingSubreddits: s
				} = e;
				const r = t.topAwardedPosts.map(e => e.post).filter(e => !e.removedBy && !e.isNsfw);
				return Object(we.b)(r, s, n)
			}
			var Ne = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				Pe = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				Re = n("./src/reddit/helpers/post/index.ts"),
				Ae = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				Me = n("./src/reddit/helpers/trackers/feed.ts"),
				Le = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				De = n("./src/reddit/models/RichTextJson/index.ts"),
				Fe = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				Ue = n("./src/reddit/selectors/communityFlairs.ts"),
				Be = n("./src/reddit/selectors/experiments/countrySites.ts"),
				qe = n("./src/reddit/helpers/chooseVariant/index.ts");
			var Ge = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				He = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				We = n("./src/reddit/selectors/experiments/topPosts.ts"),
				Ve = n("./src/reddit/selectors/gold/powerups/index.ts"),
				ze = n("./src/reddit/selectors/inlineSubredditEditing.ts"),
				Ke = n("./src/reddit/selectors/moderatorPermissions.ts"),
				Qe = n("./src/reddit/selectors/multireddit.ts"),
				Ye = n("./src/reddit/selectors/posts.ts"),
				Je = n("./src/reddit/endpoints/page/popularFeed.ts"),
				Xe = n("./src/lib/initializeClient/installReducer.ts"),
				Ze = n("./src/reddit/reducers/features/modUserNotes/index.ts"),
				$e = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				et = n("./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts"),
				tt = n("./node_modules/@sentry/minimal/esm/index.js"),
				nt = n("./src/lib/env/index.ts"),
				st = n("./node_modules/lodash/cloneDeep.js"),
				rt = n.n(st);
			const ot = new Set(["authorFlair.cssClass", "posts.adSupplementaryText", "posts.allAwardings", "posts.approvedAtUTC", "posts.approvedBy", "posts.attributionInfo", "posts.audioRoom", "posts.bannedAtUTC", "posts.bannedBy", "posts.collapsedBecauseCrowdControl", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForLinkedPosts", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isReactAllowed", "posts.isRemoved", "posts.isSpam", "posts.lastAuthorModNote", "posts.modQueueTriggers", "posts.modReportsDismissed", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.modReports", "posts.numReports", "posts.reactedFrom", "posts.removedBy", "posts.removedByCategory", "posts.topAwardedType", "posts.userReports", "posts.userReportsDismissed", "posts.modReasonBy", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "authorFlair.richtext", "authorFlair.text", "posts.collectionIds", "posts.liveCommentsWebsocket", "posts.thumbnail.url", "posts.discussionType", "posts.eventsOnRender", "posts.flair", "posts.gildings", "posts.media", "posts.goldCount", "posts.sendReplies", "posts.score", "posts.sendReplies", "posts.source.url", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "profiles.acceptFollowers", "profiles.communityIcon", "profiles.icon.url", "posts.upvoteRatio", "subreddits.acceptFollowers", "subreddits.allowChatPostCreation", "subreddits.communityIcon", "subreddits.icon.url", "subreddits.isChatPostFeatureEnabled", "subreddits.primaryColor", "subreddits.subscribers"]),
				it = new Set(["posts.upvoteRatio", "posts.score", "posts.sendReplies", "posts.media", "posts.eventsOnRender", "posts.liveCommentsWebsocket", "posts.flair", "posts.source.outboundUrl", "posts.source.outboundUrlCreated", "posts.source.outboundUrlExpiration", "posts.numComments", "posts.thumbnail.url", "posts.contentCategories", "subreddits.acceptFollowers", "subreddits.communityIcon", "subreddits.primaryColor", "subreddits.isChatPostFeatureEnabled", "subreddits.allowChatPostCreation", "subreddits.icon.url", "subreddits.subscribers", "token", "recentPostIds", "trendingSubredditIds", "posts.gildings", "posts.goldCount", "listingSort", "posts.discussionType", "posts.topAwardedType", "posts.allAwardings", "posts.audioRoom", "posts.approvedAtUTC", "posts.approvedBy", "posts.bannedAtUTC", "posts.bannedBy", "posts.ignoreReports", "posts.isApproved", "posts.isAuthorPremium", "posts.isEligibleForQASchema", "posts.isFollowed", "posts.isPinned", "posts.isRemoved", "posts.isSpam", "posts.isReactAllowed", "posts.reactedFrom", "posts.attributionInfo", "posts.modReports", "posts.numReports", "posts.pollData", "posts.predictionTournament", "posts.previewComments", "posts.removedBy", "posts.removedByCategory", "posts.userReports", "subreddits.answerableQuestions", "subreddits.freeFormReports", "subreddits.isSubscribed", "subreddits.devPlatformMetadata"]);
			var at = n("./node_modules/deep-diff/index.js");
			const dt = (e, t) => {
					e.postIds = t, e.posts = t.reduce((t, n) => (e.posts[n] && (t[n] = e.posts[n]), t), {}), e.postInstances = t.reduce((t, n) => (e.postInstances[n] && (t[n] = e.postInstances[n]), t), {});
					const n = Object.keys(e.posts).map(t => e.posts[t].belongsTo.id);
					e.subreddits = n.reduce((t, n) => (e.subreddits[n] && (t[n] = e.subreddits[n]), t), {}), e.postFlair = n.reduce((t, n) => (e.postFlair[n] && (t[n] = e.postFlair[n]), t), {})
				},
				ct = (e, t, n) => {
					const s = {},
						r = {};
					Object.keys(e).forEach(o => {
						if (!n.has(o)) {
							const i = e[o] || {},
								a = t[o] || {};
							s[o] = {}, r[o] = 0, Object.keys(i).forEach(e => {
								const t = i[e],
									d = a[e],
									c = Object(at.diff)(t, d, {
										prefilter: (e, t) => (e => {
											let {
												ignorePaths: t,
												path: n,
												k: s,
												key: r
											} = e;
											return t.has(`${s}.${n.length?`${n.join(".")}.`:""}${r}`) || t.has(`${s}.${r}`)
										})({
											ignorePaths: n,
											path: e,
											k: o,
											key: t
										}),
										normalize: (e, t, n, s) => n || s ? [n, s] : [n, n]
									});
								r[o] = c ? r[o] + c.length : (null == r ? void 0 : r[o]) || 0, c && (s[o][e] = {
									gatewayThing: t,
									gqlThing: d,
									diffResult: c
								})
							})
						}
					});
					const o = Object.keys(r).reduce((e, t) => e += r[t], 0);
					return {
						allDiffs: s,
						issueCounts: r,
						totalIssues: o
					}
				},
				lt = (e, t) => {
					const n = ((e, t) => {
							const n = e.postIds;
							return t.postIds.reduce((e, t, s) => {
								const r = n.findIndex(e => t === e);
								return r > 0 ? e.found[t] = {
									gateway: r,
									gql: s
								} : e.notFound.push(t), e
							}, {
								found: {},
								notFound: []
							})
						})(e, t),
						s = Object.keys(n.found).sort();
					return dt(e, s), dt(t, s), {
						gatewayResponse: e,
						normalizedGqlResponse: t,
						positionDiffs: n
					}
				},
				ut = e => {
					let {
						gatewayResponse: t,
						normalizedGqlResponse: n,
						ignorePaths: s,
						normalizeFunction: r
					} = e;
					if (r) {
						const e = r(t, n);
						return {
							...ct(e.gatewayResponse, e.normalizedGqlResponse, s),
							positionDiffs: e.positionDiffs
						}
					}
					return ct(t, n, s)
				};
			var mt = n("./src/reddit/helpers/locales.ts"),
				pt = n("./src/reddit/selectors/experiments/popularGqlMigration.ts"),
				bt = n("./node_modules/reselect/es/index.js");
			const ft = Object(bt.a)(e => Object(qe.c)(e, {
				experimentEligibilitySelector: qe.a,
				experimentName: _e.rc
			}), e => e === _e.Kd);
			var ht = n("./src/reddit/selectors/meta.ts");

			function _t(e) {
				return Boolean(e && e.subredditInfoByName)
			}
			Object(Xe.a)({
				features: {
					modUserNotes: Ze.a
				}
			});
			const gt = (e, t) => async n => {
				if (!e.ok && e.body && (e => !!e.reason)(e.body)) {
					const {
						body: {
							data: s,
							reason: r
						}
					} = e, o = s ? s.account : void 0, i = s && s.features || void 0, a = t ? t.toLowerCase() : "";
					if (404 === e.status)
						if (r === X.f.NotFoundSubreddit) n(y.t({
							account: o,
							features: i,
							subredditName: a
						}));
						else if (r === X.f.BannedSubreddit) {
						const e = s ? s.banMessage || s.ban_message : void 0;
						n(y.r({
							banMessage: e,
							account: o,
							features: i,
							subredditName: a
						}))
					}
					if (451 === e.status && n(y.s({
							account: o,
							features: i,
							subredditName: a
						})), 403 === e.status)
						if (r === X.f.GoldSubreddit) n(y.w({
							account: o,
							features: i,
							subredditName: a
						}));
						else if (r === X.f.PrivateSubreddit) n(y.x({
						account: o,
						features: i,
						subredditDescription: s.description || "",
						subredditName: a,
						isContributorRequestsDisabled: !!s.isContributorRequestsDisabled,
						isContributorRequestTimestamp: s.isContributorRequestTimestamp ? parseInt(s.isContributorRequestTimestamp, 10) : void 0,
						subredditId: s.id
					}));
					else if (r === X.f.QuarantinedSubreddit) {
						const e = !s || void 0 === s.quarantineRequiresEmailOptin || s.quarantineRequiresEmailOptin;
						n(y.z({
							account: o,
							features: i,
							subredditName: a,
							quarantineRequiresEmail: e,
							quarantineMessage: s.quarantineMessage,
							quarantineMessageHtml: s.quarantineMessageHtml || "",
							quarantineMessageRTJson: s.quarantineMessageRTJson || De.i
						}))
					} else if (r === X.f.GatedSubreddit) {
						const {
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: r
						} = s;
						n(y.v({
							account: o,
							features: i,
							subredditName: a,
							interstitialWarningMessage: e,
							interstitialWarningMessageHtml: t,
							interstitialWarningMessageRTJson: r
						}))
					}
				}
			}, vt = "PAGE__SUBREDDIT_PENDING", xt = "PAGE__SUBREDDIT_LOADED", Ot = "PAGE__SUBREDDIT_FAILED", Et = Object(b.a)(vt), yt = Object(b.a)(xt), Ct = Object(b.a)(Ot), jt = async e => {
				let {
					subredditsResponse: t,
					extraArgs: n,
					state: s,
					isPopular: r,
					isInGqlSubredditExperiment: o
				} = e;
				if (!t || o) return t;
				const i = {
					...t
				};
				if (!r) {
					const e = await Object(Re.a)(n.gqlContext, i.posts);
					i.posts = e
				}
				const a = await Object(et.a)(n.apiContext(), i.posts, s);
				return a && (i.posts = a), i
			}, kt = (e, t, n, o) => async (a, d, c) => {
				var u, m, b, f, h, _, g, y, C, R, M, D, F, U, W, K, J, X, $, ee, se, ce, le, ke, Ie;
				const Se = d(),
					we = Object(ne.Q)(Se) || Object(ne.R)(Se);
				if (Object(x.a)(Se.listings.postOrder.api.pending, e)) return;
				const Re = null === (m = null === (u = Object(te.b)(Se)) || void 0 === u ? void 0 : u.routeMatch) || void 0 === m ? void 0 : m.route.chunk,
					{
						currentPage: Le
					} = Se.platform,
					{
						countryCode: De,
						languageCode: Ue
					} = (null == Le ? void 0 : Le.urlParams) || {},
					He = Object(p.a)(t, {
						countryCode: De,
						languageCode: Ue
					}),
					We = Object(p.c)(t, {
						countryCode: De,
						languageCode: Ue
					}),
					Ke = (Object(p.b)(t, {
						countryCode: De,
						languageCode: Ue
					}) || We) && Se.posts.recent.length ? {
						...n,
						recentPostIds: Se.posts.recent
					} : n;
				Ke.layout = ue.e[Object(me.U)(Se, {})], We && (Ke.forceGeopopular = !0), a(Et({
					key: e
				}));
				const Qe = !He && Object(te.m)(Se) && Object(Ge.b)(Se),
					Ye = We && (Object(pt.a)(Se) || Object(pt.b)(Se)),
					Xe = We && ft(Se);
				let Ze, et;
				if ((Ye || Xe) && (Ze = Object(v.i)(() => Object(Je.a)(c.gqlContext(), Object(fe.c)(Se, t, Ke, !0)), {
						name: Qe ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: Re,
						isLoggedIn: we
					})), Ye) et = Ze;
				else if (n.sort === l.bb.AWARDED && We) et = Object(pe.a)(c.gqlContext(), {
					top: 0,
					includeListingMetadata: !0
				}).then(e => {
					const t = e.body;
					return {
						...e,
						body: Te(t.data)
					}
				});
				else {
					const e = Qe ? () => Object(fe.b)(c.gqlContext(), Object(fe.c)(Se, t, Ke, !0), we) : () => Object(fe.a)(c.apiContext(), t, Ke);
					et = Object(v.i)(e, {
						name: Qe ? "fetchSubredditPageFromGql" : "fetchSubredditPage",
						page: Re,
						isLoggedIn: we
					})
				}
				const st = Object(H.X)(d(), {
						subredditId: Object(H.I)(d(), t)
					}).length > 0,
					at = Object(v.i)(() => (async function(e, t) {
						return Object(B.a)(e, {
							...Ce,
							variables: t
						})
					})(c.gqlContext(), ((e, t) => {
						let {
							after: n,
							isMobile: s,
							subredditName: r,
							isFake: o,
							isLoggedIn: i,
							layout: a,
							limit: d,
							hasRules: c,
							sort: l,
							t: u
						} = t;
						var m, p;
						const b = Object(ye.i)(e),
							f = !!b && !Object(_e.rg)(b) && (o || b === _e.nb.Community),
							{
								adsSeenCount: h,
								totalPostsSeenCount: _,
								sessionStartTime: g
							} = Object(xe.a)(e),
							v = Object(Ee.d)(e),
							x = Object(Oe.c)(e),
							O = {
								subredditName: r,
								isFake: o,
								sort: l,
								adContext: {
									layout: a ? a.toUpperCase() : ge.a.Card,
									clientSignalSessionData: {
										adsSeenCount: h,
										totalPostsSeenCount: _,
										sessionStartTime: g
									}
								},
								includeAchievementFlairs: !o,
								includeCustomEmojis: !o && v,
								includeIdentity: i,
								includeInterestTopics: f,
								includePowerups: !o,
								includeQuestions: i && !o,
								includeRules: !o && !c,
								includeRedditorKarma: i && !(null === (p = null === (m = e.user.account) || void 0 === m ? void 0 : m.karma) || void 0 === p ? void 0 : p.total),
								includeSubredditLinks: !i,
								includeSubredditRankings: x,
								includeTopicLinks: !i
							};
						return l && (O.sort = l.toUpperCase()), u && (O.range = u.toUpperCase()), s ? O.pageSize = Object(ve.a)(a) : d && (O.pageSize = d), n && (O.after = Object(he.a)(n)), O
					})(Se, {
						after: n.after,
						isLoggedIn: we,
						subredditName: t,
						hasRules: st,
						isFake: He,
						isMobile: n.isMobile,
						layout: n.layout,
						limit: n.limit,
						sort: n.sort,
						t: n.t
					})), {
						name: "fetchSubredditPageExtra",
						page: Re,
						isLoggedIn: we
					}),
					dt = Object($e.a)();
				let ct, bt;
				Qe ? ct = await et : [ct, bt] = await Promise.all([et, at]);
				const vt = bt && Object(r.c)(bt) ? bt.body.data : null;
				if (Xe) {
					const e = await Ze;
					! function(e) {
						let {
							gatewayResponse: t,
							normalizedGqlResponse: n,
							rawGqlResponse: s,
							ignorePaths: r = ot,
							normalizeFunction: o
						} = e;
						const i = rt()(t),
							a = rt()(n);
						if (Object(nt.a)()) {
							console.group("GQL Popular Shadowtest"), console.groupCollapsed("raw gql response"), console.log(s), console.groupEnd(), console.groupCollapsed("normalized gql response"), console.log(n), console.groupEnd(), console.groupCollapsed("gateway response"), console.log(t), console.groupEnd();
							const e = ut({
									gatewayResponse: i,
									normalizedGqlResponse: a,
									ignorePaths: r,
									normalizeFunction: o
								}),
								{
									allDiffs: d,
									issueCounts: c,
									totalIssues: l
								} = e;
							e.positionDiffs && (console.groupCollapsed("position errors"), console.log(e.positionDiffs), console.groupEnd()), console.groupCollapsed(`diff: ${l} issues`), console.log("lhs = gateway\nrhs = gql");
							for (const t in d) {
								if (console.groupCollapsed(`${t}: ${c[t]} issues`), c[t] > 0)
									for (const e in d[t]) {
										const n = d[t][e].diffResult;
										console.groupCollapsed(`${e}: ${n.length||0} issues`), console.log(n), console.log({
											gql: d[t][e].gqlThing,
											gateway: d[t][e].gatewayThing
										}), console.groupEnd()
									}
								console.groupEnd()
							}
							console.groupEnd(), console.groupEnd()
						}
						if (Object(nt.b)() || Object(nt.c)()) {
							const e = ut({
								gatewayResponse: i,
								normalizedGqlResponse: a,
								ignorePaths: r,
								normalizeFunction: o
							});
							tt.l(t => {
								t.setExtra("info", e), t.setExtra("bypassSampling", !0), tt.d("GQL Popular Shadowtest Diff")
							})
						}
					}({
						gatewayResponse: ct.body,
						normalizedGqlResponse: e.body,
						rawGqlResponse: e,
						ignorePaths: it,
						normalizeFunction: lt
					})
				}
				let xt = ct.body;
				const Ot = (null == xt ? void 0 : xt.subreddits) ? ((e, t) => {
					var n;
					return null === (n = i()(e, e => (null == e ? void 0 : e.name.toLowerCase()) === t.toLowerCase())) || void 0 === n ? void 0 : n.id
				})(xt.subreddits, t) : null;
				xt = await jt({
					subredditsResponse: xt,
					isInGqlSubredditExperiment: Qe,
					extraArgs: c,
					isPopular: We,
					state: Se
				}), a(L.n(ct.status));
				const It = `error-${e}`,
					St = He || Ot;
				if (ct.ok && St || We && xt) {
					if ((We || !He && Ot) && xt.geoFilter && a(Object(N.k)(xt.geoFilter)), !He && Ot) {
						let e, t;
						if (e = Qe ? xt : Object(S.b)(null == vt ? void 0 : vt.subredditInfoByName), Object(S.a)(a, Ot, e), Object(Ee.d)(Se)) {
							let e;
							e = Qe ? xt : Object(w.b)(null == vt ? void 0 : vt.subredditInfoByName), Object(w.a)(a, Ot, e)
						}
						t = Qe ? xt.powerups : Object(T.b)(null == vt ? void 0 : vt.subredditInfoByName, null == vt ? void 0 : vt.identity);
						const n = (null === (f = null === (b = null == xt ? void 0 : xt.subredditAboutInfo) || void 0 === b ? void 0 : b[Ot]) || void 0 === f ? void 0 : f.detectedLanguage) || (null === (h = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === h ? void 0 : h.detectedLanguage);
						Object(ht.d)(Se) && n && Object(Be.f)(Se) && await Object(mt.a)(n, a), xt.subredditAboutInfo[Ot].detectedLanguage = n, Object(T.a)(a, Ot, t), Qe ? a(Object(k.n)(Ot, xt.predictionTournaments || [])) : (null == vt ? void 0 : vt.subredditInfoByName) && a(Object(k.n)(Ot, vt.subredditInfoByName.predictionTournaments || [])), Object(Ve.b)(d(), {
							subredditId: Ot
						}) && (e => Object(qe.c)(e, {
							experimentName: _e.sd,
							experimentEligibilitySelector: ne.R
						}))(d())
					}
					let s;
					const r = null === (_ = xt.postIds) || void 0 === _ ? void 0 : _.filter(e => !!xt.posts[e].isMeta);
					if (r && r.length && Ot) {
						const e = Object(v.i)(() => Object(be.a)(c.apiContext(), Ot, r), {
								name: "getGovernanceData",
								page: Re,
								isLoggedIn: we
							}),
							t = await e;
						t.ok && (s = t.body)
					}
					if (Ot) {
						const e = (null === (y = null === (g = null == xt ? void 0 : xt.subredditAboutInfo) || void 0 === g ? void 0 : g[Ot]) || void 0 === y ? void 0 : y.isEligibleForContentBlocking) || (null === (C = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === C ? void 0 : C.isEligibleForContentBlocking);
						xt.subredditAboutInfo[Ot].isEligibleForContentBlocking = e;
						const t = (null === (M = null === (R = null == xt ? void 0 : xt.subredditAboutInfo) || void 0 === R ? void 0 : R[Ot]) || void 0 === M ? void 0 : M.isMediaInCommentsSettingShown) || (null === (D = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === D ? void 0 : D.isMediaInCommentsSettingShown);
						xt.subredditAboutInfo[Ot].isMediaInCommentsSettingShown = t;
						const n = Qe ? null : null === (F = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === F ? void 0 : F.directoryRankings;
						n && (xt.subredditAboutInfo[Ot].directoryRankings = n)
					}
					if (vt) {
						const e = null === (W = null === (U = vt.identity) || void 0 === U ? void 0 : U.redditor) || void 0 === W ? void 0 : W.karma,
							t = {
								karma: {
									...(null === (K = Se.user.account) || void 0 === K ? void 0 : K.karma) || je.a,
									...e
								}
							};
						xt.account && Object.assign(xt.account, t)
					}
					if (Ot) {
						let e, t;
						if (Qe) {
							const n = xt.subredditAboutInfo[Ot];
							e = null == n ? void 0 : n.notificationLevel, t = null == n ? void 0 : n.myRedditSettings
						} else if (_t(vt)) {
							const n = vt.subredditInfoByName;
							e = null == n ? void 0 : n.notificationLevel, t = null == n ? void 0 : n.myRedditSettings
						}
						xt.subredditAboutInfo[Ot].notificationLevel = e, xt.subredditAboutInfo[Ot].myRedditSettings = t
					}
					if (Ot) {
						let e;
						_t(vt) && (e = null === (J = vt.subredditInfoByName) || void 0 === J ? void 0 : J.isMuted), xt.subredditAboutInfo[Ot].isMuted = e
					}
					const i = null === (X = xt.subredditPermissions) || void 0 === X ? void 0 : X.posts;
					!Qe && i && a(Object(P.a)({
						postIds: xt.postIds
					}));
					let l = null == xt ? void 0 : xt.interestTopicRecommendations;
					if (!l && (null == vt ? void 0 : vt.interestTopics)) {
						const e = Object(Ne.a)(vt.interestTopics);
						e.topics.length && (l = {
							interests: e,
							index: 5
						})
					}
					l && a(Object(A.subredditInterestTopicsLoaded)({
						interestTopicRecommendations: l
					})), a(yt({
						key: e,
						meta: Se.meta,
						governance: s,
						correlationId: dt,
						...xt,
						postIds: xt.postIds
					}));
					const u = null === (ee = null === ($ = Object(te.b)(Se)) || void 0 === $ ? void 0 : $.locationState) || void 0 === ee ? void 0 : ee[de.b.FeedLoadReason];
					if (Object(Me.b)(n.isRefresh ? de.a.UserRefresh : null != u ? u : de.a.InitialLoad)(d()), !He) {
						const e = Object(H.I)(d(), t);
						Qe && xt.subredditRules ? a(Q.t({
							rules: {
								rules: xt.subredditRules
							},
							subredditId: e
						})) : (null === (se = null == vt ? void 0 : vt.subreddit) || void 0 === se ? void 0 : se.rules) && a(Q.t({
							rules: Object(Pe.a)(vt.subreddit.rules),
							subredditId: e
						}));
						const n = Object(E.c)(xt.posts, e),
							s = Object(E.b)(xt.structuredStyles),
							r = (s ? Object(E.d)(s) : []).concat(n);
						a(Object(E.a)(r, e))
					}
					if (o && a(Y.g(It)), a(Object(O.b)(Fe.a.SUBREDDIT)), a(Object(I.p)()), Ot) {
						let e, n, s;
						if (Qe ? (e = xt.questions, n = xt.subredditLinks, s = xt.subredditTopicLinks) : (e = null == vt ? void 0 : vt.subredditInfoByName, n = Object(q.a)({
								data: {
									subredditInfoById: null == vt ? void 0 : vt.subredditInfoByName
								}
							}), s = Object(G.a)({
								data: {
									subredditInfoById: null == vt ? void 0 : vt.subredditInfoByName
								}
							})), Object(re.a)(a, Ot, e), a(V(Ot, n)), a(z(Ot, s)), !Qe && (null === (le = null === (ce = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === ce ? void 0 : ce.elements) || void 0 === le ? void 0 : le.edges)) {
							const e = (null === (Ie = null === (ke = null == vt ? void 0 : vt.subredditInfoByName) || void 0 === ke ? void 0 : ke.elements) || void 0 === Ie ? void 0 : Ie.edges).map(e => {
								var t, n;
								return null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote
							});
							a(Object(oe.e)({
								subredditId: Ot,
								nodes: e
							}))
						} else if (Qe && (null == xt ? void 0 : xt.postIds)) {
							const e = xt.postIds.map(e => null == xt ? void 0 : xt.posts[e].lastAuthorModNote);
							e && a(Object(oe.e)({
								subredditId: Ot,
								nodes: e
							}))
						}
						const r = [Object(v.i)(() => a(Object(j.a)({
							subredditId: Ot,
							postIds: xt.postIds,
							skip: ["subscription"]
						})), {
							name: "fetchAllEconomicsData",
							page: Re,
							isLoggedIn: we
						})];
						if (Object(ze.a)(d(), {
								subredditId: Ot
							})) {
							const e = Object(v.i)(() => a(Object(ie.h)(t, Ot)), {
									name: "subredditSettingsRequested",
									isLoggedIn: we,
									page: Re
								}),
								n = Object(v.i)(() => a(Object(ae.g)(Ot, Ae.a.idCard)), {
									name: "subredditTagsRequested",
									isLoggedIn: we,
									page: Re
								});
							r.push(e, n)
						}
						await Promise.all(r)
					}
				} else {
					const r = ct.ok ? void 0 : ct.error;
					if (Object(Me.a)(r ? `${ct.status||"000"}: ${r.type}` : "000: UNKNOWN_ERROR")(d()), 403 === ct.status || 404 === ct.status || 451 === ct.status) return void a(gt(ct, t));
					a(Ct({
						error: !ct.ok && ct.error || {
							type: l.L.NOT_FOUND_ERROR
						},
						key: e,
						...xt
					})), o && a(Y.f({
						id: It,
						kind: Z.b.Error,
						text: s.fbt._("Sorry, we couldn't load posts for this page.", null, {
							hk: "CvZvm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "3gV6S0"
						}),
						buttonAction: kt(e, t, n, o)
					}))
				}
			}, It = (e, t, n) => async (s, r) => {
				const o = r(),
					i = Object(f.a)(e, t.sort, t);
				Object(Ye.z)(o, {
					listingKey: i
				}).length > 0 || await s(kt(i, e, t, n))
			}, St = (e, t, n, s) => {
				const r = Object(Be.b)(e);
				if (Object(p.a)(t, {
						countryCode: n,
						languageCode: s
					})) {
					if (Object(m.a)(t)) {
						return Object(Qe.a)(e, {
							listingName: t
						}).displayText
					}
					if (r) return Object(g.a)(e, Object(_.g)(t.toLowerCase()));
					switch (t.toLowerCase()) {
						case ce.d.Popular:
							return "r/popular";
						case ce.d.All:
							return "r/all"
					}
				}
				const o = Object(H.bb)(e, {
					subredditName: t
				});
				if (r) {
					const n = Object(H.z)(e, {
							subredditName: t
						}),
						s = n && n.detectedLanguage;
					return Object(g.a)(e, o, s)
				}
				return o
			}, wt = (e, t, n, s) => s ? Object(h.b)(e.subredditName, void 0, s) : Object(f.a)(e.subredditName, t, n), Tt = (e, t) => async (n, s) => {
				var r, o, i;
				const {
					countryCode: a,
					languageCode: m
				} = e.params, b = Object(u.e)(e.params), {
					styling: _
				} = e.queryParams, g = s(), y = Object(Ie.a)(e.params, g);
				if ("Popular" === b) return void n(Object(c.c)(e.url.replace("r/Popular", "r/popular")));
				if ("All" === b) return void n(Object(c.c)(e.url.replace("r/All", "r/all")));
				const j = Object(h.d)(e.queryParams, Object(ne.lb)(g)),
					k = wt({
						subredditName: b,
						countryCode: a,
						languageCode: m
					}, y, e.queryParams, j),
					S = y,
					w = Object(x.a)(g.listings.postOrder.api.error, k),
					T = Object(x.a)(g.listings.postOrder.api.pending, k);
				let N = !!Object(x.a)(g.listings.postOrder.ids, k);
				const P = Object(x.a)(g.listings.postOrder.listingSort, k);
				P && P.hasChanged && (N = !1);
				let A = Object(H.I)(g, b);
				const F = (e, t) => "true" === _ && ((e, t) => Object(Ke.b)(Le.c.config)(e, {
						subredditId: t
					}) || Object(Ke.b)(Le.c.flair)(e, {
						subredditId: t
					}))(e, t),
					U = le.O in e.queryParams && e.queryParams[le.O].toUpperCase() || "",
					B = U in l.oc && l.oc[U];
				if (T || N && !w && !t) {
					if (F(g, A) && n(K.i(A)), N) {
						const t = St(s(), b, a, m);
						n(L.m({
							title: t
						})), (null === (r = g.listings.postOrder.correlationIds) || void 0 === r ? void 0 : r[k]) && n(L.o({
							correlationId: g.listings.postOrder.correlationIds[k]
						})), Object(ke.g)(s(), n, e), window.addEventListener("load", () => {
							n(Object(I.p)())
						}), g.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
							n(Object(O.b)(Fe.a.SUBREDDIT))
						}), n(se())
					}
					return void(Object(He.e)(s()) && n(Object(R.a)()))
				}
				n(C.g());
				const q = null === (i = null === (o = Object(te.b)(g)) || void 0 === o ? void 0 : o.routeMatch) || void 0 === i ? void 0 : i.route.chunk,
					G = Object(ne.R)(s()),
					W = Object(v.i)(() => n(Object(D.c)(`r/${b}`)), {
						name: "rpanConfigRequested",
						isLoggedIn: G,
						page: q
					});
				if (j) {
					const e = Object(v.i)(() => n(Object(M.d)({
						key: k,
						options: j,
						subredditName: b
					})), {
						name: "searchDataRequested",
						isLoggedIn: G,
						page: q
					});
					await e
				} else {
					const t = {
						...d()(e.queryParams, [...le.q, ...le.p, le.l]),
						sort: S,
						t: Object(Se.a)(S, B)
					};
					await n(kt(k, b, t, !0))
				}
				const V = g.platform.currentPage,
					z = Object(We.d)(g, {
						pageLayer: V
					});
				if (Object(We.a)(z) || Object(We.b)(z) || Object(We.c)(z)) {
					const e = Object(f.a)(b, l.bb.TOP, {
							t: l.oc.WEEK
						}),
						t = {
							sort: l.bb.TOP,
							t: l.oc.WEEK
						};
					await n(kt(e, b, t, !1))
				}
				if (Object(He.e)(s()) && n(Object(R.a)()), A = A || Object(H.I)(s(), b), !Object(Ue.a)(g, A) && !Object(p.a)(b, {
						countryCode: a,
						languageCode: m
					})) {
					const e = Object(v.i)(() => n(Object(E.e)(b)), {
						name: "getTopCommunityFlair",
						page: q,
						isLoggedIn: G
					});
					await e
				}
				F(s(), A) && n(K.i(A)), Object(ke.g)(s(), n, e);
				const Q = St(s(), b);
				n(L.m({
					title: Q
				})), n(se()), await W
			}, Nt = "PAGE__SUBREDDIT_INVALIDATE_LISTING", Pt = Object(b.a)(Nt)
		},
		"./src/reddit/actions/pages/subredditWiki/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_PENDING",
				r = "PAGE__SUBREDDIT_WIKI_PAGE_LOADED",
				o = "PAGE__SUBREDDIT_WIKI_PAGE_FAILED"
		},
		"./src/reddit/actions/pages/subredditWiki/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "subredditWikiDataPending", (function() {
				return We
			})), n.d(t, "subredditWikiDataLoaded", (function() {
				return Ve
			})), n.d(t, "subredditWikiDataFailed", (function() {
				return ze
			})), n.d(t, "fetchSubredditWikiData", (function() {
				return Ye
			})), n.d(t, "handleWikiRedirects", (function() {
				return Xe
			})), n.d(t, "subredditWikDataRequested", (function() {
				return Ze
			})), n.d(t, "subredditWikiPageRequested", (function() {
				return $e
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/isEmpty.js"),
				o = n.n(r),
				i = n("./node_modules/react-router-redux/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/config.ts"),
				u = n("./src/reddit/actions/platform.ts"),
				m = n("./src/reddit/helpers/path/index.ts");
			var p = n("./src/reddit/actions/ads/index.ts"),
				b = n("./src/reddit/actions/pages/subreddit.ts"),
				f = n("./src/reddit/actions/pages/subredditWiki/constants.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/actions/wiki/wikiBannedContributors/index.ts"),
				g = n("./src/reddit/actions/wiki/wikiContributors/index.ts"),
				v = n("./src/lib/makeGqlRequest/index.ts"),
				x = n("./src/reddit/helpers/wiki/wikiRevision.ts"),
				O = n("./src/redditGQL/operations/WikiComparisonDiff.json");
			var E = n("./src/reddit/helpers/wiki/makeComparisonDiffKey.ts"),
				y = n("./src/reddit/selectors/subredditWiki.ts");
			const C = Object(d.a)("WIKI_DIFF_PENDING"),
				j = Object(d.a)("WIKI_DIFF_LOADED"),
				k = Object(d.a)("WIKI_DIFF_FAILED"),
				I = e => async (t, n, s) => {
					const r = n(),
						o = Object(E.a)(e),
						i = Object(y.i)(r, {
							key: o
						});
					if (i && (i.pending || !i.error)) return !0;
					const d = {
						key: o
					};
					t(C(d));
					const c = await ((e, t) => Object(v.a)(e, {
						...O,
						variables: {
							...t,
							comparisonRevisionId: Object(x.b)(t.comparisonRevisionId),
							revisionId: Object(x.b)(t.revisionId)
						}
					}))(s.gqlContext(), e);
					let l = null,
						u = "";
					if (c.ok) {
						const e = c.body,
							t = e.data.subreddit && e.data.subreddit.wiki,
							n = t && t.page && t.page.revisionComparisonDiffHtml;
						n ? u = n : l = {
							type: a.L.NOT_FOUND_ERROR
						}
					} else l = c.error || {
						type: a.L.UNKNOWN_ERROR
					};
					return t(l ? k({
						...d,
						error: l
					}) : j({
						...d,
						htmlDiff: u
					})), !l
				};
			var S = n("./src/reddit/actions/wiki/wikiPageSettings/index.tsx"),
				w = n("./src/reddit/actions/wiki/wikiRevisions/index.ts"),
				T = n("./src/reddit/constants/parameters.ts"),
				N = n("./src/reddit/constants/wiki.ts"),
				P = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				R = n("./src/reddit/helpers/brandSafety/index.ts"),
				A = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				M = n("./src/reddit/models/Toast/index.ts"),
				L = n("./src/reddit/reducers/sidebarPromotedPosts/models/index.ts"),
				D = n("./src/reddit/routes/subredditWiki/normalizeWikiUrl.ts"),
				F = n("./src/reddit/selectors/subreddit.ts"),
				U = n("./src/lib/initializeClient/installReducer.ts"),
				B = n("./node_modules/redux/es/redux.js");
			const q = {};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : q,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "WIKI_DIFF_LOADED": {
						const {
							key: n,
							htmlDiff: s
						} = t.payload;
						return {
							...e,
							[n]: {
								htmlDiff: s
							}
						}
					}
					case "WIKI_DIFF_PENDING": {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !0
							}
						}
					}
					case "WIKI_DIFF_FAILED": {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								pending: !1,
								error: s
							}
						}
					}
					default:
						return e
				}
			};
			const H = {};
			var W = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : H,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b:
							const n = t.payload,
								{
									subredditWiki: s,
									options: r
								} = n,
								o = s && s.directory;
							if (!o) return e;
							const {
								subredditName: i
							} = r;
							return {
								...e, [i.toLowerCase()]: o
							};
						default:
							return e
					}
				},
				V = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const z = {};
			var K = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b: {
							const {
								subredditWiki: n,
								pageKey: s
							} = t.payload, {
								page: r
							} = n;
							return s && r ? {
								...e,
								[s]: r
							} : e
						}
						case V.a: {
							const {
								pageKey: n,
								page: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Q = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const Y = {};
			var J = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Y,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Q.c: {
							const {
								settings: n,
								pageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: n
							} : e
						}
						case Q.d: {
							const {
								isVisible: n,
								editPermissions: s,
								pageKey: r
							} = t.payload, o = e[r];
							return o ? {
								...e,
								[r]: {
									...o,
									isVisible: n,
									editPermissions: s
								}
							} : e
						}
						case Q.b: {
							const {
								editorsInfo: n,
								afterToken: s,
								pageKey: r
							} = t.payload, o = e[r];
							if (!o) return e;
							const i = [...o.editorsInfo, ...n];
							return {
								...e,
								[r]: {
									...o,
									editorsInfo: i,
									afterToken: s
								}
							}
						}
						case Q.a: {
							const {
								username: n,
								pageKey: s
							} = t.payload, r = e[s];
							if (!r) return e;
							const o = r.editorsInfo.filter(e => e.username !== n);
							return {
								...e,
								[s]: {
									...r,
									editorsInfo: o
								}
							}
						}
						default:
							return e
					}
				},
				X = n("./src/lib/omitKey/index.ts");
			const Z = {};
			var $ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case V.b: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case V.d:
					case V.c: {
						const {
							key: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const ee = {};
			var te = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ee,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case V.d:
						case V.b:
						case V.c: {
							const {
								key: n
							} = t.payload, s = t.type === V.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				ne = Object(B.c)({
					error: $,
					pending: te
				}),
				se = n("./src/reddit/actions/wiki/wikiEditing/constants.ts");
			const re = {};
			var oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : re,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case V.c: {
						const {
							key: n,
							options: s,
							pageInfo: r,
							revisionsIds: o
						} = t.payload, i = e[n], a = s.after && i ? [...i.ids, ...o] : o;
						return {
							...e,
							[n]: {
								ids: a,
								pageInfo: r
							}
						}
					}
					case V.a: {
						const {
							page: {
								revision: n
							},
							pageRevisionsListingKey: s,
							recentRevisionsListingKey: r
						} = t.payload, o = e[s];
						return o && n ? {
							...Object(X.a)(e, r),
							[s]: {
								...o,
								ids: [n.id, ...o.ids]
							}
						} : e
					}
					case se.a: {
						const {
							pageRevisionsListingKey: n,
							recentRevisionsListingKey: s
						} = t.payload, r = {
							...e
						};
						return delete r[n], delete r[s], r
					}
					default:
						return e
				}
			};
			const ie = {};
			var ae = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ie,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.b: {
							const {
								subredditWiki: {
									page: n
								}
							} = t.payload, s = n && n.revision;
							return s && !e[s.id] ? {
								...e,
								[s.id]: s
							} : e
						}
						case V.c: {
							const {
								revisions: n
							} = t.payload;
							return {
								...e,
								...n
							}
						}
						case V.a: {
							const {
								page: n
							} = t.payload, s = n.revision;
							return s ? {
								...e,
								[s.id]: s
							} : e
						}
						case V.e: {
							const {
								revisionId: n,
								isHidden: s
							} = t.payload, r = e[n];
							return r ? {
								...e,
								[n]: {
									...r,
									isHidden: s
								}
							} : e
						}
						default:
							return e
					}
				},
				de = Object(B.c)({
					api: ne,
					listings: oe,
					models: ae
				}),
				ce = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const le = {};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : le,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.c:
					case ce.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ce.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case ce.d:
					case ce.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const be = {};
			var fe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : be,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.d:
						case ce.c:
						case ce.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === ce.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				he = Object(B.c)({
					error: pe,
					pending: fe
				});
			const _e = {};
			var ge = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _e,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								bannedContributors: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: {
									...e[n],
									...s
								}
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload, r = Object(X.a)(e[n], s);
							return {
								...e,
								[n]: r
							}
						}
						default:
							return e
					}
				},
				ve = n("./node_modules/lodash/uniq.js"),
				xe = n.n(ve);
			const Oe = {};
			var Ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Oe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.c:
						case ce.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: xe()([...e[n] || [], ...s])
							}
						}
						case ce.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: xe()([...s, ...e[n] || []])
							}
						}
						case ce.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				ye = Object(B.c)({
					afterToken: ue,
					api: he,
					models: ge,
					userOrder: Ee
				});
			const Ce = {};
			var je = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ce,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ce.g: {
							const {
								subredditName: n,
								bannedContributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				ke = Object(B.c)({
					listing: ye,
					search: je
				}),
				Ie = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const Se = {};
			var we = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.c:
					case Ie.a: {
						const {
							subredditName: n,
							afterToken: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			const Te = {};
			var Ne = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Te,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.b: {
						const {
							subredditName: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case Ie.d:
					case Ie.c: {
						const {
							subredditName: n
						} = t.payload;
						return Object(X.a)(e, n)
					}
					default:
						return e
				}
			};
			const Pe = {};
			var Re = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pe,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.d:
						case Ie.c:
						case Ie.b: {
							const {
								subredditName: n
							} = t.payload, s = t.type === Ie.d;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Ae = Object(B.c)({
					error: Ne,
					pending: Re
				});
			const Me = {};
			var Le = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case Ie.c:
					case Ie.a: {
						const {
							subredditName: n,
							contributors: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case Ie.e: {
						const {
							subredditName: n,
							contributor: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s
							}
						}
					}
					case Ie.f: {
						const {
							subredditName: n,
							userId: s
						} = t.payload, r = Object(X.a)(e[n], s);
						return {
							...e,
							newState: r
						}
					}
					default:
						return e
				}
			};
			const De = {};
			var Fe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : De,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.c:
						case Ie.a: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: xe()([...e[n] || [], ...s])
							}
						}
						case Ie.e: {
							const {
								subredditName: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: [...s, ...e[n] || []]
							}
						}
						case Ie.f: {
							const {
								subredditName: n,
								userId: s
							} = t.payload;
							return {
								...e,
								[n]: (e[n] || []).filter(e => e !== s)
							}
						}
						default:
							return e
					}
				},
				Ue = Object(B.c)({
					afterToken: we,
					api: Ae,
					models: Le,
					userOrder: Fe
				});
			const Be = {};
			var qe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Be,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case Ie.g: {
							const {
								subredditName: n,
								contributor: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						default:
							return e
					}
				},
				Ge = Object(B.c)({
					listing: Ue,
					search: qe
				}),
				He = Object(B.c)({
					diff: G,
					directory: W,
					pages: K,
					pageSettings: J,
					revisions: de,
					wikiBannedContributors: ke,
					wikiContributors: Ge
				});
			Object(U.a)({
				pages: {
					subredditWiki: He
				}
			});
			const We = Object(d.a)(f.c),
				Ve = Object(d.a)(f.b),
				ze = Object(d.a)(f.a),
				Ke = (e, t, n, s) => {
					return n === N.j ? Qe(e, t) : !!Object(y.c)(e, {
						subredditName: t,
						wikiPageName: n,
						revisionId: s
					})
				},
				Qe = (e, t) => !!Object(y.b)(e, {
					subredditName: t
				}),
				Ye = e => async (t, n, r) => {
					const {
						canShowFailToast: i,
						wikiPageName: d
					} = e, c = d === N.j, l = {
						...e,
						includePageData: e.includePageData && !c
					}, u = d ? Object(A.a)({
						...e,
						wikiPageName: d
					}) : void 0;
					t(We({
						options: l,
						pageKey: u
					}));
					const m = await Object(P.a)(r.gqlContext(), l),
						p = m.body,
						b = m.ok ? p.data && p.data.subreddit && p.data.subreddit.wiki : null;
					return m.ok && b ? t(Ve({
						options: l,
						pageKey: u,
						subredditWiki: b
					})) : (t(ze({
						options: l,
						pageKey: u,
						error: m.error || {
							type: a.L.NOT_FOUND_ERROR
						}
					})), i && t(Object(h.f)({
						id: "SUBREDDIT_WIKI_DATA_ERROR_TOAST",
						kind: M.b.Error,
						text: s.fbt._("Something went wrong loading this page. Try again?", null, {
							hk: "wZxm"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "mgOpG"
						}),
						buttonAction: Ye(e)
					}))), !(!m.ok || !o()(p.data.subreddit)) || !(!m.ok || !b)
				}, Je = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s) => {
						const r = s(),
							o = {
								sort: a.bb.HOT
							},
							i = Object(c.a)(e, o.sort),
							d = r.listings.postOrder.api.error[i],
							l = r.listings.postOrder.api.pending[i],
							u = !!r.listings.postOrder.ids[i];
						return !!(l || u && !d) || (await n(Object(b.subredditDataRequested)(i, e, o, t)), !s().listings.postOrder.api.error[i])
					}
				}, Xe = e => async (t, n) => {
					const {
						params: s,
						url: r
					} = e, {
						wikiPageName: o
					} = s, a = Object(D.a)(r, s);
					let d = !1;
					return N.l.includes(o || "") ? (await (async (e, t) => {
						const n = `${l.a.oldRedditUrl}${Object(m.b)(e)}`;
						window.location.href = n
					})(e.url), d = !0) : r !== a && (await t(Object(i.c)(a)), d = !0), d
				}, Ze = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, i) => {
						const {
							subredditName: d = N.e,
							wikiPageName: c,
							wikiSubRoute: l
						} = e, u = t[T.T], m = t[T.U], p = u ? Object(x.a)(u) : void 0, b = m ? Object(x.a)(m) : void 0, f = c === N.j, v = l === N.m.Revisions;
						let O = !1,
							E = !1;
						if (n) {
							const {
								pageName: t
							} = e;
							O = t === a.mc.WikiContributors, E = t === a.mc.WikiBanned
						}
						const y = o(),
							C = (f || n) && !Qe(y, d),
							j = !!c && !Ke(y, d, c, p),
							k = [];
						k.push(r(Je(d))), (C || j) && k.push(r(Ye({
							includeDirectory: C,
							includePageData: j,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), l === N.m.Settings && c && k.push(r(Object(S.c)(d, c))), c && p && b && k.push(r(I({
							comparisonRevisionId: b,
							revisionId: p,
							subredditName: d,
							wikiPageName: c
						}))), v && k.push(r(Object(w.c)({
							isRecent: !c,
							wikiPageName: c,
							subredditName: d
						}))), O && k.push(r(Object(g.e)(d))), E && k.push(r(Object(_.e)(d))), (await Promise.all(k)).every(Boolean) || r(Object(h.f)({
							kind: M.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "3UWos1"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "mgOpG"
							}),
							buttonAction: Ze(e, t, n)
						}))
					}
				}, $e = e => async (t, n) => {
					if (await t(Xe(e))) return;
					const {
						params: s,
						queryParams: r
					} = e, o = s.subredditName || N.e;
					t(u.m({
						title: s.wikiPageName ? `${s.wikiPageName} - ${o}` : `wiki - ${o}`
					})), await t(Ze(s, r));
					const i = Object(F.C)(n(), {
							subredditName: o
						}),
						a = n();
					i && (a.sidebarPromotedPosts.firstFetch || window.addEventListener("load", () => {
						t(Object(p.b)(L.a.SUBREDDIT))
					}), t(Object(p.d)({
						isViewSafe: Object(R.a)([], [i])
					})))
				}
		},
		"./src/reddit/actions/pinnedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "i", (function() {
				return R
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/modal.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/constants/modals.ts"),
				c = n("./src/reddit/endpoints/post/index.tsx"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/profile.ts");
			const b = "PINNEDPOST__PINNED_POSTS_LOADED",
				f = Object(o.a)(b),
				h = "PINNEDPOST__PIN_POST_SUCCESS",
				_ = "PINNEDPOST__UNPIN_POST_SUCCESS",
				g = Object(o.a)(h),
				v = Object(o.a)(_),
				x = "PINNEDPOST__PIN_POST_PENDING",
				O = "PINNEDPOST__UNPIN_POST_PENDING",
				E = Object(o.a)(x),
				y = Object(o.a)(O),
				C = "PINNEDPOST__PIN_POST_FAILURE",
				j = "PINNEDPOST__UNPIN_POST_FAILURE",
				k = Object(o.a)(C),
				I = Object(o.a)(j),
				S = e => Object(a.f)({
					buttonAction: R(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "1O9LWh"
					}),
					kind: l.b.SuccessMod,
					text: s.fbt._("Post pinned to profile!", null, {
						hk: "1hbHLt"
					})
				}),
				w = (e, t) => Object(a.f)({
					buttonAction: R(e, !0),
					buttonText: s.fbt._("UNDO", null, {
						hk: "3YtcK2"
					}),
					kind: l.b.SuccessMod,
					text: t ? s.fbt._("Post unpinned, reload to see changes", null, {
						hk: "5FF1g"
					}) : s.fbt._("Post unpinned.", null, {
						hk: "2BgT0h"
					})
				}),
				T = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not pin post", null, {
						hk: "3uNHEh"
					})
				}),
				N = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("You can't pin a removed post", null, {
						hk: "3bdn2y"
					})
				}),
				P = () => Object(a.f)({
					kind: l.b.Error,
					text: s.fbt._("Could not unpin post", null, {
						hk: "o8HG0"
					})
				}),
				R = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return async (n, s, o) => {
						let {
							apiContext: a,
							gqlContext: l
						} = o;
						const b = s(),
							f = b.posts.models[e];
						if (!f) return;
						const h = !Object(m.s)(b, {
							postId: e
						});
						if (h && f.isRemoved) return n(N());
						const _ = f.author,
							x = Object(p.o)(b, _),
							[O, C, j, R, A] = h ? [E, g, k, S, T] : [y, v, I, w, P];
						if (h) {
							if (Object(m.P)(b, {
									profileName: _
								}).length >= r.hb) return void n(Object(i.i)(d.a.PINNED_POSTS_LIMIT_REACHED))
						}
						const M = Object(m.p)(b, e, _),
							L = !h && M;
						n(O({
							postId: e,
							profileId: x
						})), (Object(u.b)(b) ? await Object(c.i)(l(), e, h, !0) : await Object(c.t)(a(), e, h, !0)).ok ? (n(C({
							postId: e,
							profileId: x
						})), t || n(R(e, L))) : (n(j({
							postId: e,
							profileId: x
						})), n(A()))
					}
				}
		},
		"./src/reddit/actions/postCollection/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "t", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "s", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			})), n.d(t, "p", (function() {
				return x
			})), n.d(t, "q", (function() {
				return O
			})), n.d(t, "o", (function() {
				return E
			}));
			const s = "CREATE_COLLECTION_PENDING",
				r = "CREATE_COLLECTION_SUCCESS",
				o = "CREATE_COLLECTION_FAILED",
				i = "GET_SUBREDDIT_COLLECTION_SUCCESS",
				a = "REMOVE_POST_FROM_COLLECTION_SUCCESS",
				d = "ADD_POST_TO_COLLECTION_SUCCESS",
				c = "UPDATE_POST_WITH_COLLECTION_ID",
				l = "DELETE_COLLECTION_SUCCESS",
				u = "UPDATE_COLLECTION_PENDING",
				m = "UPDATE_COLLECTION_SUCCESS",
				p = "UPDATE_COLLECTION_FAILED",
				b = "UPDATE_COLLECTION_DESCRIPTION_PENDING",
				f = "UPDATE_COLLECTION_DESCRIPTION_SUCCESS",
				h = "UPDATE_COLLECTION_DESCRIPTION_FAILED",
				_ = "REORDER_COLLECTION_PENDING",
				g = "REORDER_COLLECTION_SUCCESS",
				v = "REORDER_COLLECTION_FAILED",
				x = "UPDATE_COLLECTION_LAYOUT_PENDING",
				O = "UPDATE_COLLECTION_LAYOUT_SUCCESS",
				E = "UPDATE_COLLECTION_LAYOUT_FAILED"
		},
		"./src/reddit/actions/postCollection/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			})), n.d(t, "e", (function() {
				return D
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "a", (function() {
				return G
			})), n.d(t, "c", (function() {
				return W
			})), n.d(t, "h", (function() {
				return Q
			})), n.d(t, "f", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return oe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/lib/filterQueryParams/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/post.ts"),
				d = n("./src/reddit/actions/postCollection/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/constants/history.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var f = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/add_post_to_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var h = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/create_collection.json`,
				method: u.ob.POST,
				data: {
					title: t,
					sr_fullname: n
				}
			});
			var _ = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/delete_collection.json`,
					method: u.ob.POST,
					data: {
						collection_id: t
					}
				}),
				g = n("./src/config.ts");
			var v = (e, t) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${g.a.gatewayUrl}/desktopapi/v1/subreddit_collections/${t}`,
				method: u.ob.GET
			});
			var x = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/remove_post_in_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_fullname: n
				}
			});
			var O = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_title.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					title: n
				}
			});
			var E = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/reorder_collection.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					link_ids: n.join(",")
				}
			});
			var y = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
				endpoint: `${e.apiUrl}/api/v1/collections/update_collection_description.json`,
				method: u.ob.POST,
				data: {
					collection_id: t,
					description: n
				}
			});
			var C = (e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
					endpoint: `${e.apiUrl}/api/v1/collections/update_collection_display_layout.json`,
					method: u.ob.POST,
					data: {
						collection_id: t,
						display_layout: n
					}
				}),
				j = n("./src/reddit/helpers/overlay/index.ts"),
				k = n("./src/reddit/helpers/path/index.ts"),
				I = n("./src/reddit/models/Toast/index.ts"),
				S = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				w = n("./src/reddit/selectors/postCollection.ts"),
				T = n("./src/reddit/selectors/posts.ts"),
				N = n("./src/reddit/selectors/subreddit.ts");
			const P = Object(i.a)(d.c),
				R = Object(i.a)(d.b),
				A = Object(i.a)(d.d),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(P());
					const i = await h(o(), e, t);
					let a;
					if (i.ok) {
						const e = s().meta,
							t = (e => ({
								author: e.author_name || void 0,
								createdAtUTC: e.created_at_utc,
								description: e.description,
								displayLayout: e.display_layout,
								id: e.collection_id,
								lastUpdateUTC: e.last_update_utc,
								permalink: e.permalink,
								postIds: e.link_ids,
								primaryPostId: e.primary_link_id || void 0,
								subredditId: e.subreddit_id,
								title: e.title
							}))(i.body);
						n(A({
							collection: t,
							meta: e
						})), a = t
					} else {
						const e = i.error;
						n(R(e))
					}
					return a
				}, L = Object(i.a)(d.f), D = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const i = n().postCollection.subredditToIds || {};
					if (Object.keys(i).length > 0) return;
					const a = await v(o(), e);
					a.ok ? t(L(a.body)) : t(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, F = Object(i.a)(d.g), U = (e, t, n) => async (r, o, i) => {
					let {
						apiContext: a
					} = i;
					if ((await x(a(), e, t)).ok) {
						const i = o(),
							a = Object(T.G)(i, {
								postId: t
							}),
							d = a && a.title || "",
							l = Object(w.q)(i, {
								collectionId: e
							}),
							u = (l && l.postIds && l.postIds.indexOf(t) || -1) - 1;
						if (r(F({
								collectionId: e,
								postId: t
							})), n && u >= 0) {
							const t = o(),
								n = Object(w.q)(t, {
									collectionId: e
								}),
								s = n && n.postIds && n.postIds[u] || "",
								i = Object(T.G)(t, {
									postId: s
								});
							i && i.permalink && r(Object(j.a)(i.permalink))
						}
						r(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Following post removed from collection successfully: {postTitle}", [s.fbt._param("postTitle", d)], {
								hk: "8e1lV"
							}),
							buttonText: s.fbt._("UNDO", null, {
								hk: "3KPLib"
							}),
							buttonAction: G(e, t)
						}))
					} else r(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, B = Object(i.a)(d.a), q = Object(i.a)(d.t), G = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r();
					if ((await f(i(), e, t)).ok) {
						n(B({
							collectionId: e,
							postId: t
						})), n(q({
							collectionId: e,
							postId: t
						}));
						const r = Object(T.G)(a, {
								postId: t
							}),
							o = Object(w.q)(a, {
								collectionId: e
							}),
							i = o && o.title || "";
						n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Success! You added a post to the collection: {title}", [s.fbt._param("title", i)], {
								hk: "3KNJWi"
							}),
							buttonText: s.fbt._("VIEW", null, {
								hk: "1SSkgL"
							}),
							buttonAction: Object(j.a)(r.permalink)
						}))
					} else n(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, H = Object(i.a)(d.e), W = (e, t) => async (n, i, a) => {
					let {
						apiContext: d
					} = a;
					const l = i();
					if ((await _(d(), e)).ok) {
						const {
							url: i
						} = l.platform.currentPage, a = Object(w.q)(l, {
							collectionId: e
						}), d = a && a.title || "", u = a && a.subredditId, m = u ? Object(N.c)(l, u) : "/";
						n(H({
							collectionId: e,
							collection: a
						})), n(t ? Object(r.c)(Object(o.a)(i, ["collection"])) : Object(r.b)(m)), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection deleted successfully: {title}", [s.fbt._param("title", d)], {
								hk: "4tcOKB"
							})
						}))
					} else n(Object(c.f)({
						kind: I.b.Error,
						text: s.fbt._("Something went wrong. Just don't panic.", null, {
							hk: "4Ck6Cm"
						})
					}))
				}, V = Object(i.a)(d.r), z = Object(i.a)(d.n), K = Object(i.a)(d.s), Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					n(V());
					const a = await O(i(), e, t);
					let d = !1;
					if (a.ok) n(K({
						collectionId: e,
						newTitle: t
					})), n(Object(c.f)({
						kind: I.b.SuccessMod,
						text: s.fbt._("Collection title updated successfully", null, {
							hk: "2hKzKl"
						})
					})), d = !0;
					else {
						const e = a.error;
						n(z(e)), n(Object(c.f)({
							kind: I.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))
					}
					return d
				}, Y = Object(i.a)(d.l), J = Object(i.a)(d.m), X = Object(i.a)(d.k), Z = e => async (t, n) => {
					const s = n();
					if (Object(S.b)(s) || Object(S.c)(s)) return void t(Object(a.ab)(Object(k.b)(e.permalink), e.id));
					const o = s.platform.currentPage.locationState;
					t(!(!o || !o[l.b.IsOverlay]) ? Object(j.a)(e.permalink) : Object(r.b)(Object(k.b)(e.permalink)))
				}, $ = Object(i.a)(d.i), ee = Object(i.a)(d.j), te = Object(i.a)(d.h), ne = Object(i.a)(d.p), se = Object(i.a)(d.o), re = Object(i.a)(d.q), oe = e => async t => {
					const n = [],
						{
							collectionId: r,
							description: o,
							displayLayout: i,
							postIds: a,
							title: d
						} = e;
					a && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n($());
						const a = await E(i(), e, t);
						let d = !1;
						return a.ok ? (n(ee({
							collectionId: e,
							postIds: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection order updated successfully", null, {
								hk: "4ccHEL"
							})
						})), d = !0) : (n(te({
							error: a.error
						})), n(Object(c.f)({
							kind: I.b.Error,
							text: s.fbt._("Something went wrong. Just don't panic.", null, {
								hk: "4Ck6Cm"
							})
						}))), d
					})(r, a))), d && n.push(t(Q(r, d))), void 0 !== o && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n(Y());
						const a = await y(i(), e, t);
						let d = !1;
						if (a.ok) n(J({
							collectionId: e,
							newDescription: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection description updated successfully", null, {
								hk: "1rIDCC"
							})
						})), d = !0;
						else {
							const e = a.error;
							n(X(e)), n(Object(c.f)({
								kind: I.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, o))), i && n.push(t(((e, t) => async (n, r, o) => {
						let {
							apiContext: i
						} = o;
						n(ne());
						const a = await C(i(), e, t);
						let d = !1;
						if (a.ok) n(re({
							collectionId: e,
							newLayout: t
						})), n(Object(c.f)({
							kind: I.b.SuccessMod,
							text: s.fbt._("Collection layout updated successfully", null, {
								hk: "1Rs19j"
							})
						})), d = !0;
						else {
							const e = a.error;
							n(se(e)), n(Object(c.f)({
								kind: I.b.Error,
								text: s.fbt._("Something went wrong. Just don't panic.", null, {
									hk: "4Ck6Cm"
								})
							}))
						}
						return d
					})(r, i)));
					let l = !0;
					return await Promise.all(n).then(e => {
						e.forEach(e => {
							e || (l = !1)
						})
					}), l
				}
		},
		"./src/reddit/actions/postCreation/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "K", (function() {
				return s
			})), n.d(t, "L", (function() {
				return r
			})), n.d(t, "l", (function() {
				return o
			})), n.d(t, "m", (function() {
				return i
			})), n.d(t, "x", (function() {
				return a
			})), n.d(t, "H", (function() {
				return d
			})), n.d(t, "I", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "G", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "Q", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "D", (function() {
				return f
			})), n.d(t, "s", (function() {
				return h
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "q", (function() {
				return k
			})), n.d(t, "S", (function() {
				return I
			})), n.d(t, "R", (function() {
				return S
			})), n.d(t, "T", (function() {
				return w
			})), n.d(t, "U", (function() {
				return T
			})), n.d(t, "V", (function() {
				return N
			})), n.d(t, "W", (function() {
				return P
			})), n.d(t, "X", (function() {
				return R
			})), n.d(t, "Y", (function() {
				return A
			})), n.d(t, "Z", (function() {
				return M
			})), n.d(t, "r", (function() {
				return L
			})), n.d(t, "E", (function() {
				return D
			})), n.d(t, "u", (function() {
				return F
			})), n.d(t, "v", (function() {
				return U
			})), n.d(t, "t", (function() {
				return B
			})), n.d(t, "w", (function() {
				return q
			})), n.d(t, "P", (function() {
				return G
			})), n.d(t, "o", (function() {
				return H
			})), n.d(t, "y", (function() {
				return W
			})), n.d(t, "db", (function() {
				return V
			})), n.d(t, "J", (function() {
				return z
			})), n.d(t, "a", (function() {
				return K
			})), n.d(t, "F", (function() {
				return Q
			})), n.d(t, "N", (function() {
				return Y
			})), n.d(t, "O", (function() {
				return J
			})), n.d(t, "M", (function() {
				return X
			})), n.d(t, "ab", (function() {
				return Z
			})), n.d(t, "C", (function() {
				return $
			})), n.d(t, "B", (function() {
				return ee
			})), n.d(t, "z", (function() {
				return te
			})), n.d(t, "A", (function() {
				return ne
			})), n.d(t, "cb", (function() {
				return se
			})), n.d(t, "bb", (function() {
				return re
			}));
			const s = "SUBMIT_VALIDATION_FIELD_HAS_ERROR",
				r = "SUBMIT_VALIDATION_FIELD_IS_VALID",
				o = "POST_CREATION_EDIT_COMPLETE",
				i = "POST_CREATION_EDIT_FAILED",
				a = "POST_CREATION_PENDING_EDIT",
				d = "POST_CREATION_START_EDITING_POST",
				c = "POST_CREATION_STOP_EDITING_POST",
				l = "EDITOR_CONTENT_KEY__NEW_DRAFT",
				u = "STARTED_CONVERTING_EDITOR_CONTENT",
				m = "FINISHED_CONVERTING_EDITOR_CONTENT",
				p = "POST_CREATION__TOGGLE_EDITOR_MODE",
				b = "POST_CREATION__ERRORS_NO_LONGER_VALID",
				f = "POST_TITLE_FETCHED",
				h = "INITIALIZE_EDITOR_MODE",
				_ = "POST_CREATION__CHANGE_FLAIR",
				g = "POST_CREATION__CHANGE_EVENT_SCHEDULE",
				v = "POST_CREATION__CHANGE_LINK_BODY",
				x = "POST_CREATION__CHANGE_MARKDOWN_BODY",
				O = "POST_CREATION__CHANGE_MEDIA_BODY",
				E = "POST_CREATION__CHANGE_RECAPTCHA",
				y = "POST_CREATION__CHANGE_RTE_STATE",
				C = "POST_CREATION__CHANGE_SUBMISSION_TYPE",
				j = "POST_CREATION__CHANGE_TITLE",
				k = "POST_CREATION__GOV_TYPE_CHANGED",
				I = "POST_CREATION__TOGGLE_IS_CHAT_POST",
				S = "POST_CREATION__TOGGLE_IS_CHANGED",
				w = "POST_CREATION__TOGGLE_IS_GOV",
				T = "POST_CREATION__TOGGLE_IS_NSFW",
				N = "POST_CREATION__TOGGLE_IS_OC",
				P = "POST_CREATION__TOGGLE_IS_POLL",
				R = "POST_CREATION__TOGGLE_IS_SPOILER",
				A = "POST_CREATION__TOGGLE_POST_TO_TWITTER",
				M = "POST_CREATION__TOGGLE_SEND_REPLIES",
				L = "POST_CREATION__INITIALIZE_CROSSPOST_MODE",
				D = "POST_CREATION__RESET_FORM",
				F = "POST_CREATION__MEDIA_UPLOAD_PENDING",
				U = "POST_CREATION__MEDIA_UPLOAD_SUCCEEDED",
				B = "POST_CREATION__MEDIA_UPLOAD_FAILED",
				q = "POST_CREATION__PENDING",
				G = "POST_CREATION__SUCCEEDED",
				H = "POST_CREATION__FAILED",
				W = "POST_CREATION__POLL_FAILED",
				V = "POST_CREATION__VALIDATION_FAILED",
				z = "POST_CREATION__SUBMIT_VALIDATION_FAILED",
				K = "POST_CREATION__CAPTCHA_REQUIRED",
				Q = "POST_CREATION__SET_SUBMIT_MODE",
				Y = "POST_CREATION__SUBREDDIT_CHANGE_PENDING",
				J = "POST_CREATION__SUBREDDIT_WILL_CHANGE",
				X = "POST_CREATION__SUBREDDIT_CHANGE_CANCELED",
				Z = "POST_CREATION__UPDATE_SCHEDULED_POST_ADVANCED_SETTINGS",
				$ = "POST_CREATION__SUBREDDIT_RECOMMENDATION_PENDING",
				ee = "POST_CREATION__SUBREDDIT_RECOMMENDATION_LOADED",
				te = "POST_CREATION__SUBREDDIT_RECOMMENDATION_FAILED",
				ne = "POST_CREATION__SUB_REC_IS_INPUT_CHANGED",
				se = "POST_CREATION__UPDATE_TOURNAMENT",
				re = "POST_CREATION__UPDATE_TALK"
		},
		"./src/reddit/actions/postCreation/editing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return A
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "c", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				m = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				p = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const b = e => !(!e.document || !e.document.length),
				f = e => ({
					text: null,
					richtext_json: JSON.stringify({
						document: e.document
					})
				}),
				h = e => ({
					text: e.markdown,
					return_rtjson: !0
				}),
				_ = e => ({
					api_type: "json",
					show_error_list: !0,
					thing_id: e.post.id,
					validate_on_submit: !0,
					...b(e) ? f(e) : h(e)
				});
			var g = (e, t) => Object(d.a)(Object(c.a)(e, [l.a]), {
					endpoint: Object(p.a)(Object(u.a)(`${e.apiUrl}/api/editusertext`)),
					method: a.ob.POST,
					data: _(t)
				}).then(m.b),
				v = n("./src/reddit/helpers/overlay/index.ts"),
				x = n("./src/reddit/helpers/r2/normalizePostFromR2/index.ts"),
				O = n("./src/reddit/helpers/trackers/lightbox.ts"),
				E = n("./src/reddit/helpers/trackers/post.ts"),
				y = n("./src/reddit/helpers/trackers/postComposer.ts"),
				C = n("./src/reddit/models/Media/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				k = n("./src/reddit/models/Toast/index.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/actions/postCreation/constants.ts"),
				w = n("./src/reddit/actions/postCreation/general.ts");
			const T = Object(r.a)(S.l),
				N = Object(r.a)(S.m),
				P = Object(r.a)(S.x),
				R = Object(r.a)(S.H),
				A = Object(r.a)(S.I),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(I.G)(i, {
							postId: e
						});
					t ? (n(Object(v.a)(a.permalink)), Object(O.e)(e, "edit")(i)) : Object(E.e)(e, "edit")(i);
					const {
						media: d
					} = a;
					if (!d) return;
					let c, l = j.i.RICH_TEXT,
						u = "";
					d.type === C.o.TEXT ? (l = j.i.MARKDOWN, u = d.content) : d.type === C.o.RTJSON && (u = (l = d.rteMode || j.i.RICH_TEXT) === j.i.MARKDOWN ? d.markdownContent : d.richtextContent, c = d.mediaMetadata || void 0), n(R({
						editorMode: l,
						mediaMetadata: c,
						postContent: u,
						postId: e
					}))
				}, L = e => async (t, n, r) => {
					let {
						apiContext: a
					} = r;
					const {
						post: d
					} = e, c = !d.media || "rtjson" !== d.media.type && "text" !== d.media.type ? "" : d.media.rteMode;
					y.E(n(), Object(w.o)(c)), t(P(d.id));
					const l = await g(a(), e),
						u = !1 === l.body.success;
					if (t(T(d.id)), l.ok && !u) {
						t(Object(i.f)({
							kind: k.b.SuccessCommunity,
							text: s.fbt._("Post successfully edited", null, {
								hk: "xej5K"
							})
						})), t(A(d.id));
						const e = Object(x.a)(l.body);
						t(Object(o.R)({
							[d.id]: e
						}))
					} else t(N(l.error))
				}
		},
		"./src/reddit/actions/postCreation/editorContent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return _
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/reddit/endpoints/post/convert.ts"),
				a = n("./src/reddit/helpers/localStorage/index.ts"),
				d = n("./src/reddit/helpers/trackers/postComposer.ts"),
				c = n("./src/reddit/models/PostCreationForm/index.ts"),
				l = n("./src/reddit/models/RichTextJson/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/actions/postCreation/constants.ts");
			const p = Object(r.a)(m.G),
				b = Object(r.a)(m.p),
				f = Object(r.a)(m.Q),
				h = (e, t, n) => async (r, a, h) => {
					let {
						apiContext: g
					} = h;
					d.m(a(), t);
					const v = t === c.i.MARKDOWN,
						x = t === c.i.RICH_TEXT,
						O = m.k;
					if (v && Object(l.H)(n)) return r(f({
						editorKey: e,
						editorMode: c.i.MARKDOWN,
						content: ""
					})), void r(_(t));
					if (x && !n) return r(f({
						editorKey: e,
						editorMode: c.i.RICH_TEXT,
						content: l.i
					})), void r(_(t));
					r(p(O));
					const E = await Object(i.a)(g(), t, v ? JSON.stringify(n) : n);
					E.ok ? (r(b(O)), r(f({
						editorKey: e,
						editorMode: t,
						content: E.body.output
					})), r(_(t))) : (r(b(O)), r(Object(o.f)({
						duration: o.a,
						kind: u.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "3UtpxU"
						})
					})))
				}, _ = e => async (t, n) => {
					const r = Object(a.l)();
					if (r >= 3) return;
					const i = n().user.prefs.useMarkdown ? c.i.MARKDOWN : c.i.RICH_TEXT;
					if (e === i) return;
					const d = e === c.i.MARKDOWN ? s.fbt._("You can set Markdown as the default editor mode in the settings", null, {
						hk: "yvN18"
					}) : s.fbt._("You can set Fancy Pants as the default editor mode in the settings", null, {
						hk: "4kQi5k"
					});
					t(Object(o.f)({
						buttonAction: async () => {
							window.open("/settings/feed")
						},
						buttonText: s.fbt._("Open Settings", null, {
							hk: "1CKz9o"
						}),
						kind: u.b.SuccessCommunity,
						text: d
					})), Object(a.wb)(r + 1)
				}
		},
		"./src/reddit/actions/postCreation/general.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return I
			})), n.d(t, "o", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "d", (function() {
				return A
			})), n.d(t, "f", (function() {
				return M
			})), n.d(t, "e", (function() {
				return L
			})), n.d(t, "g", (function() {
				return D
			})), n.d(t, "h", (function() {
				return F
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "u", (function() {
				return B
			})), n.d(t, "t", (function() {
				return q
			})), n.d(t, "v", (function() {
				return G
			})), n.d(t, "w", (function() {
				return H
			})), n.d(t, "x", (function() {
				return W
			})), n.d(t, "y", (function() {
				return V
			})), n.d(t, "A", (function() {
				return z
			})), n.d(t, "B", (function() {
				return K
			})), n.d(t, "E", (function() {
				return Q
			})), n.d(t, "D", (function() {
				return Y
			})), n.d(t, "C", (function() {
				return J
			})), n.d(t, "m", (function() {
				return X
			})), n.d(t, "r", (function() {
				return $
			})), n.d(t, "s", (function() {
				return ee
			})), n.d(t, "q", (function() {
				return te
			})), n.d(t, "z", (function() {
				return ne
			})), n.d(t, "p", (function() {
				return se
			})), n.d(t, "n", (function() {
				return re
			})), n.d(t, "k", (function() {
				return le
			})), n.d(t, "j", (function() {
				return pe
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/debounce.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-redux/es/index.js"),
				i = n("./src/lib/isUrl/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/contexts/PageLayer/index.tsx"),
				l = n("./src/reddit/endpoints/post/index.tsx"),
				u = n("./src/redditGQL/operations/WhereToPostSubRec.json"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/redditGQL/operations/OpenAISubRecWithDetail.json");
			var b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				_ = n("./src/reddit/helpers/trackers/postComposer.ts"),
				g = n("./src/reddit/models/PostCreationForm/index.ts"),
				v = n("./src/reddit/models/Subreddit/index.ts"),
				x = n("./src/reddit/routes/postCreation/constants.ts"),
				O = n("./src/reddit/selectors/activeModalId.ts"),
				E = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				y = n("./src/reddit/selectors/postCollection.ts"),
				C = n("./src/reddit/selectors/postCreations.ts"),
				j = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				k = n("./src/reddit/actions/postCreation/constants.ts");
			const I = Object(a.a)(k.n),
				S = Object(a.a)(k.D),
				w = (Object(a.a)(k.s), e => {
					switch (e) {
						case "markdown":
							return "self";
						case "richtext":
						case "richText":
							return "self";
						case "media":
							return "media";
						default:
							return "link"
					}
				}),
				T = Object(a.a)(k.b),
				N = Object(a.a)(k.c),
				P = Object(a.a)(k.d),
				R = Object(a.a)(k.e),
				A = Object(a.a)(k.f),
				M = Object(a.a)(k.g),
				L = Object(a.a)(k.h),
				D = Object(a.a)(k.i),
				F = Object(a.a)(k.j),
				U = Object(a.a)(k.q),
				B = Object(a.a)(k.S),
				q = Object(a.a)(k.R),
				G = (Object(a.a)(k.T), Object(a.a)(k.U)),
				H = Object(a.a)(k.V),
				W = Object(a.a)(k.W),
				V = Object(a.a)(k.X),
				z = Object(a.a)(k.Y),
				K = Object(a.a)(k.Z),
				Q = Object(a.a)(k.cb),
				Y = Object(a.a)(k.bb),
				J = Object(a.a)(k.ab),
				X = Object(a.a)(k.r),
				Z = r()((e, t) => {
					Object(i.a)(t) && e((e => async (t, n, s) => {
						let {
							apiContext: r
						} = s;
						const o = await Object(l.e)(r(), e);
						o.ok && o.body && o.body.json && o.body.json.data && t(S(o.body.json.data))
					})(t))
				}, 500),
				$ = e => async t => {
					t(P(e)), Z(t, e)
				}, ee = Object(a.a)(k.E), te = (e, t) => async (n, s) => {
					n(ee()), n(e ? Object(o.b)(x.b) : Object(o.b)(Object(C.db)(s(), {
						pageLayer: t
					})))
				}, ne = e => async t => {
					t(d.i(e))
				}, se = e => async (t, n) => {
					const s = n(),
						r = Object(c.I)(e),
						o = Object(C.H)(s);
					if (r && o) {
						Object(O.a)(s) !== g.d && t(ne(g.d))
					} else t(te(!1, e))
				}, re = e => async (t, n) => {
					const s = n();
					Object(y.m)(s, {
						subredditId: e
					}) ? t(d.i(g.a)) : t(d.i(g.c))
				}, oe = Object(a.a)(k.B), ie = Object(a.a)(k.C), ae = Object(a.a)(k.z), de = Object(a.a)(k.A), ce = e => async (t, n) => {
					Object(j.e)(n()) !== e && t(de({
						isChanged: e
					}))
				}, le = () => async (e, t) => {
					const n = t();
					if (Object(j.g)(n))
						if (Object(j.h)(n)) {
							const t = n.creations.formData.title,
								s = Object(j.l)(n),
								r = Object(j.k)(n),
								o = Object(j.b)(n);
							e(pe(t, s, r, void 0, o))
						} else Object(j.j)(n) && !Object(j.d)(n) && e(be())
				}, ue = ["torrents", "IsolatedVocals"], me = ["askreddit", "teenagers"], pe = (e, t, n, s, r) => async (o, i, a) => {
					let {
						apiContext: d,
						gqlContext: c
					} = a;
					const l = i();
					if (Object(j.i)(l)) return;
					o(ie());
					const u = Object(b.c)(b.a.PostComposer),
						g = await ((e, t, n, s, r, o) => Object(m.a)(e, {
							...p,
							variables: {
								title: t,
								body: n,
								link: s,
								correlationId: r,
								confidenceWeight: o
							}
						}))(c(), e, t, n, u, r),
						x = {};
					let O = {};
					const y = {},
						C = {},
						k = [];
					if (!g.body || !g.ok) return o(ce(!1)), void o(ae()); {
						const {
							data: e
						} = g.body, {
							subredditSuggestions: t
						} = e.openaiSubredditSuggestionsDetailed;
						let n = t.map(e => {
							const {
								subredditInfo: t,
								cVal: n,
								sVal: s
							} = e, r = t.name;
							return r && (C[r] = {
								confidence: n,
								succRate: s
							}), t
						}).filter(e => !ue.includes(e.name));
						const r = (n = s ? n.filter(e => !s(e)) : n).slice(0, j.a),
							a = r.map(e => {
								const t = e.name;
								return k.push(t), t
							});
						if (Object(E.b)(l) && (e => {
								const t = e.map(e => e.toLowerCase());
								let n = !1;
								return me.forEach(e => {
									t.includes(e) && (n = !0)
								}), n
							})(a)) return o(ce(!1)), o(oe({
							subreddits: {},
							subredditsAboutInfo: {},
							unavailableSubreddits: {},
							recSubsDict: {},
							recSubsOrder: []
						})), Object(_.G)(i()), void o(ae());
						r.forEach(e => {
							if (Object(v.k)(e)) {
								const t = Object(h.f)(e);
								y[t.id] = t
							} else if (e && Object.keys(e).length > 0) {
								const t = Object(h.a)(e),
									n = Object(f.a)(e);
								x[t.id] = t, O = {
									...O,
									...n
								}
							}
						})
					}
					o(ce(!1)), o(oe({
						subreddits: x,
						subredditsAboutInfo: O,
						unavailableSubreddits: y,
						recSubsDict: C,
						recSubsOrder: k
					})), 0 === Object(j.c)(i()).length && o(ae())
				}, be = () => async (e, t, n) => {
					let {
						apiContext: s,
						gqlContext: r
					} = n;
					const o = t();
					if (Object(j.i)(o)) return;
					e(ie());
					const i = {};
					let a = {};
					const d = {},
						c = {},
						l = [],
						p = await (e => Object(m.a)(e, {
							...u,
							variables: {
								recentSubreddits: []
							}
						}))(r());
					if (!p.ok || !p.body) return e(ae()), void e(ce(!1)); {
						const {
							data: e
						} = p.body;
						(e.whereToPostSuggestions.edges || []).forEach((e, t) => {
							if (t >= j.a) return;
							const n = e.node.subredditInfo;
							if (Object(v.k)(n)) {
								const e = Object(h.f)(n);
								d[e.id] = e
							} else if (n && Object.keys(n).length > 0) {
								const e = Object(h.a)(n),
									t = Object(f.a)(n);
								c[n.name] = {}, l.push(n.name), i[e.id] = e, a = {
									...a,
									...t
								}
							}
						})
					}
					e(ce(!1)), e(oe({
						subreddits: i,
						subredditsAboutInfo: a,
						unavailableSubreddits: d,
						recSubsDict: c,
						recSubsOrder: l
					})), 0 === Object(j.c)(t()).length && e(ae())
				}
		},
		"./src/reddit/actions/postCreation/mediaUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return R
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "c", (function() {
				return F
			})), n.d(t, "e", (function() {
				return U
			})), n.d(t, "d", (function() {
				return B
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/formatApiError/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/actions/upload.ts"),
				l = n("./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts"),
				u = n("./src/lib/makeApiRequest/index.ts"),
				m = n("./src/lib/makeGqlRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts"),
				f = n("./src/redditGQL/operations/CreateMediaUploadLease.json");
			var h = n("./src/reddit/helpers/correlationIdTracker.ts"),
				_ = n("./src/reddit/helpers/imagePreview/index.ts"),
				g = n("./src/reddit/helpers/media/index.ts"),
				v = n("./src/reddit/models/Upload/index.ts"),
				x = n("./src/reddit/selectors/telemetry.ts"),
				O = n("./src/telemetry/index.ts");
			const E = e => ({
				...x.o(e),
				screen: x.cb(e),
				profile: x.T(e),
				subreddit: x.kb(e)
			});
			var y = n("./src/reddit/helpers/trackers/postComposer.ts"),
				C = n("./src/reddit/models/PostCreationForm/index.ts"),
				j = n("./src/reddit/models/Toast/index.ts"),
				k = n("./src/reddit/selectors/postCreations.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts"),
				S = n("./src/reddit/actions/postCreation/constants.ts"),
				w = n("./src/reddit/actions/postCreation/general.ts");
			const T = Object(a.a)(S.u),
				N = Object(a.a)(S.v),
				P = Object(a.a)(S.t),
				R = e => async (t, n) => {
					t(T());
					const s = e.map(e => {
						let {
							url: n,
							uploadKey: s
						} = e;
						const r = Object(g.b)(Object(g.d)(n), "poster.png");
						return t(D(r, s, !0))
					});
					await Promise.all(s);
					const r = n().uploads,
						o = e.map(e => {
							let {
								uploadKey: t
							} = e;
							return r[t]
						}).find(e => e.status !== v.a.SUCCESS);
					t(o ? P(o.error) : N())
				}, A = (e, t) => ({
					error: t ? {
						type: e,
						fields: [{
							field: "",
							msg: t
						}]
					} : {
						type: e
					}
				});
			const M = "RTE",
				L = "GALLERY",
				D = (e, t, n, r, i, a, l) => async (C, S, w) => {
					let {
						apiContext: T,
						gqlContext: N
					} = w;
					const P = Object(k.h)(S()),
						R = Date.now();
					let M = null,
						L = !1,
						D = !1,
						F = !1;
					const U = e => {
						if (!F && r && L) {
							F = !0;
							const n = S(),
								s = Date.now() - R,
								o = Object(h.c)(h.a.PostComposer);
							D ? (async e => {
								let {
									state: t,
									uploadKey: n,
									assetId: s,
									isCanceled: r,
									fileSource: o,
									uploadDuration: i,
									correlationId: a
								} = e;
								const d = t.uploads[n],
									c = r || d.status === v.a.CANCELED,
									{
										file: l,
										url: u,
										metadata: m,
										error: p
									} = d,
									b = m.mimetype || l.type,
									f = b.startsWith("video/"),
									h = d.status === v.a.SUCCESS;
								let _ = "";
								p ? _ = JSON.stringify(p) : c && (_ = "canceled");
								const g = {
									width: m.width,
									height: m.height,
									duration: m.videoDuration && Math.round(1e3 * m.videoDuration)
								};
								Object(O.a)({
									source: "post_composer",
									action: "upload",
									correlationId: a,
									noun: f ? "video" : "image",
									...E(t),
									actionInfo: {
										...x.d(t),
										success: h,
										..._ ? {
											reason: _
										} : {}
									},
									media: {
										mimetype: b,
										uploadDuration: i,
										source: o,
										fileName: l.name,
										size: l.size,
										type: f ? "video" : "image",
										...s ? {
											id: s
										} : {},
										...u ? {
											url: u
										} : {},
										...g
									}
								})
							})({
								state: n,
								uploadKey: t,
								assetId: M,
								isCanceled: e,
								fileSource: r,
								uploadDuration: s,
								correlationId: o
							}) : y.D(n, t)
						}
					};
					return await C(Object(c.l)(e, t, async h => {
						var v, x, O, E;
						L = !0, Object(c.k)(h.id, () => {
							U(!0)
						});
						const {
							error: y,
							metadata: k
						} = await async function(e, t, n, r) {
							const i = n && n.allowedPostTypes,
								a = n && n.name,
								d = await Object(g.h)(e) || e.type,
								c = Object(g.c)(e) || void 0;
							if (!c) return A("UNSUPPORTED_BROWSER");
							const l = {
								localUrl: c,
								mimetype: d,
								size: e.size
							};
							if (!d || !Object(g.k)(d)) return {
								error: {
									type: o.Y
								}
							};
							if (d.startsWith("image/")) {
								if (t && i && !i.images) {
									const e = s.fbt._("Images are not allowed in r/{subredditName}", [s.fbt._param("subredditName", a)], {
										hk: "3C2E7Q"
									});
									return A(o.Y, e)
								}
								if ("image/gif" === d) {
									if (e.size > o.eb) return A(o.O)
								} else if (e.size > o.gb) return A(o.W);
								const n = await Object(_.a)(c);
								if (r && (n.width < r || n.height < r)) {
									const e = s.fbt._("Image must be {min_image_width}x{min_image_height} pixels or larger.", [s.fbt._param("min_image_width", r.toString()), s.fbt._param("min_image_height", r.toString())], {
										hk: "2WFKgs"
									});
									return A(o.V, e)
								}
								l.width = n.width, l.height = n.height
							} else if (d.startsWith("video/")) {
								if (e.size > o.kb) return A(o.vc);
								let t;
								try {
									t = await Object(g.j)(c, !0)
								} catch (u) {
									return A(o.Y)
								}
								if (i) {
									const {
										videos: e,
										images: n
									} = i;
									if (n && !e && t.duration > o.lb) {
										const e = s.fbt._("Sorry, r/{subredditName} doesn't allow videos. Please upload a video less than 60 seconds to convert to animated GIF.", [s.fbt._param("subredditName", a)], {
											hk: "46ULiz"
										});
										return A(o.Y, e)
									}
									if (!n && !e) {
										const e = s.fbt._("Videos are not allowed in r/{subredditName}", [s.fbt._param("subredditName", a)], {
											hk: "4uTUZb"
										});
										return A(o.Y, e)
									}
								}
								if (t.duration > o.jb) {
									const e = s.fbt._("Video is too long. Maximum video length is {duration} minutes.", [s.fbt._param("duration", (o.jb / 60).toString())], {
										hk: "20nB6Q"
									});
									return A(o.Y, e)
								}
								if (t.duration < o.rb) {
									const e = s.fbt._("Video is too short. Minimum video length is {duration} seconds.", [s.fbt._param("duration", o.rb.toString())], {
										hk: "49PSW8"
									});
									return A(o.Y, e)
								}
								if (0 === t.height || 0 === t.width) {
									const e = s.fbt._("Your browser does not support the video codec used for this video. Please try using a different video codec.", null, {
										hk: "1AC0mg"
									});
									return A(o.Y, e)
								}
								if (t.height < o.sb || t.width < o.tb) {
									const e = s.fbt._("Videos must be {min_video_width}x{min_video_height} pixels or larger.", [s.fbt._param("min_video_width", o.tb.toString()), s.fbt._param("min_video_height", o.sb.toString())], {
										hk: "2HSUGl"
									});
									return A(o.Y, e)
								}
								if (e.size / t.duration < o.qb) {
									const e = s.fbt._("Videos must have a bitrate of {min_bitrate}KB/s or larger.", [s.fbt._param("min_bitrate", (o.qb / o.Z).toString())], {
										hk: "1ehgDE"
									});
									return A(o.Y, e)
								}
								l.height = t.height, l.width = t.width, l.videoDuration = t.duration, l.videoFirstFrameUrl = t.firstFrame.dataUrl
							}
							return {
								metadata: l
							}
						}(e, n, P, l);
						if (y || !k) return {
							error: y
						};
						if (C(Object(c.m)({
								key: t,
								metadata: {
									fileSource: r,
									...k
								}
							})), D = !0, i && i(), a) {
							const e = k.mimetype,
								t = e && o.T[e];
							if (e && t) {
								const e = await (async (e, t) => {
									return await Object(m.a)(e, {
										...f,
										variables: {
											input: {
												mimetype: t
											}
										}
									})
								})(N(), t);
								if (e.ok) {
									const t = e.body,
										n = (null === (v = t.data.createMediaUploadLease) || void 0 === v ? void 0 : v.uploadLease.uploadLeaseUrl) || "",
										s = Object(I.a)({
											uploadLeaseUrl: n,
											uploadLeaseHeaders: null === (x = t.data.createMediaUploadLease) || void 0 === x ? void 0 : x.uploadLease.uploadLeaseHeaders
										});
									return M = (null === (O = t.data.createMediaUploadLease) || void 0 === O ? void 0 : O.mediaId) || null, {
										uploadLease: s
									}
								} {
									const t = null === (E = e.body.data.createMediaUploadLease) || void 0 === E ? void 0 : E.errors;
									let n = null;
									return t && (n = {
										fields: [{
											field: t[0].__typename || "",
											msg: t[0].message
										}],
										type: t[0].__typename || ""
									}), {
										error: n || void 0
									}
								}
							}
							return C(Object(d.f)({
								kind: j.b.Error,
								text: s.fbt._("Only .jpeg and .png image types are are allowed", null, {
									hk: "30Ms4V"
								}),
								duration: 6e3
							})), {
								error: void 0
							}
						}
						const S = e.name,
							w = await (async (e, t, n) => Object(u.a)(Object(p.a)(e, [b.a]), {
								endpoint: `${e.apiUrl}/api/media/asset.json`,
								method: o.ob.POST,
								data: {
									filepath: t,
									mimetype: n
								}
							}))(T(), S, k.mimetype);
						return w.ok ? (M = w.body.asset.asset_id, {
							uploadLease: w.body.args
						}) : {
							error: w.error || void 0
						}
					}, !0)), U(!1), S().uploads[t] || null
				}, F = (e, t) => async (n, s) => {
					const r = s().uploads[e];
					r && !Object(v.c)(r) && await n(D(r.file, r.key, t, r.metadata.fileSource, void 0))
				}, U = (e, t, n, o, a, c) => async (l, u) => {
					const m = e.map((e, s) => new Promise(async s => {
							const i = Object(v.d)(n, Object(r.a)().slice(-6));
							await l(D(e, i, o, t, () => s({
								uploadKey: i,
								isValid: !0
							}), a, c)), s({
								uploadKey: i,
								isValid: !1
							})
						})),
						p = await Promise.all(m),
						b = p.map(e => e.uploadKey);
					return l(function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
						return async (n, r) => {
							const {
								uploads: o
							} = r(), a = e.map(e => o[e]).filter(e => e.status === v.a.FAILED && !e.metadata.mimetype).map(e => e.error), c = a.length > t ? t - 1 : a.length, l = a.length - c;
							a.slice(0, c).forEach(e => n(Object(d.f)({
								duration: d.a,
								kind: j.b.Error,
								text: Object(i.a)(e)
							}))), l > 0 && n(Object(d.f)({
								duration: d.a,
								kind: j.b.Error,
								text: s.fbt._({
									"*": "Couldn't add {number} more files",
									_1: "Couldn't add 1 more file"
								}, [s.fbt._plural(l, "number")], {
									hk: "2fQwvl"
								})
							}))
						}
					}(b)), p.filter(e => e.isValid).map(e => e.uploadKey)
				}, B = (e, t) => async (n, r) => {
					const o = r(),
						i = Object(k.X)(o),
						{
							items: a
						} = i,
						u = !a.length && 1 === e.length,
						m = Object(k.O)(o) && !u;
					let p = !1,
						b = e;
					if (m) {
						if (Object(C.x)(i)) return void n(Object(d.f)({
							kind: j.b.Error,
							text: s.fbt._("Please remove the existing video first. Videos aren't supported within galleries yet.", null, {
								hk: "3lGxp4"
							})
						}));
						b.some(e => Object(g.n)(e.type)) && n(Object(d.f)({
							duration: d.a,
							kind: j.b.Error,
							text: s.fbt._("Videos aren’t supported within galleries...yet", null, {
								hk: "9Cl20"
							})
						})), b = b.filter(e => Object(g.m)(e.type));
						const e = Math.max(0, l.b - a.length);
						b.length > e && (n(Object(d.f)({
							kind: j.b.Error,
							text: s.fbt._("You have hit the limit of {images_limit} images", [s.fbt._param("images_limit", `${l.b}`)], {
								hk: "6M4kX"
							})
						})), b = b.slice(0, e))
					} else b = b.slice(0, 1), p = !0, n(Object(c.j)(L, !0));
					const f = await n(U(b, t, L, !0));
					if (!f.length) return;
					const h = f.map(e => ({
							uploadKey: e,
							caption: "",
							url: ""
						})),
						_ = 0 === a.length;
					n(Object(w.d)({
						...i,
						items: p ? h : [...a, ...h],
						selectedKey: _ ? f[0] : f[f.length - 1]
					}))
				}
		},
		"./src/reddit/actions/postCreation/submit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return D
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "e", (function() {
				return G
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "d", (function() {
				return X
			})), n.d(t, "a", (function() {
				return Z
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/reddit/actions/crosspostSubredditRec/index.ts"),
				a = n("./src/reddit/actions/governance/index.ts"),
				d = n("./src/reddit/actions/pages/subreddit.ts"),
				c = n("./src/reddit/actions/postDraft.ts"),
				l = n("./src/reddit/actions/scheduledPosts/index.ts"),
				u = n("./src/reddit/actions/urlRequested.ts"),
				m = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				p = n("./src/config.ts"),
				b = n("./src/lib/convertToCamelCase/index.ts"),
				f = n("./src/lib/makeApiRequest/index.ts"),
				h = n("./src/reddit/endpoints/post/create.ts");
			var _ = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				g = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				v = n("./src/reddit/featureFlags/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				O = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				C = n("./src/reddit/models/Poll/index.ts"),
				j = n("./src/reddit/models/PostCreationForm/index.ts"),
				k = n("./src/reddit/models/User/index.ts"),
				I = n("./src/reddit/selectors/experiments/crosspostRecommendations.ts"),
				S = n("./src/reddit/selectors/postCreations.ts"),
				w = n("./src/reddit/selectors/postDraft.ts"),
				T = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/models/Post/index.ts"),
				R = n("./src/reddit/models/ScheduledPost/index.ts"),
				A = n("./src/reddit/actions/postCreation/constants.ts"),
				M = n("./src/reddit/actions/postCreation/general.ts"),
				L = n("./src/reddit/actions/postCreation/mediaUpload.ts");
			const D = Object(r.a)(A.w),
				F = Object(r.a)(A.P),
				U = Object(r.a)(A.o),
				B = Object(r.a)(A.y),
				q = Object(r.a)(A.db),
				G = Object(r.a)(A.J),
				H = Object(r.a)(A.a),
				W = Object(r.a)(A.F),
				V = e => `/r/${e}/about/${R.s}`,
				z = (e, t) => {
					const n = e || {
							duration: s.E,
							options: []
						},
						{
							govType: r,
							newSubreddit: o,
							newTopMod: i
						} = Object(S.u)(t),
						a = {
							...n
						};
					return r && (a.type = r), a.type === C.a.ReplaceTopMod ? (a.params = {
						userName: i
					}, a.options = C.f[C.a.ReplaceTopMod]()) : a.type === C.a.Spinoff ? (a.params = {
						subreddit: o
					}, a.options = C.f[C.a.Spinoff](o)) : a.options = a.options.map(e => ({
						text: e.text.trim()
					})).filter(e => !!e.text), a
				},
				K = e => {
					const t = e.uploads,
						n = Object(S.X)(e),
						r = Object(S.a)(e),
						o = Object(S.jb)(e);
					if (r === s.bc.POST) return m.a.getPendingThumbnailUploads(o, t);
					if (r === s.bc.MEDIA && n && n.items.length) {
						const {
							video: e
						} = n.items[0];
						if (e && e.thumbnail && !t[j.n]) return [{
							...e.thumbnail,
							uploadKey: j.n
						}]
					}
				},
				Q = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o, a = r();
					const {
						pending: d
					} = a.creations.api.post.submit, l = Object(w.g)(a);
					if (d || l) return;
					n(W(e)), a = r();
					const u = Object(S.a)(a),
						m = v.d.rteVideoPoster(a),
						p = K(a),
						b = u === s.bc.MEDIA;
					p && (m || b) && (await n(L.f(p)), K(r())) || (e === j.r.Draft ? await n(Object(c.r)(t.draftId)) : e === j.r.ScheduledPost && Object(T.r)(a) ? await n(Y(t)) : e === j.r.ScheduledPost ? await n(J(t)) : await n(X(t)))
				}, Y = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const i = n(),
						a = Object(S.eb)(i),
						d = Object(S.fb)(i, e),
						c = Object(S.h)(i),
						m = Object(T.r)(i);
					if (!(d && c.id && a && Object(O.f)(m))) return;
					const p = c.id,
						b = Object(T.a)(i, {
							subredditId: p,
							scheduledPostId: m
						});
					if (b && Object(o.a)(Object(y.r)(b)(i)), t(D(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					const {
						isPoll: f,
						polls: h
					} = Object(S.u)(i), v = z(h, i), x = {
						...Object(_.e)({
							poll: f ? v : void 0,
							submission: d,
							schedule: a,
							subredditId: c.id,
							scheduledPostId: m
						})
					}, E = await Object(g.a)(r(), x);
					if (E.ok) return t(Object(l.e)({
						subredditId: c.id
					})), void t(Object(u.a)(V(c.name), !1));
					const C = E.error;
					t(U(C))
				}, J = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const i = n(),
						a = Object(S.eb)(i),
						d = Object(S.fb)(i, e),
						c = Object(S.h)(i),
						m = Object(T.b)(i);
					if (!d || !c.id || !a) return;
					if (t(D(d)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					const {
						isPoll: p,
						polls: b
					} = Object(S.u)(i), f = z(b, i), h = {
						duration: f.duration,
						options: f.options
					}, g = {
						...Object(_.d)({
							poll: p ? h : void 0,
							submission: d,
							schedule: a,
							subredditId: c.id
						}),
						creationToken: m
					}, v = await Object(_.a)(r(), g);
					if (v.ok) {
						t(Object(l.e)({
							subredditId: c.id
						}));
						const e = v.body.data.createScheduledPost.scheduledPost;
						return e && Object(o.a)(Object(y.o)(Object(x.d)(e))(i)), void t(Object(u.a)(V(c.name), !1))
					}
					const O = v.error;
					t(U(O))
				}, X = e => async (t, n, r) => {
					let {
						apiContext: o
					} = r;
					const c = n(),
						l = Object(S.fb)(c, e),
						{
							isPoll: m,
							polls: _
						} = Object(S.u)(c),
						g = z(_, c);
					if (!l) return;
					if (t(D(l)), e.postFieldValidationPending && (await e.postFieldValidationPending, Object(S.x)(n()))) return;
					let x;
					const O = m && v.d.spPolls(c);
					if ((x = O ? await
							function(e, t, n) {
								const r = t.destSubreddit.id;
								return Object(f.a)(e, {
									method: s.ob.POST,
									endpoint: `${p.a.metaUrl}/polls/${r}`,
									type: "json",
									data: {
										poll: n,
										subredditId: r,
										...Object(b.a)(Object(h.d)(t))
									}
								}).then(async e => {
									const n = e.ok ? {
											...e,
											body: {
												json: {
													data: e.body
												}
											}
										} : e,
										s = await Object(h.e)(n, t);
									if (s.ok) {
										return {
											body: {
												...s.body,
												poll: e.body.poll
											},
											ok: !0,
											status: e.status
										}
									}
									return {
										error: s.body,
										ok: !1,
										status: e.status
									}
								})
							}(o(), l, g) : m ? await Object(h.b)(o(), {
								...l,
								kind: j.p.POLL,
								poll: g
							}) : l.kind === j.p.GALLERY ? await Object(h.a)(o(), l) : await Object(h.c)(o(), l)).ok) {
						const e = Object(N.l)(c),
							n = x.body;
						t(F({
							draftId: l.draftId,
							response: n
						})), O && t(Object(a.c)({
							poll: n.poll
						}));
						const s = Object(I.b)(c);
						l.kind !== j.p.LINK && l.kind !== j.p.RICH_TEXT && l.kind !== j.p.MARKDOWN || m || !s || t(Object(i.c)());
						const r = (n.path || `/user/${Object(k.e)(e)}/posts`).replace(/^\/r\/u_/, "/user/");
						t(Object(d.subredditInvalidateListing)(l.destSubreddit.name)), t(Object(u.a)(r, !1))
					} else {
						if (m) {
							const e = x.error;
							t(B(e))
						}
						const e = x.error;
						Z(t, e)
					}
					const y = Object(M.o)(l.kind),
						C = x.ok && x.body && x.body.id && Object(P.z)(x.body.id),
						w = n();
					E.B(w, y, C, e.correlationId)
				}, Z = (e, t) => {
					t.type === s.L.BAD_CAPTCHA_ERROR ? e(H()) : t.type === s.L.VALIDATION_ERROR ? e(q(t)) : t.type === s.L.SUBMIT_VALIDATION_ERROR ? e(G(t)) : e(U(t))
				}
		},
		"./src/reddit/actions/postCreation/subredditChange.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "c", (function() {
				return k
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/addQueryParams/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/filterQueryParams/index.ts"),
				a = n("./src/lib/makeActionCreator/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/pages/postCreation.ts"),
				l = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				u = n("./src/reddit/helpers/name/index.ts"),
				m = n("./src/reddit/models/PostCreationForm/index.ts"),
				p = n("./src/reddit/routes/postCreation/index.ts"),
				b = n("./src/reddit/routes/postCreation/constants.ts"),
				f = n("./src/reddit/selectors/postCreations.ts"),
				h = n("./src/reddit/selectors/platform.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/postCreation/constants.ts"),
				v = n("./src/reddit/actions/postCreation/general.ts");
			const x = Object(a.a)(g.N),
				O = Object(a.a)(g.O),
				E = Object(a.a)(g.M),
				y = (e, t) => async (n, s, r) => {
					let {
						apiContext: i
					} = r, a = s();
					const {
						name: p,
						isProfile: b
					} = e, g = Object(h.e)(a), v = g && !b && Object(u.a)(g.name, p), O = a.creations.api.subreddit.change.pending;
					if (v || O) return;
					const E = Object(l.x)(t);
					if (!p) return void n(C(e, E));
					n(x(e));
					const y = b ? {
						profileName: p
					} : {
						subredditName: p
					};
					if (await n(Object(c.postCreationPageDataRequested)(y)), b || !Object(f.C)(a)) return n(C(e, E));
					const j = e.allowedPostTypes || Object(_.B)(s(), {
						subredditName: p
					});
					if (!j) return void n(C(e, E));
					let k;
					a = s();
					const I = Object(f.pb)(a),
						S = Object(f.C)(a);
					if (I === o.bc.MEDIA && S) {
						const e = Object(f.X)(a),
							t = Object(m.x)(e),
							n = Object(f.O)(a) && e.items.length > 1,
							s = !t && !n;
						if (n && !j.galleries) k = m.q.GalleryWillBeRemovedGalleryNotAllowed;
						else if (s && !j.images) k = m.q.ImageWillBeRemoved;
						else if (t && !j.videos) {
							const t = a.uploads[e.items[0].uploadKey],
								n = t && t.metadata.videoDuration || 0;
							j.images ? n > o.lb && (k = m.q.VideoWillBeRemovedTooLongForGif) : k = m.q.VideoWillBeRemovedMediaNotAllowed
						}
					}
					n(k ? Object(d.i)(k) : C({
						...e,
						allowedPostTypes: j
					}, E))
				}, C = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (o, i) => {
						const {
							name: a,
							isProfile: d
						} = e, c = i().platform.currentPage, l = c.queryParams, u = d ? p.b : p.c;
						let m = "";
						m = a ? u(a) : b.b, m = Object(r.a)(m, {
							...l,
							draft: t || l.draft
						}), (t || c.url.toLowerCase() !== m.toLowerCase()) && (o(O(e)), n && o(Object(v.t)(!0)), o(Object(v.i)()), o(Object(s.c)(m)))
					}
				}, j = e => async (t, n) => {
					const o = n().platform.currentPage,
						i = o.queryParams,
						a = Object(r.a)(o.url, {
							...i,
							collection: e
						});
					t(Object(s.c)(a))
				}, k = () => async (e, t) => {
					const n = t().platform.currentPage,
						r = Object(i.a)(n.url, ["collection"]);
					e(Object(s.c)(r))
				}
		},
		"./src/reddit/actions/postDraft.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "d", (function() {
				return P
			})), n.d(t, "p", (function() {
				return L
			})), n.d(t, "j", (function() {
				return D
			})), n.d(t, "l", (function() {
				return F
			})), n.d(t, "i", (function() {
				return U
			})), n.d(t, "m", (function() {
				return B
			})), n.d(t, "k", (function() {
				return q
			})), n.d(t, "h", (function() {
				return G
			})), n.d(t, "n", (function() {
				return H
			})), n.d(t, "s", (function() {
				return J
			})), n.d(t, "r", (function() {
				return X
			})), n.d(t, "g", (function() {
				return Z
			})), n.d(t, "q", (function() {
				return ee
			})), n.d(t, "c", (function() {
				return te
			})), n.d(t, "a", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "o", (function() {
				return ae
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/formatApiError/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/postCreation/general.ts"),
				a = n("./src/reddit/actions/postCreation/subredditChange.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/models/StructuredStyles/index.ts");
			var p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/name/index.ts"),
				f = n("./src/reddit/models/PostDraft/index.ts"),
				h = n("./src/reddit/helpers/r2/normalizeProfileSubredditFromR2/index.ts"),
				_ = n("./src/reddit/helpers/r2/normalizeSubredditFromR2/index.ts"),
				g = n("./src/reddit/models/Subreddit/index.ts");
			const v = e => {
				let t = e.drafts.reduce((e, t) => {
					const n = (e => {
						let t;
						return t = "link" === e.kind ? {
							kind: f.b.Link,
							body: e.body || void 0
						} : "markdown" === e.kind ? {
							kind: f.b.Markdown,
							body: e.body || void 0
						} : {
							kind: f.b.RichText,
							body: e.body || void 0
						}, {
							subredditId: e.subreddit || void 0,
							contentCategory: e.content_category || void 0,
							created: e.created,
							flair: e.flair,
							id: e.id,
							isChatPost: !!e.discussion_type,
							isNSFW: !!e.nsfw,
							isOriginalContent: !!e.original_content,
							isSpoiler: !!e.spoiler,
							modified: e.modified || void 0,
							sendReplies: !!e.send_replies,
							isPublicLink: !!e.is_public_link,
							title: e.title || "",
							...t
						}
					})(t);
					return e.postDraftIds.push(n.id), e.postDrafts[n.id] = n, e
				}, {
					postDraftIds: [],
					postDrafts: {},
					profiles: {},
					subreddits: {}
				});
				return t = e.subreddits.reduce((e, t) => {
					if (t.subreddit_type === g.g.User) {
						const n = Object(h.a)(t, Object(b.i)(t.display_name_prefixed));
						e.profiles[n.id] = n
					} else {
						const n = Object(_.a)(t);
						e.subreddits[n.id] = n
					}
					return e
				}, t)
			};
			var x = n("./src/reddit/endpoints/post/draft/helpers.ts"),
				O = n("./src/reddit/models/PostCreationForm/index.ts"),
				E = n("./src/reddit/helpers/trackers/postComposer.ts"),
				y = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/models/User/index.ts"),
				j = n("./src/reddit/selectors/postCreations.ts"),
				k = n("./src/reddit/selectors/postDraft.ts"),
				I = n("./src/reddit/selectors/profile.ts"),
				S = n("./src/reddit/selectors/subreddit.ts"),
				w = n("./src/reddit/selectors/user.ts");
			const T = "POST_DRAFT__LIST_PENDING",
				N = "POST_DRAFT__LIST_LOADED",
				P = "POST_DRAFT__LIST_FAILED",
				R = Object(o.a)(T),
				A = Object(o.a)(N),
				M = Object(o.a)(P),
				L = () => async (e, t, n) => {
					let {
						apiContext: r
					} = n;
					const o = t();
					if (!Object(w.l)(o) || Object(k.b)(o)) return;
					e(R());
					const i = await (e => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/drafts.json`,
						method: s.ob.GET
					}))(r());
					i.ok ? e(A(v(i.body))) : e(M(i.error))
				}, D = "POST_DRAFT__SAVE_DRAFT_PENDING", F = "POST_DRAFT__SAVE_DRAFT_SUCCEEDED", U = "POST_DRAFT__SAVE_DRAFT_FAILED", B = "POST_DRAFT__SAVE_DRAFT_VALIDATION_FAILED", q = "POST_DRAFT__SAVE_DRAFT_SUBMIT_VALIDATION_FAILED", G = "POST_DRAFT__SAVE_DRAFT_CAPTCHA_REQUIRED", H = "POST_CREATION__TOGGLE_DRAFT_IS_PUBLIC", W = Object(o.a)(D), V = Object(o.a)(F), z = Object(o.a)(U), K = Object(o.a)(B), Q = Object(o.a)(q), Y = Object(o.a)(G), J = Object(o.a)(H), X = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const c = n(),
						m = Object(k.g)(c),
						b = Object(j.cb)(c);
					if (m || b) return;
					const f = Object(k.h)(c, e);
					if (!f) return;
					t(W(f)), E.g(c, f);
					const h = await ((e, t, n) => Object(l.a)(Object(u.a)(e, [p.a]), {
						endpoint: `${e.apiUrl}/api/v1/draft`,
						method: n ? s.ob.PUT : s.ob.POST,
						data: Object(x.a)(t)
					}).then(e => e.body.fields && Object(O.w)(e.body.fields[0]) ? {
						...e,
						body: {},
						error: {
							type: s.L.SUBMIT_VALIDATION_ERROR,
							fields: [{
								field: e.body.fields[0],
								msg: e.body.explanation
							}]
						}
					} : e))(i(), f, e);
					if (h.ok) {
						const {
							id: n,
							draftsCount: s
						} = Object(x.c)(h.body);
						t(V({
							draftId: n,
							draftsCount: s
						})), e || t(Object(a.a)(f.destSubreddit, n, !1))
					} else {
						const e = h.error;
						e.type === s.L.BAD_CAPTCHA_ERROR ? t(Y()) : e.type === s.L.VALIDATION_ERROR ? t(K(e)) : e.type === s.L.SUBMIT_VALIDATION_ERROR ? t(Q(e)) : t(z(e)), t(Object(d.f)({
							duration: d.a,
							kind: y.b.Error,
							text: Object(r.a)(e)
						}))
					}
				}, Z = "POST_DRAFT__LOAD_DRAFT", $ = Object(o.a)(Z), ee = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t($(e));
					let o = O.f;
					const i = n();
					if (e.subredditId) {
						const t = Object(S.Y)(i, {
								subredditId: e.subredditId
							}),
							n = Object(I.r)(i, {
								profileId: e.subredditId
							}),
							s = Object(w.l)(i);
						t ? o = {
							isProfile: !1,
							name: t.name
						} : n && s && (o = {
							isProfile: !0,
							name: Object(C.e)(s)
						})
					}
					await t(Object(a.a)(o, e.id, !1));
					const d = Object(k.h)(n(), e.id);
					d && E.j(n(), d)
				}, te = "POST_DELETE_DRAFT_SUCCEEDED", ne = "POST_DELETE_DRAFT_FAILED", se = "POST_DELETE_DRAFT_PENDING", re = Object(o.a)(te), oe = Object(o.a)(ne), ie = Object(o.a)(se), ae = (e, t) => async (n, o, a) => {
					let {
						apiContext: p
					} = a;
					const b = o();
					if (Object(k.a)(b, e)) return;
					const f = Object(k.d)(b, {
						draftId: e
					});
					f && E.h(b, f), n(ie({
						draftId: e
					}));
					const h = await (async (e, t) => Object(l.a)(Object(u.a)(e, [m.g]), {
						endpoint: `${e.apiUrl}/api/v1/draft?draft_id=${t}`,
						method: s.ob.DELETE
					}))(p(), e);
					if (h.ok) {
						const {
							draftsCount: s
						} = Object(x.c)(h.body);
						n(re({
							draftId: e,
							draftsCount: s
						}));
						const r = Object(c.x)(t);
						e === r && n(Object(i.q)(!0, t))
					} else {
						const t = h.error;
						n(oe({
							draftId: e,
							apiError: t
						})), n(Object(d.f)({
							duration: d.a,
							kind: y.b.Error,
							text: Object(r.a)(t)
						}))
					}
				}
		},
		"./src/reddit/actions/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "f", (function() {
				return E
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "d", (function() {
				return N
			})), n.d(t, "l", (function() {
				return M
			})), n.d(t, "k", (function() {
				return L
			})), n.d(t, "j", (function() {
				return D
			})), n.d(t, "g", (function() {
				return F
			})), n.d(t, "i", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/post.ts"),
				i = n("./src/reddit/actions/postFlairStyleTemplate.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/flair/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/models/Flair/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts"),
				m = n("./src/reddit/selectors/postFlair.ts"),
				p = n("./src/reddit/selectors/subreddit.ts");
			const b = "STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_SUCCESS",
				f = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_PENDING"),
				h = Object(r.a)(b),
				_ = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ENABLED_SETTING_FAILED"),
				g = "STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				v = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING"),
				x = Object(r.a)(g),
				O = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED"),
				E = "STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_SUCCESS",
				y = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_PENDING"),
				C = Object(r.a)(E),
				j = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_SAVETEMPLATE_FAILED"),
				k = "STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_SUCCESS",
				I = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_PENDING"),
				S = Object(r.a)(k),
				w = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_DELETETEMPLATE_FAILED"),
				T = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_PENDING",
				N = "STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_FAILED",
				P = Object(r.a)(T),
				R = Object(r.a)("STRUCTURED_STYLES__POSTFLAIR_REORDERTEMPLATES_SUCCESS"),
				A = Object(r.a)(N),
				M = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(p.Y)(i, {
							subredditId: e
						}).name;
					n(f());
					const c = await Object(d.k)(o(), a, t);
					if (c.ok) {
						n(h({
							subredditId: e,
							isEnabled: t
						}))
					} else n(_());
					return c.ok
				}, L = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(p.Y)(i, {
							subredditId: e
						}).name;
					n(v());
					const c = await Object(d.j)(o(), t, l.d.LinkFlair, a);
					if (c.ok) {
						n(x({
							subredditId: e,
							canAssignOwn: t
						}))
					} else n(O());
					return c.ok
				}, D = (e, t) => async (n, r, o) => {
					let {
						apiContext: c
					} = o;
					const m = r(),
						b = Object(p.Y)(m, {
							subredditId: t
						}).name;
					n(y());
					const f = await Object(d.f)(c(), e, b, l.d.LinkFlair);
					let h = f.ok && !(f.body && !1 === f.body.success);
					if (h) {
						const s = f.body;
						if (n(C({
								subredditId: t,
								template: s
							})), s.id) {
							const r = e.styleTemplate,
								o = m.structuredStyles.flairTemplate.models[s.id];
							r ? h = await n(Object(i.d)(t, s.id, r)) : o && (h = await n(Object(i.c)(t, s.id)))
						}
					}
					if (h) {
						const e = Object(a.e)(s.fbt._("Flair saved!", null, {
							hk: "3MQuUt"
						}), u.b.SuccessMod);
						n(Object(a.f)(e))
					} else {
						n(j());
						const r = Object(a.e)(s.fbt._("Sorry, flair wasn't saved.", null, {
							hk: "1yf1Ne"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), D(e, t));
						n(Object(a.f)(r))
					}
					return h
				}, F = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const c = r(),
						l = Object(p.Y)(c, {
							subredditId: t
						}).name;
					if (n(I()), (await Object(d.b)(i(), e, l)).ok) {
						n(S({
							subredditId: t,
							templateId: e
						}));
						const r = Object(a.e)(s.fbt._("Flair deleted!", null, {
							hk: "44T1il"
						}), u.b.SuccessMod);
						n(Object(a.f)(r))
					} else {
						n(w());
						const r = Object(a.e)(s.fbt._("Sorry, flair wasn't deleted.", null, {
							hk: "1nwT0G"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), F(e, t));
						n(Object(a.f)(r))
					}
				}, U = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const c = r(),
						b = Object(m.d)(c, {
							subredditId: t
						}).templateIds,
						f = Object(p.Y)(c, {
							subredditId: t
						}).name;
					if (n(P({
							subredditId: t,
							templateIds: e
						})), (await Object(d.e)(i(), f, l.d.LinkFlair, e)).ok) {
						n(R());
						const e = Object(a.e)(s.fbt._("Flair reorder saved.", null, {
							hk: "1Xbuan"
						}), u.b.SuccessMod);
						n(Object(a.f)(e))
					} else {
						n(A({
							subredditId: t,
							templateIds: b
						}));
						const r = Object(a.e)(s.fbt._("Sorry. Flair reorder wasn't saved.", null, {
							hk: "4ohwNd"
						}), u.b.Error, s.fbt._("Retry", null, {
							hk: "1XMjgA"
						}), U(e, t));
						n(Object(a.f)(r))
					}
				}, B = e => {
					let {
						post: t,
						previewFlair: n,
						selectedTemplateId: s
					} = e;
					return async (e, r, i) => {
						let {
							apiContext: a
						} = i;
						const l = t.flair.filter(e => !Object(c.q)(e.type));
						if (n && l.unshift(n), e(Object(o.R)({
								[t.id]: {
									flair: l
								}
							})), n) {
							const e = Object(c.g)(n);
							Object(d.h)(a(), t.id, s, e)
						} else Object(d.h)(a(), t.id, "", "")
					}
				}
		},
		"./src/reddit/actions/postFlairStyleTemplate.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "c", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/forEach.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/isEqual.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/values.js"),
				d = n.n(a),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/reddit/actions/imageUploads.ts"),
				u = n("./src/reddit/helpers/media/index.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts");
			var h = n("./src/reddit/helpers/trackers/blade.ts"),
				_ = n("./src/reddit/models/Image/index.tsx"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/telemetry/index.ts");
			const x = e => {
					let {
						subredditId: t,
						flairId: n,
						imageKey: s,
						imageData: r
					} = e;
					return async (e, o, i) => {
						const a = o(),
							d = Object(g.Y)(a, {
								subredditId: t
							});
						if (!d) return !1;
						e(Object(l.k)(r));
						const c = await (async (e, t, n, s, r, o) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_style_asset_upload_s3/${n}`,
							method: m.ob.POST,
							data: {
								filepath: s,
								imagetype: r,
								mimetype: o
							}
						}))(i.apiContext(), d.name, n, r.file.name, s, await Object(u.h)(r.file));
						let h = !1;
						try {
							const t = await Object(l.g)(o(), c, r, _.a.FlairTemplates);
							t && e(Object(l.j)(t)), h = !0
						} catch (v) {
							if (v instanceof Error) throw v;
							e(Object(l.i)(v))
						}
						return h
					}
				},
				O = "POSTFLAIR_STYLETEMPLATE_SAVED_SUCCESS",
				E = Object(c.a)(O),
				y = (e, t, n) => async (s, o, a) => {
					const {
						apiContext: c
					} = a;
					let u = o();
					const {
						pendingImages: O,
						...y
					} = n;
					let C = y;
					const j = Object(g.Y)(u, {
						subredditId: e
					});
					if (!j) return !1;
					const k = u.structuredStyles.flairTemplate.models[t];
					if (k && i()(k, C)) return !0;
					if (O) {
						const n = [];
						if (r()(O, (r, o) => {
								r && n.push(s(x({
									flairId: t,
									imageData: Object(_.m)(r),
									imageKey: o,
									subredditId: e
								})))
							}), !(await Promise.all(n)).every(e => e)) return !1;
						C = ((e, t, n) => {
							const s = {
								...e
							};
							return r()(t, (e, t) => {
								const r = e && n.imageUploads[e.id];
								r && r.kind === _.b.TempUploaded && (s[t] = r.url)
							}), s
						})(C, O, o())
					}
					u = o();
					let I = null,
						S = null;
					const w = [];
					try {
						(I = await Object(l.f)(u, _.a.FlairTemplates)) && (S = Object(l.m)(I)(s, o, a), w.push(...d()(I.imagesByKey)))
					} catch (R) {
						return !1
					}
					const T = await (async (e, t, n, s) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.ob.PUT,
							data: s
						}))(c(), j.name, t, C),
						N = k ? "edit_post_flair_template" : "save_post_flair_template",
						P = Object(h.e)(u, N);
					if (T.ok) {
						let e;
						if (S) try {
							await S, e = ((e, t, n) => {
								const s = {
									...e
								};
								return t.forEach(e => {
									const t = n.imageUploads[e.id];
									t && t.kind === _.b.Uploaded && (e.url === s.postBackgroundImage ? s.postBackgroundImage = t.url : e.url === s.postPlaceholderImage && (s.postPlaceholderImage = t.url))
								}), s
							})(C, w, o())
						} catch (R) {
							e = null
						} else e = C;
						s(E({
							flairId: t,
							template: e || C
						}))
					} else I && I.websocket.close();
					return Object(v.a)({
						...P,
						actionInfo: {
							...P.actionInfo,
							success: T.ok
						}
					}), T.ok
				}, C = "POSTFLAIR_STYLETEMPLATE_DELETED_SUCCESS", j = Object(c.a)(C), k = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s(),
						a = Object(g.Y)(i, {
							subredditId: e
						});
					if (!a) return !1;
					const d = await (async (e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}/api/v1/${t}/flair_styles/${n}`,
							method: m.ob.DELETE
						}))(o(), a.name, t),
						c = Object(h.e)(i, "delete_flair_template");
					return d.ok && n(j({
						flairId: t
					})), Object(v.a)({
						...c,
						actionInfo: {
							...c.actionInfo,
							success: d.ok
						}
					}), d.ok
				}
		},
		"./src/reddit/actions/postFlairStyleTemplates/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_PENDING",
				r = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_LOADED",
				o = "SUBREDDIT__POST_FLAIR_STYLE_TEMPLATES_FAILED"
		},
		"./src/reddit/actions/publicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "b", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/post.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				a = n("./src/reddit/selectors/experiments/publicAccessNetwork.ts"),
				d = n("./src/reddit/selectors/PublicAccessNetwork/api.ts");
			const c = Object(s.a)(o.w),
				l = Object(s.a)(o.x),
				u = Object(s.a)(o.G),
				m = (Object(s.a)(o.H), Object(s.a)(o.I)),
				p = Object(s.a)(o.T),
				b = e => async (t, n) => {
					if (Object(a.a)(n())) return t(f(e))
				}, f = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(d.k)(n()),
						a = Object(d.m)(n(), {
							subreddit: e
						}),
						p = a && a.lastUpdated || 0,
						b = 1e3 * o.global.rpan_config_refresh_rate;
					if (o.isPending || o.isPermanentlyCanceled || Date.now() < p + b) return;
					t(u());
					const f = await Object(i.c)(r(), e);
					if (!f.ok) return void t(m());
					const h = f.body;
					t(c({
						...h.global,
						lastUpdated: Date.now()
					})), t(l({
						name: e,
						config: {
							...h.listing_info,
							lastUpdated: Date.now()
						}
					}))
				}, h = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					t(p()), await Object(i.h)(r(), e)
				}, _ = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					n().posts.models[e] || await t(Object(r.L)(e))
				}, g = Object(s.a)(o.v), v = Object(s.a)(o.J), x = Object(s.a)(o.K), O = () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (Object(d.h)(r)) return;
					e(v());
					const o = await Object(i.d)(s());
					o.ok && o.body && o.body.data ? e(g({
						subreddits: o.body.data
					})) : e(x({
						error: o.error
					}))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/automute.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts");
			const i = Object(s.a)(o.r),
				a = Object(s.a)(o.F),
				d = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const d = await Object(r.a)(o(), e);
					d && d.ok ? t(i({
						streamId: e,
						level: d.body.data.auto_mute_status.level
					})) : t(a(e))
				}
		},
		"./src/reddit/actions/publicAccessNetwork/streams.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "f", (function() {
				return C
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/query-string/index.js"),
				r = n.n(s),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				a = n("./src/reddit/endpoints/publicAccessNetwork/index.ts"),
				d = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				c = n("./src/reddit/selectors/PublicAccessNetwork/api.ts"),
				l = n("./src/reddit/selectors/subreddit.ts");
			const u = new Set(["home", "r/popular"]),
				m = e => {
					const t = location && location.search || "",
						n = r.a.parse(t);
					u.has(e) && (n.related = e);
					const s = r.a.stringify(n);
					return s ? `?${s}` : ""
				},
				p = Object(o.a)(i.N),
				b = Object(o.a)(i.y),
				f = Object(o.a)(i.O),
				h = Object(o.a)(i.z),
				_ = Object(o.a)(i.M),
				g = Object(o.a)(i.L),
				v = Object(o.a)(i.t),
				x = Object(o.a)(i.u),
				O = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = Object(d.g)(e),
						i = n();
					if (Object(c.d)(i, o)) return;
					t(p(o));
					const l = await Object(a.e)(r(), o),
						u = Date.now();
					if (l.ok && l.body && l.body.data) {
						const e = l.body.data;
						t(b({
							model: e,
							utcTimeStamp: u
						}))
					} else t(k({
						streamId: o,
						error: l.error,
						utcTimeStamp: u
					}))
				}, E = (e, t) => async (n, s) => n(y(e, t)), y = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = s();
					if (Object(c.f)(i)) return;
					n(f());
					const d = await Object(a.f)(o(), e, t),
						l = Date.now();
					if (d.ok && d.body && d.body.data) {
						const t = d.body.data;
						n(h({
							listingName: e,
							models: t,
							utcTimeStamp: l
						}))
					} else n(I({
						error: d.error,
						utcTimeStamp: l
					}))
				}, C = (e, t) => async (n, s) => n(j(e, t)), j = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = s();
					if (Object(c.f)(i)) return;
					n(f());
					const d = Date.now(),
						u = e.replace("r/", ""),
						m = Object(l.I)(i, u),
						p = await Object(a.b)(o(), {
							subredditId: m,
							options: t
						}),
						b = p.body;
					p.ok && b && b.data || n(I({
						error: p.error,
						utcTimeStamp: d
					}));
					const _ = b.data.liveVideoFeed.posts.edges.map(e => (async (e, t) => {
							const n = await Object(a.e)(e, t),
								s = Date.now(),
								r = n.body;
							return r && r.data ? r.data : void k({
								streamId: t,
								error: n.error,
								utcTimeStamp: s
							})
						})(o(), e.node.id)),
						g = (await Promise.all(_)).filter(e => void 0 !== typeof e);
					n(h({
						listingName: e,
						models: g,
						utcTimeStamp: d
					}))
				}, k = e => async t => {
					t(_(e))
				}, I = e => async t => {
					t(g(e))
				}
		},
		"./src/reddit/actions/recentSubreddits/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			const s = "SET_RECENT_SUBREDDITS",
				r = "SUBREDDIT_VISITED",
				o = "SUBREDDIT_SAVED",
				i = "COPY_SAVED_SUBREDDITS",
				a = "COPY_SAVED_ID_SUBREDDITS",
				d = 10
		},
		"./src/reddit/actions/redditEmbed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tabBadging.ts"),
				i = n("./src/reddit/endpoints/me/index.ts"),
				a = n("./src/reddit/helpers/pageActionLoginRedirect.ts"),
				d = n("./src/reddit/helpers/trackers/screenview.ts");
			const c = "REDDIT_EMBED_LOADED",
				l = "REDDIT_EMBED_FAILED",
				u = Object(r.a)("REDDIT_EMBED_PENDING"),
				m = Object(r.a)(c),
				p = Object(r.a)(l),
				b = (e, t) => async (e, n, s) => {
					let {
						apiContext: r
					} = s;
					const d = n();
					e(u());
					const c = await Object(i.a)(r());
					c.ok && c.body ? !t || c.body.account ? (e(m(c.body)), e(Object(o.d)()), f(d)) : Object(a.a)(e, d) : e(p(c.error))
				}, f = e => {
					e.platform.currentPage && e.platform.currentPage.routeMatch && e.platform.currentPage.routeMatch.route && e.platform.currentPage.routeMatch.route.meta && e.platform.currentPage.routeMatch.route.meta.name && e.platform.currentPage.routeMatch.route.meta.name === s.Sb.INBOX_PAGES && Object(d.g)(e)
				}
		},
		"./src/reddit/actions/removalReasons/index.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "removalReasonsPending", (function() {
				return Z
			})), n.d(t, "removalReasonsLoaded", (function() {
				return $
			})), n.d(t, "removalReasonsFailed", (function() {
				return ee
			})), n.d(t, "removalReasonsRequested", (function() {
				return te
			})), n.d(t, "removalReasonAddedPending", (function() {
				return ne
			})), n.d(t, "removalReasonAddedSuccess", (function() {
				return se
			})), n.d(t, "removalReasonAddedFailed", (function() {
				return re
			})), n.d(t, "addRemovalReason", (function() {
				return oe
			})), n.d(t, "editRemovalReasonPending", (function() {
				return ie
			})), n.d(t, "editRemovalReasonSuccess", (function() {
				return ae
			})), n.d(t, "editRemovalReasonFailed", (function() {
				return de
			})), n.d(t, "editRemovalReason", (function() {
				return ce
			})), n.d(t, "deleteRemovalReasonPending", (function() {
				return le
			})), n.d(t, "deleteRemovalReasonSuccess", (function() {
				return ue
			})), n.d(t, "deleteRemovalReasonFailed", (function() {
				return me
			})), n.d(t, "deleteRemovalReason", (function() {
				return pe
			})), n.d(t, "removedItemsSelected", (function() {
				return be
			})), n.d(t, "fetchReasonsAndOpenModal", (function() {
				return fe
			})), n.d(t, "removalReasonSubmittedPending", (function() {
				return he
			})), n.d(t, "removalReasonSubmittedSuccess", (function() {
				return _e
			})), n.d(t, "removalReasonSubmittedFailed", (function() {
				return ge
			})), n.d(t, "removalReasonMessagePending", (function() {
				return ve
			})), n.d(t, "removalReasonPrivateMessageSuccess", (function() {
				return xe
			})), n.d(t, "removalReasonPublicMessageSuccess", (function() {
				return Oe
			})), n.d(t, "removalReasonMessageFailed", (function() {
				return Ee
			})), n.d(t, "submitRemovalReason", (function() {
				return ye
			})), n.d(t, "submitBulkRemovalReason", (function() {
				return Ce
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./node_modules/redux/es/redux.js");
			const i = "REMOVALREASONS__LOAD_SUCCESS",
				a = "REMOVALREASONS__ADD_PENDING",
				d = "REMOVALREASONS__ADD_SUCCESS",
				c = "REMOVALREASONS__ADD_FAILED",
				l = "REMOVALREASONS__EDIT_PENDING",
				u = "REMOVALREASONS__EDIT_SUCCESS",
				m = "REMOVALREASONS__EDIT_FAILED",
				p = "REMOVALREASONS__DELETE_PENDING",
				b = "REMOVALREASONS__DELETE_SUCCESS",
				f = "REMOVALREASONS__DELETE_FAILED";
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case "REMOVALREASONS__LOAD_PENDING":
					case i:
					case a:
					case d:
					case l:
					case u:
					case p:
					case b:
						return null;
					case "REMOVALREASONS__LOAD_FAILED":
					case c:
					case m:
					case f:
						return t.payload;
					default:
						return e
				}
			};
			var _ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__LOAD_PENDING":
						case a:
						case l:
						case p:
							return !0;
						case i:
						case "REMOVALREASONS__LOAD_FAILED":
						case d:
						case c:
						case u:
						case m:
						case b:
						case f:
							return !1;
						default:
							return e
					}
				},
				g = Object(o.c)({
					error: h,
					pending: _
				});
			const v = {};
			var x = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i: {
						const {
							response: n
						} = t.payload, {
							data: s
						} = n;
						return {
							...e,
							...s
						}
					}
					case d:
					case u: {
						const {
							reason: n
						} = t.payload;
						return {
							...e,
							[n.id]: n
						}
					}
					case b: {
						const {
							reasonId: n
						} = t.payload, {
							[n]: s,
							...r
						} = e;
						return r
					}
					default:
						return e
				}
			};
			const O = {};
			var E = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : O,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							order: r
						} = s;
						return {
							...e,
							[n]: r
						}
					}
					case d: {
						const {
							subredditId: n,
							reason: s
						} = t.payload;
						return {
							...e,
							[n]: [...e[n], s.id]
						}
					}
					case b: {
						const {
							subredditId: n,
							reasonId: s
						} = t.payload, r = [...e[n]].filter(e => e !== s);
						return {
							...e,
							[n]: r
						}
					}
					default:
						return e
				}
			};
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case "REMOVALREASONS__REMOVEDITEMS_SELECTED": {
							const {
								subredditId: e,
								itemIds: n
							} = t.payload;
							return {
								itemIds: n,
								subredditId: e
							}
						}
						default:
							return e
					}
				},
				C = Object(o.c)({
					api: g,
					models: x,
					reasonOrder: E,
					removedItemIds: y
				}),
				j = n("./src/lib/constants/index.ts"),
				k = n("./src/lib/makeActionCreator/index.ts"),
				I = n("./src/lib/makeCommentsPageKey/index.ts"),
				S = n("./src/lib/makeDraftKey/index.ts"),
				w = n("./src/reddit/actions/bulkActions/index.ts"),
				T = n("./src/reddit/actions/comment/index.ts"),
				N = n("./src/reddit/actions/comment/authoring.ts"),
				P = n("./src/reddit/actions/comment/moderation.ts"),
				R = n("./src/reddit/actions/modal.ts"),
				A = n("./src/reddit/actions/post.ts"),
				M = n("./src/reddit/actions/toaster.ts"),
				L = n("./src/reddit/constants/modals.ts"),
				D = n("./src/lib/makeApiRequest/index.ts"),
				F = n("./src/lib/omitHeaders/index.ts"),
				U = n("./src/reddit/constants/headers.ts"),
				B = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const q = (e, t) => Object(D.a)(Object(F.a)(e, [U.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/removal_reasons/`,
					method: j.ob.POST,
					type: "json",
					data: {
						item_ids: t.itemIds,
						reason_id: t.reasonId,
						mod_note: t.modNote
					}
				}),
				G = (e, t, n) => Object(D.a)(Object(F.a)(e, [U.a]), {
					endpoint: Object(B.a)(`${e.apiUrl}/api/v1/modactions/removal_${n}_message/`),
					method: j.ob.POST,
					type: "json",
					data: t
				});
			var H = n("./src/reddit/helpers/isPost.ts"),
				W = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				V = n("./src/reddit/helpers/routeKey/index.ts"),
				z = n("./src/reddit/models/ModQueue/index.ts"),
				K = n("./src/reddit/models/PostDraft/index.ts"),
				Q = n("./src/reddit/models/RemovalReason/index.ts"),
				Y = n("./src/reddit/models/Toast/index.ts"),
				J = n("./src/reddit/selectors/comments.ts"),
				X = n("./src/reddit/selectors/platform.ts");
			Object(r.a)({
				features: {
					removalReasons: C
				}
			});
			const Z = Object(k.a)("REMOVALREASONS__LOAD_PENDING"),
				$ = Object(k.a)(i),
				ee = Object(k.a)("REMOVALREASONS__LOAD_FAILED"),
				te = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n().subreddits.models[e].name;
					t(Z());
					const i = await ((e, t) => Object(D.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons.json`,
						method: j.ob.GET
					}))(r(), o);
					i.ok ? t($({
						subredditId: e,
						response: i.body
					})) : t(ee(i.error))
				}, ne = Object(k.a)(a), se = Object(k.a)(d), re = Object(k.a)(c), oe = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(ne());
					const d = await ((e, t, n) => Object(D.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons`,
						method: j.ob.POST,
						data: n
					}))(i(), a, t);
					if (d.ok) {
						const {
							id: r
						} = d.body, o = {
							...t,
							id: r
						};
						n(se({
							subredditId: e,
							reason: o
						})), n(Object(M.f)({
							kind: Y.b.SuccessMod,
							text: s.fbt._("Removal reason added!", null, {
								hk: "2WSh8N"
							})
						}))
					} else n(re(d.error))
				}, ie = Object(k.a)(l), ae = Object(k.a)(u), de = Object(k.a)(m), ce = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(ie());
					const d = await ((e, t, n) => Object(D.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons/${n.id}`,
						method: j.ob.PUT,
						data: {
							message: n.message,
							title: n.title
						}
					}))(i(), a, t);
					d.ok ? (n(ae({
						subredditId: e,
						reason: t
					})), n(Object(M.f)({
						kind: Y.b.SuccessMod,
						text: s.fbt._("Removal reason saved", null, {
							hk: "28ScuL"
						})
					}))) : n(de(d.error))
				}, le = Object(k.a)(p), ue = Object(k.a)(b), me = Object(k.a)(f), pe = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = r().subreddits.models[e].name;
					n(le());
					const d = await ((e, t, n) => Object(D.a)(Object(F.a)(e, [U.a]), {
						endpoint: `${e.apiUrl}/api/v1/${t}/removal_reasons/${n}`,
						method: j.ob.DELETE
					}))(i(), a, t);
					d.ok ? (n(ue({
						subredditId: e,
						reasonId: t
					})), n(Object(M.f)({
						kind: Y.b.SuccessMod,
						text: s.fbt._("Removal reason deleted", null, {
							hk: "4xzgsa"
						})
					}))) : n(me(d.error))
				}, be = Object(k.a)("REMOVALREASONS__REMOVEDITEMS_SELECTED"), fe = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s();
					i.features.removalReasons.reasonOrder[e] && i.features.removalReasons.reasonOrder[e].length > 0 || n(te(e)), n(be({
						subredditId: e,
						itemIds: t
					})), n(Object(R.i)(L.a.ADD_REMOVAL_REASON))
				}, he = Object(k.a)("REMOVALREASONS__SUBMIT_PENDING"), _e = Object(k.a)("REMOVALREASONS__SUBMIT_SUCCESS"), ge = Object(k.a)("REMOVALREASONS__SUBMIT_FAILED"), ve = Object(k.a)("REMOVALREASONS__MESSAGE_PENDING"), xe = Object(k.a)("REMOVALREASONS__MESSAGE_PRIVATE_SUCCESS"), Oe = Object(k.a)("REMOVALREASONS__MESSAGE_PUBLIC_SUCCESS"), Ee = Object(k.a)("REMOVALREASONS__MESSAGE_FAILED"), ye = (e, t, n, s, r, o) => async (i, a, d) => {
					let {
						apiContext: c
					} = d;
					const l = a(),
						u = l.user.account && l.user.account.displayText,
						m = e[0],
						p = Object(H.a)(m) ? Q.e.Post : Q.e.Comment,
						b = p === Q.e.Post ? l.posts.models[m] : l.features.comments.models[m],
						f = p === Q.e.Post ? A.R : T.j;
					if (!b || !u) return !1;
					i(he()), i(f({
						[m]: {
							modNote: r,
							modRemovalReason: t && t.title,
							modReasonBy: u
						}
					}));
					const h = {
							itemIds: e,
							modNote: r,
							reasonId: t ? t.id : null
						},
						_ = await q(c(), h);
					if (_.ok) {
						if (i(_e()), t) {
							i(ve());
							const r = {
									itemId: e,
									message: n,
									title: t.title,
									isLocked: o,
									type: s
								},
								a = await G(c(), Object(Q.h)(r, p), p);
							if (a.ok) {
								if ([Q.f.Public, Q.f.PublicAsSubreddit].includes(s)) {
									if (i(Oe()), a.body) {
										const e = Object(W.a)(a.body),
											t = {
												comment: e,
												parentId: m
											},
											n = Object(X.f)(l),
											s = l.platform.currentPage && l.platform.currentPage.routeMatch;
										let r = n && s && Object(V.a)(s, l, l.posts.models[e.postId]);
										if (r || (r = Object(I.a)(e.postId, null, {
												sort: j.x,
												hasSortParam: !0
											})), p === Q.e.Post) {
											const n = Object(S.a)(K.c.replyToPost, m);
											i(Object(N.r)({
												...t,
												headCommentId: Object(J.w)(l, {
													commentsPageKey: r
												}),
												commentsPageKey: r,
												draftKey: n
											}));
											const s = l.postStickiedComments.data[m];
											i(Object(P.f)({
												id: e.id,
												postId: e.postId,
												commentsPageKey: r
											})), s && s !== e.id && i(Object(T.j)({
												[s]: {
													isStickied: !1
												}
											}))
										} else if (p === Q.e.Comment) {
											const e = Object(S.a)(K.c.replyToComment, b.id),
												n = Object(J.j)(l, {
													commentId: m,
													commentsPageKey: r
												});
											i(Object(N.p)({
												...t,
												parentCommentId: m,
												commentsPageKey: r,
												draftKey: e,
												depth: n + 1
											}))
										}
									}
								} else i(xe());
								return !0
							}
							return i(Ee(a.error)), !1
						}
					} else i(ge(_.error)), i(f({
						[m]: {
							modNote: b.modNote,
							modRemovalReason: b.modRemovalReason,
							modReasonBy: b.modReasonBy
						}
					}));
					return !1
				}, Ce = (e, t, n, r, o) => async (i, a, d) => {
					let {
						apiContext: c
					} = d;
					const l = a(),
						u = l.user.account && l.user.account.displayText;
					if (!u) return;
					i(he());
					const m = Object(M.f)({
							kind: Y.b.SuccessMod,
							text: s.fbt._({
								"*": "Added removal reason for {number} posts/comments",
								_1: "Added removal reason for 1 post/comment"
							}, [s.fbt._plural(e.length, "number")], {
								hk: "3Gipsf"
							})
						}),
						p = {
							itemIds: e,
							modNote: o,
							reasonId: t ? t.id : null
						},
						b = await q(c(), p);
					if (b.ok) {
						const s = {
							ids: e,
							operation: z.a.RemovalReason,
							username: u,
							options: {
								modNote: o,
								removalReason: t && t.title
							}
						};
						if (i(Object(w.b)(s)), t) {
							const s = {
									itemId: e,
									message: n,
									title: t.title,
									type: r
								},
								o = await G(c(), Object(Q.h)(s, Q.e.Bulk), Q.e.Bulk);
							o.ok ? (i(xe()), i(m)) : i(Ee(o.error))
						} else i(m)
					} else i(ge(b.error))
				}
		},
		"./src/reddit/actions/reportFlow/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.postOrCommentReported)),
				o = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowOpened)),
				i = Object(s.a)(() => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/actions/reportFlow/reportFlow.ts")).then(e => e.reportFlowClosed))
		},
		"./src/reddit/actions/scheduledPosts/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "m", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "r", (function() {
				return v
			})), n.d(t, "u", (function() {
				return x
			})), n.d(t, "p", (function() {
				return O
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "v", (function() {
				return y
			})), n.d(t, "s", (function() {
				return C
			})), n.d(t, "x", (function() {
				return j
			})), n.d(t, "w", (function() {
				return k
			})), n.d(t, "t", (function() {
				return I
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = "SCHEDULED_POSTS_REQUESTED",
				o = "SCHEDULED_POSTS_LOADED",
				i = "STANDALONE_SCHEDULED_POSTS_LOADED",
				a = "RECURRING_SCHEDULED_POSTS_LOADED",
				d = "SCHEDULED_POSTS_FAILED",
				c = "SCHEDULED_POST_CREATION_SUCCEEDED",
				l = "SCHEDULED_POST_SUBMIT_NOW_SUCCESS",
				u = "SCHEDULED_POST_MUTATE_REQUESTED",
				m = "SCHEDULED_POST_MUTATE_FAILED",
				p = "STANDALONE_POST_MUTATE_SUCCESS",
				b = "RECURRING_POST_MUTATE_SUCCESS",
				f = "RECURRING_POST__EDIT_MODAL_LOAD",
				h = "RECURRING_POST__EDIT_LOAD",
				_ = "STANDALONE_POST__EDIT_LOAD",
				g = "SCHEDULED_POST__DELETE_SUCCESS",
				v = () => s.fbt._("Failed to load scheduled posts", null, {
					hk: "1fhkq4"
				}),
				x = () => s.fbt._("Whoops! Invalid scheduled post", null, {
					hk: "35jBb6"
				}),
				O = () => s.fbt._("Unable to delete scheduled post", null, {
					hk: "23nWms"
				}),
				E = () => s.fbt._("Successfully deleted scheduled post", null, {
					hk: "1Lk7r2"
				}),
				y = () => s.fbt._("Unable to submit scheduled post", null, {
					hk: "vCW43"
				}),
				C = () => s.fbt._("Retry", null, {
					hk: "4bCZ7M"
				}),
				j = () => s.fbt._("Successfully submitted scheduled post!", null, {
					hk: "ONo6q"
				}),
				k = () => s.fbt._("Successfully edited scheduled post!", null, {
					hk: "HfGcT"
				}),
				I = () => s.fbt._("Failed to update scheduled post", null, {
					hk: "2zBuRu"
				})
		},
		"./src/reddit/actions/scheduledPosts/delete.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/DeleteScheduledPost.json");
			var d = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				c = n("./src/reddit/models/ScheduledPost/index.ts"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				m = n("./src/telemetry/index.ts");
			const p = Object(s.a)(r.i),
				b = (e, t) => async (n, s, b) => {
					let {
						gqlContext: f
					} = b;
					const h = Object(u.a)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					h && Object(c.q)(h) && Object(m.a)(Object(d.s)()(s(), h)), h ? (await ((e, t) => Object(i.a)(e, {
						...a,
						variables: t
					}))(f(), {
						input: {
							id: h.id
						}
					})).ok ? (n(Object(o.f)(Object(o.e)(r.q(), l.b.SuccessCommunity))), n(p({
						subredditId: e,
						scheduledPostId: t
					}))) : n(Object(o.f)(Object(o.e)(r.p(), l.b.Error))) : n(Object(o.f)(Object(o.e)(r.u(), l.b.Error)))
				}
		},
		"./src/reddit/actions/scheduledPosts/edit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react-router-redux/es/index.js"),
				o = n("./src/telemetry/index.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/scheduledPosts/index.ts"),
				d = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/endpoints/scheduledPosts/update.ts"),
				u = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				m = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				p = n("./src/reddit/models/ScheduledPost/index.ts"),
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/routes/postCreation/index.ts"),
				h = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const _ = Object(i.a)(d.n),
				g = Object(i.a)(d.b),
				v = (e, t) => async (n, s, o) => {
					const i = Object(h.a)(s(), {
						scheduledPostId: t,
						subredditId: e
					});
					i && (await n(Object(r.b)(Object(f.c)(i.subreddit.name, i.collectionId))), n((Object(p.q)(i) ? g : _)(i)))
				}, x = (e, t) => {
					Object(p.q)(t) ? e(Object(a.d)({
						scheduledPost: t
					})) : e(Object(a.h)({
						scheduledPost: t
					}))
				}, O = (e, t, n) => async (r, i, f) => {
					let {
						gqlContext: _
					} = f;
					r(Object(a.g)());
					const g = Object(h.a)(i(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (g && Object(p.q)(g) && Object(o.a)(Object(m.u)()(i(), g)), !g) return void r(Object(a.f)({
						message: s.fbt._("Scheduled post not found", null, {
							hk: "2zjM55"
						})
					}));
					if (!Object.keys(n).length) return void x(r, g);
					const v = await Object(l.a)(_(), {
							...n,
							id: t
						}),
						E = v.body;
					if (!(v.ok && E && E.data && E.data.updateScheduledPost && E.data.updateScheduledPost.ok && E.data.updateScheduledPost.scheduledPost)) return r(Object(a.f)({
						message: v.error && v.error.fields && v.error.fields.length && v.error.fields[0].msg || s.fbt._("Unknown error", null, {
							hk: "fXs5s"
						})
					})), void r(Object(c.f)(Object(c.e)(d.t(), b.b.Error, d.s(), O(e, t, n))));
					r(Object(c.f)(Object(c.e)(d.w(), b.b.SuccessCommunity))), x(r, Object(u.d)(E.data.updateScheduledPost.scheduledPost))
				}
		},
		"./src/reddit/actions/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return P
			}));
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				i = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/reddit/endpoints/scheduledPosts/index.ts"),
				c = n("./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts"),
				l = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				b = n("./src/telemetry/index.ts");
			const f = 25,
				h = 1e4,
				_ = Object(r.a)(o.g),
				g = Object(r.a)(o.k),
				v = Object(r.a)(o.j),
				x = Object(r.a)(o.o),
				O = Object(r.a)(o.d),
				E = Object(r.a)(o.f),
				y = Object(r.a)(o.m),
				C = Object(r.a)(o.a),
				j = Object(r.a)(o.c),
				k = Object(r.a)(o.e),
				I = Object(r.a)(o.h),
				S = (e, t) => {
					e(k()), e(Object(a.f)(Object(a.e)(o.r(), m.b.Error, o.s(), w(t))))
				},
				w = e => {
					let {
						subredditId: t,
						includeStandalone: n = {
							standaloneFirst: f
						},
						includeRecurring: s = {
							recurringFirst: h
						},
						...r
					} = e;
					return async (e, o, i) => {
						let {
							gqlContext: a
						} = i;
						if (Object(p.h)(o(), {
								subredditId: t
							})) return;
						e(_());
						const l = {
								subredditId: t,
								includeRecurring: s,
								includeStandalone: n,
								...r
							},
							u = await Object(d.b)(a(), l);
						Object(d.f)(u, l) ? N(e, Object(c.e)(u.body.data), l) : S(e, l)
					}
				},
				T = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (!Object(p.h)(o, {
							subredditId: e
						})) return t(w({
						subredditId: e
					}));
					if (!Object(p.g)(o, {
							subredditId: e,
							type: u.g.standalonePosts
						})) return;
					const i = Object(p.c)(o, {
						subredditId: e,
						type: u.g.standalonePosts
					});
					if (!i) return;
					t(_());
					const a = {
							subredditId: e,
							includeStandalone: {
								standaloneFirst: f,
								standaloneAfter: i
							}
						},
						l = await Object(d.b)(r(), a);
					l.ok ? N(t, Object(c.e)(l.body.data), a) : t(k())
				}, N = (e, t, n) => {
					Object(c.b)(t) ? e(E(t)) : Object(c.a)(t) ? e(C(t)) : Object(c.c)(t) ? e(y(t)) : S(e, n)
				}, P = (e, t) => async (n, r, o) => {
					const a = {},
						d = r();
					switch (e) {
						case "isModDistinguished":
						case "isNsfw":
						case "isOriginalContent":
						case "isContestMode":
						case "isPostAsMetaMod":
						case "isSpoiler":
							a[e] = !t[e];
							break;
						case "isSticky":
							const n = !!t.sticky && "NONE" !== t.sticky;
							a.sticky = n ? "NONE" : "SECOND";
							break;
						default:
							return Object(s.a)(e)
					}
					Object(b.a)(Object(l.t)(e, a[e], Object(u.q)(t))(d)), n(Object(i.a)(t.subreddit.id, t.id, a))
				}
		},
		"./src/reddit/actions/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/reddit/endpoints/goodContent/index.ts");
			const o = "FRONTPAGE_LINKS__REQUEST_LOADED",
				i = "SUBREDDIT_LINKS_LOADED",
				a = 10,
				d = Object(s.a)("FRONTPAGE_LINKS__REQUEST_PENDING"),
				c = Object(s.a)("FRONTPAGE_LINKS__REQUEST_FAILED"),
				l = Object(s.a)(o),
				u = Object(s.a)(i),
				m = () => async e => {
					e(d());
					const t = await Object(r.a)();
					e(t ? l(t) : c())
				}
		},
		"./src/reddit/actions/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeActionCreator/index.ts");
			const r = "SUBREDDIT_TOPIC_LINKS_LOADED",
				o = Object(s.a)(r)
		},
		"./src/reddit/actions/shortcuts/utils.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/shortcuts.ts"),
				r = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				o = n("./src/reddit/helpers/routeKey/index.ts");
			const i = e => {
					const t = e.platform.currentPage;
					if (!t || !t.routeMatch) return;
					const n = t.routeMatch,
						s = Object(r.a)(e);
					return Object(o.b)(n, e, s)
				},
				a = e => {
					const t = document.getElementById(e);
					t && t.focus()
				},
				d = e => {
					const t = document.getElementById(e),
						n = window.scrollX,
						s = window.scrollY;
					t && (t.focus(), window.scrollTo(n, s))
				},
				c = () => {
					d(s.b)
				}
		},
		"./src/reddit/actions/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/config.ts"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts");
			var u = n("./src/reddit/reducers/features/avatar/index.ts"),
				m = n("./src/reddit/selectors/avatar.ts"),
				p = n("./src/reddit/actions/users.ts");
			Object(s.a)({
				features: {
					avatar: u.a
				}
			});
			const b = "SET_AVATAR_USER",
				f = Object(r.a)(b),
				h = "RANDOM_AVATAR_LOADED",
				_ = Object(r.a)(h),
				g = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: u
					} = o;
					var b, f, h, _;
					const g = Object(m.b)(r()),
						v = await (async (e, t, n, s, r) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatar?skip_telemetry=true`,
							method: a.ob.POST,
							headers: {
								"Content-Type": "application/json ",
								"X-CSRF-Token": r || ""
							},
							data: {
								accessory_ids: t,
								styles: n,
								...s
							}
						}))(u(), e, t, n, g);
					if (!v.ok) throw new Error("User avatar failed to save");
					return s(Object(p.y)(v.body)), {
						accountIcon: null === (f = null === (b = v.body) || void 0 === b ? void 0 : b.avatar) || void 0 === f ? void 0 : f.headshot_image_url,
						fullBodySnoovatar: null === (_ = null === (h = v.body) || void 0 === h ? void 0 : h.avatar) || void 0 === _ ? void 0 : _.image_url
					}
				}, v = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/account`,
							method: a.ob.GET
						}))(s());
						t.ok && e(f(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}, x = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					try {
						const t = await (async e => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${i.a.snoovatarUrl}/api/snoovatars/random:byId`,
							method: a.ob.GET
						}))(s());
						t.ok && e(_(t.body))
					} catch (r) {
						o.c.captureException(r)
					}
				}
		},
		"./src/reddit/actions/snoovatarModal.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/reddit/actions/login.ts"),
				r = n("./src/reddit/actions/modal.ts"),
				o = n("./src/reddit/actions/users.ts"),
				i = n("./src/reddit/constants/modals.ts"),
				a = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				c = n("./src/telemetry/index.ts");
			const l = () => async (e, t) => {
				const n = t();
				Object(c.a)(Object(a.l)(n)), e(Object(o.s)({
					forceFetch: !0
				})), await e(Object(r.g)(i.a.SNOOVATAR_MODAL))
			};

			function u() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return async (t, n) => {
					const {
						clickSource: o,
						share: l,
						source: u,
						activeTab: m,
						activeMeSubpage: p,
						activeDetails: b,
						shopTabState: f
					} = e, h = n();
					o && Object(c.a)(Object(a.g)(o)(h)), Object(d.R)(h) ? await t(Object(r.h)(i.a.SNOOVATAR_MODAL, {
						share: l,
						source: u,
						activeTab: m,
						activeMeSubpage: p,
						activeDetails: b,
						shopTabState: f
					})) : await t(Object(s.openLoginModal)())
				}
			}
		},
		"./src/reddit/actions/streaming/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "SUBREDDIT__STREAMING_MOD_SETTINGS_LOADED"
		},
		"./src/reddit/actions/streaming/modSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "e", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/streaming/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeGqlRequest/index.ts"),
				d = n("./src/redditGQL/operations/FetchSubredditStreamingModSettings.json"),
				c = n("./src/redditGQL/operations/UpdateSubredditStreamingModSettings.json"),
				l = n("./src/reddit/models/Toast/index.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = Object(r.a)(o.a),
				p = "STREAMING_MOD_SETTINGS__UPDATE_PENDING",
				b = "STREAMING_MOD_SETTINGS__UPDATE_LOADED",
				f = "STREAMING_MOD_SETTINGS__UPDATE_FAILED",
				h = Object(r.a)(p),
				_ = Object(r.a)(b),
				g = Object(r.a)(f),
				v = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const c = Object(u.Y)(n(), {
						subredditId: e
					});
					if (void 0 === c) {
						const e = s.fbt._("Invalid subreddit", null, {
								hk: "2iUXvs"
							}),
							n = Object(i.e)(e, l.b.Error);
						return await t(Object(i.f)({
							...n,
							duration: i.a
						})), {
							reason: e
						}
					}
					const p = await ((e, t) => Object(a.a)(e, {
						...d,
						variables: {
							subredditId: t
						}
					}))(o(), e);
					if (!p.ok) {
						const e = s.fbt._("Could not fetch settings for {subredditName}", [s.fbt._param("subredditName", c.name)], {
								hk: "2G8rnU"
							}),
							n = Object(i.e)(e, l.b.Error);
						return await t(Object(i.f)({
							...n,
							duration: i.a
						})), {
							reason: e
						}
					}
					const b = p.body.data.subredditInfoById;
					return await t(m({
						subredditId: e,
						modSettings: b.liveStreamingInfo
					})), {}
				}, x = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					await n(O(t, e, o())), n(v(t))
				}, O = (e, t, n) => async (n, r, o) => {
					let {
						gqlContext: d
					} = o;
					n(h({
						subredditId: e
					}));
					const u = await ((e, t) => Object(a.a)(e, {
						...c,
						variables: t
					}))(d(), {
						input: {
							subredditId: e,
							liveStreamingModeratorSettings: t
						}
					});
					if (!u.ok || !u.body.data.updateSubredditLiveStreamingModeratorSettings.ok) {
						const t = u.error && u.error.fields ? u.error.fields[0].msg : s.fbt._("Could not update community broadcasting settings", null, {
								hk: "3Uw7zu"
							}),
							r = Object(i.e)(t, l.b.Error);
						await n(Object(i.f)({
							...r,
							duration: i.a
						})), n(g({
							subredditId: e
						}))
					}
					const m = s.fbt._("Community broadcasting settings saved", null, {
							hk: "GTwrg"
						}),
						p = Object(i.e)(m, l.b.SuccessCommunity);
					await n(Object(i.f)({
						...p,
						duration: i.a
					})), n(_({
						subredditId: e
					}))
				}, E = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = [...n.whitelistedUsers.map(e => ({
						redditorName: e.name
					})), {
						redditorName: t
					}];
					await s(O(e, {
						whitelistedRedditors: a
					}, i())), await s(v(e))
				}, y = (e, t, n) => async (s, r, o) => {
					let {
						gqlContext: i
					} = o;
					const a = n.whitelistedUsers.filter(e => e.name !== t).map(e => ({
						redditorName: e.name
					}));
					await s(O(e, {
						whitelistedRedditors: a
					}, i())), await s(v(e))
				}
		},
		"./src/reddit/actions/structuredStyles/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return s
			})), n.d(t, "k", (function() {
				return r
			})), n.d(t, "j", (function() {
				return o
			})), n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "d", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			}));
			const s = "STRUCTURED_STYLES__STYLES_RESET_PENDING",
				r = "STRUCTURED_STYLES__STYLES_RESET_LOADED",
				o = "STRUCTURED_STYLES__STYLES_RESET_FAILED",
				i = "SUBREDDIT__STYLES_PENDING",
				a = "SUBREDDIT__STYLES_LOADED",
				d = "SUBREDDIT__STYLES_FAILED",
				c = "STRUCTURED_STYLES__DRAFT_REPLACED",
				l = "STRUCTURED_STYLES__DRAFT_UPDATED",
				u = "STRUCTURED_STYLES__EDITING_STOPPED",
				m = "STRUCTURED_STYLES__EDITING_STARTED",
				p = "STRUCTURED_STYLES__IMAGE_UPLOAD_ADDED",
				b = "STRUCTURED_STYLES__DIRTIED_BLADE_EDITOR",
				f = "STRUCTURED_STYLES__UNDIRTIED_BLADE_EDITOR",
				h = "STRUCTURED_STYLES__STYLES_UPDATED_LOADED"
		},
		"./src/reddit/actions/structuredStyles/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "l", (function() {
				return F
			})), n.d(t, "k", (function() {
				return q
			})), n.d(t, "j", (function() {
				return V
			})), n.d(t, "e", (function() {
				return K
			})), n.d(t, "d", (function() {
				return Y
			})), n.d(t, "g", (function() {
				return X
			})), n.d(t, "c", (function() {
				return $
			})), n.d(t, "f", (function() {
				return te
			})), n.d(t, "b", (function() {
				return ne
			})), n.d(t, "m", (function() {
				return se
			})), n.d(t, "a", (function() {
				return re
			})), n.d(t, "h", (function() {
				return oe
			})), n.d(t, "i", (function() {
				return ie
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/pick.js"),
				i = n.n(o),
				a = n("./node_modules/react-router-redux/es/index.js"),
				d = n("./src/lib/filterQueryParams/index.ts"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/lib/makeActionCreator/index.ts"),
				u = n("./src/reddit/actions/apiRequestState.ts"),
				m = n("./src/reddit/actions/imageUploads.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/endpoints/moderator/structuredStyles.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				h = n("./src/reddit/selectors/postFlair.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/actions/postFlairStyleTemplates/constants.ts");
			const v = Object(l.a)(g.c),
				x = Object(l.a)(g.b),
				O = Object(l.a)(g.a);
			var E = n("./src/reddit/actions/toaster.ts"),
				y = n("./src/reddit/actions/widgets/index.ts"),
				C = n("./src/reddit/constants/modals.ts"),
				j = n("./src/reddit/helpers/getGenericUploadError.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				I = n("./src/reddit/helpers/media/index.ts"),
				S = n("./src/reddit/models/Image/index.tsx"),
				w = n("./src/reddit/models/StructuredStyles/index.ts"),
				T = n("./src/reddit/models/Toast/index.ts"),
				N = n("./src/reddit/selectors/activeModalId.ts"),
				P = n("./src/reddit/selectors/platform.ts"),
				R = n("./src/reddit/selectors/structuredStyles.ts"),
				A = n("./src/reddit/selectors/user.ts"),
				M = n("./src/reddit/helpers/trackers/blade.ts"),
				L = n("./src/telemetry/index.ts"),
				D = n("./src/reddit/actions/structuredStyles/constants.ts");
			const F = Object(l.a)(D.m),
				U = {
					bannerBackgroundImage: ["bannerBackgroundImagePosition"],
					bannerPositionedImage: ["bannerPositionedImagePosition", "secondaryBannerPositionedImage"]
				},
				B = e => {
					const t = {
						...e
					};
					return Object.keys(e).forEach(n => {
						U[n] && !e[n] && U[n].forEach(e => t[e] = null)
					}), t
				},
				q = (e, t, n, s) => async (r, o, i) => {
					const {
						apiContext: a
					} = i, d = o(), l = B(t), p = d.structuredStyles.models[e];
					let f;
					for (const e in l)
						if (l[e] !== p[e]) {
							f = !0;
							break
						} if (!f) return;
					r(Object(u.h)(s));
					const h = Object(M.i)(n)(d);
					let g = null,
						v = null;
					try {
						(g = await Object(m.f)(o(), S.a.StructuredStyles)) && (v = Object(m.m)(g)(r, o, i))
					} catch (C) {
						const e = Object(j.a)("webSocket");
						return void r(Object(u.f)(s, e))
					}
					const x = Object(_.Y)(d, {
							subredditId: e
						}).name,
						O = await b.e(a(), x, l),
						y = {};
					if (O.ok) {
						if (v) try {
							await v
						} catch (C) {}
						const n = Object(R.f)(o(), {
							apiRequestId: s
						});
						for (const e in n)
							if (e in t) {
								const t = Object(R.g)(o(), {
									name: e
								});
								t && Object(S.j)(t) && (y[e] = n[e])
							} Object.keys(y).length && r(Q(y)), r(Object(u.e)(s)), r(F({
							subredditId: e,
							styles: {
								...l,
								...y
							}
						}))
					} else g && g.websocket.close(), r(Object(u.f)(s, O.error)), O.body && r(E.f({
						kind: T.b.Error,
						text: Object(c.a)(O.error, O.status)
					}));
					Object(L.a)({
						...h,
						actionInfo: {
							...h.actionInfo,
							success: O.ok
						}
					})
				}, G = Object(l.a)(D.l), H = Object(l.a)(D.k), W = Object(l.a)(D.j), V = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					t(G({
						subredditId: e
					}));
					const o = Object(_.Y)(n(), {
							subredditId: e
						}).name,
						i = await b.f(r(), o);
					if (i.ok) {
						const s = n().structuredStyles.models[e],
							r = s ? s.mobileKeyColor : null;
						t(H({
							subredditId: e,
							styles: {
								mobileKeyColor: r
							}
						}))
					} else t(W({
						subredditId: e,
						...i.error
					}))
				}, z = Object(l.a)(D.d), K = e => async (t, n, s) => {
					const r = n(),
						o = r.structuredStyles.models[e] || {},
						i = Object(A.eb)(r);
					t(z({
						isNightmodeOn: i,
						styles: o,
						subredditId: e
					})), le(e, !1)(t, n, s), (e => async (t, n, s) => {
						let {
							gqlContext: r
						} = s;
						const o = n(),
							i = Object(_.Y)(o, {
								subredditId: e
							});
						if (!i) return;
						const a = Object(h.d)(o, {
								subredditId: e
							}),
							d = a && a.templateIds;
						if (!d || !d.length) return;
						t(v({
							subredditId: e
						}));
						const c = await Object(b.a)(r(), i.name, d);
						if (c.ok) {
							const n = {};
							if (c.body) {
								const {
									data: e
								} = c.body;
								if (e && e.subreddit)
									for (const t of e.subreddit.postFlairStyleTemplates) n[t.id] = Object(f.a)(t)
							}
							t(x({
								subredditId: e,
								templates: n
							}))
						} else t(O({
							subredditId: e,
							error: c.error
						}))
					})(e)(t, n, s), Object(y.g)(e, !1)(t, n, s)
				}, Q = Object(l.a)(D.c), Y = e => async (t, n, s) => {
					const r = B(e),
						o = n();
					for (const e in r)
						if (Object(w.l)(e))
							if (r[e]) {
								if ("string" != typeof r[e]) {
									const o = r[e],
										i = await Object(S.e)(o);
									X(e, i)(t, n, s), r[e] = ""
								}
							} else {
								const n = Object(R.g)(o, {
									name: e
								});
								n && t(Object(m.h)(n))
							} t(Q(r))
				}, J = Object(l.a)(D.f), X = (e, t, n) => async (s, r, o) => {
					const i = r(),
						a = n || i.structuredStyles.isEditing,
						d = Object(_.Y)(i, {
							subredditId: a
						}).name;
					s(J({
						imageKey: e,
						uploadId: t.id
					})), s(Object(m.k)(t));
					const c = await b.d(o.apiContext(), d, t.file.name, e, await Object(I.h)(t.file));
					try {
						const n = await Object(m.g)(r(), c, t, S.a.StructuredStyles);
						if (n) {
							const t = n.url;
							s(Object(m.j)(n)), s(Q({
								[e]: t
							}))
						}
					} catch (l) {
						if (l instanceof Error) throw l;
						s(Object(m.i)(l))
					}
				}, Z = Object(l.a)(D.b), $ = (e, t, n) => async (s, o, a) => {
					const d = o(),
						c = d.structuredStyles.models[e] || {},
						l = d.structuredStyles.draft,
						u = Object(M.h)(t)(d);
					if (n) {
						const t = i()(c, n),
							o = {
								...r()(l, n),
								...t
							};
						s(Z({
							subredditId: e,
							styles: o
						}))
					} else {
						s(Z({
							subredditId: e,
							styles: c
						}))
					}
					Object(L.a)(u)
				}, ee = Object(l.a)(D.e), te = () => async (e, t, n) => {
					const s = t(),
						r = Object(A.fb)(s),
						o = !!Object(P.a)(s);
					if (e(ee({
							nightmodeTempUpdated: r
						})), o) return;
					const {
						url: i
					} = s.platform.currentPage;
					i && e(Object(a.c)(Object(d.a)(i, ["styling", "route"])))
				}, ne = Object(l.a)(D.a), se = Object(l.a)(D.n), re = () => async e => e(te()), oe = e => async (t, n) => {
					const s = n(),
						r = Object(R.i)(s);
					!Object(N.b)(C.a.BLADE_UNSAVED_CHANGES)(s) && r && (Object(R.a)(s, {
						subredditId: e
					}) ? t(Object(p.i)(C.a.BLADE_UNSAVED_CHANGES)) : t(re()))
				}, ie = e => async (t, n) => {
					const s = n();
					Object(R.i)(s) || t(Object(A.eb)(s) ? Object(p.i)(C.a.BLADE_NIGHTMODE) : K(e))
				}, ae = Object(l.a)(D.i), de = Object(l.a)(D.h), ce = Object(l.a)(D.g), le = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o,
						apiContext: i
					} = r;
					n(ae({
						subredditId: e
					}));
					const a = Object(_.Y)(s(), {
						subredditId: e
					});
					if (!a) return;
					if (!t) {
						const s = await b.c(i(), a.name, t);
						if (s.ok) {
							const t = s.body,
								r = t.data ? t.data.style : {};
							n(de({
								subredditId: e,
								styles: r
							}))
						} else n(ce({
							subredditId: e,
							...s.error
						}));
						return
					}
					const d = await b.b(o(), a.name);
					if (d.ok) {
						let t = {};
						if (d.body) {
							const {
								data: e
							} = d.body;
							e && e.subreddit && e.subreddit.styles && (t = Object(k.a)(e.subreddit.styles))
						}
						n(de({
							subredditId: e,
							styles: t
						}))
					} else n(ce({
						subredditId: e,
						...d.error
					}))
				}
		},
		"./src/reddit/actions/subreddit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "m", (function() {
				return J
			})), n.d(t, "l", (function() {
				return X
			})), n.d(t, "k", (function() {
				return Z
			})), n.d(t, "j", (function() {
				return $
			})), n.d(t, "i", (function() {
				return ee
			})), n.d(t, "h", (function() {
				return te
			})), n.d(t, "d", (function() {
				return ne
			})), n.d(t, "p", (function() {
				return ie
			})), n.d(t, "t", (function() {
				return ae
			})), n.d(t, "o", (function() {
				return le
			})), n.d(t, "r", (function() {
				return pe
			})), n.d(t, "g", (function() {
				return be
			})), n.d(t, "f", (function() {
				return fe
			})), n.d(t, "e", (function() {
				return he
			})), n.d(t, "q", (function() {
				return xe
			})), n.d(t, "b", (function() {
				return Oe
			})), n.d(t, "c", (function() {
				return Ee
			})), n.d(t, "a", (function() {
				return ye
			})), n.d(t, "u", (function() {
				return Ie
			})), n.d(t, "n", (function() {
				return Se
			})), n.d(t, "s", (function() {
				return we
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/lib/listingSort/index.ts"),
				d = n("./src/lib/makeActionCreator/index.ts"),
				c = n("./src/lib/makeListingKey/index.ts"),
				l = n("./src/reddit/actions/economics/helpers/async.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/modQueueTriggers/index.ts"),
				p = n("./src/reddit/actions/pages/subreddit.ts"),
				b = n("./src/reddit/actions/preferences.ts"),
				f = n("./src/reddit/actions/subredditModeration/modUserNotes.ts"),
				h = n("./src/reddit/actions/subredditRules/constants.ts"),
				_ = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/constants/history.ts"),
				v = n("./src/reddit/constants/modals.ts"),
				x = n("./src/reddit/constants/page.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				E = n("./src/reddit/constants/postLayout.ts"),
				y = n("./src/reddit/contexts/PageLayer/index.tsx"),
				C = n("./src/reddit/endpoints/governance/posts.ts"),
				j = n("./src/reddit/endpoints/messages/index.ts"),
				k = n("./src/reddit/endpoints/modQueue/index.ts"),
				I = n("./src/reddit/endpoints/page/subredditPage.ts"),
				S = n("./src/reddit/endpoints/subreddit/about.ts"),
				w = n("./src/reddit/endpoints/subreddit/rules.ts"),
				T = n("./src/reddit/endpoints/user/preferences.ts"),
				N = n("./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts"),
				P = n("./src/reddit/helpers/filterListingResponse/index.ts"),
				R = n("./src/reddit/helpers/getSubredditSortForListingKeyCreation/index.ts"),
				A = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				M = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				L = n("./src/reddit/helpers/trackers/feed.ts"),
				D = n("./src/reddit/models/Subreddit/index.ts"),
				F = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				U = n("./src/reddit/models/Toast/index.ts"),
				B = n("./src/reddit/models/User/index.ts"),
				q = n("./src/reddit/selectors/experiments/gqlSubredditPage.ts"),
				G = n("./src/reddit/selectors/moderatorPermissions.ts"),
				H = n("./src/reddit/selectors/profile.ts"),
				W = n("./src/reddit/selectors/subreddit.ts"),
				V = n("./src/reddit/selectors/user.ts"),
				z = n("./src/lib/isFakeSubreddit/index.ts"),
				K = n("./src/reddit/endpoints/page/popularFeed.ts"),
				Q = n("./src/reddit/selectors/experiments/popularGqlMigration.ts");
			const Y = {},
				J = "SUBREDDIT__MODEL_SUCCEEDED",
				X = "SUBREDDIT__MODEL_PENDING",
				Z = "SUBREDDIT__MODEL_FAILED",
				$ = "SUBREDDIT__MORE_POSTS_PENDING",
				ee = "SUBREDDIT__MORE_POSTS_LOADED",
				te = "SUBREDDIT__MORE_POSTS_FAILED",
				ne = "SUBREDDIT__META_FILTER_TOGGLED",
				se = Object(d.a)($),
				re = Object(d.a)(ee),
				oe = Object(d.a)(te),
				ie = Object(d.a)(ne),
				ae = Object(d.a)(h.b),
				de = Object(d.a)(h.c),
				ce = Object(d.a)(h.a),
				le = (e, t) => async (n, s) => {
					await (t === D.g.User ? n(ue(e)) : n(me(e)))
				}, ue = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = Object(H.o)(n(), e),
						i = await Object(w.c)(r(), e);
					if (i.ok) {
						const e = i.body;
						t(ae({
							rules: e,
							subredditId: o
						}))
					}
				}, me = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(W.I)(n(), e);
					t(de());
					const a = await Object(w.b)(o(), e);
					if (a.ok) {
						const e = a.body;
						t(ae({
							rules: e,
							subredditId: i
						}))
					} else {
						t(ce());
						const n = `error-block-${e}`;
						t(_.f({
							id: n,
							kind: U.b.Error,
							text: s.fbt._("An error has occurred. Please try again later", null, {
								hk: "Elbdz"
							})
						}))
					}
				}, pe = e => async (t, n, s) => {
					let {
						apiContext: r,
						gqlContext: d
					} = s;
					const {
						subredditName: u
					} = e;
					let p = e.t;
					const b = n(),
						h = Object(R.a)(e, b),
						_ = b.platform.currentPage ? b.platform.currentPage.queryParams : {},
						{
							currentPage: v
						} = b.platform,
						{
							countryCode: j,
							languageCode: k
						} = (null == v ? void 0 : v.urlParams) || {},
						S = Object(c.a)(u, h, {
							t: p,
							..._
						}),
						w = b.listings.postOrder.loadMore[S],
						T = b.listings.postOrder.listingSort[S];
					let A = h;
					if (T && !A) {
						const e = Object(a.d)(T.sort);
						A = e.sort, p = e.timeSort
					}
					const M = b.listings.postOrder.api.pending[S],
						{
							fetchedTokens: D
						} = b.listings.postOrder,
						F = !(!D[S] || !D[S][w.token]);
					if (M || F) return;
					if (A === i.bb.AWARDED && u === x.g) return;
					t(se({
						key: S,
						fetchedToken: w.token
					}));
					const U = {
							after: w.token,
							dist: w.dist,
							forceGeopopular: u === x.d.Popular,
							layout: E.e[Object(y.U)(b, {})],
							sort: A,
							t: p,
							...o()(_, [...O.q, O.l])
						},
						B = Object(q.a)(b);
					let H;
					H = Object(z.c)(u, {
						countryCode: j,
						languageCode: k
					}) && (Object(Q.a)(b) || Object(Q.b)(b)) ? () => Object(K.a)(d(), Object(I.c)(b, u, U, !0)) : B ? () => Object(I.b)(d(), Object(I.c)(b, u, {
						...U,
						limit: E.a
					}), Object(V.ab)(b)) : () => Object(I.a)(r(), u, U);
					const Y = await H(),
						J = {
							...Y.body,
							...Object(P.a)(b, S, Y.body)
						};
					if (Y.ok) {
						if (!B) {
							const e = await Object(N.a)(r(), J.posts, b);
							J.posts = e
						}
						let e;
						const s = J.postIds.filter(e => !!J.posts[e].isMeta),
							o = Object(W.I)(n(), u);
						if (s.length) {
							const t = await Object(C.a)(r(), o, s);
							t.ok && (e = t.body)
						}
						const i = Object(G.h)(b, {
							subredditId: Object(W.I)(b, u)
						});
						if (!B && i && t(Object(m.a)({
								postIds: J.postIds
							})), t(re({
								fetchedToken: w.token,
								key: S,
								meta: b.meta,
								governance: e,
								...J
							})), Object(G.i)(b, o)) {
							let e;
							B || (e = await Object(I.b)(d(), Object(I.c)(b, u, {
								...U,
								limit: E.a
							}), Object(V.ab)(b)));
							const n = B ? J : e.body;
							if (B ? n : e.ok) {
								const e = n.postIds.map(e => n.posts[e].lastAuthorModNote);
								t(Object(f.e)({
									subredditId: o,
									nodes: e
								}))
							}
						}
						await t(Object(l.a)({
							subredditId: o,
							postIds: J.postIds,
							skip: ["communityDetails", "subscription"]
						})), Object(L.b)(g.a.NextPageLoad)(n())
					} else {
						t(oe({
							error: Y.error,
							fetchedToken: w.token,
							key: S,
							...J
						}));
						const e = Y.error;
						Object(L.a)(e ? `${Y.status||"000"}: ${e.type}` : "000: UNKNOWN_ERROR")(n())
					}
				}, be = "SUBSCRIPTION__MODERATED_SUBREDDITS_PENDING", fe = "SUBSCRIPTION__MODERATED_SUBREDDITS_LOADED", he = "SUBSCRIPTION__MODERATED_SUBREDDITS_FAILED", _e = Object(d.a)(be), ge = Object(d.a)(fe), ve = Object(d.a)(he), xe = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subreddits.moderated.api.fetched) return;
					e(_e());
					const o = await Object(k.c)(s(), i.wb.Modqueue, {
						moderated: !0,
						moderated_limit: 50
					});
					o.ok ? e(ge(o.body)) : e(ve({
						error: o.error
					}))
				}, Oe = "SUBREDDIT__ABOUT_PENDING", Ee = "SUBREDDIT__ABOUT_SUCCEEDED", ye = "SUBREDDIT__ABOUT_FAILED", Ce = Object(d.a)(Oe), je = Object(d.a)(Ee), ke = Object(d.a)(ye), Ie = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n();
					if (Object(W.z)(o, {
							subredditName: e
						}) || o.subreddits.api.about.error[e.toLowerCase()] || o.subreddits.api.about.pending[e.toLowerCase()]) return;
					t(Ce({
						subredditName: e
					}));
					const i = !Object(W.I)(o, e),
						a = await Object(S.a)(r(), e, i);
					if (a.ok) {
						const n = a.body.data.subreddit,
							s = Object(A.a)(n),
							r = i ? Object(M.a)(n) : void 0;
						t(je({
							subredditName: e,
							subreddits: r ? {
								[r.id]: r
							} : void 0,
							data: s
						}))
					} else t(ke({
						subredditName: e,
						error: a.error
					}))
				}, Se = (e, t, n) => async (s, r, o) => {
					let {
						apiContext: i
					} = o;
					var a;
					const d = e.substring(2),
						c = n === F.e.View ? null === (a = Object(V.g)(r(), d)) || void 0 === a ? void 0 : a.subredditId : Object(W.I)(r(), d),
						l = Object(V.l)(r());
					if (l && c) {
						const e = ((e, t, n, s) => {
							return {
								to: `/r/${e}`,
								subject: `[join] I would like to join ${e}`,
								text: n + "\n\n   *To approve this user*, visit [the approved users page for r/" + e + "](https://www.reddit.com/r/" + e + "/about/contributors?user=" + t + ') and click "ADD USER".\n    Approving this user gives them permission to ' + s + ". You can change these community restrictions from the [community settings](/r/" + e + "/about/edit) page.\n\n   To get more information about this user, visit the profile page of [u/" + t + "](/u/" + t + ") or reply to this message to start a conversation."
							}
						})(d, Object(B.e)(l), t, n);
						if ((await Object(j.b)(i(), e)).ok) {
							const e = new Date,
								t = {
									isContributorRequestTimestamp: e.setDate(e.getDate())
								};
							s(Object(b.G)({
								subredditId: c,
								prefs: t
							})), Object(T.j)(c, t, i()), n !== F.e.View && s(Object(u.i)(v.a.CONTRIBUTOR_REQUEST_PENDING))
						}
					}
				}, we = e => async (t, n) => {
					const s = n(),
						{
							subredditName: r
						} = e,
						o = e.t,
						i = Object(R.a)(e, s),
						a = s.platform.currentPage ? s.platform.currentPage.queryParams : Y,
						d = Object(c.a)(r, i, {
							t: o,
							...a
						}),
						l = {
							t: o,
							sort: i,
							isRefresh: !0,
							...a
						};
					await t(Object(p.subredditDataRequested)(d, r, l, !0))
				}
		},
		"./src/reddit/actions/subreddit/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "o", (function() {
				return i
			})), n.d(t, "n", (function() {
				return a
			})), n.d(t, "w", (function() {
				return d
			})), n.d(t, "v", (function() {
				return c
			})), n.d(t, "r", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "u", (function() {
				return p
			})), n.d(t, "t", (function() {
				return b
			})), n.d(t, "s", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "l", (function() {
				return _
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "B", (function() {
				return v
			})), n.d(t, "A", (function() {
				return x
			})), n.d(t, "C", (function() {
				return O
			})), n.d(t, "D", (function() {
				return E
			})), n.d(t, "E", (function() {
				return y
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "d", (function() {
				return j
			})), n.d(t, "y", (function() {
				return k
			})), n.d(t, "z", (function() {
				return I
			})), n.d(t, "x", (function() {
				return S
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "F", (function() {
				return T
			})), n.d(t, "G", (function() {
				return N
			})), n.d(t, "i", (function() {
				return P
			})), n.d(t, "h", (function() {
				return R
			})), n.d(t, "g", (function() {
				return A
			})), n.d(t, "f", (function() {
				return M
			}));
			const s = "SUBREDDIT__ADD_TOP_SUBREDDIT_MODELS",
				r = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS",
				o = "SUBREDDIT__ADD_TOP_SUBREDDIT_RANKINGS_PAGE_INFO",
				i = "SUBREDDIT__POSTS_LOADED",
				a = "SUBREDDIT__POSTS_SET_FAILED",
				d = "SUBREDDIT__SUBREDDITS_POSTS_LOADED",
				c = "SUBREDDIT__SUBREDDITS_POSTS_SET_FAILED",
				l = "SUBREDDIT__RANKINGS_PENDING",
				u = "SUBREDDIT__RANKINGS_LOADED",
				m = "SUBREDDIT__RANKINGS_FAILED",
				p = "SUBREDDIT__SIMILAR_SUBREDDITS_PENDING",
				b = "SUBREDDIT__SIMILAR_SUBREDDITS_LOADED",
				f = "SUBREDDIT__SIMILAR_SUBREDDITS_FAILED",
				h = "SUBREDDIT__ONBOARDING_SUBREDDITS_PENDING",
				_ = "SUBREDDIT__ONBOARDING_SUBREDDITS_LOADED",
				g = "SUBREDDIT__ONBOARDING_SUBREDDITS_FAILED",
				v = "SUBREDDIT__EDIT_REQUESTED",
				x = "SUBREDDIT__EDIT_FAILED",
				O = "SUBREDDIT__EDIT_SUCCESS",
				E = "SUBREDDIT_QUESTIONS_LOADED",
				y = "SUBREDDIT_SURVEY_ANSWERED",
				C = "SUBREDDIT_SURVEY_DISMISSED",
				j = "SUBREDDIT_SURVEY_DISMISS",
				k = "SUBREDDIT_ABOUT_INFO_UPDATE__PENDING",
				I = "SUBREDDIT_ABOUT_INFO_UPDATE__SUCCESS",
				S = "SUBREDDIT_ABOUT_INFO_UPDATE__FAILED",
				w = "MUTE_SUBREDDIT__SUCCESS",
				T = "UNMUTE_SUBREDDIT_SUCCESS",
				N = "UPDATE_MUTE_AND_NOTIFICATION_LEVEL_SUCCESS",
				P = "MUTED_SUBREDDIT_LOADED__SUCCESS",
				R = "MUTED_SUBREDDIT_LOADED__FAILED",
				A = "MUTED_SUBREDDIT_LIST__UNMUTE",
				M = "MUTED_SUBREDDIT_LIST__MUTE"
		},
		"./src/reddit/actions/subreddit/muting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return k
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "e", (function() {
				return w
			})), n.d(t, "g", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "f", (function() {
				return P
			})), n.d(t, "b", (function() {
				return R
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/toaster.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/redditGQL/operations/DeleteSubredditMuteSettings.json"),
				d = n("./src/redditGQL/operations/MutedSubreddits.json"),
				c = n("./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json"),
				l = n("./src/redditGQL/operations/UpdateSubredditMuteSettings.json");
			const u = (e, t) => Object(i.a)(e, {
					...l,
					variables: {
						input: {
							subredditId: t
						}
					}
				}),
				m = (e, t) => Object(i.a)(e, {
					...a,
					variables: {
						input: {
							subredditId: t
						}
					}
				});
			var p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/actions/subreddit/constants.ts"),
				f = n("./src/reddit/actions/subreddit/notifications.ts"),
				h = n("./src/reddit/selectors/subreddit.ts");
			const _ = e => Object(o.f)({
					id: e,
					kind: p.b.Error,
					duration: o.a,
					text: s.fbt._("An error has occured. Please try again later", null, {
						hk: "2FpsLy"
					})
				}),
				g = (e, t) => Object(o.f)({
					kind: p.b.SuccessCommunityGreen,
					text: s.fbt._("Muted r/{subreddit name}", [s.fbt._param("subreddit name", e)], {
						hk: "Mg9mO"
					}),
					...t ? {
						buttonText: s.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				}),
				v = (e, t) => Object(o.f)({
					kind: p.b.SuccessCommunityGreen,
					text: s.fbt._("Unmuted r/{subreddit name}", [s.fbt._param("subreddit name", e)], {
						hk: "Fhnht"
					}),
					...t ? {
						buttonText: s.fbt._("Undo", null, {
							hk: "2siioQ"
						}),
						buttonAction: t
					} : {}
				});
			var x = n("./src/reddit/endpoints/subreddit/about.ts");
			const O = Object(r.a)(b.i),
				E = Object(r.a)(b.h),
				y = Object(r.a)(b.G),
				C = (Object(r.a)(b.j), Object(r.a)(b.F), Object(r.a)(b.g)),
				j = Object(r.a)(b.f),
				k = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						if ((await u(i(), t)).ok) s && s(), e(g(n, I({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(_(`error-muting-${t}`))
						}
					}
				},
				I = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						if ((await m(i(), t)).ok) s && s(), e(v(n, k({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(_(`error-muting-${t}`))
						}
					}
				},
				S = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						if ((await u(i(), t)).ok) s && s(), e(Object(f.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !0
								}
							}
						})), e(g(n, w({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(_(`error-muting-${t}`))
						}
					}
				},
				w = e => {
					let {
						subredditId: t,
						subredditName: n,
						successCallback: s
					} = e;
					return async (e, r, o) => {
						let {
							gqlContext: i
						} = o;
						if ((await m(i(), t)).ok) s && s(), e(Object(f.c)({
							subredditAboutInfo: {
								[t]: {
									isMuted: !1
								}
							}
						})), e(v(n, S({
							subredditId: t,
							subredditName: n
						})));
						else {
							e(_(`error-muting-${t}`))
						}
					}
				},
				T = e => {
					let {
						subredditId: t,
						notificationLevel: n
					} = e;
					return async (e, r, a) => {
						let {
							gqlContext: d
						} = a;
						const l = Object(f.a)(n);
						(await ((e, t, n) => Object(i.a)(e, {
							...c,
							variables: {
								input: {
									...n,
									subredditId: t
								}
							}
						}))(d(), t, l)).ok ? (e(y({
							subredditId: t,
							notificationLevel: n
						})), e(Object(o.f)({
							kind: p.b.SuccessCommunityGreen,
							text: Object(f.b)(n)
						}))) : e(Object(o.f)({
							kind: p.b.Error,
							text: s.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
								hk: "4avFFV"
							})
						}))
					}
				},
				N = () => async (e, t, n) => {
					let {
						gqlContext: r
					} = n;
					const a = await (e => Object(i.a)(e, d))(r());
					if (a.ok && a.body && a.body.data) {
						const {
							data: t
						} = a.body, n = (t && t.identity.mutedSubreddits).edges.map(e => e.node);
						e(O({
							nodes: n
						}))
					} else e(E()), e(Object(o.f)({
						duration: o.a,
						kind: p.b.Error,
						text: s.fbt._("Failed to get muted subreddits, please try again.", null, {
							hk: "2dCj3Q"
						})
					}))
				}, P = e => {
					let {
						subredditId: t,
						subredditName: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = await m(o(), t),
							{
								data: a
							} = i.body;
						if (i.ok && a.deleteSubredditMuteSettings.ok) e(C(t)), e(v(n));
						else {
							e(_(`error-unmuting-${t}`))
						}
					}
				}, R = e => {
					let {
						subredditName: t
					} = e;
					return async (e, n, r) => {
						let {
							gqlContext: i
						} = r;
						const a = n(),
							d = Object(h.t)(a).find(e => e.name.toLowerCase() === t.toLowerCase());
						if (d) {
							const t = d.name,
								n = `error-muting-duplicate-${t}`;
							return e(Object(o.f)({
								id: n,
								kind: p.b.Error,
								duration: o.a,
								text: s.fbt._("Sorry, r/{subreddit name} is already muted.", [s.fbt._param("subreddit name", t)], {
									hk: "4n64wl"
								})
							}))
						}
						const c = await Object(x.a)(i(), t, !0),
							{
								data: l
							} = c.body,
							m = l && l.subreddit;
						if (!c.ok || null === m) {
							return e(((e, t) => Object(o.f)({
								id: e,
								kind: p.b.Error,
								duration: o.a,
								text: s.fbt._("Sorry, r/{subreddit name} isn't a community.", [s.fbt._param("subreddit name", t)], {
									hk: "3UtglL"
								})
							}))(`error-muting-${t}`, t))
						}
						const b = m.id,
							f = await u(i(), b),
							{
								data: v
							} = f.body;
						if (f.ok && v.updateSubredditMuteSettings.ok) e(j([m])), e(g(m.name));
						else {
							e(_(`error-muting-${b}`))
						}
					}
				}
		},
		"./src/reddit/actions/subreddit/notifications.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "d", (function() {
				return _
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/notificationSettingsLayout/index.ts"),
				i = n("./src/reddit/actions/notificationsInbox/index.ts"),
				a = n("./src/reddit/actions/subreddit/constants.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/models/Toast/index.ts");
			const m = Object(r.a)(a.z),
				p = Object(r.a)(a.y),
				b = Object(r.a)(a.x),
				f = e => {
					switch (e) {
						case l.c.FREQUENT:
							return {
								isSubredditUpdatesInterestingPostEnabled: !0, isUpdateFromSubredditEnabled: !0
							};
						case l.c.LOW:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !0
							};
						case l.c.OFF:
						default:
							return {
								isSubredditUpdatesInterestingPostEnabled: !1, isUpdateFromSubredditEnabled: !1
							}
					}
				},
				h = e => {
					switch (e) {
						case l.c.OFF:
							return s.fbt._("Unfollowed. You won’t get updates on new activity anymore.", null, {
								hk: "3e1CJR"
							});
						case l.c.FREQUENT:
							return s.fbt._("Followed! Now you’ll get updates on new activity.", null, {
								hk: "3JzOOa"
							});
						case l.c.LOW:
							return s.fbt._("Success! You will see fewer notifications from this community in the future.", null, {
								hk: "4x3TS8"
							});
						default:
							return null
					}
				};
			const _ = e => {
				let {
					subredditId: t,
					notificationLevel: n,
					successCallback: r,
					undoCallback: a
				} = e;
				return async (e, l, _) => {
					let {
						gqlContext: g
					} = _;
					var v, x, O;
					e(p());
					const E = f(n),
						y = await Object(c.b)(g(), t, E);
					if ((null === (x = null === (v = y.error) || void 0 === v ? void 0 : v.fields) || void 0 === x ? void 0 : x.length) || function(e) {
							return Boolean(e && e.data && e.data.updateSubredditNotificationSettings)
						}(y.body) && (null === (O = y.body.data.updateSubredditNotificationSettings.errors) || void 0 === O ? void 0 : O.length)) return e(b()), e(Object(d.f)({
						kind: u.b.Error,
						text: s.fbt._("Failed to change the frequency of notifications from this community, please try again.", null, {
							hk: "4avFFV"
						})
					}));
					y.ok && (e(Object(o.c)({
						subredditId: t,
						notificationLevel: n
					})), e(m({
						subredditAboutInfo: {
							[t]: {
								notificationLevel: n
							}
						}
					})), r && r(), e(a ? Object(d.f)(Object(d.e)(h(n), u.b.Undo, s.fbt._("Undo", null, {
						hk: "46OwLP"
					}), Object(i.i)(t, a))) : Object(d.f)(Object(d.e)(h(n), u.b.SuccessCommunityGreen))))
				}
			}
		},
		"./src/reddit/actions/subreddit/questions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/GetSubredditQuestions.json"),
				o = n("./src/reddit/actions/subreddit/constants.ts");
			const i = e => async (t, n, o) => {
				let {
					gqlContext: i
				} = o;
				var d;
				const c = (await ((e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}))(i(), {
					id: e
				})).body;
				a(t, e, null === (d = c.data) || void 0 === d ? void 0 : d.subredditInfoById)
			};

			function a(e, t, n) {
				const s = null == n ? void 0 : n.answerableQuestions,
					r = null == n ? void 0 : n.contentRatingSurvey,
					i = null == n ? void 0 : n.communityProgressModule;
				(s || r || i) && e({
					type: o.D,
					payload: {
						id: t,
						questions: s,
						survey: r,
						progressModule: i
					}
				})
			}
		},
		"./src/reddit/actions/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return T
			})), n.d(t, "c", (function() {
				return N
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "b", (function() {
				return R
			})), n.d(t, "a", (function() {
				return A
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "g", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			})), n.d(t, "i", (function() {
				return q
			}));
			var s = n("./node_modules/react-router-redux/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/postCreation/general.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/actions/postCreation/submit.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ModWelcomeTooltip/index.tsx"),
				u = n("./src/reddit/components/SubredditForkingCTA/index.tsx"),
				m = n("./src/reddit/constants/experiments.ts"),
				p = n("./src/reddit/constants/modals.ts"),
				b = n("./src/lib/makeApiRequest/index.ts"),
				f = n("./src/lib/omitHeaders/index.ts"),
				h = n("./src/reddit/constants/headers.ts"),
				_ = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const g = e => ({
				public_description: e.publicDescription,
				name: e.name,
				type: e.type,
				over_18: e.over18,
				restrict_commenting: e.restrictCommenting,
				restrict_posting: e.restrictPosting,
				existing_tags: e.existingTags.join(","),
				new_tags: e.newTags.join(","),
				primary_tag: e.primaryTagId
			});
			var v = n("./src/lib/makeGqlRequest/index.ts"),
				x = n("./src/redditGQL/operations/ValidateCreateSubreddit.json");
			var O = n("./src/reddit/helpers/correlationIdTracker.ts"),
				E = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				y = n("./src/reddit/selectors/experiments/newCommunityProgressV3.ts"),
				C = n("./src/reddit/selectors/meta.ts"),
				j = n("./src/reddit/selectors/posts.ts"),
				k = n("./src/reddit/selectors/subreddit.ts"),
				I = n("./src/reddit/selectors/user.ts"),
				S = n("./src/telemetry/index.ts"),
				w = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts");
			const T = "SUBREDDIT__CREATE_SET_INITIAL_CROSSPOST",
				N = "SUBREDDIT__CREATE_PENDING",
				P = "SUBREDDIT__CREATE_SUCCEEDED",
				R = "SUBREDDIT__CREATE_FAILED",
				A = "SUBREDDIT__CREATE_CLEARED",
				M = Object(o.a)(N),
				L = Object(o.a)(P),
				D = Object(o.a)(R),
				F = Object(o.a)(A),
				U = Object(o.a)(T),
				B = e => async (t, n, o) => {
					let {
						apiContext: v
					} = o;
					var x;
					const T = n(),
						{
							name: N,
							type: P,
							crosspostId: R
						} = e;
					if (Object(k.l)(T)) return;
					t(M({
						subredditName: N
					}));
					const A = await ((e, t) => Object(b.a)(Object(f.a)(e, [h.a]), {
						endpoint: Object(_.a)(`${e.apiUrl}/api/v1/subreddit/create_subreddit`),
						method: r.ob.POST,
						data: g(t)
					}))(v(), e);
					if (A.ok) {
						const n = A.body,
							o = n.fullname;
						Object(S.a)(Object(E.d)(P, e, o)(T)), t(L({
							subredditName: N
						}));
						const b = await Object(y.b)(T);
						if (R) {
							const e = Object(j.G)(T, {
								postId: R
							});
							t(Object(i.h)(e.title)), t(Object(i.g)({
								submissionType: r.bc.CROSSPOST
							})), await t(Object(d.d)({
								destSubreddit: {
									...n,
									isProfile: !1
								},
								sourcePostId: R,
								postFieldValidationPending: Promise.resolve()
							})), Object(u.b)(R)
						}
						await t(Object(s.b)(`${n.path}`)), b ? b === m.Me.NewModule && t(Object(c.h)({
							tooltipId: l.MOD_WELCOME_TOOLTIP_ID
						})) : (t(Object(a.h)(p.a.POST_FLOW_UPSELL_MODAL_ID)), Object(S.a)(Object(E.g)()(T))), Object(O.b)(O.a.SubredditCreation), t(Object(w.f)(o, null !== (x = Object(I.cb)(T)) && void 0 !== x ? x : Object(C.j)(T)))
					} else A.error && Object(S.a)(Object(E.h)(A.error.type, N)(T)), t(D({
						subredditName: N,
						error: A.error
					}))
				}, q = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					const o = n(),
						i = {
							name: e
						},
						a = await ((e, t) => Object(v.a)(e, {
							...x,
							variables: t
						}))(r(), {
							input: i
						});
					let d = null;
					if (a.ok) {
						d = a.body.data.validateCreateSubredditInput.fieldErrors
					}
					if (d) {
						const n = {
							fields: [{
								field: d[0].field,
								msg: d[0].message
							}],
							type: d[0].code
						};
						t(D({
							subredditName: e,
							error: n
						})), n && Object(S.a)(Object(E.h)(n.type, e)(o))
					} else await t(F())
				}
		},
		"./src/reddit/actions/subredditDuplicates.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/config.ts"),
				i = n("./src/lib/makeApiRequest/index.ts"),
				a = n("./src/reddit/models/Post/index.ts");
			var d = n("./src/reddit/models/Duplicates/index.ts"),
				c = n("./src/reddit/models/Subreddit/index.ts"),
				l = n("./src/reddit/selectors/profile.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");
			const m = "SUBREDDIT_DUPLICATES_IN_SUBREDDIT_LOADED",
				p = (Object(s.a)("SUBREDDIT_DUPLICATES_IN_SUBREDDIT_PENDING"), Object(s.a)(m)),
				b = (e, t) => async (n, s, m) => {
					let {
						apiContext: b
					} = m;
					const f = Object(u.Y)(s(), {
						subredditId: e
					}) || Object(l.r)(s(), {
						profileId: e
					});
					if (!f) return;
					const h = {
							crossposts_only: !0,
							sort: "new",
							sr: Object(c.i)(f) ? r.qc + f.name : f.name
						},
						_ = await ((e, t, n) => Object(i.a)(e, {
							data: n,
							endpoint: `${o.a.gatewayUrl}/desktopapi/v1/duplicates/${Object(a.D)(t)}`,
							method: r.ob.GET
						}))(b(), t, h);
					if (_.ok) {
						const s = _.body;
						n(p({
							distinguishKey: Object(d.a)(t, h),
							postIds: s.postIds,
							posts: s.posts,
							profiles: s.profiles,
							subreddits: s.subreddits,
							subredditId: e
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedSubmitters.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "d", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const p = (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: Object(m.a)(`${e.apiUrl}/api/v1/${t}/contributors`),
				method: d.ob.GET,
				data: n
			});
			var b = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				f = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/actions/subredditModeration/constants.ts");
			const g = Object(i.a)(_.g),
				v = Object(i.a)(_.f),
				x = Object(i.a)(_.e),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(f.e)(e, a),
							c = i.pages.modHub.approvedSubmitters.fetchedTokens[d];
						if (i.pages.modHub.approvedSubmitters.api.pending[d] || c) return;
						n(g({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await p(o(), l, t);
						u.ok ? n(v({
							...u.body,
							fetchedToken: a
						})) : n(x({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				E = Object(i.a)(_.j),
				y = Object(i.a)(_.i),
				C = Object(i.a)(_.h),
				j = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(b.a)(t)
						};
					n(E());
					const d = await p(o(), i, a);
					d.ok ? n(y(d.body)) : n(C(d.error))
				}, k = Object(i.a)(_.d), I = Object(i.a)(_.k), S = (e, t) => async (n, r, i) => {
					let {
						apiContext: m
					} = i;
					const f = r(),
						_ = f.subreddits.models[e].url,
						g = f.subreddits.models[e].name;
					t = Object(b.a)(t);
					const v = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: d.ob.POST,
						data: {
							api_type: "json",
							name: n,
							type: "contributor"
						}
					}))(m(), _, t);
					if (v.ok) {
						const e = {
							username: t
						};
						n(Object(a.f)({
							kind: h.b.SuccessMod,
							text: s.fbt._("Successfully added an approved submitter", null, {
								hk: "4gruK7"
							})
						}));
						const r = await p(m(), g, e);
						r.ok && n(k(r.body))
					} else {
						const e = o()(v, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(a.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, w = (e, t) => async (n, r, i) => {
					let {
						apiContext: m
					} = i;
					const p = r().subreddits.models[e].url,
						b = await ((e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: d.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "contributor"
							}
						}))(m(), p, t);
					if (b.ok) n(I({
						subredditId: e,
						userId: t
					}));
					else {
						const e = o()(b, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(a.f)({
							kind: h.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditModeration/approvedTalkHosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return v
			})), n.d(t, "a", (function() {
				return x
			})), n.d(t, "c", (function() {
				return O
			}));
			var s = n("./src/lib/makeActionCreator/index.ts"),
				r = n("./src/lib/sentry/index.ts"),
				o = n("./src/reddit/actions/subredditModeration/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/redditor/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/AddApprovedTalkHost.json"),
				l = n("./src/redditGQL/operations/RemoveApprovedTalkHost.json"),
				u = n("./src/redditGQL/operations/SubredditApprovedTalkHosts.json");
			var m = n("./src/reddit/models/SubredditModeration/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts");
			const {
				fbt: b
			} = n("./node_modules/fbt/lib/FbtPublic.js"), f = Object(s.a)(o.n), h = Object(s.a)(o.m), _ = Object(s.a)(o.l), g = Object(s.a)(o.o), v = e => async (t, n, s) => {
				let {
					gqlContext: o
				} = s;
				var a;
				const c = n(),
					{
						subredditId: l,
						before: g,
						forceRefresh: v
					} = e,
					x = Object(m.f)(l, g),
					O = c.pages.modHub.approvedTalkHosts.fetchedTokens[x];
				if (!(c.pages.modHub.approvedTalkHosts.api.pending[x] || O && !v)) {
					t(f({
						subredditId: l,
						fetchedToken: g
					}));
					try {
						const e = await ((e, t) => Object(d.a)(e, {
							...u,
							variables: {
								...t,
								last: 20
							}
						}))(o(), {
							subredditId: l,
							before: g
						});
						if (e.ok) {
							const {
								data: {
									subredditInfoById: n
								}
							} = e.body;
							if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (a = null == n ? void 0 : n.talkApprovedHostMembers) || void 0 === a ? void 0 : a.edges)) {
								const {
									edges: e,
									pageInfo: s
								} = n.talkApprovedHostMembers, r = [];
								e.forEach(e => {
									e && e.node && r.push(e.node)
								}), t(h({
									subredditId: l,
									approvedTalkHosts: r,
									fetchedToken: g,
									loadMoreToken: s.hasNextPage ? s.endCursor : null,
									forceRefresh: v
								}))
							}
							const {
								errors: s
							} = e.body;
							s && s.length && r.c.captureException(s)
						} else t(_({
							subredditId: l,
							fetchedToken: g
						})), t(Object(i.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					} catch (E) {
						r.c.captureException(E), t(Object(i.f)({
							kind: p.b.Error,
							text: b._("Oops, something went wrong. Try again.", null, {
								hk: "2VQ3RW"
							}),
							duration: 3e3
						}))
					}
				}
			}, x = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const l = await Object(a.a)(o(), {
					name: t
				});
				if (!l) return void n(Object(i.f)({
					kind: p.b.Error,
					text: b._("{username} doesn’t exist. Double-check your spelling.", [b._param("username", t)], {
						hk: "1sikIN"
					}),
					duration: 3e3
				}));
				const u = {
						subredditId: e,
						userId: l
					},
					m = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(o(), u);
				if (m.ok) {
					if (!m.body) return void n(Object(i.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "28RRuF"
						}),
						duration: 3e3
					}));
					n(v({
						subredditId: e,
						forceRefresh: !0
					})), n(Object(i.f)({
						kind: p.b.SuccessMod,
						text: b._("User approved!", null, {
							hk: "PeRM2"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = m.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(i.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}, O = (e, t) => async (n, s, r) => {
				let {
					gqlContext: o
				} = r;
				const a = {
						subredditId: e,
						userId: t
					},
					c = await ((e, t) => Object(d.a)(e, {
						...l,
						variables: t
					}))(o(), a);
				if (c.ok) {
					if (!c.body) return void n(Object(i.f)({
						kind: p.b.Error,
						text: b._("Something went wrong", null, {
							hk: "1o9j5I"
						}),
						duration: 3e3
					}));
					n(g({
						subredditId: e,
						userId: t
					})), n(Object(i.f)({
						kind: p.b.SuccessMod,
						text: b._("User removed from approved hosts list", null, {
							hk: "1RWvrp"
						}),
						duration: 3e3
					}))
				} else {
					const {
						errors: e
					} = c.body, t = e[0] ? e[0].message : b._("Something went wrong", null, {
						hk: "HsnIE"
					});
					n(Object(i.f)({
						kind: p.b.Error,
						text: t,
						duration: 3e3
					}))
				}
			}
		},
		"./src/reddit/actions/subredditModeration/ban.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return $
			})), n.d(t, "d", (function() {
				return se
			})), n.d(t, "b", (function() {
				return ie
			})), n.d(t, "e", (function() {
				return ae
			})), n.d(t, "a", (function() {
				return de
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/get.js"),
				o = n.n(r),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/apiRequestState.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/subreddit.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/modals.ts"),
				m = n("./src/lib/constants/index.ts"),
				p = n("./src/lib/makeApiRequest/index.ts"),
				b = n("./src/lib/omitHeaders/index.ts"),
				f = n("./src/reddit/constants/headers.ts"),
				h = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				_ = n("./src/reddit/models/RichTextJson/addRTJParam.ts");
			const g = (e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
				endpoint: Object(h.a)(Object(_.a)(`${e.apiUrl}/api/v1/${t}/banned`)),
				method: m.ob.GET,
				data: n
			});
			var v = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				x = n("./src/reddit/models/SubredditModeration/index.ts"),
				O = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/reddit/selectors/bannedUser.ts"),
				C = n("./src/reddit/selectors/subreddit.ts"),
				j = n("./src/reddit/selectors/user.ts"),
				k = n("./src/reddit/actions/subredditModeration/constants.ts"),
				I = n("./src/lib/initializeClient/installReducer.ts"),
				S = n("./node_modules/redux/es/redux.js");
			var w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.s:
					case k.r:
						return null;
					case k.q:
						return t.payload;
					default:
						return e
				}
			};
			const T = {};
			var N = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : T,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.s: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(x.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case k.r:
						case k.q: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(x.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				P = Object(S.c)({
					error: w,
					pending: N
				});
			const R = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(x.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				M = n("./src/reddit/actions/inContextModeration.ts");
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case M.a:
						return t.payload;
					default:
						return e
				}
			};
			const D = {};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				U = n("./node_modules/icepick/icepick.js");
			const B = {};
			var q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : B,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.p:
					case k.r: {
						const {
							subredditId: n,
							bannedUsers: s
						} = t.payload;
						return Object(U.merge)(e, {
							[n]: s
						})
					}
					case k.w: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(U.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var G = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case k.v:
					case k.u:
						return null;
					case k.t:
						return t.payload;
					default:
						return e
				}
			};
			var H = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.v:
							return !0;
						case k.u:
						case k.t:
							return !1;
						default:
							return e
					}
				},
				W = Object(S.c)({
					error: G,
					pending: H
				});
			var V = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.v:
						case k.t:
							return null;
						case k.u: {
							const e = t.payload.bannedUserIds[0];
							return e ? t.payload.bannedUsers[e] : null
						}
						default:
							return e
					}
				},
				z = Object(S.c)({
					api: W,
					result: V
				});
			const K = {};
			var Q = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : K,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case k.r: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case k.w: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case k.p: {
							const {
								subredditId: n,
								bannedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Y = Object(S.c)({
					api: P,
					fetchedTokens: A,
					inContext: L,
					loadMore: F,
					models: q,
					search: z,
					userOrder: Q
				});
			Object(I.a)({
				features: {
					banned: Y
				}
			});
			const J = Object(i.a)(k.s),
				X = Object(i.a)(k.r),
				Z = Object(i.a)(k.q),
				$ = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(x.e)(e, a),
							c = i.features.banned.fetchedTokens[d];
						if (i.features.banned.api.pending[d] || c) return;
						n(J({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await g(o(), l, t);
						u.ok ? n(X({
							...u.body,
							fetchedToken: a
						})) : n(Z({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				ee = Object(i.a)(k.v),
				te = Object(i.a)(k.u),
				ne = Object(i.a)(k.t),
				se = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(v.a)(t)
						};
					n(ee());
					const d = await g(o(), i, a);
					d.ok ? n(te(d.body)) : n(ne(d.error))
				}, re = Object(i.a)(k.p), oe = Object(i.a)(k.w), ie = (e, t, n) => async (r, i, d) => {
					let {
						apiContext: c
					} = d;
					const u = i(),
						h = u.subreddits.models[e].url,
						_ = u.subreddits.models[e].name;
					t.username = Object(v.a)(t.username), r(Object(a.h)(n));
					const x = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: m.ob.POST,
						data: {
							api_type: "json",
							ban_reason: n.reason,
							ban_message: n.banMessage,
							duration: n.duration,
							name: n.username,
							note: n.modNote,
							ban_context: n.contextId,
							type: "banned"
						}
					}))(c(), h, t);
					if (x.ok) {
						r(Object(a.e)(n));
						const e = {
							username: t.username
						};
						r(Object(l.f)({
							kind: O.b.SuccessMod,
							text: s.fbt._("Successfully banned a user", null, {
								hk: "1kORpS"
							})
						}));
						const o = await g(c(), _, e);
						o.ok && r(re(o.body))
					} else {
						r(Object(a.f)(n, x.error));
						const e = o()(x, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(l.f)({
							kind: O.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, ae = (e, t) => async (n, r, i) => {
					let {
						apiContext: a
					} = i;
					const d = r().subreddits.models[e].url,
						c = await ((e, t, n) => Object(p.a)(Object(b.a)(e, [f.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: m.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "banned"
							}
						}))(a(), d, t);
					if (c.ok) n(oe({
						subredditId: e,
						userId: t
					})), n(Object(l.f)({
						kind: O.b.SuccessMod,
						text: s.fbt._("Successfully unbanned a user", null, {
							hk: "OgqK6"
						})
					}));
					else {
						const e = o()(c, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(l.f)({
							kind: O.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, de = (e, t) => async (n, s) => {
					const r = s();
					await Promise.all([(async () => {
						if (!Object(E.b)(u.a.BAN_USER)(r) && !Object(C.V)(r, {
								subredditId: e
							})) {
							const t = Object(C.Y)(r, {
								subredditId: e
							});
							await n(Object(c.o)(t.name))
						}
					})(), (async () => {
						const s = Object(j.Bb)(r, {
							userName: t
						});
						if (!s) return;
						const o = Object(y.h)(r, {
							subredditId: e
						});
						o && o[s.id] || await n($(e, {
							username: t
						}))
					})()]), n(Object(d.i)(u.a.BAN_USER))
				}
		},
		"./src/reddit/actions/subredditModeration/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return w
			})), n.d(t, "e", (function() {
				return P
			})), n.d(t, "c", (function() {
				return R
			})), n.d(t, "a", (function() {
				return M
			})), n.d(t, "d", (function() {
				return D
			})), n.d(t, "b", (function() {
				return F
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/subredditModeration/constants.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json"),
				l = n("./src/redditGQL/operations/CreateModUserNote.json"),
				u = n("./src/redditGQL/operations/DeleteModUserNote.json"),
				m = n("./src/redditGQL/operations/GetModUserNotes.json"),
				p = n("./src/redditGQL/operations/GetTotalModNoteCount.json");
			var b = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				f = n("./src/reddit/models/SubredditModeration/index.ts"),
				h = n("./src/reddit/models/Toast/index.ts"),
				_ = n("./src/reddit/selectors/moderatorPermissions.ts"),
				g = n("./src/reddit/selectors/modUserNotes.ts"),
				v = n("./src/reddit/helpers/trackers/modNote.ts"),
				x = n("./src/telemetry/index.ts"),
				O = n("./src/redditGQL/types.ts"),
				E = n("./src/lib/initializeClient/installReducer.ts"),
				y = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			const {
				fbt: C
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			Object(E.a)({
				features: {
					modUserNotes: y.a
				}
			});
			const j = Object(r.a)(i.U),
				k = Object(r.a)(i.T),
				I = Object(r.a)(i.S),
				S = Object(r.a)(i.R),
				w = e => async (t, n, s) => {
					let {
						gqlContext: r
					} = s;
					var i;
					const c = n(),
						{
							forceLoad: l,
							subredditId: u,
							userId: p,
							before: b,
							filter: _
						} = e,
						g = Object(f.d)(u, p, _, b),
						v = c.features.modUserNotes.fetchedTokens[g] && !l;
					if (!c.features.modUserNotes.api.pending[g] && !v) {
						t(j({
							subredditId: u,
							userId: p,
							filter: _,
							fetchedToken: b
						}));
						try {
							const e = await ((e, t) => Object(d.a)(e, {
								...m,
								variables: {
									...t,
									last: 25
								}
							}))(r(), {
								subredditId: u,
								userId: p,
								filter: _,
								before: b
							});
							if (e.ok) {
								const {
									data: {
										subredditInfoById: n
									}
								} = e.body;
								if ("Subreddit" === (null == n ? void 0 : n.__typename) && (null === (i = null == n ? void 0 : n.modNotes) || void 0 === i ? void 0 : i.edges)) {
									const {
										edges: e,
										pageInfo: s
									} = n.modNotes, r = [];
									e.forEach(e => {
										e && e.node && r.push(e.node)
									}), t(k({
										notes: r,
										subredditId: u,
										userId: p,
										filter: _,
										fetchedToken: b,
										loadMoreToken: s.hasNextPage ? s.endCursor : null
									}))
								}
								const {
									errors: s
								} = e.body;
								s && s.length && o.c.captureException(s)
							} else t(I({
								subredditId: u,
								userId: p,
								filter: _,
								fetchedToken: b
							})), t(Object(a.f)({
								kind: h.b.Error,
								text: C._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						} catch (x) {
							o.c.captureException(x), t(Object(a.f)({
								kind: h.b.Error,
								text: C._("Oops, something went wrong. Try again.", null, {
									hk: "2VQ3RW"
								}),
								duration: 3e3
							}))
						}
					}
				}, T = Object(r.a)(i.H), N = Object(r.a)(i.G), P = e => {
					let {
						subredditId: t,
						nodes: n
					} = e;
					return async (e, s, r) => {
						let {
							gqlContext: o
						} = r;
						const i = [],
							a = [];
						n.map(e => {
							const t = null == e ? void 0 : e.user.id;
							t && !a.includes(t) && e && (i.push(e), a.push(t))
						}), e(N({
							subredditId: t,
							lastAuthorModNotes: i
						}))
					}
				}, R = (e, t, n) => async (r, o, i) => {
					let {
						gqlContext: a
					} = i;
					var l, u, m, p, f, h, _;
					const {
						hasSortParam: g,
						sortToUse: v
					} = Object(b.a)(o(), e), x = s.Ob[v], E = {
						postId: e,
						requestPostModerationInfo: !t,
						...g && x && {
							sortType: O.g[x]
						},
						...n && {
							after: n
						}
					}, y = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: {
							...t
						}
					}))(a(), E);
					if (y.ok) {
						const e = null === (l = y.body) || void 0 === l ? void 0 : l.data,
							t = null === (m = null === (u = null == e ? void 0 : e.postInfoById) || void 0 === u ? void 0 : u.subreddit) || void 0 === m ? void 0 : m.id,
							n = null === (f = null === (p = null == e ? void 0 : e.postInfoById) || void 0 === p ? void 0 : p.moderationInfo) || void 0 === f ? void 0 : f.lastAuthorModNote,
							s = null === (_ = null === (h = null == e ? void 0 : e.postInfoById) || void 0 === h ? void 0 : h.commentForest) || void 0 === _ ? void 0 : _.trees;
						n && r(T({
							subredditId: t,
							lastAuthorModNote: n
						})), s && r((e => {
							let {
								subredditId: t,
								commentTrees: n
							} = e;
							return async (e, s, r) => {
								let {
									gqlContext: o
								} = r;
								const i = [],
									a = [];
								n.map(e => {
									var t, n;
									if (!(null == e ? void 0 : e.node)) return;
									const s = null === (n = null === (t = e.node) || void 0 === t ? void 0 : t.moderationInfo) || void 0 === n ? void 0 : n.lastAuthorModNote,
										r = null == s ? void 0 : s.user.id;
									r && !a.includes(r) && s && (i.push(s), a.push(r))
								}), e(N({
									subredditId: t,
									lastAuthorModNotes: i
								}))
							}
						})({
							subredditId: t,
							commentTrees: s
						}))
					}
				}, A = Object(r.a)(i.Q), M = (e, t, n, s, r, o) => async (i, c, u) => {
					let {
						gqlContext: m
					} = u;
					var p, b;
					const f = {
							subredditId: e,
							userId: t,
							label: r,
							note: n,
							redditId: o
						},
						_ = await ((e, t) => Object(d.a)(e, {
							...l,
							variables: {
								input: t
							}
						}))(m(), f);
					if (_.ok) {
						const n = null === (b = null === (p = _.body) || void 0 === p ? void 0 : p.data) || void 0 === b ? void 0 : b.createModUserNote.createdNote;
						if (!n) return void i(Object(a.f)({
							kind: h.b.Error,
							text: C._("Something went wrong", null, {
								hk: "zYMeg"
							}),
							duration: 3e3
						}));
						i(A({
							subredditId: e,
							newModNote: n,
							filter: s
						})), Object(x.a)(Object(v.v)({
							userId: t,
							subredditId: e,
							filteredType: s,
							modNote: n
						})(c())), i(Object(a.f)({
							kind: h.b.SuccessMod,
							text: C._("Successfully created mod note", null, {
								hk: "10Vu91"
							}),
							duration: 3e3
						}))
					} else {
						const {
							errors: e
						} = _.body, t = e[0] ? e[0].message : C._("Something went wrong", null, {
							hk: "2uu095"
						});
						i(Object(a.f)({
							kind: h.b.Error,
							text: t,
							duration: 3e3
						}))
					}
				}, L = Object(r.a)(i.lb), D = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					var i, a;
					const c = s();
					if (!Object(_.i)(c, e)) return;
					const l = {
						subredditId: e,
						userId: t
					};
					if (Object(g.g)(c, t, e)) return;
					const u = await ((e, t) => Object(d.a)(e, {
						...p,
						variables: {
							...t
						}
					}))(o(), l);
					if (u.ok) {
						const s = null === (i = u.body) || void 0 === i ? void 0 : i.data;
						if ("Subreddit" === (null === (a = null == s ? void 0 : s.subredditInfoById) || void 0 === a ? void 0 : a.__typename)) {
							const r = null == s ? void 0 : s.subredditInfoById;
							r && n(L({
								subredditId: e,
								userId: t,
								totalCounts: r
							}))
						}
					}
				}, F = (e, t, n, s) => async (r, o, i) => {
					let {
						gqlContext: c
					} = i;
					const l = {
						subredditId: e,
						userId: t,
						noteId: n,
						noteType: s
					};
					(await ((e, t) => Object(d.a)(e, {
						...u,
						variables: {
							input: t
						}
					}))(c(), l)).ok ? (r(S({
						subredditId: e,
						userId: t,
						noteId: n
					})), r(Object(a.f)({
						kind: h.b.SuccessMod,
						text: C._("Mod Note sucessfully deleted!", null, {
							hk: "17NyFK"
						})
					}))) : r(Object(a.f)({
						kind: h.b.Error,
						text: C._("Could not delete note. Try again later.", null, {
							hk: "1XczhA"
						})
					}))
				}
		},
		"./src/reddit/actions/subredditModeration/mute.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./node_modules/lodash/get.js"),
				i = n.n(o),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const m = (e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
				endpoint: Object(u.a)(`${e.apiUrl}/api/v1/${t}/muted`),
				method: a.ob.GET,
				data: n
			});
			var p = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				b = n("./src/reddit/models/SubredditModeration/index.ts"),
				f = n("./src/reddit/models/Toast/index.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/actions/subredditModeration/constants.ts");
			const g = Object(r.a)(_.Y),
				v = Object(r.a)(_.W),
				x = Object(r.a)(_.V),
				O = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
					return async (n, s, r) => {
						let {
							apiContext: o
						} = r;
						const i = s(),
							a = t.after || "",
							d = Object(b.e)(e, a),
							c = i.pages.modHub.muted.fetchedTokens[d];
						if (i.pages.modHub.muted.api.pending[d] || c) return;
						n(g({
							subredditId: e,
							fetchedToken: a
						}));
						const l = i.subreddits.models[e].name,
							u = await m(o(), l, t);
						u.ok ? n(v({
							...u.body,
							fetchedToken: a
						})) : n(x({
							subredditId: e,
							fetchedToken: a
						}))
					}
				},
				E = Object(r.a)(_.bb),
				y = Object(r.a)(_.ab),
				C = Object(r.a)(_.Z),
				j = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = s().subreddits.models[e].name,
						a = {
							username: Object(p.a)(t)
						};
					n(E());
					const d = await m(o(), i, a);
					d.ok ? n(y(d.body)) : n(C(d.error))
				}, k = Object(r.a)(_.X), I = Object(r.a)(_.cb), S = (e, t) => async (n, r, o) => {
					let {
						apiContext: u
					} = o;
					const m = r().subreddits.models[e].url,
						p = await ((e, t, n) => Object(d.a)(Object(c.a)(e, [l.a]), {
							endpoint: `${e.apiUrl}${t}api/unfriend`,
							method: a.ob.POST,
							data: {
								api_type: "json",
								id: n,
								type: "muted"
							}
						}))(u(), m, t);
					if (p.ok) n(I({
						subredditId: e,
						userId: t
					}));
					else {
						const e = i()(p, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						n(Object(h.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}, w = (e, t, n) => async (r, o, u) => {
					let {
						apiContext: b
					} = u;
					const _ = o(),
						g = _.subreddits.models[e].url,
						v = _.subreddits.models[e].name;
					t = Object(p.a)(t);
					const x = await ((e, t, n, s) => Object(d.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}${t}api/friend`,
						method: a.ob.POST,
						data: {
							api_type: "json",
							name: n,
							note: s,
							type: "muted"
						}
					}))(b(), g, t, n);
					if (x.ok) {
						const e = {
							username: t
						};
						r(Object(h.f)({
							kind: f.b.SuccessMod,
							text: s.fbt._("Successfully muted a user", null, {
								hk: "2ypyuL"
							})
						}));
						const n = await m(b(), v, e);
						n.ok && r(k(n.body))
					} else {
						const e = i()(x, "body.json.errors[0][1]", s.fbt._("Something went wrong", null, {
							hk: "1IJNeH"
						}));
						r(Object(h.f)({
							kind: f.b.Error,
							text: e,
							duration: 3e3
						}))
					}
				}
		},
		"./src/reddit/actions/subredditRules/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			const s = "SUBREDDIT__RULES_LOADED",
				r = "SUBREDDIT__RULES_PENDING",
				o = "SUBREDDIT__RULES_FAILED",
				i = "SUBREDDIT__RULE_ADDED",
				a = "SUBREDDIT__RULE_EDITED",
				d = "SUBREDDIT__RULE_REMOVED",
				c = "SUBREDDIT__RULES_REORDERED"
		},
		"./src/reddit/actions/subredditSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return F
			})), n.d(t, "a", (function() {
				return B
			})), n.d(t, "b", (function() {
				return G
			})), n.d(t, "h", (function() {
				return W
			})), n.d(t, "g", (function() {
				return V
			})), n.d(t, "e", (function() {
				return z
			})), n.d(t, "f", (function() {
				return K
			})), n.d(t, "d", (function() {
				return Q
			})), n.d(t, "j", (function() {
				return Z
			})), n.d(t, "i", (function() {
				return $
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/xor.js"),
				a = n.n(i),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeActionCreator/index.ts"),
				l = n("./src/lib/name/index.ts"),
				u = n("./src/reddit/endpoints/subreddit/settings.ts"),
				m = n("./src/telemetry/index.ts"),
				p = n("./src/reddit/actions/toaster.ts"),
				b = n("./src/reddit/endpoints/subreddit/notificationSettings.ts"),
				f = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				h = n("./src/redditGQL/types.ts");
			const _ = e => {
					var t, n;
					if (!e) return {};
					const {
						id: s,
						isArchivePostsEnabled: r,
						isDiscoveryAllowed: o,
						isChatPostCreationAllowed: i,
						isCrosspostingAllowed: a,
						isPredictionAllowed: d,
						isPredictionContributorsAllowed: c,
						isPredictionsTournamentAllowed: l,
						banEvasionThreshold: u,
						commentContributionSettings: m,
						isNsfw: p,
						language: b,
						publicDescriptionText: f,
						isChatPostFeatureEnabled: _,
						welcomeMessage: g,
						allAllowedPostTypes: v,
						liveStreamingInfo: O,
						isTopListingAllowed: E,
						isCommentingRestricted: C,
						isPostingRestricted: j,
						isSpoilerAvailable: k,
						isContributorRequestsDisabled: I,
						type: w,
						suggestedCommentSort: T,
						title: N,
						toxicityThresholdChatLevel: P,
						crowdControl: R,
						commentDisplaySettings: A,
						allowedPostType: M,
						wikiSettings: L,
						spamFilter: D,
						modQueueSettings: F
					} = e;
					return {
						allowGalleries: v.includes(h.J.Gallery),
						allowImages: v.includes(h.J.Image),
						allowPolls: v.includes(h.J.Poll),
						archivePostsEnabled: r,
						allowDiscovery: o,
						allowChatPostCreation: i,
						allowPostCrossposts: a,
						allowPredictionContributors: c,
						allowPredictions: d,
						allowPredictionsTournament: l,
						banEvasionThreshold: x(u),
						commentContributionSettings: m,
						contentVisible: E,
						crowdControlLevel: y(null == R ? void 0 : R.crowdControlLevel),
						crowdControlChatLevel: y(null == R ? void 0 : R.crowdControlChatLevel),
						crowdControlPostLevel: y(null == R ? void 0 : R.crowdControlPostLevel),
						disableContributorRequests: I,
						isChatPostFeatureEnabled: _,
						language: b,
						liveStreamingIsEnabled: (null == O ? void 0 : O.isLiveStreamingEnabled) || void 0,
						over18: p,
						publicDescription: f || void 0,
						restrictCommenting: C,
						restrictPosting: j,
						spoilersEnabled: k,
						subredditId: s,
						subredditType: null == w ? void 0 : w.toLowerCase(),
						suggestedCommentSort: (null == T ? void 0 : T.toLowerCase()) || void 0,
						title: N,
						toxicityThresholdChatLevel: S(P),
						welcomeMessageEnabled: null == g ? void 0 : g.isEnabled,
						welcomeMessageText: (null == g ? void 0 : g.body) ? null === (t = g.body) || void 0 === t ? void 0 : t.markdown : void 0,
						wikimode: null === (n = null == L ? void 0 : L.wikiEditMode) || void 0 === n ? void 0 : n.toLowerCase(),
						crowdControlFilter: null == R ? void 0 : R.isCrowdControlFilterEnabled,
						collapseDeletedComments: null == A ? void 0 : A.isCollapseDeletedCommentsEnabled,
						commentScoreHideMins: (null == A ? void 0 : A.commentScoreHideMinutes) || 0,
						contentOptions: M || void 0,
						excludeBannedModqueue: null == F ? void 0 : F.isExcludeBannedModqueueEnabled,
						spamLinks: (null == D ? void 0 : D.spamPosts) || void 0,
						spamSelfposts: (null == D ? void 0 : D.spamSelfposts) || void 0,
						spamComments: (null == D ? void 0 : D.spamComments) || void 0,
						wikiEditAge: "number" == typeof(null == L ? void 0 : L.wikiEditMinimumAge) ? null == L ? void 0 : L.wikiEditMinimumAge : void 0,
						wikiEditKarma: "number" == typeof(null == L ? void 0 : L.wikiEditKarma) ? null == L ? void 0 : L.wikiEditKarma : void 0
					}
				},
				g = [h.c.Unknown, h.c.Off, h.c.Lenient, h.c.Moderate, h.c.Strict],
				v = e => {
					if (e) return (null == g ? void 0 : g[e]) || h.c.Unknown
				},
				x = e => e ? g.indexOf(e) : 0,
				O = [h.l.Off, h.l.Lenient, h.l.Medium, h.l.Strict],
				E = e => {
					if (e) return null == O ? void 0 : O[e]
				},
				y = e => e ? O.indexOf(e) : 0,
				C = e => {
					if (e) return Object.values(h.P).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				j = e => {
					if (e) return Object.values(h.g).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				k = e => {
					if (e) return Object.values(h.X).find(t => t === (null == e ? void 0 : e.toUpperCase()))
				},
				I = e => {
					if (e) return e > 0 ? h.S.Enabled : h.S.Disabled
				},
				S = e => {
					if (e) return e === h.S.Enabled ? 1 : 0
				},
				w = e => {
					let {
						over18: t,
						publicDescription: n,
						subredditType: s,
						contentOptions: r,
						archivePostsEnabled: o,
						allowDiscovery: i,
						allowGalleries: a,
						allowImages: d,
						allowChatPostCreation: c,
						allowPolls: l,
						allowPostCrossposts: u,
						allowPredictionContributors: m,
						allowPredictionsTournament: p,
						welcomeMessageEnabled: b,
						welcomeMessageText: f,
						language: h,
						contentVisible: _,
						banEvasionThreshold: g,
						commentContributionSettings: x,
						crowdControlFilter: O,
						crowdControlPostLevel: y,
						crowdControlChatLevel: S,
						crowdControlLevel: w,
						allowPredictions: T,
						collapseDeletedComments: N,
						commentScoreHideMins: P,
						disableContributorRequests: R,
						excludeBannedModqueue: A,
						hideAds: M,
						keyColor: L,
						restrictCommenting: D,
						restrictPosting: F,
						spamLinks: U,
						spamSelfposts: B,
						spamComments: q,
						spoilersEnabled: G,
						showMedia: H,
						showMediaPreview: W,
						submitLinkLabel: V,
						submitTextLabel: z,
						submitText: K,
						suggestedCommentSort: Q,
						title: Y,
						toxicityThresholdChatLevel: J,
						wikiEditAge: X,
						wikiEditKarma: Z,
						wikimode: $,
						...ee
					} = e;
					return {
						isNsfw: t,
						publicDescription: n,
						type: null == s ? void 0 : s.toUpperCase(),
						allowedPostType: null == r ? void 0 : r.toUpperCase(),
						isImagesAllowed: d,
						isCrosspostingAllowed: u,
						isPollsAllowed: l,
						isGalleriesAllowed: a,
						isChatPostAllowed: c,
						isTopListingAllowed: _,
						isDiscoveryAllowed: i,
						isArchivePostsEnabled: o,
						isPredictionContributorsAllowed: m,
						isPredictionsTournamentAllowed: p,
						language: h,
						banEvasionThreshold: v(g),
						crowdControlChatLevel: E(S),
						crowdControlFilter: O,
						crowdControlLevel: E(w),
						crowdControlPostLevel: E(y),
						welcomeMessage: f ? {
							markdown: f
						} : void 0,
						isWelcomeMessageEnabled: b,
						commentContributionSettings: x,
						allowPredictions: T,
						collapseDeletedComments: N,
						commentScoreHideMinutes: P,
						disableContributorRequests: R,
						excludeBannedModqueue: A,
						restrictCommenting: D,
						restrictPosting: F,
						spamLinks: C(U),
						spamSelfposts: C(B),
						spamComments: C(q),
						spoilersEnabled: G,
						suggestedCommentSort: j(Q),
						title: Y,
						toxicityThresholdChatLevel: I(J),
						wikiEditKarma: Z,
						wikiEditMinimumAge: X,
						wikiEditMode: k($),
						...ee
					}
				};
			var T = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				N = n("./src/reddit/models/Toast/index.ts"),
				P = n("./src/reddit/models/User/index.ts"),
				R = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				A = n("./src/reddit/selectors/subreddit.ts"),
				M = n("./src/reddit/selectors/subredditSettings.ts"),
				L = n("./src/reddit/selectors/user.ts"),
				D = n("./src/reddit/selectors/widgets.ts");
			const F = "SUBREDDIT_SETTINGS_LOADED",
				U = Object(c.a)(F),
				B = "SUBREDDIT_NOTIFICATION_SETTINGS_LOADED",
				q = Object(c.a)(B),
				G = "SUBREDDIT_NOTIFICATION_SETTINGS_UPDATED",
				H = Object(c.a)(G),
				W = (e, t) => async (n, s, r) => {
					let {
						apiContext: o,
						gqlContext: i
					} = r;
					var a, d;
					const c = s(),
						m = Object(R.c)(c) && !Object(l.b)(e);
					if (!t || !Object(A.ab)(c, t)) {
						const t = await (m ? Object(u.b)(i(), e) : Object(u.c)(o(), e)),
							s = m ? _(null === (d = null === (a = null == t ? void 0 : t.body) || void 0 === a ? void 0 : a.data) || void 0 === d ? void 0 : d.subredditInfoByName) : t.body;
						t && t.ok && n(U(s))
					}
					if (t && !Object(M.b)(c, {
							subredditId: t
						})) {
						const e = await Object(b.a)(i(), t);
						if (e && e.ok) {
							const t = e.body,
								s = Object(f.e)(t.data);
							n(q(s))
						}
					}
				}, V = () => async (e, t, n) => {
					let {
						apiContext: s
					} = n;
					const r = Object(L.l)(t());
					r && await e(W(d.qc + Object(P.e)(r)))
				}, z = "SUBREDDIT_SETTINGS_UPDATE_REQUESTED", K = "SUBREDDIT_SETTINGS_UPDATE_SUCCESS", Q = "SUBREDDIT_SETTINGS_UPDATE_FAILURE", Y = Object(c.a)(z), J = Object(c.a)(K), X = Object(c.a)(Q), Z = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
						r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (i, d, c) => {
						let {
							apiContext: l,
							gqlContext: f
						} = c;
						var h, g;
						i(Y());
						const v = d(),
							x = o()(Object(A.ab)(v, e), ...Object.keys(t)),
							O = o()(Object(M.b)(v, {
								subredditId: e
							}), ...Object.keys(n));
						let E;
						const y = Object(R.c)(v);
						if (y) {
							const n = w(t);
							E = await Object(u.h)(f(), e, n)
						}
						E || (E = await Object(u.g)(l(), e, t));
						const C = Object.keys(n).length > 0;
						let j = !0;
						if (C) {
							j = (await Object(b.b)(f(), e, n)).ok
						}
						if (E.ok && (!C || j)) {
							const o = y ? _(null === (g = null === (h = null == E ? void 0 : E.body) || void 0 === h ? void 0 : h.data) || void 0 === g ? void 0 : g.subreddit) : Object(u.d)(E.body);
							i(J({
								settings: {
									...o,
									subredditId: e
								},
								idCardWidgetId: Object(D.c)(v, {
									subredditId: e
								})
							})), C && i(H({
								notificationSettings: n,
								subredditId: e
							}));
							const d = {};
							return r && 0 === a()(Object.keys(t), Object.keys(x)).length && (d.buttonText = s.fbt._("Undo", null, {
								hk: "1Gskii"
							}), d.buttonAction = Z(e, x, O, r)), void i(Object(p.f)({
								kind: N.b.SuccessCommunity,
								text: s.fbt._("Subreddit settings updated successfully", null, {
									hk: "2fmdlZ"
								}),
								...d
							}))
						}
						i(X()), i(Object(p.f)({
							kind: N.b.Error,
							text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
								hk: "3wBPeO"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: Z(e, t, O, void 0)
						})), r && Object(m.a)(Object(T.c)(v, "BE returned an error:"))
					}
				}, $ = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					(await Object(u.e)(i(), e, t)).ok ? n(Object(p.f)({
						kind: N.b.SuccessCommunity,
						text: s.fbt._("Test message was sent to your inbox", null, {
							hk: "1ZtKzO"
						})
					})) : n(Object(p.f)({
						kind: N.b.Error,
						text: s.fbt._("Give us a few minutes to fix the problem. Sorry!", null, {
							hk: "3wBPeO"
						})
					}))
				}
		},
		"./src/reddit/actions/subscription/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			}));
			const s = "SUBSCRIPTION__FETCH_DATA_PENDING",
				r = "SUBSCRIPTION__FETCH_DATA_SUCCESS",
				o = "SUBSCRIPTION__FETCH_DATA_FAILURE",
				i = "SUBSCRIPTION__SUBSCRIPTION_TOGGLED",
				a = "SUBSCRIPTION__SUBSCIPTION_TOGGLE_FAILED",
				d = "SUBSCRIPTION__ORDER_LOADED",
				c = "SUBSCRIPTION__SUBREDDIT_FAVORITE_TOGGLED",
				l = "SUBSCRIPTION__MULTI_FAVORITE_TOGGLED",
				u = "SUBSCRIPTION__MULTI_FOLLOW_TOGGLED"
		},
		"./src/reddit/actions/subscription/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return N
			})), n.d(t, "d", (function() {
				return R
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "a", (function() {
				return D
			})), n.d(t, "b", (function() {
				return U
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/linkMatchers/customLinks.ts"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/reddit/actions/login.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/subscription/constants.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/constants/posts.ts"),
				m = n("./src/lib/makeApiRequest/index.ts"),
				p = n("./src/lib/omitHeaders/index.ts"),
				b = n("./src/reddit/constants/headers.ts");
			var f = n("./src/reddit/endpoints/subreddit/subscriptions.ts"),
				h = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				g = n("./src/reddit/models/GqlTopLevelField.ts"),
				v = n("./src/reddit/models/User/index.ts");

			function x(e) {
				const t = [],
					n = [],
					s = {},
					r = {},
					{
						followedRedditorsInfo: o
					} = e.identity;
				for (const a of o.edges) {
					if (a.node.__typename !== v.c.AvailableRedditor || !a.node.profile) continue;
					const e = Object(h.a)(a.node.profile);
					s[e.id] = e;
					const {
						isFavorite: n
					} = a.node.profile;
					n && t.push(e.id)
				}
				const {
					subscribedSubreddits: i
				} = e.identity;
				for (const a of i.edges) {
					if (a.node.__typename !== g.a.Subreddit) continue;
					const e = Object(_.a)(a.node);
					r[e.id] = e;
					const {
						isFavorite: t
					} = a.node;
					t && n.push(e.id)
				}
				return {
					favoriteProfileIds: t,
					favoriteSubredditIds: n,
					profiles: s,
					subreddits: r
				}
			}
			var O = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/profile.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/selectors/subscriptions.ts"),
				j = n("./src/reddit/selectors/user.ts");
			const k = () => s.fbt._("Sorry, failed to update favorites.", null, {
					hk: "40XHkp"
				}),
				I = Object(i.a)(c.c),
				S = Object(i.a)(c.b),
				w = Object(i.a)(c.a),
				T = Object(i.a)(c.h),
				N = (Object(i.a)(c.i), Object(i.a)(c.g), () => async (e, t, n) => {
					let {
						gqlContext: s
					} = n;
					const r = t();
					if (!r.user.account || r.subscriptions.api.fetched) return;
					e(S());
					const o = await Object(f.a)(s());
					if (o.ok) {
						const t = x(o.body.data);
						e(I(t))
					} else e(w({
						error: o.error
					}))
				}),
				P = (e, t) => t.type === u.a.PROFILE && e.displayText === t.name.replace("u_", ""),
				R = (e, t, n) => async (i, c, m) => {
					let {
						apiContext: p
					} = m, b = e.map(e => e.type === u.a.SUBREDDIT ? {
						id: Object(y.I)(c(), e.name),
						name: e.name,
						type: e.type
					} : {
						id: Object(E.o)(c(), e.name),
						name: `${r.qc}${e.name}`,
						type: e.type
					});
					if (!Object(j.R)(c())) return i(Object(d.k)({
						actionSource: d.a.Subscribe
					})), void i(Object(a.openRegisterModal)());
					const h = Object(j.l)(c());
					if (h) {
						const t = b.length,
							n = e.length;
						if (b = b.filter(e => !P(h, e)), (e = e.filter(e => !P(h, e))).length !== n || b.length !== t) {
							const e = s.fbt._("You cannot follow yourself!", null, {
								hk: "3tfSaq"
							});
							i(Object(l.f)(Object(l.e)(e, O.b.Error)))
						}
						if (!e.length && !b.length) return
					}
					i(T({
						identifiers: b,
						nameIdentifiers: e,
						profileModels: c().profiles.models,
						subredditModels: c().subreddits.models,
						subscriptionsCount: Object(C.b)(c()),
						userIsSubscriber: t,
						widgetId: n
					}));
					const _ = await Object(f.c)(p(), {
						subredditNames: b.map(e => {
							let {
								name: t
							} = e;
							return t
						}),
						subscribe: t
					});
					if (_.ok) {
						const n = 1 === e.length ? `${"subreddit"===e[0].type?o.d.subreddit:o.d.profile}${e[0].name}` : s.fbt._({
								"*": "{communities} communities",
								_1: "1 community"
							}, [s.fbt._plural(e.length, "communities")], {
								hk: "IgDzJ"
							}),
							r = s.fbt._("Successfully followed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "23Snyg"
							}),
							a = s.fbt._("Successfully unfollowed {communityname}", [s.fbt._param("communityname", n)], {
								hk: "jfC0S"
							}),
							d = s.fbt._("Successfully joined {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1W9UY3"
							}),
							c = s.fbt._("Successfully left {communityname}", [s.fbt._param("communityname", n)], {
								hk: "1saMW"
							});
						i(Object(l.f)({
							text: 1 === e.length && "profile" === e[0].type ? t ? r : a : t ? d : c
						}))
					} else {
						i(T({
							identifiers: b,
							nameIdentifiers: e,
							profileModels: c().profiles.models,
							subredditModels: c().subreddits.models,
							subscriptionsCount: Object(C.b)(c()),
							userIsSubscriber: !t,
							widgetId: n
						}));
						const r = s.fbt._("Something went wrong. Please try again!", null, {
							hk: "1zlDeq"
						});
						i(Object(l.f)(Object(l.e)(r, O.b.Error)))
					}
					return _.ok
				}, A = Object(i.a)(c.f), M = e => async (t, n, s) => {
					let {
						apiContext: r
					} = s;
					const o = n(),
						i = Object(y.Q)(o, {
							identifier: e
						});
					if (!i) throw new Error(`actions.subscription -- No subreddit or profile found with id ${e.id}`);
					const a = e.type === u.a.SUBREDDIT ? i.name : `u_${i.name}`,
						d = o.subscriptions.favoriteSubredditOrder || [],
						c = o.subscriptions.favoriteProfileOrder || [],
						m = d.indexOf(e.id),
						p = c.indexOf(e.id),
						b = -1 === m && -1 === p,
						h = o.subreddits.models,
						_ = o.profiles.models,
						g = {
							type: e.type,
							name: i.name
						},
						v = () => Object(y.kb)(n(), {
							identifier: g
						});
					(v() || (await t(R([g], !0)), v())) && (t(A({
						makeFavorite: b,
						identifier: e,
						subredditModels: h,
						profileModels: _
					})), (await Object(f.b)(r(), a, b)).ok || (t(A({
						makeFavorite: !b,
						identifier: e,
						subredditModels: h,
						profileModels: _
					})), t(Object(l.f)({
						text: k(),
						kind: O.b.Error
					}))))
				}, L = Object(i.a)(c.d), D = e => async (t, n, s) => {
					let {
						apiContext: o
					} = s;
					const i = n().multireddits.models,
						a = () => {
							t(Object(l.f)({
								text: k(),
								kind: O.b.Error
							}))
						},
						d = i[e];
					if (!d) return void a();
					const c = !d.isFavorited;
					t(L({
						makeFavorite: c,
						multiredditPath: e,
						multiredditsModelsState: i
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/favorite`,
						data: {
							make_favorite: n ? "true" : "false",
							multipath: t,
							api_type: "json"
						}
					}))(o(), e, c)).ok || (t(L({
						makeFavorite: !c,
						multiredditPath: e,
						multiredditsModelsState: i
					})), a())
				}, F = Object(i.a)(c.e), U = e => async (t, n, o) => {
					let {
						apiContext: i
					} = o;
					const a = n(),
						d = a.multireddits.models;
					if (!Object(j.R)(a)) return;
					const c = function() {
							let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
							t(Object(l.f)({
								text: s.fbt._("Sorry, failed to {followAction}", [s.fbt._param("followAction", e ? s.fbt._("follow", null, {
									hk: "3YMYJK"
								}) : s.fbt._("unfollow", null, {
									hk: "24IYxj"
								}))], {
									hk: "1ufRSl"
								}),
								kind: O.b.Error
							}))
						},
						u = d[e];
					if (!u) return void c();
					const f = !u.isFollowed;
					t(F({
						follow: f,
						multiredditPath: e,
						multiredditsModelsState: d
					})), (await ((e, t, n) => Object(m.a)(Object(p.a)(e, [b.a]), {
						method: r.ob.POST,
						endpoint: `${e.apiUrl}/api/multi/subscribe`,
						data: {
							action: n ? "sub" : "unsub",
							path: t,
							api_type: "json"
						},
						type: "json"
					}))(i(), e, f)).ok || (t(F({
						follow: !f,
						multiredditPath: e,
						multiredditsModelsState: d
					})), c(f))
				}
		},
		"./src/reddit/actions/tabBadging.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "f", (function() {
				return g
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				a = n("./src/reddit/helpers/tabBadging/index.ts"),
				d = n("./src/reddit/models/Badge/index.ts"),
				c = n("./src/reddit/selectors/appBadges.ts"),
				l = n("./src/reddit/selectors/user.ts"),
				u = n("./src/reddit/actions/appBadgeIndicators/index.ts");
			const m = "TAB__UPDATE_HAS_UNREAD_MESSAGES_BADGE",
				p = Object(o.a)(m),
				b = (e, t) => {
					e <= 0 ? r.a.write(() => {
						Object(a.b)(!1), window.document.title = t
					}) : r.a.write(() => {
						Object(a.b)(), window.document.title = `(${e}) ${t}`
					})
				},
				f = Object(s.c)({
					basicChannelCount: c.e,
					subredditChannelCount: c.d,
					subredditMentionCount: c.c
				}),
				h = () => async (e, t) => {
					const n = t(),
						s = Object(i.g)(n, {});
					if (!(Object(l.Q)(n) || Object(l.R)(n)) || !s) return;
					const r = Object(c.i)(n);
					b(r, s), e(p({
						hasUnreadMessages: !!r
					}))
				}, _ = () => async (e, t) => {
					{
						e(h());
						const n = (e => ({
							inboxCount: Object(c.h)(e),
							basicChannelCount: Object(c.e)(e)
						}))(t());
						Object(a.c)(n)
					}
				}, g = e => async (t, n) => {
					const s = n(),
						r = Object(c.e)(s),
						o = Object(c.h)(s),
						{
							basicChannelCount: i,
							inboxCount: a
						} = e;
					if (r !== i) {
						const e = Object(u.e)({
							count: i,
							key: d.c.ChatTab
						});
						t(Object(u.a)(e))
					}
					if (a && a !== o) {
						const e = Object(u.e)({
							count: a,
							key: d.c.MessageTab
						});
						t(Object(u.a)(e))
					}(r !== i || a && a !== o) && t(h())
				}
		},
		"./src/reddit/actions/tags/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "t", (function() {
				return s
			})), n.d(t, "j", (function() {
				return r
			})), n.d(t, "r", (function() {
				return o
			})), n.d(t, "q", (function() {
				return i
			})), n.d(t, "s", (function() {
				return a
			})), n.d(t, "l", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "v", (function() {
				return b
			})), n.d(t, "w", (function() {
				return f
			})), n.d(t, "u", (function() {
				return h
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "f", (function() {
				return v
			})), n.d(t, "A", (function() {
				return x
			})), n.d(t, "z", (function() {
				return O
			})), n.d(t, "D", (function() {
				return E
			})), n.d(t, "y", (function() {
				return y
			})), n.d(t, "C", (function() {
				return C
			})), n.d(t, "x", (function() {
				return j
			})), n.d(t, "B", (function() {
				return k
			})), n.d(t, "e", (function() {
				return I
			})), n.d(t, "b", (function() {
				return S
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "i", (function() {
				return P
			}));
			const s = "TAGS__REQUESTED",
				r = "TAGS__AVAILABLE_LOADED",
				o = "TAGS__LOADED",
				i = "TAGS__FAILURE",
				a = "TAGS__RELEVANCE_LOADED",
				d = "TAGS__CREATE_REQUESTED",
				c = "TAGS__CREATE_SUCCESS",
				l = "TAGS__CREATE_FAILURE",
				u = "TAGS__DELETE_REQUESTED",
				m = "TAGS__DELETE_SUCCESS",
				p = "TAGS__DELETE_FAILURE",
				b = "TAGS__UPDATE_STATE_REQUESTED",
				f = "TAGS__UPDATE_STATE_SUCCESS",
				h = "TAGS__UPDATE_STATE_FAILURE",
				_ = "PRIMARY_TAG__UPDATE_STATE_REQUESTED",
				g = "PRIMARY_TAG__UPDATE_STATE_SUCCESS",
				v = "PRIMARY_TAG__UPDATE_STATE_FAILURE",
				x = "TAGS__OPTIONS_CANCELLED",
				O = "TAGS__OPTION_SELECTED",
				E = "TAGS__SUGGESTED_OPTION_SELECTED",
				y = "TAGS__OPTION_DESELECTED",
				C = "TAGS__SUGGESTED_OPTION_DESELECTED",
				j = "TAGS__INPUT_CHANGED",
				k = "TAGS__SUGGESTED_INPUT_CHANGED",
				I = "GLOBAL__TAGS__LOADED",
				S = "CREATION__TAGS_INPUT_CHANGED",
				w = "CREATION__TAGS_OPTION_SELECTED",
				T = "CREATION__TAGS_OPTION_DESELECTED",
				N = "CREATION__PRIMARY_TAG_SELECTED",
				P = "SETTINGS_PAGE_PRIMARY_TAG_UPDATE"
		},
		"./src/reddit/actions/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return L
			})), n.d(t, "m", (function() {
				return D
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "l", (function() {
				return U
			})), n.d(t, "h", (function() {
				return B
			})), n.d(t, "k", (function() {
				return q
			})), n.d(t, "a", (function() {
				return V
			})), n.d(t, "f", (function() {
				return z
			})), n.d(t, "g", (function() {
				return Q
			})), n.d(t, "e", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return $
			})), n.d(t, "b", (function() {
				return ee
			})), n.d(t, "n", (function() {
				return te
			})), n.d(t, "c", (function() {
				return ne
			})), n.d(t, "o", (function() {
				return se
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/tags/constants.ts"),
				i = n("./src/reddit/actions/toaster.ts");
			const a = e => {
				const {
					subredditInfoById: t
				} = e, n = {
					global: {},
					[t.id]: {}
				};
				t.availableTags && t.availableTags.edges.reduce((e, t) => {
					let {
						node: n
					} = t;
					return e[n.subreddit && n.subreddit.id || "global"][n.id] = n, e
				}, n);
				const s = {
					[t.id]: {}
				};
				t.secondaryTags && t.secondaryTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, s);
				const r = {
					[t.id]: {}
				};
				return t.suggestedTags && t.suggestedTags.edges.reduce((e, n) => {
					let {
						node: s
					} = n;
					return e[t.id][s.tag.id] = s, e
				}, r), {
					primaryTag: t.primaryTag,
					globalSubredditTags: n.global,
					subredditScopedTags: {
						[t.id]: n[t.id]
					},
					subredditId: t.id,
					itemTags: s,
					suggestedItemTags: r,
					geoPlace: t.geoPlace
				}
			};
			var d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/CreateSubredditTags.json");
			const l = 1050;
			n("./src/redditGQL/operations/FetchGlobalTags.json");
			var u = n("./src/redditGQL/operations/FetchSubredditTags.json");
			const m = (e, t) => {
				let {
					subredditId: n,
					pageSize: s = l,
					after: r,
					includeAvailableTags: o
				} = t;
				return Object(d.a)(e, {
					...u,
					variables: {
						subredditId: n,
						pageSize: s,
						after: r,
						includeAvailableTags: o
					}
				})
			};
			var p = n("./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json");
			const b = (e, t) => Object(d.a)(e, {
				...p,
				variables: {
					...t,
					deleteTags: 0 !== t.deleteTagsInput.length,
					pageSize: l
				}
			});
			var f = n("./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json");
			const h = (e, t) => Object(d.a)(e, {
				...f,
				variables: t
			});
			var _ = n("./src/redditGQL/operations/UpdateSubredditPrimaryTag.json");
			const g = e => {
					const {
						secondaryTags: t,
						id: n,
						primaryTag: s
					} = e.updateSubredditTagStates.subreddit, r = t && t.edges || [];
					return {
						subredditId: n,
						primaryTagId: s && s.tag.id || null,
						secondaryTags: r.reduce((e, t) => {
							let {
								node: n
							} = t;
							return e[n.tag.id] = n, e
						}, {})
					}
				},
				v = (e, t) => Object(d.a)(e, {
					..._,
					variables: t
				});
			var x = n("./src/reddit/helpers/tags/index.ts"),
				O = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				E = n("./src/reddit/models/Tags/index.ts"),
				y = n("./src/reddit/models/Toast/index.ts"),
				C = n("./src/reddit/reducers/tags/selected/index.ts"),
				j = n("./src/reddit/selectors/tags.ts");
			Object(r.a)(o.e);
			const k = Object(r.a)(o.t),
				I = Object(r.a)(o.r),
				S = Object(r.a)(o.s),
				w = Object(r.a)(o.q),
				T = Object(r.a)(o.l),
				N = Object(r.a)(o.m),
				P = Object(r.a)(o.k),
				R = Object(r.a)(o.v),
				A = Object(r.a)(o.w),
				M = Object(r.a)(o.u),
				L = Object(r.a)(o.z),
				D = Object(r.a)(o.D),
				F = Object(r.a)(o.y),
				U = Object(r.a)(o.C),
				B = Object(r.a)(o.x),
				q = Object(r.a)(o.B),
				G = (Object(r.a)(o.d), Object(r.a)(o.c), Object(r.a)(o.b), Object(r.a)(o.g)),
				H = Object(r.a)(o.h),
				W = Object(r.a)(o.f),
				V = Object(r.a)(o.a),
				z = Object(r.a)(o.i),
				K = Object(r.a)(o.A),
				Q = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, d) => {
						let {
							gqlContext: c
						} = d;
						const l = o();
						r(k());
						const u = await m(c(), {
								subredditId: e
							}),
							p = u.body;
						if (u.ok && p.data.subredditInfoById.secondaryTags && p.data.subredditInfoById.availableTags && p.data.subredditInfoById.suggestedTags) r(I(a(p.data))), n && O.h(o(), e, {
							context: t
						});
						else {
							r(w());
							const o = n ? "topics_save" : "topics_load";
							O.g(l, e, o, {
								context: t
							}), r(Object(i.f)(Object(i.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
								hk: "2DUkWX"
							}), y.b.Error, s.fbt._("Retry", null, {
								hk: "1c2xrJ"
							}), Q(e, t, n))))
						}
					}
				},
				Y = e => async (t, n, r) => {
					let {
						gqlContext: o
					} = r;
					t(k());
					const d = await m(o(), {
						subredditId: e
					});
					if (d.ok) {
						const e = d.body;
						t(S(a(e.data)))
					} else t(w()), t(Object(i.f)(Object(i.e)(s.fbt._("Oh no! We didn't load your topics. Please try again.", null, {
						hk: "2DUkWX"
					}), y.b.Error, s.fbt._("Retry", null, {
						hk: "1c2xrJ"
					}), S(e))))
				}, J = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					if (!t.length) return null;
					n(T());
					const i = t.map(t => ({
							subredditId: e,
							...t
						})),
						a = await ((e, t) => Object(d.a)(e, {
							...c,
							variables: t
						}))(o(), {
							input: i
						}),
						l = a.body && a.body.data || null;
					return a.ok && l && l.createSubredditTags && l.createSubredditTags.ok ? (n(N()), l.createSubredditTags.createdTags || []) : (n(P()), null)
				}, X = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
					return async (s, r, o) => {
						let {
							gqlContext: i
						} = o;
						if (!t.length && !n.length) return;
						s(R());
						const d = r(),
							c = Object(j.d)(d, {
								subredditId: e
							}),
							l = Object(j.o)(d, {
								itemId: e
							}),
							u = Object(j.z)(d, {
								itemId: e
							}),
							m = new Set;
						for (const e of t)
							if (e.state === E.d.NONE && c[e.tagId] && !u[e.tagId]) {
								!!n.find(t => t.state === E.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} for (const e of n)
							if (e.state === E.d.NONE && c[e.tagId] && !l[e.tagId]) {
								!!t.find(t => t.state === E.d.TAGGED && t.tagId === e.tagId) || m.add(e.tagId)
							} const p = await b(i(), {
								deleteTagsInput: [...m].map(t => ({
									tagId: t,
									subredditId: e
								})),
								updateTagStatesInput: {
									subredditId: e,
									suggestedTagStates: n,
									tagStates: t
								}
							}),
							f = p.body && p.body.data || null;
						p.ok && f && f.updateSubredditTagStates && f.updateSubredditTagStates.ok && f.updateSubredditTagStates.subreddit ? s(A(a({
							subredditInfoById: f.updateSubredditTagStates.subreddit
						}))) : s(M())
					}
				}, Z = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return async (r, o, a) => {
						const d = o(),
							c = Object(j.q)(d, {
								subredditId: e
							}),
							l = Object(j.C)(d, {
								subredditId: e
							});
						let u = c.filter(e => !!e.id && !!e.action).map(e => ({
							tagId: e.id,
							state: e.action === C.a.ADD ? E.d.TAGGED : E.d.NONE
						}));
						if (l.length > 0) {
							const t = await J(e, l)(r, o, a);
							u = u.concat((t || []).map(e => ({
								tagId: e.id,
								state: E.d.TAGGED
							})))
						}
						await X(e, u)(r, o, a), Object(j.A)(o()) ? r(Object(i.f)(Object(i.e)(s.fbt._("Yikes! It looks like we didn't save all of your topics. Please try again", null, {
							hk: "2Jbh5V"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1c2xrJ"
						}), Z(e, t, n)))) : n && r(Object(i.f)(Object(i.e)(s.fbt._("Community topics saved!", null, {
							hk: "3wtajT"
						}), y.b.SuccessCommunity)))
					}
				}, $ = (e, t, n) => async (n, r, o) => {
					const a = {
						state: E.d.TAGGED
					};
					if (Object(x.b)(t)) {
						const s = await J(e, [{
							text: t.displayText,
							type: E.c.CLASSIFICATION
						}])(n, r, o);
						s && 1 === s.length && (a.tagId = s[0].id)
					} else {
						if (!t.id) return void n(Object(i.f)(Object(i.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
							hk: "CxjiK"
						}), y.b.Error)));
						a.tagId = t.id
					}(e => !!e.tagId && !!e.state)(a) ? await X(e, [], [a])(n, r, o): n(Object(i.f)(Object(i.e)(s.fbt._("Whoops, we couldn't save that topic. Please try again later.", null, {
						hk: "CxjiK"
					}), y.b.Error)))
				}, ee = (e, t, n) => async (s, r, o) => {
					t.id ? await X(e, [], [{
						state: E.d.NONE,
						tagId: t.id
					}])(s, r, o) : s(Q(e, n, !1))
				}, te = function(e, t, n, r) {
					let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return async (a, d, c) => {
						let {
							gqlContext: l
						} = c;
						if (!(await h(l(), {
								input: {
									tagStatesRelevance: t,
									suggestedTagStatesRelevance: n
								}
							})).ok) return a(Object(i.f)(Object(i.e)(s.fbt._("Whoops! Unable to update topics relevance status", null, {
							hk: "17akdT"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1wqK2v"
						}), te(e, t, n, r, o)))), void a(Y(e));
						if (o)
							for (const e of n) O.f(d(), e, {
								context: r
							});
						a(Object(i.f)(Object(i.e)(s.fbt._("Successfully updated topics relevance!", null, {
							hk: "3KIYlz"
						}), y.b.SuccessCommunity, s.fbt._("Undo", null, {
							hk: "34apPL"
						}), te(e, t.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), n.map(e => ({
							...e,
							isRelevant: !e.isRelevant
						})), r, o)))), a(Y(e))
					}
				}, ne = e => async (t, n) => {
					t(K({
						itemTagsState: {
							[e]: Object(j.o)(n(), {
								itemId: e
							})
						}
					}))
				}, se = function(e, t) {
					let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return async (r, o, a) => {
						let {
							gqlContext: d
						} = a;
						const c = Object(j.x)(o(), {
							subredditId: e
						});
						if ((null == c ? void 0 : c.id) === t.tagId && t.state === E.d.TAGGED) return;
						r(G());
						const l = await v(d(), {
								input: {
									subredditId: e,
									primaryTagState: t
								}
							}),
							u = l.body && l.body.data || null;
						l.ok && u && u.updateSubredditTagStates && u.updateSubredditTagStates.ok ? (r(H(g(u))), n && r(Object(i.f)(Object(i.e)(s.fbt._("Successfully updated primary topic!", null, {
							hk: "1NL90v"
						}), y.b.SuccessCommunity)))) : (r(W()), r(Object(i.f)(Object(i.e)(s.fbt._("Whoops! Unable to update primary topic", null, {
							hk: "3ilZqp"
						}), y.b.Error, s.fbt._("Retry", null, {
							hk: "1dRYXW"
						}), se(e, t)))))
					}
				}
		},
		"./src/reddit/actions/trafficStats/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = "SUBREDDIT__TRAFFIC_STATS_LOADED",
				r = "SUBREDDIT__TRAFFIC_STATS_PENDING",
				o = "SUBREDDIT__TRAFFIC_STATS_FAILED"
		},
		"./src/reddit/actions/upload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "m", (function() {
				return v
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "j", (function() {
				return T
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/get.js"),
				r = n.n(s),
				o = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				i = n("./src/lib/makeActionCreator/index.ts"),
				a = n("./src/lib/uploadToS3/index.ts"),
				d = n("./src/reddit/models/Upload/index.ts");
			const c = "UPLOAD_PENDING",
				l = "UPLOAD_UPLOADING",
				u = "UPLOAD_METADATA_CHANGED",
				m = "UPLOAD_PROGRESS",
				p = "UPLOAD_SUCCESS",
				b = "UPLOAD_FAILED",
				f = "UPLOAD_CANCELED",
				h = "UPLOAD_REMOVED",
				_ = Object(i.a)(c),
				g = Object(i.a)(l),
				v = Object(i.a)(u),
				x = Object(i.a)(m),
				O = Object(i.a)(p),
				E = Object(i.a)(b),
				y = Object(i.a)(f),
				C = Object(i.a)(h),
				j = new Map,
				k = (e, t) => {
					const n = j.get(e) || [];
					n.push(t), j.set(e, n)
				},
				I = (e, t) => {
					const n = j.get(e);
					n && n.forEach(n => n(e, t)), j.delete(e)
				},
				S = function(e, t, n) {
					let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					return async (i, c) => {
						const l = t;
						if (c().uploads[l] && Object(d.c)(c().uploads[l])) return;
						const u = Object(o.a)(),
							m = () => {
								const e = c().uploads[l];
								return !e || e.id !== u || e.status === d.a.CANCELED
							};
						i(_({
							key: l,
							id: u,
							file: e
						}));
						const {
							uploadLease: p,
							error: b
						} = await n(c().uploads[l]);
						if (m()) return;
						if (b || !p) return void i(E({
							key: l,
							error: b
						}));
						let f;
						k(u, () => {
							f && f.abort()
						}), i(g({
							key: l
						}));
						const h = await Object(a.a)(e, p, e => (f = e, s && e.on("progress", e => {
							if (!m() && "upload" === e.direction) {
								const t = {
									percent: e.percent,
									total: e.total,
									uploaded: e.loaded
								};
								i(x({
									key: l,
									progress: t
								}))
							}
						}), e));
						if (f = null, !m())
							if (h.ok) {
								const e = decodeURIComponent(h.body.PostResponse.Location);
								i(O({
									key: l,
									url: e
								}))
							} else {
								const e = r()(h, "body.Error.Message.0"),
									t = {
										type: "ERROR",
										...e ? {
											fields: [{
												field: "0",
												msg: e
											}]
										} : {}
									};
								i(E({
									key: l,
									error: t
								}))
							}
					}
				},
				w = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						const r = s().uploads[e];
						r && (I(r.id, t), n(t ? C({
							key: e
						}) : y({
							key: e
						})))
					}
				},
				T = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return (n, s) => {
						Object.keys(s().uploads).forEach(s => {
							s.startsWith(e) && n(w(s, t))
						})
					}
				}
		},
		"./src/reddit/actions/urlRequested.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/matchRoute/index.ts"),
				r = n("./src/lib/opener/index.ts"),
				o = n("./node_modules/react-router-redux/es/index.js");
			const i = function(e) {
				let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
				return async (n, i, a) => {
					let {
						routes: d
					} = a;
					const c = i();
					Object(s.a)(e, d, c) ? n(Object(o.b)(e)) : t ? Object(r.e)(e, "_blank") : window.location.assign(e)
				}
			}
		},
		"./src/reddit/actions/userFlair/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "i", (function() {
				return o
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "p", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "m", (function() {
				return _
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "k", (function() {
				return x
			}));
			const s = "USER_FLAIR_DATA__MUTATED",
				r = "AUTHOR_FLAIR_DATA__MUTATED",
				o = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_PENDING",
				i = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_SUCCESS",
				a = "STRUCTURED_STYLES__USERFLAIR_ENABLED_SETTING_FAILED",
				d = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_PENDING",
				c = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_SUCCESS",
				l = "STRUCTURED_STYLES__USERFLAIR_ALLOW_ASSIGN_OWN_SETTING_FAILED",
				u = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_PENDING",
				m = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_SUCCESS",
				p = "STRUCTURED_STYLES__USERFLAIR_SAVETEMPLATE_FAILED",
				b = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_PENDING",
				f = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_SUCCESS",
				h = "STRUCTURED_STYLES__USERFLAIR_DELETETEMPLATE_FAILED",
				_ = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_PENDING",
				g = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_SUCCESS",
				v = "STRUCTURED_STYLES__USERFLAIR_REORDERTEMPLATES_FAILED",
				x = "USERFLAIR_FETCH_SUCCESS"
		},
		"./src/reddit/actions/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			}));
			var s = n("./src/lib/loadableAction/index.ts");
			const r = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairChanged)),
				o = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleUserFlairInSubreddit)),
				i = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.toggleAssignOwnFlairPermission)),
				a = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.saveUserFlairTemplate)),
				d = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.deleteUserFlairTemplate)),
				c = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.reorderUserFlairTemplates)),
				l = Object(s.a)(() => n.e("UserFlair").then(n.bind(null, "./src/reddit/actions/userFlair/userFlair.ts")).then(e => e.userFlairLoadedAndModalOpened))
		},
		"./src/reddit/actions/widgets/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return s
			})), n.d(t, "i", (function() {
				return r
			})), n.d(t, "h", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			const s = "WIDGETS__WIDGET_CREATED",
				r = "WIDGETS__WIDGET_UPDATED",
				o = "WIDGET_DELETED",
				i = "WIDGETS_SORTED",
				a = "WIDGETS__STARTED_EDITING_WIDGET",
				d = "WIDGETS__LOADED",
				c = "SUBREDDIT__WIDGETS_PENDING",
				l = "SUBREDDIT__WIDGETS_LOADED",
				u = "SUBREDDIT__WIDGETS_FAILED"
		},
		"./src/reddit/actions/widgets/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return C
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "d", (function() {
				return S
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "f", (function() {
				return A
			})), n.d(t, "g", (function() {
				return F
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/makeActionCreator/index.ts"),
				o = n("./src/reddit/actions/apiRequestState.ts"),
				i = n("./src/reddit/actions/imageUploads.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/makeApiRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts");
			const m = async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
				endpoint: `${e.apiUrl}/r/${t}/api/widgets`,
				method: d.ob.GET,
				type: "json",
				data: {
					progressive_images: n
				}
			});
			var p = n("./src/reddit/helpers/getGenericUploadError.ts"),
				b = n("./src/reddit/helpers/media/index.ts"),
				f = n("./src/lib/assertNever.ts"),
				h = n("./src/reddit/models/Widgets/index.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/helpers/widgets/index.tsx"),
				v = n("./src/reddit/models/Image/index.tsx"),
				x = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				E = n("./src/reddit/actions/widgets/constants.ts");
			const y = Object(r.a)(E.g),
				C = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: f
					} = b;
					r(Object(o.h)(n));
					const h = m(),
						E = Object(_.Y)(h, {
							subredditId: e
						}).name,
						C = Object(O.f)(h),
						j = Object(g.e)(t);
					let k = null,
						I = null;
					try {
						(k = await Object(i.f)(h, v.a.Widgets)) && (I = Object(i.m)(k)(r, m, b))
					} catch (w) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					if (C && I) try {
						await I
					} catch (w) {}
					const S = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget`,
						method: d.ob.POST,
						type: "json",
						data: n
					}))(f(), E, j);
					if (S.ok) {
						let i = S.body;
						const d = i.id;
						if ("calendar" === t.kind && r(Object(a.f)({
								kind: x.b.SuccessMod,
								text: s.fbt._("New calendar added! It may take a few minutes to see your events appear", null, {
									hk: "4iETrT"
								})
							})), k) {
							if (!C) try {
								await I
							} catch (w) {}
							i = await r(U(e, d)) || i
						}
						r(y({
							subredditId: e,
							widget: i,
							widgetId: d
						})), r(Object(o.e)(n))
					} else k && k.websocket.close(), r(Object(o.f)(n, S.error))
				}, j = Object(r.a)(E.i), k = (e, t, n) => async (r, m, b) => {
					const {
						apiContext: E
					} = b;
					r(Object(o.h)(n));
					const y = t.id,
						C = m(),
						k = Object(_.Y)(C, {
							subredditId: e
						}).name,
						I = Object(O.f)(C),
						S = Object(g.e)(t);
					let w = null,
						T = null;
					try {
						(w = await Object(i.f)(C, v.a.Widgets)) && (T = Object(i.m)(w)(r, m, b))
					} catch (P) {
						const e = Object(p.a)("webSocket");
						return void r(Object(o.f)(n, e))
					}
					if (I && T) try {
						await T
					} catch (P) {}
					const N = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
						method: d.ob.PUT,
						type: "json",
						data: n
					}))(E(), k, S);
					if (N.ok) {
						let i = function(e, t, n) {
							switch (e.kind) {
								case h.i.Calendar:
								case h.i.IdCard:
								case h.i.SubredditRules:
									return {
										...e, ...t
									};
								case h.i.CommunityList: {
									const s = {};
									for (const t of e.data) s[t.name] = t;
									return {
										...t,
										data: t.data.map(e => {
											if (!("subscribers" in s[e])) {
												const t = {
														subredditName: e
													},
													s = Object(_.C)(n, t),
													r = Object(_.z)(n, t);
												return {
													name: s.name,
													subscribers: s ? s.subscribers : void 0,
													iconUrl: s ? s.communityIcon : void 0,
													isNSFW: s ? s.isNSFW : void 0,
													isSubscribed: r ? r.userIsSubscriber : void 0
												}
											}
											return s[e]
										})
									}
								}
								case h.i.Button:
								case h.i.Custom:
								case h.i.Image:
								case h.j.Menu:
								case h.i.Moderators:
								case h.i.Textarea:
								case h.i.PostFlair:
									return t;
								default:
									return Object(f.a)(e)
							}
						}(t, N.body, C);
						if (T) {
							if (!I) try {
								await T
							} catch (P) {}
							i = await r(U(e, y)) || i
						}
						r(j({
							subredditId: e,
							widgetId: y,
							widget: i
						})), "calendar" === t.kind && r(Object(a.f)({
							kind: x.b.SuccessMod,
							text: s.fbt._("Calendar is updated! It may take a few minutes to see your events change", null, {
								hk: "10XWV"
							})
						})), r(Object(o.e)(n))
					} else w && w.websocket.close(), r(Object(o.f)(n, N.error))
				}, I = Object(r.a)(E.h), S = (e, t, n) => async (s, r, i) => {
					let {
						apiContext: a
					} = i;
					s(Object(o.h)(n));
					const m = t.id,
						p = Object(_.Y)(r(), {
							subredditId: e
						}).name,
						b = await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget/${n.id}`,
							method: d.ob.DELETE,
							type: "json"
						}))(a(), p, t);
					b.ok ? (s(Object(o.e)(n)), s(I({
						subredditId: e,
						widgetId: m
					}))) : s(Object(o.f)(n, b.error))
				}, w = Object(r.a)(E.f), T = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = Object(_.Y)(s(), {
						subredditId: e
					}).name;
					(await (async (e, t, n) => Object(c.a)(Object(l.a)(e, [u.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/widget_order/sidebar`,
						method: d.ob.PATCH,
						type: "json",
						data: n
					}))(o(), i, t)).ok && n(w({
						subredditId: e,
						widgetIds: t
					}))
				}, N = e => {
					let {
						imageData: t
					} = e;
					return async (e, n, s) => {
						const r = n(),
							o = r.structuredStyles.isEditing,
							a = Object(_.Y)(r, {
								subredditId: o
							}).name;
						e(Object(i.k)(t));
						const m = await (async (e, t, n, s) => Object(c.a)(Object(l.a)(e, [u.a]), {
							endpoint: `${e.apiUrl}/r/${t}/api/widget_image_upload_s3`,
							method: d.ob.POST,
							data: {
								filepath: n,
								mimetype: s
							}
						}))(s.apiContext(), a, t.file.name, await Object(b.h)(t.file));
						let p = !1;
						try {
							const s = await Object(i.g)(n(), m, t, v.a.Widgets);
							s && (e(Object(i.j)(s)), p = !0)
						} catch (f) {
							if (f instanceof Error) throw f;
							e(Object(i.i)(f))
						}
						return p
					}
				}, P = Object(r.a)(E.d), R = Object(r.a)(E.e), A = (e, t) => async (n, s, r) => {
					let {
						apiContext: i
					} = r;
					n(Object(o.h)(t));
					const a = Object(_.Y)(s(), {
							subredditId: e
						}).name,
						d = await m(i(), a);
					if (d.ok) {
						const s = d.body;
						n(R({
							subredditId: e,
							widgets: s
						})), n(Object(o.e)(t))
					} else n(Object(o.f)(t, d.error))
				}, M = Object(r.a)(E.c), L = Object(r.a)(E.b), D = Object(r.a)(E.a), F = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					n(M({
						subredditId: e
					}));
					const i = Object(_.Y)(s(), {
							subredditId: e
						}).name,
						a = await m(o(), i, t);
					if (a.ok) {
						const t = a.body;
						n(L({
							subredditId: e,
							widgets: t
						}))
					} else n(D({
						subredditId: e,
						error: a.error
					}))
				}, U = (e, t) => async (n, s, r) => {
					let {
						apiContext: o
					} = r;
					const i = Object(_.Y)(s(), {
							subredditId: e
						}).name,
						a = await m(o(), i, !0);
					if (a.ok) return a.body.items[t]
				}
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_BANNED_CONTRIBUTORS_PENDING",
				r = "WIKI_BANNED_CONTRIBUTORS_LOADED",
				o = "WIKI_BANNED_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_BANNED_CONTRIBUTORS_LOADED",
				a = "WIKI_BANNED_CONTRIBUTOR_ADDED",
				d = "WIKI_BANNED_CONTRIBUTOR_REMOVED",
				c = "WIKI_BANNED_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiBannedContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return v
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiBannedContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						bannedMembersInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n,
							editWikiBanInfo: s
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t,
							daysRemaining: s.daysRemaining,
							note: s.note
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						bannedContributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/actions/wiki/wikiBannedContributors/constants.ts");
			const h = Object(o.a)(f.d),
				_ = Object(o.a)(f.c),
				g = Object(o.a)(f.b),
				v = e => async (t, n, s) => {
					t(h({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						i = await m(s.gqlContext(), o);
					if (i.ok) {
						const n = i.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(_({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = i.error || {
							type: r.L.UNKNOWN_ERROR
						};
						t(g({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return i.ok
				}, x = Object(o.a)(f.a), O = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(x({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2EIEjY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: O(e, t)
					}));
					return d.ok
				}, E = Object(o.a)(f.e), y = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							name: n.username,
							type: "wikibanned",
							duration: n.duration,
							ban_reason: n.banReason,
							note: n.note
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(i.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("Successfully banned user", null, {
								hk: "1VcdP9"
							})
						}));
						const r = {
								subredditName: e,
								username: t.username
							},
							o = (await m(d.gqlContext(), r)).body;
						if (o.data.subreddit.wiki) {
							const t = p(o.data.subreddit.wiki);
							n(E({
								bannedContributor: t.bannedContributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						u.error.type === r.L.USER_DOESNT_EXIST && (e = s.fbt._("That user doesn't exist", null, {
							hk: "1AFgzG"
						})), n(Object(i.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "14O55Y"
							})
						}))
					}
					return u.ok
				}, C = Object(o.a)(f.f), j = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikibanned"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(i.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "381leB"
						})
					})), n(C({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "4lHXgg"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: j(e, t)
					})), u.ok
				}, k = Object(o.a)(f.g), I = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.bannedContributors)[0];
							n(k({
								subredditName: e.toLowerCase(),
								bannedContributor: s.bannedContributors[r]
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2iRQ4u"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiContributors/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "WIKI_CONTRIBUTORS_PENDING",
				r = "WIKI_CONTRIBUTORS_LOADED",
				o = "WIKI_CONTRIBUTORS_FAILED",
				i = "MORE_WIKI_CONTRIBUTORS_LOADED",
				a = "WIKI_CONTRIBUTOR_ADDED",
				d = "WIKI_CONTRIBUTOR_REMOVED",
				c = "WIKI_CONTRIBUTOR_SEARCH_LOADED"
		},
		"./src/reddit/actions/wiki/wikiContributors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return v
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "d", (function() {
				return I
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/omitHeaders/index.ts"),
				l = n("./src/reddit/constants/headers.ts"),
				u = n("./src/redditGQL/operations/SubredditWikiContributors.json");
			const m = (e, t) => Object(d.a)(e, {
				...u,
				variables: t
			});
			var p = e => {
					const {
						contributorsInfo: t
					} = e, {
						edges: n,
						pageInfo: s
					} = t, r = [], o = {};
					return n.forEach(e => {
						const {
							date: t,
							redditor: n
						} = e.node;
						n.id && n.name && n.icon && (o[n.id] = {
							id: n.id,
							username: n.name,
							iconUrl: n.icon.url,
							date: t
						}, r.push(n.id))
					}), {
						afterToken: s.hasNextPage ? s.endCursor : null,
						contributors: o,
						userOrder: r
					}
				},
				b = n("./src/reddit/models/Toast/index.ts"),
				f = n("./src/reddit/actions/wiki/wikiContributors/constants.ts");
			const h = Object(o.a)(f.d),
				_ = Object(o.a)(f.c),
				g = Object(o.a)(f.b),
				v = e => async (t, n, s) => {
					t(h({
						subredditName: e
					}));
					const o = {
							subredditName: e
						},
						i = await m(s.gqlContext(), o);
					if (i.ok) {
						const n = i.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s) {
							const n = p(s);
							t(_({
								...n,
								subredditName: e.toLowerCase()
							}))
						}
					} else {
						const n = i.error || {
							type: r.L.UNKNOWN_ERROR
						};
						t(g({
							error: n,
							subredditName: e.toLowerCase()
						}))
					}
					return i.ok
				}, x = Object(o.a)(f.a), O = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							after: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki);
							n(x({
								...s,
								subredditName: e.toLowerCase()
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: O(e, t)
					}));
					return d.ok
				}, E = Object(o.a)(f.e), y = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/friend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							name: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					if (u.ok) {
						n(Object(i.f)({
							kind: b.b.SuccessMod,
							text: s.fbt._("User has been successfully added", null, {
								hk: "3mt5Vr"
							})
						}));
						const r = {
								subredditName: e,
								username: t
							},
							a = (await m(d.gqlContext(), r)).body;
						if (a.data.subreddit.wiki) {
							const t = p(a.data.subreddit.wiki),
								s = Object.keys(t.contributors)[0];
							!!o().pages.subredditWiki.wikiContributors.listing.models[e.toLowerCase()][s] || n(E({
								contributor: t.contributors,
								subredditName: e.toLowerCase(),
								userOrder: t.userOrder
							}))
						}
					} else if (u.error) {
						let e;
						const t = u.error.type;
						t === r.L.USER_DOESNT_EXIST ? e = s.fbt._("That user doesn't exist", null, {
							hk: "1OHcCX"
						}) : t === r.L.BANNED_FROM_SUBREDDIT && (e = s.fbt._("That user is banned from the subreddit", null, {
							hk: "4eZcXp"
						})), n(Object(i.f)({
							kind: b.b.Error,
							text: e || s.fbt._("Something went wrong", null, {
								hk: "3VCQr6"
							})
						}))
					}
					return u.ok
				}, C = Object(o.a)(f.f), j = (e, t) => async (n, o, d) => {
					const u = await ((e, t, n) => Object(a.a)(Object(c.a)(e, [l.a]), {
						endpoint: `${e.apiUrl}/r/${t}/api/unfriend`,
						method: r.ob.POST,
						data: {
							api_type: "json",
							id: n,
							type: "wikicontributor"
						}
					}))(d.apiContext(), e, t);
					return u.ok ? (n(Object(i.f)({
						kind: b.b.SuccessMod,
						text: s.fbt._("User has been successfully removed", null, {
							hk: "2OevWA"
						})
					})), n(C({
						subredditName: e.toLowerCase(),
						userId: t
					}))) : n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "1zUdz2"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: j(e, t)
					})), u.ok
				}, k = Object(o.a)(f.g), I = (e, t) => async (n, r, o) => {
					const a = {
							subredditName: e,
							username: t
						},
						d = await m(o.gqlContext(), a);
					if (d.ok) {
						const t = d.body;
						if (t.data.subreddit.wiki) {
							const s = p(t.data.subreddit.wiki),
								r = Object.keys(s.contributors)[0];
							n(k({
								subredditName: e.toLowerCase(),
								contributor: s.contributors[r]
							}))
						}
					} else n(Object(i.f)({
						kind: b.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2s4L9n"
						})
					}));
					return d.ok
				}
		},
		"./src/reddit/actions/wiki/wikiEditing/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "WIKI_PAGE_SAVE_SUCCESS"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "d", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			const s = "PAGE__SUBREDDIT_WIKI_PAGE_SETTINGS_LOADED",
				r = "SUBREDDIT_WIKI_PAGE_SETTINGS_UPDATED",
				o = "SUBREDDIT_WIKI_PAGE_CONTRIBUTOR_REOVED",
				i = "SUBREDDIT_WIKI_PAGE_MORE_CONTRIBUTORS_LOADED"
		},
		"./src/reddit/actions/wiki/wikiPageSettings/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "d", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/subredditSettings.ts"),
				a = n("./src/reddit/actions/toaster.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/reddit/constants/headers.ts"),
				m = n("./src/reddit/models/SubredditWikiPage/index.ts"),
				p = n("./src/redditGQL/operations/SubredditWikiPageSettings.json");
			const b = (e, t) => Object(c.a)(e, {
					...p,
					variables: t
				}),
				f = {
					[m.a.Inherit]: "0",
					[m.a.Contributors]: "1",
					[m.a.Mods]: "2"
				};
			var h = e => {
					const {
						editPermissions: t,
						editorsInfo: n,
						isVisible: s
					} = e, {
						edges: r,
						pageInfo: o
					} = n, i = [];
					return r.forEach(e => {
						e.node.name && e.node.icon && i.push({
							username: e.node.name,
							iconUrl: e.node.icon.url
						})
					}), {
						editPermissions: t,
						editorsInfo: i,
						isVisible: s,
						afterToken: o.hasNextPage ? o.endCursor : null
					}
				},
				_ = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				g = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/selectors/subreddit.ts"),
				x = n("./src/reddit/actions/wiki/wikiPageSettings/constants.ts");
			const O = Object(o.a)(x.c),
				E = (e, t) => async (n, s, r) => {
					const o = {
							subredditName: e,
							wikiPageName: t
						},
						a = await b(r.gqlContext(), o),
						d = Object(v.I)(s(), e);
					if (Object(v.ab)(s(), d) || await n(Object(i.h)(e, d)), a.ok) {
						const e = a.body,
							t = e.data.subreddit && e.data.subreddit.wiki;
						if (t && t.page) {
							const e = h(t.page.settings);
							n(O({
								pageKey: Object(_.a)(o),
								settings: e
							}))
						}
					}
					return a.ok
				}, y = Object(o.a)(x.b), C = (e, t, n) => async (r, o, i) => {
					const d = {
							subredditName: e,
							wikiPageName: t,
							after: n
						},
						c = await b(i.gqlContext(), d);
					if (c.ok) {
						const n = c.body,
							s = n.data.subreddit && n.data.subreddit.wiki;
						if (s && s.page) {
							const n = h(s.page.settings),
								{
									editorsInfo: o,
									afterToken: i
								} = n;
							r(y({
								editorsInfo: o,
								afterToken: i,
								pageKey: Object(_.a)({
									wikiPageName: t,
									subredditName: e
								})
							}))
						}
					} else r(Object(a.f)({
						kind: g.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "P9mov"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: C(e, t, n)
					}));
					return c.ok
				}, j = Object(o.a)(x.d), k = e => {
					let {
						editPermissions: t,
						isVisible: n,
						wikiPageName: s,
						subredditName: o
					} = e;
					return async (e, i, a) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/wiki/settings/${e.wikiPageName}`,
							method: r.ob.POST,
							data: {
								permlevel: f[e.editPermissions],
								listed: e.isVisible ? "on" : void 0
							}
						}))({
							context: a.apiContext(),
							editPermissions: t,
							isVisible: n,
							wikiPageName: s,
							subredditName: o
						});
						return c.ok && e(j({
							editPermissions: t,
							isVisible: n,
							pageKey: Object(_.a)({
								wikiPageName: s,
								subredditName: o
							})
						})), c.ok
					}
				}, I = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: o
					} = e;
					return async (e, i, c) => {
						const m = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/add`,
							method: r.ob.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: c.apiContext(),
							wikiPageName: o,
							subredditName: t,
							username: n
						});
						if (m.ok) e(Object(a.f)({
							kind: g.b.SuccessCommunity,
							text: "User successfully added"
						})), await e(E(t, o));
						else if (m.error) {
							const t = m.error.type;
							let n = s.fbt._("Something went wrong", null, {
								hk: "8AkV3"
							});
							t === r.L.NOT_FOUND_ERROR && (n = s.fbt._("That user does not exist", null, {
								hk: "XDM7X"
							})), e(Object(a.f)({
								kind: g.b.Error,
								text: n
							}))
						}
						return m.ok
					}
				}, S = Object(o.a)(x.a), w = e => {
					let {
						subredditName: t,
						username: n,
						wikiPageName: s
					} = e;
					return async (e, o, i) => {
						const c = await (e => Object(d.a)(Object(l.a)(e.context, [u.a]), {
							endpoint: `${e.context.apiUrl}/r/${e.subredditName}/api/wiki/alloweditor/del`,
							method: r.ob.POST,
							data: {
								page: e.wikiPageName,
								username: e.username
							}
						}))({
							context: i.apiContext(),
							wikiPageName: s,
							subredditName: t,
							username: n
						});
						return c.ok && (e(Object(a.f)({
							kind: g.b.SuccessCommunity,
							text: "User has been successfully removed"
						})), e(S({
							username: n,
							pageKey: Object(_.a)({
								wikiPageName: s,
								subredditName: t
							})
						}))), c.ok
					}
				}
		},
		"./src/reddit/actions/wiki/wikiRevisions/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = "WIKI_REVISIONS_PENDING",
				r = "WIKI_REVISIONS_LOADED",
				o = "WIKI_REVISIONS_FAILED",
				i = "WIKI_PAGE_REVERT_SUCCESS",
				a = "WIKI_REVISION_TOGGLE_VISIBILITY"
		},
		"./src/reddit/actions/wiki/wikiRevisions/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "a", (function() {
				return I
			})), n.d(t, "b", (function() {
				return w
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeActionCreator/index.ts"),
				i = n("./src/reddit/actions/toaster.ts"),
				a = n("./src/reddit/endpoints/page/subredditWiki.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/redditGQL/operations/WikiRevisions.json");
			var l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/omitHeaders/index.ts"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/wiki/wikiRevision.ts");
			var b = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/hide`,
				method: r.ob.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var f = (e, t) => Object(l.a)(Object(u.a)(e, [m.a]), {
				endpoint: `${e.apiUrl}/r/${t.subredditName}/api/wiki/revert`,
				method: r.ob.POST,
				data: {
					page: t.wikiPageName,
					revision: Object(p.b)(t.revisionId)
				}
			});
			var h = e => {
					const t = e.subreddit && e.subreddit.wiki || {},
						n = t.pageRevisions && t.pageRevisions.revisions || t.recentRevisions;
					if (!n) throw new Error("Invalid response");
					return (e => {
						const t = {},
							n = [];
						return e.edges.forEach(e => {
							const s = e.node;
							t[s.id] = s, n.push(s.id)
						}), {
							pageInfo: e.pageInfo,
							revisions: t,
							revisionsIds: n
						}
					})(n)
				},
				_ = n("./src/reddit/helpers/wiki/makeRevisionsListingKey.ts"),
				g = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/subredditWiki.ts"),
				O = n("./src/reddit/actions/wiki/wikiRevisions/constants.ts");
			const E = Object(o.a)(O.d),
				y = Object(o.a)(O.c),
				C = Object(o.a)(O.b),
				j = e => async (t, n, o) => {
					const {
						canLoadMore: a = !1,
						canShowFailToast: l = !1,
						isRecent: u,
						subredditName: m,
						wikiPageName: p
					} = e, b = n(), f = Object(_.a)(e), g = Object(x.p)(b, {
						listingKey: f
					});
					if (!a && !!g) return !0;
					const O = g && g.pageInfo.endCursor || void 0;
					if (!(!g || g.pageInfo.hasNextPage)) return !0;
					const k = {
							after: O,
							isRecent: u,
							subredditName: m,
							wikiPageName: p
						},
						I = {
							key: f,
							options: k
						};
					t(E(I));
					const S = await ((e, t) => Object(d.a)(e, {
						...c,
						variables: t
					}))(o.gqlContext(), k);
					if (S.ok) {
						const e = S.body;
						if (e.data.subreddit) {
							const n = h(e.data);
							t(y({
								...I,
								...n
							}))
						}
					} else {
						const n = S.error || {
							type: r.L.UNKNOWN_ERROR
						};
						t(C({
							...I,
							error: n
						})), l && t(Object(i.f)({
							kind: v.b.Error,
							text: s.fbt._("Something went wrong", null, {
								hk: "1e4Swa"
							}),
							buttonText: s.fbt._("Retry", null, {
								hk: "1QXiG6"
							}),
							buttonAction: j(e)
						}))
					}
					return S.ok
				}, k = Object(o.a)(O.a), I = e => async (t, n, r) => {
					const {
						subredditName: o,
						wikiPageName: d
					} = e, c = Object(g.a)({
						...e,
						revisionId: void 0
					}), l = Object(_.a)({
						...e,
						isRecent: !1
					}), u = Object(_.a)({
						...e,
						isRecent: !0
					}), m = Object(x.p)(n(), {
						listingKey: l
					}), p = m && m.ids[0];
					if ((await f(r.apiContext(), e)).ok) {
						const e = (await Object(a.a)(r.gqlContext(), {
								includePageData: !0,
								subredditName: o,
								wikiPageName: d
							})).body,
							n = e.data.subreddit && e.data.subreddit.wiki,
							m = n && n.page;
						if (!m || !m.revision) return;
						if (m.revision.id === p) return void t(Object(i.f)({
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Wiki page is already at selected revision!", null, {
								hk: "46i9jx"
							})
						}));
						t(k({
							page: m,
							pageKey: c,
							pageRevisionsListingKey: l,
							recentRevisionsListingKey: u,
							subredditName: o,
							wikiPageName: d
						}))
					} else t(Object(i.f)({
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2L5ytY"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: I(e)
					}))
				}, S = Object(o.a)(O.e), w = e => async (t, n, r) => {
					const o = await b(r.apiContext(), e);
					if (o.ok) {
						const n = o.body.status;
						t(S({
							revisionId: e.revisionId,
							isHidden: n
						}))
					} else t(Object(i.f)({
						kind: v.b.Error,
						text: s.fbt._("Something went wrong", null, {
							hk: "2gGq8w"
						}),
						buttonText: s.fbt._("Retry", null, {
							hk: "1QXiG6"
						}),
						buttonAction: I(e)
					}))
				}
		},
		"./src/reddit/components/AdLinkWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				AdLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				adLinkWrapper: "LniF5nGHFXZ6i7_mQiEaT",
				ctaExperiment: "_3JgLF82C_0NM3uN8pOyJTu",
				borders: "_3LUqJuEsn44ivYFDMegLQG",
				borderTop: "_2n1stnecLcYB2e1RjBwSq_",
				borderBottom: "_2EVJbBkxJortsXpkuVWaPA"
			}
		},
		"./src/reddit/components/AdLinkWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				a = n("./src/reddit/components/AdLinkWrapper/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = function(e) {
				const {
					className: t,
					ctaExperimentDesign: n,
					children: s,
					...a
				} = e, l = Object(o.a)(d.a.adLinkWrapper, t, {
					[d.a.ctaExperiment]: !!n,
					[d.a.borders]: "classic" === n,
					[d.a.borderTop]: "compact" === n || "conversation" === n,
					[d.a.borderBottom]: "card" === n
				});
				return r.a.createElement("div", c({
					className: l,
					"data-adclicklocation": i.a.CTA_WHITESPACE
				}, a), s)
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.m.less": function(e, t, n) {
			e.exports = {
				displayUrl: "Nd1oMnpI7mh5Ewfm9VQxq",
				ctaExperimentLink: "a3FqJA6bjuoLKqPBEp52R",
				leftSideContent: "_1oCxYg3Tu1IIcDUUOu9gIA",
				ctaExperimentNoPadding: "_2pWpf_lwFeF9qkMKAgnF1j",
				ctaExperimentPadded: "_3xECPPLU5gHGEwtMV_um7R",
				productTitle: "_3IN2NbpghDp3ddkK_5fJX8",
				subcaption: "_20wkPJgadrJIAZtTeFXQXU",
				caption: "_2LmxORnqxzKG1lDeTP_w6R"
			}
		},
		"./src/reddit/components/AdLinkWrapperContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/CallToActionButton/index.tsx"),
				d = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				u = n("./src/reddit/components/AdLinkWrapperContent/index.m.less"),
				m = n.n(u);
			t.a = e => {
				const {
					adLinkContent: t,
					post: n,
					isCompact: r
				} = e, {
					source: u,
					callToAction: p,
					caption: b
				} = t;
				if (!u || !u.url) return null;
				let f = u.displayText;
				u.displayText.length >= 40 && (f = u.displayText.slice(0, 40 - "...".length) + "...");
				const h = Object(c.u)(n, u.displayText),
					_ = Object(c.v)(n) ? f : b,
					g = Object(c.v)(n) ? n.subcaption : u.displayText,
					v = Object(i.a)(m.a.leftSideContent, {
						[m.a.ctaExperimentNoPadding]: e.ctaExperimentDesign && "card" !== e.ctaExperimentDesign,
						[m.a.ctaExperimentPadded]: "card" === e.ctaExperimentDesign
					}),
					x = Object(i.a)(m.a.displayUrl, {
						[m.a.ctaExperimentLink]: !!e.ctaExperimentDesign
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: v
				}, b && !r && !h && o.a.createElement("span", {
					className: m.a.caption,
					title: b,
					"data-adclicklocation": l.a.CTA_CAPTION
				}, b), !h && o.a.createElement(d.a, {
					href: u.url.replace(s.a.redditUrl, ""),
					isSponsored: n.isSponsored,
					postId: n.id,
					source: u,
					className: x,
					"data-adclicklocation": l.a.CTA_URL
				}, f), h && o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
					className: m.a.productTitle
				}, _), o.a.createElement("span", {
					className: m.a.subcaption
				}, g))), p && o.a.createElement(a.a, {
					className: m.a.callToAction,
					href: u.url,
					isSponsored: n.isSponsored,
					postId: n.id,
					source: u,
					showCTAExperiment: !!e.ctaExperimentDesign,
					"data-adclicklocation": l.a.CTA_BUTTON
				}, p))
			}
		},
		"./src/reddit/components/AdViewability/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/ads/store.ts"),
				u = n("./src/lib/onFocusAndVisibilityChange/index.ts"),
				m = n("./src/reddit/connectors/PostViewable/index.ts"),
				p = n("./src/reddit/constants/adEvents.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/selectors/media.ts"),
				h = n("./src/reddit/selectors/video.ts");
			const _ = [{
					event: p.a.ViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.m
				}, {
					event: p.a.Impression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.GalleryItemImpression,
					threshold: c.c,
					viewabilityMinimum: c.d
				}, {
					event: p.a.VendorFullyInView,
					threshold: c.b,
					viewabilityMinimum: c.f
				}, {
					event: p.a.GroupMViewable,
					threshold: c.b,
					viewabilityMinimum: c.m
				}, {
					event: p.a.VendorFullyInViewSeconds5,
					threshold: c.l,
					viewabilityMinimum: c.h,
					remainingTime: c.h,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}, {
					event: p.a.VendorFullyInViewSeconds15,
					threshold: c.l,
					viewabilityMinimum: c.g,
					remainingTime: c.g,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				g = [{
					event: p.a.VideoViewableImpression,
					threshold: c.l,
					viewabilityMinimum: c.k,
					remainingTime: c.k,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoFullyViewableImpression,
					threshold: c.a,
					viewabilityMinimum: c.i,
					remainingTime: c.i,
					timeViewingInterrupted: 0
				}, {
					event: p.a.VideoGroupMViewable,
					threshold: void 0,
					viewabilityMinimum: c.k,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0,
					checkAudible: !0
				}, {
					event: p.a.VideoVendorFullyViewable50,
					threshold: c.a,
					viewabilityMinimum: void 0,
					remainingTime: void 0,
					timeViewingInterrupted: 0,
					cumulative: !0,
					cumulativeElapsedTime: 0
				}],
				v = e => e.map(e => {
					let {
						event: t,
						cumulative: n = !1,
						cumulativeElapsedTime: s,
						remainingTime: r,
						threshold: o = null,
						viewabilityMinimum: i,
						checkAudible: a = !1,
						timeViewingInterrupted: d
					} = e;
					return {
						event: t,
						cumulative: n,
						checkAudible: a,
						timer: null,
						fired: !1,
						threshold: o,
						remainingTime: r,
						cumulativeElapsedTime: 0,
						viewabilityMinimum: i,
						timeViewingInitialized: 0,
						timeViewingInterrupted: d
					}
				}),
				x = () => v(_),
				O = () => v(g),
				E = [c.c, c.e, c.l, c.j, c.a, c.b],
				y = [c.c, c.l, c.j, c.a],
				C = [c.c, c.e, c.l, c.b],
				j = e => "boolean" == typeof e.cumulative && e.cumulative,
				k = Object(a.c)({
					continuousViewingStartedAt: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.b)(e, {
							postId: n.id
						})
					},
					videoDuration: (e, t) => {
						let {
							post: n
						} = t;
						const s = Object(h.h)(e, {
							postId: n.id
						});
						if (s) return s.length
					},
					isAudible: e => Object(f.a)(e),
					isPlaying: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.d)(e, {
							postId: n.id
						})
					},
					isFullScreen: (e, t) => {
						let {
							post: n
						} = t;
						return Object(h.e)(e, {
							postId: n.id
						})
					}
				}),
				I = Object(m.a)(k);
			class S extends o.Component {
				constructor(e) {
					super(e), this.viewabilityStats = x(), this.videoStats = O(), this.pageInFocus = !0, this.inViewStats = [], this.outOfViewStats = [], this.handleViewabilityChange = e => {
						this.props.trackDisplay && this.handleThresholds(e, c.r), this.props.trackVideo && this.handleThresholds(e, c.p, !0), this.checkViewabilityByType(e)
					}, this.checkViewabilityByType = e => {
						if (r()(this.state.event, e) || this.setState({
								event: e
							}), this.props.trackDisplay) {
							const t = this.props.post.media && Object(b.F)(this.props.post.media);
							this.viewabilityStats.forEach(n => {
								(n.event !== p.a.GalleryItemImpression || t) && this.checkViewability(e, n)
							})
						}
						this.props.isPlaying && this.props.trackVideo && this.videoStats.forEach(t => {
							t.checkAudible && !this.props.isAudible || this.checkViewability(e, t)
						})
					}, this.state = {
						event: null,
						currentContinuousViewingStartedAt: e.continuousViewingStartedAt
					}
				}
				componentDidMount() {
					this.visibilityChangeSubscriptionId = u.a.subscribe(e => {
						this.pageInFocus = e.documentInFocus, this.state.event && this.handleViewabilityChange(this.state.event)
					})
				}
				componentWillUnmount() {
					const {
						post: e,
						trackDisplay: t,
						trackVideo: n
					} = this.props;
					this.visibilityChangeSubscriptionId && u.a.unsubscribe(this.visibilityChangeSubscriptionId), t && (l.d(e.id, c.r, !1), this.viewabilityStats.forEach(e => {
						j(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), n && (l.d(e.id, c.p, !0), this.videoStats.forEach(e => {
						j(e) && e.cumulative && this.pauseCumulativeStats(e), this.clearTimer(e)
					})), this.outOfViewStats = [], this.inViewStats = []
				}
				componentDidUpdate() {
					this.props.trackVideo && (this.state.currentContinuousViewingStartedAt === this.props.continuousViewingStartedAt ? (this.handleThresholds(this.state.event, c.p, !0), this.videoStats.forEach(e => {
						!this.props.isPlaying || e.checkAudible && !this.props.isAudible ? e.cumulative ? this.pauseCumulativeStats(e) : this.pauseViewableStats(e) : this.checkViewability(this.state.event, e)
					})) : this.resetTimers())
				}
				resetTimers() {
					this.videoStats.forEach(e => {
						e.cumulative || this.resetTimer(e)
					}), this.setState({
						currentContinuousViewingStartedAt: this.props.continuousViewingStartedAt
					})
				}
				resetTimer(e) {
					this.clearTimer(e), e.timeViewingInitialized = 0, void 0 !== e.viewabilityMinimum && (e.remainingTime = e.viewabilityMinimum)
				}
				pauseViewableStats(e) {
					let t;
					if (!e.timer || e.fired) return;
					e.timeViewingInterrupted = Date.now();
					const n = e.timeViewingInterrupted - e.timeViewingInitialized;
					t = (e.viewabilityMinimum || 0) - n, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e)
				}
				pauseCumulativeStats(e) {
					let t;
					e.timer && !e.fired && (e.timeViewingInterrupted = Date.now(), e.cumulativeElapsedTime += e.timeViewingInterrupted - e.timeViewingInitialized, t = (e.viewabilityMinimum || 0) - e.cumulativeElapsedTime, e.remainingTime = t > 0 ? t : 0, this.clearTimer(e))
				}
				meetsViewabilityRequirements(e, t) {
					let n, s = !1,
						r = !1;
					return "object" == typeof t ? (n = t.threshold, s = !!t.playing, r = !!t.withSound) : n = t, this.isAdequatelyInView(e, n) && (!s || this.props.isPlaying) && (!r || this.props.isAudible)
				}
				handleThresholds(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					const {
						post: s
					} = this.props, o = t.filter(t => this.meetsViewabilityRequirements(e, t));
					!r()(o, this.inViewStats) && o.length > 0 && l.b(s.id, o, n);
					const i = t.filter(t => !this.meetsViewabilityRequirements(e, t));
					!r()(i, this.outOfViewStats) && i.length > 0 && l.d(s.id, i, n), this.outOfViewStats = i, this.inViewStats = o
				}
				isAdequatelyInView(e, t) {
					return !!this.props.isFullScreen || !!e && e.intersectionRatio >= t && this.pageInFocus
				}
				addDurationBasedViewabilityMinimum(e) {
					this.props.videoDuration ? e.viewabilityMinimum = Math.min(.5 * this.props.videoDuration, c.g) : e.viewabilityMinimum = c.g, e.remainingTime = e.viewabilityMinimum
				}
				adjustThreshold(e, t) {
					const {
						height: n,
						width: s
					} = e.boundingClientRect;
					return !t.threshold && t.event === p.a.VideoGroupMViewable && this.props.videoDuration && (t.threshold = s * n < 3e5 ? c.a : c.j, t.viewabilityMinimum = .5 * this.props.videoDuration), t.event === p.a.GroupMViewable && s * n > 242500 && (t.threshold = c.l), t
				}
				checkViewability(e, t) {
					if (j(t) && t.event === p.a.VideoVendorFullyViewable50 && this.addDurationBasedViewabilityMinimum(t), e && e.target && this.adjustThreshold(e, t), t.threshold && void 0 !== t.viewabilityMinimum) {
						if (this.isAdequatelyInView(e, t.threshold) && !t.fired) {
							if (t.timer) return;
							const e = this.getLengthForTimer(t);
							return e > 0 ? this.initTimer(t, e) : this.fireStat(t), void(t.timeViewingInitialized = Date.now())
						}
						j(t) && t.cumulative && this.pauseCumulativeStats(t), this.clearTimer(t)
					}
				}
				clearTimer(e) {
					e.timer && (clearTimeout(e.timer), e.timer = null)
				}
				getLengthForTimer(e) {
					return void 0 !== e.remainingTime ? e.remainingTime : e.viewabilityMinimum || 0
				}
				fireStat(e) {
					setTimeout(() => this.props.onPostViewable(this.props.post, e.event), 0), e.fired = !0
				}
				initTimer(e, t) {
					this.clearTimer(e), e.timer = window.setTimeout(() => {
						this.fireStat(e)
					}, t)
				}
				render() {
					const {
						trackDisplay: e,
						trackVideo: t
					} = this.props;
					let n = E;
					return e && !t ? n = C : !e && t && (n = y), i.a.createElement(d.a, {
						threshold: n,
						onChange: this.handleViewabilityChange
					}, this.props.children)
				}
			}
			t.a = I(S)
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_2MgVqpGJKTGicaQowt_R9h",
				primaryButton: "_2MgVqpGJKTGicaQowt_R9h"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/controls/TextButton/index.tsx"),
				m = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				p = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				b = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.m.less"),
				f = n.n(b);
			const h = a.a.wrapped(l.l, "PrimaryButton", f.a);
			class _ extends o.a.Component {
				constructor(e) {
					super(e), this.onInputChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						e.onAddSubmitter(e.subredditId, t.username), e.sendEventWithName("add")(), e.toggleModal()
					}, this.state = {
						username: ""
					}
				}
				componentDidMount() {
					this.setState({
						username: this.props.username || ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(d.e, null, o.a.createElement(d.i, null, o.a.createElement(p.a, null, o.a.createElement(d.q, null, s.fbt._("Add approved user", null, {
						hk: "rVlIL"
					})), o.a.createElement(u.a, {
						onClick: e.toggleModal
					}, o.a.createElement(d.b, null)))), o.a.createElement(d.l, null, o.a.createElement(c.d, {
						placeholder: s.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: this.onInputChange,
						value: this.state.username,
						autoFocus: !0
					})), o.a.createElement(d.g, null, o.a.createElement(d.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(h, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !Object(m.a)(t.username)
					}, s.fbt._("Add user", null, {
						hk: "23A7cj"
					}))))
				}
			}
			t.a = Object(i.a)(_)
		},
		"./src/reddit/components/ApprovedSubmitterList/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				pencilIcon: "_1XoRj9AWrCZUnxJt2JB2QS",
				noPermissions: "_2LSmyOf3zXlFqKumLW0h7B"
			}
		},
		"./src/reddit/components/ApprovedSubmitterList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedSubmitters.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				_ = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/Scroller/Simple.tsx"),
				v = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				x = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				O = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				C = n("./src/reddit/models/SubredditModeration/index.ts"),
				j = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./src/lib/objectSelector/index.ts"),
				I = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const S = Object(k.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				const s = e.pages.modHub.approvedSubmitters.userOrder[n];
				return s ? s.map(t => e.pages.modHub.approvedSubmitters.models[n][t]) : I.a
			});
			var w = n("./src/reddit/selectors/user.ts"),
				T = n("./src/reddit/contexts/PageLayer/index.tsx"),
				N = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				P = n("./src/reddit/components/ApprovedSubmitterList/index.m.less"),
				R = n.n(P);
			const A = 24,
				M = Object(T.v)({
					username: e => Object(T.Z)(e).user
				}),
				L = Object(d.c)({
					approvedSubmitters: S,
					approvedSubmittersListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(C.e)(n);
						return !!e.pages.modHub.approvedSubmitters.api.pending[s]
					},
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(j.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(j.a)(e),
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedSubmitters.loadMore[n]
					},
					searchPending: e => !!e.pages.modHub.approvedSubmitters.search.api.pending,
					searchResult: e => e.pages.modHub.approvedSubmitters.search.result,
					currentUser: w.l
				}),
				D = Object(a.b)(L, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addSubmitter: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)(n, {
							after: t
						})),
						removeSubmitter: (t, n) => e(Object(m.d)(t, n)),
						searchForSubmitter: (t, n) => e(Object(m.c)(t, n)),
						toggleRemoveUserModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						toggleAddUserModal: () => e(Object(u.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class F extends i.a.Component {
				constructor(e) {
					super(e), this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveUserModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeSubmitter(this.props.subredditId, this.state.userId)
					}, this.onSearch = e => {
						this.props.searchForSubmitter(this.props.subredditId, e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveSubmitter = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddUserModal()
					}, this.renderUser = e => {
						var t, n;
						return i.a.createElement(O.b, {
							timeAgo: i.a.createElement(b.d, {
								seconds: e.approvedAtUTC
							}),
							pageName: l.mc.Contributors,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.id ? i.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.username}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, i.a.createElement(E.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? i.a.createElement(E.r, {
								onClick: () => this.handleRemoveToggled(e.id, e.username)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: e.accountIcon,
							username: e.username
						})
					}, this.renderAddUserModal = () => i.a.createElement(N.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.props.addSubmitter,
						sendEventWithName: this.props.sendEventWithName,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: this.props.username,
						withOverlay: !0
					}), this.state = C.a
				}
				componentDidMount() {
					this.props.username && this.approveSubmitter()
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedSubmitters.length ? t.approvedSubmitters[t.approvedSubmitters.length - 1].id : void 0, a = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return t.approvedSubmitters.length ? i.a.createElement(i.a.Fragment, null, a && i.a.createElement(_.c, null, i.a.createElement(E.l, {
						onClick: this.approveSubmitter
					}, r.fbt._("Approve user", null, {
						hk: "2v6FxN"
					}))), i.a.createElement(_.a, {
						className: Object(c.a)(!a && R.a.noPermissions)
					}, i.a.createElement(_.b, null, r.fbt._("Approved users", null, {
						hk: "1alMeD"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), i.a.createElement(x.b, {
						activeSearchQuery: this.state.searchTerm,
						onSearch: this.onSearch
					}), n.searchTerm ? i.a.createElement(v.a, {
						cancelSearch: this.cancelSearch,
						noResultsFound: !t.searchResult,
						searchPending: t.searchPending,
						searchTerm: n.searchTerm
					}, t.searchResult && this.renderUser(t.searchResult)) : i.a.createElement(g.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedSubmitters.map((e, t) => ({
						estHeight: A,
						id: e.id,
						render: () => this.renderUser(e)
					})))), t.isAddUserModalOpen && this.renderAddUserModal(), t.isConfirmModalOpen && n.userId && n.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved user?", [r.fbt._param("username", n.username)], {
							hk: "4ELjHt"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveUserModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					})) : i.a.createElement(i.a.Fragment, null, a && i.a.createElement(_.c, null, i.a.createElement(E.l, {
						onClick: this.approveSubmitter
					}, r.fbt._("Approve user", null, {
						hk: "1qX1LT"
					}))), i.a.createElement(_.a, {
						className: Object(c.a)(!a && R.a.noPermissions)
					}, i.a.createElement(_.b, null, r.fbt._("Approved users", null, {
						hk: "pxkv2"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009164452`
					})), t.approvedSubmittersListPending ? i.a.createElement(O.a, null) : i.a.createElement(f.c, {
						text: r.fbt._("No approved users in {subredditName}", [r.fbt._param("subredditName", t.subreddit.displayText)], {
							hk: "1VEG1v"
						})
					}, i.a.createElement(y.a, {
						name: "edit",
						className: R.a.PencilIcon
					}))), t.isAddUserModalOpen && this.renderAddUserModal())
				}
			}
			t.a = M(D(F))
		},
		"./src/reddit/components/AvatarPost/index.m.less": function(e, t, n) {
			e.exports = {
				avatarPostContainer: "_2nck8non0VYnkIkyUpuvpw",
				avatarPostImage: "_2yQLdTnHA0y3hZ3I588oUM"
			}
		},
		"./src/reddit/components/BadgeCounter/index.m.less": function(e, t, n) {
			e.exports = {
				badgeCounter: "_1-nIsCaWhGBFN-L4ZHnbGp",
				mEmpty: "_3FX9lCQKNdKXkfBiSWCjSb"
			}
		},
		"./src/reddit/components/BadgeCounter/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./src/reddit/components/BadgeCounter/index.m.less"),
				d = n.n(a);
			t.a = e => {
				let {
					className: t,
					isActive: n,
					showEmpty: s,
					unreadCount: a,
					testId: c
				} = e;
				return n ? r.a.createElement("span", {
					className: Object(o.a)(t, d.a.badgeCounter, {
						[d.a.mEmpty]: s || a < 1
					}),
					"data-testid": c
				}, s || a < 1 ? "" : Object(i.b)(a)) : null
			}
		},
		"./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("BannedUserModal").then(n.bind(null, "./src/reddit/components/BannedUserList/AddBannedUserModal/_AddBannedUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/BannedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				UnthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				unthreadedComment: "lOLiM3i26F_WjvQ8LeLft",
				BanReason: "SrZ1u3sJDzvdTgFW_XYZl",
				banReason: "SrZ1u3sJDzvdTgFW_XYZl",
				ExpandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				expandedComponentContainer: "_3q58C3lscUB_CbjoSfgVW2",
				ModNote: "_3hA381rnksvJreaBfQTIC3",
				modNote: "_3hA381rnksvJreaBfQTIC3",
				ModNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				modNoteContainer: "_35E0y1j_QASeOMGpNM97k7",
				SectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				sectionTitle: "_3QIBdlHwReGVNodLBY3cSt",
				ContextContainer: "_1pqL5T1jpl-iWaJcvRftmU",
				contextContainer: "_1pqL5T1jpl-iWaJcvRftmU"
			}
		},
		"./src/reddit/components/BannedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				BanIcon: "_1c2rKv1iuQylye8ejI6-1v",
				banIcon: "_1c2rKv1iuQylye8ejI6-1v"
			}
		},
		"./src/reddit/components/BannedUserList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return J
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditModeration/ban.ts"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				p = n("./src/reddit/components/HumanDate/index.tsx"),
				b = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				h = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/Scroller/Simple.tsx"),
				g = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				x = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				O = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/bannedUser.ts"),
				k = n("./src/reddit/components/BannedUserList/AddBannedUserModal/index.tsx"),
				I = n("./src/lib/lessComponent.tsx"),
				S = n("./src/reddit/components/Comments/UnthreadedComment/index.tsx"),
				w = n("./src/reddit/components/CompactPost/index.tsx"),
				T = n("./src/reddit/contexts/PageLayer/index.tsx"),
				N = n("./src/reddit/contexts/Post/index.tsx"),
				P = n("./src/reddit/selectors/commentSelector.ts"),
				R = n("./src/reddit/components/BannedUserList/ExpandedComponent.m.less"),
				A = n.n(R);
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), L = Object(T.v)({
				currentProfileName: T.j,
				isCommentsPage: T.y,
				isCommentPermalink: T.x,
				isProfilePostListing: T.N,
				pageLayer: e => e
			}), D = I.a.wrapped(S.c, "UnthreadedComment", A.a), F = I.a.div("BanReason", A.a), U = I.a.div("ExpandedComponentContainer", A.a), B = I.a.div("ModNote", A.a), q = I.a.div("ModNoteContainer", A.a), G = I.a.div("SectionTitle", A.a), H = I.a.div("ContextContainer", A.a), W = e => () => {}, V = e => {
				let {
					commentId: t
				} = e;
				const n = Object(a.e)(e => Object(P.b)(e, {
					commentId: t
				}));
				return n && n.postId ? i.a.createElement(N.a, {
					postId: n.postId
				}, i.a.createElement(D, {
					commentId: t,
					highlight: !1,
					trackClick: W
				})) : null
			};
			var z = L(e => {
					const {
						currentProfileName: t,
						isCommentPermalink: n,
						isCommentsPage: s,
						isProfilePostListing: r,
						pageLayer: o,
						user: a
					} = e;
					return i.a.createElement(U, null, a.modNote && i.a.createElement(q, null, i.a.createElement(G, null, M._("Mod note:", null, {
						hk: "2LBtSw"
					})), i.a.createElement(B, null, a.modNote)), i.a.createElement("div", null, i.a.createElement(G, null, M._("Banned For:", null, {
						hk: "3UbXsX"
					})), i.a.createElement(F, null, a.reason), (a.postId || a.commentId) && i.a.createElement(H, null, a.postId && i.a.createElement(w.default, {
						currentProfileName: t,
						isCommentsPage: s,
						isCommentPermalink: n,
						isProfilePostListing: r,
						pageLayer: o,
						last: !0,
						postId: a.postId,
						hideModTools: !0,
						inSubredditOrProfile: !0
					}), a.commentId && i.a.createElement(V, {
						commentId: a.commentId
					}))))
				}),
				K = n("./src/reddit/components/BannedUserList/index.m.less"),
				Q = n.n(K);
			const Y = 48,
				J = e => null == e ? r.fbt._("Permanent", null, {
					hk: "3pNDzS"
				}) : r.fbt._({
					"*": "{number} days left",
					_1: "1 day left"
				}, [r.fbt._plural(e, "number")], {
					hk: "3VM32a"
				}),
				X = Object(d.c)({
					bannedUsers: j.h,
					bannedUsersList: j.d,
					bannedUsersListPending: j.c,
					loadMoreToken: j.e,
					isBanUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(C.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--BanUserConfirmation" === Object(C.a)(e),
					searchPending: j.f,
					searchResult: j.g
				}),
				Z = Object(a.b)(X, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(u.c)(n, {
							after: t
						})),
						onUnbanUser: t => () => e(Object(u.e)(n, t)),
						searchForBannedUser: t => e(Object(u.d)(n, t)),
						toggleBanUserModal: () => e(Object(l.i)("ModerationPage--Modal--AddUser"))
					}
				});
			class $ extends i.a.Component {
				constructor(e) {
					super(e), this.handleBanUserToggled = e => {
						if (e) {
							const {
								id: t,
								username: n
							} = e;
							this.setState({
								userId: t,
								username: n
							})
						} else this.setState({
							...y.a,
							searchTerm: this.state.searchTerm
						});
						this.props.isBanUserModalOpen || this.props.sendEventWithName(e ? "edit_user" : "ban_dialog_banpage")(), this.props.toggleBanUserModal()
					}, this.addBannedUser = () => this.handleBanUserToggled(null), this.onSearch = e => {
						this.props.searchForBannedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.renderBannedUser = e => {
						const t = this.props.bannedUsers[e] || this.props.searchResult,
							n = J(t.duration);
						return t ? i.a.createElement(x.b, {
							description: t.reason,
							expandedComponent: i.a.createElement(z, {
								user: t
							}),
							pageName: c.mc.Banned,
							primaryButton: i.a.createElement(O.r, {
								onClick: () => this.handleBanUserToggled(t),
								"data-redditstyle": !0
							}, r.fbt._("Edit", null, {
								hk: "1nftDt"
							})),
							subredditId: this.props.subredditId,
							timeAgo: i.a.createElement(i.a.Fragment, null, i.a.createElement(p.d, {
								seconds: t.bannedAtUTC
							}), " (", n, ")"),
							userIcon: t.accountIcon,
							username: t.username
						}) : i.a.createElement("div", null)
					}, this.renderAddBannedUserModal = () => i.a.createElement(k.a, {
						ignoreDefaultFocus: !0,
						onUnbanUser: this.state.userId ? this.props.onUnbanUser(this.state.userId) : void 0,
						subredditId: this.props.subredditId,
						toggleModal: () => this.handleBanUserToggled(null),
						trackAddEvent: this.props.sendEventWithName("add_banpage"),
						trackEventWithName: this.props.sendEventWithName,
						user: this.state.userId ? this.state.searchTerm ? this.props.searchResult || null : this.props.bannedUsers[this.state.userId] : null,
						withOverlay: !0
					}), this.state = y.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = e.bannedUsersList.length ? e.bannedUsersList[e.bannedUsersList.length - 1].id : void 0;
					return e.bannedUsersList.length ? i.a.createElement(i.a.Fragment, null, i.a.createElement(h.c, null, i.a.createElement(O.l, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, r.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), i.a.createElement(h.a, null, i.a.createElement(h.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), i.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), i.a.createElement(v.b, {
						onSearch: this.onSearch,
						activeSearchQuery: this.state.searchTerm
					}), t.searchTerm ? i.a.createElement(g.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderBannedUser(e.searchResult.id)) : i.a.createElement(_.b, {
						loadMoreToken: n,
						onLoadMore: this.onLoadMore
					}, e.bannedUsersList.map(e => ({
						estHeight: Y,
						id: e.id,
						render: () => this.renderBannedUser(e.id)
					})))), e.isBanUserModalOpen && this.renderAddBannedUserModal(), e.isConfirmModalOpen && t.userId && t.username && i.a.createElement(m.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to ban {username}?", [r.fbt._param("username", t.username)], {
							hk: "4f7Mkp"
						}),
						onConfirm: () => {},
						toggleModal: e.toggleBanUserModal,
						trackClick: e.sendEventWithName("remove")
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(h.c, null, i.a.createElement(O.l, {
						onClick: this.addBannedUser,
						"data-redditstyle": !0
					}, " ", r.fbt._("Ban user", null, {
						hk: "2q7TuL"
					}))), i.a.createElement(h.a, null, i.a.createElement(h.b, null, r.fbt._("Banned users", null, {
						hk: "3hvISm"
					}), i.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.bannedUsersListPending ? i.a.createElement(x.a, null) : i.a.createElement(b.c, {
						text: r.fbt._("No banned users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1nOcbC"
						})
					}, i.a.createElement(E.a, {
						name: "ban",
						className: Q.a.BanIcon
					}))), e.isBanUserModalOpen && this.renderAddBannedUserModal())
				}
			}
			t.a = Z($)
		},
		"./src/reddit/components/BlockNavigation/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router/esm/react-router.js"),
				a = n("./src/reddit/actions/modal.ts");
			const d = "non-empty-string-to-block-navigation";
			class c extends r.a.Component {
				constructor() {
					super(...arguments), this.onBeforeUnload = e => {
						if (this.props.enabled) return e.preventDefault(), e.returnValue = "", ""
					}, this.message = (e, t) => {
						return !0 === (this.props.confirmNavigate || this.defaultConfirmNavigate)(e, t) || d
					}, this.defaultConfirmNavigate = (e, t) => {
						const {
							ignoreCurrentLocation: n = !0,
							location: s,
							showModal: r,
							dialogId: o
						} = this.props;
						return !(!n || e.pathname !== s.pathname) || (o && r(), !1)
					}
				}
				componentDidMount() {
					this.props.blockOnBeforeUnload && window.addEventListener("beforeunload", this.onBeforeUnload)
				}
				componentWillUnmount() {
					this.props.blockOnBeforeUnload && window.removeEventListener("beforeunload", this.onBeforeUnload)
				}
				render() {
					const {
						enabled: e = !0
					} = this.props;
					return r.a.createElement(i.b, {
						message: this.message,
						when: e
					})
				}
			}
			t.a = Object(o.b)(null, (e, t) => ({
				showModal: () => e(Object(a.h)(t.dialogId))
			}))(Object(i.i)(c))
		},
		"./src/reddit/components/CCM/AddModNoteCTA/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/reddit/contexts/PageLayer/index.tsx"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				u = n("./src/reddit/components/Hovercards/helpers.ts"),
				m = n("./src/reddit/components/PostTopMeta/index.tsx"),
				p = n("./src/reddit/hooks/useIsOverlay.ts"),
				b = n("./src/reddit/models/Post/index.ts"),
				f = n("./src/redditGQL/types.ts");
			const h = Object(d.v)();
			t.a = h(e => {
				let {
					pageLayer: t,
					postOrComment: n,
					className: d
				} = e;
				var h;
				const _ = Object(p.a)(),
					g = Object(i.d)(),
					v = (null === (h = null == t ? void 0 : t.urlParams) || void 0 === h ? void 0 : h.pageName) === a.wb.Modqueue,
					x = Object(r.useCallback)(() => {
						const e = Object(u.b)({
							itemId: n.id,
							tooltipIdPrefix: l.a,
							tooltipType: _ ? m.f.Lightbox : void 0
						});
						g(Object(c.h)({
							tooltipId: e,
							args: {
								isModNotesView: !0,
								modNotesFilter: f.x.Note
							}
						}))
					}, [n, g, _]);
				return !v || Object(b.p)(n.author) ? null : o.a.createElement("button", {
					className: d,
					onClick: x
				}, s.fbt._("Add a note", null, {
					hk: "1dmmma"
				}))
			})
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ModerationLogFilters",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModerationLogFilters").then(n.bind(null, "./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/Action/index.m.less": function(e, t, n) {
			e.exports = {
				actionLink: "_28SdCXCgfR0vAmVJxu6-36"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.m.less": function(e, t, n) {
			e.exports = {
				bullet: "_2NlviZ4OCkAQ6ccvVO5UKP",
				icon: "_3pfYW7u0eipWXzeAU7bAH"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/moderationLog.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.m.less"),
				l = n.n(c);
			t.a = e => {
				let {
					category: t,
					onClick: n
				} = e;
				const s = Object(o.e)(a.eb),
					c = i.e[t],
					u = s ? i.f[t] : i.d[t],
					m = i.c[t];
				return m ? r.a.createElement("button", {
					className: l.a.bullet,
					style: {
						background: u
					},
					onClick: n ? () => n(t) : void 0
				}, r.a.createElement(d.a, {
					name: c,
					className: l.a.icon
				}), m()) : null
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/DetailsColumn/index.m.less": function(e, t, n) {
			e.exports = {
				title: "_1Qgx8pnOedeEcUq1Aq7nnI",
				titleLink: "_3kK7NXJ6HXs_ri8LQwEjsP",
				content: "VQD060Jlvk5c0sh6AFZp8",
				contentLink: "d952AWo5Tt44L0YhpuoUH",
				detailsType: "_1IMWJItpkXdv4aQ8ONBhPq",
				usernameLink: "_34auX_aCptXoIb7c7744y-",
				expandButton: "_3J69NuGduUVAs7ZP_p_Lna"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_3ylwGIumN6Usp9S0wyrUaD",
				thumbnail: "_3Z1cNySjt_ptG1UcbJvKix",
				blur: "EfkQdGKgBzVW902KMircF"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less": function(e, t, n) {
			e.exports = {
				body: "_2rttRV2XGKDsn9MzINY3OH",
				bodyExpanded: "_2b_AtwH66JK156EkcBDM0d",
				seeMore: "WoZ7u09hFLxJLrpjCwQzd"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less": function(e, t, n) {
			e.exports = {
				previewInfo: "_3GbSYbYdsqwQtlFTG_8n_I",
				previewInfoItem: "fQ-tARWmzWFHWbBpup9Z6"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_39tOdYiwnq1F1StfeCfMw2",
				contentWrapperComment: "_1AhVlTZKxaFeJ3o1wiyhaz",
				title: "zNUbRkrX31LKGQyn6kybd",
				authorLink: "_37cQc-cNah-iE4GOzG7qES"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/ModerationLogItem/index.m.less": function(e, t, n) {
			e.exports = {
				row: "_21wBv1F97jRGr7cFOkkCJE",
				dateCell: "_6EVzgYd9a6dYgbfgRERA4",
				modCell: "_3Z-rQJg_uFjkxGkMrsmUn0",
				modNameAndIconContainer: "_1iY1HavVYTo4oCrYd78WrE",
				modNameAndIcon: "_2mOXiCh_6Z4sEH3RuMtEo-",
				actionCategoryCell: "_1abC0NqB4IvxHMrdWEYZpm",
				actionCell: "_3K7ZZHqE-muy3Z4WyyRObc",
				takedownContentPreview: "V0oJFR3vDQ2gfIPbbusXq"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/PageLimit/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2dp3heyx3W_muidSvrAtbe",
				dropdown: "_1zelwPtWhXpA0U4vKtSppP"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_30Tatb_Hd9Ia0IxUf_1fcq",
				table: "_9ZBCc4lvvSOp7lMsuGyFZ",
				controlRow: "_19avorQMLJgpADLYzbu7Lg",
				filters: "_30ALxCcNK-RqU6mCGsR7RX",
				paging: "_3FHBykioCchdAa3cFob_ip",
				pageLimit: "_2rc3n-RQJfDFYBJZ2d4fnm",
				title: "_1z1Hw7iREBdwhCqbaJ5diX",
				emptyPanel: "_2_imy3guN_jJPm-R93J_Ka",
				emptyIcon: "_3KJYvAtYbiobspSNUSIkNr"
			}
		},
		"./src/reddit/components/CCM/ModerationLog/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/react-router-redux/es/index.js"),
				c = n("./src/reddit/hooks/useTracking.ts"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/stripQueryParams/index.ts"),
				p = n("./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts"),
				b = n("./src/reddit/helpers/trackers/modLog.ts"),
				f = n("./src/reddit/actions/moderationLog/allModerators.ts"),
				h = n("./src/lib/makeActionCreator/index.ts"),
				_ = n("./node_modules/lodash/isEmpty.js"),
				g = n.n(_),
				v = n("./src/reddit/endpoints/subredditModeration/moderationLog.ts");
			var x = n("./src/reddit/actions/moderationLog/constants.ts");
			const O = Object(h.a)(x.b);
			var E = n("./src/reddit/components/CCM/ModerationLog/Filters/ActionsDropdown/Loader.tsx"),
				y = n("./src/reddit/components/CCM/ModerationLog/Filters/DateRangeDropdown/Loader.tsx"),
				C = n("./src/reddit/components/CCM/ModerationLog/Filters/ModeratorsDropdown/Loader.tsx"),
				j = n("./src/reddit/components/CCM/ModerationLog/Filters/UsernameDropdown/Loader.tsx"),
				k = n("./src/reddit/constants/intlSupport.ts"),
				I = n("./src/reddit/components/HumanDate/HumanDate.tsx"),
				S = n("./src/reddit/components/IdentityAndIcon/index.tsx"),
				w = n("./src/reddit/constants/moderationLog.ts"),
				T = n("./src/reddit/controls/InvisibleScreenReaderText/index.tsx"),
				N = n("./src/reddit/models/User/index.ts"),
				P = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/Action/index.m.less"),
				R = n.n(P);
			const A = e => {
				let {
					action: t,
					onClick: n
				} = e;
				const s = w.b[t];
				return i.a.createElement("button", {
					className: R.a.actionLink,
					onClick: n ? () => n(t) : void 0
				}, s && s())
			};
			var M = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/ActionCategory/index.tsx"),
				L = n("./src/reddit/components/AuthorLink/index.tsx"),
				D = n("./node_modules/lodash/noop.js"),
				F = n.n(D),
				U = n("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				B = n("./src/reddit/components/Hovercards/helpers.ts"),
				q = n("./src/reddit/components/Hovercards/HoverDiv/index.tsx");
			var G = e => {
					const t = Object(B.b)({
							author: e.author,
							itemId: e.contextId,
							tooltipIdPrefix: "ModerationLogUserInfoTooltip"
						}),
						n = `${t}-hover-id`,
						s = e.author;
					return i.a.createElement(q.a, {
						authorOrSubredditName: s,
						className: e.hoverDivClassName,
						hoverId: n,
						sendHoverEvent: F.a,
						tooltipId: t
					}, i.a.createElement("div", {
						id: t
					}, e.children), i.a.createElement(U.a, {
						className: e.className,
						contextId: e.contextId,
						hoverId: n,
						sendEvent: F.a,
						subredditId: e.subredditId,
						tooltipId: t,
						userName: s
					}))
				},
				H = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.tsx"),
				W = n("./src/reddit/components/TrackingHelper/index.tsx"),
				V = n("./src/reddit/models/Comment/index.ts"),
				z = n("./src/reddit/models/FeedElement/index.ts"),
				K = n("./src/redditGQL/types.ts"),
				Q = n("./src/reddit/helpers/graphql/helpers.ts");
			const Y = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === N.c.AvailableRedditor ? t.name : null
				},
				J = e => `${e.id}-takedown-content-preview`,
				X = e => {
					var t;
					return null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.violatedContentPolicyRule
				},
				Z = e => {
					const {
						target: t,
						takedownContentPreview: n
					} = e;
					if (!t || !n) return null;
					const {
						title: s,
						body: r,
						thumbnail: o,
						violatedContentPolicyRule: i
					} = n;
					if ((e => e.__typename === z.a.SubredditPost)(t)) {
						const e = t,
							{
								score: n,
								commentCount: a,
								createdAt: d
							} = e;
						return {
							title: s,
							body: r,
							thumbnail: o,
							violatedContentPolicyRule: i,
							score: n,
							commentCount: a,
							author: Y(e),
							createdAt: Object(Q.g)(d)
						}
					}
					if ((e => e.__typename === V.d.Comment)(t)) {
						const e = t,
							{
								score: n,
								createdAt: s,
								postInfo: o
							} = e;
						return {
							title: null == o ? void 0 : o.title,
							body: r,
							parent: {
								score: null == o ? void 0 : o.score,
								commentCount: null == o ? void 0 : o.commentCount,
								createdAt: (null == o ? void 0 : o.createdAt) ? Object(Q.g)(null == o ? void 0 : o.createdAt) : null
							},
							score: n,
							author: Y(e),
							createdAt: Object(Q.g)(s)
						}
					}
					return null
				},
				$ = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === N.c.AvailableRedditor && t.name || null
				};
			var ee = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/DetailsColumn/index.m.less"),
				te = n.n(ee);
			const ne = e => {
				let {
					action: t,
					showTakedownPreview: n,
					subredditId: s,
					toggleShowTakedownPreview: r
				} = e;
				const a = Object(W.b)(),
					{
						authorUsername: d,
						title: c,
						content: l,
						urlPath: u
					} = (e => {
						var t, n, s, r;
						const o = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let i = e.target;
						switch (o) {
							case z.a.SubredditPost:
								return {
									authorUsername: $(i = i), title: (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.title) || i.title, content: (null === (s = e.takedownContentPreview) || void 0 === s ? void 0 : s.body) || i.content && i.content.markdown, urlPath: i.permalink
								};
							case z.a.DeletedSubredditPost:
								return {
									authorUsername: null, title: (i = i).title, content: null, urlPath: i.permalink
								};
							case N.c.AvailableRedditor:
								return {
									authorUsername: (i = i) && i.name || null, title: null, content: null, urlPath: void 0
								};
							case V.d.Comment:
								return {
									authorUsername: $(i = i), title: null, content: (null === (r = e.takedownContentPreview) || void 0 === r ? void 0 : r.body) || i.content && i.content.markdown, urlPath: i.permalink
								};
							case V.d.DeletedComment:
								return {
									authorUsername: null, title: (i = i).postInfo && i.postInfo.title, content: null, urlPath: i.postInfo && i.postInfo.permalink
								};
							default:
								return {
									authorUsername: null, title: null, content: null, urlPath: void 0
								}
						}
					})(t),
					{
						text: m,
						url: p
					} = (e => {
						var t;
						const {
							actionNotes: n,
							details: s,
							takedownContentPreview: r
						} = e;
						if (null == r ? void 0 : r.violatedContentPolicyRule) return {
							text: w.l[r.violatedContentPolicyRule](),
							url: r.violatedContentPolicyRule === K.h.Dmca ? w.j : w.i
						};
						const o = (null === (t = w.g[s]) || void 0 === t ? void 0 : t.call(w.g)) || s;
						return n ? o ? {
							text: `${o}: ${e.actionNotes}`
						} : {
							text: n
						} : {
							text: o
						}
					})(t),
					f = (e => {
						var t;
						const n = X(e) || void 0,
							s = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
						let r = e.target;
						switch (s) {
							case z.a.SubredditPost:
							case z.a.DeletedSubredditPost:
								return {
									post: {
										id: (r = r).id
									}, comment: void 0, violatedContentPolicyRule: n
								};
							case V.d.Comment:
							case V.d.DeletedComment:
								return {
									post: void 0, comment: {
										id: (r = r).id
									}, violatedContentPolicyRule: n
								};
							default:
								return {
									post: void 0, comment: void 0, violatedContentPolicyRule: n
								}
						}
					})(t),
					h = (e => !!X(e))(t),
					_ = Object(o.useCallback)(() => {
						r(), n || a(Object(b.j)(f))
					}, [f, a, n, r]),
					g = Object(o.useCallback)(() => a(Object(b.k)(f)), [f, a]),
					v = Object(o.useCallback)(() => a(Object(b.l)(f)), [f, a]),
					x = Object(o.useCallback)(() => a(Object(b.i)(f)), [f, a]);
				return i.a.createElement("div", {
					className: te.a.container
				}, i.a.createElement("div", {
					className: te.a.detailsContainer
				}, d && !w.k.includes(d) ? i.a.createElement(G, {
					contextId: t.id,
					alwaysShowChildren: !0,
					author: d,
					subredditId: s
				}, i.a.createElement(L.a, {
					className: te.a.usernameLink,
					author: d,
					onClick: g
				}, `u/${d}`)) : d, c && u && i.a.createElement(i.a.Fragment, null, i.a.createElement("h5", {
					className: te.a.title
				}, i.a.createElement("a", {
					className: te.a.titleLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: u,
					onClick: v
				}, c)), l && i.a.createElement("p", {
					className: te.a.content
				}, l)), !c && l && u && i.a.createElement("p", {
					className: te.a.content
				}, i.a.createElement("a", {
					className: te.a.contentLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: u,
					onClick: v
				}, l)), m && i.a.createElement("span", {
					className: te.a.detailsType
				}, "(", p ? i.a.createElement("a", {
					href: p,
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: x
				}, m) : m, ")")), h && i.a.createElement(H.a, {
					className: te.a.expandButton,
					action: t,
					showTakedownPreview: n,
					toggleShowTakedownPreview: _
				}))
			};
			var se = n("./src/lib/classNames/index.ts"),
				re = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less"),
				oe = n.n(re);
			const ie = e => {
				let {
					src: t
				} = e;
				const [n, s] = Object(o.useState)(!0);
				return i.a.createElement("button", {
					className: oe.a.wrapper,
					onClick: () => s(e => !e),
					role: "img",
					"aria-label": r.fbt._("Thumbnail preview of content media", null, {
						hk: "43MhFw"
					})
				}, i.a.createElement("img", {
					className: Object(se.a)(oe.a.thumbnail, {
						[oe.a.blur]: n
					}),
					src: t
				}))
			};
			var ae = n("./src/reddit/controls/Button/index.tsx"),
				de = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less"),
				ce = n.n(de);
			const le = e => {
				let {
					children: t
				} = e;
				const n = Object(o.useRef)(null),
					[s, a] = Object(o.useState)(!1);
				Object(o.useLayoutEffect)(() => {
					if (n.current) {
						const e = n.current,
							t = e.clientHeight >= e.scrollHeight;
						a(t)
					}
				}, [n, a]);
				return i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					ref: n,
					className: Object(se.a)(ce.a.body, {
						[ce.a.bodyExpanded]: s
					})
				}, t), !s && i.a.createElement(ae.t, {
					className: ce.a.seeMore,
					size: ae.d.XS,
					priority: ae.c.PlainLink,
					onClick: () => {
						a(!0)
					}
				}, r.fbt._("See more", null, {
					hk: "PNFjo"
				})))
			};
			var ue = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less"),
				me = n.n(ue),
				pe = n("./src/reddit/components/HumanDate/index.tsx"),
				be = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less"),
				fe = n.n(be);
			const he = e => {
					let {
						author: t,
						score: n,
						commentCount: s,
						createdAt: o
					} = e;
					return i.a.createElement("ul", {
						className: fe.a.previewInfo
					}, t && i.a.createElement("li", {
						className: fe.a.previewInfoItem
					}, i.a.createElement(L.a, {
						author: t,
						className: fe.a.authorLink
					}, "u/", t)), Number.isInteger(n) && i.a.createElement("li", {
						className: fe.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} points",
						_1: "1 point"
					}, [r.fbt._plural(n, "number")], {
						hk: "1nHdfa"
					})), Number.isInteger(s) && i.a.createElement("li", {
						className: fe.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} comments",
						_1: "1 comment"
					}, [r.fbt._plural(s, "number")], {
						hk: "1izKX9"
					})), o && i.a.createElement("li", {
						className: fe.a.previewInfoItem
					}, i.a.createElement(pe.d, {
						seconds: o / u.Xb
					})))
				},
				_e = e => {
					let {
						action: t
					} = e;
					var n, s, r;
					const o = Z(t);
					return null === o ? null : i.a.createElement("article", {
						className: me.a.container,
						id: J(t)
					}, (null == o ? void 0 : o.title) && i.a.createElement("p", {
						className: me.a.title
					}, o.title), i.a.createElement("div", {
						className: Object(se.a)({
							[me.a.contentWrapperComment]: !!o.parent
						})
					}, (null == o ? void 0 : o.body) && i.a.createElement(le, null, o.body), (null == o ? void 0 : o.thumbnail) && i.a.createElement(ie, {
						src: o.thumbnail
					}), i.a.createElement(he, {
						author: null == o ? void 0 : o.author,
						score: null == o ? void 0 : o.score,
						commentCount: null == o ? void 0 : o.commentCount,
						createdAt: null == o ? void 0 : o.createdAt
					})), (null == o ? void 0 : o.parent) && i.a.createElement(he, {
						score: null === (n = null == o ? void 0 : o.parent) || void 0 === n ? void 0 : n.score,
						commentCount: null === (s = null == o ? void 0 : o.parent) || void 0 === s ? void 0 : s.commentCount,
						createdAt: null === (r = null == o ? void 0 : o.parent) || void 0 === r ? void 0 : r.createdAt
					}))
				};
			var ge = n("./src/reddit/components/CCM/ModerationLog/ModerationLogItem/index.m.less"),
				ve = n.n(ge);
			const xe = e => {
					const t = new Date(e * u.Xb);
					return k.a ? new Intl.DateTimeFormat("en-US", {
						hour: "numeric",
						minute: "numeric"
					}).format(t) : `${t.getHours()}:${t.getMinutes}`
				},
				Oe = e => {
					var t;
					return (null == e ? void 0 : e.__typename) === N.c.AvailableRedditor ? null === (t = e.icon) || void 0 === t ? void 0 : t.url : void 0
				};
			var Ee = e => {
					let {
						action: t,
						actionsUnderCategory: n,
						subredditId: s,
						updateParams: a
					} = e;
					const [d, c] = Object(o.useState)(!1), l = (e => (null == e ? void 0 : e.__typename) === N.c.AvailableRedditor ? e.displayName : null)(t.moderatorInfo), m = !!l && !w.k.includes(l), p = (e => {
						var t, n;
						return !!((null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.title) || (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.body))
					})(t), b = Object(o.useCallback)(e => a({
						actions: [e]
					}), [a]), f = Object(o.useCallback)(() => a({
						actions: n
					}), [a, n]);
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("tr", {
						className: ve.a.row
					}, i.a.createElement("td", {
						className: ve.a.dateCell
					}, r.fbt._("{time} on {date}", [r.fbt._param("time", xe(t.createdAt / u.Xb)), r.fbt._param("date", i.a.createElement(I.a, {
						seconds: t.createdAt / u.Xb,
						showDay: !0,
						shortMonths: !0
					}))], {
						hk: "1YNruk"
					})), i.a.createElement("td", {
						className: ve.a.modCell
					}, l && m ? i.a.createElement(S.a, {
						className: ve.a.modNameAndIconContainer,
						username: l,
						iconClassName: ve.a.modNameAndIcon,
						iconSize: 24,
						userIcon: Oe(t.moderatorInfo)
					}) : l), i.a.createElement("td", {
						className: ve.a.actionCategoryCell
					}, t.actionCategory && i.a.createElement(M.a, {
						category: t.actionCategory,
						onClick: f
					})), i.a.createElement("td", {
						className: ve.a.actionCell
					}, i.a.createElement(A, {
						action: t.action,
						onClick: b
					})), i.a.createElement("td", null, i.a.createElement(ne, {
						action: t,
						subredditId: s,
						showTakedownPreview: d,
						toggleShowTakedownPreview: () => c(!d)
					}), p && !d && i.a.createElement(T.a, null, r.fbt._("No content preview shown. Press show details in previous cell to reveal.", null, {
						hk: "3OP9nc"
					})), !p && i.a.createElement(T.a, null, r.fbt._("No content preview available.", null, {
						hk: "4mp2x9"
					})))), p && d && i.a.createElement("tr", null, i.a.createElement("td", {
						colSpan: 5,
						className: ve.a.takedownContentPreview
					}, i.a.createElement(_e, {
						action: t
					}))))
				},
				ye = n("./src/reddit/components/CCM/ModerationLog/PageLimit/index.m.less"),
				Ce = n.n(ye);
			var je = e => {
					const [t, n] = Object(o.useState)(e.limit || 50);
					e.limit && e.limit !== t && n(e.limit);
					const s = Object(o.useCallback)(t => {
							const s = parseInt(t.target.value, 10) || 50;
							n(s), e.onChange && e.onChange(s)
						}, [e]),
						a = e.max !== e.approximateMax,
						d = Math.max(t * e.pageNumber + 1, 1),
						c = a ? Math.min(d, e.max) : d,
						l = t * (e.pageNumber + 1),
						u = a ? Math.min(l, e.max) : l,
						m = `${e.max.toLocaleString()}${a?"":"+"}`;
					return i.a.createElement("label", {
						className: Object(se.a)(Ce.a.container, e.className)
					}, i.a.createElement("span", {
						className: Ce.a.limit
					}, r.fbt._("{Left page limit}–{Right page limit} of {Max}", [r.fbt._param("Left page limit", c.toLocaleString()), r.fbt._param("Right page limit", u.toLocaleString()), r.fbt._param("Max", m)], {
						hk: "2bGsu9"
					})), e.availableLimits && i.a.createElement("select", {
						className: Ce.a.dropdown,
						onChange: s,
						value: t
					}, e.availableLimits.map((e, t) => i.a.createElement("option", {
						value: e,
						key: `${e}_${t}`
					}, e))))
				},
				ke = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				Ie = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				Se = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				we = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				Te = n("./src/reddit/constants/parameters.ts"),
				Ne = n("./src/reddit/contexts/PageLayer/index.tsx"),
				Pe = n("./src/reddit/selectors/moderationLog.ts"),
				Re = n("./src/reddit/components/CCM/ModerationLog/index.m.less"),
				Ae = n.n(Re);
			const Me = Object(Ne.v)({
					currentPageUrl: Ne.f,
					queryParams: Ne.Z
				}),
				Le = e => new Date(e).toISOString().slice(0, 10);
			t.a = Me(e => {
				const t = Object(c.a)(),
					{
						currentPageUrl: n,
						queryParams: h,
						subreddit: _,
						subredditId: x
					} = e,
					k = Object(a.d)(),
					I = Object(a.e)(t => Object(Pe.c)(t, e)),
					S = Object(a.e)(e => Object(Pe.e)(e)),
					w = Object(a.e)(e => Object(Pe.d)(e)),
					T = Object(a.e)(t => Object(Pe.f)(t, e)),
					N = Object(a.e)(t => Object(Pe.g)(t, e)),
					P = Object(a.e)(e => Object(Pe.h)(e)),
					R = Object(a.e)(e => Object(Pe.b)(e));
				Object(o.useEffect)(() => {
					k(Object(f.a)(_.name))
				}, [k, _.name]), Object(o.useEffect)(() => {
					k((() => async (e, t, n) => {
						let {
							gqlContext: s
						} = n;
						const r = t();
						if (!g()(r.pages.modHub.moderationLog.actionCategories)) return;
						const o = await Object(v.a)(s());
						if (o.body) {
							const t = o.body.data.moderationActionCategories;
							if (t) {
								const n = (e => e.reduce((e, t) => ({
									...e,
									[t.category]: t.actions
								}), {}))(t);
								e(O({
									normalizedCategories: n
								}))
							}
						}
					})())
				}, [k]);
				const A = Object(o.useCallback)(e => k(Object(d.b)(e)), [k]),
					M = Object(o.useCallback)(() => t(Object(b.m)()), [t]),
					L = ((e, t) => {
						const n = Object(p.b)(e, t);
						return n[Te.x] = parseInt(t[Te.x], 10) || 0, n[Te.Q] = t[Te.Q], n
					})(_.name, h),
					D = L.pageNumber || 0,
					F = Object(o.useCallback)(e => {
						const t = {
								...L,
								last: void 0,
								before: void 0,
								after: void 0,
								pageNumber: 0,
								first: L.last || L.first || p.a,
								...e
							},
							s = Object.keys(t).reduce((e, n) => ({
								...e,
								[n]: Array.isArray(t[n]) ? t[n].join(",") : t[n]
							}), {});
						return Object(l.a)(Object(m.a)(n), s)
					}, [n, L]),
					U = Object(o.useCallback)(e => {
						const t = F(e);
						A(t)
					}, [A, F]),
					B = {
						pageNumber: D > 0 ? D - 1 : 0,
						before: P || void 0,
						first: void 0,
						last: L.last || L.first || p.a,
						after: void 0
					},
					q = {
						pageNumber: D + 1,
						after: S || void 0,
						before: void 0,
						last: void 0,
						first: L.last || L.first || p.a
					},
					G = e => U(e),
					H = Object(o.useCallback)(e => {
						U({
							last: void 0,
							before: void 0,
							after: void 0,
							first: e,
							pageNumber: 0
						}), t(Object(b.n)())
					}, [U, t]),
					W = !I.length,
					V = Le(Date.now() - 90 * u.E),
					z = Le(Date.now()),
					K = L.startDate ? L.startDate : V,
					Q = L.endDate ? L.endDate : z;
				return i.a.createElement(we.a, {
					className: Ae.a.contentContainer
				}, i.a.createElement(we.b, null, r.fbt._("Mod Log", null, {
					hk: "2wnuzj"
				}), i.a.createElement(Ie.a, {
					onClick: M,
					linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360022402312`
				})), i.a.createElement("span", {
					className: Ae.a.title
				}, r.fbt._("Filter by", null, {
					hk: "3RkGvd"
				})), i.a.createElement("div", {
					className: Ae.a.controlRow
				}, i.a.createElement("div", {
					className: Ae.a.filters
				}, i.a.createElement(y.a, {
					shouldShowDefaultTitle: !L.startDate && !L.endDate,
					startDate: K,
					endDate: Q,
					maxDate: z,
					minDate: V,
					onApply: G
				}), i.a.createElement(C.a, {
					moderatorNames: "string" == typeof L.moderatorNames ? [L.moderatorNames] : L.moderatorNames,
					onApply: G,
					subredditId: x
				}), i.a.createElement(E.a, {
					actions: "string" == typeof L.actions ? [L.actions] : L.actions,
					onApply: G
				}), i.a.createElement(j.a, {
					userName: L.userName,
					onApply: e => U({
						targetAuthorIds: e.userId ? [e.userId] : void 0,
						userName: e.userName
					})
				})), i.a.createElement("div", {
					className: Ae.a.paging
				}, !!w && i.a.createElement(je, {
					approximateMax: 5e3,
					availableLimits: [25, 50, 100, 500],
					className: Ae.a.pageLimit,
					limit: L.first || L.last,
					max: w,
					pageNumber: D,
					onChange: H
				}), i.a.createElement(Se.a, {
					prevButtonEnabled: N,
					prevTo: F(B),
					nextButtonEnabled: T,
					nextTo: F(q),
					keepDisabled: !0
				}))), W && i.a.createElement(ke.c, {
					className: Ae.a.emptyPanel,
					text: r.fbt._("No mod actions found", null, {
						hk: "y2pGb"
					})
				}, i.a.createElement("img", {
					src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`,
					className: Ae.a.emptyIcon
				})), !W && i.a.createElement("table", {
					className: Ae.a.table
				}, i.a.createElement("thead", null, i.a.createElement("tr", null, i.a.createElement("th", null, r.fbt._("Time", null, {
					hk: "4bvCKA"
				})), i.a.createElement("th", null, r.fbt._("Moderator", null, {
					hk: "2krNIi"
				})), i.a.createElement("th", null, r.fbt._("Type", null, {
					hk: "334ba7"
				})), i.a.createElement("th", null, r.fbt._("Action", null, {
					hk: "1rF6TH"
				})), i.a.createElement("th", null, r.fbt._("Details", null, {
					hk: "41wdQs"
				})))), i.a.createElement("tbody", null, I.map(e => i.a.createElement(Ee, {
					key: e.id,
					action: e,
					actionsUnderCategory: e.actionCategory ? R[e.actionCategory] : [],
					subredditId: x,
					updateParams: U
				})))))
			})
		},
		"./src/reddit/components/CallToActionButton/index.m.less": function(e, t, n) {
			e.exports = {
				CallToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				callToActionButton: "_2pjSQOdNtYd1I2W0Z1Im8I",
				ctaExperiment: "O3tUaKrd54EXILNilEqF_",
				Icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				icon: "_2W1YFyYH_CTGX4_5OEBs2Q",
				isLeft: "p8bIdnQ5pQUQRETAyCoa5",
				isRight: "_36ucS75syCWwJ_ee7IieXZ",
				active: "NPw0Z_HL-yJPXnZ3mpWEA",
				redditStyle: "OGOshepc50ul-kJHrocIO",
				mNotCardView: "_33VrFkg3gJpkL8AlPfcHUE"
			}
		},
		"./src/reddit/components/CallToActionButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/OutboundLink/index.tsx"),
				a = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				d = n("./src/reddit/components/CallToActionButton/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					showCTAExperiment: n,
					...s
				} = e;
				return r.a.createElement(i.b, l({
					className: Object(o.a)(c.a.CallToActionButton, t, {
						[c.a.mNotCardView]: s.isNotCardView,
						[c.a.ctaExperiment]: !!n
					}),
					"data-adclicklocation": a.a.CTA_BUTTON
				}, s))
			}
		},
		"./src/reddit/components/CharacterCountdown/index.m.less": function(e, t, n) {
			e.exports = {
				container: "s5ap8yh1b4ZfwxvHizW3f",
				mOverflow: "_19JhaP1slDQqu2XgT3vVS0"
			}
		},
		"./src/reddit/components/CharacterCountdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				a = n("./src/reddit/components/CharacterCountdown/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => r.a.createElement(i.b, {
				className: Object(o.a)(e.className, d.a.container, e.text.length >= e.maxChars ? d.a.mOverflow : null)
			}, c._({
				"*": "{characters} Characters remaining",
				_1: "1 Character remaining"
			}, [c._plural(e.maxChars - e.text.length, "characters")], {
				hk: "V22sW"
			}))
		},
		"./src/reddit/components/ChatButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/actions/chat/toggle.ts"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/trackers/authorHovercard.ts");
			! function(e) {
				e.awardNotification = "AWARD_NOTIFICATION"
			}(s || (s = {}));
			const u = e => {
				let {
					onStartChat: t,
					text: n,
					className: r,
					sendEvent: i,
					contextId: a,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					eventSource: b,
					onClick: f,
					onAddUserToQuickReplyList: h,
					children: _,
					style: g
				} = e;
				return o.a.createElement(c.t, {
					onClick: e => {
						if (f && f(e), t(), b === s.awardNotification) return h();
						i(Object(l.b)(a))
					},
					className: r,
					text: n,
					priority: d,
					Icon: u,
					redditStyle: m,
					isFullWidth: p,
					style: g
				}, _)
			};
			u.displayName = "ChatButton";
			const m = Object(i.b)(null, (e, t) => {
				let {
					contextId: n,
					userId: s
				} = t;
				return {
					onStartChat: () => {
						e(Object(a.b)(s, n))
					},
					onAddUserToQuickReplyList: () => {
						e(Object(a.a)(s))
					}
				}
			});
			t.b = m(Object(d.c)(u))
		},
		"./src/reddit/components/ClassicPost/Thumbnail.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Thumbnail/index.tsx"),
				a = n("./src/reddit/components/ClassicPost/index.m.less"),
				d = n.n(a);
			t.a = e => {
				let {
					className: t,
					classNameInnerThumbnail: n,
					crosspost: s,
					forceShowNSFW: a,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					thumbnailContainerClassName: b,
					url: f,
					usePreview: h
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(d.a.thumbnailContainer, t)
				}, r.a.createElement(i.b, {
					className: Object(o.a)(d.a.thumbnail, n),
					containerClassName: b,
					crosspost: s,
					forceShowNSFW: a,
					isMeta: c,
					post: l,
					redditStyle: u,
					removeLink: m,
					templatePlaceholderImage: p,
					url: m ? void 0 : f,
					usePreview: h
				}))
			}
		},
		"./src/reddit/components/ClassicPost/index.m.less": function(e, t, n) {
			e.exports = {
				adLinkWrapper: "_2c-0jMA2BuDIlKjWFiOUOt",
				ctaExperiment: "_17HI1sHAGvXEekFXNNcehn",
				classicThumbnail: "nL7Q54U2LLg9rkVdSxxLe",
				content: "_1Y6dfr4zLlrygH-FLmr8x-",
				showBulkActionCheckbox: "W-Z7cDkcZIo1dPic9COiN",
				flatlistContainer: "_36kpXQ-z7Hr61j8878uRkP",
				creatorStatsContainer: "_2I70Qhfz-GbGzP54PWXR3P",
				crosspostMediaWrapper: "_1qc1-Anfrhr6APGcBKFk8M",
				expandoContainer: "_3r40yytzBnldjGGOrs2mCw",
				flatlist: "ssgs3QQidkqeycI33hlBa",
				flatlistSeparator: "_1wDt70OnYnqsrm0XIsNn8v",
				horizontalVotes: "_3ytybPoFoY12sGn375PMy1",
				leftExpando: "_35zWJjb5RJMIMkexZ2Prus",
				mainBody: "_2XDITKxlj4y3M99thqyCsO",
				rightExpando: "_2Ddj1d6vOe9NlJqkdothNe",
				spacer: "iRkLLvxarfGu_2c7HxhW0",
				titleWithPoll: "_2FcpdQwjwRwk7X_NiZub8x",
				thumbnail: "_2e9Lv1I3dOmICVO9fg3uTG",
				thumbnailContainer: "_38EcSQ9jzVrdtzkXO1cydX",
				eventMeta: "rmPDRyja27ULjwD3rW14H",
				postContainer: "D3IyhBGwXo9jPwz-Ka0Ve",
				shouldShowOverflow: "_3FOlcZoWAvyAWZYSVd8-WD",
				shouldUseRoundedBorder: "_2g8Jz2obQVOELSfntlgVsJ",
				promotedMainBody: "_1LAkIKOirJP5Hor0NamqyY"
			}
		},
		"./src/reddit/components/CommentSort/CommentSort.m.less": function(e, t, n) {
			e.exports = {
				container: "_2ulKn_zs7Y3LWsOqoFLHPo",
				mHasOtherDiscussions: "_3iO3U_i4YUx-2qahK_BTu1",
				HighlightPicker: "_1n6gZPmNQU56UBglU718cx",
				highlightPicker: "_1n6gZPmNQU56UBglU718cx",
				Row: "zW82EsY6Pakxpq4WWvsUG",
				row: "zW82EsY6Pakxpq4WWvsUG",
				SortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				sortPicker: "_1nMYOibX9neGRqvcaCrPDz",
				containerRow: "_1avwNy0RnwlEwVEW-fwKCI",
				DropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				dropdownContainer: "_3N0NZT0gc58Hq7p0XRUjsH",
				ContestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				contestMode: "_3dAMO_XZMVp2K1JSO53ohA",
				SortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				sortOptionDropdownText: "_3LRBCA71BwLLXBNsSlY7HW",
				ToggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				toggleSwitch: "JVPG0c9TNru5TLSq9sdUG",
				DropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				dropdownTriangle: "_2MGxQvIhmM2I5CzPdSJTtM",
				hideCommentSort: "uAIheeoxWlq57lu5ghv43",
				HighlightWrapper: "_201SpO3todaXvcWUHaLymN",
				highlightWrapper: "_201SpO3todaXvcWUHaLymN",
				Info: "_1urK6AxAk9Sl76RgLUHOqh",
				info: "_1urK6AxAk9Sl76RgLUHOqh",
				SetSort: "_1Pn7_008tGFVitpaAxNI9b",
				setSort: "_1Pn7_008tGFVitpaAxNI9b",
				SingleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				singleCommentText: "_2iOrDLLjWlyPdmGh4fQMuE",
				SortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				sortLink: "_2C0TYCrsi0B3m8sQW0hmFv",
				Title: "_1MfL8RlT7Bsr76qYvR-nqM",
				title: "_1MfL8RlT7Bsr76qYvR-nqM",
				Tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				tooltip: "_2PA6P-upB6MB4B4I4WgZGA",
				ViewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				viewFullLinkContainer: "_2Cjk95J3a3LyPUHsLEhO37",
				ViewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q",
				viewFullLinkOrOverlayLink: "_3P3T6fdpdL6GGPyCM7zs9q"
			}
		},
		"./src/reddit/components/CommentSort/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return me
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/actions/comment/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/post.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/lib/makeApiRequest/index.ts"),
				h = n("./src/lib/omitHeaders/index.ts"),
				_ = n("./src/reddit/constants/headers.ts"),
				g = n("./src/reddit/models/Toast/index.ts");
			const v = (e, t) => async (n, r, o) => {
				let {
					apiContext: i
				} = o;
				const a = await (async (e, t, n) => Object(f.a)(Object(h.a)(e, [_.a]), {
						endpoint: `${e.apiUrl}/api/set_suggested_sort/`,
						method: c.ob.POST,
						data: {
							api_type: "json",
							id: t,
							sort: n
						}
					}))(i(), e, t),
					d = `error-block-${t}`,
					l = `success-block-${t}`;
				if (a.ok) {
					n(Object(p.R)({
						[e]: {
							suggestedSort: t
						}
					}));
					const r = t ? s.fbt._("Suggested sort is on.", null, {
						hk: "tW1Rb"
					}) : s.fbt._("Suggested sort is off.", null, {
						hk: "4fwvgj"
					});
					n(b.f({
						id: l,
						kind: g.b.SuccessCommunityGreen,
						text: r
					}))
				} else n(b.f({
					id: d,
					kind: g.b.Error,
					text: s.fbt._("Try again later", null, {
						hk: "1Lqlj2"
					}),
					buttonText: s.fbt._("Retry", null, {
						hk: "44HF9e"
					}),
					buttonAction: v(e, t)
				}))
			};
			var x = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				O = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				E = n("./src/reddit/components/LinkOrOverlayLink/index.tsx"),
				y = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				C = n("./src/reddit/components/TrackingHelper/index.tsx"),
				j = n("./src/reddit/controls/Dropdown/index.tsx"),
				k = n("./src/reddit/controls/Dropdown/Row.tsx"),
				I = n("./node_modules/react-router-redux/es/index.js"),
				S = n("./src/lib/addQueryParams/index.ts"),
				w = n("./src/lib/makeSearchKey/index.ts"),
				T = n("./src/lib/search/index.ts"),
				N = n("./src/reddit/actions/pages/search/index.ts"),
				P = n("./src/reddit/constants/keycodes.ts"),
				R = n("./src/reddit/constants/parameters.ts"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				M = n("./src/reddit/controls/SearchBar/index.tsx"),
				L = n("./src/reddit/helpers/clickSourceData/index.ts"),
				D = n("./src/reddit/hooks/usePageLayer.ts"),
				F = n("./src/reddit/selectors/platform.ts");
			const U = "comment-search-bar",
				B = "comment-search-button",
				q = "search/";

			function G(e) {
				const {
					expanded: t,
					bucketed: n
				} = e.experiment, a = Object(D.a)(), d = (null == a ? void 0 : a.queryParams.q) || "", [l, u] = Object(r.useState)(d), [m, p] = Object(r.useState)(t), b = Object(i.d)(), f = Object(i.e)(e => Object(A.h)(e, {
					pageLayer: a
				})), h = Object(i.e)(e => Object(A.s)(e, {
					pageLayer: a
				})), _ = Object(i.e)(e => Object(F.j)(e));

				function g() {
					if (!l.trim() || !f) return;
					const e = Object(T.b)(l),
						t = `${new URL(f.permalink).pathname}${q}`,
						n = {
							[R.z]: e,
							[R.P]: [c.ic.Comments],
							[R.C]: "1",
							...(null == h ? void 0 : h.isNSFW) ? {
								[R.L]: "1"
							} : {},
							...(null == f ? void 0 : f.isNSFW) ? {
								[R.m]: "1"
							} : {}
						},
						s = Object(L.b)(a),
						r = Object(w.b)(f.id, void 0, n);
					b(Object(N.d)({
						key: r,
						options: n,
						subredditName: null == h ? void 0 : h.name,
						postId: f.id
					}));
					const o = Object(S.a)(t, n);
					b(Object(I.b)(o, {
						...s,
						isOverlay: _
					}))
				}
				return n ? o.a.createElement("div", null, l || m ? o.a.createElement("div", {
					"data-testid": U
				}, o.a.createElement(M.a, {
					onSearch: g,
					onKeyPress: function(e) {
						e.key === P.b.Enter && g()
					},
					onTextChange: e => {
						u(e.target.value)
					},
					value: l
				})) : o.a.createElement("button", {
					"data-testid": B,
					onClick: () => p(!0)
				}, s.fbt._("Search comments", null, {
					hk: "2ObH7B"
				}))) : null
			}
			var H = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				W = n("./src/reddit/helpers/path/index.ts"),
				V = n("./src/reddit/selectors/telemetry.ts");
			n("./src/telemetry/models/Event.ts");
			const z = (e, t, n, s, r) => o => ({
					source: "comment_sort",
					action: "click",
					noun: e,
					actionInfo: {
						pageType: t ? "post_detail" : "home"
					},
					listing: Object(V.z)(o, void 0, {
						oldSort: n,
						sort: s,
						source: r
					}),
					userSubreddit: Object(V.ub)(o)
				}),
				K = (e, t) => n => ({
					source: "comment_highlighting",
					action: t,
					noun: e
				}),
				Q = e => ({
					subreddit: Object(V.kb)(e),
					userSubreddit: Object(V.ub)(e)
				}),
				Y = e => t => ({
					source: "contest_mode",
					action: "click",
					noun: e ? "enable" : "disable",
					...Q
				});
			var J = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				X = n("./src/reddit/icons/svgs/Info/index.tsx"),
				Z = n("./src/reddit/selectors/activeModalId.ts"),
				$ = n("./src/reddit/selectors/comments.ts"),
				ee = n("./src/reddit/selectors/experiments/commentSearchPdp.ts"),
				te = n("./src/reddit/selectors/moderatorPermissions.ts"),
				ne = n("./src/reddit/selectors/posts.ts"),
				se = n("./src/reddit/selectors/tooltip.ts"),
				re = n("./src/reddit/selectors/user.ts"),
				oe = n("./src/reddit/components/CommentSort/CommentSort.m.less"),
				ie = n.n(oe),
				ae = n("./src/reddit/reducers/features/comments/visitHighlightingFilter/index.ts");
			const de = Object(y.a)(j.a),
				ce = e => e === ae.a.First ? s.fbt._("First Visit", null, {
					hk: "HdDSr"
				}) : e === ae.a.Last ? s.fbt._("Last Visit", null, {
					hk: "3ubIq3"
				}) : s.fbt._("None", null, {
					hk: "4jwXNg"
				});
			class le extends o.a.Component {
				constructor() {
					super(...arguments), this.track = () => {
						const {
							trackHighlight: e,
							selectedSort: t
						} = this.props;
						if (t !== ae.a.None) {
							e(t === ae.a.Last ? "since_last_visit" : "since_first_visit", "view")
						}
					}, this.onDropdownClick = (e, t) => {
						this.props.trackHighlight(e, "click"), this.props.changeHighlightSort(t)
					}, this.onDropdownClickFirst = () => {
						this.onDropdownClick("since_first_visit", ae.a.First)
					}, this.onDropdownClickLast = () => {
						this.onDropdownClick("since_last_visit", ae.a.Last)
					}, this.onDropdownClickNone = () => {
						this.onDropdownClick("do_not_highlight", ae.a.None)
					}
				}
				componentDidMount() {
					this.track()
				}
				componentDidUpdate(e) {
					e.selectedSort !== this.props.selectedSort && this.track()
				}
				render() {
					const {
						highlightIsOpen: e,
						id: t,
						onOpen: n,
						selectedSort: r
					} = this.props;
					return o.a.createElement("div", {
						className: ie.a.HighlightWrapper
					}, o.a.createElement(k.b, {
						className: Object(d.a)(ie.a.HighlightPicker, ie.a.Row),
						textClassName: ie.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Highlight",null,{hk:"2ZiUE8"})}: ${ce(r)}`,
						id: t,
						noHover: !0,
						onClick: n
					}), o.a.createElement(J.b, {
						className: ie.a.DropdownTriangle,
						onClick: n
					}), o.a.createElement(de, {
						isOpen: e,
						renderContentsHidden: !0,
						tooltipId: t
					}, o.a.createElement(k.b, {
						displayText: ce(ae.a.First),
						isSelected: r === ae.a.First,
						onClick: this.onDropdownClickFirst
					}), o.a.createElement(k.b, {
						displayText: ce(ae.a.Last),
						isSelected: r === ae.a.Last,
						onClick: this.onDropdownClickLast
					}), o.a.createElement(k.b, {
						displayText: ce(ae.a.None),
						isSelected: r === ae.a.None,
						onClick: this.onDropdownClickNone
					})))
				}
			}
			var ue = le;
			const me = "CommentSort--SortPicker",
				pe = "CommentSort--HighlightPicker",
				be = "CommentSort--Tooltip",
				fe = Object(y.a)(j.a),
				he = Object(a.c)({
					commentPermalink: (e, t) => {
						let {
							commentId: n
						} = t;
						return n && Object($.m)(e, {
							commentId: n
						})
					},
					commentSearchPdp: e => Object(ee.a)(e),
					contestModeModalIsOpen: Object(Z.b)("CommentSort--ContestMode--Modal"),
					dropdownIsOpen: Object(se.b)(me),
					highlightIsOpen: Object(se.b)(pe),
					hasModeratorPostPermissions: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(te.m)(e, {
							postId: n
						});
						return !!s && s.posts
					},
					post: ne.G,
					postPermalink: ne.F,
					showCommentHighlighter: (e, t) => {
						let {
							postId: n
						} = t;
						const s = Object(re.w)(e),
							r = !!Object(te.m)(e, {
								postId: n
							}),
							o = Object(ne.G)(e, {
								postId: n
							});
						return (r || s) && !!o && !!o.previousVisits && o.previousVisits.length > 0
					},
					selectedHighlightSort: $.p
				}),
				_e = Object(i.b)(he, (e, t) => {
					let {
						postId: n
					} = t;
					return {
						changeHighlightSort: t => e(Object(u.b)({
							sort: t
						})),
						onOpenDropdown: () => e(Object(l.h)({
							tooltipId: me
						})),
						onOpenHighlightDropdown: t => {
							e(Object(l.h)({
								tooltipId: pe
							})), t()
						},
						onSetSuggestedSort: t => e(v(n, t)),
						hideTooltip: () => e(Object(l.i)()),
						setContestMode: t => e(Object(p.W)(t, n)),
						showTooltip: () => e(Object(l.h)({
							tooltipId: be
						})),
						toggleContestModeModal: () => e(Object(m.i)("CommentSort--ContestMode--Modal"))
					}
				});
			class ge extends o.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.sendCommentSortEvent = (e, t, n, s) => this.props.sendEvent(z(e, this.props.isOverlay, t, n, s)), this.onOpenDropdownClick = () => {
						this.props.onOpenDropdown(), this.sendCommentSortEvent("sorting", void 0, this.props.sort, "post_detail")
					}, this.onSortOptionClick = e => this.sendCommentSortEvent("sort_by", this.props.sort, e, "post_detail"), this.clearSortOnClick = () => {
						this.props.onSetSuggestedSort(null), this.sendCommentSortEvent("clear_suggested_sort", this.props.sort)
					}, this.setSortOnClick = () => {
						const e = this.props.suggestedSort || void 0;
						this.props.onSetSuggestedSort(this.props.sort), this.sendCommentSortEvent("set_suggested_sort", e, this.props.sort)
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onOpenHighlightSelector = () => {
						this.props.onOpenHighlightDropdown(K("dropdown", "click"))
					}, this.setContestMode = () => {
						this.props.sendEvent(Y(!this.props.post.contestMode)), this.props.setContestMode(!this.props.post.contestMode)
					}
				}
				addSuggestedLabel(e) {
					return s.fbt._("{sort name} (suggested)", [s.fbt._param("sort name", e)], {
						hk: "3pDfQ9"
					})
				}
				render() {
					const {
						changeHighlightSort: e,
						className: t,
						commentId: n,
						commentPermalink: r,
						commentSearchPdp: i,
						contestModeModalIsOpen: a,
						dropdownIsOpen: l,
						elementRef: u,
						hideTooltip: m,
						highlightIsOpen: p,
						hasModeratorPostPermissions: b,
						isOverlay: f,
						location: h,
						post: _,
						postPermalink: g,
						selectedHighlightSort: v,
						showCommentHighlighter: y,
						sort: C,
						suggestedSort: j,
						showTooltip: I,
						toggleContestModeModal: S
					} = this.props, w = _.contestMode, T = !h.search.includes(c.w.CONFIDENCE), N = C === c.w.CONFIDENCE && T, P = b && !N, R = c.y[C], A = R ? R() : "", M = j && C === j && !N ? this.addSuggestedLabel(A) : A, L = w ? s.fbt._("End contest mode?", null, {
						hk: "2AkJRZ"
					}) : s.fbt._("Start contest?", null, {
						hk: "2PQPOu"
					}), D = w ? s.fbt._("End", null, {
						hk: "1Q8KqM"
					}) : s.fbt._("Start", null, {
						hk: "Mjvpj"
					}), F = w ? s.fbt._("Ending contest mode will make comment vote scores visible and disable random comment ordering.", null, {
						hk: "3PXrGq"
					}) : s.fbt._("Starting a contest will hide comment vote scores and randomize the order of the comments for non-mods.", null, {
						hk: "EDqlf"
					}), U = w && !b;
					return o.a.createElement("div", {
						className: Object(d.a)(t, ie.a.container, {
							[ie.a.hideCommentSort]: !y && U
						}),
						ref: u
					}, o.a.createElement("div", {
						className: ie.a.containerRow
					}, !U && o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: ie.a.DropdownContainer
					}, o.a.createElement(k.b, {
						className: Object(d.a)(ie.a.SortPicker, ie.a.Row),
						textClassName: ie.a.SortOptionDropdownText,
						displayText: `${s.fbt._("Sort by",null,{hk:"E6T9r"})}: ${M}`,
						id: me,
						noHover: !0,
						skipRoleAttr: !0,
						onClick: this.onOpenDropdownClick
					}), o.a.createElement(J.b, {
						className: ie.a.DropdownTriangle,
						onClick: this.onOpenDropdownClick
					})), i.bucketed && o.a.createElement("div", null, o.a.createElement(G, {
						experiment: i,
						commentId: n,
						postId: this.props.postId
					})), o.a.createElement(fe, {
						isOpen: l,
						tooltipId: me
					}, [c.w.CONFIDENCE, c.w.TOP, c.w.NEW, c.w.CONTROVERSIAL, c.w.OLD, c.w.QA].map(e => {
						const t = r || g,
							n = Object(W.b)(t),
							s = c.y[e],
							i = s ? s() : "";
						return o.a.createElement(E.a, {
							className: ie.a.ViewFullLinkOrOverlayLink,
							isOverlay: f,
							key: e,
							onClick: () => this.onSortOptionClick(e),
							role: "menuitem",
							tabIndex: -1,
							to: `${n}?sort=${e}`
						}, o.a.createElement(k.b, {
							displayText: i,
							isSelected: C === e,
							skipRoleAttr: !0
						}))
					}))), P && !U && (j ? o.a.createElement("button", {
						className: ie.a.SortLink,
						onClick: C !== j ? this.setSortOnClick : this.clearSortOnClick
					}, C !== j ? s.fbt._("Set new suggested sort", null, {
						hk: "13BpoB"
					}) : s.fbt._("Clear suggested sort", null, {
						hk: "3WWQBy"
					})) : o.a.createElement("button", {
						className: ie.a.SetSort
					}, o.a.createElement("button", {
						className: ie.a.SortLink,
						onClick: this.setSortOnClick
					}, s.fbt._("Set as suggested sort", null, {
						hk: "3qLzxp"
					})), o.a.createElement("span", {
						id: be,
						onMouseEnter: I,
						onMouseLeave: m
					}, o.a.createElement(O.c, {
						className: ie.a.Tooltip,
						text: s.fbt._("Suggested sort defaults Redditors to a specific way of sorting comments within this post", null, {
							hk: "3KM0ma"
						}),
						tooltipId: be
					}), o.a.createElement(X.a, {
						className: ie.a.Info
					})))), b && o.a.createElement("button", {
						className: ie.a.ContestMode,
						onClick: this.props.toggleContestModeModal
					}, s.fbt._("Contest", null, {
						hk: "1KrhdJ"
					}), o.a.createElement(H.a, {
						className: ie.a.ToggleSwitch,
						on: w
					}))), y && o.a.createElement("div", {
						className: ie.a.containerRow
					}, o.a.createElement(ue, {
						changeHighlightSort: e,
						highlightIsOpen: p,
						id: pe,
						onOpen: this.onOpenHighlightSelector,
						selectedSort: v,
						trackHighlight: K
					})), a && o.a.createElement(x.a, {
						actionText: D,
						headerText: L,
						modalText: F,
						onConfirm: this.setContestMode,
						toggleModal: S,
						withOverlay: !0
					}))
				}
			}
			t.b = _e(Object(C.c)(ge))
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				o = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				i = n.n(o);
			const a = s.a.wrapped(r.c, "RestrictedButton", i.a);
			t.a = a
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				RestrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				restrictedButton: "_1HjNIJegwQhOyUoxHZNWnm",
				Show: "YoaDbMbI8PpFFWQbD_Uwq",
				show: "YoaDbMbI8PpFFWQbD_Uwq",
				CommentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk",
				commentModToolsFlatlist: "_3cJNzWW-kTTUFiqoBkRMRk"
			}
		},
		"./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/reddit/actions/comment/moderation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/ModModeReports/helpers.ts"),
				b = n("./src/reddit/components/TrackingHelper/index.tsx"),
				f = n("./src/reddit/contexts/PageLayer/index.tsx"),
				h = n("./src/reddit/helpers/trackers/modTools.ts"),
				_ = n("./src/reddit/selectors/moderatingComments.ts"),
				g = n("./src/reddit/selectors/moderatorPermissions.ts"),
				v = n("./src/reddit/selectors/tooltip.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				E = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				y = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				C = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				j = n("./src/reddit/icons/svgs/Show/index.tsx"),
				k = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				I = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.m.less"),
				S = n.n(I);
			const w = Object(f.v)(),
				T = e => `Distinguish--Dropdown--${e}`,
				N = Object(a.c)({
					currentUser: x.l,
					collapsedBecauseCrowdControl: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(_.a)(e, {
							commentId: n.id
						})
					},
					isDistinguishDropdownOpen: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(v.b)(T(n.id))(e)
					},
					moderatorPermissions: (e, t) => {
						const {
							comment: n
						} = t;
						return Object(f.i)(e, t) || Object(g.n)(e, {
							subredditId: n.subredditId
						})
					},
					modModeEnabled: f.W
				}),
				P = Object(i.b)(N, (e, t) => {
					let {
						comment: n
					} = t;
					return {
						onApproveComment: () => e(Object(u.a)(n.id)),
						onDistinguishComment: (t, s) => e(Object(u.b)(n.id, t, s)),
						onLockComment: () => e(Object(u.c)(n.id)),
						onRemoveComment: () => e(Object(u.e)(n.id, !1)),
						onSpamComment: () => e(Object(u.e)(n.id, !0)),
						onShowComment: () => e(Object(u.d)(n.id)),
						onToggleDistinguishDropdown: () => e(Object(m.h)({
							tooltipId: T(n.id)
						}))
					}
				});
			t.a = w(P(l.a.wrapped(Object(b.c)(e => {
				let {
					className: t,
					comment: n,
					currentUser: r,
					isCommentAuthor: i,
					collapsedBecauseCrowdControl: a,
					moderatorPermissions: l,
					modModeEnabled: u,
					onApproveComment: m,
					onDistinguishComment: b,
					onLockComment: f,
					onRemoveComment: _,
					onShowComment: g,
					onSpamComment: v,
					onToggleDistinguishDropdown: x,
					sendEvent: I,
					pageLayer: w,
					...T
				} = e;
				const N = Object(p.b)(n),
					P = n.isApproved && N,
					R = !n.isRemoved || n.bannedBy === c.m,
					A = a,
					M = e => I(Object(h.b)(e, n.id)),
					L = "chat_comments" === (null == w ? void 0 : w.queryParams.only);
				return o.a.createElement("div", {
					className: t
				}, (n.bannedBy || N) && o.a.createElement(k.a, {
					text: P ? s.fbt._("Reapprove", null, {
						hk: "1XngBU"
					}) : s.fbt._("Approve", null, {
						hk: "2219Nh"
					}),
					onClick: () => {
						m(), L && I(Object(h.a)("approve", n.id)), M("approve")
					}
				}, o.a.createElement(O.a, {
					className: S.a.icon
				})), R && o.a.createElement(o.a.Fragment, null, o.a.createElement(k.a, {
					text: n.bannedBy === c.m ? s.fbt._("Confirm Removal", null, {
						hk: "3JozXJ"
					}) : s.fbt._("Remove", null, {
						hk: "3tYl0U"
					}),
					onClick: () => {
						_(), L && I(Object(h.a)("remove", n.id)), n.bannedBy === c.m ? M("confirm_remove") : M("remove")
					}
				}, o.a.createElement(y.a, {
					className: S.a.icon
				})), o.a.createElement(k.a, {
					text: s.fbt._("Spam", null, {
						hk: "1jEVwZ"
					}),
					onClick: () => {
						v(), M("spam")
					}
				}, o.a.createElement(C.a, {
					className: S.a.icon
				}))), o.a.createElement(k.a, {
					text: n.isLocked ? s.fbt._("Unlock", null, {
						hk: "KGYeO"
					}) : s.fbt._("Lock", null, {
						hk: "3rDzwU"
					}),
					onClick: () => {
						f(), M(n.isLocked ? "unlock" : "lock")
					}
				}, o.a.createElement(E.a, {
					className: S.a.icon
				})), A && o.a.createElement(k.a, {
					text: s.fbt._("Show Comment", null, {
						hk: "2ki02n"
					}),
					onClick: () => {
						g()
					}
				}, o.a.createElement(j.a, {
					className: Object(d.a)(S.a.icon, S.a.Show)
				})))
			}), "CommentModToolsFlatlist", S.a)))
		},
		"./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less": function(e, t, n) {
			e.exports = {
				author: "DjcdNGtVXPcxG0yiFXIoZ",
				authorLine: "_1a_HxF03jCyxnx706hQmJR",
				headerLine: "_2nobNdIwmDrXK7NZps5zUO",
				flair: "cFNx42ceihnMpvAsovOTi",
				baselineItem: "_3QEK34iVL1BjyHAVleVVNQ",
				container: "-Xcv3XBXmgiY2X5RqaPbO",
				cryptoPoints: "_2bfuNFXt4pN8991xPpimzy",
				role: "_3AgEmWP1qkCB8nds7LhzEB",
				achievementFlair: "_2a_XgY10KOzM0PRvywwDuY",
				cakeDay: "TNzy9Y4Ql8v80YssZ59GR",
				metaText: "_3yx4Dn0W3Yunucf5sVJeFU",
				separator: "_8b8fUdBRxCYj9MkNpFvvv",
				userBadges: "_3AXw8D3tzlqTRxjQdd5ve7",
				userFlairLine: "_3w527zTLhXkd08MyacMV9H",
				LastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy",
				lastAuthorModNoteIcon: "_3TVHJ99XXRlGtv0wqGCBFy"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/Role.m.less": function(e, t, n) {
			e.exports = {
				role: "LWgI-A6rN9Wajn1VLxu2A",
				modAchievement: "_2am63Mu1vtyM2MwmCJoxJp"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/author.m.less": function(e, t, n) {
			e.exports = {
				authorHoverCard: "sMaSljeAO1a-nAhrURxdj",
				container: "NL6v1uLnaxK0IHIJdUdel"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less": function(e, t, n) {
			e.exports = {
				cakedayIcon: "_12wHSVQW6wUCbn56VnIfI-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less": function(e, t, n) {
			e.exports = {
				commentAuthorLink: "wM6scouPXXsFDSZmZPHRo"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less": function(e, t, n) {
			e.exports = {
				crowdControlText: "_3UBJEBi_CJ8y1i9Up_67Hb"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/edited.m.less": function(e, t, n) {
			e.exports = {
				editedText: "_18WUrfxbke5CjwIjhXu6C-"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.m.less": function(e, t, n) {
			e.exports = {
				iconStyles: "S8WH2aCfP030wVxp0iR_o",
				AdminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				adminEmeritus: "xIZgDbR-AMck1mC6sZI1m",
				AdminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				adminIcon: "_2IdAWdzNdIq-LUdJv0lpD6",
				ContractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				contractorIcon: "_39FDxNax8J3IkHXRxQmeJE",
				ModeratorIcon: "rZkjnStRKzlmtr__ixhKy",
				moderatorIcon: "rZkjnStRKzlmtr__ixhKy",
				OpIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				opIcon: "_3X_-kuWbD5_nVi9_eTAYVC",
				RightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				rightPositionedAuthorFlair: "_zMIUk6t-WDI7fxfkvD02",
				MetaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				metaSeparator: "yJGcpQjpmA13QcuUz2h0B",
				publicPoints: "_2LXcsgibmlCEsBPk8MLy7e",
				NftAuthor: "kDnKKJWz2PJGoalLInCW1",
				nftAuthor: "kDnKKJWz2PJGoalLInCW1",
				MetaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				metaLink: "_1sA-1jNHouHDpgCp1fCQ_F",
				DeletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				deletedText: "_2Wu4MNMVl4bsJ9iVnQz0dF",
				container: "_3ezOJqKdLbgkHsXcfvS5SA",
				collapsed: "_2k27lgIDltx9kOzVGXt48i",
				hasBadges: "_1KMFaeLEhRikeFEOlWE9Ti",
				liveStreaming: "_1iUed95f0HTc84gBtoOxdc",
				authorRole: "_3uDFtRr_CTErFPJQBtzECl",
				metaText: "_3_GZIIN1xcMEC5AVuv4kfa",
				separator: "_1PuBpmbH2FA5sozYR7EuCs",
				userBadges: "_3Ofd-Ek86mwX500i92F84q",
				cakeDay: "UG2sa-VYMzrn7D1iNXtfR",
				addModNote: "_3xk2cMvsSpPHBinHNwkDHi"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/AwardBadges/index.tsx"),
				u = n("./src/reddit/components/CCM/AddModNoteCTA/index.tsx"),
				m = n("./src/reddit/components/AuthorLink/index.tsx"),
				p = n("./src/reddit/components/Comments/Comment/TopMeta/commentAuthorLink.m.less"),
				b = n.n(p);
			const f = e => {
				const {
					className: t,
					collapsed: n,
					comment: r,
					isAuthorDeleted: i,
					isCommentAuthorBlocked: a,
					isLivestreaming: c,
					isEmbeddedLiveChat: l,
					isStrong: u,
					onClick: p,
					style: f
				} = e;
				return n && a ? o.a.createElement("p", {
					className: Object(d.a)(b.a.commentAuthorLink, t)
				}, s.fbt._("Blocked account", null, {
					hk: "2KVMxM"
				})) : o.a.createElement(m.a, {
					author: r.author,
					className: Object(d.a)(b.a.commentAuthorLink, t),
					isAuthorDeleted: i,
					isCommentAuthorBlocked: a,
					isLivestreaming: c,
					forceOpenInNewTab: l,
					isStrong: u,
					linkProps: {
						"data-testid": "comment_author_link"
					},
					onClick: p,
					style: f
				}, r.author)
			};
			var h = n("./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts"),
				_ = n("./src/reddit/components/Economics/SubredditPremium/Badges/UserDisplay/index.tsx"),
				g = n("./src/reddit/components/Flair/index.tsx"),
				v = n("./src/reddit/components/Governance/UserPublicPointsDisplay/async.tsx"),
				x = n("./src/reddit/components/LastAuthorModNoteIcon/index.tsx"),
				O = n("./src/reddit/components/PostTopMeta/index.tsx"),
				E = n("./src/reddit/controls/MetaData/index.tsx"),
				y = n("./src/reddit/helpers/flair.ts"),
				C = n("./src/reddit/helpers/trackers/features/powerupsFlair.ts"),
				j = n("./src/reddit/hooks/useTracking.ts"),
				k = n("./src/reddit/models/Comment/index.ts"),
				I = n("./src/reddit/selectors/gold/powerups/index.ts"),
				S = n("./src/lib/constants/index.ts"),
				w = n("./src/reddit/components/Economics/SubredditPremium/Badges/UsernameDisplay/index.tsx"),
				T = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				N = n("./src/reddit/components/Comments/Comment/TopMeta/author.m.less"),
				P = n.n(N);
			const R = e => {
				let {
					authorClassName: t,
					className: n,
					comment: s,
					collapsed: r,
					isLivestreaming: i,
					isEmbeddedLiveChat: a,
					isStrong: c,
					onClick: l,
					renderedInOverlay: u
				} = e;
				const m = Object(k.f)(s),
					p = o.a.createElement(w.b, {
						ignore: m || !!s.distinguishType && s.distinguishType !== S.J.NONE,
						subredditId: s.subredditId,
						userId: s.authorId
					}, o.a.createElement(f, {
						className: t,
						collapsed: r,
						comment: s,
						isAuthorDeleted: Object(k.f)(s),
						isCommentAuthorBlocked: Object(k.g)(s),
						isLivestreaming: i,
						isEmbeddedLiveChat: a,
						isStrong: c,
						onClick: l
					}));
				return m || a ? p : o.a.createElement(T.b, {
					className: Object(d.a)(P.a.authorHoverCard, n),
					collapsed: r,
					isCommentAuthorBlocked: Object(k.g)(s),
					postOrComment: s,
					tooltipType: u ? O.f.Lightbox : void 0
				}, p)
			};
			var A = n("./src/config.ts"),
				M = n("./src/reddit/actions/tooltip.ts"),
				L = n("./src/reddit/components/InfoTextTooltip/index.tsx");
			const D = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return `${e}${t}${n?"inOverlay":""}`
				},
				F = e => s.fbt._("Moderator of {subredditDisplayText}, speaking officially", [s.fbt._param("subredditDisplayText", e)], {
					hk: "3pHm3n"
				});
			var U = n("./src/reddit/components/Comments/Comment/TopMeta/cakeDay.m.less"),
				B = n.n(U);
			const q = e => {
				let {
					className: t,
					commentId: n,
					renderedInOverlay: r
				} = e;
				const a = Object(i.d)(),
					c = () => a(Object(M.h)({
						tooltipId: l
					})),
					l = D("CommentTopMeta--cakeday--", n, r),
					u = s.fbt._("Cake day", null, {
						hk: "1xptSi"
					});
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("img", {
					className: Object(d.a)(B.a.cakedayIcon, t),
					src: `${A.a.assetPath}/img/powerups/flair_cakeday.png`,
					alt: u,
					id: l,
					onMouseEnter: c,
					onMouseLeave: c,
					"data-testid": "cakeday-icon"
				}), o.a.createElement(L.c, {
					tooltipId: l,
					text: u
				}))
			};
			var G = n("./src/lib/addQueryParams/index.ts"),
				H = n("./src/reddit/actions/comment/index.ts"),
				W = n("./src/reddit/actions/post.ts"),
				V = n("./src/reddit/components/HumanDate/index.tsx"),
				z = n("./src/reddit/helpers/path/index.ts");
			const K = e => {
					const {
						className: t,
						comment: n,
						compact: s,
						onClick: r,
						permalink: a,
						renderedInOverlay: d,
						isBlockingInterstitialEnabled: c
					} = e, l = Object(i.d)(), u = D("CommentTopMeta--Created--", n.id, d), m = () => l(Object(M.h)({
						tooltipId: u
					}));
					return o.a.createElement("a", {
						className: t,
						"data-testid": "comment_timestamp",
						href: Object(G.a)(a, {
							utm_source: "reddit",
							utm_medium: "web2x",
							context: 3
						}),
						id: u,
						onClick: e => {
							null == r || r(e), Q(l, n.id), c && (e.preventDefault(), l(Object(W.Y)(Object(z.b)(a), n.postId)))
						},
						onMouseEnter: m,
						onMouseLeave: m,
						target: "_blank",
						rel: "nofollow noopener noreferrer"
					}, o.a.createElement(V.d, {
						seconds: n.created,
						shortenedUnit: s
					}), o.a.createElement(L.c, {
						tooltipId: u
					}, o.a.createElement(V.b, {
						seconds: n.created
					})))
				},
				Q = (e, t) => {
					window.addEventListener("focus", (function n() {
						Y(e, t, n)
					}))
				},
				Y = (e, t, n) => {
					window.removeEventListener("focus", n), e(Object(H.h)({
						commentListNodeId: t
					})), window.setTimeout(() => e(Object(H.h)({
						commentListNodeId: t
					})), 5e3)
				};
			var J = n("./src/reddit/components/Comments/Comment/TopMeta/crowdControl.m.less"),
				X = n.n(J);
			const {
				fbt: Z
			} = n("./node_modules/fbt/lib/FbtPublic.js"), $ = () => o.a.createElement(E.a, {
				className: X.a.crowdControlText
			}, Z._("Crowd Control", null, {
				hk: "4WgEW"
			}));
			var ee = n("./src/reddit/components/Comments/Comment/TopMeta/edited.m.less"),
				te = n.n(ee);
			const {
				fbt: ne
			} = n("./node_modules/fbt/lib/FbtPublic.js"), se = e => {
				let {
					compact: t,
					editedAt: n
				} = e;
				return o.a.createElement(E.a, {
					className: te.a.editedText
				}, ne._("edited {time}", [ne._param("time", o.a.createElement(V.d, {
					seconds: n,
					shortenedUnit: t
				}))], {
					hk: "1tiB0u"
				}))
			};
			var re = n("./src/reddit/helpers/isRemoved.ts"),
				oe = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				ie = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				ae = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				de = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				ce = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				le = n("./src/reddit/icons/fonts/Report/index.tsx"),
				ue = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				me = n("./src/reddit/selectors/modQueue.ts"),
				pe = n("./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less"),
				be = n.n(pe);
			const fe = e => {
				let {
					comment: t,
					ignoreLock: r,
					renderedInOverlay: a,
					isAdmin: d
				} = e;
				const c = Object(i.d)(),
					l = Object(i.e)(me.b),
					u = e => () => c(Object(M.f)({
						tooltipId: e
					})),
					m = () => c(Object(M.i)()),
					p = e => D(e, t.id, a),
					b = p("CommentTopMeta--Approve--"),
					f = p("CommentTopMeta--Remove--"),
					h = p("CommentTopMeta--Report--"),
					_ = p("CommentTopMeta--Spam--"),
					g = u(f);
				return o.a.createElement(o.a.Fragment, null, (t.approvedBy || t.isApproved) && !l && o.a.createElement(o.a.Fragment, null, o.a.createElement(ae.a, {
					className: be.a.approveIcon,
					desc: Object(oe.a)(t),
					id: b,
					onMouseEnter: u(b),
					onMouseLeave: m,
					isFilled: !0
				}), o.a.createElement(L.c, {
					tooltipId: b,
					text: Object(oe.a)(t)
				})), Object(re.a)(t) && !l && o.a.createElement(o.a.Fragment, null, o.a.createElement(ce.a, {
					className: be.a.removeIcon,
					desc: Object(oe.b)(t),
					id: f,
					onMouseEnter: g,
					onMouseLeave: m,
					isFilled: !0
				}), o.a.createElement(L.c, {
					tooltipId: f,
					text: Object(oe.b)(t)
				})), Object(re.a)(t) && t.isRemoved && !t.modNote && !t.modRemovalReason && !l && o.a.createElement("a", {
					className: be.a.removalReason,
					onClick: () => {
						n.e("removalReasonActions").then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(e => c(e.fetchReasonsAndOpenModal(t.subredditId, [t.id])))
					}
				}, s.fbt._("Add a removal reason", null, {
					hk: "L6yrL"
				})), Object(re.a)(t) && !(t.isRemoved && !t.modNote && !t.modRemovalReason) && !l && o.a.createElement("a", {
					className: be.a.removalReason,
					onMouseEnter: g,
					onMouseLeave: m
				}, s.fbt._("Removal reason", null, {
					hk: "20NRw8"
				})), t.isLocked && !r && o.a.createElement(de.a, {
					className: be.a.lockIcon,
					desc: s.fbt._("Locked", null, {
						hk: "40Ju3g"
					}),
					isFilled: !0
				}), t.bannedBy && t.isSpam && !l && o.a.createElement(o.a.Fragment, null, o.a.createElement(ue.a, {
					className: be.a.spamIcon,
					desc: Object(oe.d)(t),
					id: _,
					onMouseEnter: u(_),
					onMouseLeave: m,
					isFilled: !0
				}), o.a.createElement(L.c, {
					tooltipId: _,
					text: Object(oe.d)(t)
				})), Object(ie.a)(t) && !l && o.a.createElement(o.a.Fragment, null, o.a.createElement(le.a, {
					className: be.a.reportIcon,
					desc: Object(oe.c)(t.numReports),
					id: h,
					onMouseEnter: u(h),
					onMouseLeave: m,
					isFilled: !0
				}), o.a.createElement(L.c, {
					tooltipId: h,
					text: Object(oe.c)(t.numReports)
				})), t.isDeleted && d && !l && o.a.createElement(o.a.Fragment, null, o.a.createElement(ce.a, {
					className: be.a.removeIcon,
					isFilled: !0
				}), o.a.createElement("span", {
					className: be.a.userDeletion
				}, s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}))))
			};
			var he, _e = n("./src/lib/colors/constants.ts"),
				ge = n("./src/reddit/helpers/author.ts");
			! function(e) {
				e.Op = "op", e.Mod = "mod", e.ModTeam = "modTeam", e.Admin = "admin", e.AlumniAdmin = "alumniAdmin", e.Contractor = "contractor"
			}(he || (he = {}));
			var ve = n("./src/reddit/components/Comments/Comment/TopMeta/Role.m.less"),
				xe = n.n(ve);
			const Oe = {
					[he.Admin]: {
						color: _e.c,
						getLabel: () => s.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--Admin--",
						tooltipTemplate: () => s.fbt._("Reddit admin, speaking officially", null, {
							hk: "3vg8wE"
						})
					},
					[he.Mod]: {
						color: _e.d,
						getLabel: () => s.fbt._("Mod", null, {
							hk: "1b6Q1p"
						}),
						tooltipPrefix: "CommentTopMeta--Mod--",
						tooltipTemplate: e => F(e.subredditDisplayText)
					},
					[he.ModTeam]: {
						color: _e.d,
						getLabel: () => s.fbt._("Mods", null, {
							hk: "2rP88U"
						}),
						tooltipPrefix: "CommentTopMeta--ModTeam--",
						tooltipTemplate: e => F(e.subredditDisplayText)
					},
					[he.Op]: {
						color: _e.a,
						getLabel: () => s.fbt._("Op", null, {
							hk: "ERTp9"
						}),
						tooltipPrefix: "CommentTopMeta--OP--",
						tooltipTemplate: () => s.fbt._("Original Poster", null, {
							hk: "3DqK8z"
						})
					},
					[he.AlumniAdmin]: {
						color: _e.c,
						getLabel: () => s.fbt._("Admin", null, {
							hk: "Iku1o"
						}),
						tooltipPrefix: "CommentTopMeta--AdEm--",
						tooltipTemplate: () => s.fbt._("Reddit admin emeritus", null, {
							hk: "1Md5AV"
						})
					},
					[he.Contractor]: {
						color: _e.a,
						getLabel: () => s.fbt._("Contractor", null, {
							hk: "2nhaY6"
						}),
						tooltipPrefix: "CommentTopMeta--Contractor--",
						tooltipTemplate: () => s.fbt._("Reddit contractor", null, {
							hk: "3APwEh"
						})
					}
				},
				Ee = e => {
					const t = Object(i.d)(),
						n = function(e) {
							if (e.isAdmin) return he.Admin;
							const t = e.isMod || e.distinguishType === S.J.MODERATOR;
							return t && e.author && Object(ge.a)(e.author) ? he.ModTeam : t ? he.Mod : e.isOp ? he.Op : e.distinguishType === S.J.ALUMNI_ADMIN ? he.AlumniAdmin : e.authorIsContractor ? he.Contractor : null
						}(e.comment);
					if (!n) return null;
					if (n === he.Contractor && !e.renderContractorBadge) return null;
					const {
						tooltipPrefix: s,
						color: r,
						getLabel: a,
						tooltipTemplate: c
					} = Oe[n], l = a(), u = D(s, e.comment.id, e.renderedInOverlay), m = c(e), p = () => t(Object(M.h)({
						tooltipId: u
					}));
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
						className: Object(d.a)(xe.a.role, e.className),
						style: {
							color: r
						},
						id: u,
						onMouseEnter: p,
						onMouseLeave: p
					}, o.a.createElement("span", null, l), (n === he.Mod || n === he.ModTeam) && o.a.createElement(ye, null)), o.a.createElement(L.c, {
						tooltipId: u,
						text: m
					}))
				},
				ye = () => o.a.createElement("img", {
					alt: s.fbt._("Moderator Achievement", null, {
						hk: "20RhJI"
					}),
					className: xe.a.modAchievement,
					src: `${A.a.assetPath}/img/powerups/moderator-achievement.svg`
				});
			var Ce = n("./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less"),
				je = n.n(Ce);
			const {
				fbt: ke
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Ie = () => o.a.createElement(E.a, {
				className: je.a.stickiedText
			}, ke._("Stickied comment", null, {
				hk: "XUSav"
			}));
			var Se = n("./src/reddit/components/Comments/Comment/TopMeta/PostCommentHeader/index.m.less"),
				we = n.n(Se);
			const Te = e => {
				const {
					className: t,
					collapsed: n,
					collapsedBecauseCrowdControl: r,
					comment: a,
					flair: c,
					ignoreLock: u,
					isModWithUserNotesPermissions: m,
					isLivestreaming: p,
					onCommentAuthorClick: b,
					onCommentTimestampClick: f,
					permalink: S,
					renderContractorBadge: w,
					renderedInOverlay: T,
					subredditDisplayText: N,
					isAdmin: P
				} = e, A = Object(j.a)(), M = a.subredditId, L = Object(i.e)(e => Object(I.f)(e, {
					subredditId: M
				}));
				if (a.isDeleted && !P) return o.a.createElement("div", {
					className: Object(d.a)(we.a.container, t),
					"data-testid": "post-comment-header-deleted"
				}, o.a.createElement("span", {
					className: we.a.authorLine
				}, o.a.createElement("span", {
					className: we.a.metaText
				}, a.deletedBy === k.c.User ? s.fbt._("Comment deleted by user", null, {
					hk: "1Rtt4V"
				}) : s.fbt._("Comment removed by moderator", null, {
					hk: "E1t49"
				})), o.a.createElement(E.c, {
					className: we.a.separator
				}), o.a.createElement(K, {
					key: "Created",
					className: we.a.metaText,
					comment: a,
					compact: !0,
					permalink: S,
					renderedInOverlay: T
				})));
				return o.a.createElement("div", {
					className: Object(d.a)(we.a.container, t),
					"data-testid": "post-comment-header"
				}, o.a.createElement("span", {
					className: we.a.authorLine
				}, !Object(k.f)(a) && o.a.createElement(_.b, {
					className: we.a.userBadges,
					badgeSize: 20,
					showAddCustom: !0,
					subredditId: a.subredditId,
					userId: a.authorId,
					uniqueIdentifier: a.id
				}), o.a.createElement("div", {
					className: we.a.baselineItem
				}, o.a.createElement(R, {
					authorClassName: we.a.author,
					collapsed: n,
					comment: a,
					isLivestreaming: p,
					onClick: b,
					renderedInOverlay: T
				})), !Object(k.f)(a) && m && o.a.createElement(x.a, {
					postOrComment: a,
					className: we.a.LastAuthorModNoteIcon
				}), r && o.a.createElement($, null), o.a.createElement(Ee, {
					className: we.a.role,
					comment: a,
					subredditDisplayText: N,
					renderContractorBadge: w,
					renderedInOverlay: T
				}), a.isAuthorCakeday ? o.a.createElement(q, {
					className: we.a.cakeDay,
					commentId: a.id,
					renderedInOverlay: T
				}) : !Object(k.f)(a) && L && o.a.createElement(h.a, {
					className: we.a.achievementFlair,
					subredditId: a.subredditId,
					userId: a.authorId,
					onHover: () => {
						A(Object(C.b)(a.id, a.subredditId, a.authorId))
					},
					showPopupOnHover: !0
				}), o.a.createElement(v.a, {
					className: we.a.cryptoPoints,
					contentId: a.id,
					subredditId: a.subredditId,
					userId: a.authorId,
					username: a.author
				}), o.a.createElement(E.c, {
					className: we.a.separator
				}), o.a.createElement(K, {
					key: "Created",
					className: we.a.metaText,
					comment: a,
					compact: !0,
					onClick: f,
					permalink: S,
					renderedInOverlay: T
				}), a.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(E.c, {
					className: we.a.separator
				}), o.a.createElement(Ie, null)), a.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(E.c, {
					className: we.a.separator
				}), o.a.createElement(se, {
					compact: !0,
					editedAt: a.editedAt
				})), o.a.createElement(fe, {
					comment: a,
					ignoreLock: u,
					renderedInOverlay: T,
					isAdmin: P
				}), o.a.createElement(l.a, {
					thing: a,
					tooltipType: T ? O.f.Lightbox : void 0
				})), c && !Object(y.o)(c) && o.a.createElement("span", {
					className: we.a.userFlairLine
				}, o.a.createElement(g.b, {
					className: we.a.flair,
					flair: c,
					forceSmallEmojis: !0
				})))
			};
			var Ne = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				Pe = n("./src/reddit/selectors/economics.ts"),
				Re = n("./src/reddit/models/Flair/index.ts"),
				Ae = n("./src/reddit/selectors/comments.ts"),
				Me = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				Le = n("./src/reddit/selectors/moderatorPermissions.ts"),
				De = n("./src/reddit/selectors/subreddit.ts"),
				Fe = n("./src/reddit/selectors/userFlair.ts"),
				Ue = n("./src/reddit/components/Comments/Comment/TopMeta/index.m.less"),
				Be = n.n(Ue);

			function qe() {
				return (qe = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Ge = c.a.wrapped(g.b, "RightPositionedAuthorFlair", Be.a),
				He = c.a.span("DeletedText", Be.a),
				We = c.a.wrapped(E.a, "MetaSeparator", Be.a),
				Ve = Object(i.b)(() => Object(a.c)({
					hasBadges: (e, t) => {
						let {
							comment: n
						} = t;
						return !!Object(Pe.q)(e, n.subredditId, n.authorId).length
					},
					subredditDisplayText: (e, t) => {
						const n = Object(De.N)(e, {
							commentId: t.comment.id
						});
						return n ? n.displayText : ""
					},
					flairPosition: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(Fe.e)(e, {
							subredditId: n.subredditId
						})
					},
					commentPermalink: (e, t) => Object(Ae.m)(e, {
						commentId: t.comment.id
					}),
					isBlockingInterstitialEnabled: Me.b,
					isBlockingInterstitialV2Enabled: Me.c,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							comment: n
						} = t;
						return Object(Le.i)(e, n.subredditId)
					}
				}));
			t.a = Ve(e => {
				const {
					children: t,
					className: n,
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: i,
					commentPermalink: a,
					commentsPageKey: c,
					compact: m,
					flair: p,
					flairPosition: b,
					hasBadges: f,
					hideAwards: h = !1,
					ignoreFlairPosition: x,
					ignoreLock: y,
					isAdmin: C,
					isBlockingInterstitialEnabled: j,
					isBlockingInterstitialV2Enabled: I,
					isModWithUserNotesPermissions: S,
					isLivestreaming: w,
					isEmbeddedLiveChat: T,
					isPostComment: N,
					onCommentAuthorClick: P,
					onCommentTimestampClick: A,
					renderContractorBadge: M,
					renderedInOverlay: L,
					subredditDisplayText: D,
					userHasNft: F
				} = e, U = o.a.createElement(o.a.Fragment, null, o.a.createElement(Ne.b, {
					commentId: i.id
				}), o.a.createElement(Ne.a, {
					commentId: i.id,
					commentsPageKey: c
				}));
				if (N) return o.a.createElement(o.a.Fragment, null, o.a.createElement(Te, {
					className: Object(d.a)(n, {
						[Be.a.collapsed]: s
					}),
					collapsed: s,
					collapsedBecauseCrowdControl: r,
					comment: i,
					flair: p || null,
					ignoreLock: y,
					isAdmin: C,
					isModWithUserNotesPermissions: S,
					isLivestreaming: w,
					onCommentAuthorClick: P,
					onCommentTimestampClick: A,
					permalink: a,
					renderContractorBadge: !!M,
					renderedInOverlay: L,
					subredditDisplayText: D
				}), U);
				if (i.isDeleted) return o.a.createElement(ze, qe({}, e, {
					className: Object(d.a)(n, Be.a.container, {
						[Be.a.collapsed]: s
					})
				}));
				if (s) return o.a.createElement(Ke, qe({}, e, {
					className: Object(d.a)(n, Be.a.container, {
						[Be.a.collapsed]: s
					})
				}));
				const B = !x && b === Re.b.Left;
				return o.a.createElement("div", {
					className: Object(d.a)(n, Be.a.container, {
						[Be.a.collapsed]: s,
						[Be.a.hasBadges]: f,
						[Be.a.liveStreaming]: w
					}),
					"data-testid": "comment-top-meta"
				}, p && B && o.a.createElement(g.b, {
					flair: p,
					forceSmallEmojis: m
				}), !Object(k.f)(i) && o.a.createElement(_.b, {
					className: Be.a.userBadges,
					showAddCustom: !0,
					subredditId: i.subredditId,
					userId: i.authorId,
					uniqueIdentifier: i.id
				}), t && t, o.a.createElement(R, {
					authorClassName: F ? Be.a.NftAuthor : void 0,
					collapsed: s,
					comment: i,
					isLivestreaming: w,
					isEmbeddedLiveChat: T,
					isStrong: !!m,
					onClick: P,
					renderedInOverlay: L
				}), r && o.a.createElement($, null), r && o.a.createElement(E.c, {
					className: Be.a.metaText,
					key: "crowdControlSeparator"
				}), p && !B && o.a.createElement(Ge, {
					flair: p,
					forceSmallEmojis: m
				}), !m && o.a.createElement(v.a, {
					className: Be.a.publicPoints,
					contentId: i.id,
					metaSeparator: o.a.createElement(E.c, {
						className: Be.a.metaText
					}),
					subredditId: i.subredditId,
					userId: i.authorId,
					username: i.author
				}), U, o.a.createElement(Ee, {
					className: Be.a.authorRole,
					comment: i,
					subredditDisplayText: D,
					renderContractorBadge: !!M,
					renderedInOverlay: L
				}), !m && o.a.createElement(o.a.Fragment, null, !i.isDeleted && !N && o.a.createElement(o.a.Fragment, null, o.a.createElement(E.b, {
					className: Be.a.metaText,
					isScoreHidden: i.isScoreHidden,
					score: i.score
				}), o.a.createElement(E.c, {
					className: Be.a.metaText,
					key: "scoreCreatedSeparator"
				})), o.a.createElement(K, {
					key: "Created",
					className: Be.a.MetaLink,
					comment: i,
					permalink: a,
					renderedInOverlay: L,
					isBlockingInterstitialEnabled: j || I
				}), i.isStickied && o.a.createElement(o.a.Fragment, null, o.a.createElement(E.c, {
					className: Be.a.separator
				}), o.a.createElement(Ie, null)), i.editedAt && o.a.createElement(o.a.Fragment, null, o.a.createElement(E.c, {
					className: Be.a.separator
				}), o.a.createElement(se, {
					editedAt: i.editedAt
				}))), o.a.createElement(fe, {
					comment: i,
					ignoreLock: y,
					renderedInOverlay: L
				}), !h && o.a.createElement(l.a, {
					thing: i,
					tooltipType: L ? O.f.Lightbox : void 0
				}), S && o.a.createElement(u.a, {
					postOrComment: i,
					className: Be.a.addModNote
				}))
			});
			const ze = e => {
					const {
						childrenInfo: t,
						collapsed: n,
						className: r,
						comment: i,
						commentPermalink: a,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c,
						renderedInOverlay: l
					} = e;
					return o.a.createElement("div", {
						className: r
					}, o.a.createElement(He, null, i.deletedBy === k.c.User ? s.fbt._("Comment deleted by user", null, {
						hk: "1Rtt4V"
					}) : s.fbt._("Comment removed by moderator", null, {
						hk: "E1t49"
					})), o.a.createElement(K, {
						key: "Created",
						className: Be.a.MetaLink,
						comment: i,
						permalink: a,
						renderedInOverlay: l,
						isBlockingInterstitialEnabled: d || c
					}), n && Qe({
						childrenInfo: t
					}))
				},
				Ke = e => {
					const {
						comment: t,
						className: n,
						childrenInfo: s,
						renderedInOverlay: r,
						collapsed: i,
						commentPermalink: a,
						isBlockingInterstitialEnabled: d,
						isBlockingInterstitialV2Enabled: c
					} = e;
					return o.a.createElement("div", {
						className: n
					}, o.a.createElement("div", null, o.a.createElement(f, {
						comment: t,
						isAuthorDeleted: Object(k.f)(t),
						collapsed: i
					})), o.a.createElement(E.b, {
						className: Be.a.metaText,
						isScoreHidden: t.isScoreHidden,
						score: t.score
					}), o.a.createElement(E.c, {
						className: Be.a.metaText,
						key: "scoreCreatedSeparator"
					}), o.a.createElement(K, {
						key: "Created",
						className: Be.a.MetaLink,
						comment: t,
						permalink: a,
						renderedInOverlay: r,
						isBlockingInterstitialEnabled: d || c
					}), Qe({
						childrenInfo: s
					}))
				},
				Qe = e => {
					const {
						hasContinueThread: t,
						numChildren: n
					} = e.childrenInfo || {
						hasContinueThread: !1,
						numChildren: 0
					};
					return o.a.createElement(We, {
						className: Be.a.metaText
					}, t ? s.fbt._({
						"*": "More than {number} children",
						_1: "More than 1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "13XC7a"
					}) : s.fbt._({
						"*": "{number} children",
						_1: "1 child"
					}, [s.fbt._plural(n, "number")], {
						hk: "dhX9w"
					}))
				}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/modBadgeTooltip.m.less": function(e, t, n) {
			e.exports = {
				approveIcon: "_3Jlybj1GmQS_PfZVxE6yR1",
				automoderatorIcon: "_2EBjdWEqs2dwPePq0_1vJn",
				lockIcon: "YjyVr4SnBmO7WorLVMXq5",
				removeIcon: "_3M_jIwyB1POxBFR2jnGIp_",
				reportIcon: "_3hI84iVaolaHi85h6liPyp",
				spamIcon: "MufLXlXcv1oes9OlakuXr",
				removed: "_2LQnjoTNHDUWKBOoq2gTlm",
				removalReason: "EM8fL_jC3oe9bruIOZt2U",
				userDeletion: "_1KVzcRpEm0U5vCgrZbgiyN"
			}
		},
		"./src/reddit/components/Comments/Comment/TopMeta/stickied.m.less": function(e, t, n) {
			e.exports = {
				stickiedText: "_2wd-K5Djdc9TGPRGDgmkpX"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.m.less": function(e, t, n) {
			e.exports = {
				VoteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				voteSpacer: "oq5mUzSj_vNl2qp3WN_JJ",
				ContentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				contentWrapper: "Z-SSPhDFBXkUleK1Uoo5n",
				CommentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				commentContentWrapper: "_2OgGzVSF6RB04Jb2cXSiPj",
				CommentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				commentParentWrapper: "OPElT6Do1pTNOWhGkL1eT",
				CommentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				commentBody: "_3PTQsA2VkqzBrZxhvpwI8Z",
				ParentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				parentPostTitle: "_144TYY84bzwNfGN3DGzUvi",
				Component: "_29-oldqrqqPwwjRRH0aLqU",
				component: "_29-oldqrqqPwwjRRH0aLqU"
			}
		},
		"./src/reddit/components/Comments/UnthreadedComment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return M
			})), n.d(t, "b", (function() {
				return F
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/objectSelector/index.ts"),
				c = n("./src/reddit/actions/comment/index.ts"),
				l = n("./src/reddit/actions/comment/moderation.ts"),
				u = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/index.tsx"),
				m = n("./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx"),
				p = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx"),
				b = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx"),
				f = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx"),
				h = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				_ = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				g = n("./src/reddit/components/ModModeReports/index.tsx"),
				v = n("./src/reddit/components/PostRailAndVotes/index.tsx"),
				x = n("./src/reddit/components/RichTextJson/index.tsx"),
				O = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				E = n("./src/reddit/models/Vote/index.ts"),
				y = n("./src/reddit/selectors/comments.ts"),
				C = n("./src/reddit/selectors/commentSelector.ts"),
				j = n("./src/reddit/selectors/modQueue.ts"),
				k = n("./src/reddit/selectors/subreddit.ts"),
				I = n("./src/reddit/selectors/user.ts"),
				S = n("./src/reddit/components/Comments/UnthreadedComment/index.m.less"),
				w = n.n(S),
				T = n("./src/lib/lessComponent.tsx");
			const N = T.a.div("VoteSpacer", w.a),
				P = T.a.div("ContentWrapper", w.a),
				R = T.a.div("CommentContentWrapper", w.a),
				A = T.a.div("CommentBody", w.a),
				M = T.a.div("ParentPostTitle", w.a),
				L = T.a.div("CommentParentWrapper", w.a),
				D = Object(i.c)({
					comment: (e, t) => Object(C.b)(e, t),
					commentPermalink: y.m,
					flair: y.e,
					subreddit: k.N,
					isModQueueDisplayEnabled: j.b,
					isUpdatedContent: (e, t) => {
						let {
							commentId: n
						} = t;
						var s, r;
						return !!(null === (r = null === (s = e.features) || void 0 === s ? void 0 : s.realtimeModqueue) || void 0 === r ? void 0 : r.updated.includes(n))
					},
					showRealtimeUpdateAnimation: (e, t) => {
						let {
							commentId: n
						} = t;
						var s;
						return (null === (s = e.features) || void 0 === s ? void 0 : s.realtimeUpdateAnimationId) === n
					},
					isNightMode: I.eb
				}),
				F = Object(o.b)(D, (e, t) => {
					let {
						commentId: n,
						trackClick: s
					} = t;
					return {
						onIgnoreReports: () => e(Object(l.g)(n)),
						onVoteClick: t => {
							const [r, o] = t === E.a.upvoted ? [Object(c.s)(n), "upvote_comment"] : [Object(c.k)(n), "downvote_comment"];
							s(o)(), e(r)
						}
					}
				}),
				U = Object(d.b)(e => ({
					renderingObjectInfo: e.comment
				}));
			t.c = F(T.a.wrapped(e => {
				const {
					className: t,
					comment: n,
					commentPermalink: s,
					flair: o,
					hasReports: i,
					isCheckboxSelected: d = !1,
					onIgnoreReports: c,
					onVoteClick: l,
					showModTools: E,
					subreddit: y,
					showBulkActionCheckbox: C,
					toggleCheckbox: j
				} = e, k = Object(_.a)(n);
				return r.a.createElement(m.a, {
					className: Object(a.a)(t, "UnthreadedComment"),
					clickTrackingId: n.id,
					permalink: s
				}, r.a.createElement(v.a, {
					model: n,
					handleVote: l,
					showBulkActionCheckbox: C,
					isCheckboxSelected: d,
					toggleCheckbox: j
				}), r.a.createElement(N, null, r.a.createElement(P, null, r.a.createElement(L, null, n.postTitle && r.a.createElement(M, null, n.postTitle), n.postAuthor && r.a.createElement(f.a, {
					comment: n
				})), r.a.createElement(R, null, r.a.createElement(p.a, {
					comment: n
				}, r.a.createElement(A, null, r.a.createElement(x.b, {
					content: Object(O.a)(n),
					mediaMetadata: n.media && n.media.mediaMetadata,
					rtJsonElementProps: U(e),
					mediaProps: {
						alignLeft: !0,
						renderSmallMedia: !0
					}
				})), r.a.createElement(b.a, {
					comment: n,
					flair: o,
					subredditName: y ? y.displayText : null
				}), k && r.a.createElement(h.a, {
					thing: n
				}), i && r.a.createElement(g.a, {
					onIgnoreReports: c,
					reportable: n
				}), E && !n.isDeleted && r.a.createElement(u.a, {
					comment: n
				}))))))
			}, "Component", w.a))
		},
		"./src/reddit/components/Comments/UnthreadedCommentContainer/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/addQueryParams/index.ts"),
				a = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				d = n("./src/reddit/helpers/overlay/index.ts");
			const c = Object(o.b)(null, e => ({
				openLightbox: t => e(Object(d.a)(t))
			}));
			class l extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						permalink: t,
						openLightbox: n,
						...s
					} = this.props, o = s => e(() => s.metaKey || s.ctrlKey || 1 === s.button ? window.open(Object(i.a)(t, {
						context: 3
					})) : n(Object(i.a)(t, {
						context: 3
					})))(s);
					return r.a.createElement("div", {
						className: s.className,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3)), 1 === e.button && o(e)
						},
						onClick: e => {
							!this.cancelClick && 0 === e.button && o(e)
						}
					}, s.children)
				}
			}
			t.a = c(Object(a.a)(l))
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				DashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u",
				dashWrapper: "_3Ed3UKndPjQ4kkX0QvOz3u"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/Comments/UnthreadedCommentDashWrapper/index.m.less"),
				a = n.n(i);
			const d = o.a.div("DashWrapper", a.a);
			t.a = e => null === e.comment.parentId ? r.a.createElement(d, null, e.children) : r.a.createElement(d, null, r.a.createElement(d, null, e.children))
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				subredditWrapper: "_1ZSTlGe7wnX1GJX3F-AEwD",
				TopMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				topMeta: "_2Rm4FD32bOsXwX7lx3GeYW",
				Inline: "meK3ndVOmnvQt6wVaAg5W",
				inline: "meK3ndVOmnvQt6wVaAg5W",
				PostedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				postedInfo: "_6b3ccJ38E6dy9dby4PlDN",
				TextContainer: "iV3Hb5JWIQSpA3WhioY-N",
				textContainer: "iV3Hb5JWIQSpA3WhioY-N",
				SubredditIcon: "_3VveukTKira5rWfNi-vDI4",
				subredditIcon: "_3VveukTKira5rWfNi-vDI4"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/components/Comments/Comment/TopMeta/index.tsx"),
				a = n("./src/reddit/layout/row/Inline/index.tsx"),
				d = n("./src/reddit/components/Comments/UnthreadedCommentMeta/index.m.less"),
				c = n.n(d),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/reddit/components/SubredditIcon/index.tsx");
			const m = l.a.wrapped(a.a, "Inline", c.a),
				p = l.a.wrapped(a.a, "PostedInfo", c.a),
				b = l.a.wrapped(a.a, "SubredditWrapper", c.a),
				f = l.a.div("TextContainer", c.a),
				h = l.a.wrapped(i.a, "TopMeta", c.a);
			t.a = e => {
				let {
					subredditName: t,
					className: n,
					comment: r,
					flair: i,
					subredditOrProfile: a
				} = e;
				return o.a.createElement(m, {
					className: n
				}, a && o.a.createElement(b, null, a && o.a.createElement(u.b, {
					className: c.a.SubredditIcon,
					subredditOrProfile: a
				}), a && o.a.createElement(f, null, a.displayText)), t && !a && o.a.createElement(b, null, t && o.a.createElement(f, null, t)), o.a.createElement(p, null, o.a.createElement(f, null, `${s.fbt._("Commented by",null,{hk:"4Dveap"})}`), o.a.createElement(h, {
					collapsedBecauseCrowdControl: r.collapsedBecauseCrowdControl,
					collapsed: !1,
					comment: r,
					flair: i,
					renderedInOverlay: !1
				})))
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				AuthorLink: "_2jljMb6FK7HnIb15zmm1of",
				authorLink: "_2jljMb6FK7HnIb15zmm1of",
				SubredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				subredditWrapper: "SZcM6DS3LArR6FZxlQXOv",
				TextContainer: "_2in6k_0-sFgKVz16hifq03",
				textContainer: "_2in6k_0-sFgKVz16hifq03",
				SubredditIcon: "uCjYZbKNai0INWGwHjoUh",
				subredditIcon: "uCjYZbKNai0INWGwHjoUh",
				Inline: "_2VWXAfRlnHG_4nydI7J4l3",
				inline: "_2VWXAfRlnHG_4nydI7J4l3"
			}
		},
		"./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/AuthorLink/index.tsx"),
				i = n("./src/reddit/components/Hovercards/AuthorHovercard/index.tsx"),
				a = n("./src/reddit/components/SubredditIcon/index.tsx"),
				d = n("./src/reddit/layout/row/Inline/index.tsx"),
				c = n("./src/reddit/components/Comments/UnthreadedCommentPostMeta/index.m.less"),
				l = n.n(c),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/lib/lessComponent.tsx");
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = m.a.wrapped(o.a, "AuthorLink", l.a), f = m.a.wrapped(d.a, "Inline", l.a), h = m.a.wrapped(d.a, "SubredditWrapper", l.a), _ = m.a.div("TextContainer", l.a), g = m.a.wrapped(a.b, "SubredditIcon", l.a);
			t.a = e => r.a.createElement(f, null, e.subredditOrProfile && r.a.createElement(h, null, e.subredditOrProfile && r.a.createElement(g, {
				subredditOrProfile: e.subredditOrProfile
			}), e.subredditOrProfile && r.a.createElement(_, null, e.subredditOrProfile.displayText)), p._("posted by", null, {
				hk: "1EuRc2"
			}), e.comment.postAuthor && r.a.createElement(i.b, {
				postOrComment: e.comment,
				author: e.comment.postAuthor
			}, r.a.createElement(b, {
				author: e.comment.postAuthor,
				isUnstyled: !0,
				isAuthorDeleted: e.comment.postAuthor === u.H
			}, `u/${e.comment.postAuthor}`)))
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				icon: "_1BLJJHA9oAzG1Rqmf4pcYW",
				IconText: "_6cNM5NdF82ASM5hiBVNN5",
				iconText: "_6cNM5NdF82ASM5hiBVNN5",
				Animate: "_3j98tX1WZapEArV-4rmJe5",
				animate: "_3j98tX1WZapEArV-4rmJe5",
				top: "_3Dr1MoYY5Yv4YhbQFFcks0",
				bottom: "_1GRYNQhMsR-00cWDJcE3UJ",
				bigCircle: "_85rqvRijdIsn3s0j-gUaw",
				midCircle: "RS1g6Gd_W67wwWKSteEB1",
				smallCircle: "lRlGcfTzZ7njZnIUyvhGH",
				play: "_3Kxa8oHGuT_QpP4zIN5jrV",
				blinker: "_20WvB_9deo7bJVi4af1dSS"
			}
		},
		"./src/reddit/components/CommentsChat/LiveIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/selectors/chatPost.ts"),
				l = n("./src/reddit/components/CommentsChat/LiveIcon/index.m.less"),
				u = n.n(l);
			const m = e => {
				let {
					className: t,
					postId: n
				} = e;
				const [o, l] = i.a.useState(!1), m = Object(a.e)(e => Object(c.d)(e, {
					postId: n
				})), p = m && o;
				return m ? i.a.createElement(s.a, {
					rootMargin: "20px 0px 20px 0px",
					threshold: .1,
					onChange: e => {
						e.isIntersecting && e.intersectionRatio >= .1 ? o || l(!0) : o && l(!1)
					}
				}, i.a.createElement("div", {
					className: Object(d.a)(u.a.Icon, t)
				}, i.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.top, {
						[u.a.play]: p
					})
				}, i.a.createElement("span", {
					className: u.a.bigCircle
				}), i.a.createElement("span", {
					className: u.a.midCircle
				}), i.a.createElement("span", {
					className: u.a.smallCircle
				})), i.a.createElement("p", {
					className: u.a.IconText
				}, r.fbt._("Live Chat", null, {
					hk: "gyqAe"
				})), i.a.createElement("span", {
					className: Object(d.a)(u.a.Animate, u.a.bottom, {
						[u.a.play]: p
					})
				}, i.a.createElement("span", {
					className: u.a.bigCircle
				}), i.a.createElement("span", {
					className: u.a.midCircle
				}), i.a.createElement("span", {
					className: u.a.smallCircle
				})))) : null
			}
		},
		"./src/reddit/components/CommentsLink/index.m.less": function(e, t, n) {
			e.exports = {
				commentsLink: "_1UoeAeSRhOKSNdY_h3iS1O",
				commentIcon: "_3DVrpDrMM9NLT6TlsTUMxC",
				defaultCursorWrapper: "_3m17ICJgx45k_z-t82iVuO",
				link: "_1Hw7tY9pMr-T1F4P1C-xNU",
				text: "FHCV02u6Cp2zYL0fhQPsO",
				commentsText: "_25BV1fTi10_HqCnD195T85"
			}
		},
		"./src/reddit/components/CommentsLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./node_modules/fbt/lib/FbtPublic.js"),
				m = n("./src/lib/prettyPrintNumber/index.ts"),
				p = n("./src/reddit/components/CountAnimation/index.tsx"),
				b = n("./src/reddit/constants/postLayout.ts"),
				f = n("./src/reddit/icons/fonts/Comment/index.tsx"),
				h = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				_ = n("./src/reddit/components/CommentsLink/index.m.less"),
				g = n.n(_);
			const v = () => 0,
				x = e => {
					let t, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: i,
						isChatPost: a,
						isCommentCountAnimation: c,
						modModeEnabled: _,
						numComments: x,
						postId: O,
						shouldShowIcon: E,
						shouldShowText: y,
						text: C,
						type: j
					} = e;
					const k = c && x < h.a,
						I = a ? u.fbt._({
							"*": "{number} messages",
							_1: "1 message"
						}, [u.fbt._plural(x, "number", Object(m.b)(x))], {
							hk: "2wEqSc"
						}) : u.fbt._({
							"*": "{number} comments",
							_1: "1 comment"
						}, [u.fbt._plural(x, "number", Object(m.b)(x))], {
							hk: "1QeOde"
						}),
						S = a ? u.fbt._({
							"*": "messages",
							_1: "message"
						}, [u.fbt._plural(x)], {
							hk: "1mMKLS"
						}) : u.fbt._({
							"*": "comments",
							_1: "comment"
						}, [u.fbt._plural(x)], {
							hk: "2fJpkn"
						});
					t = C || (j === b.g.Compact || _ && n ? Object(m.b)(x) : I);
					const w = Object(o.d)(),
						T = Object(s.useCallback)(e => {
							const {
								commentCountChange: t
							} = e.subscribe.data;
							0 !== t && w(Object(l.G)({
								postId: O,
								delta: t
							}))
						}, [w, O]),
						N = Object(s.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "COMMENT_COUNT_UPDATE",
									postID: O
								}
							}
						});
					return r.a.createElement(r.a.Fragment, null, E && r.a.createElement(f.a, {
						className: g.a.commentIcon,
						role: "presentation"
					}), y && r.a.createElement(r.a.Fragment, null, r.a.createElement("span", {
						className: g.a.text
					}, (k || i) && r.a.createElement(p.b, {
						countToUpperBound: x,
						incrementDelta: v,
						initialDelay: v,
						initialDisplayCount: x,
						postId: O,
						shouldDisjointAnimation: !0,
						subsequentRecurringDelay: v,
						featureName: p.a.Comment,
						queryKey: "postCommentCount",
						queryVariables: N.current,
						onDataCB: T,
						isLoadTestOnly: Boolean(i) && !k
					}), !k && t), (!_ || !n) && k && r.a.createElement("span", {
						className: Object(d.a)(g.a.text, g.a.commentsText)
					}, S)))
				};
			var O = n("./src/reddit/constants/componentTestIds.ts"),
				E = n("./src/reddit/helpers/path/index.ts"),
				y = n("./src/reddit/hooks/useClickSourceData.ts"),
				C = n("./src/reddit/selectors/chatPost.ts"),
				j = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				k = n("./src/reddit/selectors/experiments/postSeo.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts");
			const T = Object(o.b)(() => Object(a.c)({
				isChatPost: C.d,
				isPostSEOEligible: k.e,
				postPermalink: I.F,
				shouldOpenPostInNewTab: S.kb,
				isBlockingInterstitialEnabled: j.b,
				isBlockingInterstitialV2Enabled: j.c
			}));
			t.a = T(e => {
				let {
					className: t,
					hasModPostPerms: n,
					forceOpenInNewTab: s,
					isChatPost: a,
					isCommentPermalink: u,
					isCommentsPage: m,
					isOverlay: p,
					isPostSEOEligible: b,
					modModeEnabled: f,
					numComments: h,
					onClick: _,
					postPermalink: v,
					shouldOpenPostInNewTab: C,
					shouldShowIcon: j = !0,
					shouldShowText: k = !0,
					text: I,
					type: S,
					postId: T,
					isCommentCountAnimation: N,
					isCountAnimShadowTestEnabled: P,
					isBlockingInterstitialEnabled: R,
					isBlockingInterstitialV2Enabled: A
				} = e;
				const M = Object(o.d)(),
					L = m && !u && !b,
					D = u && !p,
					F = Object(y.a)(),
					U = r.a.createElement(x, {
						hasModPostPerms: n,
						isCountAnimShadowTestEnabled: !!P,
						isChatPost: a,
						isCommentCountAnimation: !!N,
						modModeEnabled: f,
						numComments: h,
						postId: T,
						shouldShowIcon: j,
						shouldShowText: k,
						text: I,
						type: S
					});
				return L ? r.a.createElement("div", {
					className: Object(d.a)(g.a.commentsLink, g.a.defaultCursorWrapper, t),
					onClick: _
				}, U) : r.a.createElement(i.a, {
					rel: "nofollow",
					"data-click-id": "comments",
					"data-adclicklocation": w.b.COMMENTS,
					"data-test-id": O.a,
					className: Object(d.a)(g.a.commentsLink, g.a.link, t),
					target: s || C ? "_blank" : void 0,
					to: D ? Object(E.b)(v) : Object(c.a)(v, !0, F),
					onClick: e => {
						(R || A) && (e.preventDefault(), M(Object(l.Y)(Object(E.b)(v), T))), _ && _()
					}
				}, U)
			})
		},
		"./src/reddit/components/CommonAutocompleteDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				autocompleteLabel: "_39qccdns_RvOZZlRIIVGoK",
				locked: "_2WupD4z680kgaOvurMIh3K",
				labelIcon: "_3dK0j9mvmwPub-EQjQEF-f",
				lockIcon: "m15TxfKz9KwlKtTpuUOGU",
				autocompleteInput: "_2DhRYyE3X6UOdxywO4xoas",
				autocompleteInput__no_icon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInputNoIcon: "_2gDZgLjG5_0otT8r_3nrX9",
				autocompleteInput__disabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputDisabled: "_2y-MwvP_24hapwkGLPhGNv",
				autocompleteInputContainer: "_3G7m5yzFmzVctZTxy3ZUkf",
				autocompleteDropdown: "nUeCIjmjHU-llTCBuUdnn",
				autocompleteDropdownItem: "_3eWYFOsdnA9K-Jw8qXFbfH",
				autocompleteDropdownItem__rtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItemRtl: "_3e5-Tc_WqzN-NNzAg8R7T6",
				autocompleteDropdownItem__icon: "_1x6PJuPScW1xzB8k-WzEN",
				autocompleteDropdownItemIcon: "_1x6PJuPScW1xzB8k-WzEN",
				highlight: "_2cIM3xprCSzGFYnQGsdVSL",
				selected: "_1EEVp702_ABu8mple5Dpfk"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardRow/index.m.less": function(e, t, n) {
			e.exports = {
				row: "_1SJYzo3UAyKEOF7dfuB9mj",
				awardName: "KMxVBNnYo_dcBwZGB9Y7a",
				unfilledAward: "_3s20dmDQOAFnj9VBvMb_K9",
				awardDetail: "_2NA5kHSdCz8PTAq-oiC2lE",
				awardExpiresDetail: "_23IvuOow0OJsmKnkmU_FEX",
				headerRow: "_1NbiD8qa7KncC2IlK9RoSb",
				awardIconImage: "_3sB_KQUJdYFc6cPgCjizd4",
				deleteIcon: "_1Aox5T2z7StzW_M0WfnDTe",
				rightAlign: "_3MpqTEDv3tS3-u-1uNAt6Y",
				createButton: "_3pXwHsShRJ0s12b9e-_gCX",
				emptyIcon: "yy-p6aZDVdPVBPBYMhbEy",
				emptyDetails: "LUZArpcpRdOTEPUDrjKVR",
				awardLoadingContainer: "_2WNYZIJMYIXJIS_IJIIiTe"
			}
		},
		"./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less": function(e, t, n) {
			e.exports = {
				awardToggleContainer: "_2E_k43b0N9nhGQKfSvT_c_",
				emptyToggleContainer: "_1lQVQi-D8yElpWeJLbrix0",
				emptyToggleContainerLabel: "_2Porr9EjtYqQt8OhMaCU3h",
				optionalAwardInfo: "ZViyY3IDk7c6MplUKuCKa",
				awardToggleItem: "XwXRf6eWep27jKV1kkNDN",
				awardToggleLabelItem: "_2d9jt8apy5IwNRPdrC_RtG",
				awardIconWrapper: "_3DGDvlViP1uosxrUobijCu",
				awardIcon: "_10ar4v6qlEgLvqEhxk_wyP",
				awardInfoWrapper: "_2LxUe9vOie60H44Rkl5YYd",
				awardToggleItemDisabled: "_1touzuLFgoSGqEcDiLDD00",
				awardTitle: "_1fG-NkjOvo6khgB4qJmizu",
				awardDescription: "_2VABiA5W4pgqWyCK_oV4Hg"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_27C02100EX-RnLoDyL_PYT",
				gildIcon: "_3f4YbBVVbX4YXols-8AmgC",
				infoIcon: "_1HPeb_FxEOzicQ4BuIVonK",
				pageInfo: "_2bEhfADeSjJE-8zKoxjbGy",
				awardToDelete: "dzAx082Iu3F9M7xS-PL80",
				awardToDeleteIcon: "_11ikfBu3qqa0paYAJLQINO"
			}
		},
		"./src/reddit/components/CommunityAwardList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/gold/communityAwards/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/constants/gold.ts"),
				m = n("./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts"),
				p = n("./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts"),
				b = n("./src/reddit/helpers/correlationIdTracker.ts"),
				f = n("./src/reddit/helpers/trackers/communityAwards.ts"),
				h = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/makeAsync.tsx")),
				_ = n("./src/lib/loadWithRetries/index.ts");
			var g = Object(h.a)({
					getComponent: () => Object(_.a)(() => Promise.all([n.e("AwardCreationModal").then(n.bind(null, "./src/reddit/components/AwardCreationModal/index.tsx"))])).then(e => e[0].default),
					ErrorComponent: () => null,
					LoadingComponent: () => null
				}),
				v = n("./src/reddit/models/Gold/Award.ts"),
				x = n("./src/reddit/components/ConfirmModal/index.tsx"),
				O = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				E = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				y = n("./src/reddit/components/TrackingHelper/index.tsx"),
				C = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/selectors/activeModalId.ts"),
				k = n("./node_modules/lodash/times.js"),
				I = n.n(k),
				S = n("./src/lib/classNames/index.ts"),
				w = n("./src/reddit/controls/Button/index.tsx"),
				T = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				N = n("./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts"),
				P = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				R = n("./src/reddit/components/CommunityAwardList/AwardRow/index.m.less"),
				A = n.n(R);
			const {
				fbt: M
			} = n("./node_modules/fbt/lib/FbtPublic.js"), L = () => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: A.a.awardName
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyIcon
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			})), o.a.createElement("div", {
				className: A.a.awardDetail
			}, o.a.createElement("div", {
				className: A.a.emptyDetails
			}))), D = e => o.a.createElement("div", {
				className: Object(S.a)(e.className, A.a.awardLoadingContainer)
			}, I()(10, e => o.a.createElement(L, {
				key: e
			}))), F = e => {
				let {
					subredditId: t
				} = e;
				return o.a.createElement("div", {
					className: A.a.headerRow
				}, o.a.createElement("div", {
					className: A.a.awardName
				}, M._("Name", null, {
					hk: "2rgEdc"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Icon", null, {
					hk: "zWzOj"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Coins", null, {
					hk: "2uhz31"
				})), o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Type", null, {
					hk: "1rYgKO"
				})), Object(N.a)(t) && o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Starts", null, {
					hk: "HW61W"
				})), Object(N.a)(t) && o.a.createElement("div", {
					className: A.a.awardDetail
				}, M._("Expires", null, {
					hk: "3hS2VX"
				})))
			}, U = e => {
				let {
					date: t
				} = e;
				return o.a.createElement("div", {
					className: A.a.awardExpiresDetail
				}, t && t.toLocaleString())
			}, B = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._({
				"*": "Create up to {quantity} more {coin-price} Coin Awards",
				_1: "Create up to {quantity} more {coin-price} Coin Award"
			}, [M._param("quantity", e.quantity), M._param("coin-price", e.coinPrice), M._plural(e.quantity)], {
				hk: "4nSQI7"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			})))), q = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._("Create a Moderator-Only Award", null, {
				hk: "3aMmTo"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			})))), G = e => o.a.createElement("div", {
				className: A.a.row
			}, o.a.createElement("div", {
				className: Object(S.a)(A.a.awardName, A.a.unfilledAward)
			}, M._("Create an Award", null, {
				hk: "1zGxjw"
			})), o.a.createElement(P.a, {
				className: A.a.rightAlign
			}, o.a.createElement(w.l, {
				className: A.a.createButton,
				onClick: e.onCreate
			}, M._("Create", null, {
				hk: "3aEi77"
			}))));
			class H extends o.a.Component {
				constructor() {
					super(...arguments), this.onDelete = e => {
						e.preventDefault(), this.props.onDelete(this.props.award.id)
					}
				}
				render() {
					const {
						award: e,
						canDelete: t,
						iconUrl: n,
						subredditId: s
					} = this.props, r = Object(N.a)(s), i = e.startsAt ? new Date(e.startsAt) : void 0, a = e.endsAt ? new Date(e.endsAt) : void 0;
					return o.a.createElement("div", {
						className: A.a.row
					}, o.a.createElement("div", {
						className: A.a.awardName
					}, e.name), o.a.createElement("div", {
						className: A.a.awardDetail
					}, o.a.createElement("img", {
						className: A.a.awardIconImage,
						src: n,
						title: e.name
					})), o.a.createElement("div", {
						className: A.a.awardDetail
					}, e.coinPrice || 0), o.a.createElement("div", {
						className: A.a.awardDetail
					}, e.awardType === v.f.Moderator ? M._("Mod only", null, {
						hk: "UxkP0"
					}) : M._("All", null, {
						hk: "2J55F0"
					})), r && [o.a.createElement(U, {
						key: "startDate",
						date: i
					}), o.a.createElement(U, {
						key: "endDate",
						date: a
					})], o.a.createElement(P.a, {
						className: A.a.rightAlign
					}, t && o.a.createElement("a", {
						href: ".",
						onClick: this.onDelete
					}, o.a.createElement(T.b, {
						className: A.a.deleteIcon
					}))))
				}
			}
			var W = H,
				V = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				z = n("./src/reddit/hooks/useTracking.ts"),
				K = n("./src/reddit/selectors/communityAwards.ts"),
				Q = n("./src/reddit/selectors/gold/awardIcon.ts"),
				Y = n("./src/reddit/components/CommunityAwardList/AwardSettings/index.m.less"),
				J = n.n(Y);
			const {
				fbt: X
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Z = e => {
				let {
					award: t,
					iconUrl: n
				} = e;
				return o.a.createElement("div", {
					className: J.a.awardToggleLabelItem
				}, o.a.createElement("div", {
					className: J.a.awardIconWrapper
				}, o.a.createElement("img", {
					className: J.a.awardIcon,
					src: n
				})), o.a.createElement("div", {
					className: J.a.awardInfoWrapper
				}, o.a.createElement("div", {
					className: J.a.awardTitle
				}, t.name), o.a.createElement("div", {
					className: J.a.awardDescription
				}, t.description)))
			};
			var $ = e => {
					let {
						subredditOrProfile: t,
						subredditOrProfileId: n,
						moderatorPermissions: s
					} = e;
					const r = Object(i.d)(),
						a = Object(z.a)(),
						c = Object(i.e)(e => Object(K.f)(e, {
							subredditOrProfileId: n
						})),
						l = Object(i.e)(e => Object(K.d)(e, {
							subredditOrProfileId: n
						})),
						u = Object(i.e)(e => Object(Q.b)(e, {
							awards: c,
							minSize: 64
						}));
					if (!c.length) return o.a.createElement("div", {
						className: J.a.emptyToggleContainer
					}, o.a.createElement("div", {
						className: J.a.emptyToggleContainerLabel
					}, l ? X._("Pending", null, {
						hk: "1heuFt"
					}) : X._("No Awards currently available for configuration. Please try again later.", null, {
						hk: "3BsFsT"
					})));
					const m = s && s.all;
					return o.a.createElement("div", {
						className: J.a.awardToggleContainer
					}, o.a.createElement("div", {
						className: J.a.optionalAwardInfo
					}, X._("Toggle whether these awards are available in your community. If disabled, they cannot be given on any posts or comments.", null, {
						hk: "4e1OPL"
					})), o.a.createElement("div", null, c.map(e => o.a.createElement(V.p, {
						key: e.id,
						on: e.isEnabled,
						forceOn: e.isEnabled,
						className: Object(S.a)(J.a.awardToggleItem, {
							[J.a.awardToggleItemDisabled]: !e.isEnabled
						}),
						label: o.a.createElement(Z, {
							award: e,
							iconUrl: u[e.id]
						}),
						onClick: () => (e => {
							const s = e.isEnabled ? d.g : d.h,
								o = e.isEnabled ? f.h : f.i;
							a(o(e, n)), m && r(s(t, e))
						})(e),
						disabled: !m
					}))))
				},
				ee = n("./src/reddit/components/CommunityAwardList/index.m.less"),
				te = n.n(ee);
			const ne = Object(a.c)({
					awardIcons: (e, t) => {
						let {
							subredditOrProfileId: n
						} = t;
						const s = Object(K.e)(e, {
							subredditOrProfileId: n
						});
						return Object(Q.b)(e, {
							awards: s,
							minSize: 32
						})
					},
					awards: K.e,
					awardsPending: K.d,
					communityAwardsDisabled: K.b,
					isAddAwardModalOpen: e => Object(j.a)(e) === u.a,
					isConfirmModalOpen: e => Object(j.a)(e) === u.b
				}),
				se = Object(i.b)(ne, (e, t) => {
					let {
						subredditOrProfileId: n
					} = t;
					return {
						deleteAward: t => e(Object(d.j)(n, t)),
						toggleAddAwardModal: () => e(Object(c.i)(u.a)),
						toggleConfirmModal: () => e(Object(c.i)(u.b)),
						toggleTooltip: t => e(Object(l.h)({
							tooltipId: t
						}))
					}
				}),
				re = {
					awardId: null,
					selectedCoinPrice: void 0,
					selectedModOnly: void 0
				};
			class oe extends o.a.Component {
				constructor(e) {
					super(e), this.openAddAwardModal = (e, t) => {
						Object(b.d)(b.a.AwardCreationFlow), this.props.sendEvent(Object(f.e)()), this.setState({
							selectedCoinPrice: e,
							selectedModOnly: t
						}, this.props.toggleAddAwardModal)
					}, this.openDeleteAwardModal = e => {
						Object(b.d)(b.a.AwardDeletionFlow), this.props.toggleConfirmModal(), this.setState({
							awardId: e
						})
					}, this.confirmDeleteAward = () => {
						const {
							awardId: e
						} = this.state, {
							awards: t
						} = this.props;
						if (this.props.toggleConfirmModal(), e) {
							const n = t.filter(t => t.id === e)[0];
							n && this.props.sendEvent(Object(f.g)(n)), this.props.deleteAward(e), Object(b.b)(b.a.AwardDeletionFlow)
						}
					}, this.renderAwardSlotRow = e => {
						const {
							awardIcons: t,
							awards: n,
							moderatorPermissions: s,
							subredditOrProfileId: r
						} = this.props, i = !(!s || !s.all);
						if (!e.filled && n.length < u.d) return o.a.createElement(B, {
							coinPrice: e.price,
							key: e.price,
							onCreate: () => this.openAddAwardModal(e.price),
							quantity: e.quantity
						});
						if (!e.filled) return null;
						const {
							award: a
						} = e, d = t[a.id];
						return o.a.createElement(W, {
							key: a.id,
							award: a,
							canDelete: i,
							onDelete: this.openDeleteAwardModal,
							iconUrl: d,
							subredditId: r
						})
					}, this.renderAwardToDelete = () => {
						const {
							awards: e
						} = this.props, {
							awardId: t
						} = this.state;
						if (!t) return null;
						const n = e.filter(e => e.id === t)[0];
						return n ? o.a.createElement("div", {
							className: te.a.awardToDelete
						}, o.a.createElement("span", null, s.fbt._("Remove:", null, {
							hk: "1Y4r4o"
						})), o.a.createElement("img", {
							src: n.icon.url,
							className: te.a.awardToDeleteIcon
						}), o.a.createElement("span", null, n.name)) : null
					}, this.renderInfo = () => o.a.createElement("div", {
						className: te.a.pageInfo
					}, o.a.createElement(C.a, {
						name: "info",
						className: te.a.infoIcon
					}), o.a.createElement("p", null, s.fbt._("Community Awards are unique to each community, and members can give them to each other. Moderators can design and name the Awards however they want.", null, {
						hk: "1mzX5Y"
					})), o.a.createElement("p", null, s.fbt._("A portion of Coins from Community Award purchases will be deposited to the community’s Coin balance. Moderators can use Coins from that balance to reward members with Mod Awards. The Coin balance is shown only to moderators in the community’s sidebar", null, {
						hk: "2TVMDb"
					}))), this.state = re
				}
				renderAwardsList() {
					const {
						awards: e,
						awardsPending: t,
						moderatorPermissions: n,
						subredditOrProfileId: s
					} = this.props;
					if (t) return o.a.createElement(D, null);
					const r = Object(p.a)(s),
						i = n && n.all,
						a = this.getAwardSlots().filter(e => i && !r || e.filled),
						d = e.filter(e => e.awardType === v.f.Moderator),
						c = e.length < u.d && d.length < u.e && i && !r;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(F, {
						subredditId: s
					}), r && o.a.createElement(G, {
						onCreate: () => this.openAddAwardModal()
					}), a.map(this.renderAwardSlotRow), c && o.a.createElement(q, {
						onCreate: () => this.openAddAwardModal(void 0, !0)
					}), this.renderInfo())
				}
				getAwardSlots() {
					const {
						awards: e
					} = this.props, t = Object(v.l)(e), n = e => e.filled && e.award.awardType === v.f.Moderator;
					return t.sort((e, t) => n(e) && !n(t) ? 1 : n(t) && !n(e) ? -1 : e.price !== t.price ? e.price - t.price : e.filled && !t.filled ? -1 : (t.filled && e.filled, 1))
				}
				render() {
					const {
						communityAwardsDisabled: e,
						isAddAwardModalOpen: t,
						isConfirmModalOpen: n,
						moderatorPermissions: r,
						subredditOrProfile: i,
						subredditOrProfileId: a,
						toggleAddAwardModal: d,
						toggleConfirmModal: c
					} = this.props, {
						awardId: l,
						selectedCoinPrice: u,
						selectedModOnly: p
					} = this.state, f = i.isNSFW || e;
					return o.a.createElement(o.a.Fragment, null, Object(m.a)(i) && o.a.createElement(E.a, {
						className: te.a.contentContainer
					}, o.a.createElement(E.b, null, s.fbt._("Community Awards", null, {
						hk: "lraSi"
					})), f ? this.renderBlacklistedView() : this.renderAwardsList()), o.a.createElement(E.a, {
						className: te.a.contentContainer
					}, o.a.createElement(E.b, null, s.fbt._("Enable/Disable Awards", null, {
						hk: "1IRmfG"
					})), o.a.createElement($, {
						subredditOrProfile: i,
						subredditOrProfileId: a,
						moderatorPermissions: r
					})), t && o.a.createElement(g, {
						defaultCoinPrice: u,
						defaultModOnly: p,
						subredditId: a,
						toggleModal: () => {
							d(), Object(b.b)(b.a.AwardCreationFlow)
						}
					}), n && l && o.a.createElement(x.a, {
						acceptText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						cancelText: s.fbt._("Cancel", null, {
							hk: "2TSLl5"
						}),
						headerText: s.fbt._("Delete Award", null, {
							hk: "7q2D7"
						}),
						message: s.fbt._("Deleting an Award will remove the option for members of your community to give the Award. Existing Awards will remain on the posts and comments that have received them.", null, {
							hk: "3tX5sQ"
						}),
						onAccept: this.confirmDeleteAward,
						onCancel: c,
						onClose: c,
						onOverlayClick: c,
						withOverlay: !0
					}, this.renderAwardToDelete()))
				}
				renderBlacklistedView() {
					return o.a.createElement(O.c, {
						text: s.fbt._("Community Awards have been disabled for this community.", null, {
							hk: "2g21s6"
						})
					}, o.a.createElement(C.a, {
						name: "award",
						className: te.a.gildIcon
					}))
				}
			}
			t.a = se(Object(y.c)(oe))
		},
		"./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less": function(e, t, n) {
			e.exports = {
				countrySiteForm: "_3EwDpZ19gPFB461uuy7iGL",
				dropdownContainer: "_3XPnIpveWFDgMhBmnMyd9e",
				innerFlexboxContainer: "_1tHvQJ3zvN2gjV9HDwzxRj"
			}
		},
		"./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-CommunitySettings-ModPnSettings",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-CommunitySettings-ModPnSettings").then(n.bind(null, "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/CommunitySettings/ModPnSettings/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CommunitySettings/components.m.less": function(e, t, n) {
			e.exports = {
				InputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				inputField: "_3V4RO9mtZyZCWAu4P0ST4A",
				FormContainer: "_37sNfY6fNJVPqyQXOHlg3K",
				formContainer: "_37sNfY6fNJVPqyQXOHlg3K"
			}
		},
		"./src/reddit/components/CommunitySettings/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "l", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "o", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "j", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/redditGQL/types.ts");
			const o = 500,
				i = 100,
				a = 5e3,
				d = 0,
				c = 1440,
				l = 36600,
				u = 1e9,
				m = {
					disabled: s.fbt._("Disabled", null, {
						hk: "1KaunG"
					}).toString(),
					modonly: s.fbt._("Mods only", null, {
						hk: "2yA6R8"
					}).toString(),
					anyone: s.fbt._("Anyone", null, {
						hk: "4gPsEy"
					}).toString()
				},
				p = [s.fbt._("Wiki is disabled for all users except mods", null, {
					hk: "2loUiE"
				}).toString(), s.fbt._("Only mods, approved wiki contributors, or those on a page's edit list may edit", null, {
					hk: "1WUeVN"
				}).toString(), s.fbt._("Anyone who can submit to the community may edit", null, {
					hk: "3hxotT"
				}).toString()],
				b = {
					any: s.fbt._("Any", null, {
						hk: "hVUT8"
					}),
					link: s.fbt._("Links only", null, {
						hk: "3upkyk"
					}),
					self: s.fbt._("Text posts only", null, {
						hk: "1VZn8Y"
					})
				},
				f = [s.fbt._("Any post type is allowed", null, {
					hk: "1rOxtJ"
				}), s.fbt._("Only links to external sites are allowed", null, {
					hk: "OJQdj"
				}), s.fbt._("Only text posts are allowed", null, {
					hk: "3q3v14"
				})],
				h = {
					mods: s.fbt._("Moderators", null, {
						hk: "2rrkiT"
					}),
					anyone: s.fbt._("Anyone", null, {
						hk: "Xp8Fs"
					})
				},
				_ = {
					[r.P.Low]: s.fbt._("Low", null, {
						hk: "4k3iTe"
					}),
					[r.P.High]: s.fbt._("High (default)", null, {
						hk: "2GOHsH"
					}),
					[r.P.All]: s.fbt._("All", null, {
						hk: "gl6gc"
					})
				},
				g = {
					[r.P.Low]: s.fbt._("Low (default)", null, {
						hk: "2tqJd7"
					}),
					[r.P.High]: s.fbt._("High", null, {
						hk: "ABfkc"
					}),
					[r.P.All]: s.fbt._("All", null, {
						hk: "3bPDOM"
					})
				},
				v = {
					nullValue: s.fbt._("none (recommended)", null, {
						hk: "2FMwQH"
					}),
					confidence: s.fbt._("best", null, {
						hk: "13cLYH"
					}),
					old: s.fbt._("old", null, {
						hk: "3V0QN8"
					}),
					top: s.fbt._("top", null, {
						hk: "40R5FY"
					}),
					qa: s.fbt._("q&a", null, {
						hk: "3cm6YL"
					}),
					live: s.fbt._("live (beta)", null, {
						hk: "2EVYAd"
					}),
					controversial: s.fbt._("controversial", null, {
						hk: "1uFV5F"
					}),
					new: s.fbt._("new", null, {
						hk: "39TZi6"
					})
				}
		},
		"./src/reddit/components/CommunitySettings/index.m.less": function(e, t, n) {
			e.exports = {
				pageTitle: "_1YwfovPToau7hk7kk7VjvV",
				communityTopicsHelpLink: "_2Tzl9XrmQzUn94gYHRUYMI",
				welcomeMessageHelpLink: "_3-XV8EhlxRlIzoFKUI6gmQ",
				fullWidthTextContainer: "_2SnK_8NMPSqmFfF-es2GGa",
				subtextContainer: "_2sWG233wmE9wNycTEyRHRN",
				sectionHeadingFollowedBySubtext: "_2znhaJWCK6NY6bIPtrS2sx",
				sectionSubtext: "_2gZA-d4bPf-v-QStyl39CP",
				subtextLink: "_3m7YXm3a55mNltI6wwKkal",
				numCommunityTopicsSelected: "Ty_datAAaSbn2GX5-1O58",
				welcomeMessageEnabled: "_21a0DjKnRl3i1ItjJ8cSyf",
				geoForm: "_1QCMnCbDgm4T-QmBwOFkQ7",
				geoText: "lhgqy5yEx-4vqJhuaRIW_",
				geoInput: "_20j3hiEorqFwMLxftPVQG1",
				contentTag: "_26M_DkGPAeiqHaMshbczhg",
				contentTagColumn: "_2lbeaHzGFIYy6MK6YfLqrd",
				ratingAudience: "_3HR2r8RW7cFhNSKPiAT6VO",
				ratingDescription: "_3Wy4OBl1ksNXzpoeV4dvli",
				ratingReason: "_254fRg3JX4apEtqVAAXfbm",
				promptText: "RqDOw50ARYjx_TliwJR0l",
				surveyButton: "_7aZGYzh7hj5VihV4LcNzP",
				previewButton: "_2OmdANJm2jP7a_6G2-JCqg",
				disabled: "_3DyIlr3eqm1Pq3T9Jx0Kgx",
				rangeSetting: "_3BfcidCIw4ZNn2i2jR7fKT",
				noMarginHeading: "kt9ucKpVrHFhY-_xvYiLF",
				flexSpacer: "_2urERRC5ZgXlBwG8augYFu",
				labelWithNewTag: "_2tw6jmSgf4-SvF7sT8DIwT",
				labelNewTag: "_1W9XvmIuDMXygCmP-t8uxn"
			}
		},
		"./src/reddit/components/CommunitySettings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/pages/shared.ts"),
				u = n("./src/reddit/actions/subredditSettings.ts"),
				m = n("./src/lib/makeActionCreator/index.ts"),
				p = n("./src/lib/makeGqlRequest/index.ts"),
				b = (n("./src/redditGQL/operations/GetSubredditWelcomeMessage.json"), n("./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json"));
			const f = e => {
				if (e) return {
					...e
				}
			};
			const h = (e, t, n) => async (s, r, o) => {
				let {
					gqlContext: i
				} = o;
				const a = {
						subredditId: e,
						isWelcomeMessageEnabled: t,
						welcomeMessage: {
							markdown: n
						}
					},
					d = await ((e, t) => Object(p.a)(e, {
						...b,
						variables: t
					}))(i(), {
						input: a
					});
				if (d.ok) {
					const t = (e => {
						var t, n;
						const s = null === (n = null === (t = null == e ? void 0 : e.data.updateSubredditSettings) || void 0 === t ? void 0 : t.subreddit) || void 0 === n ? void 0 : n.welcomeMessage;
						return f(s)
					})(d.body);
					t && s(_({
						subredditId: e,
						welcomeMessage: t
					}))
				}
			}, _ = Object(m.a)("SUBREDDIT_WELCOME_MESSAGE__LOADED");
			var g = n("./src/reddit/actions/tags/index.ts"),
				v = n("./src/lib/lessComponent.tsx"),
				x = n("./src/reddit/controls/FormFields/index.tsx"),
				O = n("./src/reddit/components/CommunitySettings/components.m.less"),
				E = n.n(O);
			const y = v.a.wrapped(x.b, "InputField", E.a),
				C = v.a.div("FormContainer", E.a);
			var j = n("./src/reddit/components/CommunitySettings/ModPnSettings/Loader.tsx"),
				k = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				I = n("./src/reddit/components/TrackingHelper/index.tsx"),
				S = n("./src/reddit/controls/Button/index.tsx"),
				w = n("./src/reddit/featureFlags/index.ts"),
				T = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				N = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				P = n("./src/reddit/models/Tags/index.ts"),
				R = n("./src/reddit/selectors/chatPost.ts"),
				A = n("./src/reddit/selectors/streamingModSettings.ts"),
				M = n("./src/reddit/selectors/subreddit.ts");
			var L = n("./src/reddit/selectors/subredditSettings.ts"),
				D = n("./src/reddit/selectors/tags.ts"),
				F = n("./src/reddit/selectors/user.ts"),
				U = n("./src/reddit/actions/countrySites/subredditCountrySiteSettings.ts"),
				B = n("./src/reddit/selectors/experiments/countrySites.ts"),
				q = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				G = n("./node_modules/fbt/lib/FbtPublic.js"),
				H = n("./src/lib/classNames/index.ts"),
				W = n("./src/reddit/components/CommunityTopics/index.tsx"),
				V = n("./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx"),
				z = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx"),
				K = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx"),
				Q = n("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				Y = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				J = n("./src/reddit/components/SubredditCreationModal/index.tsx"),
				X = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				Z = n("./src/reddit/controls/RadioInput/index.tsx"),
				$ = n("./src/reddit/models/Flair/index.ts"),
				ee = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				te = n("./src/reddit/components/CommunitySettings/helpers.ts"),
				ne = n("./src/reddit/actions/toaster.ts"),
				se = n("./src/reddit/components/GeoForm/GeoForm.tsx"),
				re = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				oe = n("./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts"),
				ie = n("./src/reddit/helpers/localStorage/index.ts"),
				ae = n("./src/reddit/hooks/useGqlContext.ts"),
				de = n("./src/reddit/models/Toast/index.ts"),
				ce = [{
					value: "Global",
					countryCode: "*",
					icon: "🌎"
				}, {
					value: "United States",
					countryCode: "US",
					icon: "🇺🇸"
				}, {
					value: "Argentina",
					countryCode: "AR",
					icon: "🇦🇷"
				}, {
					value: "Australia",
					countryCode: "AU",
					icon: "🇦🇺"
				}, {
					value: "Austria",
					countryCode: "AT",
					icon: "🇦🇹"
				}, {
					value: "Belgium",
					countryCode: "BE",
					icon: "🇧🇪"
				}, {
					value: "Brazil",
					countryCode: "BR",
					icon: "🇧🇷"
				}, {
					value: "Canada",
					countryCode: "CA",
					icon: "🇨🇦"
				}, {
					value: "Chile",
					countryCode: "CL",
					icon: "🇨🇱"
				}, {
					value: "Colombia",
					countryCode: "CO",
					icon: "🇨🇴"
				}, {
					value: "Czech Republic",
					countryCode: "CZ",
					icon: "🇨🇿"
				}, {
					value: "Denmark",
					countryCode: "DK",
					icon: "🇩🇰"
				}, {
					value: "Egypt",
					countryCode: "EG",
					icon: "🇪🇬"
				}, {
					value: "Finland",
					countryCode: "FI",
					icon: "🇫🇮"
				}, {
					value: "France",
					countryCode: "FR",
					icon: "🇫🇷"
				}, {
					value: "Germany",
					countryCode: "DE",
					icon: "🇩🇪"
				}, {
					value: "Greece",
					countryCode: "GR",
					icon: "🇬🇷"
				}, {
					value: "Hungary",
					countryCode: "HU",
					icon: "🇭🇺"
				}, {
					value: "India",
					countryCode: "IN",
					icon: "🇮🇳"
				}, {
					value: "Indonesia",
					countryCode: "ID",
					icon: "🇮🇩"
				}, {
					value: "Ireland",
					countryCode: "IE",
					icon: "🇮🇪"
				}, {
					value: "Italy",
					countryCode: "IT",
					icon: "🇮🇹"
				}, {
					value: "Japan",
					countryCode: "JP",
					icon: "🇯🇵"
				}, {
					value: "Korea, Republic of",
					countryCode: "KR",
					icon: "🇰🇷"
				}, {
					value: "Malaysia",
					countryCode: "MY",
					icon: "🇲🇾"
				}, {
					value: "Mexico",
					countryCode: "MX",
					icon: "🇲🇽"
				}, {
					value: "Netherlands",
					countryCode: "NL",
					icon: "🇳🇱"
				}, {
					value: "New Zealand",
					countryCode: "NZ",
					icon: "🇳🇿"
				}, {
					value: "Nigeria",
					countryCode: "NG",
					icon: "🇳🇬"
				}, {
					value: "Norway",
					countryCode: "NO",
					icon: "🇳🇴"
				}, {
					value: "Peru",
					countryCode: "PE",
					icon: "🇵🇪"
				}, {
					value: "Philippines",
					countryCode: "PH",
					icon: "🇵🇭"
				}, {
					value: "Poland",
					countryCode: "PL",
					icon: "🇵🇱"
				}, {
					value: "Portugal",
					countryCode: "PT",
					icon: "🇵🇹"
				}, {
					value: "Romania",
					countryCode: "RO",
					icon: "🇷🇴"
				}, {
					value: "Russia",
					countryCode: "RU",
					icon: "🇷🇺"
				}, {
					value: "Saudi Arabia",
					countryCode: "SA",
					icon: "🇸🇦"
				}, {
					value: "Singapore",
					countryCode: "SG",
					icon: "🇸🇬"
				}, {
					value: "South Africa",
					countryCode: "ZA",
					icon: "🇿🇦"
				}, {
					value: "Spain",
					countryCode: "ES",
					icon: "🇪🇸"
				}, {
					value: "Sweden",
					countryCode: "SE",
					icon: "🇸🇪"
				}, {
					value: "Switzerland",
					countryCode: "CH",
					icon: "🇨🇭"
				}, {
					value: "Thailand",
					countryCode: "TH",
					icon: "🇹🇭"
				}, {
					value: "Turkey",
					countryCode: "TR",
					icon: "🇹🇷"
				}, {
					value: "United Arab Emirates",
					countryCode: "AE",
					icon: "🇦🇪"
				}, {
					value: "United Kingdom",
					countryCode: "UK",
					icon: "🇬🇧"
				}, {
					value: "Vietnam",
					countryCode: "VN",
					icon: "🇻🇳"
				}];
			var le = [Object.freeze({
					isoCode: "",
					displayName: "Other",
					englishName: "Other",
					rtl: !1
				}), Object.freeze({
					isoCode: "af",
					displayName: "Afrikaans",
					englishName: "Afrikaans",
					rtl: !1
				}), Object.freeze({
					isoCode: "az",
					displayName: "Azərbaycan",
					englishName: "Azerbaijani",
					rtl: !1
				}), Object.freeze({
					isoCode: "id",
					displayName: "Bahasa Indonesia",
					englishName: "Indonesian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ms",
					displayName: "Bahasa Melayu",
					englishName: "Malay",
					rtl: !1
				}), Object.freeze({
					isoCode: "bs",
					displayName: "Bosanski",
					englishName: "Bosnian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ca",
					displayName: "Català",
					englishName: "Catalan",
					rtl: !1
				}), Object.freeze({
					isoCode: "cs",
					displayName: "Čeština",
					englishName: "Czech",
					rtl: !1
				}), Object.freeze({
					isoCode: "da",
					displayName: "Dansk",
					englishName: "Danish",
					rtl: !1
				}), Object.freeze({
					isoCode: "de",
					displayName: "Deutsch",
					englishName: "German",
					rtl: !1
				}), Object.freeze({
					isoCode: "et",
					displayName: "Eesti",
					englishName: "Estonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "en",
					displayName: "English",
					englishName: "English",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-IN",
					displayName: "English (India)",
					englishName: "English (India)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-GB",
					displayName: "English (UK)",
					englishName: "English (UK)",
					rtl: !1
				}), Object.freeze({
					isoCode: "en-US",
					displayName: "English (US)",
					englishName: "English (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-ES",
					displayName: "Español (España)",
					englishName: "Spanish (Spain)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es",
					displayName: "Español (Latinoamérica)",
					englishName: "Spanish (Latam)",
					rtl: !1
				}), Object.freeze({
					isoCode: "es-US",
					displayName: "Español (US)",
					englishName: "Spanish (US)",
					rtl: !1
				}), Object.freeze({
					isoCode: "eu",
					displayName: "Euskara",
					englishName: "Basque",
					rtl: !1
				}), Object.freeze({
					isoCode: "tl",
					displayName: "Filipino",
					englishName: "Filipino",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr",
					displayName: "Français",
					englishName: "French",
					rtl: !1
				}), Object.freeze({
					isoCode: "fr-CA",
					displayName: "Français (Canada)",
					englishName: "French Canada",
					rtl: !1
				}), Object.freeze({
					isoCode: "gl",
					displayName: "Galego",
					englishName: "Galician",
					rtl: !1
				}), Object.freeze({
					isoCode: "hr",
					displayName: "Hrvatski",
					englishName: "Croatian",
					rtl: !1
				}), Object.freeze({
					isoCode: "zu",
					displayName: "IsiZulu",
					englishName: "Zulu",
					rtl: !1
				}), Object.freeze({
					isoCode: "is",
					displayName: "Íslenska",
					englishName: "Icelandic",
					rtl: !1
				}), Object.freeze({
					isoCode: "it",
					displayName: "Italiano",
					englishName: "Italian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sw",
					displayName: "Kiswahili",
					englishName: "Swahili",
					rtl: !1
				}), Object.freeze({
					isoCode: "lv",
					displayName: "Latviešu",
					englishName: "Latvian",
					rtl: !1
				}), Object.freeze({
					isoCode: "lt",
					displayName: "Lietuvių",
					englishName: "Lithuanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hu",
					displayName: "Magyar",
					englishName: "Hungarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "nl",
					displayName: "Nederlands",
					englishName: "Dutch",
					rtl: !1
				}), Object.freeze({
					isoCode: "no",
					displayName: "Norsk",
					englishName: "Norwegian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uz",
					displayName: "O‘zbek",
					englishName: "Uzbek",
					rtl: !1
				}), Object.freeze({
					isoCode: "pl",
					displayName: "Polski",
					englishName: "Polish",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt",
					displayName: "Português",
					englishName: "Portugues",
					rtl: !1
				}), Object.freeze({
					isoCode: "pt-BR",
					displayName: "Português (Brasil)",
					englishName: "Portugues (Brazil)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ro",
					displayName: "Română",
					englishName: "Romanian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sq",
					displayName: "Shqip",
					englishName: "Sango",
					rtl: !1
				}), Object.freeze({
					isoCode: "sk",
					displayName: "Slovenčina",
					englishName: "Slovak",
					rtl: !1
				}), Object.freeze({
					isoCode: "sl",
					displayName: "Slovenščina",
					englishName: "Slovenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "Srpski",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "fi",
					displayName: "Suomi",
					englishName: "Finnish",
					rtl: !1
				}), Object.freeze({
					isoCode: "sv",
					displayName: "Svenska",
					englishName: "Swedish",
					rtl: !1
				}), Object.freeze({
					isoCode: "vi",
					displayName: "Tiếng Việt",
					englishName: "Vietnamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "tr",
					displayName: "Türkçe",
					englishName: "Turkish",
					rtl: !1
				}), Object.freeze({
					isoCode: "el",
					displayName: "Ελληνικά",
					englishName: "Greek, Modern",
					rtl: !1
				}), Object.freeze({
					isoCode: "be",
					displayName: "Беларуская",
					englishName: "Belarusian",
					rtl: !1
				}), Object.freeze({
					isoCode: "bg",
					displayName: "Български",
					englishName: "Bulgarian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ky",
					displayName: "Кыргызча",
					englishName: "Kirghiz",
					rtl: !1
				}), Object.freeze({
					isoCode: "kk",
					displayName: "Қазақ Тілі",
					englishName: "Kazakh",
					rtl: !1
				}), Object.freeze({
					isoCode: "mk",
					displayName: "Македонски",
					englishName: "Macedonian",
					rtl: !1
				}), Object.freeze({
					isoCode: "mn",
					displayName: "Монгол",
					englishName: "Mongolian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ru",
					displayName: "Русский",
					englishName: "Russian",
					rtl: !1
				}), Object.freeze({
					isoCode: "sr",
					displayName: "Српски",
					englishName: "Serbian",
					rtl: !1
				}), Object.freeze({
					isoCode: "uk",
					displayName: "Українська",
					englishName: "Ukrainian",
					rtl: !1
				}), Object.freeze({
					isoCode: "ka",
					displayName: "ქართული",
					englishName: "Georgian",
					rtl: !1
				}), Object.freeze({
					isoCode: "hy",
					displayName: "Հայերեն",
					englishName: "Armenian",
					rtl: !1
				}), Object.freeze({
					isoCode: "he",
					displayName: "עברית",
					englishName: "Hebrew",
					rtl: !0
				}), Object.freeze({
					isoCode: "ur",
					displayName: "اردو",
					englishName: "Urdu",
					rtl: !0
				}), Object.freeze({
					isoCode: "ar",
					displayName: "العربية",
					englishName: "Arabic",
					rtl: !0
				}), Object.freeze({
					isoCode: "fa",
					displayName: "فارسی",
					englishName: "Persian",
					rtl: !0
				}), Object.freeze({
					isoCode: "am",
					displayName: "አማርኛ",
					englishName: "Amharic",
					rtl: !1
				}), Object.freeze({
					isoCode: "ne",
					displayName: "नेपाली",
					englishName: "Nepali",
					rtl: !1
				}), Object.freeze({
					isoCode: "mr",
					displayName: "मराठी",
					englishName: "Marathi",
					rtl: !1
				}), Object.freeze({
					isoCode: "hi",
					displayName: "हिन्दी",
					englishName: "Hindi",
					rtl: !1
				}), Object.freeze({
					isoCode: "as",
					displayName: "অসমীয়া",
					englishName: "Assamese",
					rtl: !1
				}), Object.freeze({
					isoCode: "bn",
					displayName: "বাংলা",
					englishName: "Bengali",
					rtl: !1
				}), Object.freeze({
					isoCode: "pa",
					displayName: "ਪੰਜਾਬੀ",
					englishName: "Punjabi",
					rtl: !1
				}), Object.freeze({
					isoCode: "gu",
					displayName: "ગુજરાતી",
					englishName: "Gujarati",
					rtl: !1
				}), Object.freeze({
					isoCode: "or",
					displayName: "ଓଡ଼ିଆ",
					englishName: "Oriya",
					rtl: !1
				}), Object.freeze({
					isoCode: "ta",
					displayName: "தமிழ்",
					englishName: "Tamil",
					rtl: !1
				}), Object.freeze({
					isoCode: "te",
					displayName: "తెలుగు",
					englishName: "Telugu",
					rtl: !1
				}), Object.freeze({
					isoCode: "kn",
					displayName: "ಕನ್ನಡ",
					englishName: "Kannada",
					rtl: !1
				}), Object.freeze({
					isoCode: "ml",
					displayName: "മലയാളം",
					englishName: "Malayalam",
					rtl: !1
				}), Object.freeze({
					isoCode: "si",
					displayName: "සිංහල",
					englishName: "Sinhala",
					rtl: !1
				}), Object.freeze({
					isoCode: "th",
					displayName: "ภาษาไทย",
					englishName: "Thai",
					rtl: !1
				}), Object.freeze({
					isoCode: "lo",
					displayName: "ລາວ",
					englishName: "Lao",
					rtl: !1
				}), Object.freeze({
					isoCode: "my",
					displayName: "မြန်မာစကား",
					englishName: "Burmese",
					rtl: !1
				}), Object.freeze({
					isoCode: "km",
					displayName: "ភាសាខ្មែរ",
					englishName: "Central Khmer",
					rtl: !1
				}), Object.freeze({
					isoCode: "ko",
					displayName: "한국어",
					englishName: "Korean",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-CN",
					displayName: "中文 (简体)",
					englishName: "Chinese (Simplified)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh",
					displayName: "中文 (繁體)",
					englishName: "Chinese (Traditional)",
					rtl: !1
				}), Object.freeze({
					isoCode: "zh-HK",
					displayName: "中文 (香港)",
					englishName: "Chinese (Hong Kong)",
					rtl: !1
				}), Object.freeze({
					isoCode: "ja",
					displayName: "日本語",
					englishName: "Japanese",
					rtl: !1
				})],
				ue = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				me = n("./src/lib/humanizeDate/index.ts"),
				pe = n("./src/reddit/constants/keycodes.ts"),
				be = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				fe = n("./src/reddit/components/CommonAutocompleteDropdown/index.m.less"),
				he = n.n(fe);

			function _e(e) {
				const {
					icons: t = !0,
					id: n,
					items: s,
					currentIndex: r,
					selectValue: a
				} = e, d = Object(o.useRef)(null);
				return Object(o.useEffect)(() => {
					var e;
					let t = 30 * r;
					r > 10 && (t += 120), d && (null === (e = d.current) || void 0 === e || e.scrollTo({
						top: t
					}))
				}, [r]), i.a.createElement("ul", {
					className: he.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${n}`,
					"data-testid": `autocomplete-dropdown-${n}`,
					ref: d
				}, s.map((e, n) => i.a.createElement("li", {
					onClick: () => a(n),
					key: `${n}`,
					className: Object(H.a)({
						[he.a.highlight]: n === r
					}, he.a.autocompleteDropdownItem, {
						[he.a.autocompleteDropdownItem__rtl]: e.rtl
					})
				}, t && e.icon && i.a.createElement("span", {
					role: "img",
					"aria-label": e.value,
					className: he.a.autocompleteDropdownItem__icon
				}, e.icon), e.value)))
			}
			const ge = (e, t) => t.filter(t => 0 === t.value.toLowerCase().indexOf(e.toLocaleLowerCase()));

			function ve(e) {
				var t, n;
				const {
					className: s,
					customClickEvent: r,
					disabled: a,
					defaultIcon: d,
					icons: c = !1,
					initialItemIndex: l,
					listItems: u,
					locked: m = !1,
					placeholderText: p,
					sessionId: b,
					setSelectedParent: f
				} = e, [h, _] = Object(o.useState)(l), [g, v] = Object(o.useState)(u), [x, O] = Object(o.useState)(!0), [E, y] = Object(o.useState)((null === (t = u[l]) || void 0 === t ? void 0 : t.value) || ""), C = `autocomplete-input-${b}`, j = Object(o.useRef)(), k = (e, t) => {
					m || (O(!0), !t && e > -1 && (e = u.findIndex(t => g[e].key === t.key)), _(e), y(e > -1 && u[e].value || ""), f(e), v(u))
				};
				return Object(o.useEffect)(() => {
					var e;
					const t = function(e) {
						if (j && j.current) {
							j.current.contains(e.target) || O(!0)
						}
					};
					return _(l), y((null === (e = u[l]) || void 0 === e ? void 0 : e.value) || ""), document.addEventListener("click", t), () => document.removeEventListener("click", t)
				}, [l, u]), i.a.createElement("div", {
					className: he.a.autocompleteInputContainer,
					ref: j
				}, c && i.a.createElement("label", {
					className: he.a.autocompleteLabel,
					htmlFor: C
				}, (null === (n = g[h]) || void 0 === n ? void 0 : n.icon) || d), a ? i.a.createElement("span", {
					className: Object(H.a)(he.a.autocompleteInput, he.a.autocompleteInput__disabled, s)
				}, -1 !== l && u[l].value) : i.a.createElement("input", {
					id: `autocomplete-input-${b}`,
					"data-testid": `autocomplete-input-${b}`,
					className: Object(H.a)(he.a.autocompleteInput, s, !c && he.a.autocompleteInput__no_icon),
					name: C,
					value: E,
					placeholder: p,
					onChange: e => {
						m || (-1 !== h && (_(-1), f(-1)), y(e.currentTarget.value), v(ge(e.currentTarget.value, u)))
					},
					onKeyDown: e => {
						if (m) return;
						let t = -1;
						const n = g.length > 0;
						O(!1), n && e.key === pe.b.ArrowDown ? (t = Math.min(h + 1, g.length - 1), _(t), f(-1), t > -1 && t < g.length && y(g[t].value)) : n && e.key === pe.b.ArrowUp ? (t = Math.max(h - 1, -1), _(t), f(-1), t > -1 && t < g.length ? y(g[t].value) : y("")) : n && e.key === pe.b.Enter ? (e.preventDefault(), h > -1 && h < g.length ? k(h, !1) : 1 === g.length && k(0, !1)) : e.key === pe.b.Backspace ? f(-1) : e.key === pe.b.Escape ? (O(!0), l > -1 && ("" !== E && k(l, !0), "" === E && k(-1, !0))) : e.key === pe.b.Tab && (O(!0), -1 !== h ? k(h, !1) : ("" !== E && k(l, !0), "" === E && k(-1, !0)))
					},
					onClick: () => {
						O(!1), r()
					},
					onFocus: () => {
						O(!1)
					}
				}), m && i.a.createElement("span", {
					className: he.a.locked
				}, i.a.createElement(be.a, {
					className: he.a.lockIcon
				})), m || a || x || !g.length ? null : i.a.createElement(_e, {
					id: b,
					items: g,
					currentIndex: h,
					selectValue: e => (e => {
						k(e, !1)
					})(e)
				}))
			}
			var xe, Oe = n("./src/reddit/components/CommunitySettings/CountrySiteSettings/index.m.less"),
				Ee = n.n(Oe);
			! function(e) {
				e[e.CountryForm = 0] = "CountryForm", e[e.LanguageForm = 1] = "LanguageForm"
			}(xe || (xe = {}));
			var ye = Object(I.c)((function(e) {
					const {
						defaultIcon: t = "📍",
						formType: n,
						icons: s = !0,
						initialSubredditCountrySite: r,
						inputClassName: d,
						placeholderText: c,
						subredditId: l,
						listItems: u
					} = e, m = n === xe.CountryForm, p = m ? "countryCode" : "languageCode", b = Object(a.d)();
					let f = r && r[p] || "";
					m && (f = f.toUpperCase());
					const [h] = Object(o.useState)(() => Object(ue.a)()), _ = r && !(null == r ? void 0 : r.isCountrySiteEditable) || !1, g = m ? "country" : "language", v = r && m ? r.countryCode : (null == r ? void 0 : r.languageCode) || "";
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
						className: Ee.a.countrySiteForm
					}, i.a.createElement("div", {
						className: Ee.a.dropdownContainer
					}, i.a.createElement(ve, {
						className: d,
						defaultIcon: t,
						disabled: _,
						icons: s,
						initialItemIndex: (() => f ? u.findIndex(e => f.toUpperCase() === e.key.toUpperCase()) : -1)(),
						listItems: u,
						locked: _,
						placeholderText: c,
						sessionId: h,
						setSelectedParent: e => (e => {
							if (-1 !== e) {
								let t = u[e].code,
									n = r && r.languageCode || "";
								m || (t = r && r.countryCode || "", n = u[e].code), b(Object(U.g)({
									subredditId: l,
									subredditCountrySite: {
										countryCode: t,
										languageCode: n,
										isCountrySiteEditable: (null == r ? void 0 : r.isCountrySiteEditable) || !0,
										modMigrationAt: (null == r ? void 0 : r.modMigrationAt) || void 0
									}
								}))
							}
						})(e),
						customClickEvent: () => e.sendEvent(Object(T.a)(g, v))
					})), _ && r && i.a.createElement(Y.n, null, G.fbt._("This setting was saved by a mod on {modMigrationDate} and can’t be changed", [G.fbt._param("modMigrationDate", (e => {
						if (!e || !e.modMigrationAt) return "";
						const t = Date.parse(e.modMigrationAt);
						return Object(me.a)(t / 1e3, {
							showDay: !0
						})
					})(r))], {
						hk: "3OWLnm"
					}))))
				})),
				Ce = n("./src/reddit/components/CommunitySettings/index.m.less"),
				je = n.n(Ce);

			function ke(e) {
				var t;
				const {
					initialPlace: n,
					initialSubredditCountrySite: s,
					subredditId: r,
					subredditCountryEditEnabled: d = !1,
					subredditLanguageEditEnabled: c = !1,
					update: l
				} = e, u = Object(ae.a)(), m = Object(a.d)(), [p, b] = Object(o.useState)(n), [f, h] = Object(o.useState)(!1), [_, g] = Object(o.useState)(!0);
				return Object(o.useEffect)(() => {
					g(Object(ie.G)("location")), Object(ie.Lb)("location")
				}, []), i.a.createElement(i.a.Fragment, null, i.a.createElement(Q.a, {
					className: je.a.noMarginHeading
				}, G.fbt._("Community Location and main language", null, {
					hk: "3qWqzm"
				})), i.a.createElement(Y.n, null, G.fbt._("Adding a location helps your community show up in search results and recommendations and helps local redditors find it easier.", null, {
					hk: "3m21GN"
				})), i.a.createElement("div", {
					className: je.a.flexSpacer
				}), c && i.a.createElement(Y.l, {
					label: i.a.createElement(i.a.Fragment, null, G.fbt._("Language", null, {
						hk: "4iQFeH"
					}), !_ && i.a.createElement(re.a, null)),
					textContainerClassName: Object(H.a)(je.a.fullWidthTextContainer, je.a.geoText)
				}, i.a.createElement(ye, {
					defaultIcon: "",
					icons: !1,
					formType: xe.LanguageForm,
					initialSubredditCountrySite: s,
					inputClassName: je.a.autocompleteInput,
					listItems: Array.from(le, e => ({
						code: e.isoCode,
						key: e.isoCode,
						icon: "",
						value: e.displayName,
						rtl: e.rtl
					})),
					placeholderText: G.fbt._("Type to search for a language", null, {
						hk: "4dZ6Zv"
					}),
					subredditId: r
				})), d && i.a.createElement(Y.l, {
					label: i.a.createElement(i.a.Fragment, null, G.fbt._("Country", null, {
						hk: "1tNtsz"
					}), !_ && i.a.createElement(re.a, null)),
					textContainerClassName: Object(H.a)(je.a.fullWidthTextContainer, je.a.geoText)
				}, i.a.createElement(ye, {
					formType: xe.CountryForm,
					initialSubredditCountrySite: s,
					inputClassName: je.a.autocompleteInput,
					listItems: Array.from(ce, e => ({
						code: e.countryCode || "",
						key: e.countryCode || "",
						icon: e.icon,
						value: e.value
					})),
					placeholderText: G.fbt._("Type to search for a country", null, {
						hk: "51VKS"
					}),
					subredditId: r
				})), i.a.createElement(Y.l, {
					label: i.a.createElement(i.a.Fragment, null, G.fbt._("Region", null, {
						hk: "scpaL"
					}), !_ && i.a.createElement(re.a, null)),
					textContainerClassName: Object(H.a)(je.a.fullWidthTextContainer, je.a.geoText)
				}, i.a.createElement(se.a, {
					initialValue: null !== (t = null == n ? void 0 : n.name) && void 0 !== t ? t : "",
					initialPlace: p,
					onPlace: e => l(e, "place"),
					onSubmit: async function(e) {
						let {
							place: t,
							sessionId: n
						} = e;
						if ((null == t ? void 0 : t.id) === (null == p ? void 0 : p.id)) return;
						h(!0);
						const s = await Object(oe.a)(u(), {
							subredditId: r,
							placeId: t.id,
							source: t.source,
							sessionId: n
						});
						if (h(!1), !s.ok) return m(Object(ne.f)({
							kind: de.b.Error,
							text: G.fbt._("Something went wrong", null, {
								hk: "2PnKbu"
							}),
							duration: 5e3
						}));
						b(t), m(Object(ne.f)({
							kind: de.b.SuccessCommunity,
							text: G.fbt._("Successfully updated community location", null, {
								hk: "3aGk2e"
							}),
							duration: 5e3
						}))
					},
					disabled: f,
					className: je.a.geoForm,
					inputClassName: je.a.geoInput
				})))
			}
			const Ie = {
				[ee.e.Post]: {
					short: () => G.fbt._("Post only (default)", null, {
						hk: "2XJHW4"
					}),
					long: () => G.fbt._("Only approved users can post. Anyone can comment.", null, {
						hk: "3frgit"
					})
				},
				[ee.e.Comment]: {
					short: () => G.fbt._("Comment only", null, {
						hk: "2OhQB5"
					}),
					long: () => G.fbt._("Only approved users can comment. Anyone can post.", null, {
						hk: "2F24kr"
					})
				},
				[ee.e.PostAndComment]: {
					short: () => G.fbt._("Post & Comment", null, {
						hk: "1lWCl2"
					}),
					long: () => G.fbt._("Only approved users can post and comment.", null, {
						hk: "4GkEs6"
					})
				}
			};

			function Se(e) {
				const {
					isEmployee: t,
					restrictions: n,
					settings: s,
					subredditId: r,
					subredditName: o,
					testWelcomeMessage: a,
					update: d,
					geoPlace: l,
					onFocusWelcomeMessageInput: u,
					subredditCountrySite: m,
					subredditCountryEditEnabled: p,
					subredditLanguageEditEnabled: b
				} = e, {
					disableContributorRequests: f,
					over18: h,
					publicDescription: _,
					restrictCommenting: g,
					restrictPosting: v,
					subredditType: x,
					title: O,
					welcomeMessageEnabled: E,
					welcomeMessageText: y
				} = s, j = [], I = [];
				for (const i of Object.keys(Ie)) I.push(Ie[i].short()), j.push(Ie[i].long());
				const w = !y || 0 === (null == y ? void 0 : y.length);
				return i.a.createElement(k.a, null, i.a.createElement(C, null, i.a.createElement(k.b, null, G.fbt._("Community settings", null, {
					hk: "3mvH70"
				})), i.a.createElement(Q.a, null, G.fbt._("Community Profile", null, {
					hk: "91aEK"
				})), i.a.createElement(Y.e, {
					label: G.fbt._("Community name", null, {
						hk: "260EEx"
					}),
					maxChars: te.e,
					onChange: e => d(e.currentTarget.value, "title"),
					textContainerClassName: je.a.fullWidthTextContainer,
					value: O || ""
				}), i.a.createElement(Y.l, {
					label: G.fbt._("Community topics", null, {
						hk: "49aoGo"
					}),
					textContainerClassName: je.a.fullWidthTextContainer,
					subtext: i.a.createElement("span", {
						className: je.a.subtextContainer
					}, G.fbt._("This will help Reddit recommend your community to relevant users and other discovery experiences.", null, {
						hk: "3WYTu5"
					}), " ", i.a.createElement(X.a, {
						className: je.a.communityTopicsHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360024518712",
						rel: "noopener noreferrer",
						target: "_blank"
					}, G.fbt._("Learn more.", null, {
						hk: "1y3kXY"
					})), " ", " ", i.a.createElement("span", {
						className: je.a.numCommunityTopicsSelected
					}, i.a.createElement(V.a, {
						subredditId: r
					}))),
					direction: "column"
				}, i.a.createElement(z.b, {
					subredditId: r,
					onPrimarySelect: e.onPrimarySelect
				}), (!!e.selectedPrimaryTag || e.hasSecondaryTags) && i.a.createElement(W.b, {
					context: N.a.communitySettings,
					subredditId: r
				}), i.a.createElement(K.a, {
					context: N.a.communitySettings,
					subredditId: r
				})), i.a.createElement(Y.h, {
					label: G.fbt._("Community description", null, {
						hk: "1XBKXj"
					}),
					onChange: e => d(e.currentTarget.value, "publicDescription", !1),
					maxChars: te.d,
					rows: 2,
					subtext: G.fbt._("This is how new members come to understand your community.", null, {
						hk: "llaA4"
					}),
					value: _ || ""
				}), i.a.createElement(Y.p, {
					className: E ? je.a.welcomeMessageEnabled : void 0,
					on: E,
					onClick: () => d(!E, "welcomeMessageEnabled"),
					label: G.fbt._("Send welcome message to new members", null, {
						hk: "4euZSE"
					}),
					subtext: i.a.createElement("span", null, G.fbt._("Create a custom welcome message to greet people the instant they join your community. New community members will see this in a direct message 1 hour after joining.", null, {
						hk: "1D5tM8"
					}), " ", i.a.createElement(X.a, {
						className: je.a.welcomeMessageHelpLink,
						href: "https://mods.reddithelp.com/hc/en-us/articles/360002551551-Welcoming-new-members",
						rel: "noopener noreferrer",
						target: "_blank"
					}, G.fbt._("Learn more.", null, {
						hk: "NkFhF"
					})))
				}), E && i.a.createElement(i.a.Fragment, null, i.a.createElement(Y.h, {
					actionLink: i.a.createElement(S.t, {
						priority: S.c.PlainLink,
						className: Object(H.a)(je.a.previewButton, {
							[je.a.disabled]: w
						}),
						disabled: !y || 0 === (null == y ? void 0 : y.length),
						onClick: () => a(o, y)
					}, G.fbt._("Send me a test message", null, {
						hk: "4iE1go"
					})),
					label: null,
					onChange: e => {
						d(e.currentTarget.value, "welcomeMessageText")
					},
					onFocus: u,
					placeholder: G.fbt._("Welcome to our community! We’re here to discuss our passion for all things related to grated cheese. (Heads up—we’re a text-only community, so sorry no image posts.) Get started by introducing yourself in our post for newbies, then check out our rules to learn more and dive in.", null, {
						hk: "AnOYs"
					}),
					maxChars: te.f,
					rows: 5,
					value: y || ""
				})), i.a.createElement(ke, {
					subredditId: r,
					update: d,
					initialPlace: l,
					initialSubredditCountrySite: m,
					subredditCountryEditEnabled: !!p,
					subredditLanguageEditEnabled: !!b
				}), i.a.createElement(Q.a, null, G.fbt._("community type", null, {
					hk: "3T2OkK"
				})), i.a.createElement(Y.l, {
					label: G.fbt._("Type of Community", null, {
						hk: "2PReGw"
					}),
					direction: "column"
				}, i.a.createElement(Z.a, {
					value: x,
					name: "type",
					onChange: e => d(e, "subredditType")
				}, Object(J.radioOptions)(t, n))), i.a.createElement(Y.p, {
					on: h,
					onClick: () => d(!h, "over18"),
					label: i.a.createElement("span", null, G.fbt._("18+ year old community", null, {
						hk: "3VzYZp"
					}), i.a.createElement(Y.m, {
						flair: $.f.Nsfw
					})),
					subtext: G.fbt._("When your community is marked as an 18+ community, users must be flagged as 18+ in their user settings", null, {
						hk: "2h28m0"
					})
				}), "restricted" === x && i.a.createElement(i.a.Fragment, null, i.a.createElement(Q.a, null, G.fbt._("Restricted Community Settings", null, {
					hk: "1HiDiC"
				})), i.a.createElement(Y.d, {
					label: G.fbt._("Approved users have the ability to", null, {
						hk: "2pduhW"
					}),
					items: I,
					selected: (() => {
						let e = ee.e.Post;
						return g && v ? e = ee.e.PostAndComment : g && (e = ee.e.Comment), Ie[e].short()
					})(),
					onClick: e => {
						e === Ie[ee.e.PostAndComment].short() ? (d(!0, ee.f.Comment), d(!0, ee.f.Post)) : e === Ie[ee.e.Comment].short() ? (d(!1, ee.f.Post), d(!0, ee.f.Comment)) : e === Ie[ee.e.Post].short() && (d(!0, ee.f.Post), d(!1, ee.f.Comment))
					},
					id: "restrictionOptions",
					descriptions: j
				}), i.a.createElement(Y.p, {
					on: !f,
					onClick: () => d(!f, "disableContributorRequests"),
					label: G.fbt._("Accepting new requests to post", null, {
						hk: "bTpYB"
					})
				})), "private" === x && i.a.createElement(i.a.Fragment, null, i.a.createElement(Q.a, null, G.fbt._("Private Community Settings", null, {
					hk: "2JjNXE"
				})), i.a.createElement(Y.p, {
					on: !f,
					onClick: () => d(!f, "disableContributorRequests"),
					label: G.fbt._("Accepting requests to join", null, {
						hk: "1l1acS"
					}),
					subtext: G.fbt._("Display a button on your private subreddit that allows users to request to join. Users may still send your subreddit modmail whether this is on or off.", null, {
						hk: "1bkLxN"
					})
				})), i.a.createElement(Q.a, null, G.fbt._("Advanced Settings", null, {
					hk: "1e5Esr"
				})), i.a.createElement(Y.g, {
					label: G.fbt._("Settings for old site", null, {
						hk: "4wmYj3"
					}),
					subtext: G.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "gYPuP"
					}),
					link: `${q.a.oldRedditUrl}/r/${o}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.nc.Posts)),
					openInNewTab: !0,
					last: !0
				})))
			}
			var we = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				Te = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				Ne = n.n(Te),
				Pe = n("./src/reddit/components/ContentSurvey/RatingCard.tsx"),
				Re = n("./src/reddit/components/ContentSurvey/SurveyModal.tsx"),
				Ae = n("./src/reddit/helpers/trackers/contentTag.ts"),
				Me = n("./src/reddit/hooks/useTracking.ts");
			const {
				fbt: Le
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function De(e) {
				const {
					subreddit: t
				} = e, n = Object(a.e)(e => e.subreddits.survey[t.id]), s = Object(Me.a)();
				Object(o.useEffect)(() => s(Object(Ae.k)()), [s]);
				const [r, d] = Object(o.useState)(!1);

				function c() {
					s(Object(Ae.o)()), d(!0)
				}
				const l = !(null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible),
					u = (null == n ? void 0 : n.response) && (null == n ? void 0 : n.isEligible);
				return i.a.createElement("div", {
					className: Object(H.a)(Ne.a.ContentContainer, je.a.contentTag)
				}, i.a.createElement("h2", null, Le._("Content Tag", null, {
					hk: "1AhgrD"
				})), i.a.createElement("p", null, Le._("Your content tag is based on a moderator survey about community posts and discussions. {=Learn More}", [Le._param("=Learn More", i.a.createElement("a", {
					href: "https://www.reddithelp.com/hc/en-us/articles/360048185132",
					target: "_blank",
					rel: "noopener noreferrer",
					onClick: () => s(Object(Ae.d)())
				}, Le._("Learn More", null, {
					hk: "2gJ4PL"
				})))], {
					hk: "2xoqeD"
				})), i.a.createElement("div", {
					className: je.a.contentTagColumn
				}, i.a.createElement(Pe.a, {
					subredditId: t.id,
					ratingResponse: null == n ? void 0 : n.response
				}, (null == n ? void 0 : n.response) ? i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: je.a.ratingAudience
				}, Le._("Tagged as {ratingName} due to:", [Le._param("ratingName", n.response.rating.name)], {
					hk: "3VVnt5"
				})), i.a.createElement("ul", null, n.response.ratingReasons.map(e => i.a.createElement("li", {
					key: e.id,
					className: je.a.ratingReason
				}, e.contentRatingReasonText)))) : i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: je.a.ratingAudience
				}, Le._("Set up your tag", null, {
					hk: "2Fb5bg"
				})), i.a.createElement("p", {
					className: je.a.ratingDescription
				}, Le._("Take a quick survey to help people know what to expect when they visit this community", null, {
					hk: "VvmPr"
				})))), l && i.a.createElement(S.t, {
					redditStyle: !0,
					className: je.a.surveyButton,
					onClick: c
				}, Le._("Start Survey", null, {
					hk: "myDPK"
				})), u && i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					className: je.a.promptText
				}, Le._("Does this content tag look wrong to you?", null, {
					hk: "72VuM"
				})), i.a.createElement(S.t, {
					priority: S.c.Secondary,
					redditStyle: !0,
					className: je.a.surveyButton,
					onClick: c
				}, Le._("Take the Survey", null, {
					hk: "W30wE"
				})), i.a.createElement(we.a, {
					to: "/r/modsupport/submit"
				}, i.a.createElement(S.t, {
					priority: S.c.Tertiary,
					redditStyle: !0,
					className: je.a.surveyButton,
					onClick: () => s(Object(Ae.f)())
				}, "Message r/modsupport")))), r && n && i.a.createElement(Re.a, {
					withOverlay: !0,
					subredditId: t.id,
					survey: n,
					onClose: () => d(!1)
				}))
			}
			var Fe = n("./src/reddit/constants/experiments.ts"),
				Ue = n("./src/reddit/hooks/useExperimentVariant.ts"),
				Be = n("./src/reddit/selectors/communitySettings.ts"),
				qe = n("./src/reddit/selectors/experiments/chat.ts"),
				Ge = n("./src/reddit/selectors/experiments/imageComment.ts"),
				He = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				We = n("./src/redditGQL/types.ts");

			function Ve(e, t) {
				const n = (null == t ? void 0 : t.allowedMediaTypes) || [],
					s = n.includes(e) ? n.filter(t => t !== e) : [...n, e];
				return {
					...t,
					allowedMediaTypes: s
				}
			}
			var ze = e => {
					const {
						settings: t,
						subredditName: n,
						update: s,
						isChatPostsCreationEnabled: r,
						subredditId: d
					} = e, {
						archivePostsEnabled: l,
						allowChatPostCreation: u,
						allowGalleries: m,
						allowImages: p,
						allowPolls: b,
						allowPostCrossposts: f,
						allowPredictionsTournament: h,
						commentContributionSettings: _,
						collapseDeletedComments: g,
						commentScoreHideMins: v,
						contentOptions: x,
						spamComments: O,
						spamLinks: E,
						spamSelfposts: j,
						spoilersEnabled: I,
						suggestedCommentSort: S
					} = t, w = Object(a.e)(He.b), N = Object(a.e)(Ge.c), P = Object(a.e)(Ge.a), R = Object(a.e)(e => Object(Be.a)(e, d)), A = Object(a.e)(qe.h), M = Object(Ue.a)(Fe.Ef) === Fe.Kd, L = w && R, D = (null == _ ? void 0 : _.allowedMediaTypes) || [], F = null === S ? "nullValue" : S, U = Object(o.useCallback)(() => s(!l, "archivePostsEnabled"), [l, s]), B = e => e.toUpperCase() === We.P.All, H = e => {
						const n = B(t[e]) ? We.P.Low : We.P.All;
						s(n, e)
					};
					return i.a.createElement(k.a, null, i.a.createElement(C, null, i.a.createElement(k.b, null, G.fbt._("Post and Comment settings", null, {
						hk: "14OI7p"
					})), i.a.createElement(Q.a, null, G.fbt._("Posts", null, {
						hk: "2i2G4r"
					})), i.a.createElement(Y.d, {
						label: G.fbt._("Post type options", null, {
							hk: "M9AdT"
						}),
						items: Object.keys(te.i),
						displayItems: Object.values(te.i),
						displayTitle: te.i[x],
						selected: x,
						onClick: e => s(e, "contentOptions"),
						id: "contentOptions",
						descriptions: te.h
					}), i.a.createElement(Y.p, {
						on: f,
						onClick: () => s(!f, "allowPostCrossposts"),
						label: G.fbt._("Allow crossposting of posts.", null, {
							hk: "19EiBT"
						})
					}), i.a.createElement(Y.p, {
						on: l,
						onClick: U,
						label: G.fbt._("Archive posts", null, {
							hk: "3FdbDg"
						}),
						subtext: G.fbt._("Don’t allow commenting or voting on posts older than 6 months", null, {
							hk: "4tIS0"
						})
					}), r && A && i.a.createElement(Y.d, {
						label: G.fbt._("Live Chat Creators", null, {
							hk: "2Yd8cb"
						}),
						selected: u ? te.a.anyone : te.a.mods,
						items: Object.values(te.a),
						onClick: e => s(e === te.a.anyone, "allowChatPostCreation"),
						id: "chatPostOptions",
						subtext: G.fbt._("Choose who can start live chat posts in your community", null, {
							hk: "3F7D5k"
						})
					}), r && !A && i.a.createElement(Y.p, {
						on: u,
						onClick: () => s(!u, "allowChatPostCreation"),
						label: G.fbt._("Allow chat posts creation by users.", null, {
							hk: "4zwoUf"
						})
					}), i.a.createElement(Y.p, {
						on: I,
						onClick: () => s(!I, "spoilersEnabled"),
						label: i.a.createElement("span", null, G.fbt._("Enable spoiler tag", null, {
							hk: "2CtBpB"
						}), i.a.createElement(Y.m, {
							flair: $.f.Spoiler
						})),
						subtext: G.fbt._("Media on posts with the spoiler tag are blurred", null, {
							hk: "4rVOs6"
						})
					}), i.a.createElement(Y.p, {
						on: p,
						onClick: () => {
							s(!p, "allowImages"), s(!p, "allowGalleries")
						},
						label: G.fbt._("Allow image uploads and links to image hosting sites", null, {
							hk: "20ETVO"
						})
					}), p && i.a.createElement(Y.p, {
						"data-testid": "allow-images-community-setting",
						on: m,
						onClick: () => s(!m, "allowGalleries"),
						label: G.fbt._("Allow multiple images per post", null, {
							hk: "Pcjq5"
						})
					}), i.a.createElement(Y.p, {
						on: b,
						onClick: () => s(!b, "allowPolls"),
						label: G.fbt._("Allow polls", null, {
							hk: "15LXRO"
						})
					}), i.a.createElement(Y.p, {
						on: h,
						onClick: () => s(!h, "allowPredictionsTournament"),
						label: G.fbt._("Allow predictions", null, {
							hk: "rcdMx"
						}),
						subtext: G.fbt._("Allow predictions by mods in your community (only for public, SFW communities with 10k or more members)", null, {
							hk: "40loX3"
						})
					}), M ? i.a.createElement(i.a.Fragment, null, i.a.createElement(Y.l, {
						label: G.fbt._("Content filters", null, {
							hk: "ZAU2O"
						}),
						subtext: G.fbt._("The content types you select will be automaticaly added to your mod queue for you to approve or remove.", null, {
							hk: "1OW6Fg"
						})
					}), i.a.createElement(Y.p, {
						indent: !0,
						on: B(E),
						label: G.fbt._("Filter link, poll, and media posts", null, {
							hk: "2JjdGk"
						}),
						onClick: () => H("spamLinks")
					}), i.a.createElement(Y.p, {
						indent: !0,
						on: B(j),
						label: G.fbt._("Filter text posts", null, {
							hk: "3kvyDv"
						}),
						onClick: () => H("spamSelfposts")
					}), i.a.createElement(Y.p, {
						indent: !0,
						on: B(O),
						label: G.fbt._("Filter comments", null, {
							hk: "1llhZg"
						}),
						onClick: () => H("spamComments")
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(Y.l, {
						label: G.fbt._("Spam filter strength", null, {
							hk: "4C4qar"
						}),
						subtext: G.fbt._("'HIGH' is the standard filter, 'LOW' disables most filtering, 'ALL' will filter every post initially and they will need to be approved manually to be visible", null, {
							hk: "mdxeP"
						})
					}), i.a.createElement(Y.d, {
						label: G.fbt._("Posts", null, {
							hk: "1SdpTj"
						}),
						items: Object.keys(te.k),
						displayItems: Object.values(te.k),
						displayTitle: te.k[j],
						id: "spamSelfposts",
						selected: j.toUpperCase(),
						onClick: e => s(e, "spamSelfposts"),
						indent: !0
					}), i.a.createElement(Y.d, {
						label: G.fbt._("Links", null, {
							hk: "Ia7TU"
						}),
						items: Object.keys(te.k),
						displayItems: Object.values(te.k),
						displayTitle: te.k[E],
						id: "spamLinks",
						selected: E.toUpperCase(),
						onClick: e => s(e, "spamLinks"),
						indent: !0
					}), i.a.createElement(Y.d, {
						label: G.fbt._("Comments", null, {
							hk: "1X5Fv2"
						}),
						items: Object.keys(te.c),
						displayItems: Object.values(te.c),
						displayTitle: te.c[O],
						selected: O.toUpperCase(),
						onClick: e => s(e, "spamComments"),
						indent: !0,
						id: "spamComments"
					})), i.a.createElement(Q.a, null, G.fbt._("Comments", null, {
						hk: "4sAqsA"
					})), i.a.createElement(Y.d, {
						label: G.fbt._("Suggested sort", null, {
							hk: "4Af3Lr"
						}),
						subtext: G.fbt._("All comment feeds in community will default to this sort setting", null, {
							hk: "4grj1W"
						}),
						items: Object.keys(te.j),
						displayItems: Object.values(te.j),
						displayTitle: te.j[F],
						selected: F,
						onClick: e => s("nullValue" === e ? null : e, "suggestedCommentSort"),
						id: "suggestedCommentSort"
					}), i.a.createElement(Y.p, {
						on: g,
						onClick: () => s(!g, "collapseDeletedComments"),
						label: G.fbt._("Collapse deleted and removed comments", null, {
							hk: "Iw8kU"
						})
					}), i.a.createElement(Y.l, {
						label: G.fbt._("Minutes to hide comment scores", null, {
							hk: "1DJhj0"
						}),
						direction: "column"
					}, i.a.createElement(y, {
						onChange: e => s(e.currentTarget.value, "commentScoreHideMins"),
						isInvalid: !(v >= te.g && v <= te.b),
						min: te.g,
						max: te.b,
						type: "number",
						value: v
					})), L && i.a.createElement(i.a.Fragment, null, i.a.createElement(Y.l, {
						label: G.fbt._("Media in comments", null, {
							hk: "25YOda"
						})
					}), i.a.createElement(Y.p, {
						on: D.includes(We.f.Giphy),
						onClick: () => s(Ve(We.f.Giphy, _), "commentContributionSettings"),
						label: G.fbt._("GIFs from GIPHY", null, {
							hk: "1jwTaz"
						}),
						subtext: G.fbt._("Allow comments with GIFs from GIPHY.", null, {
							hk: "2Jqq8o"
						}),
						indent: !0
					}), N && i.a.createElement(Y.p, {
						on: D.includes(We.f.Static),
						onClick: () => s(Ve(We.f.Static, _), "commentContributionSettings"),
						label: G.fbt._("Images", null, {
							hk: "3Vrqqu"
						}),
						subtext: G.fbt._("Allow comments with uploaded images.", null, {
							hk: "4kSi3w"
						}),
						indent: !0
					}), P && i.a.createElement(Y.p, {
						on: D.includes(We.f.Animated),
						onClick: () => s(Ve(We.f.Animated, _), "commentContributionSettings"),
						label: G.fbt._("GIFs", null, {
							hk: "2vQkCj"
						}),
						subtext: G.fbt._("Allow comments with uploaded GIFs.", null, {
							hk: "2FQ8lo"
						}),
						indent: !0
					})), i.a.createElement(Q.a, null, G.fbt._("Advanced Settings", null, {
						hk: "53xlS"
					})), i.a.createElement(Y.g, {
						label: G.fbt._("Settings for old site", null, {
							hk: "2jzUi8"
						}),
						subtext: G.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
							hk: "4DHBV2"
						}),
						link: `${q.a.oldRedditUrl}/r/${n}/about/edit`,
						onClick: () => e.sendEvent(Object(T.d)(c.nc.Posts)),
						openInNewTab: !0,
						last: !0
					})))
				},
				Ke = n("./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx");
			const Qe = {
					0: {
						text: G.fbt._("Off", null, {
							hk: "30Jfc7"
						}),
						color: "#787C7E"
					},
					1: {
						text: G.fbt._("Lenient", null, {
							hk: "2TWZ21"
						}),
						color: "#46D160"
					},
					2: {
						text: G.fbt._("Moderate", null, {
							hk: "2s7qbB"
						}),
						color: "#FFB000"
					},
					3: {
						text: G.fbt._("Strict", null, {
							hk: "4s6ECM"
						}),
						color: "#EA0027"
					}
				},
				Ye = {
					0: G.fbt._("Use Crowd Control to automatically collapse comments from users you’re not sure about.", null, {
						hk: "n75Tc"
					}),
					1: G.fbt._("Comments from users who have negative karma in your community are automatically collapsed.", null, {
						hk: "37Keyu"
					}),
					2: G.fbt._("Comments from new users and users with negative karma in your community are automatically collapsed.", null, {
						hk: "v6NNK"
					}),
					3: G.fbt._("Comments from users who haven’t joined your community, new users, and users with negative karma in your community are automatically collapsed.", null, {
						hk: "4NqwJ"
					})
				},
				Je = {
					0: G.fbt._("Use Crowd Control to automatically filter posts from users you’re not sure about.", null, {
						hk: "RFsOk"
					}),
					1: G.fbt._("Posts from users who have negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "2cFJqC"
					}),
					2: G.fbt._("Posts from new users and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "1TwCdK"
					}),
					3: G.fbt._("Posts from users who haven’t joined your community, new users, and users with negative karma in your community are automatically held for review in mod queue.", null, {
						hk: "Syn69"
					})
				},
				Xe = {
					0: G.fbt._("No content posted from accounts suspected of ban evasion will automatically be held for review.", null, {
						hk: "ziWwq"
					}),
					1: G.fbt._("Content posted from accounts suspected of ban evasion within the past few weeks will automatically be held for review.", null, {
						hk: "2MWoA6"
					}),
					2: G.fbt._("Content posted from accounts suspected of ban evasion within the past few months will automatically be held for review.", null, {
						hk: "3YPzrf"
					}),
					3: G.fbt._("Content posted from accounts suspected of ban evasion will automatically be held for review.", null, {
						hk: "3CLgTG"
					})
				};

			function Ze(e) {
				const {
					banEvasionProtectionEnabled: t,
					isChatPostsCreationEnabled: n,
					isBroadcastingEnabled: s,
					settings: r,
					subredditName: o,
					subreddit: a,
					update: d
				} = e, {
					allowDiscovery: l,
					banEvasionThreshold: u,
					contentVisible: m,
					crowdControlFilter: p,
					crowdControlLevel: b,
					crowdControlChatLevel: f,
					crowdControlPostLevel: h,
					excludeBannedModqueue: _,
					toxicityThresholdChatLevel: g
				} = r, {
					showCrowdControlCampaign: v
				} = Object(Ke.b)(), x = Math.max(u - 1, 0), O = n || s;
				return i.a.createElement(k.a, null, i.a.createElement(C, null, i.a.createElement(k.b, {
					className: je.a.pageTitle
				}, G.fbt._("Safety & privacy settings", null, {
					hk: "34ghQV"
				})), i.a.createElement(Y.p, {
					on: _,
					onClick: () => d(!_, "excludeBannedModqueue"),
					label: G.fbt._("Exclude posts by site-wide banned users", null, {
						hk: "Kmfy0"
					}),
					subtext: G.fbt._("Posts are excluded from modqueue/unmoderated", null, {
						hk: "2P2pfc"
					})
				}), O && i.a.createElement(Y.p, {
					on: !!Number(g),
					onClick: () => {
						d(Number(g) ? "0" : "1", "toxicityThresholdChatLevel")
					},
					label: G.fbt._("Collapse Toxic Messages in Chat Post", null, {
						hk: "1Pk3G5"
					}),
					subtext: G.fbt._("Comments that our model scores as toxic will be automatically collapsed.", null, {
						hk: "Rohtu"
					})
				}), t && i.a.createElement(Y.j, {
					className: je.a.rangeSetting,
					ticks: Qe,
					min: 0,
					max: Object.keys(Qe).length - 1,
					step: 1,
					value: x,
					onChange: e => d((e => `${Math.min(parseInt(e,10)+1,4)}`)(e.target.value), "banEvasionThreshold"),
					label: G.fbt._("Ban Evasion Protection", null, {
						hk: "1TrdWv"
					}),
					subtext: Xe[x]
				}), i.a.createElement(Q.a, {
					className: je.a.sectionHeadingFollowedBySubtext
				}, G.fbt._("Crowd Control", null, {
					hk: "1HF3IV"
				})), i.a.createElement(Y.n, {
					className: je.a.sectionSubtext
				}, G.fbt._("Automatically collapse or filter content from people who aren't trusted users within your community yet.", null, {
					hk: "3U7kZS"
				})), i.a.createElement(Y.j, {
					className: je.a.rangeSetting,
					ticks: Qe,
					min: 0,
					max: Object.keys(Qe).length - 1,
					step: 1,
					value: b,
					onChange: e => d(e.target.value, "crowdControlLevel"),
					label: G.fbt._("Comments", null, {
						hk: "1vRuWQ"
					}),
					subtext: Ye[b]
				}), i.a.createElement(Y.p, {
					indent: !0,
					on: p,
					labelClassname: v ? je.a.labelWithNewTag : void 0,
					onClick: () => d(!p, "crowdControlFilter"),
					label: i.a.createElement(i.a.Fragment, null, G.fbt._("Hold Crowd Controlled comments for review", null, {
						hk: "43fG1u"
					}), v && i.a.createElement(re.a, {
						className: je.a.labelNewTag
					})),
					subtext: G.fbt._("Instead of collapsing crowd controlled comments will be held for review in mod queue.", null, {
						hk: "1QBJUP"
					})
				}), i.a.createElement(Y.j, {
					className: je.a.rangeSetting,
					ticks: Qe,
					min: 0,
					max: Object.keys(Qe).length - 1,
					step: 1,
					value: h,
					onChange: e => d(e.target.value, "crowdControlPostLevel"),
					labelClassname: v ? je.a.labelWithNewTag : void 0,
					label: i.a.createElement(i.a.Fragment, null, G.fbt._("Posts", null, {
						hk: "nW9yu"
					}), v && i.a.createElement(re.a, {
						className: je.a.labelNewTag
					})),
					subtext: Je[h]
				}), O && i.a.createElement(Y.j, {
					ticks: Qe,
					min: 0,
					max: Object.keys(Qe).length - 1,
					step: 1,
					value: f,
					onChange: e => d(e.target.value, "crowdControlChatLevel"),
					label: G.fbt._("Chat Posts", null, {
						hk: "eTeih"
					}),
					subtext: Ye[f]
				}), i.a.createElement(Q.a, {
					className: je.a.sectionHeadingFollowedBySubtext
				}, G.fbt._("Discover", null, {
					hk: "1I53SY"
				})), i.a.createElement(Y.n, {
					className: je.a.sectionSubtext
				}, G.fbt._("Show your community to the general Reddit population or just to people who have similar interests, by adjusting how people can find it. Not sure what's best for you? {=Learn More.}", [G.fbt._param("=Learn More.", i.a.createElement("a", {
					className: je.a.subtextLink,
					target: "_blank",
					rel: "noopener noreferrer",
					href: "https://mods.reddithelp.com/hc/en-us/sections/360000685771-General-Common-Questions"
				}, G.fbt._("Learn More.", null, {
					hk: "KAZVL"
				})))], {
					hk: "38WrgR"
				})), !a.isQuarantined && i.a.createElement(i.a.Fragment, null, i.a.createElement(Y.p, {
					on: m,
					onClick: () => d(!m, "contentVisible"),
					label: G.fbt._("Show up in high-traffic feeds", null, {
						hk: "3l7KBc"
					}),
					subtext: G.fbt._("Allow your community to be in r/all, r/popular, and trending lists where it can be seen by the general Reddit population.", null, {
						hk: "iH0lY"
					})
				}), i.a.createElement(Y.p, {
					on: l,
					onClick: () => d(!l, "allowDiscovery"),
					label: G.fbt._("Get recommended to individual redditors", null, {
						hk: "4wmaiH"
					}),
					subtext: G.fbt._("Let Reddit recommend your community to people who have similar interests.", null, {
						hk: "487MMM"
					})
				})), i.a.createElement(Q.a, null, G.fbt._("Advanced Settings", null, {
					hk: "3TL9Or"
				})), i.a.createElement(Y.g, {
					link: `${q.a.oldRedditUrl}/r/${o}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.nc.Safety)),
					openInNewTab: !0,
					last: !0,
					label: G.fbt._("Settings for old site", null, {
						hk: "1WHvCJ"
					}),
					subtext: G.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "2wPmwa"
					})
				})))
			}

			function $e(e) {
				const {
					settings: t,
					subredditName: n,
					update: s
				} = e, {
					wikiEditAge: r,
					wikiEditKarma: o,
					wikimode: a
				} = t;
				return i.a.createElement(k.a, null, i.a.createElement(C, null, i.a.createElement(k.b, null, G.fbt._("Wiki settings", null, {
					hk: "1gmluS"
				})), i.a.createElement(Q.a, null, G.fbt._("Community wiki pages", null, {
					hk: "1LwxaS"
				})), i.a.createElement(Y.d, {
					label: G.fbt._("Wikis can be edited by", null, {
						hk: "3brAqG"
					}),
					displayItems: Object.values(te.o),
					displayTitle: te.o[a],
					items: Object.keys(te.o),
					selected: a,
					onClick: e => s(e, "wikimode"),
					id: "wikimode",
					descriptions: te.n
				}), i.a.createElement(Y.l, {
					label: G.fbt._("Karma required to edit and create wiki pages", null, {
						hk: "3OgR7v"
					}),
					direction: "column"
				}, i.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditKarma"),
					isInvalid: !(o >= te.g && o <= te.m),
					min: te.g,
					max: te.m,
					type: "number",
					value: o
				})), i.a.createElement(Y.l, {
					label: G.fbt._("Age of Reddit account required to edit and create wiki pages", null, {
						hk: "3UE6cD"
					}),
					direction: "column"
				}, i.a.createElement(y, {
					onChange: e => s(e.currentTarget.value, "wikiEditAge"),
					isInvalid: !(r >= te.g && r <= te.l),
					min: te.g,
					max: te.l,
					type: "number",
					value: r
				})), i.a.createElement(Q.a, null, G.fbt._("Advanced Settings", null, {
					hk: "4drMhK"
				})), i.a.createElement(Y.g, {
					label: G.fbt._("Settings for old site", null, {
						hk: "2YU3sQ"
					}),
					subtext: G.fbt._("To change settings that influence the old site, you must go to the old settings page", null, {
						hk: "1ihkVe"
					}),
					link: `${q.a.oldRedditUrl}/r/${n}/about/edit`,
					onClick: () => e.sendEvent(Object(T.d)(c.nc.Wikis)),
					openInNewTab: !0,
					last: !0
				})))
			}
			const {
				fbt: et
			} = n("./node_modules/fbt/lib/FbtPublic.js"), tt = Object(d.c)({
				allowChatPostCreation: (e, t) => Object(R.b)(e, t.subredditId),
				banEvasionProtectionEnabled: w.d.banEvasionProtectionEnabled,
				isBroadcastingEnabled: (e, t) => Object(A.c)(e, t.subredditId),
				isChatPostsCreationEnabled: (e, t) => Object(R.c)(e, t.subredditId),
				isEmployee: F.O,
				notificationSettings: L.b,
				restrictions: M.q,
				settings: (e, t) => Object(M.ab)(e, t.subredditId),
				subreddit: M.Y,
				selectedPrimaryTag: D.s,
				hasSecondaryTags: D.m,
				geoPlace: (e, t) => e.tags.models.geoPlaces[t.subredditId],
				subredditCountrySite: (e, t) => ((e, t) => e.subreddits.countrySiteSettings[t])(e, t.subredditId),
				subredditCountryEditEnabled: (e, t) => Object(B.g)(e),
				subredditLanguageEditEnabled: (e, t) => Object(B.h)(e)
			}), nt = Object(a.b)(tt, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					onViewPageEvent: () => e(Object(l.a)()),
					testWelcomeMessage: (t, n) => e(Object(u.i)(t, n)),
					save: (t, n) => e(Object(u.j)(n, t, void 0)),
					saveCommunityTopics: t => e(Object(g.e)(t, N.a.communitySettings)),
					onPrimarySelect: t => e(Object(g.f)({
						primaryTagId: t,
						subredditId: n
					})),
					savePrimaryTopic: t => {
						t && e(Object(g.o)(n, {
							tagId: t.id,
							state: P.d.TAGGED
						}, !1))
					},
					updateSubredditWelcomeMessage: (t, n, s) => e(h(t, n, s)),
					saveSubredditCountrysite: (t, n) => {
						if (n) return e(Object(U.e)(t, n))
					}
				}
			});
			class st extends i.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.saveSettings = () => {
						var e, t, n, s;
						this.props.save(this.state.changed, this.props.subredditId);
						const o = this.props.subredditCountryEditEnabled,
							i = this.props.subredditLanguageEditEnabled;
						(o || i) && this.props.subpageName === c.nc.Community && (this.props.saveSubredditCountrysite(this.props.subredditId, this.props.subredditCountrySite), o && this.props.sendEvent(Object(T.c)("country", null === (e = this.props.subredditCountrySite) || void 0 === e ? void 0 : e.countryCode, null === (t = this.state.subredditCountrySite) || void 0 === t ? void 0 : t.countryCode)), i && this.props.sendEvent(Object(T.c)("language", null === (n = this.props.subredditCountrySite) || void 0 === n ? void 0 : n.languageCode, null === (s = this.state.subredditCountrySite) || void 0 === s ? void 0 : s.languageCode)), this.props.subredditCountrySite && !r()(this.state.subredditCountrySite, this.props.subredditCountrySite) && this.setState({
							subredditCountrySite: this.props.subredditCountrySite
						})), this.props.saveCommunityTopics(this.props.subredditId), this.props.savePrimaryTopic(this.props.selectedPrimaryTag);
						for (const r in this.state.changed) this.props.sendEvent(Object(T.e)(r, this.state.changed[r], this.props.settings[r]));
						this.setState({
							settings: this.state.settings,
							changed: {}
						})
					}, this.update = function(e, n) {
						let s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						s && t.props.sendEvent(Object(T.f)(n, e, t.state.settings[n])), t.setState(t => ({
							changed: {
								...t.changed,
								[n]: e
							},
							settings: {
								...t.settings,
								[n]: e
							}
						}))
					}, this.onFocusWelcomeMessageInput = () => this.props.sendEvent(Object(T.g)("click", "welcome_message_edit")), this.renderSubpage = () => {
						const e = {
							...this.props,
							settings: this.state.settings,
							update: this.update,
							onFocusWelcomeMessageInput: this.onFocusWelcomeMessageInput
						};
						if (!this.state.settings) return null;
						switch (this.props.subpageName) {
							case c.nc.Safety:
								return i.a.createElement(Ze, e);
							case c.nc.Notifications:
								return i.a.createElement(k.a, null, i.a.createElement(C, null, i.a.createElement(j.a, {
									subredditId: e.subredditId,
									subredditName: e.subredditName
								})));
							case c.nc.Posts:
								return i.a.createElement(ze, e);
							case c.nc.Wikis:
								return i.a.createElement($e, e);
							case c.nc.ContentTag:
								return i.a.createElement(De, {
									subreddit: e.subreddit
								});
							default:
								return i.a.createElement(Se, e)
						}
					}, this.state = {
						settings: e.settings,
						changed: {},
						subredditCountrySite: e.subredditCountrySite
					}
				}
				componentDidMount() {
					this.props.onViewPageEvent()
				}
				componentDidUpdate(e) {
					!this.props.settings || r()(e.settings, this.props.settings) || r()(this.state.settings, this.props.settings) || this.setState({
						settings: this.props.settings
					}), !this.props.subredditCountrySite || this.state.subredditCountrySite || r()(this.state.subredditCountrySite, this.props.subredditCountrySite) || this.setState({
						subredditCountrySite: this.props.subredditCountrySite
					})
				}
				render() {
					return i.a.createElement(i.a.Fragment, null, this.props.subpageName !== c.nc.ContentTag && i.a.createElement(k.c, null, i.a.createElement(S.l, {
						onClick: this.saveSettings,
						"data-redditstyle": !0
					}, et._("Save changes", null, {
						hk: "8mSp0"
					}))), this.renderSubpage())
				}
			}
			t.a = nt(Object(I.c)(st))
		},
		"./src/reddit/components/CommunityTopics/NumTopicsSelected.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/models/Tags/index.ts"),
				d = n("./src/reddit/selectors/tags.ts");
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = Object(i.c)({
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(d.r)(e, {
						subredditId: n
					})
				}
			});
			t.a = Object(o.b)(l)(e => r.a.createElement(r.a.Fragment, null, e.selectedOptions.length, "/", a.a))
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less": function(e, t, n) {
			e.exports = {
				menuItemsWrapper: "_1OISxDncG3tn4CibwqeC4e",
				tooltip: "UNHdPZIwwyCehEV-NfEY7"
			}
		},
		"./src/reddit/components/CommunityTopics/PrimaryTopic/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return R
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/ContentTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/helpers/localStorage/index.ts"),
				b = n("./src/reddit/helpers/trackers/inlineSubredditEditing.ts"),
				f = n("./src/reddit/components/InlineSubredditEditing/index.m.less"),
				h = n.n(f);
			const {
				fbt: _
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class g extends o.a.Component {
				componentDidMount() {
					this.props.sendEvent(b.e), this.props.onViewTooltip()
				}
				render() {
					const {
						translatedTitle: e,
						translatedDesc: t,
						translatedButtonText: n
					} = this.props;
					return o.a.createElement("div", {
						className: h.a.tooltipContent,
						onClick: e => {
							e.preventDefault(), e.stopPropagation()
						}
					}, o.a.createElement("span", {
						className: h.a.topRow
					}, o.a.createElement("h3", {
						className: h.a.title
					}, e)), o.a.createElement("p", {
						className: h.a.tooltipBody
					}, t), o.a.createElement(m.l, {
						className: h.a.gotIt,
						onClick: this.props.onDismissTooltip
					}, n || _._("Got it", null, {
						hk: "4CoCjQ"
					})))
				}
			}
			var v = Object(i.b)(void 0, e => ({
				onDismissTooltip: () => {
					e(Object(c.i)()), Object(p.Db)()
				},
				onViewTooltip: () => {
					Object(p.fc)()
				}
			}))(Object(u.c)(g));
			const x = "editable-primary-topic-idcard";
			var O = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				E = n("./src/reddit/models/Tags/index.ts"),
				y = n("./src/reddit/selectors/tags.ts"),
				C = n("./src/reddit/components/CommunityTopics/PrimaryTopic/index.m.less"),
				j = n.n(C);
			const k = e => {
					let {
						hasPrimaryTag: t,
						hasSecondaryTags: n
					} = e;
					if (t) return null;
					let r = s.fbt._("Add Community Topics", null, {
							hk: "2wd4kg"
						}),
						i = s.fbt._("Tell us what topics are relevant to your community so we can surface it to the right users", null, {
							hk: "24NCiQ"
						});
					return n && (r = s.fbt._("Add a Primary Topic", null, {
						hk: "41x5Gv"
					}), i = s.fbt._("Oops we don’t have a primary topic yet. Add one so we can surface your community to the right users", null, {
						hk: "XayPA"
					})), o.a.createElement(l.a, {
						className: j.a.tooltip,
						tooltipId: x,
						defaultTooltipPosition: "left",
						tooltipSizeEstimate: {
							height: 150,
							width: 320
						}
					}, o.a.createElement(v, {
						translatedTitle: r,
						translatedDesc: i
					}))
				},
				I = {
					availablePrimaryTags: y.p
				},
				S = Object(a.c)({
					...I,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(y.s)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(y.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: y.D
				}),
				w = Object(a.c)({
					...I,
					selectedPrimaryTag: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n && Object(y.x)(e, {
							subredditId: n
						}) || null
					},
					hasSecondaryTags: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object.keys(Object(y.o)(e, {
							itemId: n
						})).length > 0
					},
					isSaving: y.D
				}),
				T = Object(a.c)({
					...I,
					selectedPrimaryTag: y.v,
					hasSecondaryTags: () => !1,
					isSaving: e => Object(y.D)(e)
				}),
				N = (e, t) => {
					let {
						subredditId: n,
						onPrimarySelect: s
					} = t;
					return {
						onPrimaryTopicSelected: t => {
							t.isSelected || !s ? t.isSelected || (e(Object(d.f)({
								primaryTagId: t.value,
								subredditId: n
							})), e(Object(d.o)(n, {
								tagId: t.value,
								state: E.d.TAGGED
							}))) : s(t.value)
						},
						onShowTooltip: () => {
							e(Object(c.f)({
								tooltipId: x
							}))
						}
					}
				};
			class P extends o.a.Component {
				constructor(e) {
					super(e), this.state = {
						tooltipDismissed: !0
					}
				}
				componentDidMount() {
					const e = this.props.onShowTooltip;
					this.setState({
						tooltipDismissed: Object(p.s)()
					}, () => {
						this.isTooltipEnabled() && e && e()
					})
				}
				isTooltipEnabled() {
					const {
						shouldShowTooltip: e = !1,
						selectedPrimaryTag: t
					} = this.props;
					return !this.state.tooltipDismissed && !t && e
				}
				render() {
					const {
						availablePrimaryTags: e,
						className: t,
						hasSecondaryTags: n,
						isSaving: r,
						onPrimaryTopicSelected: i,
						selectedPrimaryTag: a
					} = this.props, d = a && a.text;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(O.b, {
						id: this.isTooltipEnabled() ? x : void 0,
						className: t,
						isTopicsStyle: !0,
						displayText: d || s.fbt._("Add a Primary Topic", null, {
							hk: "1HgVte"
						}),
						options: e.map(e => ({
							displayText: e.text,
							value: e.id,
							isSelected: !!a && a.id === e.id
						})),
						onSelect: i,
						menuItemsClassName: j.a.menuItemsWrapper,
						showSelectedCheckmark: !0,
						isSaving: r
					}), this.isTooltipEnabled() && o.a.createElement(k, {
						hasPrimaryTag: !!a,
						hasSecondaryTags: n
					}))
				}
			}
			Object(i.b)(T, e => ({
				onPrimaryTopicSelected: t => {
					e(Object(d.a)({
						primaryTagId: t.value
					}))
				}
			}))(P);
			const R = Object(i.b)(w, N)(P),
				A = Object(i.b)(S, N);
			t.b = A(P)
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less": function(e, t, n) {
			e.exports = {
				suggestedTopicsContainer: "_3qCTJNZ-iSCZa0wyVfs6my",
				relatedText: "_389N9jvZJu60U3E7vIF00n",
				closeIcon: "M40GQ3RaivlkCl8WQ-pXo",
				plusIcon: "_2OYvdU1reofcbKMJ0wvC_x",
				suggestedTopic: "_1RmiLhJpOUx_hgduPf3F5O",
				closeIconContainer: "sHLJV3zATRod0k1f_m71I",
				suggestedTopicText: "_1-rmQV4Wee08Dt-h2GyW-o"
			}
		},
		"./src/reddit/components/CommunityTopics/SuggestedTopics/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tags/index.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/icons/svgs/Close/index.tsx"),
				m = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				p = n("./src/reddit/components/CommunityTopics/SuggestedTopics/index.m.less"),
				b = n.n(p);
			var f = e => o.a.createElement("span", {
					className: b.a.suggestedTopic,
					onClick: () => e.onSuggestedTopicSelected(e.suggestedTopic)
				}, o.a.createElement(m.a, {
					className: b.a.plusIcon
				}), o.a.createElement("span", {
					className: b.a.suggestedTopicText
				}, e.suggestedTopic.displayText), o.a.createElement("span", {
					className: b.a.closeIconContainer,
					onClick: t => {
						t.preventDefault(), t.stopPropagation(), e.onSuggestedTopicDismissed(e.suggestedTopic)
					}
				}, o.a.createElement(u.a, {
					className: b.a.closeIcon
				}))),
				h = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				_ = n("./src/reddit/models/Tags/index.ts"),
				g = n("./src/reddit/models/Toast/index.ts"),
				v = n("./src/reddit/selectors/tags.ts");
			const x = Object(a.c)({
					suggestedOptions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(v.y)(e, {
								itemId: n
							}),
							r = Object(v.r)(e, {
								subredditId: n
							}),
							o = Object(v.w)(e, {
								subredditId: n
							});
						return s.filter(e => !!e.id && o !== e.id && !r.find(t => !!t.id && t.id === e.id))
					}
				}),
				O = Object(i.b)(x, (e, t) => {
					let {
						subredditId: n,
						onOptionSelected: r,
						context: o
					} = t;
					return {
						onSuggestedOptionDismissed: t => {
							e(Object(c.n)(n, [], [{
								subredditId: n,
								tagId: t.id,
								isRelevant: !1
							}], o, !0))
						},
						onSuggestedOptionSelected: t => {
							e((e, i) => {
								const a = i();
								Object(v.r)(a, {
									subredditId: n
								}).length >= _.a ? e(Object(l.f)({
									...Object(l.e)(s.fbt._("You can only add up to {max number of topics} community topics", [s.fbt._param("max number of topics", _.a.toString())], {
										hk: "1OySAh"
									}), g.b.Error),
									duration: l.a
								})) : (e(Object(c.j)({
									subredditId: n,
									option: t
								})), Object(h.c)(i(), n, t, {
									context: o
								}), r && r(t))
							})
						}
					}
				});
			t.a = O(e => e.suggestedOptions.length ? o.a.createElement("div", {
				className: Object(d.a)(b.a.suggestedTopicsContainer, e.className)
			}, e.children || o.a.createElement("span", {
				className: b.a.relatedText
			}, s.fbt._("Related:", null, {
				hk: "1qt7CO"
			})), e.suggestedOptions.map(t => o.a.createElement(f, {
				key: t.id,
				suggestedTopic: t,
				onSuggestedTopicSelected: e.onSuggestedOptionSelected,
				onSuggestedTopicDismissed: e.onSuggestedOptionDismissed
			}))) : null)
		},
		"./src/reddit/components/CommunityTopics/index.m.less": function(e, t, n) {
			e.exports = {
				communityTopicsContainer: "wsNyCIZw7veQPURlfXwXb"
			}
		},
		"./src/reddit/components/CommunityTopics/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/tags/index.ts"),
				c = n("./src/reddit/actions/toaster.ts"),
				l = n("./src/reddit/components/MultiOptionSelect/index.tsx"),
				u = n("./src/reddit/helpers/trackers/communityTopics.ts"),
				m = n("./src/reddit/models/Tags/index.ts"),
				p = n("./src/reddit/models/Toast/index.ts"),
				b = n("./src/reddit/selectors/tags.ts"),
				f = n("./src/reddit/components/CommunityTopics/index.m.less"),
				h = n.n(f);
			const _ = Object(a.c)({
				availableSubredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.d)(e, {
						subredditId: n
					})
				},
				subredditTags: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.o)(e, {
						itemId: n
					})
				},
				availableGlobalOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.a)(e, {
						thingId: n
					})
				},
				selectedOptions: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.r)(e, {
						subredditId: n
					})
				},
				isLoading: e => Object(b.B)(e),
				currentInput: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(b.i)(e, {
						subredditId: n
					})
				}
			});
			class g extends o.a.Component {
				constructor() {
					super(...arguments), this.onOptionsChanged = e => {
						const t = e.filter(e => e.selected),
							n = e.filter(e => !e.selected);
						this.onOptionsSelected(t), n.forEach(e => this.onOptionDeselected(e))
					}, this.onFocus = () => {
						this.props.onSearchBarFocused(), this.props.onFocus && this.props.onFocus()
					}
				}
				onOptionsSelected(e) {
					const t = m.a - this.props.selectedOptions.length,
						n = e.filter(e => !!e.displayText.trim()),
						s = n.slice(0, t);
					s.forEach(e => {
						if (!e.id) {
							const t = Object(b.c)(e.displayText, this.props.availableSubredditTags);
							t && (e = Object(m.f)(t, !0))
						}
						this.props.optionSelected({
							...e,
							displayText: e.displayText.trim()
						})
					}), s.length !== n.length && this.props.onMaxTopicsHit()
				}
				onOptionDeselected(e) {
					this.props.optionDeselected(e)
				}
				render() {
					return o.a.createElement("div", {
						className: h.a.communityTopicsContainer
					}, o.a.createElement(l.a, {
						readOnlyMode: this.props.readOnlyMode,
						addText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						allowFreeTextEntry: !0,
						availableOptions: this.props.availableGlobalOptions,
						childClassNames: this.props.childClassNames,
						dropdownHeaderText: s.fbt._("Suggested topics", null, {
							hk: "1RASWg"
						}),
						input: this.props.currentInput,
						isError: this.props.selectedOptions.length > m.a,
						isLoading: this.props.isLoading,
						maxOptionLength: m.b,
						maxOptionsToDisplay: this.props.maxTopicsToDisplay,
						onSearchBarFocus: this.onFocus,
						onSearchBarBlur: this.props.onBlur,
						onInputChanged: e => {
							this.props.onInputChanged(e)
						},
						onOptionsChanged: this.onOptionsChanged,
						selectedOptions: this.props.selectedOptions,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: !0
					}, this.props.children))
				}
			}
			t.b = Object(i.b)(_, (e, t) => {
				let {
					subredditId: n,
					context: r
				} = t;
				return {
					optionSelected: t => {
						e(Object(d.j)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.e(s(), n, t, {
								context: r
							})
						})
					},
					optionDeselected: t => {
						e(Object(d.i)({
							subredditId: n,
							option: t
						})), e((e, s) => {
							u.d(s(), n, t, {
								context: r
							})
						})
					},
					onInputChanged: t => e(Object(d.h)({
						subredditId: n,
						input: t
					})),
					onSearchBarFocused: () => e((e, t) => {
						u.b(t(), n, {
							context: r
						})
					}),
					onMaxTopicsHit: () => e((e, t) => {
						e(Object(c.f)({
							...Object(c.e)(s.fbt._({
								"*": "You can only add up to max {number} community topics",
								_1: "You can only add up to max 1 community topic"
							}, [s.fbt._plural(m.a, "number")], {
								hk: "s07I1"
							}), p.b.Error),
							duration: c.a
						}))
					})
				}
			})(g)
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				horizontalVotes: "_2oM1YqCxIwkvwyeZamWwhW",
				customScoreStyles: "_25IkBM0rRUqWX5ZojEMAFQ",
				customDownvoteStyles: "_783RL1AYIib59nxLCXhgv"
			}
		},
		"./src/reddit/components/CompactPost/HorizontalVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/components/CompactPost/HorizontalVotes/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(i.a)(e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement(a.a, l({}, n, {
					className: Object(o.a)(c.a.horizontalVotes, t),
					scoreClassName: Object(o.a)(c.a.customScoreStyles, n.scoreClassName),
					downvoteClassName: Object(a.b)(n) ? c.a.customDownvoteStyles : void 0
				}))
			});
			t.a = u
		},
		"./src/reddit/components/CompactPost/index.m.less": function(e, t, n) {
			e.exports = {
				hideAboveSmallTablet: "FX_aWE8xMirpzniJDh7I9",
				responsiveExpandoButton: "_3gazhzxd2iBGYb2k67_HTw",
				mHideAboveSmallTablets: "_2zV_ARVPrYN10xmbbb_4Lu",
				responsiveMeta: "_1xomvNxK4aHGoGa-YDw1Mc",
				verticalVotes: "WAapGmF_gr09J509Af-gC",
				commentsLink: "Nz0lkWnnj2V_4iBKE0WL7",
				hideBelowSmallTablet: "z_7pbLL4hZp6ikYkq0prE",
				horizontalVotes: "_37nbKm3ee5NGx6e-LXErLD",
				postTopMeta: "_1ghZRP5m5xDLh0up1rFt0e",
				mHideBelowSmallTablets: "_3x_hdVQw5uJh6xeAGoZock",
				adLinkWrapper: "_4Dt8djtbHlJ5uCZDX_SeV",
				ctaExperiment: "_3xMykgG1y_Ln8tQs4ciV4i",
				content: "_1B7SUGHK0QDoHimxX2a9D0",
				leftRail: "_2r9FABr2qYEUDyZoenhn6N",
				bulkActionCheckbox: "_44ehKZ_pl1NGGaaTYouZR",
				subredditIcon: "_1kWbgdOrvSeXIZZRIw4uBS",
				topLine: "_2ZjElFi3ORaU3VPrwmdoCp",
				postBadges: "_126a2ACB41algqMEwA34TF",
				flatList: "_3jwri54NGT-SRatPIZYiMo",
				expandedContentWrapper: "_12wy0ZFFaS3a49145uXWXt",
				crosspostMediaWrapper: "_2fCIreZsKBNS3esgsKKksM",
				compactWrapper: "YA9IzN0YR-G5_oD5EUydl",
				compactPostRow: "WnMeTcero48dKo501T-19",
				leftRailWrapper: "_3YgWdffoKyCp7UaGAEQpoo",
				proposalMetaData: "_1_B8IWlNlt5jJVg4cKy7nL",
				isEvent: "_1csviRG5jI9xOrcsmpbfwt",
				modToolsFlatlist: "_20p7Nh6bZU7MOqYuB2uJcy",
				postContainer: "_2bHVWuR_l_wVivC3FKfLFf",
				leftBorderWrapper: "_3ZmFVbkR23TIZ-3nboLYXe",
				modModeBannerWrapper: "_1_voPxd0-GKljAjvO7ZcgJ"
			}
		},
		"./src/reddit/components/CompactPost/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "renderSubredditIcon", (function() {
				return De
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/ads/index.ts"),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/lib/constants/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/postLayout.ts"),
				b = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				f = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				h = n("./src/reddit/helpers/trackers/post.ts"),
				_ = n("./src/reddit/models/Media/index.ts"),
				g = n("./src/reddit/models/Post/index.ts"),
				v = n("./src/reddit/models/User/index.ts"),
				x = n("./src/reddit/models/Vote/index.ts"),
				O = n("./src/reddit/actions/post.ts"),
				E = n("./src/reddit/actions/postFlair.ts"),
				y = n("./src/reddit/actions/tooltip.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/moderatorPermissions.ts"),
				k = n("./src/reddit/selectors/postFlair.ts"),
				I = n("./src/reddit/selectors/posts.ts"),
				S = n("./src/reddit/components/AdLinkWrapper/index.tsx"),
				w = n("./src/reddit/components/AdLinkWrapperContent/index.tsx"),
				T = n("./src/reddit/components/AwardBadges/index.tsx"),
				N = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				P = n("./src/reddit/components/CommentsLink/index.tsx"),
				R = n("./src/reddit/components/CompactPost/HorizontalVotes/index.tsx"),
				A = n("./src/reddit/components/EventPost/EventMetaHeader/index.tsx"),
				M = n("./src/reddit/components/ExpandoButton/index.tsx"),
				L = n("./src/reddit/components/Flatlist/index.tsx"),
				D = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				F = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				U = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				B = n("./src/reddit/components/ModModeFilteredReason/index.tsx"),
				q = n("./src/reddit/components/ModModeFilteredReason/helpers.ts"),
				G = n("./src/reddit/components/ModModeReports/index.tsx"),
				H = n("./src/reddit/components/ModModeReports/helpers.ts"),
				W = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				V = n("./src/reddit/components/OneFeed/PostRecommendationContext.tsx"),
				z = n("./src/reddit/components/PostBackgroundWrapper/index.tsx"),
				K = n("./src/reddit/components/PostBadges/index.tsx"),
				Q = n("./src/reddit/components/PostContainer/index.tsx"),
				Y = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				J = n("./src/reddit/components/PostLeftRail/index.tsx"),
				X = n("./src/reddit/components/PostMedia/index.tsx"),
				Z = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				$ = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				ee = n("./src/reddit/components/PostTitle/index.tsx"),
				te = n("./src/reddit/components/PostTopMeta/index.tsx"),
				ne = n("./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx"),
				se = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				re = n("./src/reddit/components/SponsoredLabel/index.tsx"),
				oe = n("./src/reddit/components/SubredditIcon/index.tsx"),
				ie = n("./src/reddit/components/VerticalVotes/index.tsx"),
				ae = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				de = n("./src/reddit/contexts/PageLayer/index.tsx"),
				ce = n("./src/reddit/contexts/Post/index.tsx"),
				le = n("./src/reddit/controls/Checkbox/index.tsx"),
				ue = n("./src/reddit/controls/MetaData/index.tsx"),
				me = n("./src/reddit/helpers/hasModFlairPermissions/index.ts"),
				pe = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				be = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				fe = n("./src/reddit/helpers/postEvent.ts"),
				he = n("./src/reddit/hooks/useIsOverlay.ts"),
				_e = n("./src/reddit/hooks/useTheme.ts"),
				ge = n("./src/reddit/hooks/useUserContext.ts"),
				ve = n("./src/reddit/icons/fonts/IgnoreReport/index.tsx"),
				xe = n("./src/reddit/icons/fonts/Report/index.tsx"),
				Oe = n("./src/reddit/selectors/experiments/web2x_cta.ts"),
				Ee = n("./src/reddit/selectors/showPromotedCTA.ts"),
				ye = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				Ce = n.n(ye),
				je = n("./src/reddit/selectors/experiments/chat.ts"),
				ke = n("./src/redditGQL/types.ts"),
				Ie = n("./src/reddit/components/LiveChatActiveUserCountWrapper/index.tsx"),
				Se = n("./src/reddit/components/CompactPost/index.m.less"),
				we = n.n(Se);

			function Te() {
				return (Te = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Ne = e => {
					let {
						isCompact: t,
						...n
					} = e;
					return o.a.createElement(M.a, Te({
						className: Object(l.a)(we.a.responsiveExpandoButton, {
							[we.a.mHideAboveSmallTablets]: !!t,
							[we.a.mHideBelowSmallTablets]: !t
						})
					}, n))
				},
				Pe = () => Object(d.c)({
					activeModalId: C.a,
					crosspost: I.d,
					flairStyleTemplate: de.Y,
					isActive: I.j,
					isExpanded: I.m,
					showPromotedCTA: Ee.a,
					layout: de.U,
					moderatorPermissions: j.m,
					poll: (e, t) => {
						const n = e.posts.metaMap[t.postId];
						if (n) return e.polls.models[n]
					},
					showEditFlair: k.a,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subreddit: n
						} = t;
						return !!n && Object(j.i)(e, n.id)
					},
					showCTAExperimentDesign: Oe.a,
					isLiveChatUserCountEnabled: je.e
				}),
				Re = (e, t) => {
					let {
						postId: n
					} = t;
					return {
						dispatchFlairChanged: t => {
							let {
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							} = t;
							return e(Object(E.h)({
								post: n,
								previewFlair: s,
								selectedTemplateId: r
							}))
						},
						handleVote: t => {
							const s = t === x.a.upvoted ? Object(O.jb)(n) : Object(O.v)(n);
							e(s)
						},
						onIgnoreReports: () => e(Object(O.fb)(n)),
						onOpenReportsDropdown: t => e(Object(y.h)({
							tooltipId: t
						}))
					}
				};
			class Ae extends o.a.Component {
				componentDidUpdate(e) {
					this.props.onSizeChanged && e.isExpanded !== this.props.isExpanded && this.props.onSizeChanged(this.props.post.id)
				}
				render() {
					const {
						activeModalId: e,
						className: t,
						currentProfileName: n,
						crosspost: s,
						currentUser: r,
						eventFactory: i,
						flairStyleTemplate: a,
						handleVote: d,
						imageGalleryCurrentItem: u,
						isCheckboxSelected: m = !1,
						isCommentsPage: x,
						isCommentPermalink: O,
						isExpanded: E,
						isGalleryTileLayoutDefault: y,
						isModWithUserNotesPermissions: C,
						isOverlay: j,
						isProfilePostListing: k,
						inSubredditOrProfile: I = !1,
						layout: M,
						moderatorPermissions: X,
						modModeEnabled: re,
						onClickPost: oe,
						onFlairChanged: de,
						onIgnoreReports: ce,
						poll: ue,
						post: he,
						subredditOrProfile: _e,
						userIsOp: ge,
						hideModTools: Oe,
						scrollerItemRef: Ee,
						showBulkActionCheckbox: ye,
						showEditFlair: je,
						toggleCheckbox: Se,
						tooltipType: Te,
						sendEvent: Pe,
						shouldShowGalleryTileOption: Re,
						showPromotedCTA: Ae,
						showCTAExperimentDesign: Le,
						isLiveChatUserCountEnabled: De
					} = this.props, Ue = !!he.media && he.media.type === _.o.RTJSON, Be = ge && Ue, qe = Object(Y.b)(he.id, j), Ge = Object(be.a)(X), He = Object(me.a)(X), We = Object(pe.a)(X), Ve = `-mod-actions-menu-${he.id}`, ze = `voting-arrows-${he.id}`, Ke = !!r && Object(v.e)(r) === he.author, Qe = Object(q.a)(he), Ye = Object(H.c)(he), Je = Object(D.a)("View--Reports", he.id, Te), Xe = Object(H.a)(he), Ze = !(j || x || O), $e = he.media && he.media.type === _.o.LIVEVIDEO, et = e => Pe(Object(h.k)(he.id, e)), tt = Object(c.t)(he, u), {
						source: nt
					} = tt, st = Object(g.s)(he), rt = o.a.createElement(Q.b, {
						className: Object(l.a)(Ce.a.compactPostStyles, we.a.postContainer, Object(f.a)(this.props), t),
						isOverlay: j,
						style: {
							...Object(f.d)(this.props),
							...Object(f.b)(this.props.flairStyleTemplate)
						},
						post: he,
						onClick: oe,
						eventFactory: i
					}, o.a.createElement("div", {
						className: we.a.compactWrapper
					}, o.a.createElement("div", {
						className: we.a.leftRailWrapper
					}, o.a.createElement("div", {
						className: we.a.leftRail,
						style: {
							borderColor: Object(J.c)({
								isRemoved: !!he.bannedBy,
								isReported: Object(b.a)(he),
								isSponsored: he.isSponsored,
								theme: this.props.theme
							})
						}
					}, ye && o.a.createElement(le.a, {
						className: we.a.bulkActionCheckbox,
						isCheckboxSelected: m,
						toggleCheckbox: Se
					}), o.a.createElement(ie.a, {
						className: we.a.verticalVotes,
						compact: !0,
						flairStyleTemplate: a,
						model: he,
						onVoteClick: d
					}), o.a.createElement(R.a, {
						className: we.a.horizontalVotes,
						compact: !1,
						flairStyleTemplate: a,
						model: he,
						onVoteClick: d,
						upvoteTooltipId: ze
					}))), o.a.createElement(z.a, {
						className: Object(l.a)(we.a.content, {
							[we.a.isEvent]: Object(fe.a)(he)
						}),
						"data-click-id": "background",
						flairStyleTemplate: a
					}, o.a.createElement(A.a, {
						isCompactMode: !0,
						post: he
					}), o.a.createElement("div", {
						className: we.a.compactPostRow
					}, !Oe && o.a.createElement(Ne, {
						crosspost: s,
						isCommentsPage: x,
						isCompact: !1,
						isExpanded: E,
						post: he,
						useMediaIcons: !0
					}), !I && !he.isSponsored && o.a.createElement(F.h, {
						type: he.belongsTo.type,
						id: he.belongsTo.id
					}), o.a.createElement("div", {
						className: we.a.topLine,
						"data-click-id": "body"
					}, st && o.a.createElement(V.a, {
						content: he.recommendationContext.content,
						layout: p.g.Compact,
						post: he
					}), o.a.createElement(ee.c, {
						post: he,
						poll: ue,
						size: ee.b.Small,
						titleColor: a && a.postTitleColor,
						isOverlay: !1
					}), Fe(he, _e), o.a.createElement(te.g, {
						className: we.a.postTopMeta,
						flairStyleTemplate: a,
						isModWithUserNotesPermissions: C,
						post: he,
						showSub: !!_e && !I && !he.isSponsored,
						subredditOrProfile: _e
					}), o.a.createElement(K.a, {
						className: we.a.postBadges,
						displayText: _e ? _e.displayText : null,
						inSubredditOrProfile: I,
						post: he
					}), o.a.createElement(T.a, {
						thing: he,
						tooltipType: j ? te.f.Lightbox : void 0
					}), he.discussionType === ke.m.Chat && o.a.createElement(Ie.a, {
						postId: he.id
					})), Ze && !$e && !De && o.a.createElement("div", null, o.a.createElement(N.a, {
						className: we.a.liveDiscussionIcon,
						postId: he.postId
					})), !he.isSurveyAd && o.a.createElement("div", {
						className: we.a.flatList
					}, o.a.createElement(P.a, {
						className: we.a.commentsLink,
						hasModPostPerms: Ge,
						isCommentsPage: x,
						isCommentPermalink: O,
						isOverlay: j,
						postId: he.id,
						modModeEnabled: re,
						numComments: he.numComments,
						type: p.g.Compact
					}), o.a.createElement(W.a, {
						className: we.a.modToolsFlatlist,
						isOverlay: !1,
						layout: M,
						modModeEnabled: re,
						post: he,
						sendEvent: Pe,
						showIconsOnly: !0
					}), Ge && o.a.createElement(U.a, {
						dropdownId: Ve,
						onClick: () => et("post_mod_action_menu")
					}, o.a.createElement(L.b, null), o.a.createElement(Z.a, {
						canEditFlair: He && je,
						hasModPostPerms: Ge,
						hasModFullPerms: We,
						isOverlay: !1,
						isPostAuthor: Ke,
						modModeEnabled: re,
						post: he,
						tooltipId: Ve
					})), Ge && Ye && !re && o.a.createElement(se.c, {
						text: `${Xe}`,
						onClick: () => {
							this.props.onOpenReportsDropdown(Je), et("post_report_menu")
						},
						id: Je
					}, o.a.createElement(ae.a, {
						model: he,
						onIgnoreReports: () => {
							ce(), et(he.ignoreReports ? "restore_reports" : "ignore_reports")
						},
						tooltipId: Je
					}), he.ignoreReports ? o.a.createElement(ve.a, null) : o.a.createElement(xe.a, null)), o.a.createElement($.a, {
						currentProfileName: n,
						isCommentsPage: x,
						isOverlay: !1,
						isProfilePostListing: k,
						isRecommendationPost: !!he.recommendationContext,
						layout: M,
						permalink: he.permalink,
						sendEvent: Pe,
						showEditPost: Be,
						showEditFlair: je,
						dropdownId: `${he.id}-overflow-menu`,
						useFlatlistBreakpoints: Object($.b)({
							share: !1,
							editPost: !1,
							save: !1,
							gild: !1,
							hide: !1,
							report: !1,
							mute: !1
						})
					}), !Oe && o.a.createElement(Ne, {
						crosspost: s,
						isCommentsPage: x,
						isCompact: !0,
						isExpanded: E,
						post: he,
						useMediaIcons: !0
					}))), Ae && nt && nt.url && !he.isSurveyAd && o.a.createElement(S.a, {
						className: Object(l.a)(we.a.adLinkWrapper, {
							[we.a.ctaExperiment]: Le
						}),
						ctaExperimentDesign: Le && "compact"
					}, o.a.createElement(w.a, {
						post: he,
						adLinkContent: tt,
						isCompact: !0,
						ctaExperimentDesign: Le && "compact"
					})), re && Ge && Qe && o.a.createElement("div", {
						className: we.a.modModeBannerWrapper
					}, o.a.createElement(B.a, {
						thing: he
					})), re && Ge && Ye && o.a.createElement("div", {
						className: we.a.modModeBannerWrapper
					}, o.a.createElement(G.a, {
						onIgnoreReports: ce,
						reportable: he
					})), o.a.createElement(F.d, null))), E && o.a.createElement(Me, {
						post: he,
						scrollerItemRef: Ee,
						flairStyleTemplate: a,
						shouldShowGalleryTileOption: Re,
						isGalleryTileLayoutDefault: y
					}), e === qe && o.a.createElement(Y.a, {
						flairs: he.flair,
						subredditId: he.belongsTo.id,
						modalId: qe,
						onFlairChanged: de
					}));
					return o.a.createElement(ne.b, null, rt)
				}
			}
			const Me = e => o.a.createElement(z.a, {
					className: Object(l.a)(e.className, we.a.expandedContentWrapper),
					flairStyleTemplate: e.flairStyleTemplate
				}, e.post.crosspostRootId ? o.a.createElement("div", {
					className: we.a.crosspostMediaWrapper
				}, Le(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)) : Le(e.post, e.scrollerItemRef, e.shouldShowGalleryTileOption, e.isGalleryTileLayoutDefault)),
				Le = (e, t, n, s) => o.a.createElement(X.a, {
					isExpando: !0,
					isGalleryTileLayoutDefault: s,
					isListing: !0,
					isNotCardView: !0,
					post: e,
					scrollerItemRef: t,
					shouldLoad: !0,
					shouldPause: !1,
					shouldShowGalleryTileOption: n,
					showCentered: !0,
					showFull: !0,
					showPromotedCTA: !0
				}),
				De = e => o.a.createElement(a.a, {
					"data-click-id": "subreddit",
					to: e.url
				}, o.a.createElement(oe.b, {
					className: we.a.subredditIcon,
					subredditOrProfile: e
				})),
				Fe = (e, t) => o.a.createElement("div", {
					className: we.a.responsiveMeta
				}, o.a.createElement(ue.b, {
					isScoreHidden: e.scoreHidden,
					score: e.score
				}), o.a.createElement(ue.c, null), Object(ue.d)(e.numComments), o.a.createElement(ue.c, null), t && o.a.createElement("a", {
					href: t.url
				}, o.a.createElement(ue.a, null, t.displayText)), e.isSponsored && [o.a.createElement(re.a, {
					key: "label",
					isSurveyAd: e.isSurveyAd
				}), o.a.createElement(ue.c, {
					key: "separator"
				})], !e.isSponsored && o.a.createElement(ue.a, null, " ", s.fbt._("Posted by", null, {
					hk: "UqFDR"
				}), " "), o.a.createElement(te.d, {
					post: e,
					isDeleted: e.author === u.H
				}));
			t.default = Object(ce.b)(o.a.memo((function(e) {
				const t = Object(ge.a)(),
					n = Object(r.useMemo)(() => Pe(), []),
					s = Object(i.e)(s => n(s, {
						...e,
						...t
					})),
					a = Object(i.d)(),
					d = Re(a, {
						...e,
						...t
					});
				return o.a.createElement(Ae, Te({}, e, t, s, d, {
					onFlairChanged: t => {
						let {
							previewFlair: n,
							selectedTemplateId: s
						} = t;
						return d.dispatchFlairChanged({
							post: e.post,
							previewFlair: n,
							selectedTemplateId: s
						})
					},
					sendEvent: Object(m.b)(),
					isOverlay: Object(he.a)(),
					theme: Object(_e.a)()
				}))
			})))
		},
		"./src/reddit/components/ConfirmModal/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3DhQ2s_h1XCiwltypHmlbp",
				close: "_2oxgXPm-tiPAEPsJoUw-ZD",
				headerText: "_2sDCzF6zlpNJ5cbVDRCPOS",
				text: "_3eWjwYvkDvPzyq4FlubrF9",
				buttonWrapper: "_6ZHRZ8Epefe887d7LL-q6",
				primaryButton: "Ch-0dFLxLOtcc6xCyQvsk",
				secondaryButton: "bgwHoiDoSwFVZKRTLRQMF"
			}
		},
		"./src/reddit/components/ConfirmModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asModal/index.tsx"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/components/ConfirmModal/index.m.less"),
				d = n.n(a),
				c = n("./src/reddit/components/ModalStyledComponents/index.tsx");
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: d.a.container
			}, r.a.createElement("button", {
				onClick: () => e.onClose ? e.onClose() : e.onCancel(),
				className: d.a.close
			}, r.a.createElement(c.b, null)), r.a.createElement(c.i, null, r.a.createElement("h2", {
				className: d.a.headerText
			}, e.headerText)), r.a.createElement(c.l, null, e.message && r.a.createElement("p", {
				className: d.a.text
			}, e.message), e.children && r.a.createElement("div", {
				className: d.a.text
			}, e.children), r.a.createElement("div", {
				className: d.a.buttonWrapper
			}, e.cancelText && r.a.createElement(i.o, {
				className: d.a.secondaryButton,
				onClick: e.onCancel
			}, e.cancelText), r.a.createElement(i.l, {
				className: d.a.primaryButton,
				onClick: e.onAccept
			}, e.acceptText)))))
		},
		"./src/reddit/components/ConfirmUserActionModal/index.m.less": function(e, t, n) {
			e.exports = {
				buttonWidth: "ogOEj4x-0BpDZWeccJwxx",
				ModalText: "_2YxEi97B6Nm7NCgLG6pCud",
				modalText: "_2YxEi97B6Nm7NCgLG6pCud"
			}
		},
		"./src/reddit/components/ConfirmUserActionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				l = n("./src/reddit/components/ConfirmUserActionModal/index.m.less"),
				u = n.n(l);
			const m = e => e.preventDefault();
			t.a = Object(i.a)(e => o.a.createElement(a.e, null, o.a.createElement(a.i, null, o.a.createElement(c.a, null, o.a.createElement(a.q, null, e.headerText || s.fbt._("Confirm", null, {
				hk: "2zlvKa"
			})), o.a.createElement(d.a, {
				onClick: () => {
					e.onClose && e.onClose(), e.toggleModal && e.toggleModal()
				}
			}, o.a.createElement(a.b, null)))), o.a.createElement(a.l, null, o.a.createElement(a.p, {
				className: u.a.ModalText
			}, e.modalText)), o.a.createElement(a.g, null, !e.hideCancelButton && o.a.createElement(a.a, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: () => {
					e.onCancel && e.onCancel(), e.toggleModal && e.toggleModal()
				},
				"data-redditstyle": !e.disableRedditStyle
			}, e.cancelActionText || s.fbt._("Cancel", null, {
				hk: "2TSLl5"
			})), o.a.createElement(a.u, {
				className: u.a.buttonWidth,
				onMouseDown: m,
				onClick: t => {
					e.onConfirm(), e.toggleModal && e.toggleModal(), e.trackClick && e.trackClick()
				},
				"data-redditstyle": !e.disableRedditStyle,
				disabled: e.isDisabled
			}, e.actionText))))
		},
		"./src/reddit/components/ContentGate/index.m.less": function(e, t, n) {
			e.exports = {
				ButtonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				buttonsContainer: "_3-bzOoWOXVn2xJ3cljz9oC",
				Container: "_32zGs4bO3IunZfS9bSJY0_",
				container: "_32zGs4bO3IunZfS9bSJY0_",
				ContainerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				containerExp: "_2l6FU0DxoyHFIOEFPg-vV6",
				Description: "_3VTI5BOpJO70xoBKSqz3O9",
				description: "_3VTI5BOpJO70xoBKSqz3O9",
				PrivateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				privateSubredditDetails: "vpktIvfG7wrc27Xk4Gk-C",
				PrivateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				privateSubredditDescription: "_2uXliuchCWW0MYUGS_Ks6v",
				PrivateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				privateSubredditName: "_3boUKJ5E--k1_9nH886_Wr",
				Link: "o4oSRcSrppMzf__hxJKxn",
				link: "o4oSRcSrppMzf__hxJKxn",
				LinkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				linkButton: "_1_UhYZsTnAQbBONlhaTTMS",
				LinkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				linkRouterButton: "_2zJbrt0pYl6tbRsmVW0peX",
				SecondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				secondaryLinkRouterButton: "rDOqrXOt4-jCKENSEQG_N",
				SecondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				secondaryLinkButton: "i2sTp1duDdXdwoKi1l8ED",
				CreateCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				createCommunityButton: "_209KUA_ej4pZVjoQbSOIf9",
				GoHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				goHomeLinkButton: "_3goHjUTM8-J0xINP6EoZkZ",
				PrivateKey: "kwHMAzQCDA69TaL3eHZLa",
				privateKey: "kwHMAzQCDA69TaL3eHZLa",
				Image: "_1jefpljVGT-eHObg40F8Dm",
				image: "_1jefpljVGT-eHObg40F8Dm",
				ImagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				imagePlaceholder: "yIkP2FaSTqFA_kLFyyH1d",
				LeftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				leftLinkButton: "_3cs2bzZ9PGS1kcZc2r7vdP",
				LeftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				leftLinkRouterButton: "_2V3wnL5o-KBHbU_hs7cMof",
				SecondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				secondaryLeftLinkButton: "_3t2KyZopmra_0R16z-1xwr",
				SecondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				secondaryLeftLinkRouterButton: "y7s2WWxfdEzMhMm2mjo-G",
				Title: "_2XKLlvmuqdor3RvVbYZfgz",
				title: "_2XKLlvmuqdor3RvVbYZfgz",
				PageBody: "bDDEX4BSkswHAG_45VkFB",
				pageBody: "bDDEX4BSkswHAG_45VkFB",
				InterstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				interstitialMessageWrapper: "_2xiFx6Zsb5W98_T1DOroT_",
				ContributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz",
				contributorRequestButton: "_3WUsc0xUSWlcvJ0BD4jiUz"
			}
		},
		"./src/reddit/components/ContentGate/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				d = n("./src/reddit/contexts/NavbarExp.ts"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/loginHref/index.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/preferences.ts"),
				b = n("./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx"),
				f = n("./src/reddit/components/CreateCommunityButton/index.tsx"),
				h = n("./src/reddit/components/Footer/index.tsx"),
				_ = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				g = n("./src/reddit/components/RichTextJson/index.tsx"),
				v = n("./src/reddit/components/SubredditSearchCarousel/async.tsx"),
				x = n("./node_modules/lodash/flatMap.js"),
				O = n.n(x),
				E = n("./src/lib/linkMatchers/index.ts"),
				y = n("./src/lib/linkMatchers/customLinks.ts"),
				C = n("./src/reddit/controls/OutboundLink/index.tsx");
			const j = /\[(.+?)\]\((.+?)\)/g,
				k = e => {
					const t = e.split(j);
					if (1 === t.length) return [e];
					const n = [];
					for (let s = 0; s < t.length; s += 3) {
						const [e, r, o] = t.slice(s, s + 3);
						n.push(e), n.push([o, r])
					}
					return n
				};
			var I = o.a.memo(e => {
					let t = [e.text];
					return e.parseMdLinks && (t = O()(t, k)), e.parseRegularLinks && (t = O()(t, e => Array.isArray(e) ? [e] : (e => {
						const t = E.f.add(y.g.subreddit.prefix, y.g.subreddit.config).match(e);
						if (!t) return [e];
						const n = [];
						let s = null;
						for (const r of t) n.push(e.slice(s ? s.lastIndex : 0, r.index)), s = r, n.push([r.url, r.text]);
						return s && n.push(e.slice(s.lastIndex)), n
					})(e))), o.a.createElement(o.a.Fragment, null, " ", t.map((t, n) => {
						if (Array.isArray(t)) {
							const [s, r] = t;
							return o.a.createElement(C.b, {
								className: e.linkClassName,
								href: s,
								key: n
							}, r)
						}
						return o.a.createElement("span", {
							key: n
						}, t)
					}), " ")
				}),
				S = n("./src/reddit/constants/parameters.ts"),
				w = n("./src/reddit/contexts/PageLayer/index.tsx"),
				T = n("./src/reddit/controls/Button/index.tsx"),
				N = n("./src/chat/controls/Svg/index.tsx");

			function P() {
				return (P = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var R = e => o.a.createElement(N.a, P({}, e, {
					viewBox: "-1 -1 21 21"
				}), o.a.createElement("path", {
					d: "M16.64,2.32a4.5,4.5,0,0,0-7,5.57L4.85,12.69,3.59,13.95h0L2.34,15.2a1,1,0,0,0,0,1.41l1.25,1.25h0l.42.42a1,1,0,0,0,1.41-1.41L5,16.46H5a.78.78,0,0,1,0-1.09.79.79,0,0,1,1.09,0h0l.42.42a1,1,0,0,0,1.41-1.41L7.52,14h0L7,13.4l4.1-4.1a4.5,4.5,0,0,0,5.57-7Zm-1.41,5a2.5,2.5,0,1,1,0-3.54A2.5,2.5,0,0,1,15.22,7.27Z"
				})),
				A = n("./src/reddit/models/ContentGate.ts"),
				M = n("./src/lib/constants/index.ts"),
				L = n("./src/reddit/selectors/platform.ts"),
				D = n("./src/reddit/selectors/user.ts");
			var F = n("./src/reddit/selectors/meta.ts"),
				U = n("./src/reddit/components/ContentGate/index.m.less"),
				B = n.n(U);
			const {
				fbt: q
			} = n("./node_modules/fbt/lib/FbtPublic.js"), G = l.a.wrapped(R, "PrivateKey", B.a), H = l.a.div("ButtonsContainer", B.a), W = l.a.div("Container", B.a), V = l.a.div("ContainerExp", B.a), z = l.a.div("Description", B.a), K = l.a.div("PrivateSubredditDetails", B.a), Q = l.a.div("PrivateSubredditDescription", B.a), Y = l.a.h3("PrivateSubredditName", B.a), J = l.a.a("Link", B.a), X = l.a.wrapped(T.n, "LinkRouterButton", B.a), Z = l.a.wrapped(T.m, "LinkButton", B.a), $ = l.a.wrapped(T.q, "SecondaryLinkRouterButton", B.a), ee = l.a.wrapped(T.p, "SecondaryLinkButton", B.a), te = l.a.wrapped(X, "GoHomeLinkButton", B.a), ne = l.a.wrapped(f.a, "CreateCommunityButton", B.a), se = l.a.img("Image", B.a), re = l.a.img("ImagePlaceholder", B.a), oe = l.a.wrapped(X, "LeftLinkRouterButton", B.a), ie = l.a.wrapped(Z, "LeftLinkButton", B.a), ae = l.a.wrapped(ee, "SecondaryLeftLinkButton", B.a), de = l.a.wrapped($, "SecondaryLeftLinkRouterButton", B.a), ce = l.a.h3("Title", B.a), le = l.a.div("PageBody", B.a), ue = l.a.div("InterstitialMessageWrapper", B.a), me = Object(c.c)({
				isLoggedIn: D.Q,
				origin: F.k,
				user: D.l,
				isPrivateSubredditContributorRequestPending: e => (e => {
					if (!Object(D.R)(e)) return !1;
					const t = Object(L.d)(e);
					if (!t) return !1;
					const n = Object(D.g)(e, t);
					if (!n) return !1;
					if (!n.privateSubreddit) return !1;
					const {
						isContributorRequestTimestamp: s
					} = n;
					if (!s) return !1;
					const r = 30 * M.E;
					return s > Date.now() - r
				})(e),
				isSeo: F.h
			}), pe = Object(w.v)(), be = Object(i.b)(me, (e, t) => {
				let {
					subredditName: n
				} = t;
				return {
					continueToQuarantinedSubreddit: async () => {
						await e(p.E(n)), window.location.reload()
					},
					continueToGatedSubreddit: async () => {
						await e(p.v(n)), window.location.reload()
					},
					setNSFWPreference: async () => {
						await e(Object(m.q)())
					}
				}
			}), fe = e => {
				const {
					banMessage: t,
					contentGateType: n,
					continueToQuarantinedSubreddit: r,
					continueToGatedSubreddit: i,
					isLoggedIn: a,
					isContributorRequestsDisabled: d,
					isPrivateSubredditContributorRequestPending: c,
					isSeo: l,
					location: p,
					origin: f,
					pageLayer: h,
					quarantineRequiresEmail: x,
					quarantineMessage: O,
					quarantineMessageHtml: E,
					quarantineMessageRTJson: y,
					interstitialWarningMessage: C,
					interstitialWarningMessageHtml: j,
					interstitialWarningMessageRTJson: k,
					setNSFWPreference: w,
					subredditDescription: T,
					subredditName: N,
					user: P
				} = e, R = async () => {
					if (a ? await w() : await Object(m.p)(), l) {
						const e = new URL(window.location.href);
						e.searchParams.set(S.k, "1"), window.location.href = e.href
					} else window.location.reload()
				};
				switch (n) {
					case A.a.GoldSubreddit:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/gold/premium-crest.png`
						}), o.a.createElement(ce, null, q._("r/{community name} is a Reddit Premium community", [q._param("community name", N)], {
							hk: "2lyDwB"
						})), o.a.createElement(z, null, q._("The moderators in this community have set it to Reddit Premium members only. You must upgrade to a Reddit Premium membership to continue.", null, {
							hk: "mIiOw"
						})), o.a.createElement(H, null, P ? o.a.createElement(ae, {
							href: `${s.a.redditUrl}/premium`,
							redditStyle: !0
						}, q._("Get Premium", null, {
							hk: "3ChWi4"
						})) : o.a.createElement(ie, {
							href: Object(u.a)(p, f),
							redditStyle: !0
						}, q._("Sign Up", null, {
							hk: "rvpjy"
						})), P ? o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, q._("Go Home", null, {
							hk: "49p4or"
						})) : o.a.createElement(ee, {
							href: Object(u.a)(p, f),
							redditStyle: !0
						}, q._("Log In", null, {
							hk: "4Cxw0g"
						}))));
					case A.a.Nsfw:
					case A.a.NsfwCustomFeed:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/nsfw.png`
						}), o.a.createElement(ce, null, n === A.a.Nsfw ? q._("You must be 18+ to view this community", null, {
							hk: "IQmEA"
						}) : q._("You must be 18+ to view this Custom Feed", null, {
							hk: "3pmHS2"
						})), o.a.createElement(z, null, q._("You must be at least eighteen years old to view this content. Are you over eighteen and willing to see adult content?", null, {
							hk: "gI12S"
						})), o.a.createElement(H, null, o.a.createElement(oe, {
							to: "/",
							redditStyle: !0
						}, q._("No", null, {
							hk: "3fMglW"
						})), o.a.createElement(ee, {
							onClick: R,
							redditStyle: !0
						}, q._("Yes", null, {
							hk: "2hpRkN"
						}))));
					case A.a.PrivateSubreddit:
						return o.a.createElement("div", null, o.a.createElement(G, null), o.a.createElement(ce, null, "r/", N, " ", q._("is a private community", null, {
							hk: "7zZmq"
						})), T && T.length && o.a.createElement(K, null, o.a.createElement(Y, null, "r/", N), o.a.createElement(Q, null, o.a.createElement("div", null, T))), o.a.createElement(z, null, q._("The moderators of", null, {
							hk: "3QSrbr"
						}), " ", "r/", N, " ", q._("have set this community as private.", null, {
							hk: "3zhD9F"
						}), o.a.createElement("br", null), q._("Only approved members can view and take part in its discussions.", null, {
							hk: "af0uR"
						})), o.a.createElement(H, null, P ? o.a.createElement(o.a.Fragment, null, !d && o.a.createElement(b.a, {
							eventSource: "content_gate",
							smallButton: !0,
							className: B.a.ContributorRequestButton,
							isContributorRequestPending: c
						}), o.a.createElement(ae, {
							href: `${s.a.redditUrl}/message/compose?to=/r/${N}`,
							redditStyle: !0
						}, q._("Message Mods", null, {
							hk: "vVe1i"
						}))) : o.a.createElement(ae, {
							href: Object(u.a)(p, f),
							redditStyle: !0
						}, q._("Sign Up", null, {
							hk: "rvpjy"
						})), o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, q._("Browse Reddit", null, {
							hk: "1fi8kh"
						}))), N && o.a.createElement(v.a, {
							subredditName: N
						}));
					case A.a.QuarantinedSubreddit:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/quarantined.png`
						}), o.a.createElement(ce, null, q._("Are you sure you want to view this community?", null, {
							hk: "2BtxLM"
						})), o.a.createElement(z, null, q._("This community is {=quarantined}", [q._param("=quarantined", o.a.createElement(J, {
							href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/quarantined-subreddits"
						}, q._("quarantined", null, {
							hk: "2XqfJa"
						})))], {
							hk: "2B9i8y"
						}), o.a.createElement(ue, null, y ? o.a.createElement(g.b, {
							content: y,
							rtJsonElementProps: {
								pageLayer: h
							}
						}) : E ? o.a.createElement(_.a, {
							html: E
						}) : O || q._("Quarantined communities are dedicated to shocking or highly offensive content. You must be logged in with a verified email to continue.", null, {
							hk: "3kRIzE"
						})), q._("Are you certain you want to continue?", null, {
							hk: "1gr5Bw"
						})), o.a.createElement(H, null, ((e, t, n) => {
							return !(e && e.hasVerifiedEmail) && n ? o.a.createElement(H, null, o.a.createElement(de, {
								to: "/",
								redditStyle: !0
							}, q._("No Thank You", null, {
								hk: "4B26AR"
							})), o.a.createElement(Z, {
								href: `${s.a.redditUrl}/prefs/update`,
								redditStyle: !0
							}, q._("Verify Email", null, {
								hk: "1893cq"
							}))) : o.a.createElement(H, null, o.a.createElement(oe, {
								to: "/",
								redditStyle: !0
							}, q._("No Thank You", null, {
								hk: "4B26AR"
							})), o.a.createElement(ee, {
								onClick: t,
								redditStyle: !0
							}, q._("Continue", null, {
								hk: "4nU0mS"
							})))
						})(P, r, x)));
					case A.a.GatedSubreddit:
						return o.a.createElement("div", null, o.a.createElement(ce, null, q._("Are you sure you want to view this community?", null, {
							hk: "1K5UIm"
						})), o.a.createElement(z, null, o.a.createElement(ue, null, k ? o.a.createElement(g.b, {
							content: k,
							rtJsonElementProps: {
								pageLayer: h
							}
						}) : j ? o.a.createElement(_.a, {
							html: j
						}) : C), q._("Are you certain you want to continue?", null, {
							hk: "3pT969"
						})), o.a.createElement(H, null, o.a.createElement(oe, {
							to: "/",
							redditStyle: !0
						}, q._("No Thank You", null, {
							hk: "4B26AR"
						})), o.a.createElement(ee, {
							onClick: i,
							redditStyle: !0
						}, q._("Continue", null, {
							hk: "2rLyAk"
						}))));
					case A.a.SubredditBanned:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/content-gate-icons/banned.png`
						}), o.a.createElement(ce, null, q._("r/{community name} has been banned from Reddit", [q._param("community name", N)], {
							hk: "2at9Se"
						})), (e => o.a.createElement(z, null, e ? o.a.createElement(I, {
							linkClassName: B.a.Link,
							text: e,
							parseMdLinks: !0,
							parseRegularLinks: !0
						}) : q._("This community has been banned for violating the Reddit rules.", null, {
							hk: "3iUVxA"
						})))(t), o.a.createElement(H, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, q._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case A.a.SubredditBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, q._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "4bCnhl"
						})), o.a.createElement(H, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, q._("Explore Reddit", null, {
							hk: "FrUWU"
						}))));
					case A.a.SubredditDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement(re, null), o.a.createElement(ce, null, q._("Sorry, there aren’t any communities on Reddit with that name.", null, {
							hk: "31DRpe"
						})), o.a.createElement(z, null, q._("This community may have been banned or the community name is incorrect.", null, {
							hk: "1lYMG2"
						})), o.a.createElement(H, null, P && o.a.createElement(ne, {
							eventSource: "content_gate"
						}), o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, q._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.ProfileDoesNotExist:
					case A.a.ProfileDeleted:
					case A.a.ProfileSuspended:
					case A.a.ProfileBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, (e => {
							const {
								contentGateType: t
							} = e;
							switch (t) {
								case A.a.ProfileBlockedForLegalReason:
									return q._("This content has been restricted in your country in response to a legal request.", null, {
										hk: "4eeylO"
									});
								case A.a.ProfileDeleted:
									return q._("This user has deleted their account.", null, {
										hk: "2IAF6m"
									});
								case A.a.ProfileSuspended:
									return o.a.createElement(o.a.Fragment, null, q._("This account has been {=suspended} .", [q._param("=suspended", o.a.createElement(J, {
										href: "https://www.reddithelp.com/en/categories/reddit-101/rules-reporting/account-and-community-restrictions/suspensions"
									}, q._("suspended", null, {
										hk: "3nHGgi"
									})))], {
										hk: "4cuTBS"
									}));
								case A.a.ProfileDoesNotExist:
									return o.a.createElement(o.a.Fragment, null, o.a.createElement(ce, null, q._("Sorry, nobody on Reddit goes by that name.", null, {
										hk: "3i02av"
									})), o.a.createElement(z, null, q._("The person may have been banned or the username is incorrect.", null, {
										hk: "36ab4J"
									})))
							}
						})(e)), o.a.createElement(H, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, q._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.CustomFeedDoesNotExist:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, q._("Sorry, this custom feed is private or does not exist.", null, {
							hk: "2Ml4j9"
						})), o.a.createElement(H, null, o.a.createElement(te, {
							to: "/",
							redditStyle: !0
						}, q._("Go Home", null, {
							hk: "49p4or"
						}))));
					case A.a.PostBlockedForLegalReason:
						return o.a.createElement("div", null, o.a.createElement(se, {
							src: `${s.a.assetPath}/img/snoomoji/snoo_thoughtful.png`
						}), o.a.createElement(ce, null, q._("This content has been restricted in your country in response to a legal request.", null, {
							hk: "1q1rVU"
						})), o.a.createElement(H, null, o.a.createElement(X, {
							to: "/",
							redditStyle: !0
						}, q._("Browse Reddit", null, {
							hk: "1XnYmj"
						}))))
				}
			};
			t.default = pe(be(Object(a.i)(e => {
				const t = Object(r.useContext)(d.a) ? V : W;
				return o.a.createElement(t, null, o.a.createElement("div", {
					"data-testid": "content-gate"
				}, o.a.createElement(le, null, fe(e))), o.a.createElement(h.b, null))
			})))
		},
		"./src/reddit/components/ContentSurvey/RatingCard.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/components/ContentSurvey/index.m.less"),
				a = n.n(i),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/SubredditIcon/index.tsx"),
				l = n("./src/reddit/hooks/useTheme.ts"),
				u = n("./src/reddit/icons/svgs/Info/index.tsx"),
				m = n("./src/reddit/models/Theme/index.ts"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/selectors/subreddit.ts");
			const {
				fbt: f
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function h(e) {
				var t, n;
				const {
					ratingResponse: s,
					subredditId: i,
					children: h
				} = e, _ = null !== (t = Object(o.e)(e => Object(b.Y)(e, {
					subredditId: i
				}))) && void 0 !== t ? t : {}, g = Object(l.a)();
				return r.a.createElement("div", {
					className: a.a.ratingCard
				}, "PENDING" === (null == s ? void 0 : s.status) && r.a.createElement("div", {
					className: Object(d.a)(a.a.card, a.a.pending)
				}, r.a.createElement(u.a, {
					className: a.a.infoIcon
				}), f._("Content tag is pending until reviewed", null, {
					hk: "Umha7"
				})), r.a.createElement("div", {
					className: a.a.card
				}, r.a.createElement("div", {
					className: a.a.banner,
					style: {
						background: Object(m.g)(Object(p.a)({
							theme: g
						}).banner.backgroundColor, Object(p.a)({
							theme: g
						}).banner.backgroundImage, Object(p.a)({
							theme: g
						}).banner.backgroundImagePosition)
					}
				}, r.a.createElement(c.b, {
					className: a.a.communityIcon,
					iconUrl: null === (n = _.icon) || void 0 === n ? void 0 : n.url
				})), r.a.createElement("h3", {
					className: a.a.communityName
				}, s ? r.a.createElement("span", null, _.displayText, r.a.createElement("img", {
					className: a.a.ratingImg,
					src: s.rating.icon.png
				})) : _.displayText), h))
			}
		},
		"./src/reddit/components/ContentSurvey/SurveyModal.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/higherOrderComponents/asModal/index.tsx");
			const o = Object(s.a)({
					resolved: {},
					chunkName: () => "",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e(0), n.e(1)]).then(n.bind(null, "./src/reddit/components/ContentSurvey/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ContentSurvey/index.tsx"
					}
				}),
				i = Object(r.a)(o);
			t.a = i
		},
		"./src/reddit/components/ContentSurvey/index.m.less": function(e, t, n) {
			e.exports = {
				feedBanner: "_3oY2sjcQ7EgBYd7agqleJv",
				notepadSnoo: "B0cLCCVs794x74kjJidDO",
				bannerCopy: "_2NfcId0Mtt4-NP4AbrAck5",
				copy: "BcSr5zM39F4cQJ9MQqkRn",
				meta: "r9AkMaLWOPKfC5Swx9XQf",
				chevron: "yFbNzMMxa-u2DgUP3Gz5h",
				header: "wKkshJ3Og8gaDgJmSULiK",
				introCopy: "m3rT-KnA6An7scRNg10UW",
				checkbox: "Y5aDAUsXXQaMbdCe1-qdG",
				result: "_29ewfEVekvKEl_P2hqf4tI",
				heading: "_3yKTUBG4MrGHv9n644t4Ua",
				card: "_18VT-IpGoX6SDdyHHLI_eo",
				pending: "hg80uiMz2ssH44RLsmlhG",
				infoIcon: "_3HgNBpJCFAy2mohcd9VxmZ",
				banner: "_23eBsXSECZlQ3Eh-zXhEbC",
				communityIcon: "_2Z8cRxGvjX2hQUlQK_VEOE",
				communityName: "_1sHP__xe_7iTbSpLKp7FeC",
				ratingImg: "UZWqo3i6ydUcE18iJqx3P",
				ratingAudience: "_1Y5aAemcMRF3uwSgYpqbsT",
				ratingDescription: "_1e5wHYsIyWJlZSjZCHhBKg",
				reasonsHeader: "_1npcgCYHbRcUsU6KOI7ony",
				reason: "_3rlzPcuZsxLsVx6ib3oBjk"
			}
		},
		"./src/reddit/components/ContentTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				styledTooltipContainer: "_2uSuNRa3OeptFDJCKQ3vU6",
				fadeIn: "_2bkYZH_kJx5pIHW0Ts5P6e",
				caretOnBottom: "_1rF-A55THyDL-rQ9ZUDQ4_",
				caretOnTop: "_1MHCyMQAMeqRqf5DPWWeq3",
				hideCaret: "dExJJiXRwxVrKsDJRWSQl",
				caretOnLeft: "nVD-oexLbZI_4QjhrkLFz",
				caretOnRight: "KRVDnoE1RIC5qyqQLXxGG"
			}
		},
		"./src/reddit/components/ContentTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/lib/fastdom/index.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				p = n("./src/reddit/selectors/tooltip.ts"),
				b = n("./src/reddit/components/ContentTooltip/index.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const _ = {
					height: 200,
					width: 200
				},
				g = e => {
					switch (e) {
						case "top":
							return "bottom";
						case "right":
							return "left";
						case "left":
							return "right";
						case "bottom":
						default:
							return "top"
					}
				},
				v = Object(c.a)(e => {
					const {
						children: t,
						className: n,
						style: s,
						caretPosition: r,
						caretColor: i,
						onClick: a,
						hideCaret: c
					} = e;
					return o.a.createElement("div", {
						onClick: a,
						className: Object(d.a)(n, f.a.StyledTooltipContainer, {
							[f.a.caretOnTop]: "top" === r,
							[f.a.caretOnLeft]: "left" === r,
							[f.a.caretOnRight]: "right" === r,
							[f.a.caretOnBottom]: "bottom" === r,
							[f.a.hideCaret]: c
						}),
						style: {
							...s,
							"--contentTooltip-caretColor": i && i[r] ? i[r] : Object(m.a)(e).body
						}
					}, t)
				}),
				x = Object(a.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(p.b)(n)(e)
					}
				}),
				O = Object(u.a)(v, [s.a.Click, s.a.Keydown]),
				E = Object(i.b)(x);
			class y extends o.a.Component {
				constructor(e) {
					super(e), this.checkAndSetPosition = () => {
						const {
							tooltipId: e,
							tooltipSizeEstimate: t = _
						} = this.props;
						l.a.read(() => {
							const n = document.getElementById(e);
							if (!n) return;
							const s = n.getBoundingClientRect();
							if (!("undefined" != typeof window)) return void this.setState({
								position: this.props.defaultTooltipPosition
							});
							let r = !0;
							switch (this.props.defaultTooltipPosition) {
								case "bottom":
									r = window.innerHeight - s.bottom > t.height;
									break;
								case "left":
									r = s.left > t.width;
									break;
								case "right":
									r = s.right <= window.innerWidth - t.width;
									break;
								case "top":
								default:
									r = s.top > t.height
							}
							this.setState({
								position: r ? this.props.defaultTooltipPosition : g(this.props.defaultTooltipPosition)
							})
						})
					}, this.state = {
						position: null
					}
				}
				componentDidUpdate(e) {
					!e.isOpen && this.props.isOpen && this.checkAndSetPosition(), e.isOpen && !this.props.isOpen && this.setState({
						position: null
					})
				}
				getPositions(e) {
					switch (e || this.props.defaultTooltipPosition) {
						case "bottom":
							return {
								tooltipPosition: ["center", "top"], targetPosition: ["center", "bottom"], caretPosition: "top"
							};
						case "left":
							return {
								tooltipPosition: ["right", "center"], targetPosition: ["left", "center"], caretPosition: "right"
							};
						case "right":
							return {
								tooltipPosition: ["left", "center"], targetPosition: ["right", "center"], caretPosition: "left"
							};
						case "top":
						default:
							return {
								tooltipPosition: ["center", "bottom"], targetPosition: ["center", "top"], caretPosition: "bottom"
							}
					}
				}
				render() {
					const {
						position: e
					} = this.state, {
						targetPosition: t,
						tooltipPosition: n,
						caretPosition: s
					} = this.getPositions(e);
					return o.a.createElement(O, h({}, this.props, {
						caretPosition: s,
						targetPosition: t,
						tooltipPosition: n
					}))
				}
			}
			t.a = E(y)
		},
		"./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "ContributorRequestButton",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ContributorRequestButton").then(n.bind(null, "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ContributorRequestFlow/ContributorRequestButton/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/CountAnimation/index.m.less": function(e, t, n) {
			e.exports = {
				countAnimation: "_3z5CnRH3l7hQGI8TQYFyqX",
				digitDeltaWrapper: "WBY6J5DJsZFZXSxBqtq0F",
				digitDelta: "_3LT2yD0gRFklddn3Ra9ElD",
				"sr-only": "D6SuXeSnAAagG8dKAb4O4",
				srOnly: "D6SuXeSnAAagG8dKAb4O4"
			}
		},
		"./src/reddit/components/CountAnimation/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/hooks/usePrevious.ts"),
				i = n("./src/realtime/GQLSubscription/async.tsx"),
				a = n("./src/reddit/hooks/useIntersectionObserver.ts");
			const d = e => {
				return Math.abs(e).toString().split("").map(e => parseInt(e))
			};
			var c = n("./src/reddit/components/CountAnimation/index.m.less"),
				l = n.n(c);
			var u;
			! function(e) {
				e.Vote = "vote", e.Comment = "comment"
			}(u || (u = {}));
			const m = () => 0;
			t.b = e => {
				const {
					countToUpperBound: t,
					featureName: n,
					incrementDelta: c,
					initialDelay: u,
					initialDisplayCount: p,
					isLoadTestOnly: b,
					onDataCB: f,
					postId: h,
					queryKey: _,
					queryVariables: g,
					shouldDisjointAnimation: v,
					subsequentRecurringDelay: x
				} = e, [O, E] = Object(s.useState)(!1), [y, C] = Object(s.useState)(!0), [j, k] = Object(s.useState)([]), [I, S] = Object(s.useState)(d(p).reverse()), w = Object(s.useRef)(!1), T = Object(s.useRef)(null), N = Object(s.useRef)(e => {}), P = Object(s.useRef)();
				N.current = Object(s.useCallback)(e => {
					let n = e || c();
					const s = [...I].reverse().join("");
					let r = parseInt(s) + n;
					r > t && (n = t - parseInt(s), r = t);
					const o = d(r).reverse();
					E(!1), k(I), S(o), C(!1), P.current = setTimeout(() => {
						E(!0)
					}, 0)
				}, [t, c, I]);
				const R = Object(s.useRef)(() => {}),
					A = Object(s.useRef)(),
					M = Object(s.useRef)();
				R.current = Object(s.useCallback)(() => {
					M.current = setTimeout(() => {
						N.current();
						const e = [...j].reverse().join("");
						parseInt(e) < t && R.current()
					}, x())
				}, [t, x, j]);
				const L = Object(s.useRef)(0),
					D = Object(s.useRef)(!1),
					F = Object(s.useCallback)(e => {
						e.forEach(e => {
							const {
								isIntersecting: t,
								intersectionRatio: n
							} = e, s = 1 !== n;
							t ? (D.current = !0, w.current || (w.current = !0, A.current = setTimeout(() => {
								N.current(), R.current()
							}, u())), L.current > 0 && (N.current(L.current), L.current = 0)) : s && (D.current = !1)
						})
					}, []);
				Object(a.a)(T, F);
				const [U, B] = Object(s.useState)(!1), q = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? B(!0) : s && B(!1)
					})
				}, []), G = Object(s.useRef)({
					rootMargin: "2000px 0px 2000px 0px"
				});
				Object(a.a)(T, q, G.current);
				const H = Object(o.a)(t);
				Object(s.useEffect)(() => {
					if (void 0 !== H && H !== t) {
						const e = t - H;
						D.current ? N.current(e) : L.current += e
					}
					return () => {
						clearTimeout(A.current), clearTimeout(M.current), clearTimeout(P.current)
					}
				}, [t]);
				const W = Object(s.useCallback)(() => C(!0), [C]),
					V = 0 === j.length,
					z = y || V,
					K = Object(s.useRef)(((e, t) => `${t}_${e}_count_anim`)(h, n));
				return r.a.createElement(r.a.Fragment, null, !b && r.a.createElement("div", {
					className: l.a.countAnimation
				}, I.map((e, t) => {
					const n = ((e, t) => {
						let n = Math.abs(e);
						const s = Math.abs(t),
							r = [n];
						if (n === s) return r;
						let o = !0;
						for (; o;) ++n > 9 && (n = 0), r.push(n), n === s && (o = !1);
						return r
					})(j[t] || 0, e);
					return r.a.createElement("span", {
						"aria-hidden": !0,
						className: l.a.digitDeltaWrapper,
						key: t,
						onTransitionEnd: W,
						style: O && j.length > 0 && !y ? {
							transform: `translateY(-${v&&n.length>1?100:100*(n.length-1)}%)`,
							transitionDuration: `${(v?500:750)/1e3}s`
						} : {
							transform: "translateY(0)"
						}
					}, z ? r.a.createElement("span", {
						className: l.a.digitDelta
					}, e) : n.map((e, t) => {
						const s = 0 === t || t === n.length - 1;
						if (!v || v && s) return r.a.createElement("span", {
							className: l.a.digitDelta,
							key: t
						}, e)
					}).filter(e => !!e))
				}), r.a.createElement("span", {
					className: l.a.srOnly,
					role: "screen-reader"
				}, [...I].reverse().join(""))), r.a.createElement("span", {
					ref: T
				}), U && r.a.createElement(i.a, {
					variables: g,
					onData: b ? m : f,
					queryKey: _,
					uniqueKey: K.current
				}))
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.m.less": function(e, t, n) {
			e.exports = {
				StyledTooltip: "FIYolDqalszTnjjNfThfT",
				styledTooltip: "FIYolDqalszTnjjNfThfT"
			}
		},
		"./src/reddit/components/CreateCommunityButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				u = n("./src/reddit/components/TrackingHelper/index.tsx"),
				m = n("./src/reddit/constants/modals.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				f = n("./src/reddit/selectors/user.ts"),
				h = n("./src/reddit/components/CreateCommunityButton/index.m.less"),
				_ = n.n(h),
				g = n("./src/lib/lessComponent.tsx");
			const v = "create-community-button",
				x = g.a.wrapped(l.c, "StyledTooltip", _.a),
				O = Object(a.c)({
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(f.qb)(e),
					userIsSuspended: f.Y
				});
			t.a = Object(i.b)(O, (e, t) => {
				let {
					eventSource: n
				} = t;
				return {
					openCommunityCreation: t => {
						t(Object(b.c)(n)), e(Object(d.h)(m.a.SUBREDDIT_CREATION_MODAL_ID))
					},
					onShowTooltip: () => e(Object(c.f)({
						tooltipId: v
					})),
					onHideTooltip: () => e(Object(c.i)())
				}
			})(Object(u.c)(e => {
				let {
					className: t,
					eventSource: n,
					onShowTooltip: r,
					onHideTooltip: i,
					openCommunityCreation: a,
					sendEvent: d,
					userDoesNotHaveEnoughExpToCreateCommunity: c,
					userIsSuspended: l,
					onClick: u
				} = e;
				return o.a.createElement(p.t, {
					className: t,
					disabled: l || c,
					onClick: e => {
						u && u(e), a(d)
					},
					onMouseEnter: r,
					onMouseLeave: i,
					priority: p.c.Secondary,
					id: v,
					isFullWidth: !0
				}, s.fbt._("Create Community", null, {
					hk: "28v7Qq"
				}), c ? o.a.createElement(x, {
					caretOnTop: !0,
					tooltipId: v,
					text: s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "2R1OXu"
					})
				}) : l ? o.a.createElement(x, {
					caretOnTop: !0,
					tooltipId: v,
					text: s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "2xBDEw"
					})
				}) : null)
			}))
		},
		"./src/reddit/components/CreatorStats/Icon.m.less": function(e, t, n) {
			e.exports = {
				icon: "D7SJKwX8OlPkNjhgXO71s"
			}
		},
		"./src/reddit/components/CreatorStats/Icon.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/icons.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/selectors/subreddit.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/components/CreatorStats/Icon.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					postCreated: t,
					subredditId: n
				} = e;
				const l = Object(i.e)(e => n ? Object(d.Y)(e, {
						subredditId: n
					}) : void 0),
					[m, p] = Object(r.useState)(!0);
				return Object(r.useEffect)(() => {
					let e = !0;
					if (void 0 !== t) {
						const n = Object(c.e)(t);
						e = e && !n
					}
					if (void 0 !== l) {
						const t = l.isQuarantined;
						e = e && !t
					}
					p(e)
				}, [t, l]), o.a.createElement(a.a, {
					name: s.a.statistics,
					className: m ? u.a.icon : void 0
				})
			}
		},
		"./src/reddit/components/CreatorStats/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = 16374492e5,
				o = 45 * s.E;
			var i;
			! function(e) {
				e.NotAvailableYet = "NotAvailableYet", e.NotAvailable = "NotAvailable", e.Available = "Available", e.Expired = "Expired", e.Quarantined = "Quarantined"
			}(i || (i = {}));
			const a = e => {
					return e < Date.now() - o
				},
				d = e => e > r,
				c = (e, t, n, s) => {
					if (!n && !d(e.created)) return i.NotAvailable;
					if (n && !d(e.created) || a(e.created)) return i.Expired;
					if (n && s) return i.Quarantined;
					if (!t) return i.NotAvailableYet;
					const {
						shareAllCountTotals: r,
						shareCopyCountTotals: o,
						viewCountTotals: c,
						viewCountTrends: l
					} = t;
					return (null == r ? void 0 : r.availability.isAvailable) && (null == o ? void 0 : o.availability.isAvailable) && (null == c ? void 0 : c.availability.isAvailable) && (null == l ? void 0 : l.availability.isAvailable) && l.data && 0 !== l.data.length ? !(null == c ? void 0 : c.totalCount) || c.totalCount < 10 ? i.NotAvailableYet : i.Available : i.NotAvailableYet
				}
		},
		"./src/reddit/components/CrosspostBox/index.m.less": function(e, t, n) {
			e.exports = {
				mediaContainer: "P8p9Nku0-ZbYCsaCOSE2t",
				Container: "_2ED-O3JtIcOqp8iIL1G5cg",
				container: "_2ED-O3JtIcOqp8iIL1G5cg",
				PostMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				postMetaWrapper: "_1u_4ufj_H3WJW2TXEZ6a3n",
				PostTitle: "_2akYJO5RtMK_ptA408seyG",
				postTitle: "_2akYJO5RtMK_ptA408seyG",
				FlatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				flatList: "_3Dd3XvAr-WcOJyMTx4y35x",
				FlatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				flatItem: "_2Pkdj4FrQFtK8COeODi_kK",
				FlatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				flatListDotSpacer: "_3w73P89exX_1mpdhQCURo6",
				LinkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				linkContainer: "CsZ0mP84ULF0bBJJa0PFy",
				Content: "_379A_08LTBsR4c8POTldR_",
				content: "_379A_08LTBsR4c8POTldR_",
				ThumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX",
				thumbnailContainer: "_7bo--rwqP4Z7K1s_8dGPX"
			}
		},
		"./src/reddit/components/CrosspostBox/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return C
			})), n.d(t, "a", (function() {
				return j
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/lib/prettyPrintNumber/index.ts"),
				u = n("./src/reddit/components/Media/index.tsx"),
				m = n("./src/reddit/components/PostMeta/index.tsx"),
				p = n("./src/reddit/components/PostTitle/index.tsx"),
				b = n("./src/reddit/components/SourceLink/index.tsx"),
				f = n("./src/reddit/components/Thumbnail/index.tsx"),
				h = n("./src/lib/constants/index.ts"),
				_ = n("./src/reddit/contexts/Post/index.tsx"),
				g = n("./src/reddit/selectors/posts.ts"),
				v = n("./src/reddit/selectors/user.ts"),
				x = n("./src/reddit/components/CrosspostBox/index.m.less"),
				O = n.n(x),
				E = n("./src/lib/lessComponent.tsx");

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = 8,
				j = 1,
				k = E.a.div("Container", O.a),
				I = E.a.div("PostMetaWrapper", O.a),
				S = E.a.wrapped(p.c, "PostTitle", O.a),
				w = E.a.div("FlatList", O.a),
				T = E.a.div("FlatItem", O.a),
				N = E.a.span("FlatListDotSpacer", O.a),
				P = E.a.wrapped(k, "LinkContainer", O.a),
				R = E.a.div("Content", O.a),
				A = E.a.div("ThumbnailContainer", O.a),
				M = Object(d.c)({
					isCurrentUserProfilePost: g.l,
					isTopicPage: e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== h.Sb.TOPIC),
					shouldOpenPostInNewTab: v.kb
				}),
				L = Object(i.b)(M);
			t.c = Object(_.b)(L(e => {
				const {
					className: t,
					isCurrentUserProfilePost: n,
					isTopicPage: s,
					mediaProps: r,
					post: i,
					subredditOrProfile: a
				} = e;
				if (!i) return null;
				const d = {
						post: i,
						hideGildCta: !0,
						inSubredditOrProfile: !1,
						isCurrentUserProfilePost: n,
						isTopicPage: s,
						shouldShowSubscribeButton: !1,
						subredditOrProfile: a,
						tooltipType: `CrosspostBox--${r.isListing}`
					},
					c = t;
				return i && !i.media ? o.a.createElement(P, {
					className: c
				}, o.a.createElement(R, null, o.a.createElement(I, null, o.a.createElement(m.a, d)), D(i), i.source && o.a.createElement(b.a, {
					post: i
				}), U(e)), q(e)) : o.a.createElement(k, {
					className: c
				}, o.a.createElement(I, null, o.a.createElement(m.a, d)), D(i), F(e), U(e))
			}));
			const D = e => o.a.createElement(S, {
					isCrosspost: !0,
					post: e,
					shouldLinkWrap: !0,
					size: p.b.Small
				}),
				F = e => {
					const {
						mediaProps: t,
						post: n
					} = e, s = {
						...t,
						post: n,
						crosspost: t.post
					};
					return o.a.createElement("div", null, o.a.createElement(u.a, y({}, s, {
						className: O.a.mediaContainer,
						scrollerItemRef: t.scrollerItemRef
					})))
				},
				U = e => {
					const {
						post: t
					} = e, {
						score: n
					} = t;
					return o.a.createElement(w, null, o.a.createElement(T, null, s.fbt._({
						"*": "{point count} points",
						_1: "1 point"
					}, [s.fbt._plural(n, "point count", Object(l.b)(n))], {
						hk: "PNZhd"
					})), o.a.createElement(N, null), o.a.createElement(T, null, B(e)))
				},
				B = e => {
					const {
						post: t,
						shouldOpenPostInNewTab: n
					} = e, {
						numComments: r
					} = t;
					return o.a.createElement(a.a, {
						"data-click-id": "comments",
						to: Object(c.a)(t.permalink, !0),
						target: n ? "_blank" : void 0
					}, s.fbt._({
						"*": "{comment count} comments",
						_1: "1 comment"
					}, [s.fbt._plural(r, "comment count", Object(l.b)(r))], {
						hk: "xPYWL"
					}))
				},
				q = e => o.a.createElement(A, null, o.a.createElement(f.b, {
					post: e.post
				}))
		},
		"./src/reddit/components/CrosspostRecommendationsModal/constants.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = "crosspost_recommendations_modal_id",
				r = 3e3
		},
		"./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return g
			})), n.d(t, "b", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/constants/index.ts"),
				a = n("./src/reddit/constants/experiments.ts"),
				d = n("./src/reddit/constants/localStorage.ts"),
				c = n("./src/reddit/hooks/useExperimentVariant.ts"),
				l = n("./src/reddit/hooks/useLocalStorage.ts"),
				u = n("./src/reddit/hooks/useMounted.ts"),
				m = n("./src/reddit/selectors/platform.ts"),
				p = n("./src/reddit/selectors/subreddit.ts"),
				b = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/constants/safety.ts"));
			const f = new Set([b.a, "t5_2vqun", "t5_2xhvq", "t5_2qq5c", "t5_2qjdm", "t5_2qh1i", "t5_2rawz", "t5_2yuqy", "t5_47waaj", "t5_2wnotk", "t5_2qh3p", "t5_3hapm", "t5_33rc6", "t5_344be", "t5_3v7up4", "t5_3f1iq", "t5_2vgfw", "t5_2qh9a", "t5_2qh1e", "t5_50bwm0", "t5_2qh2p", "t5_2ql0i", "t5_2qh22", "t5_5cg50f", "t5_2t4jw", "t5_3ewb7t", "t5_2sl16", "t5_2qh41", "t5_2qq6g", "t5_2ssp7", "t5_2r8ic", "t5_rjlwy", "t5_2usfk", "t5_2r4eo", "t5_58fbe9", "t5_2qh6c", "t5_2w2s8", "t5_2vx1z", "t5_2xbci", "t5_3oeyf", "t5_2z3lg8", "t5_2t2rd", "t5_2qh33", "t5_2titd", "t5_2sxhs", "t5_2rs2k", "t5_rgzzt", "t5_2qh03", "t5_2958ax", "t5_2r4oc", "t5_2snuku", "t5_2vgi4", "t5_2qmox", "t5_2wlnp", "t5_2tk0s", "t5_2ubgg", "t5_2qh4r", "t5_2xrd1", "t5_2eni6u", "t5_2qm4e", "t5_2qh61", "t5_57pe63", "t5_4w57kk", "t5_rd99n", "t5_2zcp2", "t5_2tasy", "t5_2xzpo", "t5_2ti4h", "t5_3894o3", "t5_39v20", "t5_3cb2g", "t5_2s0fe", "t5_2qio8", "t5_2t4pz", "t5_30m5u", "t5_3zxvgu", "t5_2hmn0j", "t5_2qioo", "t5_2ranw", "t5_40k36t", "t5_2t7hh", "t5_3jekq", "t5_3ggkdx", "t5_5tzdsj", "t5_2qh72", "t5_2teac", "t5_2xvo6s", "t5_2qhn7", "t5_2qi4z", "t5_2tbbg", "t5_2s3qj", "t5_2g026p", "t5_2qo2a", "t5_5lllzk", "t5_2sr21i", "t5_2qh2b", "t5_2s25d", "t5_2u5oo", "t5_2r8c5", "t5_44yhot", "t5_2qhv7", "t5_2rpe6", "t5_2qh1o", "t5_3j2jr", "t5_2si92", "t5_2qhb1", "t5_2qhrv", "t5_2qkya", "t5_2skrs", "t5_2sqznr", "t5_324pd", "t5_38949v", "t5_2qh3s", "t5_2to41", "t5_2qrt0", "t5_3896qi", "t5_2qhnk", "t5_2s96i", "t5_2qh6e", "t5_2we4j", "t5_2sgp1", "t5_2ea3gc", "t5_3aq6o", "t5_2abobh", "t5_33rff0", "t5_2s4kl", "t5_2hmm18", "t5_2qhr7", "t5_2uqch", "t5_2s837", "t5_2uc6j", "t5_2dbca9", "t5_2tjde", "t5_4m0kl5", "t5_4428an", "t5_34fkk", "t5_4vq2lk", "t5_2r4b9", "t5_42kuwz", "t5_2s887", "t5_2qhn5", "t5_2vq0w", "t5_2sebk", "t5_2qhs6", "t5_2qsp9", "t5_2f8e5i", "t5_2xks2", "t5_3nl4m8", "t5_2h5fm5", "t5_3yli2s", "t5_2s90n", "t5_2qh8e", "t5_2qhta", "t5_3jqiry", "t5_3bcod", "t5_2u05j", "t5_2qi6d", "t5_2w31t", "t5_3a4la3", "t5_2qls5", "t5_5pnfwg", "t5_4fkoof", "t5_2fwo", "t5_11aylv", "t5_2coav3", "t5_h6ov9", "t5_2sxwp", "t5_38qlm", "t5_2qhuq", "t5_28vmbp", "t5_2qh44", "t5_38oz1", "t5_3b5at", "t5_5is4yo", "t5_54ytpa", "t5_2qh4a", "t5_2sxmq", "t5_2ql8s", "t5_2vh2s", "t5_2qhon", "t5_2uell", "t5_2p7prz", "t5_2qvi5", "t5_2qh2n", "t5_yk18k", "t5_12p4l2", "t5_2wbww", "t5_2obn7g", "t5_22hlov", "t5_2qu9w", "t5_2uah7", "t5_5wkihl", "t5_2sbq3", "t5_2qtr8", "t5_hcycg", "t5_2qn2b", "t5_2tma3", "t5_3ovv9", "t5_39d7x", "t5_2qi0a", "t5_3grc9y", "t5_5s9wkm", "t5_2tthi", "t5_2rsc6", "t5_2qh65", "t5_2si5v", "t5_2qh7f", "t5_2qhze", "t5_2qmeb", "t5_2trig", "t5_2rm4d", "t5_2qhm7", "t5_430bn4", "t5_2cmdht", "t5_2zf9m", "t5_2vv1m", "t5_30cz1", "t5_2scmr", "t5_2qpzs", "t5_5r493w", "t5_2qkmn", "t5_2sa3m", "t5_2qixk", "t5_2rnve", "t5_2s3jo", "t5_2rd9v", "t5_2qhds", "t5_4m4vik", "t5_2yrq6", "t5_2qqqf", "t5_5r9xbe", "t5_2szyo", "t5_2rc71", "t5_22i0", "t5_2qimv", "t5_3jmre", "t5_2aeqy8", "t5_2wju0", "t5_2u5kl", "t5_rparc", "t5_2s90r", "t5_3f7in", "t5_2qztz", "t5_3pf5h", "t5_3hqta", "t5_2qn5f", "t5_2brl3f", "t5_2sr0ut", "t5_2yo6b", "t5_2qjpg", "t5_2w7mz", "t5_3pf09", "t5_3get9", "t5_2ug83", "t5_2qhn3", "t5_2sumo", "t5_2aci6g", "t5_3bnu9t", "t5_2qh3z", "t5_2skrn", "t5_2ql0k", "t5_2wthr", "t5_tgmci", "t5_273wgd", "t5_2qi4s", "t5_2qqt8", "t5_2ug54", "t5_2qhwg", "t5_2s73l", "t5_3yad57", "t5_24knsa", "t5_2qqdb", "t5_3aimx", "t5_2qkli", "t5_2r1q4", "t5_2evezl", "t5_2qszq", "t5_2qhvf", "t5_xd00y", "t5_2rw42", "t5_2pwj7t", "t5_2xtuc", "t5_1068vi", "t5_2sa8b", "t5_2qrqw", "t5_2r1b9", "t5_3w22c3", "t5_6796bw", "t5_2qlit", "t5_3g645", "t5_2r5kb", "t5_2tlqg", "t5_2x6sl", "t5_2usvo", "t5_3k11a", "t5_2s0w5", "t5_qs1n3", "t5_2xjsd", "t5_2s5oq", "t5_2u06v", "t5_2rz8w", "t5_5gh8sc", "t5_2sf2b", "t5_32eoz", "t5_2y3st", "t5_2qscu", "t5_3g7sw", "t5_2sc5r", "t5_39009", "t5_2r9vp", "t5_5o25t2", "t5_5ewqra", "t5_r1l2z", "t5_2tvg8", "t5_2quts", "t5_3nbzd", "t5_2qs08", "t5_28h1wz", "t5_2rb9g", "t5_2r3gv", "t5_2woql", "t5_2sode", "t5_2sfn3", "t5_3ipa1", "t5_22x5u9", "t5_hw1ju", "t5_32fvb", "t5_2qipl", "t5_2qi1r", "t5_2qhkh", "t5_3e8zd", "t5_2qh1u", "t5_2tzxj", "t5_3is4uo", "t5_2v6xn", "t5_2una1", "t5_muxm6", "t5_32jqy", "t5_2eoi44", "t5_2r5hw", "t5_2s8su", "t5_3h4zq", "t5_vsh00", "t5_2rgos", "t5_3eb8a", "t5_2qimy", "t5_3463p", "t5_5k4q91", "t5_2qpro", "t5_qsuox", "t5_35hao", "t5_2rjsc", "t5_2qhix", "t5_2udts", "t5_2qhjq", "t5_2mzyu2", "t5_2r5rp", "t5_2ryfy", "t5_39qgx", "t5_29numb", "t5_2s64h", "t5_3n3op", "t5_2r95q", "t5_2r8xk", "t5_2qwzb", "t5_2y44y", "t5_3noa4", "t5_o7cng", "t5_2xv6d", "t5_2qj5n", "t5_2rrf9", "t5_2tj2f", "t5_2t2qe", "t5_2sa7z", "t5_347fo", "t5_2rld6", "t5_29ddrl", "t5_37pvij", "t5_3ht28", "t5_2seeu", "t5_2qyof", "t5_2ruhk", "t5_37vko", "t5_2semr", "t5_2qi79", "t5_2qpaw", "t5_2sluh", "t5_3lacy", "t5_2qhlc", "t5_2sqqh", "t5_2rglh", "t5_2sft5", "t5_2quw1", "t5_3m9q1", "t5_2qici", "t5_2rfq0", "t5_2trs5", "t5_2tdzg", "t5_2scup", "t5_2qupj", "t5_2tfso", "t5_2qiud", "t5_4qkqf1", "t5_2qh7a", "t5_ohe0i", "t5_2qh13", "t5_2y4t5", "t5_2w67q", "t5_2vmuo", "t5_2zm7m", "t5_3jk9vd", "t5_2fpyeh", "t5_2qyei", "t5_2r121", "t5_320gp", "t5_2r067", "t5_2xn7q", "t5_3l4bg9", "t5_2qmhd", "t5_3da7e", "t5_2x71s", "t5_67kjud", "t5_2s3i3", "t5_2stl8", "t5_3iyfvr", "t5_2s5ty", "t5_2qh1f", "t5_2roj4", "t5_2s19fz", "t5_2r6t5", "t5_37g5b", "t5_13psmh", "t5_2st2l", "t5_2rlhe", "t5_2j3zuu", "t5_2w6wd", "t5_2qh2a", "t5_5rj68d", "t5_2qi2g", "t5_2rm6u", "t5_2r7ih", "t5_4x18eu", "t5_2shdt", "t5_2y8zl", "t5_3fb5x", "t5_33o0p", "t5_2wqz8", "t5_2s8fe", "t5_2quww", "t5_2qhh9", "t5_4ub23i", "t5_34mtg", "t5_2qscv", "t5_2qh1n", "t5_3bx7j", "t5_10to4u", "t5_43k5vb", "t5_3fhf0", "t5_2qi09", "t5_2ssny", "t5_2sngy", "t5_2qx4j", "t5_3531l", "t5_2qho4", "t5_qzksz", "t5_2xxyj", "t5_2qp6s", "t5_2v630", "t5_2wmnh", "t5_2cn1kk", "t5_3225u", "t5_2qnvz", "t5_3g2n6", "t5_2s8vl", "t5_2u489", "t5_2xp02", "t5_2hrvzr", "t5_3jj03", "t5_2sgwl", "t5_2ub9j", "t5_2qpqt", "t5_3ccfx", "t5_2uao3", "t5_2usxq", "t5_2r1ky", "t5_2rgjh", "t5_2rsav", "t5_66fnwh", "t5_678esn", "t5_678dw5", "t5_678dgg", "t5_678ec7", "t5_2re8c", "t5_67q63p", "t5_24mspm", "t5_5y1j4m", "t5_2q2lyu", "t5_4d5r0s", "t5_23vhbm", "t5_kylwj", "t5_293bzh", "t5_2re84", "t5_27aw4q", "t5_ybxe4", "t5_43ec6r", "t5_60y3t8", "t5_61nzil", "t5_3901x", "t5_2wd8z", "t5_25v3za", "t5_5v1iee", "t5_4h08zt", "t5_53typ1", "t5_34n9m", "t5_2za34", "t5_33xiv9", "t5_5eyo2f", "t5_qrkm3", "t5_2u0p3", "t5_huno9", "t5_23w961", "t5_4do9fz", "t5_2rga6", "t5_3op5a", "t5_29cxhr", "t5_3mglp", "t5_61limv", "t5_5en0eb", "t5_2u7c6", "t5_2hmro2", "t5_5hbxod", "t5_5n8ww2", "t5_348l4", "t5_3k5eop", "t5_2bf4a0", "t5_4dbf4z", "t5_3ub122", "t5_29ott5", "t5_4kedf9", "t5_32vkhs", "t5_5hdcv8", "t5_50ewnu", "t5_2sn3b", "t5_4u64g2", "t5_678vz4", "t5_2kpnnx", "t5_2qxh7", "t5_2xd8b", "t5_3ycdtm", "t5_wtzlf", "t5_2sag0", "t5_2e9wp1", "t5_2wlawa", "t5_377af", "t5_3v50ar", "t5_2zj24", "t5_5jw6hr", "t5_4t6fim", "t5_3hn0l", "t5_56po8j", "t5_wz86i", "t5_33dd6", "t5_2tvb27", "t5_2v8hb", "t5_47fyev", "t5_2qh8b", "t5_2ybkp8", "t5_2dggmf", "t5_26j53o", "t5_2urg0", "t5_12ufgy", "t5_3k4ht", "t5_xnpae", "t5_2jdk0n", "t5_2zw6a3", "t5_3xq5dc", "t5_39xntr", "t5_5k9u0g", "t5_41nqvr", "t5_54x0i0", "t5_3kd7f", "t5_3pdcwf", "t5_4jnuft", "t5_2rlgy", "t5_4rmijz", "t5_2e3asi", "t5_2seir", "t5_23obpw", "t5_ssd9i", "t5_5sauk2", "t5_2ca3vn", "t5_2r7yd", "t5_st6yv", "t5_250hvx", "t5_2u35xi", "t5_4ijhpi", "t5_1332lo", "t5_3fvmra", "t5_2y2sle", "t5_35z3c", "t5_2vxmcd", "t5_46qkzs", "t5_y9x67", "t5_2pnjve", "t5_x733t", "t5_2sntun", "t5_36p4d", "t5_2yzi6", "t5_53am47", "t5_go8um", "t5_311qr", "t5_3plw4n", "t5_39jdhw", "t5_2rbd9", "t5_13u0jo", "t5_2u8rdy", "t5_fxvbq", "t5_2u1ecy", "t5_3i6ji", "t5_2otxt7", "t5_3n68h", "t5_40x3ov", "t5_2qiuc", "t5_2tqlz", "t5_2sptq", "t5_go8hs", "t5_27siyz", "t5_2dxl9v", "t5_2wsfj", "t5_67r213", "t5_2d1bgq", "t5_423ry8", "t5_3zthc3", "t5_2qx81", "t5_4e86x9", "t5_3cx8ou", "t5_2s3lm", "t5_2xv16b", "t5_3j3mc", "t5_2bc9ia", "t5_2t5536", "t5_58kl24", "t5_2rgab", "t5_62153q", "t5_2r11p", "t5_2ktwai", "t5_3f9ug", "t5_wnlea", "t5_38qej", "t5_5vf8xn", "t5_2e7q21", "t5_346jr", "t5_2keo17", "t5_2a09jf", "t5_67wtjq", "t5_vt09k", "t5_2arfba", "t5_2s7d1", "t5_fpjmr", "t5_2hd2en", "t5_3b7g7d", "t5_3nnfk", "t5_24cnjd", "t5_2w9c6", "t5_2w1hp", "t5_5m0dj2", "t5_32yr7", "t5_2qhi6", "t5_2whov9", "t5_31b2m", "t5_3dccxi", "t5_30jzq", "t5_3d31dv", "t5_2y4zl", "t5_fmlr4", "t5_3xp2ez", "t5_3400c", "t5_2u3s2d", "t5_2wih4", "t5_8df0t", "t5_27kzmk", "t5_4cztsf", "t5_5qlhhl", "t5_45gonu", "t5_34lr2j", "t5_4alysl", "t5_2re3s", "t5_3bew3c", "t5_50xlmj", "t5_pts06", "t5_4wdda5", "t5_5hljia", "t5_2tino", "t5_2sfysp", "t5_4jpt4o", "t5_3frup", "t5_2l09mw", "t5_4esddx", "t5_41fccg", "t5_2r8z1p", "t5_51qjr4", "t5_59ay94", "t5_2y9ju", "t5_2rh4c", "t5_2ryzy", "t5_3lor7", "t5_3z8y83", "t5_3mqatu", "t5_l5iel", "t5_2fe124", "t5_682yx2", "t5_3qq2qy", "t5_3sb1ky", "t5_67d8ga", "t5_2u8g3", "t5_3d3i7", "t5_31hhzn", "t5_36u3z", "t5_446eq8", "t5_2z258", "t5_2qnef", "t5_3rmjxf", "t5_3ecck", "t5_2vbk7", "t5_34xato", "t5_2zigs", "t5_39uv3", "t5_2plhpc", "t5_3ji6p", "t5_rsal1", "t5_2qz7g", "t5_4r8dta", "t5_2rfqv", "t5_2yh9c", "t5_536484", "t5_2st7f", "t5_2rw0n", "t5_4a3prn", "t5_2ql97", "t5_325lr", "t5_2vfzu", "t5_2jn4v6", "t5_luco6", "t5_3eysbt", "t5_5067hi", "t5_2s0lb", "t5_2qoih", "t5_l00gg", "t5_2i0p6a", "t5_5c9fh9", "t5_2r9po", "t5_2apgk0", "t5_31aao", "t5_4cl4lc", "t5_68en4s", "t5_2il0qt", "t5_5tsbcn", "t5_67plqe", "t5_mvs2x", "t5_3bcj5l", "t5_2q8oas", "t5_3j8d7", "t5_2k45bp", "t5_3gg04", "t5_46sx0z", "t5_2lm9ic", "t5_5l5plc", "t5_38s0f", "t5_2t0eg0", "t5_3hgrge", "t5_3rsfy8", "t5_2rpyj", "t5_39rpp1", "t5_4jj409", "t5_2aqkjg", "t5_5khd31", "t5_3k5w18", "t5_2qkb5", "t5_39lih", "t5_2wq8b", "t5_34sili", "t5_5ttzw5", "t5_4awjzu", "t5_2t1jq", "t5_2rg06", "t5_2t9bx", "t5_2qpcz", "t5_2rd6n", "t5_2diucu", "t5_2wgrn", "t5_682yeu", "t5_4y8kcc", "t5_2exuuh", "t5_2rvgsr", "t5_32r9r", "t5_5xauvq", "t5_66lfqj", "t5_67juje", "t5_61ne6o", "t5_3154l", "t5_12190u", "t5_5horm9", "t5_41brv9", "t5_3mv2j", "t5_2qhxu", "t5_5bk3s3", "t5_hjw89", "t5_2o613z", "t5_53bsy2", "t5_2uyz6", "t5_3mily", "t5_3oaez", "t5_2mz580", "t5_u6isd", "t5_5x054c", "t5_67s6z2", "t5_2xp2s", "t5_3o6r76", "t5_w42u9", "t5_31c1d", "t5_3ct3w", "t5_3c2d7", "t5_2afc6f", "t5_2grft2", "t5_3rtt80", "t5_619n47", "t5_3k7ez", "t5_2slrm", "t5_2sg5b", "t5_4wuune", "t5_kyzl1", "t5_2udig", "t5_2bhjdp", "t5_13aj6l", "t5_3fhq0", "t5_2u8bb", "t5_258mfq", "t5_xgrc3", "t5_3v5uwf", "t5_5n0xuu", "t5_3n0kw", "t5_2eg7z9", "t5_36uql", "t5_2zozr", "t5_29xu9m", "t5_dzi1v", "t5_55yl9x", "t5_2wxn64", "t5_h1zup", "t5_2hzhg1", "t5_2l990n", "t5_2zpb3", "t5_416ubq", "t5_5meks3", "t5_5htt18", "t5_2qj1l", "t5_2i6cuk", "t5_67fkho", "t5_4ao32n", "t5_2dyjf1", "t5_39i0r", "t5_5273ya", "t5_34jka", "t5_2rda3", "t5_2xw8u", "t5_12gq79", "t5_2qk6v", "t5_2djl95", "t5_587pdp", "t5_4479s5", "t5_39ply", "t5_zioft", "t5_2qiu1", "t5_2rcd1", "t5_3pf9ag", "t5_2qyds", "t5_2roa2", "t5_2x24x", "t5_5kvlv4", "t5_3g9cg5", "t5_2y9q6", "t5_2qhcs", "t5_2qhr0", "t5_36dp4", "t5_2r6jl", "t5_2r9ix", "t5_54f5xj", "t5_2qh7i", "t5_3jjfr", "t5_4mtlrs", "t5_5awjen", "t5_3gvlj2", "t5_2u4eg", "t5_5qkg7g", "t5_66u4p2", "t5_2qlqh", "t5_2qm4f", "t5_4ttiyf", "t5_3ax4r", "t5_26mowr", "t5_2w3o9", "t5_4zcqg0", "t5_2smwo", "t5_679c9b", "t5_m7gkr", "t5_46gnwd", "t5_61yc0h", "t5_yu550", "t5_2rv05", "t5_4h87sk", "t5_5u87kz", "t5_2osswr", "t5_11v6xc", "t5_2j6d7j", "t5_38c6g", "t5_2v102", "t5_2q9n1z", "t5_3bopf", "t5_2sdjj", "t5_3pvrg", "t5_33an9", "t5_2s5rz", "t5_2ukv2", "t5_3g7hb", "t5_2spc8y", "t5_27ad5v", "t5_3mwoo5", "t5_687o7f", "t5_2dcgnu", "t5_5qfd0b", "t5_4dflob", "t5_2s4hr", "t5_2uaqs", "t5_44dksf", "t5_2wfy8", "t5_5imww7", "t5_3ormpy", "t5_27ylfy", "t5_33209", "t5_z550v", "t5_50zjjx", "t5_2tavu", "t5_2qkod", "t5_2k98zj", "t5_46bcum", "t5_2sxe1l", "t5_2r413", "t5_2qknc", "t5_4p4b7e", "t5_4fbqcn", "t5_2wwxo", "t5_2r6w9", "t5_2ql7e", "t5_2tny5", "t5_4wlug2", "t5_5nw6ol", "t5_2t96d", "t5_3l4ow", "t5_2rluz", "t5_2qh9x", "t5_2u7lz", "t5_2qmjp", "t5_23s94b", "t5_2qlsu", "t5_5mlfpt", "t5_mljgb", "t5_59jim6", "t5_3jarei", "t5_625or4", "t5_3r5kro", "t5_47zvgc", "t5_2sjnp", "t5_5tj24w", "t5_2vlxi", "t5_2hcp09", "t5_2oaeb3", "t5_299zdc", "t5_37469", "t5_x90qh", "t5_2ko2rp", "t5_57geyh", "t5_2gv80k", "t5_2qnri", "t5_3m02zb", "t5_2ieexa", "t5_2o8nq3", "t5_3g7rd", "t5_h6oc0", "t5_2hb1tv", "t5_475kvw", "t5_34gw00", "t5_3gwf7", "t5_418aua", "t5_2p2ttp", "t5_2p9skc", "t5_5dz2we", "t5_34l6y", "t5_eysl9", "t5_53bzyh", "t5_5e3jd5", "t5_5ar5yt", "t5_jtcp1", "t5_2vqof", "t5_2o1vqe", "t5_2nge6y", "t5_5cf8bh", "t5_4cuzgo", "t5_2vhlq", "t5_411cws", "t5_5vu13d", "t5_5sxuai", "t5_3fe58", "t5_679jg4", "t5_12yjtw", "t5_456aqk", "t5_2qjc8", "t5_2a0hlv", "t5_2jfiwv", "t5_2sw7y", "t5_2gxonr", "t5_4oqycg", "t5_2rv5s", "t5_2yoer", "t5_y2gd2", "t5_4ydda8", "t5_41t66w", "t5_2szwj", "t5_45cq5k", "t5_2coldc", "t5_687r6x", "t5_31naw", "t5_2p7wes", "t5_2qjon", "t5_4akaa7", "t5_5a111l", "t5_2w333", "t5_2qk80", "t5_2qhdf", "t5_2stj6", "t5_13bsg7", "t5_233jor", "t5_pcxm7", "t5_2qrjj", "t5_2sa9u", "t5_10xbng", "t5_2t61d", "t5_vgt2z", "t5_5a0v9j", "t5_58pdcr", "t5_61bxvy", "t5_4m5n6a", "t5_2am73k", "t5_2qpxi", "t5_4zqbbi", "t5_2ruhy", "t5_27t6v0", "t5_2qkby", "t5_2ri38", "t5_2yfo0", "t5_3p4cc", "t5_2qhe8", "t5_2rcjg", "t5_3az7x", "t5_2qore", "t5_37saz", "t5_2qhlj", "t5_2uni5", "t5_2qupf", "t5_2xv4m", "t5_46kulq", "t5_671lom", "t5_4crl0v", "t5_3gbvn", "t5_123tln", "t5_2xd5z", "t5_2zald", "t5_2tv3h", "t5_4w6vi1", "t5_2tzir", "t5_q21go", "t5_32vpkn", "t5_adf18", "t5_2g94rz", "t5_4fohwp", "t5_45e57e", "t5_2vxxc", "t5_3d95h", "t5_3gd95z", "t5_4j5z8g", "t5_2vwxh", "t5_3hz8p", "t5_2q7cco", "t5_4hhpe9", "t5_3kdas", "t5_2qi4j", "t5_4h9ug5", "t5_31f2w", "t5_4ga7kf", "t5_4gmpyo", "t5_f05b2", "t5_3noc5", "t5_2ripd", "t5_304ot", "t5_51t565", "t5_swxxz", "t5_2rkcn", "t5_2rzo0", "t5_4ib416", "t5_4ix0xt", "t5_3k2ts", "t5_2x4yx", "t5_3uqe5a", "t5_4camlk", "t5_4ems6i", "t5_3vy3h7", "t5_3equt", "t5_3od9i", "t5_2tel8", "t5_31u57f", "t5_4ggpqh", "t5_46rd1t", "t5_3ndhf", "t5_2ea6kj", "t5_3loj0", "t5_4wpg07", "t5_hq8nz", "t5_4iqai1", "t5_4pjh6s", "t5_30ftw", "t5_4l87pr", "t5_3gtgj", "t5_37fce", "t5_3oh00", "t5_83sqa", "t5_5jgp65", "t5_31vhn", "t5_o2erj", "t5_4bja4", "t5_2ropd", "t5_44kteo", "t5_43nrxg", "t5_508slz", "t5_31chqy", "t5_3ur7np", "t5_28vyek", "t5_46ubz7", "t5_2wqq6", "t5_g49g0", "t5_35e7q", "t5_59gnlx", "t5_3v7rfm", "t5_3hjz7", "t5_2s5ti", "t5_3rbvfm", "t5_2wn4q", "t5_46wdw1", "t5_4g3dzu", "t5_4d6rd1", "t5_3ilam", "t5_4b0x3z", "t5_2rqr7", "t5_4ca6c6", "t5_opqm3", "t5_3jxda", "t5_4p3y75", "t5_2u9he", "t5_4g9whx", "t5_2rx4q", "t5_3fxu2", "t5_2un3n", "t5_2u0xf", "t5_3nhfo", "t5_4esxse", "t5_2w57u", "t5_2snq8", "t5_4alyxj", "t5_2qhpn", "t5_2qj7g", "t5_3hq52e", "t5_5a6p0o", "t5_if858", "t5_2qhht", "t5_4iplq8", "t5_4aylmi", "t5_43fveg", "t5_3p6mv", "t5_26tm5u", "t5_2w58p", "t5_32zriq", "t5_31rd4", "t5_ifkmw", "t5_hcs2n", "t5_4as3k9", "t5_3nx961", "t5_44jnm4", "t5_3pccn", "t5_3o0h8", "t5_4b7cs4", "t5_2u3hz", "t5_2wm0g", "t5_2s4gt", "t5_2szo3", "t5_muuww", "t5_dxc74", "t5_5bcz1d", "t5_4crwek", "t5_2qiib", "t5_3oemb", "t5_2hfzgg", "t5_2uvie", "t5_3779u", "t5_2qi0v", "t5_46w8j5", "t5_2au4lz", "t5_3ejnx", "t5_2rr0e", "t5_47niol", "t5_2zgq3", "t5_2ysyr", "t5_29g0pl", "t5_3u1ogh", "t5_46bnjs", "t5_2qhsa", "t5_2qh1s", "t5_hq6n1", "t5_3vpfzk", "t5_m0bnr", "t5_4507cc", "t5_3vnlab", "t5_2r40j", "t5_2qhcz", "t5_2ro3i", "t5_3jj6y", "t5_2qmkf", "t5_2qh4i", "t5_2qkd7", "t5_2v2cd", "t5_2qh0s", "t5_45hae8", "t5_3nwemq", "t5_2qh16", "t5_30y53", "t5_3ni6j", "t5_2soy6", "t5_2sl2k", "t5_2wele", "t5_2v6bc", "t5_3g3zk", "t5_2qorf", "t5_2sesz", "t5_2sgz7", "t5_2segs", "t5_2s5rf", "t5_mtkhg", "t5_2s4mc", "t5_2tt3v", "t5_2s9n5", "t5_3f5dt", "t5_2rch0", "t5_2qv0q", "t5_2qwnx", "t5_2r65t", "t5_2s1me", "t5_2qhef", "t5_2s8o5", "t5_2w3h8", "t5_2uczz", "t5_2ui5x", "t5_310nr", "t5_2qn08", "t5_2y8kx", "t5_2qj9g", "t5_2yfr0", "t5_2zctt", "t5_2rhee", "t5_2zqxm", "t5_31bxh", "t5_2qlac", "t5_2upx6", "t5_2ubfr", "t5_2qhlw", "t5_2ulof", "t5_2r81q", "t5_2wrvu", "t5_2t79l", "t5_2sog2", "t5_2qrwc", "t5_31lye", "t5_2t03a", "t5_2sej3", "t5_2se5q", "t5_22bt9u", "t5_2vz6k", "t5_2u80h", "t5_2qxpm", "t5_2rfec", "t5_11h46y", "t5_2qse3", "t5_2ssuv", "t5_2rqqs", "t5_2v8ow", "t5_31m9x", "t5_2snvh", "t5_2sa9a", "t5_2s8kf", "t5_2tlrr", "t5_2ys2j", "t5_3ers2", "t5_2sg5m", "t5_319vn", "t5_2qofe", "t5_2vizz", "t5_2rp0g", "t5_2qn7b", "t5_2xinb", "t5_2qh48", "t5_2snwr", "t5_2t7no", "t5_2frmc1", "t5_10aivo", "t5_57y853", "t5_2ukxe", "t5_346d4", "t5_2qht0", "t5_2qoqw", "t5_5ql5hz", "t5_2qyu0", "t5_2x2oy", "t5_2r78l", "t5_3c24l", "t5_2zmfe", "t5_2qi4f", "t5_p2bb3", "t5_2qi3u", "t5_2wsc9", "t5_27mtyi", "t5_2qt9x", "t5_5efpin", "t5_2qi2h", "t5_2xg8a", "t5_3948y", "t5_2y2gn", "t5_2h9x5r", "t5_2qqcs", "t5_2qh87", "t5_11ga7z", "t5_3oq6ou", "t5_3amv4", "t5_2snuc", "t5_2qs6s", "t5_2qt19", "t5_2qkoi", "t5_363r3", "t5_2tex6", "t5_2t34z", "t5_mvcq5", "t5_2i9ywa", "t5_3jxvk", "t5_2qh0f", "t5_2qrrq", "t5_3fmt2", "t5_2so9j", "t5_3nasz", "t5_38hd8", "t5_3lqsns", "t5_2tqtv", "t5_2qwza", "t5_26qkg5", "t5_2szl7", "t5_2ucno", "t5_2r8hf", "t5_38e1l", "t5_2tycb", "t5_2t5y3", "t5_2rfo4", "t5_32aef", "t5_2qhvk", "t5_2kchui", "t5_2mqpqw", "t5_54rawe", "t5_628spn", "t5_x72uq", "t5_3k2t0", "t5_3eg3f", "t5_2qpgr", "t5_2skqi", "t5_33vph", "t5_2w071t", "t5_2qtwb", "t5_3mnyi", "t5_3keit", "t5_2t5fu", "t5_2r7hk", "t5_3jwf7", "t5_2srr9", "t5_2vcl0", "t5_2rvuh", "t5_2s70u", "t5_2g8yh6", "t5_2weuu", "t5_2u2bh", "t5_3b749", "t5_352pm", "t5_3mdot", "t5_2x93b", "t5_2ror6", "t5_3jgrc", "t5_2smyd", "t5_3a3ge", "t5_3md1s", "t5_2qh18", "t5_2ue3h", "t5_a7wuv", "t5_2qjof", "t5_10xdjv", "t5_2qsev", "t5_2szvb", "t5_34bsb", "t5_3imzm", "t5_3c6l1", "t5_2r9tk", "t5_2t25p", "t5_2yusr", "t5_31k9i", "t5_2s14k", "t5_2qjdo", "t5_30c2m", "t5_2qs75", "t5_2sa88", "t5_2slp5", "t5_1n3oz0", "t5_3gcwj", "t5_48t85", "t5_ge6kz", "t5_2rg21", "t5_2s8lc", "t5_2qv7l", "t5_2qy0y", "t5_2u5un", "t5_3hrub", "t5_2v0i1", "t5_vkfjx", "t5_3mig2", "t5_2rfqf", "t5_2qh9k", "t5_481xkf", "t5_2s7yr", "t5_2ri8e", "t5_2s7tt", "t5_2vppf", "t5_2qs1d", "t5_2uquc", "t5_2s3m1", "t5_2w7w72", "t5_37dr6", "t5_2ve0h", "t5_2sfmf", "t5_3sulg5", "t5_9n2w1", "t5_2qntg", "t5_2qme3", "t5_2tja6", "t5_2s7w9", "t5_3ff8l", "t5_21ub0l", "t5_2w271", "t5_2ssp3", "t5_35g8o", "t5_3ns7i", "t5_2zczk", "t5_3i60n", "t5_4lu5z9", "t5_vlfm1", "t5_3ofkf", "t5_2thu0", "t5_2ty3s", "t5_2qs1t", "t5_2r81c", "t5_2rybx", "t5_9mwcy", "t5_2vrr5", "t5_40vgcm", "t5_2we9n", "t5_xnx04", "t5_36ocn", "t5_2xzai", "t5_2svzr", "t5_2r4jn", "t5_2r0ol", "t5_2qh39", "t5_2ws9i", "t5_3l98x", "t5_2tez8", "t5_2xdht", "t5_2t2oy", "t5_3j7rv", "t5_2xbpx", "t5_rczr0", "t5_2requ", "t5_2wyug", "t5_2si2q", "t5_2qgzg", "t5_3p0xk", "t5_29cqgc", "t5_32abf", "t5_5ve8q6", "t5_9d1wl", "t5_31h3t", "t5_2ykm6", "t5_2sjkv", "t5_2r2ad", "t5_jrw25", "t5_2vzrv", "t5_2qp7z", "t5_2cjo4y", "t5_2rmkc", "t5_2tc73", "t5_2w7pi", "t5_3iqcz", "t5_2zfhy", "t5_n8im4", "t5_27hnjr", "t5_2r1sf", "t5_3fxxb", "t5_39x1d", "t5_2x8ez", "t5_2qhyi", "t5_30k9i", "t5_2xcv7", "t5_2zay0", "t5_3adlm", "t5_2v28g", "t5_2s2wi", "t5_2ro2c", "t5_2s7xv", "t5_3fu2l", "t5_2rgdr", "t5_388rp", "t5_38r3o", "t5_2tgj4", "t5_2z97c", "t5_2qihd", "t5_2qldo", "t5_3l2acu", "t5_2r4wn", "t5_3616u", "t5_3ckoa", "t5_2vroe", "t5_33cpo", "t5_2w5x9", "t5_3mchb", "t5_2r6ex", "t5_2s28b", "t5_2iokxd", "t5_39dpu", "t5_2yfmo", "t5_2typu", "t5_2qim4", "t5_h4uwp", "t5_2qjfk", "t5_2u559", "t5_2qka0", "t5_1a98wj", "t5_3ta5rx", "t5_5n5ohh", "t5_2f4l19", "t5_2qr7i", "t5_37o2hz", "t5_30c1v", "t5_x3t3a", "t5_p49x6", "t5_3ad1fs", "t5_3pmoe", "t5_336mg", "t5_2sxk3", "t5_2ku98s", "t5_117wt6", "t5_2skj2", "t5_35g9w", "t5_2hrykq", "t5_2qhe0", "t5_2viue", "t5_2s9o3", "t5_3oh4c", "t5_5y8ivk", "t5_2s8hg", "t5_3k7eh", "t5_2sil5", "t5_26rn4p", "t5_2qx19", "t5_4bhj60", "t5_2qn0o", "t5_2ri6s", "t5_233710", "t5_3ug1ww", "t5_2qhv6", "t5_2hy5hz", "t5_2xpx7", "t5_32eja", "t5_2ugup", "t5_335xe", "t5_3ibim", "t5_3ja4m", "t5_2vegg", "t5_2rr4m", "t5_2qh6d", "t5_35gtc6", "t5_5r98w", "t5_2tgrb", "t5_2tw1s", "t5_33zyg", "t5_2rvej", "t5_2rt31", "t5_2qlg0", "t5_2te5l", "t5_h8w2f", "t5_2qlve", "t5_s9t4y", "t5_3ffya", "t5_2qo29", "t5_vf2", "t5_2p976a", "t5_2r117", "t5_2v0p0", "t5_327ub", "t5_2t9mw", "t5_33y6y", "t5_2r275", "t5_362yc", "t5_2qhkd", "t5_2veqb", "t5_2lf0bu", "t5_2yb8u", "t5_2qi0s", "t5_2tqi0", "t5_3iggi", "t5_3d3xj", "t5_2qjo5", "t5_2t3p6", "t5_2t0no", "t5_3cv6y", "t5_3zv3z0", "t5_2qo41", "t5_2vemj", "t5_5vinfe", "t5_2r4yl", "t5_462zhn", "t5_3ho76", "t5_31l6u", "t5_2s4cn", "t5_4k3gid", "t5_2gl58y", "t5_2st00", "t5_2skiq", "t5_najga", "t5_2sf6w", "t5_34o9s", "t5_37a7m", "t5_2reol", "t5_2qoof", "t5_2t93w", "t5_2reee", "t5_vp2cd", "t5_37fyau", "t5_2rb5s", "t5_nngwo", "t5_3bulc2", "t5_2qhe6", "t5_2qmah", "t5_wyo9z", "t5_2qyth", "t5_34fyw", "t5_2soa5", "t5_2qj2l", "t5_dyqlw", "t5_2qtd1", "t5_2goljt", "t5_2qi1m", "t5_2tteh", "t5_xkt2h", "t5_2vcez", "t5_2t8su", "t5_3kd2i2", "t5_2ya42", "t5_3bwcw", "t5_3buh7", "t5_fc76s", "t5_2rptq", "t5_3ji03", "t5_2qgzt", "t5_2t8ya", "t5_3j5jx", "t5_2scyp", "t5_2qhb8", "t5_2xvjg", "t5_2qjmw", "t5_2sba6", "t5_3rlxu8", "t5_63ekhg", "t5_386zh", "t5_2qhqk", "t5_2s3uz", "t5_3blr7", "t5_3gmxe", "t5_2ysnf", "t5_2qkcl", "t5_2qh95", "t5_2vhg0", "t5_2qwvc", "t5_2sg7u", "t5_66fxvv", "t5_2r0bp", "t5_2qhrs", "t5_2qktn", "t5_22y335", "t5_gm2ug", "t5_2qh94", "t5_39mk7", "t5_2qo9i", "t5_3mrre", "t5_3cr3o", "t5_3nf1h9", "t5_3deqz", "t5_2y6ap", "t5_2hnraa", "t5_2rsj3", "t5_37lz8d", "t5_2uv7l", "t5_sx610", "t5_26y265", "t5_ugl30", "t5_32d3r", "t5_3md7s", "t5_k2lq4", "t5_2qtnt", "t5_38d8b", "t5_zgpel", "t5_2x42i", "t5_2s7wa", "t5_56ml5q", "t5_2r5of", "t5_2rpn6", "t5_2wn8y", "t5_1b9104", "t5_23mf5j", "t5_2s7yf", "t5_3lflvh", "t5_mh1fw", "t5_2qhii", "t5_2rrdy", "t5_32qnb", "t5_2xrxs", "t5_2t7vk", "t5_3mgxy", "t5_2qt3b", "t5_2z5sl", "t5_2u9xs", "t5_34i5y", "t5_3k6uh", "t5_2rfbh", "t5_2zqu2", "t5_2rial", "t5_2s4tv", "t5_2qkt4", "t5_39ou5", "t5_lrajx", "t5_2qh3b", "t5_2xjxs", "t5_2y920", "t5_yt6in", "t5_2snvr", "t5_2r6ca", "t5_gdma4", "t5_2qnub", "t5_3f7q5", "t5_458lb9", "t5_390mn", "t5_292mjx", "t5_2qk68", "t5_2qhqt", "t5_2sf9e", "t5_2qmhl", "t5_2qimh", "t5_2scn1", "t5_3fn31", "t5_28b334", "t5_2vrf0", "t5_2sw61", "t5_2qj2e", "t5_vko1y", "t5_2y5ib", "t5_29af8l", "t5_u1y3f", "t5_2whne", "t5_2t776", "t5_3i3yf", "t5_2ssrn", "t5_2qi32", "t5_2qpf2", "t5_mf29x", "t5_3boqz", "t5_2wptd", "t5_jfaop", "t5_2xv8l", "t5_3wnb0m", "t5_i7p64", "t5_2sg7t", "t5_3nsi0", "t5_3e6ue", "t5_3bkmw", "t5_3s0jg6", "t5_2tekq", "t5_3a1w1g", "t5_2sk1i", "t5_3cyx2p", "t5_2wjav", "t5_357tq", "t5_2uo4e", "t5_2r6rj", "t5_xtjlv", "t5_2qh69", "t5_2s65y", "t5_2vyus", "t5_2xd5g", "t5_2zkms", "t5_2tnu7", "t5_28ln0r", "t5_2t21g", "t5_3blco", "t5_to643", "t5_2s8gi", "t5_3mj3w", "t5_2qhrg", "t5_3fvkh", "t5_2l3hm0", "t5_55t84q", "t5_2w6aj", "t5_2re9h", "t5_2ykcc", "t5_2t10o", "t5_2svhp", "t5_2wb7y", "t5_2qnu5", "t5_5wncl5", "t5_2wfjv", "t5_k688v", "t5_2qh4u", "t5_2qie6", "t5_2s8d6", "t5_39lft", "t5_2qhu7", "t5_2qsfi", "t5_3eye9", "t5_w5oni", "t5_2sbkg", "t5_2qi2x", "t5_2wfy7", "t5_2qq24", "t5_3om85", "t5_2qu6q", "t5_506nnd", "t5_jewb9", "t5_2s599", "t5_2qts0", "t5_2r40o", "t5_2s53a", "t5_2qh96", "t5_gsxgd", "t5_3kh5d", "t5_2tfa4", "t5_3p8bds", "t5_2sepf", "t5_2rpor", "t5_34cyw", "t5_2rq1q", "t5_52g0qx", "t5_2sgxv", "t5_3fkyp", "t5_2r77k", "t5_38eua", "t5_28qub8", "t5_33726", "t5_xtf6x", "t5_3667v", "t5_2tkn9", "t5_2tq8v", "t5_2qm0x", "t5_2zzm9", "t5_kemed", "t5_2rec6", "t5_v6nji", "t5_2srow", "t5_2v7cj", "t5_3egmz", "t5_2stq9", "t5_2sb2e", "t5_2wbvb", "t5_2r94o", "t5_10gh3w", "t5_2yyht", "t5_mbn0j", "t5_2qhx7", "t5_2skgl", "t5_397x6", "t5_2qi50", "t5_2s2ja", "t5_358dh", "t5_5wpvfp", "t5_2q729e", "t5_2qn2o", "t5_2tluu", "t5_3ph1a", "t5_rdw2p", "t5_2w5pf", "t5_2r6sq", "t5_2u0zn", "t5_1387r9", "t5_2s5wp", "t5_2s6v6", "t5_3kcu1", "t5_2ra0i", "t5_2kvan3", "t5_2qhs7", "t5_2xiaq", "t5_3fjqo9", "t5_2rske", "t5_2rbms", "t5_35mye", "t5_2s53b", "t5_2xuj2", "t5_2qjl8", "t5_2u1if", "t5_2uctx", "t5_2qpp6", "t5_2us0e", "t5_3o4xv", "t5_32szo", "t5_2s113", "t5_2qrpc", "t5_2reni", "t5_2qwze", "t5_2rsg9", "t5_2qhb2", "t5_2vnbs", "t5_2z5zk", "t5_2si9d", "t5_2smf4", "t5_2sqd6", "t5_2skff", "t5_2s9h3", "t5_2r0th", "t5_35gpe", "t5_2se6p", "t5_2c06gq", "t5_2uo3q", "t5_2tru8", "t5_3ohto", "t5_388p4", "t5_2vs1b", "t5_2rg2o", "t5_2z0nf", "t5_2qm8v", "t5_66er5h", "t5_4ze05o", "t5_pgruw", "t5_2zflu", "t5_3c9em", "t5_qmi8w", "t5_2n600a", "t5_u99v4", "t5_33yph", "t5_2irffv", "t5_2v5ap", "t5_2r612", "t5_2s1t9", "t5_2s5gj", "t5_36r7b", "t5_3gt83", "t5_2s8bl", "t5_3h0qh", "t5_3h5d7", "t5_3h5ee", "t5_29vcoe", "t5_2f68gx", "t5_2qh5b", "t5_3lgkx", "t5_3kapl", "t5_38hzu", "t5_2kzsbs", "t5_2swdx", "t5_3dp2xu", "t5_2r7a3", "t5_2rrbz", "t5_32viw", "t5_9ldsc", "t5_48vqi3", "t5_3pjkf", "t5_9y7rz", "t5_3tx7q5", "t5_2qlia", "t5_2ro52", "t5_2r8tu", "t5_2yvry", "t5_2s747", "t5_2rd5j", "t5_3a545", "t5_2udkc", "t5_33eqi", "t5_2sgxc", "t5_2qwyp", "t5_32lik", "t5_2re7h", "t5_2qq51", "t5_2tqcj", "t5_2seq5", "t5_2s6h3", "t5_4y2yf9", "t5_2xmrc", "t5_485woa", "t5_2s9pe", "t5_kltit", "t5_366ul", "t5_2sch7", "t5_2v9r7", "t5_gajhd", "t5_2qig3", "t5_zfhap", "t5_2s53c", "t5_39xxb", "t5_2s46r", "t5_3hb2y", "t5_31m25", "t5_2ydy9", "t5_2qlht", "t5_j34kt", "t5_2qi6i", "t5_2qjy5", "t5_2scjv", "t5_2vbgl", "t5_2rmgg", "t5_2xzlq", "t5_3fcze", "t5_2todf", "t5_2qiux", "t5_2sg4w", "t5_3fl43", "t5_36iafd", "t5_2qhnf", "t5_35fmc", "t5_2qm8s", "t5_2qq6z", "t5_23e19j", "t5_2w94s", "t5_2tk3x", "t5_2robf", "t5_p2wzd", "t5_2sgvi", "t5_2sb61", "t5_2sgq6", "t5_2su6x", "t5_2tr22", "t5_2rffi", "t5_2v7pv", "t5_2qhos", "t5_2uzej", "t5_2re2p", "t5_2qhmx", "t5_2qn7a", "t5_2r772", "t5_npfgx", "t5_id42i", "t5_2qhu3", "t5_398od", "t5_31bdc", "t5_3cx36", "t5_2qxpi", "t5_2qh9w", "t5_2r1ip", "t5_2rjd4", "t5_n9nn1", "t5_2ugo7", "t5_2qkaf", "t5_2qj02", "t5_mp3ji", "t5_3o6nf", "t5_3aa11", "t5_2s3xd", "t5_2shjt", "t5_3fr05", "t5_2w32w", "t5_2zkfk", "t5_31ubw", "t5_2xoy1", "t5_2rouz", "t5_2yo2z", "t5_2qpoa", "t5_2scbs", "t5_h1pmw", "t5_2tjzt", "t5_5nly97", "t5_4jpaxi", "t5_2sdlb", "t5_2sgxj", "t5_124gju", "t5_67tk8m", "t5_2trla", "t5_3h4mae", "t5_2clyih", "t5_2r749", "t5_2tn18", "t5_2saqe", "t5_3pmsxh", "t5_2scss", "t5_63eoyg", "t5_2ukcq", "t5_3n7fs", "t5_2tpgv", "t5_49thwj", "t5_2vtr4", "t5_34hkx", "t5_3e076", "t5_2xing", "t5_syz7q", "t5_3179l", "t5_31vmq", "t5_2rxrh", "t5_32i4z", "t5_3dtsvy", "t5_2w7mh", "t5_2s6ud", "t5_2tugx", "t5_2yfgl", "t5_2rtri", "t5_2t82m", "t5_2gpd6g", "t5_22i2", "t5_2u6rc", "t5_2rbr0", "t5_2r9c1", "t5_2xk6n", "t5_2tkvu", "t5_hyahj", "t5_2s1w0", "t5_2sks3d", "t5_2recr", "t5_2qoyi", "t5_2s7z5", "t5_321qi", "t5_2va15", "t5_2vlaz", "t5_2rdrs", "t5_2qphw", "t5_2r4wm", "t5_34fcy", "t5_33syo", "t5_2rtt2", "t5_2ugf9", "t5_3851f", "t5_2qj57", "t5_5z37g4", "t5_2rw7o", "t5_2qjt9", "t5_2txs6", "t5_37se4", "t5_2vyct", "t5_2shlm", "t5_4odw1y", "t5_2w28m", "t5_2tvlb", "t5_34e1h", "t5_2rynx", "t5_2qsbv", "t5_2rscc", "t5_2rhwp", "t5_2rlp9", "t5_2qxd2", "t5_2y8xf", "t5_2qiep", "t5_2ryfw", "t5_2qhd6", "t5_2c5lze", "t5_2rq9c", "t5_3ecrg", "t5_2qudv", "t5_2va9w", "t5_2rgo2", "t5_2sco1", "t5_2qyls", "t5_2s3oo", "t5_xwu0a", "t5_2rct2", "t5_yo4xr", "t5_35f67", "t5_2qy2j", "t5_2qrzu", "t5_2qn3a", "t5_2r4or", "t5_2spz2", "t5_2qs0k", "t5_5hbf3c", "t5_2td2i", "t5_2qhf9", "t5_2w1o0", "t5_2qhvj", "t5_2951j7"]);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function _() {
				return Object(c.a)(a.N) === a.Kd
			}

			function g() {
				return function(e) {
					let {
						storageKey: t,
						setValueOnDismiss: n,
						checkIfDismissed: s
					} = e;
					const r = _(),
						i = Object(o.e)(m.c),
						[a, c] = Object(l.a)(d.b.CROWD_CONTROL_CAMPAIGN_STORE, {}),
						b = Object(o.e)(e => Object(p.ab)(e, i)),
						h = Object(u.a)(),
						g = !(!i || !f.has(i)),
						v = !1 === (null == b ? void 0 : b.crowdControlFilter) && 0 === (null == b ? void 0 : b.crowdControlPostLevel),
						x = !s(a[t]);
					return {
						showCrowdControlCampaign: h && r && g && v && x,
						dismissCrowdControlCampaign: () => c({
							...a,
							[t]: n()
						})
					}
				}({
					storageKey: "hideModQueueCTAUntil",
					setValueOnDismiss: () => Date.now() + 30 * i.E,
					checkIfDismissed: e => !!e && Date.now() < e
				})
			}

			function v() {
				return {
					showCrowdControlCampaign: _()
				}
			}

			function x(e) {
				function t(t) {
					const {
						showCrowdControlCampaign: n
					} = v();
					return r.a.createElement(e, h({}, t, {
						showCrowdControlCampaign: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `CrowdControlCampaignNewTag(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less": function(e, t, n) {
			e.exports = {
				img: "_2j4blQAaYrPKIhe5jBJ9c8"
			}
		},
		"./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.m.less"),
				d = n.n(a),
				c = n("./src/reddit/icons/fonts/Gift/index.tsx"),
				l = n("./src/reddit/selectors/gold/awardIcon.ts"),
				u = n("./src/reddit/selectors/gold/purchaseCatalog.ts");
			t.a = e => {
				const t = Object(o.e)(u.b),
					n = Object(o.e)(e => Object(l.a)(e, {
						award: t,
						minSize: 32
					}));
				return t && n ? r.a.createElement("img", {
					alt: t.name,
					className: Object(i.a)(d.a.img, e.className),
					id: e.id,
					src: n
				}) : r.a.createElement(c.a, e)
			}
		},
		"./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NftProfileUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("vendors~Avatar~CryptoLibEthers~GovernanceTransferPointsModal~MarketplaceClaimModal~MarketplaceInFeed~1befd72a"), n.e("vendors~Avatar~ChatPost~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProfileUnit~RealtimeGQLSubscr~bfab320d"), n.e("vendors~Avatar~MarketplaceClaimModal~MarketplaceInFeedUnit~NftProfileUnit~SnoovatarModal"), n.e("NftProfileUnit")]).then(n.bind(null, "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/Marketplace/NftProfileUnit/index.tsx"
				}
			}, {
				ssr: !1
			});
			t.a = r
		},
		"./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "UserAchievementFlair",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("UserAchievementFlair").then(n.bind(null, "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/Econ/PowerupsFlair/UserAchievementFlair.tsx"
				}
			})
		},
		"./src/reddit/components/EditableImage/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_27zThB3Syksyv8gLdDJqep",
				container: "_27zThB3Syksyv8gLdDJqep",
				HitBox: "_1RlGOQJAoxE66cPOVTH0s",
				hitBox: "_1RlGOQJAoxE66cPOVTH0s",
				Image: "_1te2cn6lvn-YtGSv-hrM7g",
				image: "_1te2cn6lvn-YtGSv-hrM7g",
				ImageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				imageContainer: "_1z4A5-p2XgzMTJUEq3GaXu",
				ImageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				imageUploader: "_3oOZrOdvGjAOYvzKCu-Kjf",
				LoadingIcon: "_3syvcMeczod-NOIewWIb8n",
				loadingIcon: "_3syvcMeczod-NOIewWIb8n",
				EditButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				editButton: "_3A5WTC_rfbijxxWBmIP4Yx",
				profileCard: "eHsnwmpOgtfnBAgrWXQKq",
				EditIcon: "_3X4DuB4IpAlTY0XMdSI5q6",
				editIcon: "_3X4DuB4IpAlTY0XMdSI5q6"
			}
		},
		"./src/reddit/components/EditableImage/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ImageInput/index.tsx"),
				a = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/models/ApiRequestState/index.ts"),
				l = n("./src/reddit/components/EditableImage/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				let {
					altText: t,
					children: n,
					className: s,
					isProfileCard: l,
					isLoading: m,
					imageUrl: p,
					onFileSelected: b
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(u.a.Container, s)
				}, r.a.createElement("label", {
					className: u.a.HitBox
				}, r.a.createElement("span", {
					className: u.a.ImageContainer,
					role: "presentation"
				}, p ? r.a.createElement("img", {
					alt: t,
					className: u.a.Image,
					src: p
				}) : n), r.a.createElement(i.a, {
					className: u.a.ImageUploader,
					multiple: !1,
					onChange: e => {
						const t = Object(c.b)();
						b(e, t)
					},
					isPending: m
				}), !m && r.a.createElement("div", {
					className: Object(o.a)(u.a.EditButton, {
						[u.a.profileCard]: l
					})
				}, r.a.createElement(d.a, {
					name: "add_media",
					className: u.a.EditIcon
				}))), m && r.a.createElement(a.a, {
					className: u.a.LoadingIcon,
					sizePx: 80
				}))
			}
		},
		"./src/reddit/components/EmailInvitePaintedDoor/loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "EmailInvitePaintedDoor",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("EmailInvitePaintedDoor").then(n.bind(null, "./src/reddit/components/EmailInvitePaintedDoor/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/EmailInvitePaintedDoor/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/Emoji/index.m.less": function(e, t, n) {
			e.exports = {
				EmojiDisplay: "_2Gt13AX94UlLxkluAMsZqP",
				emojiDisplay: "_2Gt13AX94UlLxkluAMsZqP"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2A1Ng1fBxjU-qYqbEJn_sm",
				EventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventMetaWrapper: "_55hUWVhbF34AzbWr7SAMi",
				eventFollowButton: "_2XCKBYzBTZpjOAFEWv1tSy",
				isCompact: "_2gNxoOe_xKaMk0mmYMQCGs"
			}
		},
		"./src/reddit/components/EventPost/EventMetaHeader/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/eventTools/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/EventPost/PostEventMeta/index.tsx"),
				c = n("./src/reddit/components/PostFollow/index.tsx"),
				l = n("./src/reddit/helpers/postCollection.ts"),
				u = n("./src/reddit/helpers/postEvent.ts"),
				m = n("./src/reddit/components/EventPost/EventMetaHeader/index.m.less"),
				p = n.n(m);
			const b = a.a.div("EventMetaWrapper", p.a);
			t.a = e => {
				let {
					className: t,
					isCompactMode: n,
					post: s
				} = e;
				if (!Object(u.a)(s)) return null;
				const a = s && s.eventInfo,
					m = Object(l.a)(s),
					f = a && Object(i.c)(a.eventStart, a.eventEnd);
				return r.a.createElement("div", {
					className: Object(o.a)(p.a.container, t, {
						[p.a.isCompact]: !!n
					})
				}, r.a.createElement(b, {
					className: p.a.eventMetaWrapper
				}, r.a.createElement(d.a, {
					post: s
				}), !m && f && r.a.createElement(c.a, {
					className: p.a.eventFollowButton,
					post: s,
					isEventFollow: !0
				})))
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.m.less": function(e, t, n) {
			e.exports = {
				PostEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				postEventFutureText: "_3rtq7SfSLd-e5fAEgn373L",
				PostEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				postEventPastText: "_1j5EnaNrX7PuyCnmpT-8o0",
				PostEventNowText: "BGfronFwr_0rXxOJmxp10",
				postEventNowText: "BGfronFwr_0rXxOJmxp10",
				Container: "_3NIcD2Vr2xrSAq08U14kCy",
				container: "_3NIcD2Vr2xrSAq08U14kCy",
				CalendarIcon: "LEz3F0HfvMpdo96occzKU",
				calendarIcon: "LEz3F0HfvMpdo96occzKU",
				LiveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				liveIcon: "_3ArSA7Spw15WyF9ld4p6ZJ",
				LoadingState: "_27_KVVxYHZ7v44CE2vg8bT",
				loadingState: "_27_KVVxYHZ7v44CE2vg8bT"
			}
		},
		"./src/reddit/components/EventPost/PostEventMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/eventTools/index.ts"),
				i = n("./src/reddit/helpers/styles/mixins/loading.ts"),
				a = n("./src/reddit/icons/fonts/Calendar/index.tsx"),
				d = n("./src/reddit/icons/fonts/Live/index.tsx"),
				c = n("./src/reddit/components/HumanDate/index.tsx"),
				l = n("./src/reddit/components/EventPost/PostEventMeta/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");
			const p = m.a.span("PostEventFutureText", u.a),
				b = m.a.span("PostEventPastText", u.a),
				f = m.a.span("PostEventNowText", u.a),
				h = m.a.span("Container", u.a),
				_ = m.a.wrapped(a.a, "CalendarIcon", u.a),
				g = m.a.wrapped(d.a, "LiveIcon", u.a),
				v = m.a.div("LoadingState", u.a);
			class x extends s.Component {
				constructor(e) {
					super(e), this.state = {
						mounted: !1
					}
				}
				componentDidMount() {
					this.setState({
						mounted: !0
					})
				}
				render() {
					const {
						className: e,
						post: t
					} = this.props, {
						eventInfo: n
					} = t;
					if (!n) return null;
					const {
						eventEnd: s,
						eventIsLive: a,
						eventStart: d
					} = n, l = Object(o.e)(d, s);
					let u, m;
					if (this.state.mounted || l === o.a.Live) u = r.a.createElement(c.c, {
						startTime: d,
						endTime: s,
						isLive: a
					});
					else {
						const e = Object(i.a)({
							isLoading: !0
						});
						u = r.a.createElement(v, {
							className: e
						})
					}
					if (a) m = r.a.createElement(f, null, r.a.createElement(g, null), u);
					else if (l === o.a.Future) m = r.a.createElement(p, null, r.a.createElement(_, null), u);
					else {
						if (l !== o.a.Past) return null;
						m = r.a.createElement(b, null, r.a.createElement(_, null), u)
					}
					return r.a.createElement(h, {
						className: e
					}, m)
				}
			}
			t.a = x
		},
		"./src/reddit/components/ExpandoButton/index.m.less": function(e, t, n) {
			e.exports = {
				outer: "RvLtAcdRtbOQbhFB7MD_T",
				icon: "saNpcHve-34zjaa0cbIxW",
				hideOnHover: "_25HJpaEPiVNq6Ss3Ad7dp9",
				showOnHover: "_2S05CzViTnl3I2ekCABqFo"
			}
		},
		"./src/reddit/components/ExpandoButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/controls/OutboundLink/index.tsx"),
				m = n("./src/reddit/helpers/path/index.ts"),
				p = n("./src/reddit/helpers/postHasSelfText/index.ts"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/models/Media/index.ts"),
				h = n("./src/reddit/models/Post/index.ts"),
				_ = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				g = n("./src/telemetry/models/Outbound.ts"),
				v = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				x = n("./src/reddit/components/ExpandoButton/index.m.less"),
				O = n.n(x);
			const E = Object(i.b)(null, (e, t) => ({
					toggle: () => e(Object(l.w)({
						postId: t.post.id
					})),
					showModalOnPostLinkClick: t => e(Object(l.ab)(Object(m.b)(t.permalink), t.id))
				})),
				y = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 ? arguments[2] : void 0;
					const s = Object(d.a)(O.a.icon, O.a.hideOnHover);
					if (t) return o.a.createElement(b.a, {
						name: "crosspost",
						className: s
					});
					if (n.pollData) return o.a.createElement(b.a, {
						name: "poll_post",
						className: s
					});
					if (n.audioRoom) return o.a.createElement(b.a, {
						name: "audio",
						className: s
					});
					switch (e) {
						case f.o.GIFVIDEO:
							return o.a.createElement(b.a, {
								name: "gif_post",
								className: s
							});
						case f.o.IMAGE:
							return o.a.createElement(b.a, {
								name: "image_post",
								className: s
							});
						case f.o.TEXT:
						case f.o.RTJSON:
							return o.a.createElement(b.a, {
								name: "text_post",
								className: s
							});
						case f.o.VIDEO:
							return o.a.createElement(b.a, {
								name: "video_post",
								className: s
							});
						case f.o.GALLERY:
							return o.a.createElement(b.a, {
								name: "media_gallery",
								className: s
							});
						case f.o.EMBED:
						default:
							return o.a.createElement(b.a, {
								name: "embed",
								className: s
							})
					}
				};
			t.a = E(e => {
				const {
					className: t,
					crosspost: n,
					enableCrosspostIcon: r,
					isCommentsPage: l,
					isExpanded: m,
					post: f,
					toggle: x,
					useMediaIcons: E
				} = e, C = n || f, j = Object(i.e)(_.b), k = Object(i.e)(_.c), I = t => {
					(j || k) && (t.preventDefault(), e.showModalOnPostLinkClick(C))
				}, S = C.media, w = Object(h.q)(f), T = r && !!n;
				return S && !w && !(("rtjson" === S.type || "text" === S.type || "liveaudio" === S.type) && !Object(p.a)(C)) || !!f.pollData ? o.a.createElement("button", {
					"aria-expanded": !!m,
					"aria-haspopup": !0,
					"aria-label": s.fbt._("Expand content", null, {
						hk: "1e35IG"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": m ? "expando_close" : "expando_open",
					"data-adclicklocation": v.a.MEDIA,
					onClick: x
				}, m ? o.a.createElement(b.a, {
					name: "collapse",
					className: O.a.icon
				}) : E ? o.a.createElement(o.a.Fragment, null, y(C.media && C.media.type, T, f), o.a.createElement(b.a, {
					name: "expand",
					className: Object(d.a)(O.a.icon, O.a.showOnHover)
				})) : o.a.createElement(b.a, {
					name: "expand",
					className: O.a.icon
				})) : C.source && C.source.url ? o.a.createElement(u.b, {
					"aria-label": s.fbt._("Open external content", null, {
						hk: "2FfpSI"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					href: C.source.url,
					isSponsored: f.isSponsored,
					postId: f.id,
					source: f.source,
					sourceElement: l ? g.SourceElement.PostImage : g.SourceElement.ListingPostImage,
					target: "_blank"
				}, o.a.createElement(b.a, {
					name: "external_link",
					className: Object(d.a)(O.a.icon, O.a.outboundLinkIcon)
				})) : o.a.createElement(a.a, {
					"aria-label": s.fbt._("View content", null, {
						hk: "24KLWF"
					}),
					className: Object(d.a)(t, O.a.outer),
					"data-click-id": "expando_open",
					to: Object(c.a)(C.permalink),
					rel: "nofollow",
					onClick: I
				}, o.a.createElement(b.a, {
					name: "text_post",
					className: O.a.icon
				}))
			})
		},
		"./src/reddit/components/Flair/index.m.less": function(e, t, n) {
			e.exports = {
				FlairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				flairEmojiDisplay: "_1QwShihKKlyRXyQSlqYaWW",
				FlairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				flairWrapper: "_2X6EB3ZhEeXCh1eIVA64XM",
				TextFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				textFlair: "_1jNPl3YUk6zbpLWdjaJT1r",
				transparentBackgroundColor: "_39BEcWjOlYi1QGcJil6-yl",
				RichTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				richTextFlair: "_2hSecp_zkPm_s5ddV2htoj",
				MetaFlair: "_1wzhGvvafQFOWAyA157okr",
				metaFlair: "_1wzhGvvafQFOWAyA157okr",
				CloseButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				closeButton: "_3BPVpMSn5b1vb1yTQuqCRH",
				CloseIcon: "_2cvySYWkqJfynvXFOpNc5L",
				closeIcon: "_2cvySYWkqJfynvXFOpNc5L",
				small: "aJrgrewN9C8x1Fusdx4hh",
				large: "_1wj6zoMi6hRP5YhJ8nXWXE",
				flairVariant: "_2VqfzH0dZ9dIl3XWNxs42y"
			}
		},
		"./src/reddit/components/Flair/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return B
			})), n.d(t, "a", (function() {
				return q
			})), n.d(t, "b", (function() {
				return V
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/pick.js"),
				o = n.n(r),
				i = n("./node_modules/polished/dist/polished.es.js"),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				l = n("./src/lib/addQueryParams/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/components/Emoji/index.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const _ = p.a.wrapped(e => {
				let {
					backgroundImage: t,
					style: n,
					...s
				} = e;
				return d.a.createElement("div", h({
					style: {
						...n || {},
						backgroundImage: `url('${t}')`
					}
				}, s))
			}, "EmojiDisplay", f.a);
			var g = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				v = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				x = n("./src/reddit/constants/colors.ts"),
				O = n("./src/reddit/constants/parameters.ts"),
				E = n("./src/reddit/controls/InternalLink/index.tsx"),
				y = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				C = n("./src/reddit/icons/svgs/Close/index.tsx"),
				j = n("./src/reddit/models/Flair/index.ts"),
				k = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				I = n("./src/reddit/components/Flair/index.m.less"),
				S = n.n(I);

			function w() {
				return (w = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const T = Object(v.a)(g.b),
				N = p.a.div("FlairWrapper", S.a),
				P = p.a.wrapped(c.a, "CloseButton", S.a),
				R = p.a.wrapped(Object(m.a)(e => {
					let {
						forceSmallEmojis: t,
						theme: n,
						...s
					} = e;
					const r = n;
					return d.a.createElement(_, w({
						style: {
							...A(!!t, r) || {}
						}
					}, s))
				}), "FlairEmojiDisplay", S.a),
				A = (e, t) => {
					if (!e && !!t.subredditContext.emojiHeight && !!t.subredditContext.emojiWidth) return {
						height: `${t.subredditContext.emojiHeight}px`,
						width: `${t.subredditContext.emojiWidth}px`
					}
				},
				M = (e, t) => {
					const n = t ? `/r/${t}/search` : "/search",
						s = `${t?"flair_name":"flair"}:"${e}"`;
					return Object(l.a)(n, {
						[O.z]: s,
						[O.C]: t ? "1" : ""
					})
				},
				L = e => e.isFlairFilter ? d.a.createElement(E.default, {
					onMouseDown: e.onMouseDown,
					to: e.to || ""
				}, e.flair) : e.onClick ? d.a.createElement(E.default, {
					onClick: () => e.onClick(e.searchableTerm),
					to: M(e.searchableTerm, e.subredditName)
				}, e.flair) : e.flair;
			class D extends d.a.Component {
				constructor() {
					super(...arguments), this.tooltipTargetElement = null, this.state = {
						isTooltipOpen: !1
					}, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							isTooltipOpen: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							isTooltipOpen: !1
						})
					}
				}
				render() {
					const e = d.a.createElement("span", {
						className: Object(u.a)(this.props.className, {
							[S.a.transparentBackgroundColor]: "transparent" === this.props.backgroundColor
						}),
						onMouseEnter: this.props.tooltip ? this.onShowTooltip : void 0,
						onMouseLeave: this.props.tooltip ? this.onHideTooltip : void 0,
						ref: this.setTooltipTargetRef,
						style: {
							backgroundColor: this.props.backgroundColor || Object(k.a)(this.props).flair,
							color: `${B(this.props)}`
						}
					}, this.props.text, this.props.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: this.props.onCloseClick
					}, d.a.createElement(C.a, {
						className: S.a.CloseIcon,
						style: {
							fill: this.props.backgroundColor || Object(k.a)(this.props).flair
						}
					})), !!this.props.tooltip && d.a.createElement(T, {
						text: this.props.tooltip,
						isOpen: this.state.isTooltipOpen,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: ["center", "top"],
						tooltipPosition: ["center", "bottom"]
					}));
					return d.a.createElement(L, {
						flair: e,
						isFlairFilter: this.props.isFlairFilter,
						onClick: this.props.onClick,
						onMouseDown: this.props.onMouseDown,
						searchableTerm: this.props.text,
						subredditName: this.props.subredditName,
						to: this.props.to
					})
				}
			}
			const F = Object(m.a)(D),
				U = Object(m.a)(e => {
					let t = "",
						n = !1;
					const s = e.richtext.map((s, r) => {
						if (s.e === j.c.Emoji) {
							const o = s;
							return t += o.a, n = !0, d.a.createElement(R, {
								forceSmallEmojis: e.forceSmallEmojis,
								backgroundImage: o.u,
								key: r,
								title: o.a
							})
						} {
							const e = s;
							return t += e.t, d.a.createElement("span", {
								key: r
							}, e.t)
						}
					});
					let r;
					n && !e.forceSmallEmojis && e.theme && e.theme.subredditContext.emojiWidth && e.theme.subredditContext.emojiHeight && e.theme.subredditContext.emojiHeight > 16 && (r = {
						marginTop: `-${e.theme.subredditContext.emojiHeight-16}px`
					});
					const o = d.a.createElement(N, {
						className: Object(u.a)(e.className, {
							[S.a.transparentBackgroundColor]: "transparent" === e.backgroundColor
						}),
						style: {
							...r,
							backgroundColor: e.backgroundColor || Object(k.a)(e).flair,
							color: `${B(e)}`
						}
					}, s, e.isSelected && d.a.createElement(P, {
						to: "./",
						onClick: e.onCloseClick
					}, d.a.createElement(C.a, {
						className: S.a.CloseIcon,
						style: {
							fill: e.backgroundColor || Object(k.a)(e).flair
						}
					})));
					return d.a.createElement(L, {
						flair: o,
						isFlairFilter: e.isFlairFilter,
						onClick: e.onClick ? () => {
							e.onClick(t)
						} : void 0,
						onMouseDown: e.onMouseDown,
						searchableTerm: t,
						subredditName: e.subredditName,
						to: e.to
					})
				}),
				B = e => !e.textColor || e.textColor && !e.backgroundColor ? Object(k.a)(e).postFlairText : "transparent" === e.backgroundColor ? Object(y.a)(Object(k.a)(e).post, x.a.black, x.a.white) : e.textColor === j.e.Dark ? x.a.black : x.a.white,
				q = p.a.wrapped(F, "TextFlair", S.a),
				G = p.a.wrapped(U, "RichTextFlair", S.a),
				H = e => {
					switch (e.type) {
						case "spoiler":
							return "#A4A7A8";
						case "nsfw":
							return "#FF585B";
						default:
							return Object(i.i)(.1, Object(k.a)(o()(e, "theme", "redditStyle", "data-redditstyle")).button)
					}
				},
				W = p.a.wrapped(e => {
					const t = H(e),
						n = d.a.createElement("span", {
							className: e.className,
							style: {
								border: `1px solid ${t}`,
								color: t
							}
						}, e.text);
					return d.a.createElement(L, {
						flair: n,
						searchableTerm: e.text
					})
				}, "MetaFlair", S.a);

			function V(e) {
				const {
					className: t,
					disabled: n = !1,
					flair: r,
					isFlairFilter: o,
					isSelected: i,
					onClick: a,
					onCloseClick: c,
					onMouseDown: l,
					subredditName: m,
					usesCommunityStyles: p,
					forceSmallEmojis: b,
					to: f
				} = e, h = Object(u.a)({
					[S.a.flairVariant]: o,
					[S.a.small]: o && !e.large,
					[S.a.large]: o && e.large
				}, t);
				switch (r.type) {
					case j.f.Richtext:
						return n || !r.richtext ? null : d.a.createElement(G, {
							backgroundColor: r.backgroundColor,
							className: h,
							forceSmallEmojis: b,
							isFlairFilter: o,
							isSelected: i,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							redditStyle: !p,
							richtext: r.richtext,
							subredditName: m,
							textColor: r.textColor,
							to: f
						});
					case j.f.Text:
						return n || !r.text ? null : d.a.createElement(q, {
							backgroundColor: r.backgroundColor,
							className: h,
							isFlairFilter: o,
							isSelected: i,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: f
						});
					case j.f.Meta:
						return d.a.createElement(q, {
							backgroundColor: r.backgroundColor,
							className: t,
							isFlairFilter: o,
							subredditName: m,
							text: r.text,
							textColor: r.textColor,
							redditStyle: !p,
							to: f
						});
					case j.f.Nsfw:
					case j.f.Spoiler:
						return d.a.createElement(W, {
							className: t,
							text: r.text,
							type: r.type
						});
					case j.f.Quarantined:
						return null;
					case j.f.Oc:
						return d.a.createElement(q, {
							backgroundColor: x.a.alienblue,
							text: r.text,
							textColor: j.e.Light,
							tooltip: s.fbt._("This post is marked as Original Content [OC]", null, {
								hk: "h7je6"
							})
						});
					default:
						return r.text ? d.a.createElement(q, {
							backgroundColor: r.backgroundColor,
							className: h,
							isFlairFilter: o,
							onClick: a,
							onCloseClick: c,
							onMouseDown: l,
							subredditName: m,
							text: r.text,
							redditStyle: !p,
							to: f
						}) : null
				}
			}
		},
		"./src/reddit/components/FlairList/index.m.less": function(e, t, n) {
			e.exports = {
				flairVariantInList: "_1Dl-kvSxyJMWO9nuoTof8N"
			}
		},
		"./src/reddit/components/FlairList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/Flair/index.tsx"),
				l = n("./src/reddit/helpers/flair.ts"),
				u = n("./src/reddit/models/Flair/index.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/reddit/components/FlairList/index.m.less"),
				b = n.n(p);
			const f = Object(d.c)({
					labelNSFW: m.bb
				}),
				h = Object(a.b)(f),
				_ = e => {
					if (e.type === u.f.Richtext && e.richtext) {
						const t = e.richtext.map(e => e.e === u.c.Emoji ? e.u : e.t).join("-");
						return `${e.type}--${t}`
					}
					return `${e.type}--${e.text}`
				};
			t.a = h(e => {
				let {
					className: t,
					isFlairFilter: n,
					onClick: s,
					onMouseDown: o,
					disabled: a = !1,
					flair: d,
					labelNSFW: m,
					subredditName: p
				} = e;
				const f = !!d.find(e => e.type === u.f.Richtext),
					h = d.map(e => {
						if (e.type === u.f.Text && f) return null;
						if (!m && e.type === u.f.Nsfw) return null;
						const t = Object(l.j)(e),
							d = `/r/${p}/`,
							h = o ? () => o(e) : r.a,
							g = n && (e.type === u.f.Richtext || e.type === u.f.Text);
						return i.a.createElement(c.b, {
							className: g ? b.a.flairVariantInList : void 0,
							isFlairFilter: n,
							key: _(e),
							onClick: s,
							onMouseDown: h,
							disabled: a,
							flair: e,
							forceSmallEmojis: !0,
							subredditName: p,
							to: Object(l.e)(d, t)
						})
					});
				return i.a.createElement("div", {
					className: t
				}, h)
			})
		},
		"./src/reddit/components/FlairPickerTitle/index.m.less": function(e, t, n) {
			e.exports = {
				modalHeader: "_26bOTAKvGixX5tMC3vGfTv"
			}
		},
		"./src/reddit/components/FlairPickerTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/noop.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/components/FlairPickerTitle/index.m.less"),
				l = n.n(c);
			t.a = e => i.a.createElement(a.i, {
				className: l.a.modalHeader
			}, i.a.createElement(a.q, null, e.title), i.a.createElement(d.a, {
				onClick: e.onClosePressed || r.a
			}, i.a.createElement(a.b, null)))
		},
		"./src/reddit/components/FlairPickerWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_3nRJIwLuth2pKYrXnr2jPN",
				wrapper: "_3nRJIwLuth2pKYrXnr2jPN"
			}
		},
		"./src/reddit/components/FlairPickerWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/FlairPickerWrapper/index.m.less"),
				o = n.n(r);
			const i = s.a.div("Wrapper", o.a);
			t.a = i
		},
		"./src/reddit/components/FlairPreview/index.m.less": function(e, t, n) {
			e.exports = {
				Placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				placeholder: "_30zvTaAcvBFmwfelq6Bvwg",
				SelectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				selectedFlair: "BzonfS85jX2JTiu_i0Jyd",
				FlairComponent: "vynkb69RQyUY-PA6bCaW0",
				flairComponent: "vynkb69RQyUY-PA6bCaW0"
			}
		},
		"./src/reddit/components/FlairPreview/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Flair/index.tsx"),
				d = n("./src/reddit/components/FlairPreview/index.m.less"),
				c = n.n(d);
			const l = i.a.span("Placeholder", c.a),
				u = i.a.div("SelectedFlair", c.a),
				m = i.a.wrapped(a.b, "FlairComponent", c.a);
			t.a = e => e.flair ? o.a.createElement(u, null, o.a.createElement(l, null, s.fbt._("{placeholder}", [s.fbt._param("placeholder", e.placeholderText)], {
				hk: "4G6VRy"
			})), o.a.createElement(m, {
				flair: e.flair,
				forceSmallEmojis: !0
			})) : o.a.createElement(u, null, s.fbt._("No flair selected", null, {
				hk: "1XPXbv"
			}))
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.m.less": function(e, t, n) {
			e.exports = {
				FlairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				flairEditStub: "Z7x0t_45z9vZGN2zw6US6",
				isCompact: "_3YjPWOd9tK9O_DN50RI_FN"
			}
		},
		"./src/reddit/components/FlairSearch/FlairEdit/helper.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/lodash/once.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/higherOrderComponents/makeAsync.tsx"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/lib/loadWithRetries/index.ts"),
				u = n("./src/reddit/components/FlairSearch/FlairEdit/helper.m.less"),
				m = n.n(u);
			const p = c.a.wrapped(e => i.a.createElement("div", {
					className: Object(d.a)(e.className, {
						[m.a.isCompact]: e.isCompact
					})
				}), "FlairEditStub", m.a),
				b = r()((function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : p;
					return Object(a.a)({
						getComponent: () => Object(l.a)(() => Promise.all([n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("FlairEdit")]).then(n.bind(null, "./src/reddit/components/FlairSearch/FlairEdit/index.tsx")).then(e => e.default)),
						ErrorComponent: e,
						LoadingComponent: e
					})
				}))
		},
		"./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1bdAduczElF9-gLoCvHz-p",
				flairComponent: "_2leID3tMN8hpvVd4XhEqTl",
				radioOption: "FJIE5E2gciCA8q3Jzvcyg",
				pencil: "_3H_wwe03-Fkrm6oWGakXI8",
				searchBoxWrapper: "_18cuM8Uu7RcIFu1bCT0r4t",
				searchIcon: "_2bECVWL_WJ9RGBx7-RnzfO",
				searchInput: "_1nQbRaoAvb6Uy0oI-OfDtZ"
			}
		},
		"./src/reddit/components/FlairSearch/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2AKP6aCod0Z6TuXXfc1ZqL",
				buttonsRow: "_3w7b_fPwMuVD17J7epjTXi",
				clearButton: "_3WykjMvdVO5xibqd5xlfTC",
				flairEditSection: "SVd7IxchgiWetdYbftTHx",
				editLabel: "KTa3kg9lzGPUeLuhAHMT_",
				restrictionHintText: "_1fV9kJfKnED9qQ2AF8f3iT"
			}
		},
		"./src/reddit/components/FlairSearch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/memoizeByReference/index.ts"),
				l = n("./src/reddit/featureFlags/index.ts"),
				u = n("./src/reddit/helpers/flair.ts"),
				m = n("./src/reddit/helpers/trackers/userFlair.ts"),
				p = n("./src/reddit/hooks/useTracking.ts"),
				b = n("./src/reddit/selectors/moderatorPermissions.ts"),
				f = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				h = n("./src/reddit/components/Flair/index.tsx"),
				_ = n("./src/reddit/components/TrackingHelper/index.tsx"),
				g = n("./src/reddit/controls/RadioInput/index.tsx"),
				v = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				x = n("./src/reddit/helpers/trackers/postComposer.ts"),
				O = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				E = n("./src/reddit/icons/svgs/Search/index.tsx"),
				y = n("./src/reddit/components/FlairSearch/FlairTemplateList/index.m.less"),
				C = n.n(y);
			class j extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						searchQuery: ""
					}, this.onSearchChange = e => {
						this.setState({
							searchQuery: e.target.value
						})
					}, this.onSearchClick = () => {
						this.props.sendEvent(Object(x.n)())
					}
				}
				render() {
					const {
						templates: e,
						templateIds: t,
						selectedTemplateId: n
					} = this.props, {
						searchQuery: r
					} = this.state, i = t.map(t => e[t]).filter(e => e.text.toLowerCase().includes(r)), a = !!n && i.some(e => e.id === n);
					return o.a.createElement("div", {
						className: C.a.container
					}, o.a.createElement("div", {
						className: C.a.searchBoxWrapper
					}, o.a.createElement("input", {
						className: C.a.searchInput,
						onChange: this.onSearchChange,
						onClick: this.onSearchClick,
						type: "text",
						placeholder: s.fbt._("Search for flair", null, {
							hk: "jQdqA"
						}),
						value: r
					}), o.a.createElement(E.a, {
						className: C.a.searchIcon
					})), o.a.createElement(g.a, {
						name: "flair_picker",
						onChange: this.props.onChange,
						value: n
					}, i.map((e, t) => {
						const s = Object(u.c)(e),
							r = n === e.id || !a && 0 === t;
						return o.a.createElement(v.a, {
							className: C.a.radioOption,
							key: e.id,
							showButton: !0,
							tabIndex: r ? 0 : -1,
							value: e.id
						}, o.a.createElement(h.b, {
							className: C.a.flairComponent,
							flair: s,
							forceSmallEmojis: !0
						}), e.textEditable && o.a.createElement(O.a, {
							className: C.a.pencil
						}))
					})))
				}
			}
			var k = Object(_.c)(j),
				I = n("./src/reddit/components/FlairSearch/index.m.less"),
				S = n.n(I);
			const w = Object(c.a)(e => e && Object(u.c)(e)),
				T = Object(a.c)({
					areFlairRestrictionsEnabled: l.d.flairRestrictions,
					isModerator: b.g
				}),
				N = Object(i.b)(T);
			t.a = N(e => {
				const {
					flairTemplateType: t,
					flair: n,
					className: r,
					onChange: i,
					subredditId: a,
					templates: c,
					templateIds: l,
					areFlairRestrictionsEnabled: b,
					isModerator: h
				} = e, _ = Object(p.a)(), g = c && n && n.templateId && c[n.templateId] || void 0, v = Object(f.a)(), x = n || w(g);
				return o.a.createElement("div", {
					className: Object(d.a)(r, S.a.container)
				}, c && l && o.a.createElement(k, {
					flairTemplateType: t,
					onChange: e => {
						if (c) {
							const t = c[e],
								n = Object(u.c)(t);
							_(Object(m.b)({
								userFlair: t
							})), i(n)
						}
					},
					selectedTemplateId: g ? g.id : "",
					templateIds: l,
					templates: c
				}), x && g && (h || g.textEditable) && o.a.createElement("div", {
					className: S.a.flairEditSection
				}, o.a.createElement("div", {
					className: S.a.editLabel
				}, s.fbt._("Edit flair", null, {
					hk: "1APWWu"
				})), b && o.a.createElement("div", {
					className: S.a.restrictionHintText
				}, Object(u.k)(g)), o.a.createElement(v, {
					autofocus: !0,
					emojiPickerId: "FlairSearch-EmojiPicker-DropdownId",
					flair: x,
					flairTemplate: g,
					flairTemplateType: t,
					isFlairModOnly: g.modOnly,
					onChange: e => {
						const t = c && e.templateId ? c[e.templateId] : void 0;
						let n = e;
						t && (n = Object(u.d)({
							flair: e,
							template: t,
							ignoreTextAllowance: !0
						})), i(n)
					},
					subredditId: a
				})))
			})
		},
		"./src/reddit/components/FlairWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				flairList: "lrzZ8b0L6AzLkQj5Ww7H1",
				flairWrapper: "_2fiIRtMpITeCAzXc4cANKp",
				flairNoWrap: "_2xu1HuBz1Yx6SP10AGVx_I"
			}
		},
		"./src/reddit/components/FlairWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/FlairList/index.tsx"),
				l = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				u = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/correlationIdTracker.ts"),
				b = n("./src/reddit/helpers/trackers/postFlair.ts"),
				f = n("./src/reddit/models/Flair/index.ts"),
				h = n("./src/reddit/selectors/postFlair.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/reddit/components/FlairWrapper/index.m.less"),
				v = n.n(g);
			const x = Object(i.b)(() => Object(a.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(m.r)(e, {
							pageLayer: n
						})
					},
					isPostFlairEnabled: (e, t) => Object(h.c)(e, {
						subredditId: t.post.belongsTo.id
					}),
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(_.Y)(e, {
							subredditId: n.belongsTo.id
						}).name
					}
				})),
				O = e => {
					const t = [];
					return e.isOriginalContent && t.push({
						text: s.fbt._("OC", null, {
							hk: "1i721p"
						}),
						type: f.f.Oc
					}), e.isMeta && t.push({
						text: s.fbt._("Poll", null, {
							hk: "1scdU1"
						}),
						type: f.f.Meta
					}), t.push(...e.flair), t
				};
			t.a = x(e => {
				let {
					className: t,
					disableFlair: n,
					flairPosition: s,
					isFlairFilter: r,
					isPostFlairEnabled: i,
					nowrap: a,
					post: m,
					sendEvent: h,
					subredditName: _,
					titleFlair: g
				} = e;
				const x = Object(u.a)(),
					E = s === f.b.Left,
					y = g || O(m),
					{
						leftFlair: C,
						rightFlair: j
					} = Object(l.a)({
						flair: y,
						isFlairPositionedLeft: E
					}),
					k = a ? v.a.flairNoWrap : C.length > 0 || j.length > 0 ? v.a.flairWrapper : null,
					I = e => {
						const t = {
							id: m.belongsTo.id,
							eventType: m.belongsTo.type,
							originElement: "post_flair",
							postFlairName: e
						};
						Object(p.d)(p.a.SearchResults), h && h(Object(b.a)(m.id, t))
					},
					S = e => {
						Object(p.d)(p.a.SearchResults), h && h(Object(b.e)(e, m.id))
					},
					w = !(n || !y || !y.length);
				return w ? o.a.createElement("div", {
					className: Object(d.a)(k, t),
					"data-ignore-click": x
				}, w && C && o.a.createElement(c.a, {
					className: v.a.flairList,
					isFlairFilter: r,
					key: "leftFlair",
					onClick: I,
					onMouseDown: S,
					flair: C,
					disabled: !i,
					subredditName: _
				}), w && o.a.createElement(c.a, {
					className: v.a.flairList,
					isFlairFilter: r,
					key: "rightFlair",
					onClick: I,
					onMouseDown: S,
					flair: j,
					disabled: !i,
					subredditName: _
				})) : null
			})
		},
		"./src/reddit/components/Flatlist/ResponsiveRow.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				a = n("./src/reddit/controls/Dropdown/Row.tsx"),
				d = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				c = n("./src/reddit/components/Flatlist/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					flatlistItem: t,
					isLoggedIn: n,
					isUserOp: s,
					noBreakpoints: c,
					...m
				} = e;
				return r.a.createElement("div", {
					"data-ignore-click": !!m.searchIgnoreClick,
					className: l.a.rowContainer,
					"data-adclicklocation": d.b.FLATLIST_GENERAL
				}, r.a.createElement(a.a, u({}, m, {
					className: c ? l.a.responsiveRow : Object(o.a)(l.a.responsiveRow, Object(i.b)({
						flatlistItem: t,
						isLoggedIn: n,
						isUserOp: s
					}))
				})))
			}
		},
		"./src/reddit/components/Flatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				hideIfVwSmaller: "_3yh2bniLq7bYr4BaiXowdO",
				FirstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				firstGroup: "_2sAFaB0tx4Hd5KxVkdUcAx",
				LoggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				loggedOutVariant: "_3sUJGnemgtNczijwoT8PGg",
				LoggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				loggedInVariant: "_28vEaVlLWeas1CDiLuTCap",
				OpVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				opVariant: "Z-VR19FVnE3nOS0_BU4Wy",
				EditingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				editingGroup: "_1EKOhBHXAW9y8Bgn93c9f3",
				SecondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				secondGroup: "_1pShbCnOaF7EGWTq6IvZux",
				AwardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				awardingGroup: "_1EWxiIupuIjiExPQeK4Kud",
				HideIfVWLarger: "_1k3nXWGGz2NdPr8dg49Tbs",
				hideIfVwLarger: "_1k3nXWGGz2NdPr8dg49Tbs"
			}
		},
		"./src/reddit/components/Flatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.EditPost = "EDITPOST", e.EditFlair = "EDITFLAIR", e.Save = "SAVE", e.Gild = "GILD", e.Hide = "HIDE", e.PostOverflowMenu = "POST_OVERFLOW_MENU", e.Report = "REPORT", e.Share = "SHARE", e.ShowFewerLikeThis = "SHOW_FEWER_LIKE_THIS", e.ShowMoreLikeThis = "SHOW_MORE_LIKE_THIS", e.Insights = "INSIGHTS", e.Mute = "MUTE"
				}(s || (s = {}))
		},
		"./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return u
			}));
			var s, r, o, i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/Flatlist/breakpoints.m.less"),
				d = n.n(a),
				c = n("./src/reddit/components/Flatlist/constants.ts");
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.First = "FirstGroup", e.Editing = "EditingGroup", e.Second = "SecondGroup", e.Awarding = "AwardingGroup"
			}(r || (r = {})),
			function(e) {
				e.LoggedIn = "LoggedInVariant", e.LoggedOut = "LoggedOutVariant", e.Op = "OpVariant"
			}(o || (o = {}));
			const l = {
					[c.a.EditFlair]: r.Editing,
					[c.a.EditPost]: r.Editing,
					[c.a.Gild]: r.Awarding,
					[c.a.Hide]: r.First,
					[c.a.PostOverflowMenu]: r.First,
					[c.a.Report]: r.First,
					[c.a.Save]: r.First,
					[c.a.Share]: r.Second,
					[c.a.ShowFewerLikeThis]: r.First,
					[c.a.ShowMoreLikeThis]: r.First,
					[c.a.Insights]: r.First,
					[c.a.Mute]: r.First
				},
				u = e => {
					return (e => {
						const t = d.a[e.type],
							n = d.a[e.group],
							s = d.a[e.groupVariant];
						return Object(i.a)(t, n, s)
					})({
						type: e.breakpointType || s.HideIfVWSmaller,
						group: l[e.flatlistItem],
						groupVariant: ((e, t) => e && t ? o.Op : e ? o.LoggedIn : o.LoggedOut)(e.isLoggedIn, e.isUserOp)
					})
				}
		},
		"./src/reddit/components/Flatlist/index.m.less": function(e, t, n) {
			e.exports = {
				flatlistContainer: "_3-miAEojrCvx_4FQ8x3P-s",
				responsiveRow: "YszYBnnIoNY8pZ6UwCivd",
				rowContainer: "_3U_7i38RDPV5eBv7m4M-9J",
				responsiveRowText: "_70940WUuFmpHbhKlj8EjZ",
				insightsButtonText: "WH45FmM2j_4Snucem7pcm",
				flatlistSeparator: "x7sinePdvDKj7bf-cdm4Z",
				flexSpacer: "_21pmAV9gWG6F_UKVe7YIE0",
				modActionsIcon: "_15c1hqseW25EvRu0WP2Dq5",
				shareText: "_6_44iTtZoeY6_XChKt5b0",
				commentsLink: "_2qww3J5KKzsD7e5DO0BvvU",
				supportButton: "_3NIVQWStkLT7RXnwKpKNuT",
				text: "YCL-CnLJKXzXbwuLZEyh1",
				ShareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareButton: "kU8ebCMnbXfjCWfqn0WPb",
				shareIcon: "_1GQDWqbF-wkYWbrpmOvjqJ",
				ShareMenu: "_JRBNstMcGxbZUxrrIKXe",
				shareMenu: "_JRBNstMcGxbZUxrrIKXe",
				liveDiscussionWrapper: "_3rnnBQZL1OOttG3tFn629n",
				modLargePost: "_1rz4qmtk19qk1KbsKVMbAq",
				overflowMenuContainer: "_3MmwvEEt6fv5kQPFCVJizH",
				awardIcon: "_3yNNYT3e1avhAAWVHd0-92",
				saveIcon: "_1Xe01txJfRB9udUU85DNeR"
			}
		},
		"./src/reddit/components/Flatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return he
			})), n.d(t, "a", (function() {
				return _e
			})), n.d(t, "d", (function() {
				return Ee
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/lib/ads/index.ts"),
				p = n("./src/lib/timezone/index.ts"),
				b = n("./src/reddit/actions/gold/modals.ts"),
				f = n("./src/reddit/actions/modal.ts"),
				h = n("./src/reddit/actions/post.ts"),
				_ = n("./src/reddit/actions/postCreation/editing.ts"),
				g = n("./src/reddit/actions/postFlair.ts"),
				v = n("./src/reddit/actions/reportFlow/index.ts"),
				x = n("./src/reddit/components/CommentsChat/LiveIcon/index.tsx"),
				O = n("./src/reddit/components/CommentsLink/index.tsx"),
				E = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				y = n("./src/reddit/components/GiveAwardTooltip/index.tsx"),
				C = n("./src/reddit/components/ModActionsMenu/index.tsx"),
				j = n("./src/reddit/components/ModModeReports/helpers.ts"),
				k = n("./src/reddit/components/ModToolsFlatlist/index.tsx"),
				I = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				S = n("./src/reddit/components/PostModModeDropdown/index.tsx"),
				w = n("./src/reddit/components/PostOverflowMenu/index.tsx"),
				T = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				N = n("./src/reddit/components/ShareMenu/index.tsx"),
				P = n("./src/reddit/components/TrackingHelper/index.tsx"),
				R = n("./src/reddit/components/ViewReportsDropdown/Loader.ts"),
				A = n("./src/reddit/constants/postLayout.ts"),
				M = n("./src/reddit/contexts/PageLayer/index.tsx"),
				L = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				D = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				F = n("./src/reddit/selectors/experiments/reportAd.ts"),
				U = n("./src/reddit/selectors/user.ts"),
				B = n("./src/reddit/components/Flatlist/ResponsiveRow.tsx"),
				q = n("./src/reddit/helpers/correlationIdTracker.ts"),
				G = n("./src/reddit/helpers/trackers/modTools.ts"),
				H = n("./src/reddit/helpers/trackers/post.ts"),
				W = n("./src/reddit/icons/fonts/index.tsx"),
				V = n("./src/reddit/icons/fonts/ModActions/index.tsx"),
				z = n("./src/reddit/icons/fonts/Share/index.tsx"),
				K = n("./src/reddit/models/Media/index.ts"),
				Q = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				Y = n("./src/reddit/models/PostCreationForm/index.ts"),
				J = n("./src/reddit/models/User/index.ts"),
				X = n("./src/reddit/components/Flatlist/constants.ts"),
				Z = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				$ = n("./src/reddit/components/Flatlist/getFlatlistTooltipId.ts"),
				ee = n("./src/reddit/actions/postCollection/index.ts"),
				te = n("./src/reddit/components/Econ/GiftOrFreeAwardIcon/index.tsx"),
				ne = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx"),
				se = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx"),
				re = n("./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts"),
				oe = n("./src/reddit/selectors/activeModalId.ts"),
				ie = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				ae = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				de = n("./src/reddit/selectors/experiments/chat.ts"),
				ce = n("./src/reddit/components/Flatlist/index.m.less"),
				le = n.n(ce);

			function ue() {
				return (ue = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			let me, pe;
			const be = u.a.button("ShareButton", le.a),
				fe = u.a.wrapped(N.a, "ShareMenu", le.a),
				he = Object(l.a)(e => {
					let {
						className: t,
						...n
					} = e;
					return o.a.createElement(V.a, ue({}, n, {
						className: Object(d.a)(le.a.modActionsIcon, t),
						style: {
							color: Object(D.a)(Object(L.a)(n), Q.a.actionIcon, Q.b.actionIcon)
						}
					}))
				}),
				_e = e => o.a.createElement("div", ue({}, e, {
					className: Object(d.a)(le.a.flatlistSeparator, e.className)
				})),
				ge = Object(M.v)({
					currentProfileName: M.j,
					isCommentPermalink: M.x,
					isCommentsPage: M.y,
					isProfilePostListing: M.N,
					pageLayer: e => e
				}),
				ve = Object(a.c)({
					activeModalId: oe.a,
					claimedFreeAward: ie.b,
					layout: M.U,
					userIsOp: U.Eb,
					subreddit: M.s,
					isReportAnAdEnabled: F.a
				}),
				xe = Object(i.b)(ve, (e, t) => {
					let {
						post: s,
						isOverlay: r,
						isCommentsPage: o
					} = t;
					return {
						addPostToCollection: (t, n) => e(Object(ee.a)(t, n)),
						onToggleModal: t => e(Object(f.i)(t)),
						onToggleSave: () => e(Object(h.U)(s.postId)),
						onHide: t => e(Object(h.eb)(s.postId, !s.hidden, r, !0)),
						onReportClick: () => e(Object(v.c)(s.postId, r)),
						onEdit: () => {
							const t = !r && !o;
							e(Object(_.a)(s.postId, t))
						},
						onFlairPost: () => e(Object(f.i)(Object(I.b)(s.postId, r))),
						onGildClick: (t, n) => e(Object(b.d)({
							awardId: n,
							correlationId: t,
							thingId: s.postId
						})),
						onFlairChanged: t => {
							let {
								selectedTemplateId: n,
								previewFlair: r
							} = t;
							return e(Object(g.h)({
								post: s,
								selectedTemplateId: n,
								previewFlair: r
							}))
						},
						toggleEditStartTimeModal: async () => {
							me && pe || ([me, pe] = await Promise.all([n.e("schedulePickerModal").then(n.bind(null, "./src/reddit/components/PostCreationForm/SchedulePickerModal/index.tsx")).then(e => e.default), Promise.resolve().then(n.bind(null, "./src/reddit/actions/eventPosts/index.ts")).then(e => e.editEventTimeRequested)])), e(Object(f.i)(Object(Y.s)(s.postId, r, Y.k.POST_OVERFLOW_MENU)))
						},
						addEventStartTime: t => {
							pe && e(pe(s.id, t))
						}
					}
				}),
				Oe = o.a.memo(e => {
					const {
						activeModalId: t,
						addEventStartTime: a,
						className: l,
						currentProfileName: u,
						currentUser: b,
						forceOpenInNewTab: f,
						hasModFlairPerms: h,
						hasModFullPerms: _,
						hasModPostPerms: g,
						isCommentPermalink: v,
						isCommentsPage: N,
						isCountAnimShadowTestEnabled: P,
						isLargePost: M,
						isOverlay: L,
						isProfilePostListing: D,
						isSticky: F,
						layout: U,
						modModeEnabled: V,
						onClickInsightsButton: Q,
						onFlairChanged: ee,
						onIgnoreReports: re,
						onOpenReportsDropdown: oe,
						pageLayer: ie,
						post: ce,
						sendEvent: ue,
						showEditFlair: pe,
						showEditPost: _e,
						subreddit: ge,
						toggleEditStartTimeModal: ve,
						tooltipType: xe,
						userIsOp: Oe,
						searchIgnoreClick: ye,
						isCommentCountAnimation: Ce,
						hostPostData: je,
						listingKey: ke,
						onGildClick: Ie,
						onToggleModal: Se,
						claimedFreeAward: we,
						onToggleSave: Te,
						onHide: Ne,
						addPostToCollection: Pe,
						onReportClick: Re,
						shouldHideItems: Ae,
						shouldShowInsightsButton: Me,
						isReportAnAdEnabled: Le
					} = e, De = Object(i.e)(de.e), Fe = Object(r.useCallback)(async () => {
						const e = Object(q.d)(q.a.GildingFlow, !0);
						Ie(e, null == we ? void 0 : we.id);
						const {
							clickGildEvent: t
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						ue(t(ce.id))
					}, [Ie, ce, ue, we]), Ue = Object(r.useCallback)(() => {
						t && Se(t)
					}, [t, Se]), Be = Object(r.useCallback)(() => {
						const e = Object(Y.t)(ce.id, L);
						Se(e)
					}, [Se, L, ce]), qe = Object(r.useCallback)(e => {
						Pe(e.id, ce.id).then(() => Ue())
					}, [Pe, Ue, ce]), Ge = Object(r.useCallback)((e, t) => {
						ue(Object(H.k)(ce.id, e, L ? "post_detail" : "post", ke, je, void 0, null == t ? void 0 : t.referralId))
					}, [je, L, ue, ke, ce]), He = Object(r.useCallback)(() => {
						Te(), Ge(ce.saved ? "unsave" : "save")
					}, [Te, ce, Ge]), We = Object(r.useCallback)(() => {
						Ne(!!ce.hidden), Ge(ce.hidden ? "unhide" : "hide")
					}, [Ne, ce, Ge]), Ve = Object(r.useCallback)(() => {
						Re(), Ge("report")
					}, [Re, Ge]), ze = Object(r.useMemo)(() => o.a.createElement(be, {
						"data-click-id": "share",
						"data-adclicklocation": ae.b.FLATLIST_SHARE
					}, o.a.createElement(z.a, {
						className: le.a.shareIcon
					}), o.a.createElement("span", {
						className: le.a.shareText
					}, s.fbt._("share", null, {
						hk: "1eAfZg"
					}))), []), Ke = !!b && Object(J.e)(b) === ce.author, Qe = Object($.a)("View--Reports", ce.id, xe), Ye = Object($.a)(c.wc, ce.id, xe), Je = Object(j.c)(ce), Xe = Ee("-mod-actions-menu", ce.id, L, F), Ze = Object(j.a)(ce), $e = ce.postId, et = U === A.g.Large, tt = !N && et || g && V || Ae, nt = !(L || N || v), st = !ce.authorIsBlocked && b && ce.isGildable && !ce.authorIsBlocked && !ce.unrepliableReason, rt = ce.media && ce.media.type === K.o.LIVEVIDEO, ot = !!ce.recommendationContext, it = ce.isSponsored || Object(m.u)(ie);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(d.a)(le.a.flatlistContainer, l)
					}, o.a.createElement(O.a, {
						className: Object(d.a)(le.a.rowContainer, le.a.commentsLink),
						forceOpenInNewTab: f,
						hasModPostPerms: g,
						isCommentsPage: N,
						isCommentPermalink: v,
						isOverlay: L,
						postId: ce.id,
						modModeEnabled: V,
						numComments: ce.numComments,
						isCommentCountAnimation: Ce,
						isCountAnimShadowTestEnabled: P
					}), st && o.a.createElement(o.a.Fragment, null, o.a.createElement(B.a, {
						displayText: s.fbt._("Award", null, {
							hk: "2fZCpE"
						}),
						textClassName: le.a.responsiveRowText,
						flatlistItem: X.a.Gild,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: Fe,
						searchIgnoreClick: ye,
						"data-adclicklocation": ae.b.FLATLIST_AWARD,
						skipRoleAttr: !0
					}, o.a.createElement(te.a, {
						className: le.a.awardIcon,
						id: Ye
					})), o.a.createElement(y.a, {
						postOrComment: ce,
						tooltipId: Ye
					})), o.a.createElement(fe, {
						className: Object(d.a)(le.a.rowContainer, Object(Z.b)({
							flatlistItem: X.a.Share,
							isLoggedIn: !!b,
							isUserOp: Oe
						})),
						dropdownId: Ee("-share-menu", ce.id, L, F),
						permalink: ce.permalink,
						post: ce,
						sendEventWithName: Ge,
						subredditType: null == ge ? void 0 : ge.type
					}, ze), _e && !tt && o.a.createElement(B.a, {
						displayText: s.fbt._("Edit post", null, {
							hk: "Jq2Cr"
						}),
						textClassName: le.a.responsiveRowText,
						flatlistItem: X.a.EditPost,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: e.onEdit,
						skipRoleAttr: !0
					}, o.a.createElement(W.a, {
						name: "edit"
					})), (!g || !V) && o.a.createElement(B.a, {
						displayText: ce.saved ? s.fbt._("unsave", null, {
							hk: "4Dn4IT"
						}) : s.fbt._("save", null, {
							hk: "3NOMst"
						}),
						textClassName: le.a.responsiveRowText,
						flatlistItem: X.a.Save,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: He,
						searchIgnoreClick: ye,
						skipRoleAttr: !0,
						"data-adclicklocation": ae.b.FLATLIST_SAVE
					}, o.a.createElement(W.a, {
						name: ce.saved ? "saved" : "save",
						className: le.a.saveIcon
					})), !it && !tt && o.a.createElement(B.a, {
						displayText: ce.hidden ? s.fbt._("unhide", null, {
							hk: "151XLs"
						}) : s.fbt._("hide", null, {
							hk: "4AnA6R"
						}),
						textClassName: le.a.responsiveRowText,
						flatlistItem: X.a.Hide,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: We,
						searchIgnoreClick: ye,
						skipRoleAttr: !0
					}, o.a.createElement(W.a, {
						name: "hide",
						isFilled: ce.hidden
					})), !Ke && (!it || Le) && !tt && o.a.createElement(B.a, {
						displayText: s.fbt._("report", null, {
							hk: "1phfns"
						}),
						textClassName: le.a.responsiveRowText,
						flatlistItem: X.a.Report,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: Ve,
						searchIgnoreClick: ye,
						skipRoleAttr: !0
					}, o.a.createElement(W.a, {
						name: "report"
					})), o.a.createElement(k.a, {
						isOverlay: L,
						layout: U,
						modModeEnabled: V,
						post: ce,
						sendEvent: ue
					}), g && o.a.createElement(C.a, {
						dropdownId: Xe,
						onClick: () => ue(Object(H.k)(ce.id, "post_mod_action_menu"))
					}, o.a.createElement(he, null), o.a.createElement(S.a, {
						canEditFlair: h && !!pe,
						hasModFullPerms: _,
						hasModPostPerms: g,
						isOverlay: !!L,
						isPostAuthor: Ke,
						modModeEnabled: V,
						post: ce,
						tooltipId: Xe
					})), g && Je && !V && o.a.createElement(T.c, {
						text: `${Ze}`,
						onClick: () => {
							oe(Qe), ue(Object(H.k)(ce.id, "post_report_menu"))
						},
						id: Qe
					}, o.a.createElement(R.a, {
						model: ce,
						onIgnoreReports: () => {
							re(), ue(Object(G.m)(ce.ignoreReports ? "restore_reports" : "ignore_reports", ce.id))
						},
						tooltipId: Qe
					}), o.a.createElement(W.a, {
						className: le.a.icon,
						name: ce.ignoreReports ? "ignore_reports" : "report"
					})), Me && o.a.createElement(B.a, {
						displayText: s.fbt._("Insights", null, {
							hk: "2IyDq5"
						}),
						textClassName: Object(d.a)(le.a.responsiveRowText, le.a.insightsButtonText),
						flatlistItem: X.a.Insights,
						isLoggedIn: !!b,
						isUserOp: Oe,
						onClick: Q,
						skipRoleAttr: !0
					}, o.a.createElement(E.a, {
						postCreated: ce.created,
						subredditId: ce.belongsTo.id
					})), (!it || Le) && o.a.createElement("div", {
						className: le.a.overflowMenuContainer
					}, o.a.createElement(w.a, {
						currentProfileName: u,
						dropdownId: Ee("-overflow-menu", ce.id, L, F),
						ignoreOverflowMenuBreakpoints: Ae,
						isCommentsPage: N,
						isFixed: F,
						isOverlay: !!L,
						isProfilePostListing: D,
						isRecommendationPost: ot,
						layout: U,
						modModeWithPost: V && g,
						onClickInsightsButton: Q,
						pageLayer: ie,
						permalink: ce.permalink,
						postId: $e,
						sendEvent: ue,
						shouldShowInsightsButton: Me,
						showEditPost: !!_e,
						showEditFlair: !!pe,
						useFlatlistBreakpoints: e.useFlatlistBreakpoints,
						toggleAddEventStartTimeModal: ve,
						toggleEditStartTimeModal: ve
					})), t === Object(Y.t)(ce.id, L) && o.a.createElement(ne.a, {
						subredditId: ce.belongsTo.id,
						onClose: Ue,
						postId: ce.id,
						onSelectCollection: qe,
						titleText: s.fbt._("Add post to a collection", null, {
							hk: "38vSyF"
						}),
						onItemHoverActionText: s.fbt._("Add", null, {
							hk: "2wi3d4"
						}),
						isOverlay: L
					}), t === Object(Y.s)(ce.id, L, Y.k.POST_OVERFLOW_MENU) && me && o.a.createElement(me, {
						onChange: a,
						onClose: ve,
						schedule: Object(p.c)(ce),
						shouldShowDeleteButton: !1
					}), t === Object(Y.u)(ce.id, L) && o.a.createElement(se.a, {
						onCancel: Be,
						onCollectionCreated: qe,
						subredditId: ce.belongsTo.id
					}), t === Object(I.b)(ce.id, L) && o.a.createElement(I.a, {
						flairs: ce.flair,
						subredditId: ce.belongsTo.id,
						modalId: Object(I.b)(ce.id, L),
						onFlairChanged: ee
					}), o.a.createElement("div", {
						className: le.a.flexSpacer
					})), nt && !rt && !De && o.a.createElement(x.a, {
						className: Object(d.a)(le.a.liveDiscussionWrapper, {
							[le.a.modLargePost]: M && g
						}),
						postId: ce.postId
					}))
				});
			Oe.displayName = "Flatlist";
			const Ee = (e, t, n, s) => {
					let r = t;
					return n && (r += "-overlay"), s && (r += "-sticky"), r += e
				},
				ye = ge(xe(Object(P.c)(Oe)));
			t.c = o.a.memo((function(e) {
				const t = Object(re.a)();
				return o.a.createElement(ye, ue({}, e, {
					searchIgnoreClick: t
				}))
			}))
		},
		"./src/reddit/components/Footer/index.m.less": function(e, t, n) {
			e.exports = {
				FooterContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				footerContainer: "_3qDK09Tb3ktpZiYXSfeMzE",
				mIsWhite: "_3TyrvwTfHlJHEevBoOKkDJ",
				PrivacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				privacyLink: "_2mk2nvnRu7inPdJY2i-H79",
				UserAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				userAgreement: "_2qv_r3Tr8ZqOWkU9s1qRfw",
				UserAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				userAgreementLink: "vzd9DQ5W5uhRFvqy1_xKh",
				mIsGrey: "_2g4mHpbVF30jxvk8ZPbqBe"
			}
		},
		"./src/reddit/components/Footer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/Footer/index.m.less"),
				c = n.n(d);
			const {
				fbt: l
			} = n("./node_modules/fbt/lib/FbtPublic.js"), u = a.a.div("UserAgreement", c.a), m = a.a.a("UserAgreementLink", c.a), p = a.a.a("PrivacyLink", c.a);
			var b;
			! function(e) {
				e.Grey = "grey", e.White = "white"
			}(b || (b = {}));
			t.b = e => r.a.createElement("div", {
				className: Object(i.a)(c.a.FooterContainer, {
					[c.a.mIsGrey]: e.textColor === b.Grey,
					[c.a.mIsWhite]: e.textColor === b.White
				})
			}, r.a.createElement(u, null, l._("Use of this site constitutes acceptance of our {=User Agreement} and {=Privacy Policy.} ©{year} reddit inc. All rights reserved. REDDIT and the ALIEN Logo are registered trademarks of reddit inc.", [l._param("=User Agreement", r.a.createElement(m, {
				href: `${o.a.redditUrl}/help/useragreement`
			}, l._("User Agreement", null, {
				hk: "YviZP"
			}))), l._param("=Privacy Policy.", r.a.createElement(p, {
				href: `${o.a.redditUrl}/help/privacypolicy`
			}, l._("Privacy Policy.", null, {
				hk: "1fsgYq"
			}))), l._param("year", (new Date).getFullYear())], {
				hk: "3wzgp7"
			})))
		},
		"./src/reddit/components/GeoForm/GeoForm.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return k
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/hooks/useMounted.ts"),
				u = n("./node_modules/p-debounce/index.js"),
				m = n.n(u),
				p = n("./src/lib/hooks/useOnClickOutside.ts"),
				b = n("./src/reddit/constants/keycodes.ts"),
				f = n("./src/lib/makeGqlRequest/index.ts"),
				h = n("./src/lib/sentry/index.ts"),
				_ = n("./src/redditGQL/operations/GeoPlaceAutocomplete.json");
			! function(e) {
				e.GoogleMaps = "GOOGLE_MAPS", e.Geonames = "GEONAMES"
			}(s || (s = {}));
			const g = (e, t) => async n => {
				let s;
				try {
					s = await async function(e, t) {
						return Object(f.a)(e, {
							..._,
							variables: t
						})
					}(e(), {
						query: n,
						sessionId: t
					})
				} catch (r) {
					return h.c.captureException(r), []
				}
				return s.body.data.geoPlaceAutocomplete || []
			};
			var v = n("./src/reddit/hooks/useGqlContext.ts"),
				x = n("./src/reddit/icons/svgs/Location/index.tsx"),
				O = n("./src/reddit/components/GeoForm/index.m.less"),
				E = n.n(O);

			function y(e) {
				const {
					value: t,
					setValue: n,
					setPlace: s,
					disabled: a,
					onFocus: c,
					sessionId: l,
					className: u
				} = e, p = Object(v.a)(), [f, h] = Object(o.useState)(!1), _ = function(e, t, n) {
					const [s, r] = Object(o.useState)([]), i = Object(o.useMemo)(() => m()(n, 300), [n]);
					return Object(o.useEffect)(() => {
						e && t && i(e).then(e => {
							r(e)
						}).catch(() => r([]))
					}, [e]), s
				}(t, f, g(p, l)), {
					highlightValue: O,
					selectedIndex: y,
					onKeyDown: j,
					isClosed: k,
					setClosed: I
				} = function(e, t, n) {
					const [s, r] = Object(o.useState)(-1), [i, a] = Object(o.useState)(!!e.length), [d, c] = Object(o.useState)(void 0);
					return {
						highlightValue: d,
						selectedIndex: s,
						onKeyDown: o => {
							if (o.key === b.b.ArrowDown) {
								const t = Math.min(s + 1, e.length - 1);
								r(t), c(e[t])
							} else if (o.key === b.b.ArrowUp) {
								const t = Math.max(s - 1, -1);
								r(t), c(e[t])
							} else o.key === b.b.Enter && s > -1 ? (r(-1), t(e[s].name), n(e[s]), a(!0), o.preventDefault()) : o.key === b.b.Escape ? (r(-1), a(!0)) : c(void 0)
						},
						isClosed: i,
						setClosed: a
					}
				}(_, n, s), S = `location-input-${l}`;
				return i.a.createElement("div", {
					className: E.a.autocompleteInput
				}, i.a.createElement("label", {
					className: E.a.geoLabel,
					htmlFor: S
				}, i.a.createElement(x.a, {
					className: E.a.locationIcon
				})), i.a.createElement("input", {
					className: Object(d.a)(E.a.geoInput, u),
					name: S,
					disabled: a,
					onKeyDown: j,
					value: O && O.name || t,
					placeholder: r.fbt._("Add location", null, {
						hk: "1BaqFd"
					}),
					onChange: e => {
						n(e.currentTarget.value), s(void 0), I(!1)
					},
					onFocus: () => {
						h(!0), c()
					},
					onBlur: () => h(!1)
				}), _.length && !k ? i.a.createElement(C, {
					id: l,
					items: _.map(e => e.name),
					selectedIndex: y,
					selectValue: e => {
						n(_[e].name), s(_[e]), I(!0)
					},
					onClickOutside: () => I(!0)
				}) : null)
			}

			function C(e) {
				const {
					id: t,
					items: n,
					selectedIndex: s,
					selectValue: r,
					onClickOutside: o
				} = e;
				return Object(p.a)(`autocomplete-dropdown-${t}`, o), i.a.createElement("ul", {
					className: E.a.autocompleteDropdown,
					id: `autocomplete-dropdown-${t}`
				}, n.map((e, t) => i.a.createElement("li", {
					key: `${e}${t}`,
					onClick: () => r(t),
					className: Object(d.a)({
						[E.a.highlight]: t === s
					})
				}, e)))
			}
			const j = () => {};

			function k(e) {
				const {
					className: t,
					initialValue: n,
					initialPlace: s,
					disabled: u = !1,
					onFocus: m = j,
					onPlace: p = j,
					onValue: b = j,
					inputClassName: f
				} = e, h = Object(l.a)(), [_] = Object(o.useState)(() => Object(a.a)()), [g, v] = Object(o.useState)(n || ""), [x, O] = Object(o.useState)(s);
				return h ? i.a.createElement("form", {
					className: Object(d.a)(E.a.geoForm, t),
					onSubmit: t => {
						t.preventDefault(), (null == s ? void 0 : s.id) !== (null == x ? void 0 : x.id) && e.onSubmit({
							name: g,
							place: x,
							sessionId: _
						})
					}
				}, i.a.createElement(y, {
					className: f,
					value: g,
					sessionId: _,
					setValue: e => {
						v(e), b(e)
					},
					setPlace: e => {
						O(e), p(e)
					},
					disabled: u,
					onFocus: m
				}), x && x.id !== (null == s ? void 0 : s.id) && i.a.createElement(c.o, {
					className: E.a.submitButton,
					type: "submit",
					disabled: u
				}, r.fbt._("Submit", null, {
					hk: "4aU3dh"
				}))) : null
			}
		},
		"./src/reddit/components/GeoForm/index.m.less": function(e, t, n) {
			e.exports = {
				geoForm: "dnC9V9HtkUxsmza-vEXgC",
				geoLabel: "_3T9bJ1ttSXUxb9rxZI9jMC",
				locationIcon: "_2Jm0p-hd1-KYZJI9iP3n6",
				geoInput: "_2O28-fZaU1kYnMmsiMKw3y",
				autocompleteInput: "oP84ZJjEgYLr154hrXHd8",
				autocompleteDropdown: "_1pwsnPyclgUCyjdfT0xWmx",
				highlight: "_1kfPE4TrjHsTFgvmrF1s33"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_17AlFvm1kWw8NYe0FZKlMB",
				newBadge: "_18TPfQgPhTmXJ8270Nc5nM",
				text: "_26N1OuVJykHlztxQkPEfqb",
				freeAwardTooltip: "_1C7AEhBd1Od4VDczirG0jB",
				freeAwardContainer: "P0AA_X8_E-4IwAxzn2uke"
			}
		},
		"./src/reddit/components/GiveAwardTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/hooks/useTracking.ts"),
				a = n("./src/reddit/helpers/trackers/freeAwardOffer.ts"),
				d = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				c = n("./src/reddit/components/ContentTooltip/index.tsx"),
				l = n("./src/reddit/components/GiveAwardTooltip/index.m.less"),
				u = n.n(l);
			const {
				fbt: m
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = e => {
				const {
					tooltipId: t
				} = e, n = Object(o.e)(d.b), l = Object(i.a)();
				return Object(s.useEffect)(() => {
					n && l(Object(a.c)())
				}, [n, l]), n ? r.a.createElement(c.a, {
					className: u.a.freeAwardTooltip,
					caretColor: {
						bottom: "#F6481E"
					},
					tooltipSizeEstimate: {
						height: 48,
						width: 148
					},
					tooltipId: t,
					defaultTooltipPosition: "top"
				}, r.a.createElement("div", {
					className: u.a.freeAwardContainer
				}, m._("Tap to give your {award name} Award", [m._param("award name", n.name)], {
					hk: "2EMqbP"
				}))) : null
			}
		},
		"./src/reddit/components/GrantUserFlair/index.m.less": function(e, t, n) {
			e.exports = {
				titleRow: "_1knBg4PWacEaLvDRHAvsTp",
				flairDetails: "_2bPY-7msbc_UjCac-In6Li",
				flairEditColumn: "_2ebZb7SML8ZCy-QsS6tUc0",
				column: "_3vuuCvX3U56Wb64Bz3AX9W",
				iconsColumn: "Q9C1YLEYQHPi_NuLIcsS3",
				removeIcon: "_2IP600IxdVV8-hzfus_xst",
				removeButton: "Yd-aY1XSmw6atYPPJHm9n",
				row: "_3W5UQ4TDClfiDY4zEBYSqT",
				flairEditHelperText: "_2JpPK1gCbDBJBbMRrx-fe6",
				errorIndicator: "_1gmumWT2YihpY16NJJw_ac",
				hasError: "Uu_my_fNiUJaUT-wFhyeq",
				flairContainer: "_1c46XAzSY3wg6lATaRh11v",
				userLink: "_14IDyvxQsRUGTR9unevdzm",
				textInput: "_3OzKI46CUHBipWh2v7Cfq",
				dropdownTriangle: "_3L2zEwdN8hdor-MjnuTTXx",
				dropdownTarget: "_2q91kdzeOjUsLeozfWfPZI",
				dropdownContainer: "_2SgxV6WihN0lLBZ06jChDN",
				dropdownRow: "Hsh_7uWgjhtYFcA5QqiI6",
				userIcon: "uHVmBRWHNpGMMkIFBthWs",
				modIcon: "_31YDoZrj2KLLxWJhYimRfb",
				infoTooltip: "i75byXeh_ZzdbD0HGxb4",
				tooltipText: "_3FXJw0xh37YZHaJP_j3Npe",
				tooltipIconContainer: "_1dZeti3tpsM8YrfluheTX5",
				tooltipIconRow: "_2B9YDCXdUsKx20YPQ_0guj",
				tooltipIconText: "_2_doCenMWfLXsGEvDSq1NB",
				cssInputError: "_3ySNKx0QJZRCNOFB6345zX",
				bottomBarRow: "Tf16TWgXZcNKzLmD4PDPq",
				topBar: "e-h9YD6UZh8FOUPTG6drY",
				disabledBanner: "_3rrCSsx0QD7pFwGJquTq-6",
				warningIcon: "_3MSU8YNfdz6icABES0GIkK",
				emptyList: "y4YDfdWBHO7s3GVuYjBDF",
				flairIcon: "_3RYWcdo8Ov1AjwCGeCUsfs",
				mainText: "_8uYoAAuUrGW1iwcBP-2eS",
				fadeIn: "_3YR0vW4lNgbJJ7RgssVmf-"
			}
		},
		"./src/reddit/components/GrantUserFlair/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/find.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts"),
				m = n("./src/lib/omitKey/index.ts"),
				p = n("./src/lib/stripQueryParams/index.ts"),
				b = n("./src/reddit/actions/grantUserFlair/index.ts"),
				f = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				_ = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				g = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				v = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				x = n("./src/lib/classNames/index.ts"),
				O = n("./src/reddit/components/SaveIndicator/index.m.less"),
				E = n.n(O),
				y = n("./src/reddit/icons/svgs/CheckmarkFitted/index.tsx"),
				C = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				j = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				k = n("./src/reddit/models/ApiRequestState/index.ts");
			const I = {
				[k.a.Pending]: () => r.fbt._("Saving", null, {
					hk: "3r9uZO"
				}),
				[k.a.Complete]: () => r.fbt._("Saved", null, {
					hk: "e9tAk"
				}),
				[k.a.Failed]: () => r.fbt._("Save error", null, {
					hk: "3NFi3S"
				})
			};
			var S = e => d.a.createElement(d.a.Fragment, null, e.status === k.a.Pending && d.a.createElement(j.a, {
					className: Object(x.a)(E.a.icon, E.a.pendingIcon)
				}), e.status === k.a.Complete && d.a.createElement(y.a, {
					className: Object(x.a)(E.a.icon, E.a.savedIcon)
				}), e.status === k.a.Failed && d.a.createElement(C.a, {
					className: Object(x.a)(E.a.icon, E.a.saveErrorIcon)
				}), d.a.createElement("span", {
					className: E.a.caption
				}, I[e.status]())),
				w = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				T = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				N = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				P = n("./src/reddit/components/TrackingHelper/index.tsx"),
				R = n("./src/reddit/constants/colors.ts"),
				A = n("./src/reddit/contexts/PageLayer/index.tsx"),
				M = n("./src/reddit/helpers/flair.ts"),
				L = n("./src/reddit/selectors/telemetry.ts");
			const D = e => ({
					subreddit: L.kb(e),
					profile: L.T(e),
					userSubreddit: L.ub(e)
				}),
				F = e => t => ({
					source: "grant_user_flair",
					action: "click",
					noun: e,
					...D(t)
				}),
				U = () => F("search_username"),
				B = () => F("page_forward"),
				q = () => F("page_back"),
				G = () => F("remove_granted_user_flair"),
				H = (e, t) => n => ({
					source: "grant_user_flair",
					action: "autosave",
					noun: e,
					actionInfo: {
						...L.d(n),
						settingValue: t
					},
					...D(n)
				}),
				W = () => H("flair_text"),
				V = e => H("flair_template", e || "none"),
				z = e => H("css_class", e);
			var K = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				Q = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				Y = n("./src/reddit/icons/svgs/User/index.tsx"),
				J = n("./src/reddit/models/SubredditModeration/index.ts");
			const X = [];
			var Z = n("./src/reddit/selectors/meta.ts"),
				$ = n("./src/reddit/selectors/userFlair.ts"),
				ee = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				te = n("./src/reddit/components/GrantUserFlair/index.m.less"),
				ne = n.n(te);
			var se = () => d.a.createElement("div", {
					className: ne.a.emptyList
				}, d.a.createElement(ee.a, {
					className: ne.a.flairIcon
				}), d.a.createElement("div", {
					className: ne.a.mainText
				}, r.fbt._("You do not have any users with user flair", null, {
					hk: "4D1S5Z"
				})), d.a.createElement("div", null, r.fbt._("Search for a user to assign a user flair", null, {
					hk: "2YaDOy"
				}))),
				re = n("./node_modules/lodash/filter.js"),
				oe = n.n(re),
				ie = n("./node_modules/lodash/isEqual.js"),
				ae = n.n(ie),
				de = n("./node_modules/lodash/omit.js"),
				ce = n.n(de),
				le = n("./src/reddit/constants/flair.ts"),
				ue = n("./src/reddit/helpers/validateFlairCssClass.ts");
			const me = 200;
			var pe;
			! function(e) {
				e[e.Save = 0] = "Save", e[e.Delete = 1] = "Delete"
			}(pe || (pe = {}));
			const be = e => null === e.flair,
				fe = e => !(!e.apiError && !e.clientValidationError),
				he = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					const n = Date.now();
					return oe()(e, e => {
						if (!e || e.clientValidationError) return !1;
						if (e.apiError && !t) return !1;
						if (be(e)) return !0;
						return n - e.changedAt > 2e3 || t
					})
				},
				_e = (e, t, n) => {
					const s = Object.keys(e).filter(s => {
						const r = e[s],
							o = t[s] || null;
						return !(!!o || s === n || !fe(r)) || !!ae()(o, r.flair)
					});
					return s.length ? ce()(e, s) : e
				},
				ge = (e, t) => {
					const n = t || le.a;
					return (e ? Object(M.m)(e, n) || Object(ue.a)(e.cssClass || "") : "") || void 0
				};
			var ve = n("./node_modules/lodash/noop.js"),
				xe = n.n(ve),
				Oe = n("./src/reddit/components/Flair/index.tsx"),
				Ee = n("./src/reddit/components/FlairSearch/FlairEdit/helper.tsx"),
				ye = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				Ce = n("./src/reddit/controls/InternalLink/index.tsx"),
				je = n("./src/reddit/icons/svgs/Remove/index.tsx"),
				ke = n("./src/reddit/models/Flair/index.ts"),
				Ie = n("./src/higherOrderComponents/asTooltip.tsx"),
				Se = n("./src/reddit/actions/tooltip.ts"),
				we = n("./src/reddit/constants/keycodes.ts"),
				Te = n("./src/reddit/controls/Dropdown/index.tsx"),
				Ne = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				Pe = n("./src/reddit/selectors/tooltip.ts");
			const Re = e => `UserFlairPicker--${e}`,
				Ae = Object(Ie.a)(Te.a),
				Me = e => {
					let {
						flair: t
					} = e;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(Oe.b, {
						flair: Object(M.c)(t),
						forceSmallEmojis: !0
					}), t.textEditable && d.a.createElement(Y.a, {
						className: ne.a.userIcon
					}), t.modOnly && d.a.createElement(K.a, {
						className: ne.a.modIcon
					}))
				},
				Le = Object(l.c)({
					isDropdownOpen: (e, t) => Object(Pe.b)(Re(t.userName))(e)
				});
			class De extends d.a.Component {
				constructor(e) {
					super(e), this.onSetFocus = e => {
						this.setState({
							focusedIndex: e
						})
					}, this.findNextFocusableItem = () => {
						if (void 0 === this.state.focusedIndex) return -1; {
							const e = this.state.focusedIndex + 1;
							if (e <= this.props.templateIds.length - 1) return e
						}
					}, this.onMouseEnter = e => {
						const t = document.getElementById(`focus-${e}`);
						t && (t.focus(), this.onSetFocus(e))
					}, this.findPreviousFocusableItem = () => {
						if (void 0 !== this.state.focusedIndex && -1 !== this.state.focusedIndex) return this.state.focusedIndex - 1
					}, this.onKeyDown = e => {
						if (e.keyCode === we.a.ArrowDown)
							if (e.preventDefault(), this.props.isDropdownOpen) {
								const e = this.findNextFocusableItem();
								if (void 0 !== e) {
									const t = document.getElementById(`focus-${e}`);
									t && (t.focus(), t.scrollIntoView({
										block: "nearest"
									})), this.onSetFocus(e)
								}
							} else this.props.onToggleDropdown();
						if (e.keyCode === we.a.ArrowUp) {
							e.preventDefault();
							const t = this.findPreviousFocusableItem();
							if (void 0 !== t) {
								const e = document.getElementById(`focus-${t}`);
								e && (e.focus(), e.scrollIntoView({
									block: "nearest"
								})), this.onSetFocus(t)
							}
						}
						if (e.keyCode === we.a.Tab && this.props.isDropdownOpen && e.preventDefault(), e.keyCode === we.a.Enter) {
							if (e.preventDefault(), e.stopPropagation(), this.props.isDropdownOpen && void 0 !== this.state.focusedIndex) {
								const e = this.props.templateIds[this.state.focusedIndex];
								this.props.onSelectFlairTemplate(e)
							}
							this.props.onToggleDropdown()
						}
					}, this.state = {}
				}
				render() {
					const {
						props: e
					} = this;
					return d.a.createElement("button", {
						className: ne.a.dropdownTarget,
						id: Re(e.userName),
						onClick: e.onToggleDropdown,
						onKeyDown: this.onKeyDown
					}, e.selectedTemplateId && e.userFlairTemplates[e.selectedTemplateId] ? d.a.createElement(Me, {
						flair: e.userFlairTemplates[e.selectedTemplateId]
					}) : r.fbt._("none", null, {
						hk: "ng6B"
					}), d.a.createElement(Ne.a, {
						className: ne.a.dropdownTriangle
					}), d.a.createElement(Ae, {
						className: ne.a.dropdownContainer,
						isOpen: e.isDropdownOpen,
						tooltipId: Re(e.userName)
					}, d.a.createElement("button", {
						className: ne.a.dropdownRow,
						id: "focus--1",
						onClick: () => e.onSelectFlairTemplate(void 0),
						onMouseEnter: () => this.onMouseEnter(-1),
						tabIndex: -1
					}, r.fbt._("none", null, {
						hk: "ng6B"
					})), e.templateIds.map((t, n) => {
						const s = e.userFlairTemplates[t];
						return d.a.createElement("button", {
							className: ne.a.dropdownRow,
							id: `focus-${n}`,
							key: t,
							onClick: () => e.onSelectFlairTemplate(t),
							onMouseEnter: () => this.onMouseEnter(n),
							tabIndex: -1
						}, d.a.createElement(Me, {
							flair: s
						}))
					})))
				}
			}
			var Fe = Object(c.b)(Le, (e, t) => ({
				onToggleDropdown: () => e(Object(Se.h)({
					tooltipId: Re(t.userName)
				}))
			}))(De);
			const Ue = e => `emoji-picker-${e}`,
				Be = Object(M.b)();
			class qe extends d.a.PureComponent {
				constructor() {
					super(...arguments), this.onSelectFlairTemplate = e => {
						const t = e && this.props.userFlairTemplates[e],
							n = t ? Object(M.c)(t) : Be;
						this.props.onChange(this.props.username, n)
					}, this.onFlairContentChanged = e => {
						this.props.onChange(this.props.username, e)
					}, this.onChangeCssClass = e => {
						const t = e.target.value,
							n = this.props.flair || Be;
						this.props.onChange(this.props.username, {
							...n,
							cssClass: t
						})
					}, this.removeFlair = () => {
						this.props.onChange(this.props.username, null)
					}
				}
				render() {
					var e;
					const {
						props: t
					} = this, {
						hasError: n
					} = t, s = t.flair || Be, r = Object(Ee.a)(), o = s.templateId, i = o && (null === (e = t.userFlairTemplates) || void 0 === e ? void 0 : e[o]) || le.a, a = !!i && i.modOnly, c = !Object(ue.a)(s.cssClass || "");
					return d.a.createElement("div", {
						className: Object(x.a)(ne.a.row, n ? ne.a.hasError : null)
					}, d.a.createElement("div", {
						className: ne.a.errorIndicator
					}, d.a.createElement(C.a, null)), d.a.createElement(Ce.default, {
						className: ne.a.userLink,
						to: `/user/${t.username}`
					}, d.a.createElement(ye.a, {
						user: t.username,
						tooltipId: `grantuserflair--userhovercard--${t.username}`,
						subredditId: t.subredditId,
						sendHoverCardEvent: xe.a
					}, t.username, d.a.createElement("div", {
						className: ne.a.flairContainer
					}, d.a.createElement(Oe.b, {
						flair: s
					})))), d.a.createElement("div", {
						className: ne.a.flairDetails
					}, d.a.createElement("div", {
						className: ne.a.column
					}, d.a.createElement(Fe, {
						onSelectFlairTemplate: this.onSelectFlairTemplate,
						selectedTemplateId: o,
						templateIds: t.templateIds,
						userFlairTemplates: t.userFlairTemplates,
						userName: this.props.username
					})), d.a.createElement("div", {
						className: ne.a.flairEditColumn
					}, d.a.createElement(r, {
						allowBlank: !t.isChanged,
						emojiPickerId: Ue(t.username),
						flair: s,
						flairTemplateType: ke.d.UserFlair,
						flairTemplate: i,
						helperTextClass: ne.a.flairEditHelperText,
						isCompact: !0,
						isFlairModOnly: a,
						onChange: this.onFlairContentChanged,
						subredditId: t.subredditId
					})), d.a.createElement("div", {
						className: ne.a.column
					}, d.a.createElement("input", {
						className: Object(x.a)(ne.a.textInput, {
							[ne.a.cssInputError]: !c
						}),
						value: s.cssClass || "",
						onChange: this.onChangeCssClass,
						disabled: !!i.id
					})), d.a.createElement("button", {
						className: ne.a.removeButton,
						onClick: this.removeFlair
					}, d.a.createElement(je.a, {
						className: ne.a.removeIcon
					}))))
				}
			}
			var Ge = qe;
			const He = {},
				We = Object(A.v)({
					currentPageUrl: A.f
				}),
				Ve = Object(l.c)({
					flairedUserOrder: (e, t) => {
						const n = Object(J.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.userOrder[n] || X
					},
					flairedUsers: (e, t) => e.pages.modHub.flairedUsers.models[t.subredditId],
					isFlairedUsersListPending: e => e.pages.modHub.flairedUsers.api.pending,
					isSearchPending: e => e.pages.modHub.flairedUsers.search.api.pending,
					isUserFlairEnabled: $.a,
					origin: Z.k,
					pageInfo: (e, t) => {
						const n = Object(J.e)(t.subredditId, t.after, t.before);
						return e.pages.modHub.flairedUsers.pageInfo[n]
					},
					searchResult: (e, t) => e.pages.modHub.flairedUsers.search.result,
					userFlairData: $.d
				}),
				ze = Object(c.b)(Ve, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						deleteUserFlair: (t, n) => e(Object(b.a)(t, n)),
						saveFlairedUser: (t, s) => e(Object(b.c)(t, n, s)),
						searchFlairedUser: t => e(Object(b.d)(n, t))
					}
				});
			class Ke extends d.a.Component {
				constructor(e) {
					var t;
					super(e), t = this, this.isUnmounted = !1, this.pendingRequestsMap = new Map, this.autoSaveIntervalId = 0, this.processChanges = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
						t.autoSaveIntervalId || (t.autoSaveIntervalId = window.setInterval(t.processChanges, me));
						const {
							flairedUsers: n
						} = t.props, {
							unsavedChanges: s,
							searchTerm: r
						} = t.state, o = _e(s, n, r), i = he(o, e);
						i.forEach(t.sendChangeToServer), o !== s && t.setState({
							unsavedChanges: o
						})
					}, this.sendChangeToServer = async e => {
						const t = e.username;
						if (this.pendingRequestsMap.get(t)) return;
						const n = this.props.flairedUsers[t] || null;
						this.sendTelemetryEvents(n, e.flair);
						const s = e.flair ? {
							type: pe.Save,
							promise: this.props.saveFlairedUser(t, e.flair)
						} : {
							type: pe.Delete,
							promise: this.props.deleteUserFlair(t, this.props.subredditId)
						};
						this.pendingRequestsMap.set(t, s);
						const r = await s.promise;
						this.pendingRequestsMap.delete(t), this.isUnmounted || this.setState(n => {
							const s = n.unsavedChanges[t];
							return e !== s ? null : {
								unsavedChanges: !0 === r ? Object(m.a)(n.unsavedChanges, t) : {
									...this.state.unsavedChanges,
									[t]: {
										...e,
										apiError: r
									}
								}
							}
						})
					}, this.onFlairChanged = (e, t) => {
						const {
							templates: n
						} = this.props.userFlairData, s = t && t.templateId ? n[t.templateId] : void 0;
						this.setState(n => {
							return {
								unsavedChanges: {
									...n.unsavedChanges,
									[e]: {
										flair: t,
										username: e,
										changedAt: Date.now(),
										clientValidationError: ge(t, s)
									}
								}
							}
						})
					}, this.onSearch = e => {
						this.props.searchFlairedUser(e), this.setState({
							searchTerm: e
						}), this.props.sendEvent(U())
					}, this.onCancelSearch = () => {
						this.setState({
							searchTerm: null
						})
					}, this.onClickNextPage = () => this.props.sendEvent(B()), this.onClickPrevPage = () => this.props.sendEvent(q()), this.renderUserRow = e => {
						const {
							state: t,
							props: n
						} = this, s = n.flairedUsers[e] || null, r = t.unsavedChanges[e], o = r && !be(r) ? r.flair : s;
						return d.a.createElement(Ge, {
							flair: o,
							hasError: !!r && fe(r),
							isChanged: !!r,
							key: e,
							onChange: this.onFlairChanged,
							subredditId: n.subredditId,
							templateIds: n.userFlairData.templateIds,
							userFlairTemplates: n.userFlairData.templates,
							username: e
						})
					}, this.state = {
						searchTerm: null,
						unsavedChanges: He
					}
				}
				componentDidUpdate() {
					this.processChanges()
				}
				componentWillUnmount() {
					this.isUnmounted = !0, this.processChanges(!0), window.clearInterval(this.autoSaveIntervalId)
				}
				sendTelemetryEvents(e, t) {
					if (!t) return void this.props.sendEvent(G());
					let n = e || Object(M.b)();
					const s = n.templateId || void 0,
						r = t.templateId || void 0;
					if (r !== s) {
						this.props.sendEvent(V(r));
						const e = t.templateId && this.props.userFlairData.templates[t.templateId];
						n = e ? Object(M.c)(e) : n
					}
					Object(M.p)(t, n) || this.props.sendEvent(W()), t.cssClass !== n.cssClass && this.props.sendEvent(z(t.cssClass || ""))
				}
				getIndicatorStatus() {
					const {
						unsavedChanges: e
					} = this.state;
					if (e === He) return null;
					const t = !!i()(e, e => fe(e));
					return !!i()(e, e => !fe(e)) ? k.a.Pending : t ? k.a.Failed : k.a.Complete
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = this.getIndicatorStatus(), i = t.pageInfo && (t.pageInfo.hasNextPage || t.pageInfo.hasPreviousPage), a = !t.flairedUserOrder.length && !i;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(v.c, {
						className: ne.a.topBar
					}, null !== o && d.a.createElement(S, {
						status: o
					})), d.a.createElement(v.a, null, d.a.createElement(v.b, null, r.fbt._("Grant user flair", null, {
						hk: "N1r42"
					}), d.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360028091332`
					})), !t.isUserFlairEnabled && d.a.createElement(f.a, {
						className: ne.a.disabledBanner,
						color: R.a.quarantine,
						icon: d.a.createElement(Q.a, {
							className: ne.a.warningIcon
						}),
						title: r.fbt._("User flair has been disabled for this community", null, {
							hk: "3BBvFe"
						}),
						subtitle: r.fbt._("User flair will not be displayed in posts or comments", null, {
							hk: "3E4WaA"
						})
					}), d.a.createElement(T.b, {
						activeSearchQuery: n.searchTerm,
						onSearch: this.onSearch
					}, t.pageInfo && !n.searchTerm && d.a.createElement(g.a, {
						prevTo: Object(u.a)(Object(p.a)(`${t.origin}${t.currentPageUrl}`), {
							before: t.pageInfo.startCursor
						}),
						prevButtonEnabled: t.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: t.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(p.a)(`${t.origin}${t.currentPageUrl}`), {
							after: t.pageInfo.endCursor
						})
					})), d.a.createElement("div", {
						className: ne.a.titleRow
					}, r.fbt._("Username with preview", null, {
						hk: "1RFjbI"
					}), d.a.createElement("div", {
						className: ne.a.flairDetails
					}, d.a.createElement("div", {
						className: ne.a.column
					}, r.fbt._("Flair template", null, {
						hk: "18cQfH"
					}), d.a.createElement(_.a, {
						className: ne.a.infoTooltip
					}, d.a.createElement("div", {
						className: ne.a.tooltipText
					}, r.fbt._("Flair templates determine the flair's background colors, text colors, and permissions", null, {
						hk: "4y58Eg"
					})), d.a.createElement("div", {
						className: ne.a.tooltipIconContainer
					}, d.a.createElement("div", {
						className: ne.a.tooltipIconRow
					}, d.a.createElement(K.a, {
						className: ne.a.modIcon
					}), d.a.createElement("span", {
						className: ne.a.tooltipIconText
					}, r.fbt._("Available only to mods", null, {
						hk: "2s7Gci"
					}))), d.a.createElement("div", {
						className: ne.a.tooltipIconRow
					}, d.a.createElement(Y.a, {
						className: ne.a.userIcon
					}), d.a.createElement("span", {
						className: ne.a.tooltipIconText
					}, r.fbt._("User editable", null, {
						hk: "3tIGRy"
					})))))), d.a.createElement("div", {
						className: ne.a.flairEditColumn
					}, r.fbt._("Flair text", null, {
						hk: "2ab8Up"
					}), d.a.createElement(_.a, {
						text: r.fbt._("Changes the text and emojis within the user flair", null, {
							hk: "4dBW4C"
						})
					})), d.a.createElement("div", {
						className: ne.a.column
					}, r.fbt._("Css class", null, {
						hk: "1TNNcJ"
					}), d.a.createElement(_.a, {
						text: r.fbt._("CSS classes determine styling for flair in old Reddit", null, {
							hk: "j4AU"
						})
					})))), n.searchTerm ? d.a.createElement(w.a, {
						cancelSearch: this.onCancelSearch,
						noResultsFound: !t.searchResult,
						searchTerm: n.searchTerm,
						searchPending: t.isSearchPending
					}, t.searchResult && this.renderUserRow(t.searchResult)) : t.isFlairedUsersListPending || !(null === (e = t.userFlairData) || void 0 === e ? void 0 : e.templates) ? d.a.createElement(N.a, null) : a ? d.a.createElement(se, null) : t.flairedUserOrder.map(this.renderUserRow), t.pageInfo && !n.searchTerm && d.a.createElement("div", {
						className: ne.a.bottomBarRow
					}, d.a.createElement(g.a, {
						prevTo: Object(u.a)(Object(p.a)(`${t.origin}${t.currentPageUrl}`), {
							before: t.pageInfo.startCursor
						}),
						prevButtonEnabled: t.pageInfo.hasPreviousPage,
						prevButtonOnClick: this.onClickPrevPage,
						nextButtonEnabled: t.pageInfo.hasNextPage,
						nextButtonOnClick: this.onClickNextPage,
						nextTo: Object(u.a)(Object(p.a)(`${t.origin}${t.currentPageUrl}`), {
							after: t.pageInfo.endCursor
						})
					}))))
				}
			}
			t.a = We(ze(Object(P.c)(Ke)))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/snoovatarModal.ts"),
				d = n("./src/reddit/actions/tooltip.ts"),
				c = n("./src/reddit/helpers/author.ts"),
				l = n("./src/reddit/helpers/isPost.ts"),
				u = n("./src/reddit/selectors/commentSelector.ts"),
				m = n("./src/reddit/selectors/gold/awardIcon.ts"),
				p = n("./src/reddit/selectors/moderatorPermissions.ts"),
				b = n("./src/reddit/selectors/modUserNotes.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/profile.ts"),
				_ = n("./src/reddit/selectors/structuredStyles.ts"),
				g = n("./src/reddit/selectors/subreddit.ts"),
				v = n("./src/reddit/selectors/tooltip.ts"),
				x = n("./src/reddit/selectors/user.ts"),
				O = n("./src/reddit/selectors/userFlair.ts"),
				E = n("./src/reddit/selectors/userPrefs.ts"),
				y = n("./src/reddit/selectors/platform.ts"),
				C = n("./src/reddit/components/Hovercards/AuthorHovercard/ModIdCard/async.tsx"),
				j = n("./node_modules/fbt/lib/FbtPublic.js"),
				k = n("./src/config.ts"),
				I = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				S = n("./src/lib/lessComponent.tsx"),
				w = n("./src/lib/prettyPrintNumber/index.ts"),
				T = n("./src/reddit/components/ChatButton/index.tsx"),
				N = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				P = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				R = n("./src/reddit/components/SubscribeButton/index.tsx"),
				A = n("./src/reddit/components/UserIcon/index.tsx"),
				M = n("./src/reddit/controls/Button/index.tsx"),
				L = n("./src/reddit/endpoints/profile/info.ts"),
				D = n("./src/reddit/helpers/trackers/authorHovercard.ts"),
				F = n("./src/reddit/icons/fonts/Info/index.tsx"),
				U = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				B = n("./src/reddit/icons/svgs/Premium/index.tsx"),
				q = n("./src/reddit/models/Gold/Award.ts"),
				G = n("./src/reddit/models/User/index.ts"),
				H = n("./src/reddit/components/HumanDate/index.tsx"),
				W = n("./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx"),
				V = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx"),
				z = n("./src/reddit/actions/inContextModeration.ts"),
				K = n("./src/reddit/actions/modal.ts"),
				Q = n("./src/reddit/actions/subredditModeration/ban.ts"),
				Y = n("./src/reddit/constants/modals.ts"),
				J = n("./src/reddit/components/Hovercards/helpers.ts"),
				X = n("./src/reddit/icons/fonts/index.tsx"),
				Z = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				$ = n("./src/reddit/selectors/bannedUser.ts"),
				ee = n("./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less"),
				te = n.n(ee);
			const {
				fbt: ne
			} = n("./node_modules/fbt/lib/FbtPublic.js"), se = Object(i.c)({
				hasModMailPermissions: Object(p.b)(Z.c.mail),
				isUserBanned: (e, t) => !!Object($.b)(e, {
					subredditId: t.subredditId,
					username: t.username
				}),
				user: (e, t) => Object(x.Bb)(e, {
					userName: t.username
				})
			});
			class re extends r.a.Component {
				componentDidMount() {
					this.props.requestUserBanInfo()
				}
				render() {
					const {
						className: e,
						contextId: t,
						hasModMailPermissions: n,
						isUserBanned: s,
						onUnbanUser: o,
						sendEvent: i,
						toggleBanModal: a,
						toggleMuteModal: d
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, s ? r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							o(this.props.user.id), i(D.e(t))
						}
					}, r.a.createElement(X.a, {
						name: "ban",
						isFilled: !0,
						className: te.a.icon
					}), ne._("Unban User", null, {
						hk: "1aASyW"
					})) : r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							a(), i(D.a(t))
						}
					}, r.a.createElement(X.a, {
						name: "ban",
						className: te.a.icon
					}), ne._("Ban User", null, {
						hk: "3OhuLx"
					})), n && r.a.createElement(J.a, {
						role: "button",
						onClick: () => {
							d(), i(D.d(t))
						}
					}, r.a.createElement(X.a, {
						name: "mod_mute",
						className: te.a.icon
					}), ne._("Mute User", null, {
						hk: "3MCujH"
					})))
				}
			}
			var oe = Object(o.b)(se, (e, t) => {
					let {
						username: n,
						subredditId: s,
						contextId: r
					} = t;
					return {
						onUnbanUser: t => e(Object(Q.e)(s, t)),
						requestUserBanInfo: () => e(Object(Q.c)(s, {
							username: n
						})),
						toggleBanModal: () => {
							e(Object(z.c)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(Q.a)(s, n))
						},
						toggleMuteModal: () => {
							e(Object(z.d)({
								username: n,
								subredditId: s,
								contextId: r
							})), e(Object(K.i)(Y.a.MUTE_USER))
						}
					}
				})(re),
				ie = n("./src/reddit/actions/userFlair/index.ts");
			const {
				fbt: ae
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			var de = Object(o.b)(null, (e, t) => ({
					onToggleUserFlairModal: () => e(Object(ie.g)(t.subredditId, t.username))
				}))(e => r.a.createElement(J.a, {
					role: "button",
					onClick: () => {
						e.onToggleUserFlairModal(), e.sendEvent(D.c(e.contextId))
					}
				}, r.a.createElement(X.a, {
					name: "tag",
					className: te.a.icon
				}), ae._("Edit user flair", null, {
					hk: "4mTxM"
				}))),
				ce = n("./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less"),
				le = n.n(ce);

			function ue() {
				return (ue = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const me = S.a.wrapped(A.a, "UserIcon", le.a),
				pe = S.a.wrapped(R.a, "SubscribeButton", le.a),
				be = S.a.wrapped(T.b, "ChatButton", le.a),
				fe = S.a.wrapped(B.a, "PremiumIcon", le.a),
				he = S.a.wrapped(I.a, "UserNameLink", le.a),
				_e = S.a.div("UserNameMetaData", le.a),
				ge = S.a.div("MetaDataItem", le.a),
				ve = S.a.div("Bullet", le.a),
				xe = S.a.div("UserNameContainer", le.a),
				Oe = S.a.div("KarmaGrid", le.a),
				Ee = S.a.div("GenericKarma", le.a),
				ye = S.a.a("InfoLink", le.a),
				Ce = S.a.div("KarmaCount", le.a),
				je = S.a.div("GenericKarmaLabel", le.a),
				ke = S.a.div("BannerImage", le.a),
				Ie = S.a.div("UserContainer", le.a),
				Se = S.a.div("BottomSpacer", le.a),
				we = S.a.div("Container", le.a),
				Te = e => r.a.createElement("div", null, r.a.createElement("div", null, r.a.createElement(he, {
					to: `/user/${e.userName}/`
				}, e.title || e.userName), e.user.isEmployee && r.a.createElement(U.a, {
					className: le.a.adminIcon,
					title: j.fbt._("Reddit admin", null, {
						hk: "15wBTE"
					})
				}), e.user.isGold && r.a.createElement(I.a, {
					to: "/premium"
				}, r.a.createElement(fe, null))), r.a.createElement(_e, null, r.a.createElement(ge, null, `u/${e.userName}`, r.a.createElement(ve, null, "•")), r.a.createElement(ge, null, (e.user.createdUtc || e.user.created) && r.a.createElement(H.d, {
					seconds: e.user.createdUtc || e.user.created
				})))),
				Ne = e => {
					const {
						user: {
							karma: t
						}
					} = e, n = {
						...L.a,
						...t
					};
					return r.a.createElement(Oe, null, r.a.createElement(Ee, null, r.a.createElement(Ce, null, Object(w.b)(n.fromPosts)), r.a.createElement(je, null, j.fbt._({
						"*": "Post Karma",
						_1: " Post Karma"
					}, [j.fbt._plural(n.fromPosts)], {
						hk: "3K4oaH"
					}))), r.a.createElement(Ee, null, r.a.createElement(Ce, null, Object(w.b)(n.fromComments)), r.a.createElement(je, null, j.fbt._({
						"*": "Comment Karma",
						_1: " Comment Karma"
					}, [j.fbt._plural(n.fromComments)], {
						hk: "3gKRx9"
					}))), r.a.createElement(Ee, null, r.a.createElement(Ce, null, Object(w.b)(n.fromAwardsReceived)), r.a.createElement(je, null, j.fbt._({
						"*": "Awardee Karma",
						_1: " Awardee Karma"
					}, [j.fbt._plural(n.fromAwardsReceived)], {
						hk: "3nzm9q"
					}), r.a.createElement(ye, {
						href: q.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, r.a.createElement(F.a, {
						className: le.a.infoIcon
					})))), r.a.createElement(Ee, null, r.a.createElement(Ce, null, Object(w.b)(n.fromAwardsGiven)), r.a.createElement(je, null, j.fbt._({
						"*": "Awarder Karma",
						_1: " Awarder Karma"
					}, [j.fbt._plural(n.fromAwardsGiven)], {
						hk: "4zXN3B"
					}), r.a.createElement(ye, {
						href: q.a,
						target: "_blank",
						rel: "noopener noreferrer"
					}, r.a.createElement(F.a, {
						className: le.a.infoIcon
					})))))
				},
				Pe = e => {
					var t, n;
					const {
						className: s,
						contextId: o,
						currentUser: i,
						hideNSFWPref: a,
						hoverId: d,
						isLoggedIn: c,
						onClickSnoovatar: l,
						moderatorPermissions: u,
						prefersReducedAnimations: m,
						profile: p,
						sendEvent: b,
						style: f,
						subredditId: h,
						topAwardIcon: _,
						userName: g,
						user: v,
						userFlair: x,
						isCurrentUserBanned: O,
						userProfileStyles: E,
						acceptChats: y,
						isCommentAuthorBlocked: C
					} = e;
					if (!v) return r.a.createElement(we, {
						style: f
					});
					const I = !!i && Object(G.e)(i) === g,
						S = !!(null == i ? void 0 : i.snoovatarFullBodyAsset),
						w = v.accountIcon || `${k.a.assetPath}/img/snoo_user_placeholder.png`,
						T = null == u ? void 0 : u.flair,
						P = null == u ? void 0 : u.access,
						R = (null == x ? void 0 : x.templateIds) && (null === (t = null == x ? void 0 : x.templateIds) || void 0 === t ? void 0 : t.length) > 0,
						A = null === (n = null == x ? void 0 : x.displaySettings) || void 0 === n ? void 0 : n.isEnabled,
						{
							awardedLastMonth: L
						} = v,
						F = !!v.snoovatarFullBodyAsset,
						U = v.isNSFW && a;
					let B;
					return B = F ? !U && E && E.bannerBackgroundImage || void 0 : U ? `${k.a.assetPath}/img/user-info-banner.png` : e.user.bannerImage, r.a.createElement(we, {
						className: s,
						id: d,
						style: f
					}, !F && B && r.a.createElement(ke, {
						style: {
							backgroundImage: `url('${B}')`
						}
					}), r.a.createElement(Ie, null, F ? r.a.createElement(V.a, {
						isHovercard: !0,
						bannerBackgroundImage: B,
						compact: !0,
						currentUserHasSnoovatar: S,
						isEmployee: v.isEmployee,
						isGold: v.isGold,
						isNSFW: v.isNSFW,
						isOwnProfile: I,
						onClickSnoovatar: () => l && l(),
						prefersReducedAnimations: !!m,
						snoovatarUrl: v.snoovatarFullBodyAsset,
						title: null == p ? void 0 : p.title,
						userCreated: v.created,
						username: g,
						url: `/user/${e.userName}/`
					}) : r.a.createElement(xe, null, r.a.createElement(me, {
						iconUrl: w,
						isNSFW: v.isNSFW,
						userName: g
					}), r.a.createElement(Te, {
						title: null == p ? void 0 : p.title,
						user: v,
						userName: g
					})), r.a.createElement(Ne, {
						user: v
					}), L && r.a.createElement(W.a, {
						recentAwardings: L,
						topAwardIcon: _,
						username: g
					}), c && !I && !O && y && !C && r.a.createElement(be, {
						contextId: o,
						priority: M.c.Secondary,
						userId: v.id,
						text: j.fbt._("Start Chat", null, {
							hk: "2mfqRE"
						}),
						isFullWidth: !0
					}), v.hasUserProfile && !O && !C && !I && v.enableFollowers && r.a.createElement(pe, {
						identifier: {
							name: e.user.username,
							type: "profile"
						},
						getEventFactory: e => Object(D.h)(e ? "unfollow" : "follow", o),
						isFullWidth: !0,
						small: !0
					})), P && o && !I && h && r.a.createElement(oe, {
						contextId: o,
						subredditId: h,
						sendEvent: b,
						username: g
					}), T && o && R && A && h && r.a.createElement(de, {
						contextId: o,
						subredditId: h,
						sendEvent: b,
						username: g
					}), r.a.createElement(N.i, {
						contextId: o,
						subredditId: h,
						user: v
					}), !(P || c) && r.a.createElement(Se, null))
				},
				Re = Object(P.a)(Pe),
				Ae = e => {
					const t = e.activeTooltipId === e.tooltipId && !e.collapsed;
					return r.a.createElement(Re, ue({
						isOpen: t
					}, e))
				};
			Ae.WrappedComponent = Pe;
			var Me = Ae;
			const Le = Object(i.c)({
					activeTooltipId: v.a,
					currentUser: x.l,
					isLoggedIn: x.R,
					hideNSFWPref: x.G,
					moderatorPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(p.n)(e, {
							subredditId: n
						}) : void 0
					},
					prefersReducedAnimations: E.d,
					profile: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(h.k)(e, {
							profileName: n
						})
					},
					topAwardIcon: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(m.e)(e, {
							userName: n,
							minSize: 32
						})
					},
					user: x.Bb,
					userFlair: (e, t) => {
						let {
							subredditId: n
						} = t;
						return n ? Object(O.d)(e, {
							subredditId: n
						}) : void 0
					},
					isCurrentUserBanned: (e, t) => !!Object(g.p)(t) && Object(g.jb)(e, t),
					userProfileStyles: (e, t) => Object(_.m)(e, Object(h.o)(e, t.userName)),
					acceptChats: (e, t) => {
						const n = Object(h.i)(e, {
							profileName: t.userName
						});
						return !n || n.acceptChats
					},
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(y.e)(e),
							r = n || s && Object(g.I)(e, s.name);
						return !!r && Object(p.i)(e, r)
					},
					trophyCase: (e, t) => Object(h.t)(e, Object(h.o)(e, t.userName)),
					isNightMode: x.eb,
					lastAuthorModNote: (e, t) => {
						if (!t.contextId) return;
						const n = Object(l.a)(t.contextId) ? Object(f.G)(e, {
							postId: t.contextId
						}) : Object(u.b)(e, {
							commentId: t.contextId
						});
						return Object(b.b)(e, null == n ? void 0 : n.authorId, t.subredditId)
					},
					userIsSubscriber: (e, t) => {
						let {
							userName: n
						} = t;
						return Object(g.kb)(e, {
							identifier: {
								name: n,
								type: "profile"
							}
						})
					}
				}),
				De = Object(o.b)(Le, (e, t) => ({
					onClickSnoovatar: () => e(Object(a.b)({
						clickSource: "user_hovercard"
					})),
					onHideTooltip: () => e(Object(d.i)())
				}));
			t.a = De(e => e.isModWithUserNotesPermissions ? r.a.createElement(C.b, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				currentUser: e.currentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				moderatorPermissions: e.moderatorPermissions,
				prefersReducedAnimations: e.prefersReducedAnimations,
				profile: e.profile,
				subredditId: e.subredditId,
				tooltipId: e.tooltipId,
				user: e.user,
				isCurrentUserBanned: e.isCurrentUserBanned,
				userName: e.userName,
				userProfileStyles: e.userProfileStyles,
				acceptChats: e.acceptChats,
				isCommentAuthorBlocked: e.isCommentAuthorBlocked,
				collapsed: e.collapsed,
				trophyCase: e.trophyCase,
				isNightMode: e.isNightMode,
				lastAuthorModNote: e.lastAuthorModNote,
				userIsSubscriber: e.userIsSubscriber
			}) : Object(c.a)(e.userName) ? null : r.a.createElement(Me, {
				activeTooltipId: e.activeTooltipId,
				contextId: e.contextId,
				currentUser: e.currentUser,
				isLoggedIn: e.isLoggedIn,
				hideNSFWPref: e.hideNSFWPref,
				hoverId: e.hoverId,
				moderatorPermissions: e.moderatorPermissions,
				onClickSnoovatar: e.onClickSnoovatar,
				prefersReducedAnimations: e.prefersReducedAnimations,
				profile: e.profile,
				sendEvent: e.sendEvent,
				subredditId: e.subredditId,
				topAwardIcon: e.topAwardIcon,
				tooltipId: e.tooltipId,
				tooltipType: e.tooltipType,
				user: e.user,
				userFlair: e.userFlair,
				isCurrentUserBanned: e.isCurrentUserBanned,
				userName: e.userName,
				userProfileStyles: e.userProfileStyles,
				acceptChats: e.acceptChats,
				isCommentAuthorBlocked: e.isCommentAuthorBlocked,
				collapsed: e.collapsed
			}))
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/ModActions.m.less": function(e, t, n) {
			e.exports = {
				icon: "xd9vrdS8_V6IVus6-mHAM"
			}
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/Hovercards/HoverDiv/index.tsx"),
				i = n("./src/reddit/components/Hovercards/AuthorHovercard/HoverCard.tsx"),
				a = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = Object(a.c)(e => {
				const t = `${e.tooltipId}-hover-id`;
				return r.a.createElement(o.a, {
					className: e.wrapperClassName,
					hoverId: t,
					sendHoverEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId,
					authorOrSubredditName: e.user
				}, e.children, r.a.createElement(i.a, {
					className: e.className,
					hoverId: t,
					sendEvent: e.sendEvent,
					subredditId: e.subredditId,
					tooltipId: e.tooltipId,
					tooltipType: e.tooltipType,
					userName: e.user
				}))
			})
		},
		"./src/reddit/components/Hovercards/AuthorHovercard/userOptions.m.less": function(e, t, n) {
			e.exports = {
				ChatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				chatButton: "_3OdnAY8EYU3x_Nni3KnKwI",
				UserIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				userIcon: "_3_NawY8A3QCHkZUHnxDxUP",
				SubscribeButton: "yFByQg8RzENoqoOt0ysAk",
				subscribeButton: "yFByQg8RzENoqoOt0ysAk",
				PremiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				premiumIcon: "_3YJqiyvx8zFvv30tmg36S-",
				Token: "_2U0P3n4v75sHsDvQmSKNz3",
				token: "_2U0P3n4v75sHsDvQmSKNz3",
				UserNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				userNameLink: "_1oT4pd8QlZQZ1wGOk9VAaQ",
				UserNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				userNameMetaData: "_1wu7a98opA-mU9WUQpJIuF",
				GildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				gildedLastMonthDisplay: "_19NlUDUSw7ra6wC0luJwKV",
				Bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				bullet: "_2dfF2p_dwLpL5C-8pAvdbL",
				MetaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				metaDataItem: "RcL4UXH2ABHT3YpYzu3ms",
				UserNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				userNameContainer: "J9OjkO5NR8gsgJUQrk2Ft",
				KarmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				karmaGrid: "_1T5Mo-6GI-SCbGJJ9xZ2N7",
				GenericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				genericKarma: "_1Tg84WxamVCCD1zg-nbbP8",
				KarmaCount: "_18aX_pAQub_mu1suz4-i8j",
				karmaCount: "_18aX_pAQub_mu1suz4-i8j",
				GenericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				genericKarmaLabel: "EtlFWXCmzvjyd92eABb-5",
				InfoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				infoLink: "_2qjqkYRKCjuqB4VRr2duCK",
				BannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				bannerImage: "_1l9DXI5VaWcxjbz23v5b6X",
				UserContainer: "_m7PpFuKATP9fZF4xKf9R",
				userContainer: "_m7PpFuKATP9fZF4xKf9R",
				BottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				bottomSpacer: "_2D-HmwsbsNkTnIiPO4zcqb",
				UserActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				userActionLink: "_1Sy8bDpK6p4JRHy1yB1Xyk",
				Container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				container: "_1sbZnfdaxhCOFVUCJ3Z75m",
				adminIcon: "_2aJuBKF3mo4YJS4YFkeU9a"
			}
		},
		"./src/reddit/components/Hovercards/SubredditHovercard/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("SubredditHovercard").then(n.bind(null, "./src/reddit/components/Hovercards/SubredditHovercard/_SubredditHovercard.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/HumanDate/HumanDate.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/humanizeDate/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var s;
				const a = Object(i.a)(),
					d = {
						...n,
						locale: null !== (s = n.locale) && void 0 !== s ? s : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(o.a)(t, d))
			}
		},
		"./src/reddit/components/HumanDate/HumanDateTime.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				i = n("./src/lib/constants/index.ts");
			var a = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					locale: n
				} = e;
				const s = Object(a.a)(),
					d = null != n ? n : s;
				return r.a.createElement(r.a.Fragment, null, function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o.DEFAULT_LOCALE;
					const n = e * i.Xb;
					return new Date(n).toLocaleString(t, {
						weekday: "short",
						month: "short",
						year: "numeric",
						day: "2-digit",
						hour: "2-digit",
						minute: "2-digit",
						second: "2-digit",
						timeZoneName: "long"
					})
				}(t, d))
			}
		},
		"./src/reddit/components/HumanDate/TimeAgo.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/timeAgo/index.ts"),
				i = n("./src/reddit/hooks/useLocale.ts");
			t.a = function(e) {
				let {
					seconds: t,
					...n
				} = e;
				var s;
				const a = Object(i.a)(),
					d = {
						...n,
						locale: null !== (s = n.locale) && void 0 !== s ? s : a
					};
				return r.a.createElement(r.a.Fragment, null, Object(o.d)(t, d))
			}
		},
		"./src/reddit/components/HumanDate/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s.a
			})), n.d(t, "a", (function() {
				return r.a
			})), n.d(t, "b", (function() {
				return o.a
			})), n.d(t, "c", (function() {
				return f
			}));
			var s = n("./src/reddit/components/HumanDate/TimeAgo.tsx"),
				r = n("./src/reddit/components/HumanDate/HumanDate.tsx"),
				o = n("./src/reddit/components/HumanDate/HumanDateTime.tsx"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				d = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				c = n("./node_modules/fbt/lib/FbtPublic.js"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/lib/eventTools/index.ts");

			function m(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : d.DEFAULT_LOCALE;
				return e.toLocaleDateString(t, {
					month: "numeric",
					day: "numeric"
				})
			}

			function p(e, t) {
				let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
					s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : d.DEFAULT_LOCALE;
				const r = Object(u.e)(e, t),
					o = new Date(e * l.Xb);
				let i;
				if (r === u.a.Live || n) return c.fbt._("Now", null, {
					hk: "Prpcg"
				});
				return r === u.a.Future ? i = Object(u.d)(e) ? c.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : Object(u.b)(e) >= 5 ? m(o, s) : function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : d.DEFAULT_LOCALE;
					return e.toLocaleDateString(t, {
						weekday: "long"
					})
				}(o, s) : r === u.a.Past && (i = Object(u.d)(e) ? c.fbt._("Today", null, {
					hk: "1sZpnp"
				}).toString() : m(o, s)), `${i} @ ${function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.DEFAULT_LOCALE;return e.toLocaleTimeString(t,{hour12:!0,hour:"numeric",minute:"2-digit"}).replace(/ /g,"").toUpperCase()}(o,s)}`
			}
			var b = n("./src/reddit/hooks/useLocale.ts");
			var f = function(e) {
				let {
					startTime: t,
					endTime: n,
					isLive: s,
					locale: r
				} = e;
				const o = Object(b.a)(),
					i = null != r ? r : o;
				return a.a.createElement(a.a.Fragment, null, p(t, n, s, i))
			};
			n("./src/lib/humanizeUTCDate/index.tsx")
		},
		"./src/reddit/components/IdentityAndIcon/index.m.less": function(e, t, n) {
			e.exports = {
				UserIconContainer: "_3eMur7R8H7sp0xvDIzN-zw",
				userIconContainer: "_3eMur7R8H7sp0xvDIzN-zw",
				UserIcon: "_2bT01xadnKvuBWLfFkZwwZ",
				userIcon: "_2bT01xadnKvuBWLfFkZwwZ",
				UserLink: "_2Dm4wqGsnmkd9xKJ1QdbtM",
				userLink: "_2Dm4wqGsnmkd9xKJ1QdbtM"
			}
		},
		"./src/reddit/components/IdentityAndIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				d = n("./src/reddit/components/UserIcon/index.tsx"),
				c = n("./src/reddit/controls/InternalLink/index.tsx"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/components/IdentityAndIcon/index.m.less"),
				m = n.n(u);
			const p = i.a.span("UserIconContainer", m.a),
				b = i.a.wrapped(d.a, "UserIcon", m.a),
				f = i.a.wrapped(c.default, "UserLink", m.a);
			t.a = e => {
				const t = e.widgetDataType === l.b.subredditMuting ? `${s.a.redditUrl}/r/${e.username}` : `${s.a.redditUrl}/user/${e.username}`,
					n = o.a.createElement(o.a.Fragment, null, o.a.createElement(p, {
						className: e.iconClassName,
						style: {
							height: e.iconSize || "32px",
							width: e.iconSize || "32px"
						}
					}, o.a.createElement(b, {
						iconUrl: e.userIcon,
						isNSFW: !1,
						userName: e.username
					})), e.username);
				return o.a.createElement(f, {
					className: e.className,
					to: t
				}, e.tooltipId && e.sendHoverCardEvent ? o.a.createElement(a.a, {
					subredditId: e.subredditId,
					user: e.username,
					sendHoverCardEvent: e.sendHoverCardEvent,
					tooltipId: e.tooltipId
				}, n) : n)
			}
		},
		"./src/reddit/components/ImageWithFallback/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const i = e => new Promise((t, n) => {
				const s = new Image;
				s.onload = () => t(s), s.onerror = n, s.src = e
			});
			t.a = e => {
				let {
					src: t,
					lowSrc: n = t,
					errorSrc: a = n,
					...d
				} = e;
				const c = Object(s.createRef)();
				return i(t).then(() => {
					c.current && (c.current.src = t)
				}).catch(() => {
					c.current && (c.current.src = a)
				}), r.a.createElement("img", o({
					ref: c,
					src: n
				}, d))
			}
		},
		"./src/reddit/components/InboxBanner/CommonBanner.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "FjkUHssa96HMV17_qcQt6",
				wrapper: "FjkUHssa96HMV17_qcQt6",
				Content: "_27ZWqn-n6gBKDTqLbt0uk1",
				content: "_27ZWqn-n6gBKDTqLbt0uk1",
				Heading: "ZtxCbLGmd-U6DH5-RsBJV",
				heading: "ZtxCbLGmd-U6DH5-RsBJV",
				Title: "_2Iz2pxeBTmtn5cilveUdwj",
				title: "_2Iz2pxeBTmtn5cilveUdwj",
				TitleIcon: "_3wZ9NKCStyQ9_XMz6jRbkL",
				titleIcon: "_3wZ9NKCStyQ9_XMz6jRbkL",
				Body: "_2GYO5AeH0SYqV0W_IYw7C_",
				body: "_2GYO5AeH0SYqV0W_IYw7C_",
				BodyText: "_1Tw_Z3ZCizARHq8mDvXtJp",
				bodyText: "_1Tw_Z3ZCizARHq8mDvXtJp",
				Thumbnail: "_3VFSVmukKEY-C06RJldU7n",
				thumbnail: "_3VFSVmukKEY-C06RJldU7n",
				ActionButtons: "_45hSSzyMPM5pmBx74E25U",
				actionButtons: "_45hSSzyMPM5pmBx74E25U",
				noMargin: "aaIwLr1Mbi15Al1BCmB8w",
				CloseButton: "_3xbx2cMOI83xtKSIZfzaeW",
				closeButton: "_3xbx2cMOI83xtKSIZfzaeW",
				SecondaryButton: "_1cOP2U6TmJgXE_lLuvdAk",
				secondaryButton: "_1cOP2U6TmJgXE_lLuvdAk",
				CloseButtonIcon: "_3uR0NalufS44rp_5yMF15w",
				closeButtonIcon: "_3uR0NalufS44rp_5yMF15w"
			}
		},
		"./src/reddit/components/InboxBanner/CommonBanner.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/opener/index.ts"),
				d = n("./src/reddit/actions/inboxBanner/index.ts"),
				c = n("./src/reddit/controls/Button/index.tsx"),
				l = n("./src/reddit/helpers/trackers/inbox.ts"),
				u = n("./src/reddit/helpers/localStorage/index.ts"),
				m = n("./src/reddit/hooks/useTracking.ts"),
				p = n("./src/reddit/icons/fonts/index.tsx"),
				b = n("./src/reddit/models/inboxBanner/index.ts");
			const f = e => e.notificationsInbox.banner,
				h = e => {
					return f(e).banners
				};
			var _ = n("./src/reddit/selectors/user.ts"),
				g = n("./src/reddit/components/InboxBanner/CommonBanner.m.less"),
				v = n.n(g);
			const x = e => {
				let {
					isFromMiniInbox: t,
					banner: n,
					userId: h
				} = e;
				var _, g, x, O, E, y, C, j, k, I, S, w, T, N, P, R, A;
				const M = Object(o.d)(),
					L = Object(m.a)(),
					[D, F, U] = function(e, t, n) {
						const [r, o] = Object(s.useState)(Object(u.r)(e, t) || 0), i = Object(s.useCallback)(() => {
							o(r + 1), Object(u.Bb)(e, t, r + 1)
						}, []), a = Object(s.useCallback)(() => {
							n > 0 && (o(n), Object(u.Bb)(e, t, n))
						}, []);
						return [r, i, a]
					}(h, n.notificationName, (null === (_ = n.persistence) || void 0 === _ ? void 0 : _.maxViews) || 0),
					[B, q] = Object(s.useState)(!1),
					[G, H] = Object(s.useState)(!1),
					W = Object(o.e)(e => ((e, t) => {
						var n;
						return !!(null === (n = f(e).dismissedBanners) || void 0 === n ? void 0 : n.find(e => e === t))
					})(e, n.notificationName));
				Object(s.useEffect)(() => {
					F(), t ? (L(Object(l.B)(n.notificationName)), L(Object(l.C)(n.notificationName))) : (L(Object(l.p)(n.notificationName)), L(Object(l.q)(n.notificationName)))
				}, []);
				const V = null === (g = null == n ? void 0 : n.persistence) || void 0 === g ? void 0 : g.maxViews;
				if (!n || V && D > V) return null;
				const z = !!(null == n ? void 0 : n.primaryCta),
					K = !!(null == n ? void 0 : n.secondaryCta),
					Q = !!(null == n ? void 0 : n.titleImage),
					Y = !!(null == n ? void 0 : n.thumbnailImageUrl),
					J = () => {
						var e;
						(null === (e = n.persistence) || void 0 === e ? void 0 : e.isDismissible) && (U(), M(Object(d.a)(n.notificationName)))
					},
					X = {
						backgroundColor: B ? null === (x = null == n ? void 0 : n.primaryCta) || void 0 === x ? void 0 : x.colors.hoverHex : null === (O = null == n ? void 0 : n.primaryCta) || void 0 === O ? void 0 : O.colors.backgroundHex,
						color: null === (E = null == n ? void 0 : n.primaryCta) || void 0 === E ? void 0 : E.text.colorText,
						borderColor: null === (y = null == n ? void 0 : n.primaryCta) || void 0 === y ? void 0 : y.colors.borderHex
					},
					Z = {
						backgroundColor: G ? null === (C = null == n ? void 0 : n.secondaryCta) || void 0 === C ? void 0 : C.colors.hoverHex : null === (j = null == n ? void 0 : n.secondaryCta) || void 0 === j ? void 0 : j.colors.backgroundHex,
						color: null === (k = null == n ? void 0 : n.secondaryCta) || void 0 === k ? void 0 : k.text.colorText,
						borderColor: null === (I = null == n ? void 0 : n.secondaryCta) || void 0 === I ? void 0 : I.colors.borderHex
					};
				return W ? null : r.a.createElement("div", {
					className: v.a.Wrapper,
					style: {
						backgroundImage: `url(${n.bodyBackgroundImage})`
					},
					onClick: e => {
						e.stopPropagation(), Object(a.e)(n.linkUrl, "_blank"), J(), L(t ? Object(l.A)(n.notificationName, l.b.BANNER) : Object(l.o)(n.notificationName, l.b.BANNER))
					}
				}, r.a.createElement("div", {
					className: v.a.Content
				}, r.a.createElement("div", {
					className: v.a.Heading
				}, Q ? r.a.createElement("img", {
					className: v.a.TitleIcon,
					src: n.titleImage
				}) : r.a.createElement("div", {
					className: v.a.Title,
					style: {
						color: null === (S = n.titleText) || void 0 === S ? void 0 : S.colorText
					}
				}, null === (w = n.titleText) || void 0 === w ? void 0 : w.text)), r.a.createElement("div", {
					className: v.a.Body
				}, r.a.createElement("div", {
					className: v.a.BodyText,
					style: {
						color: null === (T = n.bodyText) || void 0 === T ? void 0 : T.colorText
					}
				}, null === (N = n.bodyText) || void 0 === N ? void 0 : N.text), Y && r.a.createElement("img", {
					src: n.thumbnailImageUrl,
					className: v.a.Thumbnail
				})), z || K && r.a.createElement("div", {
					className: Object(i.a)(v.a.ActionButtons, {
						[v.a.noMargin]: Y
					})
				}, z && r.a.createElement(c.t, {
					text: null === (P = n.primaryCta) || void 0 === P ? void 0 : P.text.text,
					priority: c.c.Tertiary,
					size: c.d.XS,
					onClick: e => {
						var s;
						e.stopPropagation(), (null === (s = n.primaryCta) || void 0 === s ? void 0 : s.actionType) === b.a.GOTO && n.primaryCta.url && Object(a.e)(n.primaryCta.url, "_blank"), J(), L(t ? Object(l.A)(n.notificationName, l.b.CTA_1) : Object(l.o)(n.notificationName, l.b.CTA_1))
					},
					style: {
						...X
					},
					onMouseEnter: () => q(!0),
					onMouseLeave: () => q(!1)
				}), K && r.a.createElement(c.t, {
					text: null === (R = n.secondaryCta) || void 0 === R ? void 0 : R.text.text,
					priority: c.c.Plain,
					size: c.d.XS,
					className: v.a.SecondaryButton,
					onClick: e => {
						e.stopPropagation(), (null == n ? void 0 : n.secondaryCta) && (n.secondaryCta.actionType === b.a.GOTO && n.secondaryCta.url && Object(a.e)(n.secondaryCta.url, "_blank"), J(), L(t ? Object(l.A)(n.notificationName, l.b.CTA_2) : Object(l.o)(n.notificationName, l.b.CTA_2)))
					},
					style: {
						...Z
					},
					onMouseEnter: () => H(!0),
					onMouseLeave: () => H(!1)
				}))), (null === (A = n.persistence) || void 0 === A ? void 0 : A.isDismissible) && r.a.createElement(c.t, {
					Icon: Object(p.b)("close_fill"),
					className: v.a.CloseButton,
					size: c.d.XXS,
					iconClassName: v.a.CloseButtonIcon,
					priority: c.c.Plain,
					onClick: e => {
						e.stopPropagation(), J(), L(t ? Object(l.A)(n.notificationName, l.b.DISMISS) : Object(l.o)(n.notificationName, l.b.DISMISS))
					}
				}))
			};
			t.a = e => {
				let {
					isFromMiniInbox: t
				} = e;
				const n = Object(o.e)(h),
					s = Object(o.e)(_.j);
				return (null == n ? void 0 : n.length) && s ? r.a.createElement(r.a.Fragment, null, null == n ? void 0 : n.map(e => r.a.createElement(x, {
					banner: e,
					isFromMiniInbox: t,
					key: e.notificationName,
					userId: s
				}))) : null
			}
		},
		"./src/reddit/components/InboxBanner/index.m.less": function(e, t, n) {
			e.exports = {
				underlineLink: "_3vOO3WyD7yteL4Rr9E1i2y",
				banner: "_34mO86zNIysmcISYIe8gVT",
				bannerTitleContainer: "rh7yf_ejK6H75L6jZkb6C",
				bannerTitle: "V_VLkmdSrXqz92-5vad5F",
				bannerDescription: "_1vbdR0mal1nPuuTOZIemLg",
				closeButton: "-Fi_Lr4OQ6XfCIiufmgxa",
				bannerButtonsContainer: "_1a9VL63O5el1YN7RuPoDLy",
				button: "_1mejKTw8yWGmudymV6GufX",
				primaryButton: "_1mR2YFl21PdJDX9T7ykA7c",
				welcomeBanner: "_3QWgBcfZuqQ6TlxZa6uYkS",
				dnPromptBanner: "_3IIpKn1IlCXgko4sLMEie1",
				policyBanner: "GLgkxGZkPymWBWeRISXBe",
				modalHeader: "_2Ggqgl_RyXu2U-mPYZSaCk",
				modalTitle: "_2C3YUpN8pGzseZOBK0tl0I",
				modalCloseIcon: "_2BTQI8_1TIwwfdecOP_j6o",
				modalListItem: "-sXLpWAGj2HMFvzRvH_bC",
				modalListIcon: "_3UO2hA0CsOqKl1bYybPZGs",
				hotPotatoBanner: "_2oy7Xi4NUleUcHtb8YDZh7",
				bannerContainer: "V5Q75l1gWtGpBZEehJiGH",
				bannerDataContainer: "SIz6ozr7aqewYGVSLfSf6",
				bannerImage: "_2zetWw7f4W-0OWrUYJHPQ-"
			}
		},
		"./src/reddit/components/InboxTooltip/Component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return J
			})), n.d(t, "b", (function() {
				return ee
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/notifications/index.ts"),
				a = n("./src/lib/notifications/constants.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/BadgeCounter/index.tsx"),
				u = n("./node_modules/@researchgate/react-intersection-observer/lib/es/index.js"),
				m = n("./node_modules/lodash/omit.js"),
				p = n.n(m),
				b = n("./src/reddit/components/InboxBanner/CommonBanner.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/helpers/trackers/inbox.ts"),
				_ = n("./src/reddit/hooks/useTracking.ts"),
				g = n("./src/reddit/icons/fonts/index.tsx"),
				v = n("./src/reddit/components/InboxBanner/index.m.less"),
				x = n.n(v);
			var O = e => {
				let {
					className: t,
					closeButtonText: n,
					closeIcon: s,
					descriptionText: r,
					primaryButtonText: i,
					titleText: a,
					onClose: c,
					onClick: l
				} = e;
				const u = Object(_.a)();
				return o.a.createElement("div", {
					className: Object(d.a)(x.a.banner, t)
				}, o.a.createElement("div", {
					className: x.a.bannerTitleContainer
				}, a && o.a.createElement("h4", {
					className: x.a.bannerTitle
				}, a), s && o.a.createElement(f.t, {
					onClick: e => {
						c && c(e), u(Object(h.r)({
							dnPromptAction: "dismiss"
						}))
					},
					Icon: Object(g.b)("close_fill"),
					className: Object(d.a)(x.a.closeIcon, x.a.closeButton),
					size: f.d.XXS,
					priority: f.c.Plain
				})), r && o.a.createElement("p", {
					className: x.a.bannerDescription
				}, r), o.a.createElement("div", {
					className: x.a.bannerButtonsContainer
				}, i && o.a.createElement(f.t, {
					text: i,
					priority: f.c.Tertiary,
					className: Object(d.a)(x.a.button, x.a.primaryButton),
					size: f.d.XS,
					onClick: e => {
						l && l(e), u(Object(h.r)({
							dnPromptAction: "cta"
						}))
					}
				}), n && o.a.createElement(f.t, {
					text: n,
					onClick: e => {
						c && c(e), u(Object(h.r)({
							dnPromptAction: "refuse"
						}))
					},
					priority: f.c.Plain,
					size: f.d.XS,
					className: Object(d.a)(x.a.button, x.a.closeButton)
				})))
			};
			const E = e => {
				let {
					onClose: t,
					onTurnOnBrowserNotifications: n
				} = e;
				return o.a.createElement(O, {
					className: x.a.dnPromptBanner,
					titleText: s.fbt._("Don’t miss out on updates — Turn on desktop notifications.", null, {
						hk: "10oNqB"
					}),
					onClose: e => {
						e.stopPropagation(), t()
					},
					closeIcon: !0,
					primaryButtonText: s.fbt._("Turn On", null, {
						hk: "3hywR9"
					}),
					closeButtonText: s.fbt._("No Thanks", null, {
						hk: "2GQOmV"
					}),
					onClick: e => {
						n(), t()
					}
				})
			};
			var y = n("./src/reddit/components/NotificationUnit/Loader.tsx"),
				C = n("./src/reddit/components/ResizeSensor/index.tsx"),
				j = n("./src/reddit/components/InboxTooltip/index.m.less"),
				k = n.n(j);
			const I = 3;
			class S extends o.a.Component {
				constructor() {
					super(...arguments), this.ref = o.a.createRef(), this.handleResize = () => {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						e !== this.props.notificationHeight && this.props.setNotificationHeight(e, this.props.index)
					}
				}
				componentDidMount() {
					if (this.props.index + 1 <= I) {
						const e = this.ref && this.ref.current && this.ref.current.clientHeight || 0;
						this.props.setNotificationHeight(e, this.props.index)
					}
				}
				render() {
					const {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						blockAwarder: i,
						index: a,
						isInboxPostEmbedEnabled: d,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m
					} = this.props, p = a + 1 <= I;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						ref: this.ref,
						className: k.a.notificationResizeWrapper
					}, o.a.createElement(y.a, {
						activeOverflowMenuId: e,
						decreaseSubredditNotifications: t,
						disableNotificationUpdates: n,
						hideNotification: s,
						hideSubredditNotifications: r,
						isInboxPostEmbedEnabled: d,
						isInTooltip: !0,
						markNotificationAsRead: c,
						notification: l,
						setActiveOverflowMenuId: u,
						onItemClick: m,
						blockAwarder: i
					}), !!p && o.a.createElement(C.a, {
						onResize: this.handleResize
					})))
				}
			}
			var w = n("./src/reddit/components/NotificationUnit/Placeholder.tsx"),
				T = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx");

			function N() {
				return (N = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const P = {},
				R = "",
				A = 0,
				M = "200px",
				L = "250px",
				D = "270px",
				F = 100,
				U = .5,
				B = 5,
				q = 50,
				G = 55;
			class H extends o.a.Component {
				constructor() {
					super(...arguments), this.container = o.a.createRef(), this.state = {
						notificationHeights: P,
						currentNotificationCursorIndex: -1
					}, this.resetOverflowMenu = () => {
						this.props.activeOverflowMenuId.length > A && this.props.setActiveOverflowMenuId(R)
					}, this.getContainerHeight = () => {
						const {
							notificationHeights: e
						} = this.state, {
							isDNInboxPromptBannerEnabled: t,
							isInboxPrivacyPolicyBannerEnabled: n,
							isLoggedIn: s
						} = this.props, r = t || n, o = window.innerHeight - q - 2 * G - (r ? F : 0);
						let i = 0;
						for (const a in e) i += e[a];
						return 0 === i ? r ? L : s ? M : D : (r && (i += F), o < i && (i = o + (r ? F : 0)), i)
					}, this.setNotificationHeight = (e, t) => {
						this.setState(n => ({
							notificationHeights: {
								...n.notificationHeights,
								[t]: e
							}
						}))
					}, this.updateCurrentCursorIndex = () => {
						const {
							notifications: e
						} = this.props, {
							currentNotificationCursorIndex: t
						} = this.state, n = t + B, s = n > e.length ? n : e.length - 1;
						this.setState({
							currentNotificationCursorIndex: s
						})
					}, this.renderNotifications = () => {
						const e = p()(this.props, ["notifications"]),
							{
								notificationHeights: t,
								currentNotificationCursorIndex: n
							} = this.state,
							{
								isInboxInfiniteScrollEnabled: s,
								notifications: r
							} = this.props,
							i = r.length > n + B;
						return (s && r.length > 0 && i ? r.slice(0, n + 1) : r).map((n, s) => o.a.createElement(S, N({}, e, {
							index: s,
							key: s,
							notification: n,
							notificationHeight: t[s],
							setNotificationHeight: this.setNotificationHeight
						})))
					}, this.loadNotifications = e => {
						const {
							cursor: t,
							fetchNotifications: n,
							isInboxInfiniteScrollEnabled: s,
							notifications: r
						} = this.props;
						if (e.isIntersecting) {
							const e = r.length > this.state.currentNotificationCursorIndex + B;
							this.props.notifications.length > 0 && s && e ? this.updateCurrentCursorIndex() : t && n({
								after: t,
								first: B
							})
						}
					}
				}
				componentDidMount() {
					const e = this.container && this.container.current;
					e && e.addEventListener("scroll", this.resetOverflowMenu)
				}
				componentWillUnmount() {
					const e = this.container && this.container.current;
					e && e.removeEventListener("scroll", this.resetOverflowMenu), this.resetOverflowMenu()
				}
				render() {
					const {
						hasNextPage: e,
						isDNInboxPromptBannerEnabled: t,
						isInboxInfiniteScrollEnabled: n,
						isPending: s,
						notifications: r,
						setDesktopNotificationsPromptSeen: i,
						showBrowserNotificationsPermissionSettings: a
					} = this.props, d = !(!r || !r.length), c = this.getContainerHeight(), l = r.length > this.state.currentNotificationCursorIndex + B;
					return o.a.createElement("div", {
						className: k.a.notificationList,
						ref: this.container,
						style: d ? {
							height: c,
							maxHeight: c
						} : {
							minHeight: M
						}
					}, !s && o.a.createElement("div", {
						className: k.a.notificationBannerContainer
					}, t && o.a.createElement(E, {
						onTurnOnBrowserNotifications: a,
						onClose: i
					}), o.a.createElement(b.a, {
						isFromMiniInbox: !0
					})), !d && s && o.a.createElement(w.a, null), !d && !s && o.a.createElement(T.a, {
						inTooltip: !0
					}), d && this.renderNotifications(), n && d && !s && (e || l) && o.a.createElement(u.a, {
						onChange: this.loadNotifications,
						rootMargin: "0px 0px 0px 0px",
						threshold: U
					}, o.a.createElement("div", null)))
				}
			}
			var W = n("./src/reddit/constants/localStorage.ts"),
				V = n("./src/reddit/controls/InternalLink/index.tsx"),
				z = n("./src/reddit/hooks/useLocalStorage.ts");
			var K = n("./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts"),
				Q = n("./src/reddit/helpers/localStorage/index.ts");

			function Y() {
				return (Y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const J = [],
				X = c.a.div("StyledDropdown", k.a),
				Z = e => {
					let {
						isLoggedIn: t,
						onMessagesClick: n,
						onBarClick: i,
						markAllAsRead: a,
						messagesBadgeCount: c,
						sendInboxClickSettings: u
					} = e;
					const m = !!c,
						p = Object(r.useCallback)(() => {
							n(), i()
						}, [n, i]),
						b = Object(r.useCallback)(() => {
							u(), i()
						}, [u, i]);
					return o.a.createElement("nav", {
						className: k.a.topNav
					}, o.a.createElement("span", {
						className: k.a.topNavTitle
					}, s.fbt._("Notifications", null, {
						hk: "1sYFjx"
					})), t && o.a.createElement("span", {
						className: k.a.topNavLinks
					}, o.a.createElement("span", {
						className: k.a.messagesLinkContainer
					}, o.a.createElement(V.default, {
						className: Object(d.a)(k.a.messagesLink, {
							[k.a.mActive]: m
						}),
						onClick: p,
						to: m ? "/message/unread" : "/message/messages"
					}, s.fbt._("Messages", null, {
						hk: "hulKY"
					}), o.a.createElement(l.a, {
						className: k.a.badgeCount,
						isActive: m,
						unreadCount: c
					}))), o.a.createElement("button", {
						className: k.a.navLink,
						onClick: a
					}, o.a.createElement(g.a, {
						name: "mark_read",
						className: k.a.icon
					})), o.a.createElement(V.default, {
						className: k.a.navLink,
						onClick: b,
						to: "/settings/notifications"
					}, o.a.createElement(g.a, {
						name: "settings",
						className: k.a.icon
					}))))
				},
				$ = e => o.a.createElement("div", {
					className: k.a.bottomBar
				}, o.a.createElement(V.default, {
					className: k.a.bottomLink,
					onClick: () => {
						e.sendInboxClickSeeAll(), e.onBarClick()
					},
					to: "/notifications"
				}, s.fbt._("See All", null, {
					hk: "3L3tFc"
				}))),
				ee = e => {
					const t = Object(_.a)(),
						{
							clearMessageTabBadgeCount: n,
							inboxBadgeCount: s,
							isPending: d,
							messagesBadgeCount: c,
							notifications: l,
							hideTooltip: u,
							isHotPotatoEnabled: m,
							isInboxPolicyBannerEnabled: p,
							isLoggedIn: b,
							isPushNotificationsSupported: f,
							userId: g
						} = e,
						[v, x] = Object(K.a)(g),
						[O, E] = function(e) {
							const [t, n] = Object(r.useState)(() => Object(Q.u)(e));
							return [t, Object(r.useCallback)(() => {
								n(!0), Object(Q.Cb)(e)
							}, [e])]
						}(g),
						[y, C] = function(e) {
							let {
								key: t,
								userId: n
							} = e;
							const [s, r] = Object(z.a)(t, []);
							return [-1 !== s.indexOf(n), () => {
								r([...s, n])
							}]
						}({
							key: W.b.HOT_POTATO_BANNER_SEEN,
							userId: g
						}),
						j = !(!l || !l.length),
						I = Object(i.a)(),
						S = I === a.a.Closed || I === a.a.Default || I === a.a.Denied,
						w = f && S && !v;
					return o.a.createElement(X, null, o.a.createElement("div", {
						className: k.a.tooltipContainer
					}, o.a.createElement(Z, {
						markAllAsRead: () => {
							e.markAllAsRead(), t(Object(h.h)({
								isMiniInbox: !0
							}))
						},
						messagesBadgeCount: c,
						onMessagesClick: () => {
							t(Object(h.w)({
								badgeCount: s,
								tab: h.f.Messages
							})), t(Object(h.i)()), n()
						},
						sendInboxClickSettings: () => t(Object(h.n)(h.c.MiniInbox)),
						onBarClick: u,
						isLoggedIn: b
					}), o.a.createElement(H, Y({}, e, {
						isPending: d,
						onItemClick: u,
						setDesktopNotificationsPromptSeen: x,
						isDNInboxPromptBannerEnabled: w,
						isInboxPrivacyPolicyBannerEnabled: p && !O,
						setInboxPrivacyPolicyBannerSeen: E,
						isHotPotatoEnabled: m && !y,
						setHotPotatoBannerSeen: C
					})), (j || d) && o.a.createElement($, {
						sendInboxClickSeeAll: () => t(Object(h.m)()),
						onBarClick: u
					})))
				}
		},
		"./src/reddit/components/InboxTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				carot: "_389RY3FytRs4F82-BLVEiq",
				StyledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				styledDropdown: "_3fRnnkCBwqAZG6nmxhTKHr",
				tooltipContainer: "_3oNU8Gzy2V3jDPhFfeEFbD",
				topNav: "F0hrtz76LlopbY9X0wtDo",
				topNavTitle: "wdFbe8PT7DInxaiHo2Me1",
				messagesLinkContainer: "_1581SeO-Xb1j1kfhIRrIyB",
				topNavLinks: "_1R0ZV71kh7uwDXo7fn1eDk",
				messagesLink: "_27rjoZBkLhiqLLjBu-xU_p",
				"m-active": "_29xCmtH_l8UtRn8IP08VLB",
				mActive: "_29xCmtH_l8UtRn8IP08VLB",
				badgeCount: "_1mrhJHegVozrNeTH7r5svN",
				navLink: "_2l1d6HSQ764u0JcvRSEJXD",
				notificationList: "_2MId4QR3fPm4RPlrSTZg_E",
				notificationResizeWrapper: "_3PWmWL3sMw23-xBHydcnPf",
				emptyState: "_17HPdVVhdV3LWBjzHwGlhA",
				emptyTitle: "_2CY3n2AMoj0af7gQhj9dfI",
				emptyDescription: "HxBuWRTAFa8y8bMiQKdSJ",
				bottomBar: "_8INvnNiEMHRndJ0M-LiY",
				bottomLink: "X1WC7m4hrFQNzINreBRsv",
				icon: "_3pDOQfbIbQuT4PBwPGp85E",
				BellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				bellOutline: "SBkEJxL8i3eNB9EZn7AAz",
				notificationBannerContainer: "_2prSjBmU3TS_Liup8DFR-2",
				welcomeTooltipContainer: "_1OZgaZvEs6sdhMUCqaUCW_",
				closeButton: "_3fWRL_DhsIqXjpW4eXDwmR",
				CloseIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				closeIcon: "_2xK-Knp1-SUm_DxX4Ak1T0",
				tooltipTitle: "_3EmopbfaUR0bemuuUcEcko",
				tooltipDescription: "_3MtkPXIDbG9Hf6YeNOxAxv"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.m.less": function(e, t, n) {
			e.exports = {
				IconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				iconWrapper: "_2p07tPrx9WpxDTQJ5cmVNe",
				TextWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				textWrapper: "_2jpm-rNr0Hniw6BX3NWMVe",
				leftSideRectangle: "_3TLlMYjrPH9Kl9522LpSxb",
				wrapper: "_1DUKbp8va6vxOv9zemBDBi",
				subtitle: "_2J85dtk0HKQBLk8HTSWduv",
				title: "Nt8TnDvJ2BsL8KWcFQKy5"
			}
		},
		"./src/reddit/components/InfoBanners/BannerBase/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoBanners/BannerBase/index.m.less"),
				a = n.n(i),
				d = n("./src/lib/lessComponent.tsx");
			const c = d.a.div("IconWrapper", a.a),
				l = d.a.div("TextWrapper", a.a);

			function u(e) {
				const {
					className: t,
					color: n,
					icon: s,
					subtitle: i,
					title: d,
					textWrapperClassName: u
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(t, a.a.wrapper),
					style: n && {
						borderColor: n
					} || {}
				}, r.a.createElement("div", {
					className: a.a.leftSideRectangle,
					style: n && {
						backgroundColor: n
					} || {}
				}), s ? r.a.createElement(c, null, s) : r.a.createElement(c, null), r.a.createElement(l, {
					className: u
				}, r.a.createElement("div", {
					className: a.a.title
				}, d), i && r.a.createElement("div", {
					className: a.a.subtitle
				}, i)))
			}
		},
		"./src/reddit/components/InfoTextTooltip/Hooked.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/InfoTextTooltip/hooked.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = r.a.memo((function(e) {
				let {
					visible: t,
					...n
				} = e;
				const [i, c] = Object(s.useState)(t);
				return Object(s.useEffect)(() => {
					let e = window.setTimeout(() => {
						e = void 0, c(t)
					}, 0);
					return () => {
						e && window.clearTimeout(e), c(!1)
					}
				}, [t]), t ? r.a.createElement("div", d({
					className: Object(o.a)(a.a.tooltip, n.className, {
						[a.a.visible]: i
					})
				}, n.popperProps), n.children, i && r.a.createElement("div", d({
					className: a.a.arrow
				}, n.arrowProps))) : null
			}))
		},
		"./src/reddit/components/InfoTextTooltip/hooked.m.less": function(e, t, n) {
			e.exports = {
				arrow: "_1jsc29CjRXZWjd2tr0Ji0Y",
				tooltip: "_2J_zB4R1FH2EjGMkQjedwc",
				visible: "u6HtAZu8_LKL721-EnKuR"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				BottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				bottomText: "_3uK2I0hi3JFTKnMUFHD2Pd",
				Text: "HQ2VJViRjokXpRbJzPvvc",
				text: "HQ2VJViRjokXpRbJzPvvc",
				"fade-in": "_1tIZttmhLdrIGrB-6VvZcT",
				fadeIn: "_1tIZttmhLdrIGrB-6VvZcT"
			}
		},
		"./src/reddit/components/InfoTextTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/addOverlayEvents.tsx"),
				d = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				c = n("./src/reddit/selectors/tooltip.ts"),
				l = n("./src/reddit/components/InfoTextTooltip/index.m.less"),
				u = n.n(l),
				m = n("./src/lib/lessComponent.tsx");

			function p() {
				return (p = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const b = m.a.div("Text", u.a),
				f = m.a.div("BottomText", u.a),
				h = e => r.a.createElement(b, {
					className: e.className,
					style: e.style
				}, e.text, e.children),
				_ = e => {
					const t = e.overflow ? e.overflow.left : 0;
					return r.a.createElement(f, {
						className: e.className,
						style: {
							...e.style,
							"--infoTextTooltip-overflow-left": `${t}px`
						}
					}, e.text, e.children)
				},
				g = Object(i.c)({
					isOpen: (e, t) => {
						let {
							tooltipId: n
						} = t;
						return Object(c.b)(n)(e)
					}
				}),
				v = Object(d.a)(_, [a.a.Click, a.a.Keydown]),
				x = Object(d.a)(h, [a.a.Click, a.a.Keydown]),
				O = Object(o.b)(g);
			t.c = O(e => {
				const {
					caretOnTop: t
				} = e;
				return t ? r.a.createElement(v, p({}, e, {
					targetPosition: ["center", "bottom"],
					tooltipPosition: ["center", "top"]
				})) : r.a.createElement(x, p({}, e, {
					targetPosition: ["center", "top"],
					tooltipPosition: ["center", "bottom"]
				}))
			})
		},
		"./src/reddit/components/InlineSubredditEditing/index.m.less": function(e, t, n) {
			e.exports = {
				tooltipContent: "RrvkJ7ntzKYyaCOxMJ1RM",
				title: "BE2vGjFTJ80XkdBpRRr0p",
				tooltipBody: "_2yezzi8dgIemh3F2q_kvcp",
				topRow: "_1JfvdiRxYTSKf1IIe7DUvM",
				gotIt: "_1MHKCZd72tAgyoZWvIYM-G"
			}
		},
		"./src/reddit/components/LinkOrOverlayLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				a = n("./src/reddit/helpers/overlay/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e) {
				const {
					children: t,
					className: n,
					to: s,
					...o
				} = e, c = Object(a.b)(s);
				return r.a.createElement(i.a, d({
					className: n,
					to: c
				}, o), t)
			}

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				const {
					isOverlay: t,
					...n
				} = e, s = t ? c : o.a;
				return r.a.createElement(s, l({}, n, {
					children: n.children,
					className: n.className,
					onClick: n.onClick,
					to: n.to
				}))
			}
		},
		"./src/reddit/components/LiveChatActiveUserCountWrapper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/LiveChatActiveUsers/index.m.less"),
				d = n.n(a);
			const c = e => {
				let {
					userCount: t
				} = e;
				return i.a.createElement("span", {
					className: d.a.liveChatActiveUsers
				}, t > 1 ? r.fbt._("{userCount} here now", [r.fbt._param("userCount", `${t}`)], {
					hk: "4pUoKA"
				}) : r.fbt._("join now", null, {
					hk: "3JGiBG"
				}))
			};
			var l = n("./src/lib/LiveLabel/index.m.less"),
				u = n.n(l);
			const m = () => i.a.createElement("span", {
				className: u.a.LiveLabel
			}, r.fbt._("LIVE", null, {
				hk: "1N5y3d"
			}));
			var p = n("./src/lib/LiveChatActiveUsersWithLiveLabel/index.m.less"),
				b = n.n(p);
			const f = e => {
				let {
					userCount: t = 0,
					className: n
				} = e;
				return i.a.createElement("div", {
					className: Object(s.a)(b.a.liveParticipation, n)
				}, i.a.createElement(m, null), i.a.createElement(c, {
					userCount: t
				}))
			};
			var h = n("./node_modules/react-redux/es/index.js"),
				_ = n("./src/reddit/selectors/chat.ts"),
				g = n("./src/reddit/selectors/experiments/chat.ts");
			const v = e => {
				let {
					postId: t,
					className: n
				} = e;
				const s = Object(h.e)(e => Object(_.a)(e, t));
				return Object(h.e)(g.e) ? i.a.createElement(f, {
					userCount: s,
					className: n
				}) : null
			}
		},
		"./src/reddit/components/LottieAnimation/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lottie-web/build/player/lottie.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/LottieAnimation/util.ts");
			const d = i.a.memo(e => {
				const t = i.a.createRef(),
					{
						assetData: n,
						assetUrl: s,
						className: d,
						hidden: c,
						loop: l,
						useCanvasRenderer: u,
						onClick: m,
						prefersReducedAnimation: p
					} = e,
					[b, f] = Object(o.useState)(n);
				Object(o.useEffect)(() => {
					s ? Object(a.a)(s).then(f) : n && f(n)
				}, [s, n]);
				const [h, _] = Object(o.useState)(null);
				Object(o.useEffect)(() => {
					const e = t.current;
					if (!e || 0 !== e.childElementCount || h || !b) return;
					const n = r.a.loadAnimation({
						autoplay: !1,
						renderer: u ? "canvas" : "svg",
						loop: l,
						container: e,
						animationData: b
					});
					_(n)
				}, [l, t, h, b]), Object(o.useEffect)(() => {
					if (h)
						if (c) h.stop();
						else if (p) {
						const e = h.getDuration(!0);
						h.goToAndPlay(e, !0)
					} else h.goToAndPlay(0)
				}, [c, p, h]);
				const g = Object(o.useCallback)(() => {
					h && h.goToAndPlay(0)
				}, [h]);
				return i.a.createElement("div", {
					className: d,
					style: {
						display: c ? "none" : "block"
					},
					ref: t,
					onClick: m || g
				})
			});
			t.a = d
		},
		"./src/reddit/components/LottieAnimation/util.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./src/reddit/components/ImageWithFallback/index.tsx");
			const s = {};

			function r(e) {
				let t = s[e];
				return t || (t = s[e] = fetch(e, {
					mode: "cors",
					cache: "force-cache"
				}).then(t => (t.ok || function(e) {
					throw new Error(`Unable to download effect asset "${e}"`)
				}(e), t.json()))), t
			}
		},
		"./src/reddit/components/ModActionsMenu/index.m.less": function(e, t, n) {
			e.exports = {
				ModActionsMenu: "_28noJDp6DzFWESejYQdpcD",
				modActionsMenu: "_28noJDp6DzFWESejYQdpcD"
			}
		},
		"./src/reddit/components/ModActionsMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/actions/tooltip.ts"),
				d = n("./src/reddit/components/Comments/Comment/ModToolsFlatlist/RestrictedButton.tsx"),
				c = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				l = n("./src/reddit/selectors/tooltip.ts"),
				u = n("./src/reddit/components/ModActionsMenu/index.m.less"),
				m = n.n(u);
			const p = Object(i.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(l.b)(n)(e)
					}
				}),
				b = Object(o.b)(p, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(a.h)({
							tooltipId: n
						}))
					}
				}),
				f = () => null;
			t.a = b(e => r.a.createElement("div", {
				className: m.a.ModActionsMenu,
				id: e.dropdownId,
				onClick: e.dropdownIsOpen ? f : e.onClick
			}, e.inCommentFlatlist ? r.a.createElement(d.a, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children) : r.a.createElement(c.c, {
				className: e.className,
				onClick: e.toggleDropdown
			}, e.children)))
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "yumI0nyT2gr7SFtITyKpa",
				primaryButton: "yumI0nyT2gr7SFtITyKpa"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				pencilIcon: "_2no2YPg0_yUhnhUSmNU8Xu",
				noPermissions: "_2L3p28vjPxj-Ab-h1gRXii",
				helperTitle: "_3qVhi7y_9yxVxxDGEHORe9"
			}
		},
		"./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/subredditModeration/approvedTalkHosts.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/HumanDate/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/Scroller/Simple.tsx"),
				g = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				x = n("./src/reddit/icons/fonts/index.tsx"),
				O = n("./src/reddit/models/SubredditModeration/index.ts"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/lib/objectSelector/index.ts"),
				C = n("./src/reddit/components/InboxTooltip/Component.tsx");
			const j = Object(y.a)((e, t) => {
				let {
					subredditId: n
				} = t;
				return e.pages.modHub.approvedTalkHosts.models[n] || C.a
			});
			var k = n("./src/reddit/selectors/user.ts"),
				I = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				S = n("./src/higherOrderComponents/asModal/index.tsx"),
				w = n("./src/lib/lessComponent.tsx"),
				T = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				N = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				P = n("./src/reddit/controls/TextButton/index.tsx"),
				R = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				A = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				M = n("./src/reddit/components/ModHub/ApprovedTalkHosts/AddApprovedTalkHostModal.m.less"),
				L = n.n(M);
			const D = w.a.wrapped(v.l, "PrimaryButton", L.a);
			var F = Object(S.a)(e => {
					let {
						subredditId: t,
						onAddTalkHost: n,
						toggleModal: s,
						sendEventWithName: a
					} = e;
					const [d, c] = Object(o.useState)("");
					return i.a.createElement(T.e, null, i.a.createElement(T.i, null, i.a.createElement(A.a, null, i.a.createElement(T.q, null, r.fbt._("Add approved Talk host", null, {
						hk: "38DcZT"
					})), i.a.createElement(P.a, {
						onClick: s
					}, i.a.createElement(T.b, null)))), i.a.createElement(T.l, null, i.a.createElement(N.d, {
						placeholder: r.fbt._("Enter username", null, {
							hk: "4DdFFr"
						}),
						onChange: e => {
							c(e.currentTarget.value)
						},
						value: d,
						autoFocus: !0
					})), i.a.createElement(T.g, null, i.a.createElement(T.a, {
						onClick: s,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(D, {
						onClick: () => {
							n(t, d), a("add")(), s()
						},
						"data-redditstyle": !0,
						disabled: !Object(R.a)(d)
					}, r.fbt._("Approve user", null, {
						hk: "4Awx1T"
					}))))
				}),
				U = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.m.less"),
				B = n.n(U);
			const q = 24,
				G = Object(d.c)({
					approvedTalkHosts: j,
					approvedTalkHostsListPending: (e, t) => {
						let {
							subredditId: n
						} = t;
						const s = Object(O.f)(n);
						return !!e.pages.modHub.approvedTalkHosts.api.pending[s]
					},
					loadMoreToken: (e, t) => {
						let {
							subredditId: n
						} = t;
						return e.pages.modHub.approvedTalkHosts.loadMore[n]
					},
					currentUser: k.l,
					isAddApprovedTalkHostModalOpen: e => "ModerationPage--Modal--AddApprovedTalkHost" === Object(E.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveHostConfirmation" === Object(E.a)(e)
				}),
				H = Object(a.b)(G, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addApprovedTalkHost: (t, n) => e(Object(m.a)(t, n)),
						loadMore: t => e(Object(m.b)({
							subredditId: n,
							before: t
						})),
						toggleAddApprovedHostModal: () => e(Object(u.i)("ModerationPage--Modal--AddApprovedTalkHost")),
						toggleRemoveHostModal: () => e(Object(u.i)("ModerationPage--Modal--RemoveHostConfirmation")),
						removeApprovedTalkHost: (t, n) => e(Object(m.c)(t, n))
					}
				});
			class W extends i.a.Component {
				constructor(e) {
					super(e), this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.approveTalkHost = () => {
						this.props.sendEventWithName("open_add_dialog")(), this.props.toggleAddApprovedHostModal()
					}, this.handleRemoveToggled = (e, t) => {
						this.setState({
							userId: e,
							username: t
						}), this.props.toggleRemoveHostModal()
					}, this.handleRemoveConfirmed = () => {
						this.state.userId && this.props.removeApprovedTalkHost(this.props.subredditId, this.state.userId)
					}, this.renderAddApprovedHostModal = () => i.a.createElement(F, {
						ignoreDefaultFocus: !0,
						onAddTalkHost: this.props.addApprovedTalkHost,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddApprovedHostModal,
						sendEventWithName: this.props.sendEventWithName,
						withOverlay: !0
					}), this.renderUser = e => {
						var t, n, o;
						return i.a.createElement(g.b, {
							timeAgo: i.a.createElement(b.d, {
								seconds: Date.parse(e.addedAt) / 1e3
							}),
							pageName: l.mc.TalkHosts,
							primaryButton: (null === (t = this.props.currentUser) || void 0 === t ? void 0 : t.id) !== e.redditor.id ? i.a.createElement("a", {
								href: `${s.a.redditUrl}/message/compose/?to=${e.redditor.displayName}`,
								rel: "noopener noreferrer",
								target: "_blank"
							}, i.a.createElement(v.r, null, r.fbt._("Send message", null, {
								hk: "2bul7M"
							}))) : null,
							secondaryButton: (null === (n = this.props.moderatorPermissions) || void 0 === n ? void 0 : n.access) ? i.a.createElement(v.r, {
								onClick: () => this.handleRemoveToggled(e.redditor.id, e.redditor.displayName)
							}, r.fbt._("Remove", null, {
								hk: "3tYl0U"
							})) : null,
							subredditId: this.props.subredditId,
							userIcon: null === (o = e.redditor.icon) || void 0 === o ? void 0 : o.url,
							username: e.redditor.displayName
						})
					}, this.state = O.a
				}
				render() {
					var e;
					const {
						props: t,
						state: n
					} = this, o = t.approvedTalkHosts.length > 0 ? t.approvedTalkHosts[t.approvedTalkHosts.length - 1].redditor.id : void 0, a = null === (e = t.moderatorPermissions) || void 0 === e ? void 0 : e.access;
					return i.a.createElement(i.a.Fragment, null, i.a.createElement(h.c, null, i.a.createElement(v.l, {
						disabled: !a,
						onClick: this.approveTalkHost
					}, r.fbt._("Add Talk Host", null, {
						hk: "w94Fa"
					}))), i.a.createElement(h.a, {
						className: Object(c.a)(!a && B.a.noPermissions)
					}, i.a.createElement(h.b, null, r.fbt._("Talk hosts", null, {
						hk: "3ypfgA"
					}), i.a.createElement(I.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/4411156549389`
					})), i.a.createElement("p", {
						className: B.a.helperTitle
					}, r.fbt._("Talk hosts are members who are approved to create Reddit Talk posts.", null, {
						hk: "2mnjQi"
					})), t.approvedTalkHostsListPending && i.a.createElement(g.a, null), t.approvedTalkHosts.length > 0 ? i.a.createElement(_.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, t.approvedTalkHosts.map(e => ({
						estHeight: q,
						id: e.redditor.id,
						render: () => this.renderUser(e)
					}))) : i.a.createElement(f.c, {
						text: r.fbt._("No approved Talk hosts in {subredditName}", [r.fbt._param("subredditName", t.subredditName)], {
							hk: "3lDejn"
						})
					}, i.a.createElement(x.a, {
						name: "edit",
						className: B.a.PencilIcon
					}))), t.isAddApprovedTalkHostModalOpen && this.renderAddApprovedHostModal(), t.isConfirmModalOpen && n.userId && n.username && i.a.createElement(p.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to remove {username} as an approved Talk host?", [r.fbt._param("username", n.username)], {
							hk: "1p0fqz"
						}),
						onConfirm: this.handleRemoveConfirmed,
						toggleModal: t.toggleRemoveHostModal,
						trackClick: t.sendEventWithName("remove"),
						withOverlay: !0
					}))
				}
			}
			t.a = H(W)
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_12gWQ2C_gotA8s5-CJIlq9",
				icon: "_3-Fcrds7R5ihAWPAttv3AL",
				title: "_1vL1j4mpTYI5NOR335bInG",
				subtitle: "_3FOOtAw2Q-T7szrSBAbo9i"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less": function(e, t, n) {
			e.exports = {
				tabBar: "_1ItRVjBpP4aLG0vg-nXbwO",
				tab: "_3A18ggmDWAI5_Fz0nDOs-z",
				selected: "_3U85C8qDDoOUoOINg-E_3S"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_2O3bUryrh35-WVnz9Zoet5",
				content: "_1FTRfhuddBV5YzYiIzObiO",
				grid: "_3i8uEN2ZVREoZOqW0PBJKD",
				header: "_3TFv4L83k0sAQxxxDJCzh9",
				actionHeader: "_3XGx1tfvY30VXMwrnAYMfZ",
				cell: "_30GfT3S_RWhS9B1JiSCaIJ",
				imageCell: "_1mzA539xYQn08RGzbn-Rgl",
				image: "_2UKv8w6-nnOZn6-lOqv57x",
				imagePlaceholder: "_2-8LfoYIQ37smNisBTPrPA",
				title: "_2cEKePFj4PUyuqlM_8uInw",
				caption: "_33iTirQvYAUBeq5vAp6Nr6",
				timeCell: "_1EzbYLhrmLPhhpk2FFAmcj",
				actionCell: "_1JvlfJR1EFT7pnSONpgiXk",
				dropdownSelector: "_2K7txHCmQX-J_7K7zNiCM1",
				byModerator: "_3czV_FVsdvYbnimTT57vCK",
				line: "_22JqeR_rL-tI8mxRb7N8Mq",
				loadingTextLong: "_2AZFpVa_LwltM1gTwCGIDe",
				loadingTextShort: "_1LWRk2sNojXWsOI1Y85nf7"
			}
		},
		"./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return G
			})), n.d(t, "b", (function() {
				return H
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/actions/governance/errorToast.ts"),
				d = n("./src/reddit/actions/toaster.ts"),
				c = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				l = n("./src/reddit/contexts/ApiContext.tsx"),
				u = n("./src/reddit/endpoints/economics/uploadedAssets.ts"),
				m = n("./src/reddit/models/Toast/index.ts"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/icons/svgs/SnooHappy/index.tsx"),
				f = n("./src/reddit/components/ModHub/BadgesAndEmotes/EmptyState/index.m.less"),
				h = n.n(f);
			const _ = {
				[u.a.Uploaded]: {
					title: () => s.fbt._("No more to review!", null, {
						hk: "2rF58X"
					}),
					subtitle: () => s.fbt._("There are no new submissions", null, {
						hk: "3h54Ot"
					})
				},
				[u.a.Approved]: {
					title: () => s.fbt._("Nothing approved yet", null, {
						hk: "157fUO"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you approve them", null, {
						hk: "pLc2c"
					})
				},
				[u.a.Rejected]: {
					title: () => s.fbt._("Nothing rejected yet", null, {
						hk: "1XN9kw"
					}),
					subtitle: () => s.fbt._("Submissions will be here once you reject them", null, {
						hk: "2IYFHB"
					})
				}
			};

			function g(e) {
				const t = _[e.selectedStatus];
				return o.a.createElement("div", {
					className: h.a.container
				}, o.a.createElement(b.a, {
					className: h.a.icon
				}), o.a.createElement("h3", {
					className: h.a.title
				}, t.title()), o.a.createElement("p", {
					className: h.a.subtitle
				}, t.subtitle()))
			}
			var v = n("./src/reddit/components/AuthorLink/index.tsx"),
				x = n("./src/reddit/controls/DropdownSelector/index.tsx"),
				O = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.m.less"),
				E = n.n(O);
			const y = p.a.div("cell", E.a),
				C = () => [{
					displayText: s.fbt._("New", null, {
						hk: "2xTBYx"
					}),
					value: u.a.Uploaded
				}, {
					displayText: s.fbt._("Approved", null, {
						hk: "1xx5DL"
					}),
					value: u.a.Approved
				}, {
					displayText: s.fbt._("Rejected", null, {
						hk: "25TTJE"
					}),
					value: u.a.Rejected
				}],
				j = () => C().slice(1, 3),
				k = new Intl.DateTimeFormat(void 0, {
					month: "numeric",
					day: "numeric",
					year: "numeric",
					hour: "numeric",
					minute: "numeric",
					second: "numeric"
				}).format;

			function I(e) {
				const {
					item: t,
					onItemAction: n
				} = e, r = C().find(e => e.value === t.status);
				let i = t.type === u.b.Badge ? t.extra.description : void 0;
				return i && i.endsWith(" u/" + t.uploader) && (i = i.slice(0, i.length - t.uploader.length - 3)), o.a.createElement(o.a.Fragment, null, o.a.createElement(y, {
					className: E.a.imageCell
				}, o.a.createElement("div", {
					className: E.a.image,
					style: {
						backgroundImage: `url(${t.url})`
					}
				})), o.a.createElement(y, {
					className: E.a.nameCell
				}, o.a.createElement("div", {
					className: E.a.title
				}, t.type === u.b.Emote ? `:${t.name}:` : t.name), o.a.createElement("div", {
					className: E.a.caption
				}, i, " ", o.a.createElement(v.a, {
					author: t.uploader,
					style: {
						color: t.type === u.b.Badge ? t.extra.color : void 0
					}
				}, "u/", t.uploader))), o.a.createElement(y, {
					className: E.a.timeCell
				}, k(t.createdAt)), o.a.createElement(y, {
					className: E.a.actionCell
				}, o.a.createElement(x.a, {
					className: E.a.dropdownSelector,
					displayText: r ? r.displayText : "",
					options: j(),
					onSelect: e => n(t, e.value),
					isCompactStyle: !0
				}), t.status !== u.a.Uploaded && !!t.moderator && !!t.modifiedAt && o.a.createElement("div", {
					className: E.a.byModerator
				}, s.fbt._("by u/ {moderator}, {time-modified}", [s.fbt._param("moderator", t.moderator), s.fbt._param("time-modified", k(t.modifiedAt))], {
					hk: "25I5ES"
				}))), o.a.createElement("div", {
					className: E.a.line
				}))
			}
			var S = n("./src/lib/classNames/index.ts");
			const w = p.a.div("cell", E.a),
				T = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(w, {
					className: E.a.imageCell
				}, o.a.createElement("div", {
					className: Object(S.a)(E.a.image, E.a.imagePlaceholder)
				})), o.a.createElement(w, {
					className: E.a.nameCell
				}, o.a.createElement("div", {
					className: E.a.loadingTextLong
				})), o.a.createElement(w, null, o.a.createElement("div", {
					className: E.a.loadingTextShort
				})), o.a.createElement(w, {
					className: E.a.actionCell
				}, o.a.createElement("div", {
					className: E.a.loadingTextShort
				})), o.a.createElement("div", {
					className: E.a.line
				}));
			var N = () => o.a.createElement(o.a.Fragment, null, o.a.createElement(T, null), o.a.createElement(T, null), o.a.createElement(T, null), o.a.createElement(T, null));
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), R = p.a.div("header", E.a);

			function A(e) {
				const {
					onAssetAction: t,
					assets: n,
					selectedStatus: s
				} = e;
				return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
					className: E.a.grid
				}, o.a.createElement(R, null, P._("Image", null, {
					hk: "3ImlXy"
				})), o.a.createElement(R, null, P._("Name and Description", null, {
					hk: "ZMWPH"
				})), o.a.createElement(R, null, P._("Submission Time", null, {
					hk: "3qPqQa"
				})), o.a.createElement(R, {
					className: E.a.actionHeader
				}, P._("Action", null, {
					hk: "27SYzP"
				})), !n && o.a.createElement(N, null), n && !!n.length && n.map(e => o.a.createElement(I, {
					item: e,
					key: e.name,
					onItemAction: t
				}))), n && !n.length && o.a.createElement(g, {
					selectedStatus: s
				}))
			}
			var M = n("./src/reddit/components/ModHub/BadgesAndEmotes/TabBar/index.m.less"),
				L = n.n(M);
			const D = e => o.a.createElement("button", {
					className: Object(S.a)(L.a.tab, {
						[L.a.selected]: e.selected
					}),
					onClick: e.onClick
				}, e.children),
				F = e => o.a.createElement("div", {
					className: L.a.tabBar
				}, [u.a.Uploaded, u.a.Approved, u.a.Rejected].map(t => o.a.createElement(D, {
					onClick: () => e.onTabSelected(t),
					selected: t === e.value,
					value: t,
					key: t
				}, (e => {
					switch (e) {
						case u.a.Uploaded:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							});
						case u.a.Approved:
							return s.fbt._("Approved", null, {
								hk: "37lIL9"
							});
						case u.a.Rejected:
							return s.fbt._("Rejected", null, {
								hk: "W16pI"
							});
						default:
							return s.fbt._("Uploaded", null, {
								hk: "1AgqhR"
							})
					}
				})(t))));

			function U() {
				return (U = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class B extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						selectedStatus: u.a.Uploaded
					}, this.onTabChange = async e => {
						this.setState({
							assets: void 0,
							selectedStatus: e
						});
						const t = await Object(u.c)(this.props.apiContext(), this.props.subredditId, this.props.assetType, e);
						t.ok ? this.setState({
							assets: t.body.assets || []
						}) : this.props.onGovernanceError(t.error)
					}, this.onAssetAction = async (e, t) => {
						if (e.status === t) return;
						const n = this.props.assetType,
							s = await Object(u.d)(this.props.apiContext(), this.props.subredditId, n, e.id, {
								status: t
							});
						if (s.ok) {
							const s = this.state.assets;
							this.setState({
								assets: s && s.filter(t => t !== e)
							}), t === u.a.Approved ? this.props.onApproved(n) : t === u.a.Rejected && this.props.onRejected(n)
						} else this.props.onGovernanceError(s.error)
					}
				}
				componentDidMount() {
					this.onTabChange(this.state.selectedStatus)
				}
				render() {
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(c.a, {
						className: E.a.contentContainer
					}, o.a.createElement(c.b, null, this.props.assetType === u.b.Badge ? s.fbt._("User uploaded badges", null, {
						hk: "3qGdzT"
					}) : s.fbt._("User uploaded emotes", null, {
						hk: "1GJiVz"
					})), o.a.createElement("div", {
						className: E.a.content
					}, o.a.createElement(F, {
						onTabSelected: this.onTabChange,
						value: this.state.selectedStatus
					}), o.a.createElement(A, {
						selectedStatus: this.state.selectedStatus,
						assets: this.state.assets,
						onAssetAction: this.onAssetAction
					}))))
				}
			}
			const q = Object(l.b)(Object(i.b)(void 0, (e, t) => ({
					onGovernanceError: t => Object(a.a)(e, t),
					onApproved: t => e(Object(d.f)({
						kind: m.b.SuccessCommunity,
						text: t === u.b.Badge ? s.fbt._("Approved badge!", null, {
							hk: "3B3r07"
						}) : s.fbt._("Approved emote!", null, {
							hk: "tWzSE"
						})
					})),
					onRejected: t => e(Object(d.f)({
						kind: m.b.SuccessCommunity,
						text: t === u.b.Badge ? s.fbt._("Rejected badge", null, {
							hk: "1X6cSg"
						}) : s.fbt._("Rejected emote", null, {
							hk: "3RS2kT"
						})
					}))
				}))(B)),
				G = e => o.a.createElement(q, U({
					assetType: u.b.Badge
				}, e)),
				H = e => o.a.createElement(q, U({
					assetType: u.b.Emote
				}, e))
		},
		"./src/reddit/components/ModHub/Content/NoPermissions.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/contexts/NavbarExp.ts"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/components/ModHub/Content/index.m.less"),
				l = n.n(c);
			t.a = e => {
				const t = Object(o.useContext)(a.a);
				return i.a.createElement("div", {
					className: Object(d.a)(l.a.noPermissions, {
						[l.a.noPermissionsExp]: t
					})
				}, i.a.createElement("img", {
					className: l.a.rememberTheHuman,
					src: `${s.a.assetPath}/img/content-gate-icons/remember-the-human.png`
				}), e.isModerator ? r.fbt._("Sorry, you do not have the moderator permissions needed to view this page", null, {
					hk: "4wUDIF"
				}) : r.fbt._("Sorry, this is a moderator-only page", null, {
					hk: "2BZEIA"
				}), i.a.createElement("div", {
					className: l.a.noPermissionsSmallText
				}, e.isModerator ? r.fbt._("You need to change your mod permissions to view this page", null, {
					hk: "RS9sd"
				}) : e.subredditDisplayText ? r.fbt._("You must be a moderator of {subredditName} to view this page", [r.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "8eU68"
				}) : r.fbt._("You must be a moderator to view this page", null, {
					hk: "2N7TXH"
				})))
			}
		},
		"./src/reddit/components/ModHub/Content/WelcomeMessage.m.less": function(e, t, n) {
			e.exports = {
				ModerateIcon: "khXWcHNm7cUFKCGgNfNPy",
				moderateIcon: "khXWcHNm7cUFKCGgNfNPy",
				ModHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ",
				modHubWelcomeMessage: "_1WUhYUiKwTt20VZZiLFRXQ"
			}
		},
		"./src/reddit/components/ModHub/Content/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "CgYEK3BSwEitV3N5dS53Y",
				titleFontH2: "WtxSi4x3A6EHSYOlNO6dC",
				titleFontH3: "_1s8gRCw9ZEGeZdDLi4SjEs",
				titleFontH4: "iJgEN-DVO9xH1ING9PGia",
				titleFontH5: "_1Pk2HmstIcHsVCyXL0s7WR",
				titleFontH6: "_27G51xRMOXRk6p8hF2iFF4",
				metadataFont: "_3qFnOmsyfNVU4dOg-nT7AH",
				flairFont: "IHVtmv3d9vjFTy7sOv4nb",
				labelsFont: "_3veeqeCCuB-y_5Uz7aZwNo",
				actionFont: "_2GGs_1qJNsgRTBkJjB3JyV",
				smallButtonFont: "_1wMkSw4TKFwpURuJjoijc8",
				largeButtonFont: "_37n4mei_IKI2b0S9cUN6kj",
				strongTextFont: "_3iiIycx9Jvd-wtbZRRlyrS",
				tabFont: "_2uzD_ZiaRuda1gPntdeFV-",
				buttonFontXS: "X1zM6CuE0STTL567u2KEr",
				buttonFontXs: "X1zM6CuE0STTL567u2KEr",
				buttonFontS: "_35xxostuR-t_KnCQpTxb0F",
				buttonFontM: "_1siVd6fOXNWDs8SbSH_HQ5",
				buttonFontL: "_1mAbhFs88EE9k-jaJMzlbM",
				buttonFontXL: "FxQ8KBPxEROiwB1EG0sLr",
				buttonFontXl: "FxQ8KBPxEROiwB1EG0sLr",
				bodyFontH1: "_18F7ywSczMXfDxvUzIkKou",
				bodyFontH2: "_2gpSS7qXgM9-crN9KgQr_O",
				bodyFontH3: "-JM-6-h-SOMTCi9a5ZG0g",
				bodyFontH4: "_3ZVYgWzZxJjL_cahDG32l",
				bodyFontH5: "_15iJEJUM-il2Ud09a9yqhY",
				bodyFontH6: "_2kFIrTxjdWaprwQ9leev5x",
				bodyFontH6Small: "mhRrYXj7dAprAm-wE7DdO",
				bodyFont: "_38q9ZzND20FKMoX8BeB0u8",
				bodyFontSmall: "_1tFfFAHeLftmld2a2M4yIs",
				bodyFontMono: "_1N1SJCd40K_9LeW3MSWULf",
				landingPageTitleFontH1: "_188OUQdkNVSC4VoI3use3H",
				landingPageTitleFontH2: "_1Nsrmd1KvVz-41wIUPMJMp",
				landingPageTitleFontH3: "_2pcqzLgqwagTSQPKkGNO-q",
				rememberTheHuman: "_2S6IM2TPtTriI4r_2Op1Od",
				noPermissions: "_3jaCG74Q3u55JqGJy3u664",
				noPermissionsExp: "_30KCF1VJPMgbkHOfEhoE2p",
				noPermissionsSmallText: "_1Kxv5kLQoEOhRatEhltXrQ",
				container: "_3gsyCuYXsGWEEgPSTuX9aw",
				isLargePostLayout: "_1WGjuBpIEjcQC-x3_lE_Nu",
				titleContainer: "_2SyYApGPPZkM6bG9SnSk1k",
				modActivity: "zsQHq8K9sST2NCbphllOm"
			}
		},
		"./src/reddit/components/ModHub/Content/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				d = n("./src/lib/assertNever.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/components/ApprovedSubmitterList/index.tsx"),
				u = n("./src/reddit/components/BannedUserList/index.tsx"),
				m = n("./src/reddit/components/CCM/ModerationLog/index.tsx"),
				p = n("./src/reddit/components/CommunityAwardList/index.tsx"),
				b = n("./src/reddit/components/CommunitySettings/index.tsx"),
				f = n("./src/reddit/components/GrantUserFlair/index.tsx"),
				h = n("./src/reddit/components/ModerationLog/index.tsx"),
				_ = n("./src/reddit/components/ModeratorsList/index.tsx"),
				g = n("./src/reddit/components/ModHub/ApprovedTalkHosts/index.tsx"),
				v = n("./src/reddit/components/ModHub/BadgesAndEmotes/index.tsx"),
				x = n("./src/reddit/components/ModHub/Emojis/index.tsx"),
				O = n("./src/reddit/components/MutedUserList/index.tsx"),
				E = n("./src/reddit/components/PowerupsSettings/index.tsx"),
				y = n("./src/reddit/components/RemovalReasons/index.tsx"),
				C = n("./src/reddit/components/Streaming/ModSettings/index.tsx"),
				j = n("./src/reddit/components/SubredditContent/PredictionsContent/async.ts"),
				k = n("./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx"),
				I = n("./src/reddit/components/SubredditRules/index.tsx"),
				S = n("./src/reddit/pages/ErrorPages/index.tsx"),
				w = n("./src/reddit/selectors/experiments/eventPosts.ts");
			const T = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-ContentControls",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-ContentControls").then(n.bind(null, "./src/reddit/components/ModHub/ContentControls/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/ContentControls/index.tsx"
					}
				}),
				N = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-TrafficStats",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-ModHub-TrafficStats").then(n.bind(null, "./src/reddit/components/ModHub/TrafficStats/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/TrafficStats/index.tsx"
					}
				}),
				P = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-PostFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-PostFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/PostFlairManagement/index.tsx"
					}
				}),
				R = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-flairs-UserFlairManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("reddit-components-ModHub-flairs-PostFlairManagement~reddit-components-ModHub-flairs-UserFlairManagement"), n.e("reddit-components-ModHub-flairs-UserFlairManagement")]).then(n.bind(null, "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/flairs/UserFlairManagement/index.tsx"
					}
				}),
				A = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-Wiki-ModHubWikiManagement",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("SubredditWiki~reddit-components-Wiki-ModHubWikiManagement"), n.e("reddit-components-Wiki-ModHubWikiManagement")]).then(n.bind(null, "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/Wiki/ModHubWikiManagement/index.tsx"
					}
				}),
				M = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-ModHub-Content-ModQueue",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("ModQueuePages~reddit-components-ModHub-Content-ModQueue"), n.e("reddit-components-ModHub-Content-ModQueue")]).then(n.bind(null, "./src/reddit/components/ModHub/Content/ModQueue.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ModHub/Content/ModQueue.tsx"
					}
				}),
				L = Object(s.a)({
					resolved: {},
					chunkName: () => "reddit-components-SubredditContent-EventPostContent",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("reddit-components-SubredditContent-EventPostContent").then(n.bind(null, "./src/reddit/components/SubredditContent/EventPostContent/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditContent/EventPostContent/index.tsx"
					}
				}),
				D = e => {
					const {
						isRealtimeMQUpdatesExperimentEnabled: t,
						layout: n,
						pageName: s,
						postTypeFilter: r,
						postSort: D,
						subpageName: F,
						...U
					} = e, B = Object(i.e)(e => Object(a.d)(e)), q = Object(i.e)(w.a), G = {
						...U,
						subredditId: e.subreddit.id
					};
					switch (s) {
						case c.mc.Removal:
							return o.a.createElement(y.a, {
								subredditId: e.subreddit.id,
								sendEventWithName: e.sendEventWithName
							});
						case c.mc.Contributors:
							return o.a.createElement(l.a, G);
						case c.mc.Banned:
							return o.a.createElement(u.a, G);
						case c.mc.Streaming:
							return o.a.createElement(C.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id
							});
						case c.mc.Muted:
							return o.a.createElement(O.a, G);
						case c.mc.Moderators:
							return o.a.createElement(_.a, G);
						case c.mc.Modlog:
							return B ? o.a.createElement(m.a, G) : o.a.createElement(h.a, G);
						case c.mc.ContentControls:
							return o.a.createElement(T, {
								subredditName: e.subreddit.name
							});
						case c.mc.Flair:
							return o.a.createElement(f.a, {
								after: e.after,
								before: e.before,
								subredditId: e.subreddit.id
							});
						case c.mc.PostFlair:
							return o.a.createElement(P, {
								subredditId: e.subreddit.id
							});
						case c.mc.UserFlair:
							return o.a.createElement(R, {
								subredditId: e.subreddit.id
							});
						case c.mc.Badges:
							return o.a.createElement(v.a, {
								subredditId: e.subreddit.id
							});
						case c.mc.Emotes:
							return o.a.createElement(v.b, {
								subredditId: e.subreddit.id
							});
						case c.mc.SubredditRules:
							return o.a.createElement(I.a, {
								subreddit: e.subreddit
							});
						case c.mc.CommunitySettings:
							return o.a.createElement(b.a, {
								subredditId: e.subreddit.id,
								subpageName: e.subpageName,
								subredditName: e.subreddit.name
							});
						case c.mc.Modqueue:
						case c.mc.Reports:
						case c.mc.Spam:
						case c.mc.Edited:
						case c.mc.Unmoderated:
							return o.a.createElement(M, {
								after: e.after,
								layout: n,
								page: e.page,
								pageName: s,
								postTypeFilter: r,
								postSort: D,
								sendEventWithName: e.sendEventWithName,
								subredditName: e.subreddit.name,
								isRealtimeMQUpdatesExperimentEnabled: t,
								subredditId: e.subreddit.id
							});
						case c.mc.Awards:
							return o.a.createElement(p.a, {
								subredditOrProfile: e.subreddit,
								subredditOrProfileId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions
							});
						case c.mc.Powerups:
							return o.a.createElement(E.a, {
								subredditId: e.subreddit.id
							});
						case c.mc.Emojis:
							return o.a.createElement(x.a, {
								subreddit: e.subreddit
							});
						case c.mc.Wiki:
						case c.mc.WikiContributors:
						case c.mc.WikiBanned:
							return o.a.createElement(A, {
								subreddit: e.subreddit
							});
						case c.mc.Traffic:
							return o.a.createElement(N, {
								subreddit: e.subreddit
							});
						case c.mc.SubredditContent:
							return null;
						case c.mc.ScheduledPostContent:
							return o.a.createElement(k.a, {
								subreddit: e.subreddit
							});
						case c.mc.EventPostContent:
							return q ? o.a.createElement(S.b, null) : o.a.createElement(L, {
								subredditName: e.subreddit.name
							});
						case c.mc.Predictions:
							return o.a.createElement(j.a, {
								subreddit: e.subreddit
							});
						case c.mc.TalkHosts:
							return o.a.createElement(g.a, {
								subredditName: e.subreddit.name,
								subredditId: e.subreddit.id,
								moderatorPermissions: e.moderatorPermissions,
								sendEventWithName: e.sendEventWithName
							});
						default:
							return Object(d.a)(s)
					}
				};
			t.a = D
		},
		"./src/reddit/components/ModHub/ContentControls/FormSections/HatefulContentFilters/useHCFAdoptionCampaign.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/featureFlags/index.ts"),
				d = n("./src/reddit/hooks/useExperimentVariant.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function l() {
				const e = Object(d.a)(i.ce),
					t = Object(o.e)(a.d.hatefulContentFiltersEnabled);
				return e === i.Kd && t
			}

			function u(e) {
				function t(t) {
					const n = l();
					return r.a.createElement(e, c({}, t, {
						showHCFNewTagsCampaign: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `HCFAdoptionNewTagCampaign(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_20ADRJAodM5zU1OpvNEeRz",
				checkboxText: "_21Bw38NODPHxkJ8zAXjoUZ",
				closeButton: "_3m2cog1fzR2zNYfyXI2GUB",
				emojiDisplay: "_1mMSj2QBZEQ97i-4y3-WOp",
				emojiNameDisplay: "_2lbIQVKPZ4LHDNpBLwSOps",
				imageDisplay: "_3BXziWyChS-zhQ5XC9lt4k",
				appearsIn: "_1DhToTbLLM2OC-Ze5nDwCq",
				imageTitle: "_2KrLezTGMfd18btz-KkYMi",
				modalBody: "_1PLlW-_ZV0vWQQ6LS1Z2lH",
				modalAddButton: "_1vUjBClk27uHOAYH__0rj9",
				modalCancelButton: "_23RRFTkR9NKrC22rmMDNfI",
				modFlairOnlyToggle: "_19ExxuLL5lOZW35TZFXIHf",
				modIcon: "_3ta-U9hY9R1H_BRwYv1zhl",
				modProTip: "_2yN7aUrL8peCADm-u303LV",
				modProTips: "_3WtRXJc1jCLpCEw7-mlEBU",
				proTip: "_8wjmRK1w6qEGzue3BNNOA",
				modProTipTitle: "_392GI--ZxhpUHn1eRTKzqA",
				tipList: "_3PPlagKiQrtoOsW4pcf3vc"
			}
		},
		"./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_34rhMfrLYNSjUkhTK958Um",
				characterCountdown: "_15Hq3tMBKH4TWo9OJs8gny",
				clearIcon: "aCmT6tHKACP3PLk6IU6XT",
				duplicatesIcon: "Eq88P0Zb-rOoo4N5OL5uk",
				duplicateWarning: "DRp2YTik6Ln3yUKp7LBUv",
				editEmojiFooter: "_2ZoRiRDs45wlLK-ZnHzUh",
				editEmojiDisplay: "_2rDJJ0Uk_ySvUA9QNoKoKU",
				emojiDisplays: "_2FsakuX5ZR_IIPcwXQu0eD",
				errorText: "_3bRRwpzb2xfP5erPt9R6Cg",
				expandLeft: "_2byjR1IbLclRfoyvyjMDUz",
				iconSpacer: "_3tWeESqi0MQaqN5wKqkv68",
				imageDisplay: "_1MHWj3sdAGALX7r7UzFF0J",
				duplicateInput: "_280zGglckljUYhFjwaBt14",
				input: "_3xzW-TBy6RXHXBjCE9Yz7s",
				inputPlaceholder: "_1964bAdk8xBAb8-d_Mthtt",
				modalAddButton: "_2yQ10LXNPJ6antT2NgaTmI",
				modalCancelButton: "_31Qk2tb7PaP2XWWL2o4HM1",
				modProTip: "NSSpRN8n70A1TesDNcvxE",
				progressBar: "_3EbPa1JwqT9b_QgXnHzJsx",
				innerBarClassName: "_3CJpdsYAp2vfEOO_U7AaO8",
				progressText: "Wz5fdVLDZuS4d-ix-j4s9",
				replacingDescription: "_1oXr6AKswirSKypchDoX1n",
				replacingTitle: "oNyr5QxUcemiI3SFwjhvc",
				uploadingTitle: "_3ZEFRZKrLVT92hTIG7sRa9",
				textButton: "_3ZzQTZKV1t84-ND6HHwnsx",
				uploaderContainer: "OCFZ6HIQUbokDXiubxQEZ"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.m.less": function(e, t, n) {
			e.exports = {
				alertIcon: "_3x5p0Ujs6EWdeLO8-fVE7v",
				emojisDisabled: "_2H7y73ZptDGSake8tFEj0n",
				labelTitle: "_2R2K1Sz81kscliWYqOq1xU",
				labelDescription: "_1TqFvv__UfmckLHp5llo7q",
				leftForm: "_22aW9zYAhDGH2HdlJ-WWIM",
				modalBody: "_1_UK8ZmVC7e_nkeSs5CGnA",
				modalCloseButton: "_2-arZqA5i-aG-76OM9aj7k",
				modalEnableSection: "_2Wd3qBH4SU1NauwzVOQbVT",
				modalFooter: "_2R2UP3vtcyZqyNdUy9Y0nX",
				modalSubmitButton: "w7T2GA8_RqtkSpD4h6YKH",
				modalCancelButton: "_2wvHObzKgyjObCvFZ0QOp0",
				rightForm: "_1eE1s4H4f1_A3ck0iF679O",
				row: "_2NQoOHp9q7uhb8h4XdVWK",
				displayWrapper: "jiCIuKa0E1BjfGfUV407r",
				emojiDisplay: "_32BxZer8uLzSVJMZqqo95_",
				emojiName: "_2hJHG1X01WKzuznOL4l6ge",
				appears: "ZVOiCMvsomJLwhS8k4VPP",
				permissions: "UxdnKubszq3iR9sJGFwiY",
				buttonWrapper: "PflXNgwgKckPGaFe9wW8V",
				editEmoji: "_3RR0-7gyjso1AHuVhVbb6u",
				editSnoomoji: "FCFv4UPC_NQjiTCEBoOCD",
				trashIcon: "_2l2KeCLkXUEz_czKdpFqSw",
				settingsButton: "_2dh14d_OrE4Etrg44_cb4t",
				toggleSwitch: "_17kocpcRdOCXJwPiOk68B-",
				topRow: "_2oevuimQpT3hztJ5Rpf_hy",
				appearsTitle: "_1Qzxm6lOFpTR3O3hzKloA9",
				imageTitle: "_1NOoO9mz09cpZjIRT9nHTh",
				nameTitle: "_1Ra9yqtrrSj9q0akrKs83v",
				permissionsTitle: "_1gNO8_Ywz6va1MbMV7-jDG",
				titleTooltip: "_279Uba_Gpg0WVLV8efIdK_"
			}
		},
		"./src/reddit/components/ModHub/Emojis/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/lodash/map.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/actions/emoji.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				f = n("./src/reddit/components/InfoBanners/BannerBase/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				_ = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				g = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				x = n("./src/reddit/components/TrackingHelper/index.tsx"),
				O = n("./src/reddit/constants/colors.ts"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/selectors/telemetry.ts");
			const C = e => ({
					subreddit: y.kb(e),
					profile: y.T(e),
					userSubreddit: y.ub(e)
				}),
				j = (e, t) => n => ({
					source: "emoji",
					action: "toggle",
					noun: e,
					actionInfo: {
						settingValue: t ? "on" : "off"
					},
					...C(n)
				}),
				k = e => t => ({
					source: "emoji",
					action: "click",
					noun: e,
					...C(t)
				}),
				I = (e, t) => n => ({
					source: "emoji",
					action: "click",
					noun: e,
					actionInfo: y.d(n, {
						count: t
					}),
					...C(n)
				});
			var S = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				w = n("./src/reddit/selectors/activeModalId.ts"),
				T = n("./src/reddit/selectors/emojis.ts"),
				N = n("./src/reddit/components/ModHub/Emojis/index.m.less"),
				P = n.n(N),
				R = n("./src/reddit/controls/ImageDisplay/index.tsx"),
				A = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				M = n("./src/reddit/layout/row/Inline/index.tsx");
			const L = u.a.span("appears", P.a),
				D = u.a.span("buttonWrapper", P.a),
				F = u.a.span("displayWrapper", P.a),
				U = u.a.wrapped(R.a, "emojiDisplay", P.a),
				B = u.a.span("emojiName", P.a),
				q = u.a.span("permissions", P.a),
				G = u.a.wrapped(M.a, "row", P.a),
				H = u.a.wrapped(A.b, "trashIcon", P.a);
			var W = e => d.a.createElement(G, null, d.a.createElement(F, null, d.a.createElement(U, {
					backgroundImage: e.emoji.url
				})), d.a.createElement(B, null, e.emoji.name), d.a.createElement(L, null, ((e, t) => e && t ? r.fbt._("Post flair, user flair", null, {
					hk: "gLvKb"
				}) : e ? r.fbt._("Post flair", null, {
					hk: "dcIoz"
				}) : t ? r.fbt._("User flair", null, {
					hk: "4fQagx"
				}) : "")(e.emoji.postFlairAllowed, e.emoji.userFlairAllowed)), d.a.createElement(q, null, e.emoji.modFlairOnly && r.fbt._("Mod only", null, {
					hk: "NMZoE"
				})), d.a.createElement(D, null, d.a.createElement(E.r, {
					className: e.isSnoomoji ? P.a.editSnoomoji : P.a.editEmoji,
					onClick: () => e.onEdit(e.emoji, e.isSnoomoji)
				}, r.fbt._("Edit", null, {
					hk: "1nftDt"
				})), !e.isSnoomoji && d.a.createElement("button", {
					onClick: () => e.onRemove(e.emoji.name)
				}, d.a.createElement(H, null)))),
				V = n("./src/higherOrderComponents/asModal/index.tsx"),
				z = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				K = n("./src/reddit/controls/TextButton/index.tsx"),
				Q = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				Y = n("./src/reddit/selectors/subreddit.ts"),
				J = n("./src/reddit/controls/ToggleSwitch/index.tsx");
			const X = u.a.span("labelDescription", P.a),
				Z = u.a.span("labelTitle", P.a),
				$ = u.a.div("leftForm", P.a),
				ee = u.a.div("rightForm", P.a),
				te = u.a.wrapped(J.a, "toggleSwitch", P.a);
			var ne = e => d.a.createElement("div", {
				className: e.className
			}, d.a.createElement($, null, d.a.createElement(Z, null, r.fbt._("{title}", [r.fbt._param("title", e.title)], {
				hk: "4bYhaP"
			})), d.a.createElement(X, null, r.fbt._("{description}", [r.fbt._param("description", e.description)], {
				hk: "1lFxbr"
			}))), d.a.createElement(ee, null, d.a.createElement(te, {
				on: e.on,
				onToggle: e.onToggle
			})));
			const se = u.a.wrapped(ne, "modalEnableSection", P.a),
				re = u.a.wrapped(z.e, "modalBody", P.a),
				oe = u.a.wrapped(z.a, "modalCancelButton", P.a),
				ie = u.a.wrapped(K.a, "modalCloseButton", P.a),
				ae = u.a.wrapped(z.g, "modalFooter", P.a),
				de = u.a.wrapped(E.l, "modalSubmitButton", P.a),
				ce = Object(l.c)({
					isEmojisEnabled: (e, t) => Object(Y.z)(e, {
						subredditName: t.subreddit.name
					}).emojisEnabled
				}),
				le = Object(c.b)(ce, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						toggleEnableEmojis: t => e(Object(m.j)(n.id, t))
					}
				});
			class ue extends d.a.Component {
				constructor(e) {
					super(e), this.handleEnableEmojisToggle = () => this.setState({
						emojisEnabled: !this.state.emojisEnabled
					}), this.enableHasBeenToggled = () => this.props.isEmojisEnabled !== this.state.emojisEnabled, this.canSave = () => this.enableHasBeenToggled(), this.onSave = () => {
						const {
							props: e,
							state: t
						} = this;
						this.enableHasBeenToggled() && (e.toggleEnableEmojis(t.emojisEnabled), e.sendEvent(j("enable", t.emojisEnabled))), e.toggleModal(), e.sendEvent(k("save_emoji_settings"))
					}, this.state = {
						emojisEnabled: e.isEmojisEnabled
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return d.a.createElement(re, null, d.a.createElement(z.i, null, d.a.createElement(Q.a, null, d.a.createElement(z.q, null, r.fbt._("Emoji settings", null, {
						hk: "1GjUM3"
					})), d.a.createElement(ie, {
						onClick: e.toggleModal
					}, d.a.createElement(z.b, null)))), d.a.createElement(z.l, null, d.a.createElement(se, {
						description: r.fbt._("Allow emojis to be used in post and user flair within your community", null, {
							hk: "3ppqgX"
						}),
						on: t.emojisEnabled,
						onToggle: this.handleEnableEmojisToggle,
						title: r.fbt._("Enable emojis in this community", null, {
							hk: "3uLrQi"
						})
					})), d.a.createElement(ae, null, d.a.createElement(oe, {
						onClick: e.toggleModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(de, {
						disabled: !this.canSave(),
						onClick: this.onSave
					}, r.fbt._("Save", null, {
						hk: "4yMsMq"
					}))))
				}
			}
			var me = Object(V.a)(le(ue)),
				pe = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/toaster.ts")),
				be = n("./src/reddit/components/StructuredStyles/ImageUpload/index.tsx"),
				fe = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.ts"),
				he = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				_e = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				ge = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				ve = n("./src/reddit/models/Image/index.tsx"),
				xe = n("./src/reddit/models/Toast/index.ts"),
				Oe = n("./src/reddit/components/ModHub/Emojis/EmojiUploadModal/index.m.less"),
				Ee = n.n(Oe),
				ye = n("./src/higherOrderComponents/withImageUploads.tsx"),
				Ce = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				je = n("./src/reddit/models/Emoji/index.ts"),
				ke = n("./src/reddit/components/ModHub/Emojis/EmojiUploader/index.m.less"),
				Ie = n.n(ke),
				Se = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				we = n("./src/reddit/components/ProgressBar/index.tsx"),
				Te = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				Ne = n("./src/reddit/controls/ErrorText/index.tsx");
			const Pe = 5,
				Re = 95,
				Ae = 600,
				Me = 100;
			class Le extends d.a.Component {
				constructor() {
					super(...arguments), this.intervalToken = 0, this.state = {
						timeStarted: Date.now(),
						percent: Pe
					}, this.tick = () => {
						const e = function(e) {
							const t = e / Ae,
								n = (Math.log(t / 10) + 3) / 2.1;
							return Math.max(Re, Math.min(Pe, 100 * n))
						}(Date.now() - this.state.timeStarted);
						this.setState({
							percent: e
						}), e === Re && this.intervalToken && window.clearInterval(this.intervalToken)
					}
				}
				componentDidMount() {
					this.intervalToken = window.setInterval(this.tick, Me)
				}
				componentWillUnmount() {
					this.intervalToken && window.clearInterval(this.intervalToken)
				}
				render() {
					return d.a.createElement(we.a, {
						className: Ie.a.progressBar,
						innerBarClassName: Ie.a.innerBarClassName,
						percent: this.state.percent
					})
				}
			}
			var De = Le;
			const Fe = u.a.wrapped(Se.a, "characterCountdown", Ie.a),
				Ue = u.a.wrapped(Ce.a, "clearIcon", Ie.a),
				Be = u.a.wrapped(Ne.b, "errorText", Ie.a),
				qe = u.a.wrapped(Q.a, "expandLeft", Ie.a),
				Ge = u.a.div("iconSpacer", Ie.a),
				He = u.a.wrapped(R.a, "imageDisplay", Ie.a),
				We = u.a.div("inputPlaceholder", Ie.a),
				Ve = u.a.wrapped(Q.a, "inputPlaceholder", Ie.a),
				ze = u.a.wrapped(K.a, "textButton", Ie.a);
			class Ke extends d.a.Component {
				constructor() {
					super(...arguments), this.handleChangeEmojiName = e => {
						this.props.onChangeEmojiName && this.props.onChangeEmojiName(this.props.index, e.target.value)
					}, this.handleRemove = e => {
						this.props.onCancel(this.props.index)
					}, this.renderContent = () => {
						const {
							emojiName: e,
							errorText: t,
							fileName: n,
							handleRetry: s,
							imageData: o,
							isDuplicate: i
						} = this.props;
						switch (o.kind) {
							case ve.b.NotUploaded:
							case ve.b.Pending:
								return d.a.createElement("div", null, d.a.createElement(Ve, null, o.kind === ve.b.NotUploaded ? d.a.createElement(De, null) : d.a.createElement(we.a, {
									className: Ie.a.progressBar,
									innerBarClassName: Ie.a.innerBarClassName,
									percent: 0
								}), d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Cancel", null, {
									hk: "2TSLl5"
								}))), d.a.createElement(fe.b, null, r.fbt._("Uploading {fileName}", [r.fbt._param("fileName", n)], {
									hk: "NIxvK"
								})));
							case ve.b.FailedToUpload:
							case ve.b.Invalid:
								return d.a.createElement("div", null, d.a.createElement(Ve, null, r.fbt._("Failed to upload", null, {
									hk: "2LBRW2"
								}), s ? d.a.createElement(ze, {
									onClick: s
								}, r.fbt._("Retry", null, {
									hk: "3EwbaK"
								})) : d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(Be, null, t));
							case ve.b.Uploaded:
								return d.a.createElement(We, null, r.fbt._("Saved", null, {
									hk: "2xDFZZ"
								}));
							default:
								return d.a.createElement("div", null, d.a.createElement(Te.c, {
									className: i ? Ie.a.duplicateInput : Ie.a.input,
									onChange: this.handleChangeEmojiName,
									placeholder: r.fbt._("Emoji name", null, {
										hk: "UpQdA"
									}),
									value: e
								}), d.a.createElement(qe, null, d.a.createElement(Fe, {
									maxChars: je.d,
									text: e
								}), d.a.createElement(ze, {
									onClick: this.handleRemove
								}, r.fbt._("Remove", null, {
									hk: "3tYl0U"
								}))), t && d.a.createElement(Be, null, t))
						}
					}
				}
				render() {
					const {
						emojiName: e,
						imageData: t,
						isSaving: n
					} = this.props;
					return n ? d.a.createElement(d.a.Fragment, null, d.a.createElement(We, null, d.a.createElement(De, null)), d.a.createElement(fe.b, null, r.fbt._("Saving {emojiName}", [r.fbt._param("emojiName", e)], {
						hk: "3lMST7"
					}))) : d.a.createElement(ge.a, null, t.kind === ve.b.FailedToUpload || t.kind === ve.b.Invalid ? d.a.createElement(Ge, null, d.a.createElement(Ue, null)) : d.a.createElement(He, {
						backgroundImage: t.url
					}), this.renderContent())
				}
			}
			var Qe = Ke,
				Ye = n("./node_modules/lodash/countBy.js"),
				Je = n.n(Ye),
				Xe = n("./node_modules/lodash/filter.js"),
				Ze = n.n(Xe),
				$e = n("./node_modules/lodash/includes.js"),
				et = n.n($e),
				tt = n("./node_modules/lodash/transform.js"),
				nt = n.n(tt);
			const st = /^[A-Za-z0-9_-]{1,24}$/,
				rt = ["reddit", "snoo", "spez"],
				ot = (e, t, n) => !st.test(e) || !n && (e => {
					const t = e.toLowerCase();
					return rt.reduce((e, n) => e || -1 !== t.indexOf(n), !1)
				})(e) ? r.fbt._("Invalid emoji name", null, {
					hk: "2Oromm"
				}) : et()(t, e) ? r.fbt._("This name is already taken", null, {
					hk: "4dwdJL"
				}) : "",
				it = e => e.name ? e.name.replace(/\.[^.]*$/, "").replace(/[^A-Za-z0-9_-]/g, " ").trim().replace(/ +/g, "_").slice(0, 24) : "",
				at = (e, t) => (t.kind !== ve.b.TempUploaded || !e.emojiNameError && !e.isNameMissing) && (t.kind !== ve.b.NotUploaded && t.kind !== ve.b.Pending),
				dt = e => {
					let t = "";
					return e.file.size > je.a ? t = "file-size-error" : (e.height > je.b || e.width > je.c) && (t = "image-size-error"), {
						emojiNameError: "",
						imageError: t,
						name: it(e.file),
						fileName: e.file.name,
						isNameMissing: !1
					}
				},
				ct = (e, t) => t.reduce((t, n) => n.kind === e ? t + 1 : t, 0),
				lt = (e, t) => {
					const {
						emojiNameError: n,
						imageError: s,
						isNameMissing: o
					} = t;
					let i = "";
					e.kind === ve.b.FailedToUpload && (i = e.error.fields && e.error.fields.length ? e.error.fields[0].msg : r.fbt._("Something went wrong", null, {
						hk: "2fCWXR"
					}));
					const a = i || !1,
						d = n || !!o && r.fbt._("Emoji name is required", null, {
							hk: "4sL3l7"
						});
					let c = "";
					return "file-size-error" === s ? c = r.fbt._("File size too large", null, {
						hk: "EksGU"
					}) : "image-size-error" === s && (c = r.fbt._("Image size too large", null, {
						hk: "1xjOmq"
					})), c || a || d || ""
				},
				ut = e => {
					const t = Ze()(e, e => !e.emojiNameError && !e.imageError),
						n = Je()(t, e => e.name);
					return nt()(n, (e, t, n) => {
						t > 1 && e.push(n)
					}, [])
				},
				mt = 500,
				pt = u.a.div("UploaderContainer", Ie.a),
				bt = u.a.wrapped(S.a, "alertIcon", Ie.a),
				ft = u.a.wrapped(Ce.a, "duplicatesIcon", Ie.a),
				ht = u.a.wrapped(z.p, "duplicateWarning", Ie.a),
				_t = u.a.wrapped(E.l, "modalAddButton", Ie.a),
				gt = u.a.wrapped(z.a, "modalCancelButton", Ie.a),
				vt = u.a.div("uploaderContainer", Ie.a),
				xt = u.a.wrapped(z.p, "modProTip", Ie.a),
				Ot = u.a.div("progressText", Ie.a),
				Et = u.a.wrapped(z.p, "replacingDescription", Ie.a),
				yt = u.a.div("replacingTitle", Ie.a),
				Ct = u.a.div("uploadingTitle", Ie.a),
				jt = Object(l.c)({
					emojis: T.d,
					isSnoomojiSubreddit: Y.n,
					reservedEmojiNames: T.e
				}),
				kt = Object(c.b)(jt, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						emojisUploadedToast: () => e(pe.f({
							kind: xe.b.SuccessCommunityGreen,
							text: r.fbt._("New emojis added!", null, {
								hk: "1Q1mEq"
							})
						})),
						saveEmoji: (t, s, r) => e(Object(m.n)({
							imageData: t,
							subredditId: n,
							emojiName: s,
							settings: r
						}))
					}
				});
			class It extends d.a.Component {
				constructor(e) {
					super(e), this.timeoutToken = 0, this.loadIndex = 0, this.tempUploadNext = async () => {
						const e = this.getNextPendingImageToLoad();
						if (!e) return this.timeoutToken = 0, void(this.loadIndex = 0);
						const {
							subredditId: t
						} = this.props, n = this.state.emojiData[e.id], s = Object(ve.m)(e);
						await this.props.uploadImage({
							imageData: s,
							subredditId: t,
							emojiName: n.name,
							settings: this.props.emojiSettings
						}), this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(this.tempUploadNext, mt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.emojiIsADuplicate = (e, t) => e && t && t.some(t => t.id === e.id), this.saveNext = e => {
						const t = this.getNextTempUploadedImageToSave();
						if (!t) return this.timeoutToken = 0, void(this.loadIndex = 0);
						if (!this.emojiIsADuplicate(t, e)) {
							const e = this.state.emojiData[t.id],
								n = this.props.saveEmoji(t, e.name, this.props.emojiSettings);
							this.setState({
								emojisUploaded: this.state.emojisUploaded || n
							})
						}
						this.loadIndex += 1, this.loadIndex < this.state.localData.length ? this.timeoutToken = window.setTimeout(() => this.saveNext(e), mt) : (this.loadIndex = 0, this.timeoutToken = 0)
					}, this.onChangeEmojiName = (e, t) => {
						const {
							isSnoomojiSubreddit: n,
							reservedEmojiNames: s
						} = this.props;
						if (t.length > je.d) return;
						const r = this.state.isReplacing ? this.state.replacingEmoji && this.state.replacingEmoji[e] : this.state.localData[e];
						if (!r) return;
						const o = this.state.emojiData,
							i = o[r.id],
							a = t ? ot(t, s, n) : "";
						o[r.id].emojiNameError = a, o[r.id].name = t;
						const d = ut(o);
						this.setState({
							duplicateNames: d,
							emojiData: {
								...this.state.emojiData,
								[r.id]: {
									...i,
									emojiNameError: a,
									isNameMissing: !t,
									name: t
								}
							}
						})
					}, this.canSave = () => {
						let e = !1;
						for (const t of this.state.localData) {
							if (!at(this.state.emojiData[t.id], t)) return !1;
							t.kind === ve.b.TempUploaded && (e = !0)
						}
						return e
					}, this.getValidatedState = () => {
						const {
							isSnoomojiSubreddit: e,
							reservedEmojiNames: t
						} = this.props, n = {};
						for (const s of this.state.localData) {
							let r = this.state.emojiData[s.id];
							const o = ot(r.name, t, e);
							r.name && !o || (r = {
								...r,
								emojiNameError: o,
								isNameMissing: !r.name
							}), n[s.id] = r
						}
						return {
							emojiData: n
						}
					}, this.onApply = () => {
						const e = this.getValidatedState();
						this.setState(e, () => {
							if (this.canSave()) {
								const e = this.props.emojis[this.props.subredditId].emojis,
									t = [];
								for (const s of this.state.localData) {
									if (s.kind !== ve.b.TempUploaded) continue;
									this.state.emojiData[s.id].name in e && t.push(s)
								}
								t.length ? (this.setState({
									replacingEmoji: t,
									isReplacing: !0
								}), this.saveNext(t)) : (this.setState({
									isSavingImage: !0
								}), this.props.setIsSaving(!0), this.saveNext());
								const n = ct(ve.b.TempUploaded, this.state.localData) - t.length;
								n > 0 && (this.props.sendEvent(I("add", n)), this.sendSettingsEvent())
							}
						})
					}, this.sendSettingsEvent = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.props.emojiSettings;
						this.props.sendEvent(j("mods_only", e)), this.props.sendEvent(j("appear_user_flair", t)), this.props.sendEvent(j("appear_post_flair", n))
					}, this.handleSaveAndReplace = () => {
						this.setState({
							isReplacing: !1,
							isSavingImage: !0
						}), this.props.setIsSaving(!0);
						const {
							replacingEmoji: e
						} = this.state, t = e ? e.length : 0;
						this.saveNext(), t > 0 && (this.props.sendEvent(I("replace", t)), this.sendSettingsEvent())
					}, this.handleCancelReplace = () => {
						this.setState({
							isReplacing: !1,
							replacingEmoji: null
						}), this.props.stopEditing(), this.props.sendEvent(k("dont_replace"))
					}, this.findEmojiIndexById = e => this.state.localData.findIndex(t => t.id === e), this.removeEmoji = e => {
						const {
							isReplacing: t,
							localData: n,
							replacingEmoji: s
						} = this.state;
						let r, o = e;
						t && s && s[e] && (o = this.findEmojiIndexById(s[e].id), (r = s.slice(0)).splice(e, 1), this.setState({
							replacingEmoji: r
						}));
						const i = n[o],
							a = n.slice(0);
						a.splice(o, 1);
						const d = {
							...this.state.emojiData
						};
						delete d[i.id], this.setState({
							duplicateNames: ut(d),
							emojiData: d,
							localData: a
						}), t && s ? 0 === r.length && this.props.returnToAddState() : 0 === a.length && this.props.returnToAddState()
					}, this.retryEmojiUpload = () => {
						this.props.returnToAddState()
					};
					const t = {},
						n = [];
					for (const s of e.images) {
						const e = dt(s);
						t[s.id] = e, e.imageError ? n.push(Object(ve.l)(s, e.imageError)) : n.push(s)
					}
					this.state = {
						duplicateNames: ut(t),
						emojiData: t,
						emojisUploaded: !1,
						isReplacing: !1,
						isSavingImage: !1,
						localData: n,
						replacingEmoji: null
					}
				}
				UNSAFE_componentWillMount() {
					this.loadIndex = 0, this.tempUploadNext()
				}
				getNextPendingImageToLoad() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ve.b.Pending) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				getNextTempUploadedImageToSave() {
					let e, t = null;
					for (e = this.loadIndex; e < this.state.localData.length; e++) {
						const n = this.state.localData[e];
						if (n.kind === ve.b.TempUploaded) {
							t = n;
							break
						}
					}
					return this.loadIndex = e, t
				}
				UNSAFE_componentWillReceiveProps(e) {
					const t = e.getImageUploadsIfModified(this.state.localData);
					if (!t) return;
					let n = !1;
					const {
						isSavingImage: s
					} = this.state, r = {};
					for (const o of t) r[o.id] = this.state.emojiData[o.id], n = n || o.kind === ve.b.TempUploaded;
					!s || n ? (this.props.setIsSaving(s), this.setState({
						emojiData: r,
						isSavingImage: s,
						localData: t
					})) : this.props.stopEditing()
				}
				componentWillUnmount() {
					for (const e of this.state.localData) this.props.cancelUpload(e);
					this.timeoutToken && window.clearTimeout(this.timeoutToken), this.state.emojisUploaded && this.props.emojisUploadedToast(), this.setState({
						emojisUploaded: !1,
						isReplacing: !1
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = t.isReplacing ? t.replacingEmoji || [] : t.localData;
					return d.a.createElement(pt, null, d.a.createElement(vt, null, t.duplicateNames.length > 0 ? d.a.createElement(ht, null, d.a.createElement(ft, null), r.fbt._("Duplicate names", null, {
						hk: "4kkNr1"
					})) : !t.isReplacing && d.a.createElement(xt, null, d.a.createElement(bt, null), r.fbt._("Names cannot be edited once added", null, {
						hk: "3f45r5"
					})), d.a.createElement(z.l, null, t.isReplacing ? d.a.createElement(d.a.Fragment, null, d.a.createElement(yt, null, r.fbt._("Replacing emojis", null, {
						hk: "4cKike"
					})), d.a.createElement(Et, null, r.fbt._("These emoji names already exist in your community. Replacing these emojis will not change pre-existing permissions. Do you want to replace them?", null, {
						hk: "3iPBUU"
					}))) : d.a.createElement(Ct, null, r.fbt._("Uploading emojis", null, {
						hk: "7keSV"
					})), d.a.createElement("div", {
						className: t.isReplacing ? void 0 : Ie.a.emojiDisplays
					}, n.map((e, n) => {
						const s = this.state.emojiData[e.id],
							r = e.kind === ve.b.FailedToUpload || e.kind === ve.b.Invalid,
							o = t.replacingEmoji && !t.replacingEmoji.find(t => t.id === e.id);
						if (t.isSavingImage && (r || o)) return;
						const i = lt(e, s);
						return d.a.createElement(fe.a, {
							key: e.id
						}, d.a.createElement(Qe, {
							emojiName: s.name,
							errorText: i,
							fileName: s.fileName,
							imageData: e,
							index: n,
							isDuplicate: t.duplicateNames.includes(s.name),
							isSaving: t.isSavingImage,
							onCancel: this.removeEmoji,
							onChangeEmojiName: this.onChangeEmojiName
						}))
					})), !t.isReplacing && d.a.createElement(Ot, null, t.isSavingImage ? r.fbt._("{savedCount} out of {savedTotal} saved", [r.fbt._param("savedCount", ct(ve.b.Uploaded, t.localData).toString()), r.fbt._param("savedTotal", t.localData.length.toString())], {
						hk: "3v1E9N"
					}) : r.fbt._("{uploadedCount} out of {uploadedTotal} uploaded", [r.fbt._param("uploadedCount", ct(ve.b.TempUploaded, t.localData).toString()), r.fbt._param("uploadedTotal", t.localData.length.toString())], {
						hk: "41qbSa"
					})))), d.a.createElement(z.g, null, d.a.createElement(gt, {
						disabled: t.isSavingImage,
						onClick: t.isReplacing ? this.handleCancelReplace : e.stopEditing
					}, t.isReplacing ? r.fbt._("Don't replace", null, {
						hk: "4d8hwM"
					}) : r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(_t, {
						disabled: t.isSavingImage || !this.canSave() || t.duplicateNames.length > 0,
						onClick: t.isReplacing ? this.handleSaveAndReplace : this.onApply
					}, t.isReplacing ? r.fbt._("Replace", null, {
						hk: "45noqB"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					}))))
				}
			}
			var St = Object(ye.a)(kt(It), m.o),
				wt = n("./src/reddit/actions/imageUploads.ts"),
				Tt = n("./src/reddit/selectors/imageUploads.ts");
			const Nt = u.a.div("UploaderContainer", Ie.a),
				Pt = u.a.wrapped(Nt, "editEmojiDisplay", Ie.a),
				Rt = Object(l.c)({
					reduxImage: (e, t) => {
						let {
							pendingImage: n
						} = t;
						const s = Object(Tt.b)(e),
							r = n && n.id;
						return r && s[r] || void 0
					}
				});
			class At extends d.a.Component {
				constructor(e) {
					super(e), this.onCancelAndRetry = () => {
						this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage), this.props.onRetryUpload()
					}
				}
				componentDidMount() {
					const e = Object(ve.m)(this.props.pendingImage);
					this.props.uploadImage({
						imageData: e,
						subredditId: this.props.subredditId,
						emojiName: this.props.emoji.name,
						settings: this.props.emojiSettings
					})
				}
				componentDidUpdate(e) {
					this.props.reduxImage && this.props.reduxImage !== e.reduxImage && this.props.onImageChange(this.props.reduxImage)
				}
				componentWillUnmount() {
					this.props.reduxImage && this.props.cancelUpload(this.props.reduxImage)
				}
				render() {
					const {
						pendingImage: e,
						reduxImage: t,
						emoji: n
					} = this.props, s = dt(e), r = Object(ve.l)(e, s.imageError), o = s.imageError ? r : t || e, i = lt(o, s);
					return !i && o.kind === ve.b.TempUploaded || o.kind === ve.b.Uploaded ? null : d.a.createElement(Pt, null, d.a.createElement(Qe, {
						emojiName: n.name,
						errorText: i,
						fileName: s.fileName,
						handleRetry: this.onCancelAndRetry,
						imageData: o,
						index: 0,
						isSaving: !1,
						onCancel: this.onCancelAndRetry
					}))
				}
			}
			var Mt = Object(c.b)(Rt, e => ({
				uploadImage: t => e(Object(m.o)(t)),
				cancelUpload: t => e(Object(wt.h)(t))
			}))(At);

			function Lt() {
				return (Lt = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const Dt = 32,
				Ft = 128,
				Ut = 64,
				Bt = 100,
				qt = u.a.div("appearsIn", Ee.a),
				Gt = u.a.wrapped(he.a, "checkbox", Ee.a),
				Ht = u.a.span("checkboxText", Ee.a),
				Wt = u.a.wrapped(K.a, "closeButton", Ee.a),
				Vt = u.a.div("imageTitle", Ee.a),
				zt = u.a.wrapped(E.l, "modalAddButton", Ee.a),
				Kt = u.a.wrapped(z.e, "modalBody", Ee.a),
				Qt = u.a.wrapped(z.a, "modalCancelButton", Ee.a),
				Yt = u.a.wrapped(z.l, "modalMain", Ee.a),
				Jt = u.a.wrapped(ne, "modFlairOnlyToggle", Ee.a),
				Xt = u.a.wrapped(_e.a, "modIcon", Ee.a),
				Zt = u.a.li("modProTip", Ee.a),
				$t = u.a.div("modProTips", Ee.a),
				en = u.a.div("modProTipTitle", Ee.a),
				tn = u.a.div("proTip", Ee.a),
				nn = u.a.ul("tipList", Ee.a),
				sn = e => !!e && (e.kind === ve.b.Pending ? !!dt(e).imageError : e.kind === ve.b.FailedToUpload);
			var rn;
			! function(e) {
				e[e.AddState = 0] = "AddState", e[e.SingleEmojiEditState = 1] = "SingleEmojiEditState", e[e.BulkUploadState = 2] = "BulkUploadState"
			}(rn || (rn = {}));
			const on = u.a.wrapped(ge.a, "emojiDisplay", Ee.a),
				an = u.a.div("emojiNameDisplay", Ee.a),
				dn = u.a.wrapped(R.a, "imageDisplay", Ee.a),
				cn = e => d.a.createElement(on, null, d.a.createElement(dn, {
					backgroundImage: e.url
				}), d.a.createElement(an, null, e.emojiName)),
				ln = Object(l.c)({
					emojisCustomSize: (e, t) => Object(Y.z)(e, {
						subredditName: t.subreddit.name
					}).emojisCustomSize
				}),
				un = Object(c.b)(ln, (e, t) => {
					let {
						emoji: n,
						isSnoomoji: s,
						subreddit: o
					} = t;
					return {
						saveEmoji: (t, n, s) => e(m.n({
							imageData: s,
							subredditId: o.id,
							emojiName: t,
							settings: n
						})),
						saveEmojiSettings: t => {
							n && e(m.m(n.name, s, t, o.id))
						},
						saveEmojiSuccessToast: () => e(pe.f({
							kind: xe.b.SuccessCommunityGreen,
							text: r.fbt._("Emoji edits saved!", null, {
								hk: "3luBMA"
							})
						}))
					}
				});
			class mn extends d.a.Component {
				constructor(e) {
					super(e), this.closeModal = () => {
						this.props.toggleModal()
					}, this.clearImageData = () => {
						this.setState({
							imageData: [],
							emojiDraftImage: void 0
						})
					}, this.onEditingImageChange = e => {
						this.setState({
							emojiDraftImage: e
						})
					}, this.handleMultiImageInput = async e => {
						let t;
						const n = this.state.emojiState === rn.SingleEmojiEditState;
						n && this.clearImageData(), t = Array.isArray(e) ? n ? e.slice(0, 1) : e.slice(0, Bt) : [e];
						const s = await Promise.all(t.map(ve.f));
						n ? this.setState({
							imageData: s
						}) : this.setState({
							emojiState: rn.BulkUploadState,
							imageData: s
						})
					}, this.handleModExclusiveToggle = () => this.setState({
						settings: {
							...this.state.settings,
							modFlairOnly: !this.state.settings.modFlairOnly
						}
					}), this.handleTogglePostFlair = () => this.setState({
						settings: {
							...this.state.settings,
							postFlairAllowed: !this.state.settings.postFlairAllowed
						}
					}), this.handleToggleUserFlair = () => this.setState({
						settings: {
							...this.state.settings,
							userFlairAllowed: !this.state.settings.userFlairAllowed
						}
					}), this.returnToAdd = () => {
						this.setState({
							emojiState: rn.AddState
						}), this.clearImageData()
					}, this.sendToggleEvent = (e, t) => this.props.sendEvent(j(e, t)), this.modFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.modFlairOnly !== this.state.settings.modFlairOnly, this.userFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.userFlairAllowed !== this.state.settings.userFlairAllowed, this.postFlairSettingHasChanged = () => this.props.emoji && this.props.emoji.postFlairAllowed !== this.state.settings.postFlairAllowed, this.settingsHaveBeenChanged = () => this.modFlairSettingHasChanged() || this.userFlairSettingHasChanged() || this.postFlairSettingHasChanged(), this.sendTelemetryEvents = () => {
						const {
							modFlairOnly: e,
							userFlairAllowed: t,
							postFlairAllowed: n
						} = this.state.settings;
						this.modFlairSettingHasChanged() && this.sendToggleEvent("mods_only", e), this.userFlairSettingHasChanged() && this.sendToggleEvent("appear_user_flair", t), this.postFlairSettingHasChanged() && this.sendToggleEvent("appear_post_flair", n)
					}, this.saveEmoji = async () => {
						const {
							props: e,
							state: t
						} = this, n = {
							modFlairOnly: t.settings.modFlairOnly,
							postFlairAllowed: t.settings.postFlairAllowed,
							userFlairAllowed: t.settings.userFlairAllowed
						};
						if (this.setIsSaving(!0), e.emoji) {
							if (e.isSnoomoji || e.emoji && !t.emojiDraftImage) e.saveEmojiSettings(n);
							else if (e.emoji && t.emojiDraftImage && t.emojiDraftImage.kind === ve.b.TempUploaded) {
								await e.saveEmoji(e.emoji.name, n, t.emojiDraftImage) && e.saveEmojiSuccessToast()
							}
							this.sendTelemetryEvents()
						}
						this.closeModal(), this.setIsSaving(!1)
					}, this.setIsSaving = e => this.setState({
						isSaving: e
					}), this.state = {
						emojiState: e.emoji ? rn.SingleEmojiEditState : rn.AddState,
						imageData: [],
						isSaving: !1,
						settings: {
							modFlairOnly: !!e.emoji && e.emoji.modFlairOnly,
							postFlairAllowed: !e.emoji || e.emoji.postFlairAllowed,
							userFlairAllowed: !e.emoji || e.emoji.userFlairAllowed
						}
					}
				}
				render() {
					const {
						emoji: e,
						emojisCustomSize: t,
						isSnoomoji: n,
						sendEvent: s,
						subreddit: o
					} = this.props, {
						emojiDraftImage: i,
						emojiState: a,
						imageData: c,
						isSaving: l,
						settings: u
					} = this.state, m = {
						emojiSettings: u,
						stopEditing: this.closeModal,
						subredditId: o.id
					}, p = 2 * (t ? t[0] : Dt), b = 2 * (t ? t[1] : Dt), f = c.length > 0 ? c[0] : void 0, h = f && f.url, _ = i && i.url, g = h || _, v = i && i.kind === ve.b.TempUploaded, x = sn(f || i), O = a !== rn.SingleEmojiEditState || (!this.settingsHaveBeenChanged() && !v || x);
					return d.a.createElement(Kt, null, d.a.createElement(z.i, null, d.a.createElement(Q.a, null, d.a.createElement(z.q, null, e ? r.fbt._("Edit emoji", null, {
						hk: "4awCz5"
					}) : r.fbt._("Add new emojis", null, {
						hk: "2DrJ62"
					})), d.a.createElement(Wt, {
						disabled: l,
						onClick: this.closeModal
					}, d.a.createElement(z.b, null)))), (a === rn.AddState || a === rn.SingleEmojiEditState) && d.a.createElement(d.a.Fragment, null, a === rn.AddState && d.a.createElement($t, null, d.a.createElement(en, null, d.a.createElement(Xt, null), r.fbt._("Mod pro tips!", null, {
						hk: "30l9bq"
					})), d.a.createElement(nn, null, d.a.createElement(Zt, null, r.fbt._("Emoji names will use the image file name and will be editable once uploaded", null, {
						hk: "2fvAIQ"
					})), d.a.createElement(Zt, null, r.fbt._("You can upload up to {maxUpload} emojis at once", [r.fbt._param("maxUpload", Bt.toString())], {
						hk: "4aMYoX"
					})))), d.a.createElement(Yt, null, a === rn.SingleEmojiEditState && e && d.a.createElement(cn, {
						emojiName: e.name,
						url: g || e.url
					}), !n && d.a.createElement(d.a.Fragment, null, d.a.createElement(fe.i, null, d.a.createElement(Vt, null, e ? r.fbt._("Image", null, {
						hk: "3fzI70"
					}) : r.fbt._("Images", null, {
						hk: "3SapUk"
					})), e && a === rn.SingleEmojiEditState && f && d.a.createElement(Mt, Lt({}, m, {
						emoji: e,
						onRetryUpload: this.clearImageData,
						pendingImage: f,
						onImageChange: this.onEditingImageChange
					})), (!c.length || v) && !(e && x) && d.a.createElement(be.b, {
						label: r.fbt._("Drag and Drop or Upload Image", null, {
							hk: "3y5WvP"
						}),
						onChange: this.handleMultiImageInput,
						multiple: !0
					}), d.a.createElement(fe.b, null, r.fbt._("Max upload dimensions {maxEmojiWidth} x {maxEmojiHeight}px", [r.fbt._param("maxEmojiWidth", Ft.toString()), r.fbt._param("maxEmojiHeight", Ft.toString())], {
						hk: "yal28"
					})), d.a.createElement(fe.b, null, r.fbt._("Max file size {MAX_FILE_SIZE}KB", [r.fbt._param("MAX_FILE_SIZE", Ut.toString())], {
						hk: "1t1L0f"
					}))), d.a.createElement(tn, null, r.fbt._("Recommended upload dimensions: {recommendedWidth} x {recommendedHeight}px", [r.fbt._param("recommendedWidth", p.toString()), r.fbt._param("recommendedHeight", b.toString())], {
						hk: "35CqDV"
					}))), d.a.createElement(qt, null, r.fbt._("Appears in:", null, {
						hk: "3SZP5W"
					})), d.a.createElement(Gt, {
						name: "postFlair",
						onChange: this.handleTogglePostFlair,
						value: u.postFlairAllowed
					}, d.a.createElement(Ht, null, r.fbt._("Post flair", null, {
						hk: "mAzeZ"
					}))), d.a.createElement(Gt, {
						name: "userFlair",
						onChange: this.handleToggleUserFlair,
						value: u.userFlairAllowed
					}, d.a.createElement(Ht, null, r.fbt._("User flair", null, {
						hk: "qVf7x"
					}))), d.a.createElement(Jt, {
						description: "Only appears in post and user flair that are restricted for mod use.",
						on: u.modFlairOnly,
						onToggle: this.handleModExclusiveToggle,
						title: "Mod only"
					})), d.a.createElement(z.g, null, d.a.createElement(Qt, {
						disabled: l,
						onClick: this.closeModal
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), d.a.createElement(zt, {
						disabled: O,
						onClick: this.saveEmoji
					}, e ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add", null, {
						hk: "2wi3d4"
					})))), a === rn.BulkUploadState && d.a.createElement(St, Lt({}, m, {
						images: c,
						returnToAddState: this.returnToAdd,
						sendEvent: s,
						setIsSaving: this.setIsSaving
					})))
				}
			}
			var pn = Object(V.a)(un(mn));
			const bn = u.a.wrapped(S.a, "alertIcon", P.a),
				fn = u.a.span("appearsTitle", P.a),
				hn = u.a.span("imageTitle", P.a),
				_n = u.a.span("nameTitle", P.a),
				gn = u.a.span("permissionsTitle", P.a),
				vn = u.a.wrapped(E.o, "settingsButton", P.a),
				xn = u.a.wrapped(_.a, "titleTooltip", P.a),
				On = u.a.wrapped(v.a, "topRow", P.a),
				En = Object(l.c)({
					emojis: T.d,
					isConfirmModalOpen: Object(w.b)("EmojiManager--DeleteEmojiConfirmation--Modal"),
					isEmojisEnabled: (e, t) => Object(T.b)(e, t.subreddit.name),
					isEmojiSettingsModalOpen: Object(w.b)("EmojiManager--Settings--Modal"),
					isUploadEmojisModalOpen: Object(w.b)("EmojiManager--UploadEmojis--Modal")
				}),
				yn = Object(c.b)(En, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						deleteEmoji: t => e(m.i(t, n.id)),
						toggleDeleteConfirmationModal: () => e(Object(p.i)("EmojiManager--DeleteEmojiConfirmation--Modal")),
						toggleSettingsModal: () => e(Object(p.i)("EmojiManager--Settings--Modal")),
						toggleUploadEmojisModal: () => e(Object(p.i)("EmojiManager--UploadEmojis--Modal"))
					}
				});
			class Cn extends d.a.Component {
				constructor(e) {
					super(e), this.onClickEditEmoji = (e, t) => {
						this.props.toggleUploadEmojisModal(), this.setState({
							emojiToEdit: e,
							isSnoomoji: t
						})
					}, this.onConfirmDelete = () => {
						this.props.deleteEmoji(this.state.emojiNameToDelete), this.setState({
							emojiNameToDelete: ""
						}), this.props.sendEvent(k("delete"))
					}, this.handleRemoveEmoji = e => {
						this.setState({
							emojiNameToDelete: e
						}), this.props.toggleDeleteConfirmationModal()
					}, this.state = {
						emojiNameToDelete: "",
						emojiToEdit: null,
						isSnoomoji: !1
					}
				}
				static getDerivedStateFromProps(e, t) {
					return t.emojiToEdit && !e.isUploadEmojisModalOpen ? {
						emojiToEdit: null,
						isSnoomoji: !1
					} : null
				}
				render() {
					const {
						emojis: e,
						isConfirmModalOpen: t,
						isEmojisEnabled: n,
						isEmojiSettingsModalOpen: o,
						isUploadEmojisModalOpen: a,
						sendEvent: c,
						subreddit: l,
						toggleDeleteConfirmationModal: u,
						toggleSettingsModal: m,
						toggleUploadEmojisModal: p
					} = this.props;
					return d.a.createElement(d.a.Fragment, null, d.a.createElement(g.c, null, d.a.createElement(vn, {
						onClick: m
					}, r.fbt._("Emoji settings", null, {
						hk: "2k202A"
					})), d.a.createElement(E.l, {
						onClick: p
					}, r.fbt._("Add emoji", null, {
						hk: "DTe8a"
					}))), d.a.createElement(g.a, null, d.a.createElement(g.b, null, r.fbt._("Emoji management", null, {
						hk: "6xN5s"
					}), d.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010560371`
					})), !n && d.a.createElement(f.a, {
						className: P.a.emojisDisabled,
						color: O.a.quarantine,
						icon: d.a.createElement(bn, null),
						subtitle: r.fbt._("Emojis in flairs will not be displayed, and existing emojis will appear as plain text.", null, {
							hk: "2WaMtH"
						}),
						title: r.fbt._("Emojis have been disabled for this community", null, {
							hk: "7LNIO"
						})
					}), d.a.createElement(On, null, d.a.createElement(hn, null, r.fbt._("Image", null, {
						hk: "1rlqjH"
					})), d.a.createElement(_n, null, r.fbt._("Name", null, {
						hk: "1ugGFI"
					})), d.a.createElement(fn, null, r.fbt._("Appears in", null, {
						hk: "3K8vjU"
					}), d.a.createElement(xn, {
						text: r.fbt._("Set emoji to appear in post flair or user flair", null, {
							hk: "4cg4Se"
						})
					})), d.a.createElement(gn, null, r.fbt._("Settings", null, {
						hk: "2CRrAq"
					}), d.a.createElement(xn, {
						text: r.fbt._("Set emoji to only appear in mod-only flair", null, {
							hk: "2yS10f"
						})
					}))), e[l.id] && i()(e[l.id].emojis, e => d.a.createElement(W, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !1,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), e[l.id] && i()(e[l.id].snoomojis, e => d.a.createElement(W, {
						emoji: e,
						enabled: !0,
						isSnoomoji: !0,
						key: e.name,
						onEdit: this.onClickEditEmoji,
						onRemove: this.handleRemoveEmoji
					})), t && d.a.createElement(b.a, {
						toggleModal: u,
						onConfirm: this.onConfirmDelete,
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete emoji?", null, {
							hk: "3VBsS8"
						}),
						modalText: r.fbt._("Do you wish to delete this emoji?", null, {
							hk: "2sPCxc"
						}),
						trackClick: () => {},
						withOverlay: !0
					}), o && d.a.createElement(me, {
						sendEvent: c,
						subreddit: l,
						toggleModal: m,
						withOverlay: !0
					}), a && d.a.createElement(pn, {
						emoji: this.state.emojiToEdit,
						isSnoomoji: this.state.isSnoomoji,
						sendEvent: c,
						subreddit: l,
						toggleModal: p,
						withOverlay: !0
					})))
				}
			}
			t.a = yn(Object(x.c)(Cn))
		},
		"./src/reddit/components/ModHub/InfoLink/index.m.less": function(e, t, n) {
			e.exports = {
				linkContainer: "_3-yXs2bljbMxTPT6hDZU1I",
				infoIcon: "_2Eloqzd6Vfz9eGsjyzVfsf"
			}
		},
		"./src/reddit/components/ModHub/InfoLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asTooltip.tsx"),
				a = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoLink/index.m.less"),
				l = n.n(c);
			const u = Object(i.a)(a.b),
				m = ["center", "top"],
				p = ["center", "bottom"];
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					return o.a.createElement("a", {
						className: l.a.linkContainer,
						href: this.props.linkUrl,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef,
						target: "_blank",
						rel: "noopener noreferrer",
						onClick: this.props.onClick
					}, o.a.createElement(d.a, {
						className: l.a.infoIcon
					}), o.a.createElement(u, {
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: s.fbt._("Learn more", null, {
							hk: "3zoGtq"
						}),
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				iconContainer: "_39qwCVfS_zadCI7gaPX3MI",
				textTooltip: "_1yEjLpHWBPakuE9kTnIp_w"
			}
		},
		"./src/reddit/components/ModHub/InfoTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				d = n("./src/reddit/icons/fonts/Info/index.tsx"),
				c = n("./src/reddit/components/ModHub/InfoTooltip/index.m.less"),
				l = n.n(c);
			const u = Object(o.a)(a.a),
				m = ["center", "bottom"],
				p = ["center", "top"];
			class b extends r.a.Component {
				constructor(e) {
					super(e), this.tooltipTargetElement = null, this.setTooltipTargetRef = e => this.tooltipTargetElement = e, this.onShowTooltip = () => {
						this.setState({
							showTooltip: !0
						})
					}, this.onHideTooltip = () => {
						this.setState({
							showTooltip: !1
						})
					}, this.state = {
						showTooltip: !1
					}
				}
				render() {
					const {
						props: e
					} = this;
					return r.a.createElement("span", {
						className: l.a.iconContainer,
						onMouseEnter: this.onShowTooltip,
						onMouseLeave: this.onHideTooltip,
						ref: this.setTooltipTargetRef
					}, r.a.createElement(d.a, null), r.a.createElement(u, {
						className: Object(i.a)(e.className, l.a.textTooltip),
						children: e.children,
						isOpen: this.state.showTooltip,
						tooltipTarget: this.tooltipTargetElement,
						targetPosition: m,
						text: e.text,
						tooltipPosition: p
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ModHub/ModHubNav/NavItem.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/controls/InternalLink/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				l = n.n(c);
			const u = e => {
				let {
					className: t
				} = e;
				return o.a.createElement("div", {
					className: Object(i.a)(l.a.newLinkIndicator, t)
				}, s.fbt._("New", null, {
					hk: "BnhHE"
				}))
			};
			t.b = e => e.path ? e.isExternal ? o.a.createElement("a", {
				className: l.a.navLinkStyles,
				href: e.path,
				onClick: e.onClick,
				target: "_blank",
				rel: "noopener noreferrer"
			}, e.label, o.a.createElement(d.a, {
				name: "external_link",
				className: l.a.outboundLinkIcon
			})) : o.a.createElement(a.default, {
				className: Object(i.a)(l.a.navLinkStyles, {
					[l.a.activeLink]: !!e.isActive
				}),
				to: e.path,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})), e.showInboundArrow && o.a.createElement(d.a, {
				name: "right",
				className: l.a.inboundLinkIcon
			})) : o.a.createElement("button", {
				className: l.a.navLinkStyles,
				onClick: e.onClick
			}, e.label, e.isNew && o.a.createElement(u, null), e.isBeta && o.a.createElement("div", {
				className: l.a.newLinkIndicator
			}, s.fbt._("Beta", null, {
				hk: "z4XPh"
			})), e.isUpdated && o.a.createElement("div", {
				className: l.a.updatedLinkIndicator
			}, s.fbt._("Updated", null, {
				hk: "2xkGR3"
			})))
		},
		"./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less": function(e, t, n) {
			e.exports = {
				wikiNavPanel: "KAUs91LhLIPR2bTL1aZRJ",
				contentTree: "_3_qIKXEwRmWcog7k9kGSno",
				footer: "_3FqEpSEBROhNwQ6pW6xmwJ",
				primaryButton: "_3fO0HSLh0kUxdhfv06hiTX",
				pageNavItem: "gCZ0Yr9nZYa9NaCdn8-eS",
				indentLine: "_2qFuXxmElNrzv3E9Qyb5xi",
				itemText: "_8bMrzJrL3U19A5yc6HTgj",
				mActive: "_1gyKwA8_GLuoQ1hu3Apd-w",
				mExists: "_3E5JJL5f6BXoTxqDq40IbB"
			}
		},
		"./src/reddit/components/ModHub/ModHubNav/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1rWejsW3eX4yw72E6Wfmyh",
				titleFontH2: "_10H_HMu7R7ett8pmawqwCS",
				titleFontH3: "_22nuZii7bWeL3c1xoXOl9",
				titleFontH4: "_2UjVJakiyf4d3yQ1sBrOzz",
				titleFontH5: "_22v1odcGzDJaLHik5W5qCz",
				titleFontH6: "_3BdZeq3g8CWhfeqBhIiW7f",
				metadataFont: "BQ88O08B4nIUNd4oLud39",
				flairFont: "_24GksXJ4va-4ZEamEGSlFB",
				labelsFont: "bd2r035T3aLLBkiMZaODQ",
				actionFont: "v0ITosHo9F3Rl2_llDtrc",
				smallButtonFont: "_3Sxxei5IvhyFBFPSQeJemM",
				largeButtonFont: "_-8HW12kqXpCzSoPxOQgrN",
				strongTextFont: "jPwoQR2t4sGD2BGLwCS0o",
				tabFont: "_2TpZx4pScQqA92z2QTYbIk",
				buttonFontXS: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontXs: "_3hhxR89D6EPPCn0stnyDtx",
				buttonFontS: "_2geB6McFSdWvuGRz3nyzjb",
				buttonFontM: "_1uuuzIbDmUCEWDPkR9T_dx",
				buttonFontL: "_1AhaF3ULgALw9k8OUmf0pY",
				buttonFontXL: "_2iQE9slD0Zw-wYQx5FCL1j",
				buttonFontXl: "_2iQE9slD0Zw-wYQx5FCL1j",
				bodyFontH1: "_3hxV-zVTwf7J5X6U1gL2PA",
				bodyFontH2: "_1lSzh7ct7vogYQk35ULeJl",
				bodyFontH3: "_2C3DyZAU4ai6HhZtVTe-Bu",
				bodyFontH4: "_2tzV3r0Sow-B7LA2KMLD45",
				bodyFontH5: "_1-ivrwr3LQQJ2_7q7woFBf",
				bodyFontH6: "pJbG4WvyXqhjYGMHv_062",
				bodyFontH6Small: "_2lZmvARU6npWzDSAF2ffm7",
				bodyFont: "gPA4LKC5gx8g56loAEuW2",
				bodyFontSmall: "_2U2PATpiHbmfDjkovIbtF9",
				bodyFontMono: "_1tyVWTRiPy8hBs1o6HBJ_a",
				landingPageTitleFontH1: "zqAJRqCy7DeyLpsrwXWi9",
				landingPageTitleFontH2: "_1VGCtnevQ7bfeO7-4uYWSV",
				landingPageTitleFontH3: "_3dMJxOTjl7jaGOCSaAcvTW",
				navContainer: "_2xA0SygQ9V-9Vkdad_4tnh",
				wikiNavContainer: "_3wKmughJWQCbpbTpgwf2R_",
				navContainerExp: "_1HiZS01lfLdV-mZxJbB2r1",
				navSection: "_1hDKgrVgEqwg3ogyzK0xTx",
				sectionHeader: "_1C6NYhYvuXKUDoONxrMR0d",
				iconStyles: "_1lHK5OQSXGaQzgW07E3Fh4",
				inboundLinkIcon: "_1cE0_wpoZtV5YKzwxXgxQ6",
				outboundLinkIcon: "_2Fb1fof3pZ4qO7_ZowwnXG",
				navLinkStyles: "jFCRipwFbBNJ4rl18HMK5",
				activeLink: "_4Gq-jEYAhrOCtha4RZ1JZ",
				breadcrumb: "_2Pw-8XrjTaQdxaxIicJXly",
				breadcrumbButton: "_1ofO-HYNTNyx_FUAEbIMME",
				newLinkIndicator: "_26hxZhi3N_WA1WUC6pQRpa",
				updatedLinkIndicator: "_1oCiY0B1NLkEfFfIfSJIF_"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2QinjfjfDTG6Df4_Tb_eRN",
				iconStyles: "_1MvzgnzkNefTZKkd4A5o1Y",
				arrowLeft: "_1Hul4w6ANujC9NsFF6_j4f",
				disabled: "_6Tlmy2FR_9Y83uOLY6oiP"
			}
		},
		"./src/reddit/components/ModHub/PaginationButtons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				d = n("./src/reddit/components/ModHub/PaginationButtons/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("div", {
				className: c.a.container
			}, e.prevButtonEnabled && r.a.createElement(i.default, {
				to: e.prevTo,
				onClick: e.prevButtonOnClick
			}, r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.arrowLeft)
			})), !e.prevButtonEnabled && e.keepDisabled && r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.arrowLeft, c.a.disabled)
			}), e.nextButtonEnabled && r.a.createElement(i.default, {
				to: e.nextTo,
				onClick: e.nextButtonOnClick
			}, r.a.createElement(a.a, {
				className: c.a.iconStyles
			})), !e.nextButtonEnabled && e.keepDisabled && r.a.createElement(a.a, {
				className: Object(o.a)(c.a.iconStyles, c.a.disabled)
			}))
		},
		"./src/reddit/components/ModHub/StyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				ContentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				contentContainer: "_3mbqgd00Kdlh6nVVVhZYdS",
				PageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				pageTitle: "_3rnK1gNGg1hiVaiRd9Hidl",
				TopBar: "_2YY5qLRbI5q6_0JQVKiGt_",
				topBar: "_2YY5qLRbI5q6_0JQVKiGt_"
			}
		},
		"./src/reddit/components/ModHub/StyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/ModHub/StyledComponents/index.m.less"),
				o = n.n(r);
			const i = s.a.div("ContentContainer", o.a),
				a = s.a.div("PageTitle", o.a),
				d = s.a.div("TopBar", o.a)
		},
		"./src/reddit/components/ModModeBanners/index.m.less": function(e, t, n) {
			e.exports = {
				banner: "_3FJq-cq7boH_EAWZsUPWY0",
				icon: "_1QOFlf2Sv2RU3pPqUKD6UD",
				staticBanner: "_14wV0QXuPq6IJL_pdl8sQs"
			}
		},
		"./src/reddit/components/ModModeFilteredReason/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/ModQueueTrigger/index.ts");
			const r = e => (e => !e.isApproved && !!Object(s.b)(e, s.a.AUTOMOD))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.BAN_EVASION))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.CROWD_CONTROL))(e) || (e => !e.isApproved && !!Object(s.b)(e, s.a.HATEFUL_CONTENT))(e)
		},
		"./src/reddit/components/ModModeFilteredReason/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => i.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading filter reason…", null, {
				hk: "K3Ipd"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeFilteredReason/_ModModeFilteredReason.tsx"
				}
			}, {
				fallback: i.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModModeReports/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			const s = e => (e.numReports || 0) > 0 || !!e.modReportsDismissed && e.modReportsDismissed.length > 0 || !!e.userReportsDismissed && e.userReportsDismissed.length > 0,
				r = e => {
					if (e.numReports && e.numReports > 0) return e.numReports;
					return (e.modReportsDismissed && e.modReportsDismissed.length || 0) + (e.userReportsDismissed && e.userReportsDismissed.length || 0)
				},
				o = e => (e.numReports || 0) > 0
		},
		"./src/reddit/components/ModModeReports/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/ModModeBanners/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js"), l = () => i.a.createElement("div", {
				className: Object(r.a)(d.a.banner, d.a.staticBanner)
			}, c._("Loading reports…", null, {
				hk: "4gwdQw"
			})), u = Object(s.a)({
				resolved: {},
				chunkName: () => "ModModeBanners",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("ModModeBanners").then(n.bind(null, "./src/reddit/components/ModModeReports/_ModModeReports.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ModModeReports/_ModModeReports.tsx"
				}
			}, {
				fallback: i.a.createElement(l, null),
				ssr: !1
			});
			t.a = u
		},
		"./src/reddit/components/ModToolsFlatlist/breakpoints.m.less": function(e, t, n) {
			e.exports = {
				HideIfVWSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				hideIfVwSmaller: "_3_rOJpfw54EqNa6daNkKzY",
				ApproveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				approveGroup: "LoIAKSBD5_isA5qtrC3Kt",
				DefaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				defaultVariant: "_1LDTBaBSnv4jL7lV98ayQL",
				CompactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				compactVariant: "_2SLG9GIeu2AqBhz2XpW8ow",
				ClassicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				classicVariant: "_1u3Z1cqZ8_083AStFVo71a",
				RemoveGroup: "_3LzZxt89CjBbx__WYlCPCh",
				removeGroup: "_3LzZxt89CjBbx__WYlCPCh",
				SpamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				spamGroup: "_2WaHNFliLea9SKyF3nlBx8",
				FlairGroup: "_129dedXMiIcel_grUelwoG",
				flairGroup: "_129dedXMiIcel_grUelwoG",
				HideIfVWLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				hideIfVwLarger: "_1RO0TIeDG89QPdOWgZwUvR",
				ButtonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9",
				buttonTextWrapper: "_2xZQ73fYkUDMcVkB0PnaU9"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/constants.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Flair = "FLAIR", e.Spam = "SPAM", e.Remove = "REMOVE", e.Approve = "APPROVE"
				}(s || (s = {}))
		},
		"./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			}));
			var s, r, o, i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/components/ModToolsFlatlist/breakpoints.m.less"),
				l = n.n(c),
				u = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				m = n.n(u);
			! function(e) {
				e.HideIfVWSmaller = "HideIfVWSmaller", e.HideIfVWLarger = "HideIfVWLarger"
			}(s || (s = {})),
			function(e) {
				e.Approve = "ApproveGroup", e.Remove = "RemoveGroup", e.Spam = "SpamGroup", e.Flair = "FlairGroup"
			}(r || (r = {})),
			function(e) {
				e.Classic = "ClassicVariant", e.Compact = "CompactVariant", e.Default = "DefaultVariant"
			}(o || (o = {}));
			const p = {
					[a.a.Approve]: r.Approve,
					[a.a.Remove]: r.Remove,
					[a.a.Spam]: r.Spam,
					[a.a.Flair]: r.Flair
				},
				b = {
					[d.g.Classic]: o.Classic,
					[d.g.Compact]: o.Compact,
					[d.g.Large]: o.Default,
					[d.g.Medium]: o.Default,
					[d.g.Search]: o.Default
				},
				f = e => {
					const t = p[e.flatlistItem],
						n = e.postLayout && b[e.postLayout],
						s = l.a[e.breakpointType],
						r = l.a[t],
						a = n ? l.a[n] : l.a[o.Default];
					return Object(i.a)(s, r, a)
				},
				h = e => {
					const t = e && b[e],
						n = t ? l.a[t] : l.a[o.Default];
					return Object(i.a)(n, m.a.ButtonTextWrapper, l.a.ButtonTextWrapper)
				}
		},
		"./src/reddit/components/ModToolsFlatlist/index.m.less": function(e, t, n) {
			e.exports = {
				container: "OccjSdFd6HkHhShRg6DOl",
				tooltip: "_2a9swcTo72vLia4mUm08Fk",
				ButtonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq",
				buttonTextWrapper: "_3kA8j4bWXyfQV-T-H2dkNq"
			}
		},
		"./src/reddit/components/ModToolsFlatlist/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return M
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/modal.ts"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/actions/tooltip.ts"),
				m = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				p = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				b = n("./src/reddit/components/ModModeReports/helpers.ts"),
				f = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				h = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				_ = n("./src/reddit/helpers/hasModPostPermissions/index.ts"),
				g = n("./src/reddit/helpers/trackers/post.ts"),
				v = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				x = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				O = n("./src/reddit/icons/fonts/Tag/index.tsx"),
				E = n("./src/reddit/selectors/activeModalId.ts"),
				y = n("./src/reddit/selectors/moderatorPermissions.ts"),
				C = n("./src/reddit/selectors/postFlair.ts"),
				j = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				k = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				I = n("./src/lib/constants/index.ts"),
				S = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				w = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx"),
				T = n("./src/reddit/hooks/useTracking.ts"),
				N = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				P = n("./src/reddit/components/ModToolsFlatlist/index.m.less"),
				R = n.n(P);
			const A = e => {
					let {
						className: t,
						textClassName: n,
						isOverlay: r,
						iconOnly: a,
						post: d
					} = e;
					const [c, p] = o.a.useState(!1), [b, f] = o.a.useState(!1), _ = Object(T.a)(), v = Object(i.d)(), {
						isPrediction: x,
						resolvedOptionId: O,
						totalVoteCount: E
					} = d.pollData || {}, y = () => {
						p(!1), v(Object(l.T)(d.id, !1)), d.isRemoved && d.bannedBy === I.m ? _(Object(g.k)(d.id, "confirm_remove")) : _(Object(g.k)(d.id, "remove"))
					}, C = ((e, t) => e ? t === I.m ? s.fbt._("Confirm removal", null, {
						hk: "1t5tKM"
					}) : s.fbt._("removed", null, {
						hk: "35ZTch"
					}) : s.fbt._("remove", null, {
						hk: "3LWMcS"
					}))(d.isRemoved, d.bannedBy), j = M("Remove", d.id, r), k = () => a && v(Object(u.h)({
						tooltipId: j
					})), P = o.a.useMemo(() => E ? 1 === E ? s.fbt._("Removing this post will cancel the 1 prediction that has already been made.", null, {
						hk: "hVYeT"
					}) : s.fbt._("Removing this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", E.toString())], {
						hk: "47oACN"
					}) : s.fbt._("Removing this post will cancel any predictions that have already been made.", null, {
						hk: "26cLeP"
					}), [E]);
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(h.d, {
						className: t,
						textClassName: n,
						id: j,
						text: a ? void 0 : C,
						disabled: d.isRemoved && d.bannedBy !== I.m,
						onMouseEnter: k,
						onMouseLeave: k,
						onClick: () => {
							x ? O ? f(!0) : p(!0) : y()
						}
					}, o.a.createElement(N.a, {
						desc: a ? C : void 0
					}), a && o.a.createElement(m.c, {
						className: R.a.tooltip,
						tooltipId: j,
						text: C
					})), b && o.a.createElement(w.a, {
						title: s.fbt._("This post can't be removed", null, {
							hk: "2GbryD"
						}),
						body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't remove the post.", null, {
							hk: "3wgNhQ"
						}),
						onClose: () => f(!b)
					}), c && o.a.createElement(S.a, {
						withOverlay: !0,
						modalText: P,
						actionText: s.fbt._("Remove", null, {
							hk: "2DXJl4"
						}),
						headerText: s.fbt._("Are you sure?", null, {
							hk: "3CJLRE"
						}),
						onConfirm: y,
						onOverlayClick: () => p(!c),
						toggleModal: () => p(!c)
					}))
				},
				M = function(e, t) {
					let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return `ModToolsFlatlist-${e}${t}${n?"inOverlay":""}`
				},
				L = (e, t) => Object(k.b)({
					breakpointType: k.a.HideIfVWSmaller,
					flatlistItem: e,
					postLayout: t
				}),
				D = Object(i.b)(() => Object(a.c)({
					activeModalId: E.a,
					canEditFlair: (e, t) => {
						let {
							post: n
						} = t;
						return Object(C.a)(e, {
							postId: n.id
						})
					},
					moderatorPermissions: (e, t) => Object(y.m)(e, {
						postId: t.post.id
					})
				}), (e, t) => {
					let {
						post: n
					} = t;
					return {
						onApprovePost: () => e(Object(l.r)(n.id)),
						onOpenPostModModeDropdown: t => e(Object(u.h)({
							tooltipId: t
						})),
						onSpamPost: () => e(Object(l.T)(n.id, !0)),
						onFlairPost: t => () => e(Object(c.i)(t))
					}
				});
			t.a = D(e => {
				const {
					canEditFlair: t,
					className: n,
					isOverlay: a,
					layout: c,
					moderatorPermissions: l,
					modModeEnabled: E,
					onApprovePost: y,
					onFlairPost: C,
					onSpamPost: I,
					post: S,
					sendEvent: w,
					showIconsOnly: T
				} = e, N = Object(i.d)(), P = Object(_.a)(l), D = Object(b.b)(S), F = !(!S.approvedBy || !D), U = Object(f.b)(S.id, a), B = P && E && !S.isSponsored, q = t && E, G = ((e, t) => e ? s.fbt._("reapprove", null, {
					hk: "OJvB1"
				}) : t ? s.fbt._("approved", null, {
					hk: "2bWAFI"
				}) : s.fbt._("approve", null, {
					hk: "2DIHcM"
				}))(F, S.approvedBy), H = (e => e ? s.fbt._("spammed", null, {
					hk: "3GPrkZ"
				}) : s.fbt._("spam", null, {
					hk: "3ebJLg"
				}))(S.isSpam), W = M("Approve", S.id, a), V = M("Spam", S.id, a), z = () => T && N(Object(u.h)({
					tooltipId: W
				})), K = () => T && N(Object(u.h)({
					tooltipId: V
				})), Q = a ? void 0 : c;
				return o.a.createElement("div", {
					className: Object(d.a)(R.a.container, n)
				}, B && o.a.createElement(r.Fragment, null, o.a.createElement(h.b, {
					className: L(j.a.Approve, Q),
					key: "approveButton",
					text: T ? void 0 : G,
					textClassName: Object(k.c)(Q),
					disabled: !!S.approvedBy && !D,
					id: W,
					onMouseEnter: z,
					onMouseLeave: z,
					onClick: () => {
						y(), w(Object(g.k)(S.id, "approve"))
					}
				}, o.a.createElement(v.a, {
					desc: T ? G : void 0
				}), T && o.a.createElement(m.c, {
					className: R.a.tooltip,
					tooltipId: W,
					text: G
				})), o.a.createElement(A, {
					className: L(j.a.Remove, Q),
					textClassName: Object(k.c)(Q),
					isOverlay: a,
					iconOnly: T,
					post: S
				}), o.a.createElement(h.d, {
					className: L(j.a.Spam, Q),
					key: "removeSpamButton",
					text: T ? void 0 : H,
					textClassName: Object(k.c)(Q),
					disabled: S.isSpam,
					id: V,
					onMouseEnter: K,
					onMouseLeave: K,
					onClick: () => {
						I(), w(Object(g.k)(S.id, "spam"))
					}
				}, o.a.createElement(x.a, {
					desc: T ? H : void 0
				}), T && o.a.createElement(m.c, {
					className: R.a.tooltip,
					tooltipId: V,
					text: H
				}))), q && o.a.createElement(h.c, {
					className: L(j.a.Flair, Q),
					key: "tagButton",
					onClick: () => {
						C(U)(), w(Object(g.k)(S.id, "post_flair_picker"))
					}
				}, o.a.createElement(O.a, null)), o.a.createElement(p.f, null))
			})
		},
		"./src/reddit/components/ModWelcomeTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				Overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				overlay: "_2PnG5snRqhlCLmlBFW9Dud",
				isOverlayOpen: "_1LKHMvN5rVxTXGRnTa9hrB",
				DropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				dropdownPadding: "_3GVs_x5BtyiLy35GpmGSyo",
				Tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				tooltip: "_2EusAZo7A7uyI8gxC0nJdp",
				TooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				tooltipContent: "_1BsafzE6q8PmCVU5uqiTWj",
				Title: "_1BFO2H2-rybL94nyL7n-e_",
				title: "_1BFO2H2-rybL94nyL7n-e_",
				Description: "_2DnHuFoYoKwYaBvTkLrs0v",
				description: "_2DnHuFoYoKwYaBvTkLrs0v",
				modLink: "_16moQ9CB6asKjB-qTj8Tvf",
				Button: "_2x6OQ6vZfN3PNhM6Eh6FLq",
				button: "_2x6OQ6vZfN3PNhM6Eh6FLq"
			}
		},
		"./src/reddit/components/ModWelcomeTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "MOD_WELCOME_TOOLTIP_ID", (function() {
				return v
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/helpers/toggleBodyScroll/index.ts"),
				b = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				f = n("./src/reddit/selectors/platform.ts"),
				h = n("./src/reddit/components/ModWelcomeTooltip/index.m.less"),
				_ = n.n(h);
			const g = Object(l.a)(m.a),
				v = "ModProgressModule--ModWelcomeTooltip";
			t.default = Object(d.a)(e => {
				const t = Object(i.e)(f.d),
					n = v,
					d = Object(i.d)(),
					l = e => {
						e.stopPropagation(), d(Object(c.h)({
							tooltipId: n
						}))
					};
				return Object(r.useEffect)(() => {
					e.isOpen ? setTimeout(() => Object(p.a)(), 500) : setTimeout(() => Object(p.b)(), 500)
				}, [d, e.isOpen]), t ? o.a.createElement(g, {
					className: _.a.Tooltip,
					isOpen: e.isOpen,
					targetPosition: ["left", "top"],
					tooltipPosition: ["right", "top"],
					tooltipId: n,
					componentWrapper: t => o.a.createElement("div", {
						className: Object(a.a)(_.a.Overlay, {
							[_.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}, o.a.createElement("div", {
						className: Object(a.a)(_.a.DropdownPadding, {
							[_.a.isOverlayOpen]: e.isOpen
						}),
						onClick: l
					}), t)
				}, o.a.createElement("div", {
					className: _.a.TooltipContent
				}, o.a.createElement("div", {
					className: _.a.Title
				}, s.fbt._("Welcome to your community, r/{subredditName}!", [s.fbt._param("subredditName", t)], {
					hk: "e3rbC"
				})), o.a.createElement("div", {
					className: _.a.Description
				}, s.fbt._("We’ll walk you through how to get started here, and you can get more tips and advice through Reddit’s", null, {
					hk: "lffxe"
				}), " ", o.a.createElement("a", {
					className: _.a.modLink,
					style: {
						color: Object(b.a)(e).linkText
					},
					href: "https://www.reddit.com/r/ModCertification101/",
					rel: "noopener noreferrer",
					target: "_blank"
				}, s.fbt._("Mod Certification Program", null, {
					hk: "1FTpvR"
				})), "."), o.a.createElement(u.t, {
					className: _.a.Button,
					onClick: l
				}, s.fbt._("Let's go", null, {
					hk: "4hWwxv"
				})))) : null
			})
		},
		"./src/reddit/components/ModalStyledComponents/MessageBox.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/higherOrderComponents/asModal/index.tsx"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/controls/TextButton/index.tsx"),
				c = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = Object(i.a)(e => {
					let {
						title: t,
						body: n,
						actionText: r = s.fbt._("OK", null, {
							hk: "1eo6HO"
						}),
						onClose: i
					} = e;
					return o.a.createElement(a.e, null, o.a.createElement(a.i, null, o.a.createElement(c.a, null, o.a.createElement(a.q, null, t), o.a.createElement(d.a, {
						onClick: i
					}, o.a.createElement(a.b, null)))), o.a.createElement(a.l, null, o.a.createElement(a.p, null, n)), o.a.createElement(a.g, null, o.a.createElement(a.u, {
						"data-redditstyle": !0,
						onClick: i
					}, r)))
				}),
				m = e => o.a.createElement(u, l({
					withOverlay: !0,
					onOverlayClick: e.onClose
				}, e))
		},
		"./src/reddit/components/ModalStyledComponents/index.m.less": function(e, t, n) {
			e.exports = {
				CloseIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				closeIcon: "_3XSQHPxjCTSWWZh_u-d0Xf",
				ModalBody: "_2R3RlhymCOkPrz9TusvcPq",
				modalBody: "_2R3RlhymCOkPrz9TusvcPq",
				ModalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				modalPostPreview: "HydQQ-TD4TUsVnxkYk_5F",
				ModalText: "mFTHPdbEAklUs8yhT4Xm7",
				modalText: "mFTHPdbEAklUs8yhT4Xm7",
				ModalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				modalSmallText: "_3cwQrg-XvocnoG0U22wT8t",
				ModalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				modalDescriptionText: "_12g_PUGHD-w7T1w4Q3oTsq",
				ModalMetaText: "_27eskYssCs-urVW1uHI4YI",
				modalMetaText: "_27eskYssCs-urVW1uHI4YI",
				ModalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				modalFormItem: "_3xiY8nTCVp16qSb6CGW2Kv",
				ModalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				modalInput: "_20ZSV7ktyDYzPcd1UMQWZT",
				ModalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				modalInputLabel: "HVADn-LHFLaS8r6IBJWeq",
				ModalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				modalFooter: "_-0i7atRJ5NBsrRM5wuPpX",
				ModalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				modalHeader: "_1Fa5Xv7f16v5IC2Tq1m2Fy",
				ModalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				modalTitle: "eLnlHLGCDxjFf3jfGTcZu",
				ModalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				modalMain: "_1uaasV6RaxBfRyVgQJdiKs",
				ModalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				modalAnnotation: "gLlWG7Oj89Ost4_twUu8w",
				TextArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				textArea: "_2h8O7PjrCXfaJJWKrAxJPL",
				WarningButton: "_17UyTSs2atqnKg9dIq5ERg",
				warningButton: "_17UyTSs2atqnKg9dIq5ERg",
				PrimaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				primaryButton: "_2X1FFYUx3jzlnbcegBC_Sr",
				CancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				cancelButton: "_1QUX9-zZuGtifS6jJBUyh-",
				RemoveButton: "_2ulRgczjI5SWCMgSA1CNLj",
				removeButton: "_2ulRgczjI5SWCMgSA1CNLj",
				ConfirmButton: "JZC61-VzVuaiHdWuRUiSC",
				confirmButton: "JZC61-VzVuaiHdWuRUiSC"
			}
		},
		"./src/reddit/components/ModalStyledComponents/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "o", (function() {
				return _
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "m", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "g", (function() {
				return y
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "q", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "l", (function() {
				return I
			})), n.d(t, "t", (function() {
				return S
			})), n.d(t, "u", (function() {
				return w
			})), n.d(t, "r", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "c", (function() {
				return R
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/lib/lessComponent.tsx"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/controls/Input/ModalInput.tsx"),
				c = n("./src/reddit/icons/svgs/Close/index.tsx"),
				l = n("./src/reddit/components/ModalStyledComponents/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.wrapped(c.a, "CloseIcon", u.a),
				b = r.a.section("ModalBody", u.a),
				f = r.a.section("ModalPostPreview", u.a),
				h = r.a.p("ModalText", u.a),
				_ = r.a.div("ModalSmallText", u.a),
				g = r.a.div("ModalDescriptionText", u.a),
				v = r.a.div("ModalMetaText", u.a),
				x = r.a.label("ModalFormItem", u.a),
				O = r.a.wrapped(d.a, "ModalInput", u.a),
				E = r.a.label("ModalInputLabel", u.a),
				y = r.a.footer("ModalFooter", u.a),
				C = r.a.header("ModalHeader", u.a),
				j = r.a.div("ModalTitle", u.a),
				k = r.a.div("ModalAnnotation", u.a),
				I = r.a.div("ModalMain", u.a),
				S = r.a.textarea("TextArea", u.a),
				w = r.a.wrapped(a.l, "WarningButton", u.a),
				T = r.a.wrapped(a.l, "PrimaryButton", u.a),
				N = r.a.wrapped(a.o, "CancelButton", u.a),
				P = r.a.wrapped(a.r, "RemoveButton", u.a),
				R = e => {
					let {
						className: t,
						...n
					} = e;
					return i.a.createElement(a.t, m({
						kind: a.b.Button,
						priority: a.c.Primary,
						className: Object(s.a)(u.a.ConfirmButton, t)
					}, n))
				}
		},
		"./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_3aaWXDPwVg-rhD0DvWeyIg",
				titleFontH2: "_3RrF8F_t0SfGrUYfrMwbPy",
				titleFontH3: "_36oA-I2A9k4cBPYs3kAlux",
				titleFontH4: "_1neT2k10waDvSZYxkd9bk8",
				titleFontH5: "_3oeJNjYGx_aLE6l4o6Jhcr",
				titleFontH6: "_2CsvILRAMCNlhcGlq7eAZF",
				metadataFont: "_2odnjtlqO4r8tdO5H9fwLW",
				flairFont: "k5rlVaQw1fQ4nW2C-cK8H",
				labelsFont: "_20rPk9VJ1JfA7IuzEuFf25",
				actionFont: "_1YoZx3mOGBx4yxG_aQD3dq",
				smallButtonFont: "_3eWaIQ1VVjPR_5vUm4bU74",
				largeButtonFont: "rBsu7j_nL4EsDsP9nsEx4",
				strongTextFont: "_1efJllSuh9p67WrocQmmWR",
				tabFont: "_3WOHej9q3BPonP3nmtGWrh",
				buttonFontXS: "_1MX_r3WunmJuovmTcVFbK2",
				buttonFontXs: "_1MX_r3WunmJuovmTcVFbK2",
				buttonFontS: "_2KcOk-_dCdoa6LYzk-AP_9",
				buttonFontM: "BRJSsisfnzhNDIzzkZ0iD",
				buttonFontL: "WtDuFUG7c1VkpSlmXgZux",
				buttonFontXL: "_1K99pLAcTgTp5K71-CnCYk",
				buttonFontXl: "_1K99pLAcTgTp5K71-CnCYk",
				bodyFontH1: "_1m_v2MMDlDugLUDKRkPnPP",
				bodyFontH2: "uhtqruCImDdb6YMrply29",
				bodyFontH3: "oI7G9eYumAFmPy69WN078",
				bodyFontH4: "_3NN_fRjCSJGnly_ejXsz8m",
				bodyFontH5: "_1lK4S52h6Glz4-OysTx6SF",
				bodyFontH6: "BarCcSBvd2WaM4vhBY1_R",
				bodyFontH6Small: "BxuTxX9RmChqU7mme4ODG",
				bodyFont: "RIX67Ch_ZE4SYGnQlkPWs",
				bodyFontSmall: "_1_FK7Ynr3eStBK-2Nbutbg",
				bodyFontMono: "_1mpZy47SxXNRDTLTEdCUmV",
				landingPageTitleFontH1: "_2bYZhT8GFbSZieY-2ekdD-",
				landingPageTitleFontH2: "_2d4nMz6ecjt1MaRJreXgyY",
				landingPageTitleFontH3: "u3DBhvM6h8Z1aDifxelv6",
				dropdownRow: "_3p4amLmnNdNRS9NcI_TnQm",
				filter: "_1LUEYTVtU-JweRiTGrVNn6",
				container: "_1GH53do8Ql17wdDC_i_NDf",
				containerText: "KiwwtIazAS77Aa_w3AdBE",
				listContainer: "FyBjuKMom1xYgTT7w5Dg1",
				selector: "_3fe64brTItATv48WIPt-Af"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "a0XACZdyt4BIb8ijZeyYs",
				thumbnail: "_3Gr4zaxYVxnSJsswDS3DrH",
				blur: "_30-TA_nC39RinVaoLGAM80"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less": function(e, t, n) {
			e.exports = {
				body: "_12PFG6h73jYoYE1nkFmj7W",
				bodyExpanded: "_2rmMZ9SgqIsu5N4npqtHGO",
				seeMore: "_26bn7M6DKZgOME8sYRiK6_"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less": function(e, t, n) {
			e.exports = {
				noPreview: "yTkGz6Kz44pP8NXnyVDNL"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/helpers.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.m.less"),
				l = n.n(c);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js"), m = e => {
				let {
					action: t,
					className: n,
					showTakedownPreview: s,
					toggleShowTakedownPreview: c
				} = e;
				return Object(i.e)(t) ? r.a.createElement(a.t, {
					className: n,
					Icon: Object(d.b)(s ? "caret_up" : "caret_down"),
					iconPosition: a.h.R,
					priority: a.c.PlainLink,
					onClick: c,
					"aria-expanded": s,
					"aria-controls": Object(i.c)(t)
				}, s ? u._("Hide details", null, {
					hk: "4295ML"
				}) : u._("Show details", null, {
					hk: "4d94Js"
				})) : r.a.createElement("span", {
					className: Object(o.a)(n, l.a.noPreview)
				}, u._("Details removed", null, {
					hk: "25LG4u"
				}))
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less": function(e, t, n) {
			e.exports = {
				previewInfo: "sSchFsTKqgMqRa_PNJb4a",
				previewInfoItem: "_1lSOacsboVGtIvlrcO3-W1"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/graphql/helpers.ts"),
				r = n("./src/reddit/models/Comment/index.ts"),
				o = n("./src/reddit/models/FeedElement/index.ts"),
				i = n("./src/reddit/models/User/index.ts");
			const a = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === i.c.AvailableRedditor ? t.name : null
				},
				d = e => `${e.id}-takedown-content-preview`,
				c = e => {
					var t, n;
					return !!((null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.title) || (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.body))
				},
				l = e => {
					var t;
					return null === (t = e.takedownContentPreview) || void 0 === t ? void 0 : t.violatedContentPolicyRule
				},
				u = e => !!l(e),
				m = e => {
					const {
						target: t,
						takedownContentPreview: n
					} = e;
					if (!t || !n) return null;
					const {
						title: i,
						body: d,
						thumbnail: c,
						violatedContentPolicyRule: l
					} = n;
					if ((e => e.__typename === o.a.SubredditPost)(t)) {
						const e = t,
							{
								score: n,
								commentCount: r,
								createdAt: o
							} = e;
						return {
							title: i,
							body: d,
							thumbnail: c,
							violatedContentPolicyRule: l,
							score: n,
							commentCount: r,
							author: a(e),
							createdAt: Object(s.g)(o)
						}
					}
					if ((e => e.__typename === r.d.Comment)(t)) {
						const e = t,
							{
								score: n,
								createdAt: r,
								postInfo: o
							} = e;
						return {
							title: null == o ? void 0 : o.title,
							body: d,
							parent: {
								score: null == o ? void 0 : o.score,
								commentCount: null == o ? void 0 : o.commentCount,
								createdAt: (null == o ? void 0 : o.createdAt) ? Object(s.g)(null == o ? void 0 : o.createdAt) : null
							},
							score: n,
							author: a(e),
							createdAt: Object(s.g)(r)
						}
					}
					return null
				}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_3HBJtoQ8F-vJNqmtmc9gol",
				contentWrapperComment: "_3_Nih9SNk9GvWVAs0sn5FM",
				title: "_12exdWB71qX-NBs6EzOu9s",
				authorLink: "_6znEPG6Fc4vtLPviu5sZi"
			}
		},
		"./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1o6EpuTR_pbdKk4biOJFOD",
				titleFontH2: "_2scGKAM0oQo5UQ0sAeTYcJ",
				titleFontH3: "nZ8gtQ7wSBH1Ei4U88QyH",
				titleFontH4: "cWWmG8ptxDy68exgcmkxK",
				titleFontH5: "_2ltEgDFK7lEC55mqYn2t1k",
				titleFontH6: "_1wRduyAnZyUXSUvy0rPJ7E",
				metadataFont: "_3iKB3xohr95CjhTE-YrXL4",
				flairFont: "_2tIFOrubLwHvQfSpZ7MBvr",
				labelsFont: "_1Qc6zGFV60DgXsfeg4iK1-",
				actionFont: "bD7YA5ocXtmwPNG0x7gqi",
				smallButtonFont: "wa3Y6CP3s2WY-9hiMRcK6",
				largeButtonFont: "_1Td1TQRNZA20xRbI-LLHsA",
				strongTextFont: "_2bBsKMYboYeah9nlKp4p8e",
				tabFont: "_3Bdl5CdTghtfz5X9Qkn7y0",
				buttonFontXS: "_2hkAgq5O_JUGmz41U0fhSZ",
				buttonFontXs: "_2hkAgq5O_JUGmz41U0fhSZ",
				buttonFontS: "zi9zhcyy9sg1XQb4uP15B",
				buttonFontM: "_2V_SS1DAOgvZNAM9mW40qn",
				buttonFontL: "_3yj5sHGC15tSX0YBraNh9S",
				buttonFontXL: "_2rPaWVGnRh6kEv7M1PJXWa",
				buttonFontXl: "_2rPaWVGnRh6kEv7M1PJXWa",
				bodyFontH1: "_2b6RUiVz7aEMUoaiEalXki",
				bodyFontH2: "_1gD38a1FX6kmxcFvUyP8bB",
				bodyFontH3: "_20D34o21pcOy-JSvp0fq42",
				bodyFontH4: "_368KGbv676rMnmb_kPY7-A",
				bodyFontH5: "_2o6Gp_6yxl-T5p9MHsV3hI",
				bodyFontH6: "_2jp4S3tPdfLXU3FVoOvCWi",
				bodyFontH6Small: "_1OIs3KOCi4nPYoXgyoYWwD",
				bodyFont: "O3aukKYU-BhYFQQgCIAcN",
				bodyFontSmall: "_10AKt1uw6lDYoTkaQ2Egu-",
				bodyFontMono: "_3tQKpxkireZBsmkNyZ5-0J",
				landingPageTitleFontH1: "_1qGvirZftsEc5Wp3FvMYaU",
				landingPageTitleFontH2: "_17GWP90LLtRlYkZK0NE2MP",
				landingPageTitleFontH3: "_2kMDekl0Ct9vDzjTgetMNQ",
				row: "_3sZTiywtJTK5dskqy0h2G2",
				modNameCell: "_1hV1AUW4J0YvMuEK7-Ph1H",
				usernameLink: "_25VIbQ9CpcAT2Uys4A2mFb",
				actionLink: "_2yXBXFFI2XxJRqd89Zwd25",
				createdAtTooltip: "zMBbz2oHRB9_15CBkQ3P4",
				container: "_3jmSP5NpjJgNS7rO9dBogO",
				detailsContainer: "_3pusa5HaB8VO3ODi63vjLl",
				detailsContent: "piNOo-es-o0F7rcLiUu0N",
				detailsType: "_3P62Ird8EqkkVbqN0bv1tU",
				icon: "VzgXNIgPGoNVtsv9-uwYE",
				iconWrapper: "_3cDZ1nhaOv-edC1Ixznjgd",
				negativeTreatment: "XqM6DP9JAGpvwgodvCcuI",
				positiveTreatment: "Ob5o1Q3oVSaizQinm6DD",
				tooltip: "_33OjvBwqb5PPwalXFSmAoy",
				takedownContentPreviewCell: "_1KwIUVKOHu_rA2x5r1tUU5",
				takedownContentPreviewWrapper: "_2poUGYxpTc65DM1BGLyGcf"
			}
		},
		"./src/reddit/components/ModerationLog/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_2OYuAlGNOY6MlJjEC6nWEY",
				titleFontH2: "_2cz1b71RqIGBP0q1sEpoc1",
				titleFontH3: "pNuW5Xi4qPFjDgkhE2utU",
				titleFontH4: "HnjsgzUiJm7Rz4yf-QTnU",
				titleFontH5: "_32jYSRMv-UqDvlwAZ9yI4P",
				titleFontH6: "WyhSydN2c9D7w_ikI_LsS",
				metadataFont: "klmtj4Euuox2ljWXOzJqz",
				flairFont: "_1XFZbbYMt1bMVk_65YaTug",
				labelsFont: "_2lbFHk9fPHfy-Pj2cQ56ef",
				actionFont: "_250q84vRQ0qeydB79AJun",
				smallButtonFont: "_3QKadDpX2GixU1usvLUiww",
				largeButtonFont: "_24SnRKi2v2z3Q8DfWx8Cfd",
				strongTextFont: "_1bRU6ybRMZMA-zL-dR_BFc",
				tabFont: "_1y1SLpqv4ViOdLE8d7R03R",
				buttonFontXS: "_3WZjqmvG0dFKc8UjITKDDM",
				buttonFontXs: "_3WZjqmvG0dFKc8UjITKDDM",
				buttonFontS: "_2wD06G9nLrctZ6G6-fnvzn",
				buttonFontM: "f89wHQzBr1xXirRhM2r3L",
				buttonFontL: "_2B8vK6cxvYeJYneLcXU7pS",
				buttonFontXL: "_2wEcZ9dZ6skPqfnohnMjY8",
				buttonFontXl: "_2wEcZ9dZ6skPqfnohnMjY8",
				bodyFontH1: "_2qrAJcHH1W18XK6K_iZjmY",
				bodyFontH2: "_2yInLfhO3hB7n5aflEa_Y5",
				bodyFontH3: "_31VlGQEcOO_KNq8afFO4lZ",
				bodyFontH4: "_13MU9oPUeX9-FTZJw6fEdd",
				bodyFontH5: "_3h1ag_p5AVxzseMoTk9Oee",
				bodyFontH6: "_2GA-IlakdRmzOgQVFN2Q_F",
				bodyFontH6Small: "_19LZGpX04-M-lUtj-duZpb",
				bodyFont: "_3W9ZZjex4uhC0x4j0tXUE8",
				bodyFontSmall: "_2wYhe0C_P9ON8nur1uwzBd",
				bodyFontMono: "Ygu6NDZ2VS1jqJxKuuJ67",
				landingPageTitleFontH1: "_3iIZwmSNUg9eH122bwtWN0",
				landingPageTitleFontH2: "_3j9RuWLkk-AHPx0aTMk7DL",
				landingPageTitleFontH3: "Ytq1i9H9vHAiA8Iig1sGM",
				contentContainer: "PLQrC-Lzmu2AHBmciLxW5",
				table: "_27_l-nXesULxjvqLhpd6Ie",
				actionNameColHeader: "_3pOXEjq1uyvW71Pp3gS7yv",
				hiddenContentPreviewColumn: "QUUF5WYqgf5deYjxoorkx",
				icon: "_2iiHYO0HlG5gGeXyf7S3_q",
				iconContainer: "_3leJW5B-x65UTDfhDAblD_",
				title: "_2pFg2GOWUWlkKFlSaV-iFq",
				tooltip: "jkeAqS2MNV7nCHZkp4vi9",
				actionTooltip: "p12QqrsFSXUXQXCVTreZ5",
				actionTooltipDescription: "_2SZhKngNXxQ-MnrDr17Fm-",
				allIconsContainer: "_2zekEhqxlIqb4STkFCskIT",
				detailTooltip: "_20tDXbrpUnXW12ZXmRZdKa",
				bottomBarRow: "_28pYv3DHnyqXo6lJwzAOcG"
			}
		},
		"./src/reddit/components/ModerationLog/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/actions/moderationLog/allModerators.ts"),
				l = n("./node_modules/react-router-redux/es/index.js"),
				u = n("./src/higherOrderComponents/asTooltip.tsx"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/constants/keycodes.ts")),
				b = n("./src/reddit/constants/moderationLog.ts"),
				f = n("./src/reddit/controls/InternalLink/index.tsx"),
				h = n("./src/lib/addQueryParams/index.ts"),
				_ = n("./src/lib/stripQueryParams/index.ts");
			const g = e => {
				const t = e.action && "ALL_ACTIONS" !== e.action ? e.action : null,
					n = e.moderator || null,
					s = e.endCursor || null,
					r = e.startCursor || null;
				return Object(h.a)(Object(_.a)(e.currentPageUrl), {
					action: t,
					moderator: n,
					after: s,
					before: r
				})
			};
			var v = n("./src/reddit/helpers/trackers/modLog.ts"),
				x = n("./src/reddit/components/ModerationLog/FilterByDropdowns/index.m.less"),
				O = n.n(x);
			class E extends i.a.Component {
				constructor(e) {
					super(e), this.buildModLogUrlForAction = e => {
						const {
							currentPageUrl: t,
							moderator: n
						} = this.props;
						return g({
							currentPageUrl: t,
							moderator: n,
							action: e
						})
					}, this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							n = this.getFilteredActions(t);
						this.setState({
							currentInputText: t,
							filteredActions: n
						})
					}, this.onKeyDown = e => {
						if (e.which === p.a.Enter) {
							const {
								filteredActions: t
							} = this.state, n = t.length ? this.buildModLogUrlForAction(t[0]) : null;
							n && (this.props.onChangeUrl(n), e.preventDefault())
						}
					}, this.onActionClick = e => {
						this.props.sendEvent(Object(v.b)(e))
					}, this.state = {
						currentInputText: "",
						filteredActions: this.getFilteredActions("")
					}
				}
				getFilteredActions(e) {
					let t = Object.keys(b.b);
					if (e) {
						const n = e.toLowerCase();
						t = t.filter(e => b.b[e]().toString().toLowerCase().includes(n))
					}
					return t
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredActions: t
					} = this.state;
					return i.a.createElement("div", {
						role: "menu",
						className: e
					}, i.a.createElement("input", {
						"aria-label": r.fbt._("Filter", null, {
							hk: "UqHZD"
						}),
						className: O.a.filter,
						placeholder: r.fbt._("Filter", null, {
							hk: "3sxP3l"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map(e => i.a.createElement(f.default, {
						key: e,
						className: O.a.dropdownRow,
						onClick: () => this.onActionClick(e),
						to: this.buildModLogUrlForAction(e)
					}, b.b[e]())))
				}
			}
			var y = E,
				C = n("./src/lib/constants/index.ts"),
				j = n("./src/reddit/selectors/moderationLog.ts");
			const k = e => {
					let {
						name: t,
						urlPath: n
					} = e;
					return i.a.createElement(f.default, {
						className: O.a.dropdownRow,
						to: n
					}, t)
				},
				I = "a",
				S = Object(d.c)({
					allModerators: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(j.a)(e, n)
					}
				});
			class w extends i.a.Component {
				constructor(e) {
					super(e), this.onChangeFilterText = e => {
						const t = e.currentTarget.value,
							n = this.getList(t);
						this.setState({
							currentInputText: t,
							filteredList: n
						})
					}, this.onKeyDown = e => {
						if (e.which === p.a.Enter) {
							const {
								filteredList: t
							} = this.state, n = t.length ? t[0].url : "";
							n && (this.props.onChangeUrl(n), e.preventDefault())
						}
					}, this.onDropdownClick = e => {
						e.target instanceof HTMLAnchorElement && this.props.sendEvent(Object(v.g)())
					}, this.state = {
						currentInputText: "",
						filteredList: this.getList("")
					}
				}
				getList(e) {
					const {
						action: t,
						currentPageUrl: n
					} = this.props, s = e => g({
						currentPageUrl: n,
						action: t,
						moderator: e
					}), o = [{
						url: s(""),
						displayText: `${r.fbt._("All Moderators",null,{hk:"3vmWA8"})}`
					}, {
						url: s(I),
						displayText: `${r.fbt._("Admins",null,{hk:"4mKRNI"})}`
					}, {
						url: s(C.m),
						displayText: `${r.fbt._("AutoModerator",null,{hk:"4wxc1W"})}`
					}, ...this.props.allModerators.map(e => ({
						url: s(e.name),
						displayText: e.name
					}))];
					if (e) {
						const t = e.toLowerCase();
						return o.filter(e => e.displayText.toLowerCase().includes(t))
					}
					return o
				}
				render() {
					const {
						className: e
					} = this.props, {
						filteredList: t
					} = this.state;
					return i.a.createElement("div", {
						role: "menu",
						className: e,
						onClick: this.onDropdownClick
					}, i.a.createElement("input", {
						"aria-label": r.fbt._("Filter", null, {
							hk: "1qnOD5"
						}),
						className: O.a.filter,
						placeholder: r.fbt._("Filter", null, {
							hk: "1sWvOA"
						}),
						onChange: this.onChangeFilterText,
						onKeyDown: this.onKeyDown
					}), t.map((e, t) => i.a.createElement(k, {
						key: t,
						name: e.displayText,
						urlPath: e.url
					})))
				}
			}
			var T = Object(a.b)(S)(w),
				N = n("./src/reddit/components/TrackingHelper/index.tsx"),
				P = n("./src/reddit/controls/Dropdown/index.tsx"),
				R = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				A = n("./src/reddit/selectors/tooltip.ts");
			const M = "mod-log-action-filter-dropdown",
				L = "mod-log-moderator-filter-dropdown",
				D = Object(u.a)(P.a),
				F = Object(d.c)({
					isActionFilterDropdownOpen: Object(A.b)(M),
					isModeratorFilterDropdownOpen: Object(A.b)(L)
				});
			class U extends i.a.Component {
				constructor() {
					super(...arguments), this.getContainerText = e => {
						const {
							action: t,
							moderator: n
						} = this.props;
						if (e === b.a.MODERATOR) {
							let e = n;
							return n === I && (e = r.fbt._("Admins", null, {
								hk: "1qJDMA"
							})), e || r.fbt._("All Moderators", null, {
								hk: "18DhaK"
							})
						}
						if (e === b.a.ACTION) {
							return t && b.b[t] && b.b[t]() || r.fbt._("Actions", null, {
								hk: "1s4OJD"
							})
						}
					}, this.openModFilterDropdown = () => {
						this.props.onOpenDropdown(L), this.props.sendEvent(Object(v.f)())
					}, this.openActionFilterDropdown = () => {
						this.props.onOpenDropdown(M), this.props.sendEvent(Object(v.a)())
					}
				}
				stopPropagation(e) {
					e.nativeEvent.stopImmediatePropagation()
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						isActionFilterDropdownOpen: n,
						isModeratorFilterDropdownOpen: s,
						moderator: o,
						subredditId: a
					} = this.props;
					return i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
						className: O.a.container,
						onClickCapture: this.stopPropagation
					}, i.a.createElement("button", {
						"aria-expanded": s,
						"aria-label": r.fbt._("Start typing to filter moderators or use up and down to select.", null, {
							hk: "4ff0MW"
						}),
						className: O.a.selector,
						id: L,
						onClick: this.openModFilterDropdown,
						role: "navigation"
					}, i.a.createElement("span", {
						className: O.a.containerText
					}, this.getContainerText(b.a.MODERATOR)), i.a.createElement(R.a, null)), i.a.createElement(D, {
						tooltipId: L,
						isOpen: s
					}, i.a.createElement(T, {
						action: e,
						className: O.a.listContainer,
						currentPageUrl: t,
						moderator: o,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent,
						subredditId: a
					}))), i.a.createElement("div", {
						className: O.a.container,
						onClickCapture: this.stopPropagation
					}, i.a.createElement("button", {
						"aria-expanded": n,
						"aria-label": r.fbt._("Start typing to filter the mod actions or use up and down to select.", null, {
							hk: "32A4KB"
						}),
						className: O.a.selector,
						id: M,
						onClick: this.openActionFilterDropdown,
						role: "navigation"
					}, i.a.createElement("span", {
						className: O.a.containerText
					}, this.getContainerText(b.a.ACTION)), i.a.createElement(R.a, null)), i.a.createElement(D, {
						tooltipId: M,
						isOpen: n
					}, i.a.createElement(y, {
						action: e,
						className: O.a.listContainer,
						currentPageUrl: t,
						moderator: o,
						onChangeUrl: this.props.pushUrl,
						sendEvent: this.props.sendEvent
					}))))
				}
			}
			var B = Object(a.b)(F, e => ({
					onOpenDropdown: t => e(Object(m.h)({
						tooltipId: t
					})),
					pushUrl: t => e(Object(l.b)(t))
				}))(Object(N.c)(U)),
				q = n("./src/reddit/components/AuthorLink/index.tsx"),
				G = n("./src/reddit/components/HumanDate/index.tsx"),
				H = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				W = n("./src/reddit/controls/InvisibleScreenReaderText/index.tsx"),
				V = n("./src/reddit/models/User/index.ts"),
				z = (n("./src/lib/assertNever.ts"), n("./src/lib/sentry/index.ts"));
			var K = n("./src/reddit/icons/fonts/index.tsx"),
				Q = n("./src/reddit/icons/fonts/Comment/index.tsx"),
				Y = n("./src/reddit/icons/svgs/Collection/index.tsx"),
				J = n("./src/reddit/icons/svgs/Event/index.tsx"),
				X = n("./src/reddit/icons/svgs/Gild/index.tsx"),
				Z = n("./src/reddit/icons/svgs/ModLogPosts/index.tsx"),
				$ = n("./src/reddit/icons/svgs/Negative/index.tsx"),
				ee = n("./src/reddit/icons/svgs/Positive/index.tsx"),
				te = n("./src/reddit/icons/svgs/Redditor/index.tsx"),
				ne = n("./src/reddit/icons/svgs/Settings/index.tsx"),
				se = n("./src/reddit/icons/svgs/Tag/index.tsx"),
				re = n("./src/reddit/icons/svgs/Wiki/index.tsx"),
				oe = n("./src/reddit/models/Comment/index.ts"),
				ie = n("./src/reddit/models/FeedElement/index.ts"),
				ae = n("./src/reddit/components/ModerationLog/ModerationLogItem/index.m.less"),
				de = n.n(ae);
			const ce = e => {
				let {
					action: t,
					urlPath: n
				} = e;
				const s = (e => {
						switch (e) {
							case "ALL_ACTIONS":
								return;
							case "ADD_CONTRIBUTOR":
							case "ADD_MODERATOR":
								return {
									type: b.h.REDDITOR, treatment: b.m.POSITIVE
								};
							case "BAN_USER":
							case "MUTE_USER":
							case "REMOVE_CONTRIBUTOR":
							case "REMOVE_MODERATOR":
								return {
									type: b.h.REDDITOR, treatment: b.m.NEGATIVE
								};
							case "CREATE_AWARD":
							case "MOD_AWARD_GIVEN":
								return {
									type: b.h.AWARD, treatment: b.m.POSITIVE
								};
							case "DELETE_AWARD":
							case "DISABLE_AWARD":
							case "ENABLE_AWARD":
							case "HIDDEN_AWARD":
								return {
									type: b.h.AWARD, treatment: b.m.NEGATIVE
								};
							case "ACCEPT_MODERATOR_INVITE":
							case "INVITE_MODERATOR":
							case "INVITE_SUBSCRIBER":
							case "SET_PERMISSIONS":
							case "UNBAN_USER":
							case "UNINVITE_MODERATOR":
							case "UNMUTE_USER":
								return {
									type: b.h.REDDITOR, treatment: b.m.NONE
								};
							case "APPROVE_COMMENT":
							case "SHOW_COMMENT":
								return {
									type: b.h.COMMENT, treatment: b.m.POSITIVE
								};
							case "REMOVE_COMMENT":
							case "SPAM_COMMENT":
								return {
									type: b.h.COMMENT, treatment: b.m.NEGATIVE
								};
							case "EDIT_FLAIR":
								return {
									type: b.h.FLAIR, treatment: b.m.NONE
								};
							case "APPROVE_LINK":
								return {
									type: b.h.POST, treatment: b.m.POSITIVE
								};
							case "REMOVE_LINK":
							case "SPAM_LINK":
							case "ADD_REMOVAL_REASON":
								return {
									type: b.h.POST, treatment: b.m.NEGATIVE
								};
							case "LOCK":
							case "MARK_NSFW":
							case "MARK_ORIGINAL_CONTENT":
							case "SET_CONTEST_MODE":
							case "SET_SUGGESTEDSORT":
							case "SPOILER":
							case "UNLOCK":
							case "UNSET_CONTEST_MODE":
							case "UNSPOILER":
								return {
									type: b.h.POST, treatment: b.m.NONE
								};
							case "DISTINGUISH":
							case "IGNORE_REPORTS":
							case "SNOOZE_REPORTS":
							case "STICKY":
							case "UNIGNORE_REPORTS":
							case "UNSNOOZE_REPORTS":
							case "UNSTICKY":
								return {
									type: b.h.MULTIPLE, treatment: b.m.NONE
								};
							case "ADD_COMMUNITY_TOPICS":
							case "ADJUST_POST_CROWD_CONTROL_LEVEL":
							case "ENABLE_POST_CROWD_CONTROL_FILTER":
							case "DISABLE_POST_CROWD_CONTROL_FILTER":
							case "REMOVE_COMMUNITY_TOPICS":
							case "COMMUNITY_STYLING":
							case "COMMUNITY_WIDGETS":
							case "CREATE_RULE":
							case "DELETE_RULE":
							case "EDIT_POST_REQUIREMENTS":
							case "EDIT_RULE":
							case "REORDER_RULES":
							case "REORDER_MODERATORS":
							case "EDIT_SETTINGS":
							case "MODMAIL_ENROLLMENT":
							case "SUBMIT_CONTENT_RATING_SURVEY":
							case "DELETE_OVERRIDDEN_CLASSIFICATION":
							case "OVERRIDE_CLASSIFICATION":
							case "CREATE_REMOVAL_REASON":
							case "DELETE_REMOVAL_REASON":
							case "UPDATE_REMOVAL_REASON":
								return {
									type: b.h.SETTINGS, treatment: b.m.NONE
								};
							case "REMOVE_WIKI_CONTRIBUTOR":
							case "WIKI_BANNED":
								return {
									type: b.h.WIKI, treatment: b.m.NEGATIVE
								};
							case "WIKI_CONTRIBUTOR":
							case "WIKI_PAGE_LISTED":
							case "WIKI_PERM_LEVEL":
							case "WIKI_REVISE":
							case "WIKI_UNBANNED":
								return {
									type: b.h.WIKI, treatment: b.m.NONE
								};
							case "COLLECTIONS":
								return {
									type: b.h.COLLECTION, treatment: b.m.NONE
								};
							case "EVENTS":
								return {
									type: b.h.EVENT, treatment: b.m.NONE
								};
							case "CREATE_SCHEDULED_POST":
							case "EDIT_SCHEDULED_POST":
							case "DELETE_SCHEDULED_POST":
							case "SUBMIT_SCHEDULED_POST":
								return {
									type: b.h.POST, treatment: b.m.NONE
								};
							case "ADD_NOTE":
								return {
									type: b.h.NOTE, treatment: b.m.POSITIVE
								};
							case "DELETE_NOTE":
								return {
									type: b.h.NOTE, treatment: b.m.NEGATIVE
								};
							default:
								return void z.c.captureMessage(`Unknown mod action "${e}"`)
						}
					})(t.action),
					r = t.target && t.target.__typename,
					o = r === oe.d.Comment || oe.d.DeletedComment;
				let a;
				switch (s && s.type) {
					case b.h.AWARD:
						a = i.a.createElement(X.a, {
							className: de.a.icon
						});
						break;
					case b.h.COMMENT:
						a = i.a.createElement(Q.a, null);
						break;
					case b.h.FLAIR:
						a = i.a.createElement(se.a, {
							className: de.a.icon
						});
						break;
					case b.h.POST:
						a = i.a.createElement(Z.a, {
							className: de.a.icon
						});
						break;
					case b.h.REDDITOR:
						a = i.a.createElement(te.a, {
							className: de.a.icon
						});
						break;
					case b.h.SETTINGS:
						a = i.a.createElement(ne.a, {
							className: de.a.icon
						});
						break;
					case b.h.WIKI:
						a = i.a.createElement(re.a, {
							className: de.a.icon
						});
						break;
					case b.h.COLLECTION:
						a = i.a.createElement(Y.a, {
							className: de.a.icon
						});
						break;
					case b.h.EVENT:
						a = i.a.createElement(J.a, {
							className: de.a.icon
						});
						break;
					case b.h.MULTIPLE:
						o && (a = i.a.createElement(Q.a, null)), r === ie.a.SubredditPost && (a = i.a.createElement(Z.a, {
							className: de.a.icon
						}));
						break;
					case b.h.NOTE:
						const e = Object(K.b)("user_note");
						a = i.a.createElement(e, {
							className: de.a.icon,
							style: {
								fontSize: "16px"
							}
						})
				}
				const d = b.b[t.action];
				return i.a.createElement(f.default, {
					className: de.a.actionLink,
					to: n
				}, i.a.createElement("span", {
					className: de.a.iconWrapper
				}, a, s && s.treatment === b.m.POSITIVE ? i.a.createElement(ee.a, {
					className: de.a.positiveTreatment
				}) : s && s.treatment === b.m.NEGATIVE ? i.a.createElement($.a, {
					className: de.a.negativeTreatment
				}) : null), d && d())
			};
			var le = n("./node_modules/lodash/noop.js"),
				ue = n.n(le),
				me = n("./src/reddit/components/Hovercards/AuthorHovercard/UserHovercard.tsx"),
				pe = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewExpandButton.tsx"),
				be = n("./src/redditGQL/types.ts"),
				fe = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/helpers.ts");
			const he = e => {
					let {
						authorInfo: t
					} = e;
					return t && t.__typename === V.c.AvailableRedditor && t.name || null
				},
				_e = e => {
					let {
						action: t,
						showTakedownPreview: n,
						toggleShowTakedownPreview: s
					} = e;
					const r = Object(N.b)(),
						{
							authorUsername: o,
							content: a,
							urlPath: d
						} = (e => {
							var t, n, s;
							const r = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
							let o = e.target;
							switch (r) {
								case ie.a.SubredditPost:
									return {
										authorUsername: he(o = o), content: (null === (n = e.takedownContentPreview) || void 0 === n ? void 0 : n.title) || o.title, urlPath: o.permalink
									};
								case ie.a.DeletedSubredditPost:
									return {
										authorUsername: null, content: (o = o).title, urlPath: o.permalink
									};
								case V.c.AvailableRedditor:
									return {
										authorUsername: (o = o) && o.name || null, content: null, urlPath: void 0
									};
								case oe.d.Comment:
									return {
										authorUsername: he(o = o), content: (null === (s = e.takedownContentPreview) || void 0 === s ? void 0 : s.body) || o.content && o.content.markdown, urlPath: o.permalink
									};
								case oe.d.DeletedComment:
									return {
										authorUsername: null, content: (o = o).postInfo && o.postInfo.title, urlPath: o.postInfo && o.postInfo.permalink
									};
								default:
									return {
										authorUsername: null, content: null, urlPath: void 0
									}
							}
						})(t),
						{
							text: c,
							url: l
						} = (e => {
							var t;
							const {
								actionNotes: n,
								details: s,
								takedownContentPreview: r
							} = e;
							if (null == r ? void 0 : r.violatedContentPolicyRule) return {
								text: b.l[r.violatedContentPolicyRule](),
								url: r.violatedContentPolicyRule === be.h.Dmca ? b.j : b.i
							};
							const o = (null === (t = b.g[s]) || void 0 === t ? void 0 : t.call(b.g)) || s;
							return n ? o ? {
								text: `${o}: ${e.actionNotes}`
							} : {
								text: n
							} : {
								text: o
							}
						})(t),
						u = (e => {
							var t;
							const n = Object(fe.d)(e) || void 0,
								s = null === (t = e.target) || void 0 === t ? void 0 : t.__typename;
							let r = e.target;
							switch (s) {
								case ie.a.SubredditPost:
								case ie.a.DeletedSubredditPost:
									return {
										post: {
											id: (r = r).id
										}, comment: void 0, violatedContentPolicyRule: n
									};
								case oe.d.Comment:
								case oe.d.DeletedComment:
									return {
										post: void 0, comment: {
											id: (r = r).id
										}, violatedContentPolicyRule: n
									};
								default:
									return {
										post: void 0, comment: void 0, violatedContentPolicyRule: n
									}
							}
						})(t),
						m = Object(fe.a)(t);
					return i.a.createElement("div", {
						className: de.a.container
					}, i.a.createElement("div", {
						className: de.a.detailsContainer
					}, o && !b.k.includes(o) ? i.a.createElement(me.a, {
						tooltipId: `userlink-${t.id}`,
						user: o,
						sendHoverCardEvent: ue.a
					}, i.a.createElement(q.a, {
						className: de.a.usernameLink,
						author: o,
						onClick: () => r(Object(v.k)(u))
					}, `u/${o}`)) : o, a && d && i.a.createElement("a", {
						className: de.a.detailsContent,
						target: "_blank",
						rel: "noopener noreferrer",
						href: d,
						onClick: () => r(Object(v.l)(u))
					}, a), c && i.a.createElement("span", {
						className: de.a.detailsType
					}, "(", l ? i.a.createElement("a", {
						href: l,
						target: "_blank",
						rel: "noopener noreferrer",
						onClick: () => r(Object(v.i)(u))
					}, c) : c, ")")), m && i.a.createElement(pe.a, {
						action: t,
						showTakedownPreview: n,
						toggleShowTakedownPreview: () => {
							s(), n || r(Object(v.j)(u))
						}
					}))
				};
			var ge = n("./src/lib/classNames/index.ts"),
				ve = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/BlurrableThumbnail.m.less"),
				xe = n.n(ve);
			const Oe = e => {
				let {
					src: t
				} = e;
				const [n, s] = Object(o.useState)(!0);
				return i.a.createElement("button", {
					className: xe.a.wrapper,
					onClick: () => s(e => !e),
					role: "img",
					"aria-label": r.fbt._("Thumbnail preview of content media", null, {
						hk: "43MhFw"
					})
				}, i.a.createElement("img", {
					className: Object(ge.a)(xe.a.thumbnail, {
						[xe.a.blur]: n
					}),
					src: t
				}))
			};
			var Ee = n("./src/reddit/controls/Button/index.tsx"),
				ye = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/ExpandableBody.m.less"),
				Ce = n.n(ye);
			const je = e => {
				let {
					children: t
				} = e;
				const n = Object(o.useRef)(null),
					[s, a] = Object(o.useState)(!1);
				Object(o.useLayoutEffect)(() => {
					if (n.current) {
						const e = n.current,
							t = e.clientHeight >= e.scrollHeight;
						a(t)
					}
				}, [n, a]);
				return i.a.createElement(i.a.Fragment, null, i.a.createElement("p", {
					ref: n,
					className: Object(ge.a)(Ce.a.body, {
						[Ce.a.bodyExpanded]: s
					})
				}, t), !s && i.a.createElement(Ee.t, {
					className: Ce.a.seeMore,
					size: Ee.d.XS,
					priority: Ee.c.PlainLink,
					onClick: () => {
						a(!0)
					}
				}, r.fbt._("See more", null, {
					hk: "PNFjo"
				})))
			};
			var ke = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/index.m.less"),
				Ie = n.n(ke),
				Se = n("./src/reddit/components/ModerationLog/ModerationLogItem/TakedownPreview/PreviewInfo.m.less"),
				we = n.n(Se);
			const Te = e => {
					let {
						author: t,
						score: n,
						commentCount: s,
						createdAt: o
					} = e;
					return i.a.createElement("ul", {
						className: we.a.previewInfo
					}, t && i.a.createElement("li", {
						className: we.a.previewInfoItem
					}, i.a.createElement(q.a, {
						author: t,
						className: we.a.authorLink
					}, "u/", t)), Number.isInteger(n) && i.a.createElement("li", {
						className: we.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} points",
						_1: "1 point"
					}, [r.fbt._plural(n, "number")], {
						hk: "1nHdfa"
					})), Number.isInteger(s) && i.a.createElement("li", {
						className: we.a.previewInfoItem
					}, r.fbt._({
						"*": "{number} comments",
						_1: "1 comment"
					}, [r.fbt._plural(s, "number")], {
						hk: "1izKX9"
					})), o && i.a.createElement("li", {
						className: we.a.previewInfoItem
					}, i.a.createElement(G.d, {
						seconds: o / C.Xb
					})))
				},
				Ne = e => {
					let {
						action: t
					} = e;
					var n, s, r;
					const o = Object(fe.b)(t);
					return null === o ? null : i.a.createElement("article", {
						className: Ie.a.container,
						id: Object(fe.c)(t)
					}, (null == o ? void 0 : o.title) && i.a.createElement("p", {
						className: Ie.a.title
					}, o.title), i.a.createElement("div", {
						className: Object(ge.a)({
							[Ie.a.contentWrapperComment]: !!o.parent
						})
					}, (null == o ? void 0 : o.body) && i.a.createElement(je, null, o.body), (null == o ? void 0 : o.thumbnail) && i.a.createElement(Oe, {
						src: o.thumbnail
					}), i.a.createElement(Te, {
						author: null == o ? void 0 : o.author,
						score: null == o ? void 0 : o.score,
						commentCount: null == o ? void 0 : o.commentCount,
						createdAt: null == o ? void 0 : o.createdAt
					})), (null == o ? void 0 : o.parent) && i.a.createElement(Te, {
						score: null === (n = null == o ? void 0 : o.parent) || void 0 === n ? void 0 : n.score,
						commentCount: null === (s = null == o ? void 0 : o.parent) || void 0 === s ? void 0 : s.commentCount,
						createdAt: null === (r = null == o ? void 0 : o.parent) || void 0 === r ? void 0 : r.createdAt
					}))
				},
				Pe = "mod-log-timestamp-";
			class Re extends i.a.Component {
				constructor(e) {
					super(e), this.createTimestamp = e => {
						return new Date(e).toString()
					}, this.getTooltipId = e => `${Pe}${e}`, this.getActionModeratorName = e => e && e.__typename === V.c.AvailableRedditor ? e.name : null, this.toggleShowTakedownPreview = () => {
						this.setState(e => ({
							showTakedownPreview: !e.showTakedownPreview
						}))
					}, this.state = {
						showTakedownPreview: !1
					}
				}
				render() {
					const {
						action: e,
						currentPageUrl: t,
						moderator: n,
						onHideTooltip: s,
						onShowTooltip: o
					} = this.props, {
						showTakedownPreview: a
					} = this.state, d = this.getTooltipId(e.id), c = this.getActionModeratorName(e.moderator), l = Object(fe.e)(e);
					return i.a.createElement("tr", {
						className: de.a.row
					}, i.a.createElement("td", null, i.a.createElement("span", {
						id: d,
						onMouseEnter: () => o(d),
						onMouseLeave: s,
						className: de.a.tooltip
					}, i.a.createElement(G.d, {
						seconds: e.createdAt / C.Xb
					}), i.a.createElement(H.c, {
						className: de.a.createdAtTooltip,
						tooltipId: d,
						text: this.createTimestamp(e.createdAt)
					}))), i.a.createElement("td", {
						className: de.a.modNameCell
					}, c && !b.k.includes(c) ? i.a.createElement(q.a, {
						author: c,
						className: de.a.usernameLink
					}, c) : c), i.a.createElement("td", null, i.a.createElement(ce, {
						action: e,
						urlPath: g({
							currentPageUrl: t,
							action: e.action,
							moderator: n
						})
					})), i.a.createElement("td", null, i.a.createElement(_e, {
						action: e,
						showTakedownPreview: a,
						toggleShowTakedownPreview: this.toggleShowTakedownPreview
					})), i.a.createElement("td", {
						className: de.a.takedownContentPreviewCell
					}, l && a ? i.a.createElement("div", {
						className: de.a.takedownContentPreviewWrapper
					}, i.a.createElement(Ne, {
						action: e
					})) : i.a.createElement(W.a, null, l ? r.fbt._("No content preview shown. Press show details in previous cell to reveal.", null, {
						hk: "3OP9nc"
					}) : r.fbt._("No content preview available.", null, {
						hk: "4mp2x9"
					}))))
				}
			}
			var Ae = Object(a.b)(null, e => ({
					onHideTooltip: () => e(Object(m.i)()),
					onShowTooltip: t => e(Object(m.f)({
						tooltipId: t
					}))
				}))(Re),
				Me = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				Le = n("./src/reddit/components/ModHub/InfoTooltip/index.tsx"),
				De = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				Fe = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				Ue = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				Be = n("./src/reddit/constants/parameters.ts"),
				qe = n("./src/reddit/contexts/PageLayer/index.tsx"),
				Ge = n("./src/reddit/components/ModerationLog/index.m.less"),
				He = n.n(Ge);
			const We = Object(qe.v)({
					currentPageUrl: qe.f,
					queryParams: qe.Z
				}),
				Ve = Object(d.c)({
					actionsList: j.c,
					endCursor: j.e,
					nextPage: j.f,
					previousPage: j.g,
					startCursor: j.h
				}),
				ze = Object(a.b)(Ve, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						fetchAllModerators: () => e(Object(c.a)(n.name))
					}
				});
			class Ke extends i.a.Component {
				componentDidMount() {
					"complete" === document.readyState ? this.props.fetchAllModerators() : window.addEventListener("load", this.props.fetchAllModerators)
				}
				render() {
					const {
						actionsList: e,
						currentPageUrl: t,
						endCursor: n,
						nextPage: o,
						previousPage: a,
						queryParams: d,
						startCursor: c,
						subredditId: l
					} = this.props, u = d[Be.t] || null, m = d[Be.r] || null, p = {
						currentPageUrl: t,
						action: u,
						moderator: m,
						startCursor: c
					}, b = {
						currentPageUrl: t,
						endCursor: n,
						action: u,
						moderator: m
					};
					return i.a.createElement(Fe.a, {
						className: He.a.contentContainer
					}, i.a.createElement(Fe.b, null, r.fbt._("Mod log", null, {
						hk: "UdwRO"
					}), i.a.createElement(Me.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360022402312`
					})), i.a.createElement(Ue.a, null, i.a.createElement("span", {
						className: He.a.title
					}, r.fbt._("Filter by", null, {
						hk: "3RkGvd"
					})), i.a.createElement(B, {
						action: u,
						currentPageUrl: t,
						moderator: m,
						subredditId: l
					}), i.a.createElement(De.a, {
						prevButtonEnabled: a,
						prevTo: g(p),
						nextButtonEnabled: o,
						nextTo: g(b)
					})), i.a.createElement("table", {
						className: He.a.table
					}, i.a.createElement("thead", null, i.a.createElement("tr", null, i.a.createElement("th", null, r.fbt._("time", null, {
						hk: "1EnamY"
					})), i.a.createElement("th", null, r.fbt._("moderator", null, {
						hk: "22lRDF"
					})), i.a.createElement("th", {
						className: He.a.actionNameColHeader
					}, i.a.createElement("span", {
						className: He.a.tooltip
					}, r.fbt._("action", null, {
						hk: "243Ltb"
					}), i.a.createElement(Le.a, {
						className: He.a.actionTooltip
					}, i.a.createElement("div", {
						className: He.a.actionTooltipDescription
					}, r.fbt._("Actions performed within your community", null, {
						hk: "3RTNED"
					})), i.a.createElement("div", {
						className: He.a.allIconsContainer
					}, i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(Z.a, {
						className: He.a.icon
					}), r.fbt._("Post", null, {
						hk: "9rK7i"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(Q.a, null), r.fbt._("Comment", null, {
						hk: "1N3Vo2"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(se.a, {
						className: He.a.icon
					}), r.fbt._("Flair", null, {
						hk: "roX9r"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(re.a, {
						className: He.a.icon
					}), r.fbt._("Wiki", null, {
						hk: "27Czfb"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(te.a, {
						className: He.a.icon
					}), r.fbt._("User management", null, {
						hk: "NIFnh"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(ne.a, {
						className: He.a.icon
					}), r.fbt._("Community settings", null, {
						hk: "139FAy"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(Y.a, {
						className: He.a.icon
					}), r.fbt._("Collection", null, {
						hk: "3a6W4E"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(J.a, {
						className: He.a.icon
					}), r.fbt._("Event", null, {
						hk: "2odtv8"
					})), i.a.createElement("div", {
						className: He.a.iconContainer
					}, i.a.createElement(X.a, {
						className: He.a.icon
					}), r.fbt._("Award", null, {
						hk: "2l9uEL"
					})))))), i.a.createElement("th", null, i.a.createElement("span", {
						className: He.a.tooltip
					}, r.fbt._("details", null, {
						hk: "1hCsar"
					}), i.a.createElement(Le.a, {
						text: r.fbt._("Displays the author, post or comment link, and any additional information", null, {
							hk: "1EN2HF"
						})
					}))), i.a.createElement("th", {
						className: He.a.hiddenContentPreviewColumn
					}, r.fbt._("Content preview", null, {
						hk: "4C4kIi"
					})))), i.a.createElement("tbody", null, e.map(e => i.a.createElement(Ae, {
						key: e.id,
						action: e,
						currentPageUrl: t,
						moderator: m
					})))), i.a.createElement("div", {
						className: He.a.bottomBarRow
					}, i.a.createElement(De.a, {
						prevButtonEnabled: a,
						prevTo: g(p),
						nextButtonEnabled: o,
						nextTo: g(b)
					})))
				}
			}
			t.a = We(ze(Ke))
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.m.less": function(e, t, n) {
			e.exports = {
				NoResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				noResultsContainer: "FIy4e_7DNe0P9cdi_1jVn",
				NoResultsText: "_3V0T64xptTp5xLaY-1nsaz",
				noResultsText: "_3V0T64xptTp5xLaY-1nsaz"
			}
		},
		"./src/reddit/components/ModerationPagesEmptyList/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/ModerationPagesEmptyList/index.m.less"),
				a = n.n(i);
			const d = o.a.div("NoResultsContainer", a.a),
				c = o.a.div("NoResultsText", a.a);

			function l(e) {
				const {
					childrenPosition: t = "top"
				} = e;
				return r.a.createElement(d, {
					className: e.className
				}, "top" === t && e.children, r.a.createElement(c, null, e.text), "bottom" === t && e.children)
			}
		},
		"./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "TOhrvfHoucDPr36mCCzXd",
				titleFontH2: "_3brDTRw250hGX1o5_C0hbB",
				titleFontH3: "_1wry80KT9v8gZ-OR85HxZU",
				titleFontH4: "_3UyiSE-qM-508iK8v3J9VE",
				titleFontH5: "_1X7-zzcj5Xf8vTf2xtYjK5",
				titleFontH6: "_2o19XEin0G5ad6iDvABrhH",
				metadataFont: "_1IpedXmIlnKyWpICNENnHX",
				flairFont: "_17kIb-dmfAlFCaIsLz34ar",
				labelsFont: "_3IrRBgoth_MxadAqzwGE2p",
				actionFont: "_1F_YPbXlF7ItI0z0j2Kdvy",
				smallButtonFont: "Irj9r66tO2hdWqbJx-vWa",
				largeButtonFont: "_26FBjOBHlTgNO9o-fMxWOX",
				strongTextFont: "_2umiFjo_kHT370YVhqkBUV",
				tabFont: "_1DLO-Qu2r3PHt-swAklwVx",
				buttonFontXS: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontXs: "_2v4AgLqNSVXbMZLYk9vcId",
				buttonFontS: "_2MZUL_NnTj8rQV3EzNYnUE",
				buttonFontM: "_3cvFNq2HJE_JQWxO1GFYqj",
				buttonFontL: "_3PGa9K2pADItl7cyT0ykh_",
				buttonFontXL: "_1ZxChwU_-XfEgc5UHBhcTo",
				buttonFontXl: "_1ZxChwU_-XfEgc5UHBhcTo",
				bodyFontH1: "czPuE4HoIQInpzrURaqrX",
				bodyFontH2: "_1RMqo3EKzteTfSdM5Q-OSg",
				bodyFontH3: "_1SHo5_8OixTqxTjJ466mw1",
				bodyFontH4: "_3_zdAqdo55tnx5RHhyuGVr",
				bodyFontH5: "_22jno3ihRm-Ef63KN0Wuxa",
				bodyFontH6: "_28OREyYTHZDHgLjcK4pt_d",
				bodyFontH6Small: "_2TEwXCwEPVa9d9qN9FdZkk",
				bodyFont: "_38nKHi6IDujIOM7SuazWPd",
				bodyFontSmall: "_1lPuNthSPFYSROqTVgJlNG",
				bodyFontMono: "_3C9ynyJ6Z174Fb3-8O20xa",
				landingPageTitleFontH1: "_1nmNCQBH92sse_Es6cWOgt",
				landingPageTitleFontH2: "MAReLCada0ViNM1dSALIG",
				landingPageTitleFontH3: "_2hDhOwvMLP3waoNyjL5FB2",
				footer: "_1a_UtwKPW009WQq9JDInTY",
				checkbox: "hXaFasafnItuHCckiO50p",
				checkboxDescription: "_2HjmM9sJH5PNkLQde58pxS",
				checkboxContainer: "_15zz-Q8aRGCDeqROyYsa6f",
				divider: "_1QbYDWR424D6xhw9foYGiP",
				primaryButton: "h4QlBfFmd6UnAtiNaOhcR",
				SecondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				secondaryText: "jJBOgTxr1pZp_VDUmHpJ3",
				ModalBody: "_2UK71LqBvNes-Kto-uSxfU",
				modalBody: "_2UK71LqBvNes-Kto-uSxfU",
				automodMore: "_2IpMI7l5irmIV4rSq0_hXy"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitePendingModal.m.less": function(e, t, n) {
			e.exports = {
				ModalText: "LuEOOX6cpsihxJHcF5aDv",
				modalText: "LuEOOX6cpsihxJHcF5aDv",
				ModalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				modalTextBold: "_3FiaV5-fR6fAX63py6Vyzz",
				PrimaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				primaryButton: "_1s7NYS-cterYTwRKWqmaY6",
				SecondaryButton: "_31o7G_2349tIzHKunBJEua",
				secondaryButton: "_31o7G_2349tIzHKunBJEua",
				Section: "K3DxSh_MxIy1lMkeHIPMc",
				section: "K3DxSh_MxIy1lMkeHIPMc",
				Image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				image: "_2kAbqMQ0IHDV7bXgZ6Jsmf",
				ModalMain: "_3Nec6X3UqKJgLUGDaw4NCq",
				modalMain: "_3Nec6X3UqKJgLUGDaw4NCq"
			}
		},
		"./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less": function(e, t, n) {
			e.exports = {
				ListTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				listTitle: "_1LuVAChAgGbcgUPh_K7ebp",
				ListContainer: "_1IFQy3zyz-Lgs7iYZtQaPI",
				listContainer: "_1IFQy3zyz-Lgs7iYZtQaPI"
			}
		},
		"./src/reddit/components/ModeratorsList/Moderator.m.less": function(e, t, n) {
			e.exports = {
				PencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				pencilIcon: "_2Pdzq06b5akGcY4hZ05n_5",
				TrashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				trashIcon: "_2TU9GRodUTR72kz4zcFzxJ",
				InteractiveDiv: "qaNZ40bbce8HBshNk04f0",
				interactiveDiv: "qaNZ40bbce8HBshNk04f0"
			}
		},
		"./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_3j2WCnh8ZjDRHIILJwKzkx",
				primaryButton: "_3j2WCnh8ZjDRHIILJwKzkx"
			}
		},
		"./src/reddit/components/ModeratorsList/index.m.less": function(e, t, n) {
			e.exports = {
				ListContainer: "_3s9PIWHO5f49Yj01FelAkk",
				listContainer: "_3s9PIWHO5f49Yj01FelAkk",
				SecondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				secondaryButton: "_3wQwmI4Vsj0qouIT5DTZo",
				EditableTitle: "_1IBuDqoejky7tmj25quCUh",
				editableTitle: "_1IBuDqoejky7tmj25quCUh",
				UsersLoading: "_1oLmt3eyMItCQozx1nTk1E",
				usersLoading: "_1oLmt3eyMItCQozx1nTk1E"
			}
		},
		"./src/reddit/components/ModeratorsList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/addQueryParams/index.ts"),
				l = n("./src/lib/lessComponent.tsx"),
				u = n("./src/lib/stripQueryParams/index.ts"),
				m = n("./src/reddit/actions/modal.ts"),
				p = n("./src/reddit/actions/subredditModeration/index.ts"),
				b = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				f = n("./src/reddit/components/ModHub/PaginationButtons/index.tsx"),
				h = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				g = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				x = n("./src/reddit/contexts/PageLayer/index.tsx"),
				O = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/helpers/hasModFullPermissions/index.ts"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/meta.ts"),
				k = n("./src/reddit/selectors/moderatorPermissions.ts"),
				I = n("./src/reddit/selectors/subredditModeration.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/higherOrderComponents/asModal/index.tsx")),
				T = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				N = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				P = n("./src/reddit/components/TrackingHelper/index.tsx"),
				R = n("./src/reddit/controls/CheckboxWithLabel/index.tsx"),
				A = n("./src/reddit/controls/TextButton/index.tsx"),
				M = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				L = n("./src/reddit/helpers/trackers/modHub.ts"),
				D = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				F = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				U = n("./src/reddit/components/ModeratorsList/AddModeratorModal/index.m.less"),
				B = n.n(U);
			const q = e => {
					switch (e) {
						case F.c.access:
							return r.fbt._("Manage Users", null, {
								hk: "2cVPGG"
							});
						case F.c.config:
							return r.fbt._("Manage Settings", null, {
								hk: "10NyX"
							});
						case "chat_config":
						case F.c.chatConfig:
							return r.fbt._("Create Live Chats", null, {
								hk: "2OsHBQ"
							});
						case "chat_operator":
						case F.c.chatOperator:
							return r.fbt._("Monitor Chats", null, {
								hk: "3x751K"
							});
						case F.c.flair:
							return r.fbt._("Manage Flair", null, {
								hk: "IgS6W"
							});
						case F.c.mail:
							return r.fbt._("Manage Mod Mail", null, {
								hk: "1H5qJm"
							});
						case F.c.posts:
							return r.fbt._("Manage Posts & Comments", null, {
								hk: "1IVGI9"
							});
						case F.c.wiki:
							return r.fbt._("Manage Wiki Pages", null, {
								hk: "4gZJ2V"
							});
						case F.c.all:
						default:
							return r.fbt._("Everything", null, {
								hk: "24E26J"
							})
					}
				},
				G = (e, t) => {
					switch (e) {
						case F.c.access:
							return t ? r.fbt._("Access mod notes, ban and mute users, and approve submitters*.", null, {
								hk: "24IuB9"
							}) : r.fbt._("Approve submitters and ban and mute users*.", null, {
								hk: "KndNL"
							});
						case F.c.config:
							return r.fbt._("Manage community settings, appearance, emojis, rules, and AutoMod*.", null, {
								hk: "4djZSI"
							});
						case "chat_config":
						case F.c.chatConfig:
							return r.fbt._("Create live chat posts in this community.", null, {
								hk: "1Hxgd8"
							});
						case "chat_operator":
						case F.c.chatOperator:
							return r.fbt._("Remove messages, remove users, and lock chats.", null, {
								hk: "TFYA1"
							});
						case F.c.flair:
							return r.fbt._("Create and manage user and post flair.", null, {
								hk: "1oN7ft"
							});
						case F.c.mail:
							return r.fbt._("Read and respond to modmail and mute users*.", null, {
								hk: "2F8Yd"
							});
						case F.c.posts:
							return r.fbt._("Access queues, take action on content, and manage collections and events.", null, {
								hk: "vJ5lR"
							});
						case F.c.wiki:
							return r.fbt._("Create and manage wiki pages and AutoMod*.", null, {
								hk: "JarEL"
							});
						case F.c.all:
						default:
							return r.fbt._("Full access including the ability to manage moderator access and permissions.", null, {
								hk: "2r1vEj"
							})
					}
				},
				H = Object(a.b)(null, (e, t) => {
					let {
						subredditId: n,
						after: s,
						before: r
					} = t;
					return {
						addModerator: (t, s) => e(Object(p.b)(n, t, s)),
						editModerator: (t, s, r) => e(Object(p.d)(n, t, s, r)),
						removeModerator: t => e(Object(p.k)(n, t, s, r))
					}
				}),
				W = l.a.span("SecondaryText", B.a),
				V = l.a.wrapped(T.e, "ModalBody", B.a);
			class z extends i.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.toggleSelect = (e, t) => {
						if (this.props.isEditingSelf) return;
						const n = {
							...this.state.permissions,
							[e]: !t
						};
						"all" === e ? Object.keys(n).forEach(e => n[e] = n.all) : n[e] || (n.all = !1), this.setState({
							permissions: n
						}), this.props.sendEvent(Object(L.d)(e, Object.keys(this.state.permissions)))
					}, this.onSubmit = e => {
						var t;
						e.preventDefault();
						const {
							props: n,
							state: s
						} = this;
						if (n.isEditingSelf) return void n.toggleModal();
						let r;
						n.isEditingPerms && n.user ? (n.editModerator(s.username, s.permissions, n.user.id), r = "edit") : (n.addModerator(s.username, s.permissions), r = "invite_moderator"), n.sendEvent(Object(L.e)(r, (null === (t = n.user) || void 0 === t ? void 0 : t.id) || s.username, Object.entries(s.permissions).reduce((e, t) => {
							let [n, s] = t;
							return [...e, ...s ? [n] : []]
						}, []))), n.toggleModal()
					}, this.onRemove = () => {
						this.props.user && (this.props.removeModerator(this.props.user.id), this.props.sendEventWithName("remove")()), this.props.toggleModal()
					}, this.state = {
						username: e.user ? e.user.username : "",
						permissions: e.user ? e.user.modPermissions : F.a
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = ["all", ...Object.keys(t.permissions).filter(t => !["all", ...e.isLivePostCreatorModRoleEnabled ? ["chat_operator", F.c.chatOperator] : []].includes(t))];
					return i.a.createElement(V, null, i.a.createElement(T.i, null, i.a.createElement(D.a, null, i.a.createElement(T.q, null, e.isEditingPerms ? r.fbt._("Edit", null, {
						hk: "1nftDt"
					}) : r.fbt._("Invite Moderators", null, {
						hk: "hkBh1"
					}), e.username && r.fbt._(": u/{username}", [r.fbt._param("username", e.username)], {
						hk: "2FWWEd"
					})), i.a.createElement(A.a, {
						onClick: e.toggleModal
					}, i.a.createElement(T.b, null)))), i.a.createElement("form", {
						onSubmit: this.onSubmit
					}, i.a.createElement(T.l, null, !e.isEditingPerms && i.a.createElement(T.h, null, i.a.createElement(N.d, {
						autoFocus: !0,
						placeholder: r.fbt._("Enter Username", null, {
							hk: "2fYsDe"
						}),
						onChange: this.onUsernameChange
					})), i.a.createElement(T.q, null, e.isEditingSelf ? i.a.createElement(i.a.Fragment, null, r.fbt._("Access", null, {
						hk: "2We3HN"
					}), i.a.createElement(W, null, r.fbt._("(can't edit)", null, {
						hk: "3LZvZi"
					}))) : r.fbt._("Give them access to...", null, {
						hk: "1DzYmU"
					})), t.permissions && n.map((n, s) => i.a.createElement("div", {
						className: B.a.checkboxContainer,
						key: n
					}, i.a.createElement(R.a, {
						autoFocus: !(!e.isEditingPerms || 0 !== s) || void 0,
						className: B.a.checkbox,
						disabled: e.isEditingSelf,
						isSelected: t.permissions[n],
						onClick: () => this.toggleSelect(n, t.permissions[n]),
						text: q(n)
					}), i.a.createElement("p", {
						className: B.a.checkboxDescription
					}, G(n, e.isModWithUserNotesPermissions)), "all" === n && i.a.createElement("hr", {
						className: B.a.divider
					}))), i.a.createElement("p", {
						className: B.a.automodMore
					}, r.fbt._("*Note: To manage AutoMod, mods must have access to Wiki Pages and Manage Settings. To mute users, mods must have access to Mod Mail and Manage Users.", null, {
						hk: "1AYX38"
					}))), i.a.createElement(T.g, {
						className: B.a.footer
					}, i.a.createElement(O.l, {
						className: B.a.primaryButton,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(M.a)(t.username),
						type: "submit"
					}, e.isEditingPerms ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Invite", null, {
						hk: "2F1syY"
					})), i.a.createElement(T.a, {
						autoFocus: !!e.isEditingSelf || void 0,
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.isEditingPerms && !e.isEditingSelf && i.a.createElement(T.s, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, r.fbt._("Remove", null, {
						hk: "3tYl0U"
					})))))
				}
			}
			var K = Object(w.a)(H(Object(P.c)(z))),
				Q = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				Y = n("./src/reddit/selectors/telemetry.ts");
			const J = e => ({
					screen: Y.cb(e),
					subreddit: Y.kb(e)
				}),
				X = e => t => ({
					source: "remove_mod_invite",
					action: "click",
					noun: e,
					...J(t)
				});
			var Z = n("./src/lib/constants/index.ts"),
				$ = n("./src/reddit/components/HumanDate/index.tsx"),
				ee = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				te = n("./src/reddit/icons/svgs/Trash/index.tsx"),
				ne = n("./src/reddit/components/ModeratorsList/Moderator.m.less"),
				se = n.n(ne);
			const re = e => {
					const t = [],
						n = Object.keys(e);
					return e.all ? q("all") : (n.forEach((function(n) {
						e[n] && t.push(q(n))
					})), 0 === t.length ? r.fbt._("No permissions", null, {
						hk: "3eH05z"
					}) : t.join(", "))
				},
				oe = l.a.wrapped(ee.a, "PencilIcon", se.a),
				ie = l.a.wrapped(te.a, "TrashIcon", se.a),
				ae = l.a.div("InteractiveDiv", se.a),
				de = e => i.a.createElement(ae, {
					onClick: e.onClick
				}, e.moderatorType === y.c.Editable ? i.a.createElement(oe, null) : i.a.createElement(ie, null));
			var ce = e => i.a.createElement(v.b, {
					additionalText: re(e.moderator.modPermissions),
					pageName: Z.mc.Moderators,
					primaryButton: e.moderatorType && e.onClick && i.a.createElement(de, {
						onClick: e.onClick,
						moderatorType: e.moderatorType
					}),
					timeAgo: i.a.createElement($.d, {
						seconds: e.moderator.moddedAtUTC
					}),
					subredditId: e.subredditId,
					userIcon: e.moderator.accountIcon,
					username: e.moderator.username,
					moderatorType: e.moderatorType
				}),
				le = n("./src/reddit/components/ModeratorsList/InvitedModeratorsList.m.less"),
				ue = n.n(le);
			const me = l.a.div("ListTitle", ue.a),
				pe = l.a.div("ListContainer", ue.a),
				be = Object(d.c)({
					invitedModeratorsList: I.f,
					isConfirmModalOpen: Object(C.b)("ModerationPage--Modal--RemoveModeratorConfirmation")
				});
			class fe extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleRemovalModal = e => {
						this.setState({
							selectedModerator: e
						}), this.props.toggleConfirmUserActionModal(), e && this.props.sendEventWithName("remove_mod_invite")()
					}, this.state = {
						selectedModerator: void 0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					if (0 === e.invitedModeratorsList.length) return null;
					const n = () => this.props.sendEvent(X("cancel"));
					return i.a.createElement("div", null, i.a.createElement(me, null, r.fbt._("Invited moderators", null, {
						hk: "2UdpbF"
					})), i.a.createElement(pe, null, e.invitedModeratorsList.map(t => i.a.createElement(ce, {
						key: t.id,
						moderator: t,
						moderatorType: y.c.Invited,
						onClick: () => this.onToggleRemovalModal(t),
						subredditId: e.subredditId
					}))), e.isConfirmModalOpen && t.selectedModerator && i.a.createElement(Q.a, {
						actionText: r.fbt._("Remove", null, {
							hk: "3tYl0U"
						}),
						modalText: r.fbt._("Are you sure you want to rescind the moderator invite to {username}?", [r.fbt._param("username", t.selectedModerator.username)], {
							hk: "3Z7yAI"
						}),
						onConfirm: () => e.removeInvitedModerator(t.selectedModerator.id),
						toggleModal: this.onToggleRemovalModal,
						onCancel: n,
						onClose: n,
						trackClick: () => this.props.sendEvent(X("remove"))
					}))
				}
			}
			var he = Object(a.b)(be, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						removeInvitedModerator: t => e(Object(p.j)(n, t)),
						toggleConfirmUserActionModal: () => e(Object(m.i)("ModerationPage--Modal--RemoveModeratorConfirmation"))
					}
				})(Object(P.c)(fe)),
				_e = n("./src/reddit/components/ModeratorsList/InvitePendingModal.m.less"),
				ge = n.n(_e);
			const {
				fbt: ve
			} = n("./node_modules/fbt/lib/FbtPublic.js"), xe = Object(a.b)(null, (e, t) => {
				let {
					subredditId: n
				} = t;
				return {
					acceptInvite: () => e(Object(p.a)(n)),
					declineInvite: () => e(Object(p.c)(n))
				}
			}), Oe = l.a.wrapped(T.p, "ModalText", ge.a), Ee = l.a.wrapped(Oe, "ModalTextBold", ge.a), ye = l.a.wrapped(O.l, "PrimaryButton", ge.a), Ce = l.a.wrapped(O.o, "SecondaryButton", ge.a), je = l.a.div("Section", ge.a), ke = l.a.img("Image", ge.a), Ie = l.a.wrapped(T.l, "ModalMain", ge.a);
			var Se = Object(w.a)(xe(e => i.a.createElement(T.e, null, i.a.createElement(Ie, null, i.a.createElement(D.a, null, i.a.createElement("div", null), i.a.createElement(A.a, {
					onClick: e.toggleModal
				}, i.a.createElement(T.b, null))), i.a.createElement(je, null, i.a.createElement(ke, {
					src: `${s.a.assetPath}/img/snoo-success@2x.png`
				})), i.a.createElement(Ee, null, ve._("Congrats!", null, {
					hk: "T4Ccw"
				})), i.a.createElement(Oe, null, ve._("You are invited to become a moderator!", null, {
					hk: "1jRLWz"
				}))), i.a.createElement(T.g, null, i.a.createElement(Ce, {
					onClick: t => {
						e.toggleModal(), e.declineInvite(), e.sendEventWithName("declineinvite")()
					},
					"data-redditstyle": !0
				}, ve._("Decline", null, {
					hk: "1iOsJe"
				})), i.a.createElement(ye, {
					onClick: t => {
						e.toggleModal(), e.acceptInvite(), e.sendEventWithName("acceptinvite")()
					},
					"data-redditstyle": !0
				}, ve._("Accept", null, {
					hk: "2fkYc4"
				})))))),
				we = n("./src/reddit/components/ModeratorsList/ResignAsModeratorModal/index.m.less"),
				Te = n.n(we);
			const {
				fbt: Ne
			} = n("./node_modules/fbt/lib/FbtPublic.js"), Pe = Object(a.b)(null, (e, t) => {
				let {
					subredditId: n,
					userId: s,
					after: r,
					before: o
				} = t;
				return {
					removeModerator: () => e(Object(p.k)(n, s, r, o))
				}
			}), Re = l.a.wrapped(O.l, "PrimaryButton", Te.a);
			class Ae extends i.a.Component {
				constructor() {
					super(...arguments), this.onRemove = () => {
						this.props.removeModerator(), this.props.sendEventWithName("resign")(), this.props.toggleModal()
					}
				}
				render() {
					const {
						props: e
					} = this;
					return i.a.createElement(T.e, null, i.a.createElement(T.i, null, i.a.createElement(D.a, null, i.a.createElement(T.q, null, Ne._("Leave as mod", null, {
						hk: "3ajWeG"
					})), i.a.createElement(A.a, {
						onClick: e.toggleModal
					}, i.a.createElement(T.b, null)))), i.a.createElement(T.l, null, i.a.createElement(T.p, null, Ne._("Once you leave as a mod, you will lose mod permissions and will be unable to access any mod tools for this community. Are you sure you wish to leave as a mod of this community?", null, {
						hk: "4qm9md"
					}))), i.a.createElement(T.g, null, i.a.createElement(T.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, Ne._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(Re, {
						onClick: this.onRemove,
						"data-redditstyle": !0
					}, Ne._("Leave", null, {
						hk: "2ZHZVX"
					}))))
				}
			}
			var Me = Object(w.a)(Pe(Ae)),
				Le = n("./src/reddit/selectors/experiments/chat.ts"),
				De = n("./src/reddit/components/ModeratorsList/index.m.less"),
				Fe = n.n(De);
			const Ue = l.a.div("ListContainer", Fe.a),
				Be = l.a.wrapped(O.o, "SecondaryButton", Fe.a),
				qe = Object(x.v)({
					currentPageUrl: x.f
				}),
				Ge = Object(d.c)({
					currentUser: S.l,
					nextAfterToken: I.k,
					nextAfterEditableToken: I.c,
					nextBeforeToken: I.l,
					nextBeforeEditableToken: I.d,
					editableModerators: I.e,
					editableModeratorsList: I.b,
					isInvitePending: I.h,
					moderators: I.o,
					moderatorsList: I.j,
					moderatorPermissions: k.n,
					isAddUserModalOpen: Object(C.b)("ModerationPage--Modal--AddModerator"),
					isEditableListPending: I.a,
					isInvitePendingModalOpen: Object(C.b)("ModerationPage--Modal--InvitePending"),
					isLivePostCreatorModRoleEnabled: Le.h,
					isModeratorListPending: I.i,
					isResignAsModeratorModalOpen: Object(C.b)("ModerationPage--Modal--Resign"),
					origin: j.k,
					searchPending: I.m,
					searchResult: I.n,
					isModWithUserNotesPermissions: (e, t) => {
						let {
							subredditId: n
						} = t;
						return Object(k.i)(e, n)
					}
				}),
				He = Object(a.b)(Ge, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						searchForModerator: t => e(Object(p.h)(n, t)),
						toggleAddModeratorModal: () => e(Object(m.i)("ModerationPage--Modal--AddModerator")),
						toggleInvitePendingModal: () => e(Object(m.i)("ModerationPage--Modal--InvitePending")),
						toggleResignAsModModal: () => e(Object(m.i)("ModerationPage--Modal--Resign"))
					}
				}),
				We = l.a.div("EditableTitle", Fe.a),
				Ve = l.a.wrapped(v.a, "UsersLoading", Fe.a);
			class ze extends i.a.Component {
				constructor() {
					super(...arguments), this.state = y.a, this.toggleModal = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.isAddUserModalOpen || t || this.props.sendEventWithName("open_invite_dialog")(), this.props.toggleAddModeratorModal()
					}, this.onSearch = e => {
						this.props.searchForModerator(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.isButtonEnabled = (e, t) => !!(e && e.length > 0 && t), this.isModeratorsListPaginated = () => !(!this.props.nextBeforeToken && !this.props.nextAfterToken), this.renderEditableList = e => {
						const t = !(!e.nextBeforeEditableToken && !e.nextAfterEditableToken),
							n = e.isEditableListPending || e.isModeratorListPending;
						return i.a.createElement(i.a.Fragment, null, i.a.createElement(We, null, r.fbt._("You can edit these moderators", null, {
							hk: "1KTZtm"
						})), t && i.a.createElement(g.a, null, i.a.createElement(f.a, {
							prevButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextBeforeEditableToken),
							prevTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
								before: e.before,
								beforeEditable: e.nextBeforeEditableToken,
								after: e.after
							}),
							nextButtonEnabled: this.isButtonEnabled(e.editableModeratorsList, e.nextAfterEditableToken),
							nextTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
								after: e.after,
								afterEditable: e.nextAfterEditableToken,
								before: e.before
							})
						})), i.a.createElement(Ue, null, e.editableModeratorsList && e.editableModeratorsList.length > 0 ? e.editableModeratorsList.map(e => i.a.createElement(ce, {
							key: e.id,
							moderator: e,
							moderatorType: y.c.Editable,
							onClick: this.toggleModal(e.id, e.username),
							subredditId: this.props.subredditId
						})) : n ? i.a.createElement(Ve, null) : null))
					}
				}
				componentDidMount() {
					this.props.isInvitePending && !this.props.isInvitePendingModalOpen && this.props.toggleInvitePendingModal()
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = !!e.moderatorPermissions, o = Object(E.a)(e.moderatorPermissions);
					return i.a.createElement(i.a.Fragment, null, n && i.a.createElement(h.c, null, i.a.createElement(Be, {
						onClick: e.toggleResignAsModModal
					}, r.fbt._("Leave as mod", null, {
						hk: "3TwqTg"
					})), o && i.a.createElement(O.l, {
						onClick: this.toggleModal(null, null)
					}, r.fbt._("Invite user as mod", null, {
						hk: "3lJRJW"
					}))), i.a.createElement(h.a, null, i.a.createElement(h.b, null, r.fbt._("Moderators of {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
						hk: "3p7NwA"
					}), i.a.createElement(b.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009381491`
					})), i.a.createElement(g.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}, !t.searchTerm && this.isModeratorsListPaginated() && i.a.createElement(f.a, {
						prevButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextBeforeToken),
						prevTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
							afterEditable: e.afterEditable,
							before: e.nextBeforeToken,
							beforeEditable: e.beforeEditable
						}),
						nextButtonEnabled: this.isButtonEnabled(e.moderatorsList, e.nextAfterToken),
						nextTo: Object(c.a)(Object(u.a)(`${e.origin}${e.currentPageUrl}`), {
							after: e.nextAfterToken,
							afterEditable: e.afterEditable,
							beforeEditable: e.beforeEditable
						})
					})), t.searchTerm ? i.a.createElement(_.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && i.a.createElement(ce, {
						moderator: e.searchResult,
						moderatorType: e.searchResult.isEditable ? y.c.Editable : void 0,
						onClick: e.searchResult.isEditable ? this.toggleModal(e.searchResult.id, e.searchResult.username) : void 0,
						subredditId: e.subredditId
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(Ue, null, e.moderatorsList && e.moderatorsList.length > 0 ? e.moderatorsList.map(e => i.a.createElement(ce, {
						key: e.id,
						moderator: e,
						subredditId: this.props.subredditId
					})) : e.isModeratorListPending ? i.a.createElement(Ve, null) : null), o && i.a.createElement(i.a.Fragment, null, this.renderEditableList(e), i.a.createElement(he, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId
					})))), e.isAddUserModalOpen && i.a.createElement(K, {
						ignoreDefaultFocus: !0,
						after: e.afterEditable,
						before: e.beforeEditable,
						subredditId: e.subredditId,
						sendEventWithName: e.sendEventWithName,
						toggleModal: this.toggleModal(null, null),
						isEditingPerms: !!t.username,
						isEditingSelf: !(!t.userId || !e.currentUser) && t.userId === e.currentUser.id,
						username: t.username,
						user: t.userId && e.editableModerators ? e.editableModerators[t.userId] : null,
						withOverlay: !0,
						isModWithUserNotesPermissions: e.isModWithUserNotesPermissions,
						isLivePostCreatorModRoleEnabled: e.isLivePostCreatorModRoleEnabled
					}), e.currentUser && e.isResignAsModeratorModalOpen && i.a.createElement(Me, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleResignAsModModal,
						userId: e.currentUser.id,
						withOverlay: !0
					}), e.isInvitePendingModalOpen && i.a.createElement(Se, {
						sendEventWithName: e.sendEventWithName,
						subredditId: e.subredditId,
						toggleModal: e.toggleInvitePendingModal,
						withOverlay: !0
					}))
				}
			}
			t.a = qe(He(ze))
		},
		"./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				optionSearchBarContainer: "_3eVrzdp5khbz6W2NhQv7kl",
				optionSearchBarError: "_3va8RfTnDLBo2hfMm5URpu",
				optionSearchBarReadOnly: "_2siJVLOBn72IxBt8i_A1gZ",
				loadingIcon: "_3UsfWdV2CKiIs_EOeGhVxv",
				input: "_1OEtZmrYX2ct3ycV1AaUZS",
				hiddenInput: "_3WSlf55CAQYRdOxtxENgA7",
				optionsOverflowIndication: "_2qfFc8Ix-QpBqu8UNEXeH3"
			}
		},
		"./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less": function(e, t, n) {
			e.exports = {
				activeOption: "_2Kg5EXAuLcqhsBbdEr4SGZ",
				freeTextOption: "_2H29-4MOHAslt1eKYtcGaV",
				lastFixedOption: "_1ClyNNAK4vP9o_uoSwKe0Q",
				option: "_1xWVaijFIih7uj-n4FXzH2",
				availableOptionContainer: "T2jLhmuhOy8DeOHjz6WRG",
				addText: "_1OqThwyrfhl2eJ9YhWoy2I",
				optionsContainer: "_1ZmC1GBXYnksnMU9IrTAHd",
				relativeContainer: "_3SrGeaD5FxXfpWjhSAFBD-",
				dropdown: "_2dqCXnStO_Dc8Srt_lJqVj",
				dropdownHeaderText: "_2EaXrPilAtjz6VRh_xvOGU"
			}
		},
		"./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less": function(e, t, n) {
			e.exports = {
				selectedOptionComponentContainer: "_3nUaRUcJJfrvOWldA3i10S",
				closeIcon: "_1RvgsgnXdbtv2cwTTTbT7o",
				selectedOptionComponentContainerError: "_2Qpr0YORGp3CmDjJW9Txrf"
			}
		},
		"./src/reddit/components/MultiOptionSelect/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/components/MultiOptionSelect/OptionsListDropdown/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends i.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.handleOptionSelected(this.props.index)
					}, this.handleMouseEnter = () => {
						this.props.handleOnMouseEnter(this.props.index)
					}
				}
				shouldComponentUpdate(e) {
					return e.className !== this.props.className || e.divRef !== this.props.divRef || e.displayText !== this.props.displayText
				}
				render() {
					const {
						addText: e,
						displayText: t,
						divRef: n,
						handleOnMouseEnter: s,
						handleOptionSelected: r,
						index: o,
						className: d,
						...c
					} = this.props;
					return i.a.createElement("div", u({
						className: Object(a.a)(l.a.availableOptionContainer, d)
					}, c, {
						onMouseEnter: this.handleMouseEnter,
						onClick: this.handleClick,
						ref: n
					}), e && i.a.createElement("span", {
						className: l.a.addText
					}, e, " "), t)
				}
			}
			class p extends i.a.Component {
				constructor(e) {
					super(e), this.handleOptionSelectedByIndex = e => {
						this.props.selectableOptions[e] && this.handleOptionSelected(this.props.selectableOptions[e])
					}, this.handleFreeTextOptionSelected = () => {
						this.handleOptionSelected({
							id: null,
							displayText: this.props.currentInput,
							selected: !0
						})
					}, this.clearSelectedIndex = () => {
						this.setSelectedIndex(-1)
					}, this.setOptionActiveByIndex = e => {
						"number" == typeof e && e > -1 && this.setSelectedIndex(e)
					}, this.setFreeTextOptionActive = () => {
						this.setSelectedIndex(this.getOptionsLength() - 1)
					}, this.state = {
						selectedIndex: -1
					}, this.scrollContainer = i.a.createRef(), this.optionsContainer = i.a.createRef(), this.activeOptionDOMRef = i.a.createRef()
				}
				focus() {
					this.optionsContainer.current && this.optionsContainer.current.focus()
				}
				matchesDOMElement(e) {
					return this.optionsContainer.current === e
				}
				handleOptionSelected(e) {
					this.handleOptionsSelected([e])
				}
				handleOptionsSelected(e) {
					this.props.onOptionsChanged(e.map(e => ({
						...e,
						selected: !0
					})))
				}
				setSelectedIndex(e) {
					this.setState({
						selectedIndex: e
					})
				}
				freeTextEntryActive() {
					return this.props.allowFreeTextEntry && this.props.currentInput
				}
				getOptionsLength() {
					return this.freeTextEntryActive() ? this.props.selectableOptions.length + 1 : this.props.selectableOptions.length
				}
				freeTextOptionSelected() {
					return this.freeTextEntryActive() && this.state.selectedIndex === this.getOptionsLength() - 1
				}
				validOptionSelected() {
					return this.state.selectedIndex > -1 && this.state.selectedIndex < this.getOptionsLength()
				}
				handlePaste(e) {
					if (e.clipboardData.types.includes("text/plain")) return e.preventDefault(), e.stopPropagation(), void this.handleOptionsSelected(e.clipboardData.getData("text/plain").split(d.b.Comma).filter(e => !!e).map(e => ({
						id: null,
						displayText: e.trim(),
						selected: !0
					})))
				}
				handleKeyPress(e) {
					const {
						splitOnCommaPress: t
					} = this.props;
					return e.which === d.a.ArrowUp ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex - 1 > -1 ? this.state.selectedIndex - 1 : this.getOptionsLength() - 1)) : e.which === d.a.ArrowDown ? (e.preventDefault(), e.stopPropagation(), this.setSelectedIndex(this.state.selectedIndex + 1 < this.getOptionsLength() ? this.state.selectedIndex + 1 : 0)) : e.which === d.a.Comma && t ? (e.preventDefault(), e.stopPropagation(), this.handleFreeTextOptionSelected()) : e.which === d.a.Enter ? (e.preventDefault(), e.stopPropagation(), !this.validOptionSelected() || this.freeTextOptionSelected() ? this.handleFreeTextOptionSelected() : this.handleOptionSelected(this.props.selectableOptions[this.state.selectedIndex])) : void 0
				}
				componentDidUpdate() {
					if (!this.activeOptionDOMRef.current || !this.scrollContainer.current) return;
					const e = this.activeOptionDOMRef.current.getBoundingClientRect(),
						t = this.scrollContainer.current.getBoundingClientRect();
					if (e.top < t.top || e.bottom > t.bottom) {
						if (0 === this.state.selectedIndex) return void(this.scrollContainer.current.scrollTop = 0);
						if (e.top < t.top) return void(this.scrollContainer.current.scrollTop = this.activeOptionDOMRef.current.offsetTop);
						this.scrollContainer.current.scrollTop += e.bottom - t.bottom
					}
				}
				shouldRenderDropdownHeaderText() {
					return !!this.props.dropdownHeaderText && (!this.freeTextEntryActive() || this.props.selectableOptions.length > 0)
				}
				render() {
					return i.a.createElement("div", {
						className: l.a.relativeContainer
					}, i.a.createElement("div", {
						className: Object(a.a)(l.a.dropdown, this.props.className),
						ref: this.scrollContainer
					}, i.a.createElement("div", {
						ref: this.optionsContainer,
						tabIndex: -1,
						className: l.a.optionsContainer,
						onMouseOut: this.clearSelectedIndex
					}, this.shouldRenderDropdownHeaderText() && i.a.createElement("h3", {
						className: l.a.dropdownHeaderText
					}, this.props.dropdownHeaderText), this.props.selectableOptions.map((e, t) => {
						const n = [this.state.selectedIndex === t ? l.a.activeOption : l.a.option];
						return this.freeTextEntryActive() && t === this.props.selectableOptions.length - 1 && n.push(l.a.lastFixedOption), i.a.createElement(m, {
							key: e.id,
							className: Object(a.a)(...n),
							index: t,
							handleOptionSelected: this.handleOptionSelectedByIndex,
							handleOnMouseEnter: this.setOptionActiveByIndex,
							divRef: t === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
							displayText: e.displayText
						})
					}), this.freeTextEntryActive() && i.a.createElement(m, {
						key: "options-list-dropdown-free-text-option",
						className: Object(a.a)(l.a.freeTextOption, this.state.selectedIndex === this.getOptionsLength() - 1 ? l.a.activeOption : l.a.option),
						handleOptionSelected: () => this.handleFreeTextOptionSelected(),
						handleOnMouseEnter: this.setFreeTextOptionActive,
						divRef: this.getOptionsLength() - 1 === this.state.selectedIndex ? this.activeOptionDOMRef : void 0,
						addText: this.props.addText,
						displayText: this.props.currentInput
					}))))
				}
			}
			var b = n("./src/reddit/icons/svgs/Close/index.tsx"),
				f = n("./src/reddit/components/MultiOptionSelect/SelectedOption/index.m.less"),
				h = n.n(f);

			function _() {
				return (_ = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var g = e => {
					const {
						className: t,
						innerRef: n,
						onClickHandler: s,
						option: r,
						maxLength: o,
						...d
					} = e, c = [h.a.selectedOptionComponentContainer, t];
					return o && o < r.displayText.length && c.push(h.a.selectedOptionComponentContainerError), i.a.createElement("div", _({
						className: Object(a.a)(...c),
						ref: n
					}, d, {
						onClick: s
					}), r.displayText, i.a.createElement(b.a, {
						className: h.a.closeIcon
					}))
				},
				v = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				x = n("./src/reddit/helpers/readOnlyMode/index.ts"),
				O = n("./src/reddit/components/MultiOptionSelect/OptionSearchBar/index.m.less"),
				E = n.n(O);

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = 10,
				j = e => e.stopPropagation();
			class k extends i.a.Component {
				constructor(e) {
					super(e), this.handleKeyPress = e => {
						e.which !== d.a.Delete && e.which !== d.a.Backspace || !this.lastSelectedOptionComponentRef.current || "" !== this.props.value || (this.lastSelectedOptionComponentRef.current.focus(), e.preventDefault(), e.stopPropagation())
					}, this.handleMouseEnterSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !0
						})
					}, this.handleMouseLeaveSelectedOptionComponent = () => {
						this.setState({
							isHoveringOverSelectedOption: !1
						})
					}, this.onSearchBarFocus = e => {
						Object(x.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
							isFocused: !0
						}), this.props.onFocus && this.inputRef.current === e.target && this.props.onFocus())
					}, this.onSearchBarBlur = e => {
						if (this.containerRef.current && e.relatedTarget && this.containerRef.current.contains(e.relatedTarget)) return e.preventDefault(), void e.stopPropagation();
						this.props.onBlur && this.props.onBlur(e), this.setState({
							isFocused: !1
						})
					}, this.inputRef = i.a.createRef(), this.containerRef = i.a.createRef(), this.lastSelectedOptionComponentRef = i.a.createRef(), this.state = {
						isHoveringOverSelectedOption: !1,
						isFocused: !1
					}
				}
				focus() {
					Object(x.c)(this.props.readOnlyMode) || (this.inputRef.current && this.inputRef.current.focus(), this.setState({
						isFocused: !0
					}))
				}
				reset() {
					this.inputRef.current && (this.inputRef.current.value = "")
				}
				deselectOption(e) {
					this.props.onOptionsChanged([{
						...e,
						selected: !1
					}]), this.setState({
						isHoveringOverSelectedOption: !1
					})
				}
				onSelectedOptionComponentKeyDown(e, t) {
					this.state.isHoveringOverSelectedOption || e.which !== d.a.Delete && e.which !== d.a.Backspace || (e.preventDefault(), e.stopPropagation(), this.deselectOption(t), this.focus())
				}
				render() {
					const e = {};
					Object(x.c)(this.props.readOnlyMode) || (e.tabIndex = 0);
					const t = this.props.selectedOptionComponent || g,
						n = "number" == typeof this.props.maxOptionsToDisplay && this.props.options.length > this.props.maxOptionsToDisplay;
					return i.a.createElement("div", y({
						"aria-invalid": this.props.isError,
						className: Object(a.a)(this.props.className, E.a.optionSearchBarContainer, {
							[E.a.optionSearchBarError]: this.props.isError,
							[E.a.optionSearchBarReadOnly]: Object(x.c)(this.props.readOnlyMode)
						}),
						ref: this.containerRef,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur
					}, e), this.props.options.map((e, s) => {
						if (!(n && s >= (this.props.maxOptionsToDisplay || 0))) return i.a.createElement(t, {
							tabIndex: 0,
							onFocus: j,
							key: e.id || e.displayText,
							option: e,
							onKeyDown: t => this.onSelectedOptionComponentKeyDown(t, e),
							onClickHandler: () => {
								this.deselectOption(e), this.focus()
							},
							onMouseEnter: this.handleMouseEnterSelectedOptionComponent,
							onMouseLeave: this.handleMouseLeaveSelectedOptionComponent,
							maxLength: this.props.maxLength,
							innerRef: s === this.props.options.length - 1 ? this.lastSelectedOptionComponentRef : void 0
						})
					}), n && i.a.createElement("span", {
						className: E.a.optionsOverflowIndication
					}, `+${this.props.options.length-(this.props.maxOptionsToDisplay||0)}`), this.props.children, !Object(x.c)(this.props.readOnlyMode) && i.a.createElement("input", {
						className: Object(a.a)(E.a.input, {
							[E.a.hiddenInput]: Object(x.b)(this.props.readOnlyMode)
						}),
						ref: this.inputRef,
						type: "text",
						onKeyDown: this.handleKeyPress,
						value: this.props.value,
						onChange: this.props.onInputChanged,
						maxLength: this.props.maxLength
					}), this.props.isLoading && i.a.createElement(v.a, {
						className: E.a.loadingIcon,
						sizePx: C
					}), this.state.isFocused && i.a.createElement(p, {
						className: this.props.dropdownClassName,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						selectableOptions: this.props.selectableOptions,
						onOptionsChanged: this.props.onOptionsChanged,
						ref: this.props.dropdownRef,
						currentInput: this.props.value,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						splitOnCommaPress: this.props.splitOnCommaPress
					}))
				}
			}
			var I = n("./node_modules/reselect/es/index.js");
			const S = [],
				w = {};
			class T extends i.a.Component {
				constructor(e) {
					super(e), this._selectableOptionsSelector = Object(I.a)(e => e.availableOptions || S, e => e.input, (e, t) => e.filter(e => {
						const n = e.displayText.toLowerCase(),
							s = t.toLowerCase();
						return 0 === n.indexOf(s) || r()(n.split(/[\s\/]+/), e => 0 === e.indexOf(s))
					})), this.onSearchBarFocus = () => {
						Object(x.c)(this.props.readOnlyMode) || this.state.searchBarIsFocused || (this.setState({
							searchBarIsFocused: !0
						}), this.props.onSearchBarFocus && this.props.onSearchBarFocus())
					}, this.onSearchBarBlur = e => {
						if (!Object(x.c)(this.props.readOnlyMode)) return e.relatedTarget && this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.matchesDOMElement(e.relatedTarget) ? (e.stopPropagation(), e.preventDefault(), void setTimeout(() => {
							this.optionSearchBarRef.current && this.optionSearchBarRef.current.focus()
						}, 0)) : (this.setState({
							searchBarIsFocused: !1
						}), void(this.props.onSearchBarBlur && this.props.onSearchBarBlur(e)))
					}, this.setInput = e => {
						Object(x.b)(this.props.readOnlyMode) || this.props.input !== e && this.props.onInputChanged(e)
					}, this.onOptionChanged = e => {
						this.onOptionsChanged([e])
					}, this.onOptionsChanged = e => {
						this.props.onOptionsChanged(e), r()(e, e => !!e.selected) && this.setInput("")
					}, this.onInputChanged = e => {
						Object(x.b)(this.props.readOnlyMode) || this.setInput(e.currentTarget.value)
					}, this.onKeyDown = e => {
						Object(x.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handleKeyPress(e)
					}, this.onPaste = e => {
						Object(x.b)(this.props.readOnlyMode) || this.optionsListDropdownRef.current && this.optionsListDropdownRef.current.handlePaste(e)
					}, this.state = {
						searchBarIsFocused: !1
					}, this.optionsListDropdownRef = i.a.createRef(), this.optionSearchBarRef = i.a.createRef()
				}
				getSelectableOptions() {
					return this._selectableOptionsSelector(this.props)
				}
				render() {
					const {
						childClassNames: e = w
					} = this.props;
					return i.a.createElement("div", {
						className: this.props.className,
						onKeyDown: this.onKeyDown,
						onPaste: this.onPaste
					}, i.a.createElement(k, {
						className: e.searchBarClassName,
						dropdownClassName: e.optionsListDropdownClassName,
						isError: this.props.isError,
						readOnlyMode: this.props.readOnlyMode || x.a.editable,
						isLoading: this.props.isLoading,
						ref: this.optionSearchBarRef,
						options: this.props.selectedOptions,
						onFocus: this.onSearchBarFocus,
						onBlur: this.onSearchBarBlur,
						onOptionsChanged: this.onOptionsChanged,
						onInputChanged: this.onInputChanged,
						maxLength: this.props.maxOptionLength,
						maxOptionsToDisplay: this.props.maxOptionsToDisplay,
						value: this.props.input,
						dropdownHeaderText: this.props.dropdownHeaderText,
						addText: this.props.addText,
						allowFreeTextEntry: this.props.allowFreeTextEntry,
						selectableOptions: this.getSelectableOptions(),
						dropdownRef: this.optionsListDropdownRef,
						selectedOptionComponent: this.props.selectedOptionComponent,
						splitOnCommaPress: this.props.splitOnCommaPress
					}, this.props.children))
				}
			}
			t.a = T
		},
		"./src/reddit/components/MutedUserList/ExpandedComponent.m.less": function(e, t, n) {
			e.exports = {
				BannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				bannedBy: "_2004IKQq9AjT3xoiDBg7m_",
				EmptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				emptyState: "_1O-zxip2q_mFxBe_WVFPZC",
				ExpandedContainer: "_1EEdKUOD4OiTBBQQkot-L9",
				expandedContainer: "_1EEdKUOD4OiTBBQQkot-L9"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less": function(e, t, n) {
			e.exports = {
				PrimaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				primaryButton: "_16-AoomiQ2Zxycd1wA0ZL-",
				ModalText: "_3P1niYqJc2au-fmA-xIl7i",
				modalText: "_3P1niYqJc2au-fmA-xIl7i"
			}
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/subredditModeration/mute.ts"),
				l = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/TextButton/index.tsx"),
				f = n("./src/reddit/helpers/isValidUsername/index.tsx"),
				h = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				_ = n("./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.m.less"),
				g = n.n(_);
			const v = 300,
				x = Object(i.b)(null, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						onMuteUser: (t, s) => e(Object(c.a)(n, t, s))
					}
				}),
				O = d.a.wrapped(p.l, "PrimaryButton", g.a),
				E = d.a.wrapped(u.p, "ModalText", g.a);
			class y extends o.a.Component {
				constructor(e) {
					super(e), this.onUsernameChange = e => {
						this.setState({
							username: e.currentTarget.value
						})
					}, this.onReasonChange = e => {
						this.setState({
							reason: e.currentTarget.value
						})
					}, this.onSubmit = () => {
						const e = this.state.username;
						this.props.onMuteUser(e, this.state.reason), this.props.trackAddEvent(), this.props.toggleModal()
					}, this.state = {
						username: this.props.username || "",
						reason: ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement(u.e, null, o.a.createElement(u.i, null, o.a.createElement(h.a, null, o.a.createElement(u.q, null, s.fbt._("Mute user", null, {
						hk: "326ljo"
					}), e.username && `: u/${e.username}`), o.a.createElement(b.a, {
						onClick: e.toggleModal
					}, o.a.createElement(u.b, null)))), o.a.createElement(u.l, null, !e.username && o.a.createElement(u.h, null, o.a.createElement(m.d, {
						autoFocus: !0,
						placeholder: s.fbt._("Username to mute", null, {
							hk: "3GB7UW"
						}),
						onChange: this.onUsernameChange,
						value: this.state.username,
						"data-redditstyle": !0
					})), o.a.createElement(u.h, null, o.a.createElement(E, null, s.fbt._("Note about why they are muted", null, {
						hk: "12YIn5"
					})), o.a.createElement(u.f, null, s.fbt._("Only visible to other moderators. Not visible to user", null, {
						hk: "4Ahum2"
					}))), o.a.createElement(u.t, {
						maxLength: v,
						onChange: this.onReasonChange,
						placeholder: s.fbt._("Reason they were muted", null, {
							hk: "3E29Hf"
						}),
						value: this.state.reason,
						"data-redditstyle": !0
					}), o.a.createElement(l.a, {
						maxChars: v,
						text: this.state.reason
					})), o.a.createElement(u.g, null, o.a.createElement(u.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(O, {
						onClick: this.onSubmit,
						"data-redditstyle": !0,
						disabled: !e.username && !Object(f.a)(t.username)
					}, s.fbt._("Mute user", null, {
						hk: "1z1Ss8"
					}))))
				}
			}
			t.default = Object(a.a)(x(y))
		},
		"./src/reddit/components/MutedUserList/MuteUserModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~CommentsPage~ModerationPages~Reddit~reddit-components-ClassicPost~reddit-components-CompactP~d737df3e"), n.e("vendors~CommentsPage~Governance~ModListing~ModerationPages~Reddit~Subreddit"), n.e("vendors~ModerationPages"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~1fdd9b9b"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~GovernanceReleaseNotesModal~ModerationPages~Multired~4b0513d5"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("ModerationPages")]).then(n.bind(null, "./src/reddit/components/MutedUserList/MuteUserModal/_MuteUserModal.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/MutedUserList/index.m.less": function(e, t, n) {
			e.exports = {
				MuteIcon: "XHViv8EEjdjsATc3T66r9",
				muteIcon: "XHViv8EEjdjsATc3T66r9"
			}
		},
		"./src/reddit/components/MutedUserList/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditModeration/mute.ts"),
				m = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				p = n("./src/reddit/components/HumanDate/index.tsx"),
				b = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				f = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				h = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				_ = n("./src/reddit/components/Scroller/Simple.tsx"),
				g = n("./src/reddit/components/SubredditModerationSearch/index.tsx"),
				v = n("./src/reddit/components/SubredditModerationTopBar/index.tsx"),
				x = n("./src/reddit/components/SubredditModerationUserItem/index.tsx"),
				O = n("./src/reddit/controls/Button/index.tsx"),
				E = n("./src/reddit/icons/fonts/index.tsx"),
				y = n("./src/reddit/models/SubredditModeration/index.ts"),
				C = n("./src/reddit/selectors/activeModalId.ts"),
				j = n("./src/reddit/selectors/muted.ts"),
				k = n("./src/reddit/components/MutedUserList/ExpandedComponent.m.less"),
				I = n.n(k),
				S = n("./src/lib/lessComponent.tsx");
			const {
				fbt: w
			} = n("./node_modules/fbt/lib/FbtPublic.js"), T = S.a.span("BannedBy", I.a), N = S.a.span("EmptyState", I.a), P = S.a.div("ExpandedContainer", I.a);
			var R = e => i.a.createElement(P, null, e.reason ? i.a.createElement(T, null, w._("Mod note {mutedByUsername}", [w._param("mutedByUsername", e.mutedBy)], {
					hk: "15D34v"
				})) : i.a.createElement(N, null, w._("No mod note.", null, {
					hk: "3rpIuv"
				})), e.reason),
				A = n("./src/reddit/components/MutedUserList/MuteUserModal/index.tsx"),
				M = n("./src/reddit/components/MutedUserList/index.m.less"),
				L = n.n(M);
			const D = 24,
				F = Object(d.c)({
					isAddUserModalOpen: e => "ModerationPage--Modal--AddUser" === Object(C.a)(e),
					isConfirmModalOpen: e => "ModerationPage--Modal--RemoveUserConfirmation" === Object(C.a)(e),
					loadMoreToken: j.d,
					mutedUsers: j.g,
					mutedUsersListPending: j.c,
					searchPending: j.e,
					searchResult: j.f
				}),
				U = Object(a.b)(F, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						loadMore: t => e(Object(u.b)(n, {
							after: t
						})),
						searchForMutedUser: t => e(Object(u.c)(n, t)),
						toggleAddUserModal: () => e(Object(l.i)("ModerationPage--Modal--AddUser")),
						toggleUnmuteUserModal: () => e(Object(l.i)("ModerationPage--Modal--RemoveUserConfirmation")),
						unmuteUser: t => () => e(Object(u.d)(n, t))
					}
				});
			class B extends i.a.Component {
				constructor(e) {
					super(e), this.onSearch = e => {
						this.props.searchForMutedUser(e), this.props.sendEventWithName("search_done")(), this.setState({
							searchTerm: e
						})
					}, this.cancelSearch = () => this.setState({
						searchTerm: null
					}), this.unmuteToggled = (e, t) => () => {
						this.setState({
							userId: e,
							username: t
						}), this.props.sendEventWithName("edit_user")(), this.props.toggleUnmuteUserModal()
					}, this.onLoadMore = () => {
						this.props.loadMoreToken && this.props.loadMore(this.props.loadMoreToken)
					}, this.muteUser = () => {
						this.props.toggleAddUserModal(), this.props.sendEventWithName("mute_dialog_mutepage")()
					}, this.renderMutedUser = e => i.a.createElement(x.b, {
						description: e.reason,
						expandedComponent: i.a.createElement(R, {
							mutedBy: e.mutedBy,
							reason: e.reason
						}),
						pageName: c.mc.Muted,
						primaryButton: i.a.createElement(O.r, {
							onClick: this.unmuteToggled(e.id, e.username)
						}, r.fbt._("Unmute", null, {
							hk: "334kKM"
						})),
						subredditId: this.props.subredditId,
						timeAgo: i.a.createElement(p.d, {
							seconds: e.mutedAtUTC
						}),
						userIcon: e.accountIcon,
						username: e.username
					}), this.renderMuteUserModal = () => i.a.createElement(A.a, {
						ignoreDefaultFocus: !0,
						trackAddEvent: this.props.sendEventWithName("add_mutepage"),
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						withOverlay: !0
					}), this.state = y.a
				}
				render() {
					const {
						props: e,
						state: t
					} = this, {
						mutedUsers: n
					} = e;
					let o;
					return n.length && (o = n[n.length - 1].id), e.mutedUsers.length ? i.a.createElement(i.a.Fragment, null, i.a.createElement(h.c, null, i.a.createElement(O.l, {
						onClick: this.muteUser
					}, r.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), i.a.createElement(h.a, null, i.a.createElement(h.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), i.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), i.a.createElement(v.b, {
						onSearch: this.onSearch,
						activeSearchQuery: t.searchTerm
					}), t.searchTerm ? i.a.createElement(g.a, {
						cancelSearch: this.cancelSearch,
						searchPending: e.searchPending,
						searchTerm: t.searchTerm,
						noResultsFound: !e.searchResult
					}, e.searchResult && this.renderMutedUser(e.searchResult)) : i.a.createElement(_.b, {
						loadMoreToken: o,
						onLoadMore: this.onLoadMore
					}, e.mutedUsers.map((e, t) => ({
						estHeight: D,
						id: e.id,
						render: () => this.renderMutedUser(e)
					})))), e.isAddUserModalOpen && this.renderMuteUserModal(), e.isConfirmModalOpen && t.userId && t.username && i.a.createElement(m.a, {
						actionText: r.fbt._("Unmute", null, {
							hk: "334kKM"
						}),
						modalText: r.fbt._("Are you sure you want to unmute {username}?", [r.fbt._param("username", t.username)], {
							hk: "2Pq8hv"
						}),
						onConfirm: e.unmuteUser(t.userId),
						toggleModal: e.toggleUnmuteUserModal,
						trackClick: e.sendEventWithName("remove"),
						withOverlay: !0
					})) : i.a.createElement(i.a.Fragment, null, i.a.createElement(h.c, null, i.a.createElement(O.l, {
						onClick: this.muteUser
					}, r.fbt._("Mute user", null, {
						hk: "4AJ7nf"
					}))), i.a.createElement(h.a, null, i.a.createElement(h.b, null, r.fbt._("Muted users", null, {
						hk: "2kc6Jt"
					}), i.a.createElement(f.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360009161872`
					})), e.mutedUsersListPending ? i.a.createElement(x.a, null) : i.a.createElement(b.c, {
						text: r.fbt._("No muted users in {subredditName}", [r.fbt._param("subredditName", e.subreddit.displayText)], {
							hk: "1o0lOP"
						})
					}, i.a.createElement(E.a, {
						name: "mod_mute",
						className: L.a.MuteIcon
					})), e.isAddUserModalOpen && this.renderMuteUserModal()))
				}
			}
			t.a = U(B)
		},
		"./src/reddit/components/NotificationUnit/Loader.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = Object(s.a)({
				resolved: {},
				chunkName: () => "NotificationUnit",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("NotificationUnit").then(n.bind(null, "./src/reddit/components/NotificationUnit/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/NotificationUnit/index.tsx"
				}
			});
			t.a = r
		},
		"./src/reddit/components/NotificationUnit/Placeholder.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/NotificationUnit/index.m.less"),
				i = n.n(o);
			const a = () => r.a.createElement("li", {
					className: i.a.placeholderWrapper
				}, r.a.createElement("span", {
					className: i.a.placeholderAvatar
				}), r.a.createElement("span", {
					className: i.a.placeholderContent
				})),
				d = () => r.a.createElement("ol", null, r.a.createElement(a, null), r.a.createElement(a, null), r.a.createElement(a, null))
		},
		"./src/reddit/components/NotificationUnit/index.m.less": function(e, t, n) {
			e.exports = {
				notificationItem: "_3mUSJN4kdLCGjq-K-JLJw",
				unread: "_2n4UrzwZ3VBdRmFUYAHF_9",
				isNightMode: "_3ds5pVvIyBrh1GgQ2O7AFd",
				contextContainer: "_3T3J7R8JnlSfiFdB5bxe5h",
				link: "_1tpiOc0IxpDU113wUs4zi1",
				inAppNotification: "_3U799isaNx88b2pVv1S7m1",
				avatarContainer: "_2WN4-UdVoyjpLQ8mpNTQA",
				avatar: "_12V0IULSx8mSJHxdpHwOGE",
				nsfwAvatar: "_1Bzw8F6BC4Vk8OzAgnU0z3",
				notificationIconContainer: "_3smo-GSstogGTGh6ArpwI0",
				NotifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				notifIcon: "OzS9DxR-g3V71ZAeo2lbH",
				RedditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				redditorIcon: "_23rEnykeBXjpsB9b72y8_1",
				Separator: "_1caKsZ5CCRPSfIgoh608Ej",
				separator: "_1caKsZ5CCRPSfIgoh608Ej",
				topBar: "_3mGSd8RyCZhF_eqyrV_Bvk",
				TitleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				titleWrapper: "_3D7vaSdKwBK4pdvYmH0ib",
				title: "_180jOSBDwwE60X5UR8zt3-",
				"m-tooltip": "_2a8MIP8QlMF7KPqTup62Vt",
				mTooltip: "_2a8MIP8QlMF7KPqTup62Vt",
				timeAgo: "_2fQXbzOYQuzqlwMzxgtBKH",
				menuButton: "_8Q653FSGz7lD9Ux0AQsXY",
				isOpen: "WHFiF_asC8mzlevTdJv26",
				MenuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				menuIcon: "_2oVe02cXZA6mJa7WXHJFi5",
				contentContainer: "_3Q_e75oXJ8meqWwAQS36l2",
				body: "_2VDnxV3G5ZvEDq10Z-_fM9",
				ButtonIcon: "_25ecrisK-bGTesa4kIqyHR",
				buttonIcon: "_25ecrisK-bGTesa4kIqyHR",
				ReplyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				replyButtonIcon: "_1wAIwQaxmGHWzaHv-8jex_",
				notificationButton: "_3doOacPPJ-LU-aBSoLl9TV",
				isFullWidth: "_36xH7NkS9uRrlN87iMo6Bw",
				isUnread: "_2svu3lh5YfWQmYfACdB2J5",
				replyIcon: "_3LbCSOW9yuZK_CHzTuR9M5",
				postIcon: "_102yZEdZMcXLlu2Ri0KD9O",
				postEmbedContainer: "_1cndvAxAFPMUr8IaWuw_we",
				postEmbedContent: "_2fsQOzhZpW9XNu1RXtgzqW",
				deleted: "LypGzp3NJwjpkpsRn9Ocn",
				postEmbedTitleContainer: "_2XT3C7unUlQXgaiyeYfIYv",
				postEmbedTitle: "_1SZwyv3jy4dBipT0yC1CcI",
				postEmbedMeta: "_1LcCO3y9JhylZFlKsgvzHs",
				postEmbedBlurredThumbnailContainer: "_2EmrjrpYxkgB5_ljritGbO",
				postEmbedThumbnail: "msJLWFmahK0W8JhaqYny9",
				postEmbedThumbnailBase: "_3CGVcVQDu97m9Oj_xs0n01",
				postEmbedBlurredThumbnail: "_2a0rc3KL05PEnGmVWcQI8W",
				postEmbedNSFWThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				postEmbedNsfwThumbnailIndicator: "_2q-yvZHWG3Xp2YECYCI09S",
				WarningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				warningIcon: "_2PzKGDccrg-BWzhhzJaJTs",
				StyledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				styledDropdown: "_1i_9WvxHOe7AlJZQ6w_-X9",
				overflowMenuContainer: "_2UKt6pQu-os9uxZnfhPydP",
				overflowMenuOption: "_1g8x_Z2KsTf65RBk7dRBZm",
				placeholderWrapper: "_2iacm7sPgvO9z8gO1W7FoY",
				placeholderAvatar: "_2_cDiTNVpitX7CtTmIambB",
				placeholderContent: "_2KpinIkIJ7VxNGQgUgzJCA",
				glimmer: "_27pfB7o_o_4F4TdujFhrNO",
				PostUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				postUnavailableInfo: "_2lh6HxiG9gd6MKnaAag9Cu",
				StateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				stateIcon: "_2RPeGp2zLx2hBQTZWSUTQK",
				Text: "_2bba9zuFqUwxMhGdswkU86",
				text: "_2bba9zuFqUwxMhGdswkU86"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.m.less": function(e, t, n) {
			e.exports = {
				RecommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				recommendationContextStyles: "nAL34ZVf4KfyEoZIzUgmN",
				classicLayout: "_3gsfwiq-rM6zSz9YoMlnJ0",
				compactLayout: "_9huHAs0mdMzeF-pUhJbwX",
				largeLayout: "_3hWVRt6y8PqOoC2VuZETZI"
			}
		},
		"./src/reddit/components/OneFeed/PostRecommendationContext.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/objectSelector/index.ts"),
				a = n("./src/reddit/components/RichTextJson/index.tsx"),
				d = n("./src/reddit/constants/postLayout.ts"),
				c = n("./src/reddit/hooks/useRecommendationPostContext.ts"),
				l = n("./src/reddit/components/OneFeed/PostRecommendationContext.m.less"),
				u = n.n(l);
			const m = Object(i.b)(e => ({
				renderingObjectInfo: e
			}));
			t.a = e => {
				let {
					content: t,
					layout: n,
					post: s
				} = e;
				return Object(c.a)().hideRecommendationContext ? null : r.a.createElement(a.b, {
					className: Object(o.a)(u.a.RecommendationContextStyles, {
						[u.a.classicLayout]: n === d.g.Classic,
						[u.a.compactLayout]: n === d.g.Compact,
						[u.a.largeLayout]: n === d.g.Large
					}),
					content: t,
					rtJsonElementProps: m(s),
					useExplicitTextColor: !0
				})
			}
		},
		"./src/reddit/components/OverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				_Dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				dropdown: "ehsOqYO6dxn_Pf9Dzwu37",
				MenuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				menuButton: "_2pFdCpgBihIaYh9DSMWBIu",
				mIsEnabled: "uMPgOFYlCc5uvpa2Lbteu",
				MenuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				menuIcon: "_38GxRFSqSC-Z2VLi5Xzkjy",
				DropdownRow: "_2DO72U0b_6CUw3msKGrnnT",
				dropdownRow: "_2DO72U0b_6CUw3msKGrnnT"
			}
		},
		"./src/reddit/components/OverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return E
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.tsx"),
				p = n("./src/reddit/controls/Dropdown/Row.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/selectors/tooltip.ts"),
				h = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				_ = n("./src/reddit/components/OverflowMenu/index.m.less"),
				g = n.n(_);
			const v = c.a.wrapped(m.a, "_Dropdown", g.a),
				x = Object(u.a)(v),
				O = c.a.button("MenuButton", g.a),
				E = c.a.wrapped(p.b, "DropdownRow", g.a),
				y = Object(a.c)({
					dropdownIsOpen: (e, t) => {
						let {
							dropdownId: n
						} = t;
						return Object(f.b)(n)(e)
					}
				}),
				C = Object(i.b)(y, (e, t) => {
					let {
						dropdownId: n
					} = t;
					return {
						toggleDropdown: () => e(Object(l.h)({
							tooltipId: n
						}))
					}
				}),
				j = e => t => {
					e.onClick && e.onClick(), e.toggleDropdown(), t.stopPropagation()
				};
			t.b = C(e => o.a.createElement(O, {
				"aria-expanded": e.dropdownIsOpen,
				"aria-haspopup": !0,
				"aria-label": s.fbt._("more options", null, {
					hk: "2EnY1x"
				}),
				className: Object(d.a)(e.className, {
					[g.a.mIsEnabled]: !e.disabled && !e.defaultButtonOutline
				}),
				disabled: e.disabled,
				onClick: j(e),
				onMouseDown: e.handleMouseDown,
				id: e.dropdownId,
				"data-adclicklocation": h.b.OVERFLOW_MENU
			}, e.icon ? e.icon : o.a.createElement(b.a, {
				name: "overflow_horizontal",
				className: g.a.MenuIcon
			}), o.a.createElement(x, {
				className: e.dropdownClassName,
				isOpen: e.dropdownIsOpen,
				tooltipId: e.dropdownId,
				isFixed: e.isFixed,
				targetPosition: e.targetPosition,
				tooltipPosition: e.tooltipPosition,
				style: e.style
			}, e.children)))
		},
		"./src/reddit/components/OverlayAwareTooltip/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/asTooltip.tsx"),
				i = n("./src/reddit/constants/elementIds.ts"),
				a = n("./src/reddit/contexts/InsideOverlay.tsx");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function c(e, t) {
				const n = Object(o.a)(e, t);
				class s extends r.a.PureComponent {
					constructor() {
						super(...arguments), this.state = {
							container: null
						}
					}
					componentDidMount() {
						if (this.props.isOverlay) {
							const e = document.getElementById(i.e);
							this.setState({
								container: e
							})
						}
					}
					render() {
						return r.a.createElement(n, d({}, this.props, {
							container: this.state.container || this.props.container,
							excludeContainerPosition: this.props.isOverlay
						}))
					}
				}
				return Object(a.b)(s)
			}
		},
		"./src/reddit/components/Paginator/index.m.less": function(e, t, n) {
			e.exports = {
				controlRow: "_2ixigr45sqDsYvVlMBgbMm",
				nextButtonContainer: "CloCv22o0KvzOk8LzB4VX",
				prevButtonContainer: "_2Tfdm_mlb1NvgbaCCkMtdV",
				nextButton: "_1VFGYMJpiKtL_S9_RYS-CD",
				prevButton: "eX92mTA_HDG9gpfIzIGhs"
			}
		},
		"./src/reddit/components/Poll/PollExpiry/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/HumanDate/index.tsx"),
				o = n("./src/lib/timeUntil/index.ts"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");

			function c(e) {
				const t = new Date(e.poll.endsAt).getTime() - Date.now() <= 0;
				return a.a.createElement("span", {
					className: e.className
				}, t ? d._("Voting closed {timeAgo}", [d._param("timeAgo", a.a.createElement(r.d, {
					seconds: e.poll.endsAt / s.Xb
				}))], {
					hk: "3OERID"
				}) : Object(o.a)(new Date(e.poll.endsAt)))
			}
		},
		"./src/reddit/components/Poll/PostTitleMetaData/index.m.less": function(e, t, n) {
			e.exports = {
				proposalMetaData: "_3yYOHq_rWQcgaR_pinEQU7",
				proposalExpiry: "_1poH87fXNrjNu84jKXBtun"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.m.less": function(e, t, n) {
			e.exports = {
				backgroundWrapper: "_1poyrkZ7g36PawDueRza-J",
				badge: "_1lLKAbRNH1mm32sVm7yCzQ"
			}
		},
		"./src/reddit/components/PostBackgroundWrapper/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				a = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				d = n("./src/higherOrderComponents/withAdClickLocation/index.tsx"),
				c = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				l = n("./src/reddit/components/PostBackgroundWrapper/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(d.a)(Object(i.a)(e => {
				const {
					children: t,
					className: n,
					flairStyleTemplate: s,
					onClick: i,
					post: d,
					redditStyle: l,
					theme: p,
					overrideBackgroundColor: b,
					...f
				} = e;
				return r.a.createElement("div", m({
					className: Object(o.a)(u.a.backgroundWrapper, n),
					style: b || Object(a.c)(s, e),
					onClick: i,
					"data-adclicklocation": c.a.BACKGROUND
				}, f), t)
			}))
		},
		"./src/reddit/components/PostBadges/index.m.less": function(e, t, n) {
			e.exports = {
				adminIcon: "_1cje4rrmwL0yZgCOlGyBJ-",
				approveIcon: "_1knR9NIIXdSFC9IeFN11JL",
				automoderator: "_2etEb_0bRB9axAqF3uX28S",
				icon: "_3vju76MdF2FaGmELBeiJ_r",
				lockIcon: "_3wTfn3Meg1rXJ-qd2jUWMt",
				modIcon: "_SMl46gACTEszA_4A0Qfs",
				removeIcon: "_3yuF1RnBRJL4OS_STsoXcC",
				reportIcon: "_3guZWUAROueft8TPPGDZ-R",
				spamIcon: "_2BWw37nLL0rX6n7xcXciyD",
				stickyIcon: "NI8uZ-19oHf9gPO8jOvFu",
				addRemovalReason: "COGitU-ItwLZG_fP5rsdE",
				isRemoved: "_27iLVqax1FuPWTymkSkKAq",
				archivedIcon: "_2WSiH2JwZq4bXuvrDn-cgU",
				removalReason: "_16Ih3bzeELRlI6AWeW-nFy"
			}
		},
		"./src/reddit/components/PostBadges/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/reddit/actions/tooltip.ts"),
				u = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				m = n("./src/reddit/components/RestrictedFlatlistButton/index.tsx"),
				p = n("./src/reddit/constants/posts.ts"),
				b = n("./src/reddit/contexts/PageLayer/index.tsx"),
				f = n("./src/reddit/helpers/isRemoved.ts"),
				h = n("./src/reddit/helpers/modTooltipTemplates/index.ts"),
				_ = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				g = n("./src/reddit/icons/fonts/index.tsx"),
				v = n("./src/reddit/icons/fonts/Approve/index.tsx"),
				x = n("./src/reddit/icons/fonts/Archived/index.tsx"),
				O = n("./src/reddit/icons/fonts/Lock/index.tsx"),
				E = n("./src/reddit/icons/fonts/Remove/index.tsx"),
				y = n("./src/reddit/icons/fonts/Report/index.tsx"),
				C = n("./src/reddit/icons/fonts/Spam/index.tsx"),
				j = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				k = n("./src/reddit/models/Post/index.ts"),
				I = n("./src/reddit/selectors/modQueue.ts"),
				S = n("./src/reddit/selectors/posts.ts"),
				w = n("./src/reddit/components/PostBadges/index.m.less"),
				T = n.n(w);

			function N() {
				return (N = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const P = e => o.a.createElement("span", N({
					className: T.a.removalReason
				}, e), e.children),
				R = () => s.fbt._("Archived", null, {
					hk: "zv3q3"
				}),
				A = () => s.fbt._("Comments are locked", null, {
					hk: "8HjJ9"
				}),
				M = e => s.fbt._("Moderator of {community name}", [s.fbt._param("community name", e)], {
					hk: "nJqIB"
				}),
				L = () => s.fbt._("Stickied post", null, {
					hk: "3qSaBs"
				}),
				D = () => s.fbt._("Pinned post", null, {
					hk: "2oxErI"
				}),
				F = (e, t, n) => {
					const s = `PostBadges--${e}--${t}`;
					return n ? `${s}--${n}` : s
				},
				U = Object(b.v)({
					isProfilePostListing: b.N,
					isSubreddit: b.Q
				}),
				B = Object(a.c)({
					isModQueueDisplayEnabled: I.b,
					isPinned: (e, t) => {
						let {
							post: n
						} = t;
						return Object(S.q)(e, {
							postId: n.id
						})
					},
					modModeEnabled: b.W
				}),
				q = Object(i.b)(B, (e, t) => ({
					onHideTooltip: () => e(Object(l.i)()),
					onOpenRemovalReasonModal: () => {
						n.e("removalReasonActions").then(n.bind(null, "./src/reddit/actions/removalReasons/index.ts")).then(n => e(n.fetchReasonsAndOpenModal(t.post.belongsTo.id, [t.post.id])))
					},
					onShowTooltip: t => () => e(Object(l.f)({
						tooltipId: t
					}))
				}));
			t.a = U(q(e => {
				let {
					className: t,
					displayText: n,
					isSubreddit: i,
					inSubredditOrProfile: a,
					isCompactPinnedPost: l,
					isPinned: b,
					isProfilePostListing: I,
					modModeEnabled: S,
					onHideTooltip: w,
					onOpenRemovalReasonModal: U,
					onShowTooltip: B,
					post: q,
					tooltipType: G,
					isModQueueDisplayEnabled: H
				} = e;
				const W = {
						caretOnTop: !1
					},
					V = q.isRemoved && !q.modRemovalReason && !q.modNote && q.belongsTo.type === p.a.SUBREDDIT,
					z = F("Approve", q.id, G),
					K = F("Archived", q.id, G),
					Q = F("Lock", q.id, G),
					Y = F("Mod", q.id, G),
					J = F("Remove", q.id, G),
					X = F("Report", q.id, G),
					Z = F("Spam", q.id, G),
					$ = F("Sticky", q.id, G),
					ee = F("Pinned", q.id, G);
				return o.a.createElement("div", {
					className: t
				}, a && n && q.distinguishType === c.J.MODERATOR && o.a.createElement(r.Fragment, null, o.a.createElement(g.a, {
					name: "mod",
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.modIcon)
				}), o.a.createElement(u.c, N({
					tooltipId: Y,
					text: M(n)
				}, W))), q.isArchived && o.a.createElement(r.Fragment, null, o.a.createElement(x.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.archivedIcon),
					desc: R(),
					id: K,
					onMouseEnter: B(K),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: K,
					text: R()
				}, W))), q.isLocked && !q.isSponsored && o.a.createElement(r.Fragment, null, o.a.createElement(O.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.lockIcon),
					desc: A(),
					id: Q,
					onMouseEnter: B(Q),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: Q,
					text: A()
				}, W))), i && Object(k.w)(q) && !l && o.a.createElement(r.Fragment, null, o.a.createElement(j.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.stickyIcon),
					desc: L(),
					id: $,
					onMouseEnter: B($),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: $,
					text: L()
				}, W))), I && b && o.a.createElement(r.Fragment, null, o.a.createElement(j.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.stickyIcon),
					desc: D(),
					id: ee,
					onMouseEnter: B(ee),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: ee,
					text: D()
				}, W))), !H && o.a.createElement(o.a.Fragment, null, (q.isApproved || q.approvedBy) && o.a.createElement(r.Fragment, null, o.a.createElement(v.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.approveIcon),
					desc: Object(h.a)(q),
					id: z,
					onMouseEnter: B(z),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: z,
					text: Object(h.a)(q)
				}, W))), Object(f.a)(q) && o.a.createElement(r.Fragment, null, o.a.createElement(E.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.removeIcon),
					desc: Object(h.b)(q),
					id: J,
					onMouseEnter: B(J),
					onMouseLeave: w
				}), V && o.a.createElement(m.a, {
					className: T.a.addRemovalReason,
					onClick: U,
					text: s.fbt._("Add a removal reason", null, {
						hk: "1YDo3"
					})
				}), (q.modRemovalReason || q.modNote) && o.a.createElement(P, {
					onMouseEnter: B(J),
					onMouseLeave: w
				}, s.fbt._("Removal reason", null, {
					hk: "2DhKVZ"
				})), o.a.createElement(u.c, N({
					tooltipId: J,
					text: Object(h.b)(q)
				}, W))), q.bannedBy && q.isSpam && o.a.createElement(r.Fragment, null, o.a.createElement(C.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.spamIcon),
					desc: Object(h.d)(q),
					id: Z,
					onMouseEnter: B(Z),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: Z,
					text: Object(h.d)(q)
				}, W)))), Object(_.a)(q) && !S && !H && o.a.createElement(r.Fragment, null, o.a.createElement(y.a, {
					isFilled: !0,
					className: Object(d.a)(T.a.icon, T.a.reportIcon),
					desc: Object(h.c)(q.numReports),
					id: X,
					onMouseEnter: B(X),
					onMouseLeave: w
				}), o.a.createElement(u.c, N({
					tooltipId: X,
					text: Object(h.c)(q.numReports)
				}, W))))
			}))
		},
		"./src/reddit/components/PostContainer/index.m.less": function(e, t, n) {
			e.exports = {
				WrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz",
				wrappedPost: "_1oQyIsiPHYt6nx7VOmd1sz"
			}
		},
		"./src/reddit/components/PostContainer/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return j
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/lib/ads/index.ts"),
				a = n("./src/reddit/components/AdViewability/index.tsx"),
				d = n("./src/reddit/helpers/trackers/gallery.ts"),
				c = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				l = n("./src/reddit/hooks/useTracking.ts");
			var u = r.a.memo(e => {
					const t = Object(s.useRef)(null),
						n = Object(l.a)(),
						o = Object(s.useCallback)(t => {
							t.forEach(t => {
								const {
									intersectionRatio: s
								} = t;
								s >= .5 && n(d.d(e.postId))
							})
						}, [n, e.postId]),
						i = Object(s.useMemo)(() => ({
							threshold: [.5]
						}), []);
					return Object(c.a)(t, o, i), r.a.createElement("div", {
						role: "presentation"
					}, r.a.createElement("div", {
						ref: t
					}, e.children))
				}),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/connectors/PostViewable/index.ts"),
				b = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/telemetry.ts"),
				_ = n("./src/lib/classNames/index.ts"),
				g = n("./src/lib/objectSelector/index.ts"),
				v = n("./src/higherOrderComponents/withClickTracking/index.tsx"),
				x = n("./src/higherOrderComponents/withAdClickLocation/index.tsx"),
				O = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				E = n("./src/reddit/components/PostContainer/index.m.less"),
				y = n.n(E);
			const C = Object(p.a)(() => Object(o.c)({
					basePixelMetadata: Object(g.a)((e, t) => {
						let {
							post: n
						} = t;
						return Object(f.b)(e, n.id)
					}),
					clickTrackingId: (e, t) => {
						let {
							post: n
						} = t;
						return n.id
					},
					imageGalleryCurrentItem: (e, t) => {
						let {
							post: n
						} = t;
						return Object(f.i)(e, {
							postId: n.id
						})
					},
					pageType: e => Object(h.d)(e).pageType
				})),
				j = "post-container";
			class k extends r.a.Component {
				constructor() {
					super(...arguments), this.cancelClick = !1
				}
				render() {
					const {
						afterClickTracking: e,
						basePixelMetadata: t,
						children: n,
						className: s,
						imageGalleryCurrentItem: o,
						makePostContainerId: c,
						post: l,
						onClick: m,
						pageType: p,
						sendEvent: f,
						style: h,
						ref: g,
						shouldAddGalleryViewability: v = !0
					} = this.props, x = r.a.createElement("div", {
						"data-click-id": this.props["data-click-id"],
						style: h,
						ref: g,
						onMouseUp: e => {
							0 !== window.getSelection().toString().length && (this.cancelClick = !0, window.setTimeout(() => {
								this.cancelClick = !1
							}, 1e3))
						},
						onClick: n => {
							if (!this.cancelClick && n.button < 2 && e(() => m && m(n, l, t, o, p))(n), l.id && o) {
								const {
									source: e
								} = Object(i.t)(l, o);
								e && e.outboundUrl && f(Object(d.c)(l.id, e.outboundUrl))
							}
						},
						className: Object(_.a)(y.a.WrappedPost, s, `Post ${l.id}`, {
							promotedlink: l.isSponsored
						}),
						"data-testid": j,
						id: c ? c(l.id) : l.id,
						tabIndex: -1,
						"data-adclicklocation": O.a.BACKGROUND
					}, n), E = !!l.media && l.media.type === b.o.VIDEO;
					return (e => l.media && Object(b.F)(l.media) && v ? r.a.createElement(u, {
						postId: l.id
					}, e) : e)((e => l.isSponsored || E ? r.a.createElement(a.a, {
						post: l,
						trackDisplay: !0
					}, e) : e)(x))
				}
			}
			t.b = C(Object(x.a)(Object(v.a)(Object(m.c)(k))))
		},
		"./src/reddit/components/PostContent/ViewCount.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/lib/prettyPrintNumber/index.ts"),
				c = n("./src/reddit/components/CreatorStats/helpers.ts"),
				l = n("./src/reddit/selectors/creatorStats.ts"),
				u = n("./src/reddit/components/PostContent/viewCount.m.less"),
				m = n.n(u);
			t.a = e => {
				let {
					className: t,
					post: n,
					showViewCount: r
				} = e;
				const {
					upvotePercentString: u,
					viewCountString: p
				} = (e => {
					const t = e.upvoteRatio ? Math.round(100 * e.upvoteRatio).toString() : "",
						n = Object(d.b)(e.viewCount);
					return {
						upvotePercentString: s.fbt._("{percent upvoted}% Upvoted", [s.fbt._param("percent upvoted", t)], {
							hk: "432tjJ"
						}),
						viewCountString: s.fbt._({
							"*": "{number of views} Views",
							_1: "1 View"
						}, [s.fbt._plural(e.viewCount, "number of views", n)], {
							hk: "rP01m"
						})
					}
				})(n), b = r && !!n.viewCount, f = Object(i.e)(e => Object(l.a)(e, n.id)), h = Object(i.e)(e => Object(l.c)(e, n.id)), _ = Object(c.c)(n, h), g = f && _ === c.b.Available;
				return o.a.createElement("div", {
					className: Object(a.a)(m.a.viewCounts, t)
				}, b && o.a.createElement("span", null, p), b && !!n.upvoteRatio && o.a.createElement("span", {
					className: m.a.dotSpacer
				}), !!n.upvoteRatio && !g && o.a.createElement("span", null, u))
			}
		},
		"./src/reddit/components/PostContent/viewCount.m.less": function(e, t, n) {
			e.exports = {
				dotSpacer: "_3g_cwSqBe5o5mAuhfMeGu5",
				viewCounts: "t4Hq30BDzTeJ85vREX7_M"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1IZotn_IQQ1fgtUjaFYbkd",
				onHoverActionText: "_1Zlk1VrZ8puYZy5lJOfz--",
				Container: "_1IZotn_IQQ1fgtUjaFYbkd",
				PostTitle: "_1hzDym_NpIlizkTDXc_rQj",
				postTitle: "_1hzDym_NpIlizkTDXc_rQj",
				MetaLine: "_67JuJTdFwIJPLPDkyPX-f",
				metaLine: "_67JuJTdFwIJPLPDkyPX-f",
				SubredditName: "_88OYON0K3w_tpnmCSWlUX",
				subredditName: "_88OYON0K3w_tpnmCSWlUX",
				InfoSpan: "_3DFfW-OG-MvCLiiEN18mpq",
				infoSpan: "_3DFfW-OG-MvCLiiEN18mpq"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				wrapper: "_1QvpnsvD_e--dvDTEcz7_w",
				TopRow: "vuQEtla32r0kemmh11Hov",
				topRow: "vuQEtla32r0kemmh11Hov",
				TitleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				titleRow: "_1eSyFPTFSsfyp8BVxs83PB",
				DetailsContainer: "_87UrrqUro4oVpXFAElZUX",
				detailsContainer: "_87UrrqUro4oVpXFAElZUX",
				ButtonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				buttonRow: "_1CUOht5hsM0AF9T3Ox1yos",
				CloseWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				closeWrapper: "_3OsXrjEdHgK1wJBfPX6IhR",
				Close: "_1TaKYhB80ExuTPoLaQZMRE",
				close: "_1TaKYhB80ExuTPoLaQZMRE",
				Empty: "_20K7F6rAgXGH5z83v7Ifiv",
				empty: "_20K7F6rAgXGH5z83v7Ifiv",
				EmptyImage: "_2eLeResic3Gc77W_edgNGt",
				emptyImage: "_2eLeResic3Gc77W_edgNGt",
				EmptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				emptyText: "_3t6VBoBsR8CGQvaPLHPjmW",
				FilterWrapper: "pKfhphFBuya82DYP2Q90X",
				filterWrapper: "pKfhphFBuya82DYP2Q90X",
				FilterInput: "_3W5cary86KmYWrVgEpGKPb",
				filterInput: "_3W5cary86KmYWrVgEpGKPb",
				SearchIcon: "_9T_dguVcd795c_vOyl9s4",
				searchIcon: "_9T_dguVcd795c_vOyl9s4",
				PlusIcon: "hfmgzmXCLe3hvSyZad9WP",
				plusIcon: "hfmgzmXCLe3hvSyZad9WP",
				CreateCollectionButton: "_34_h0zRV3AgFr_0sh99pKz",
				createCollectionButton: "_34_h0zRV3AgFr_0sh99pKz"
			}
		},
		"./src/reddit/components/PostCreationForm/CollectionListModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/higherOrderComponents/asModal/index.tsx"),
				l = n("./src/lib/memoizeByReference/index.ts"),
				u = n("./src/reddit/actions/postCreation/general.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/constants/keycodes.ts"),
				b = n("./src/reddit/controls/Button/index.tsx"),
				f = n("./src/reddit/controls/Input/index.tsx"),
				h = n("./src/reddit/icons/svgs/Close/index.tsx"),
				_ = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				g = n("./src/reddit/icons/svgs/Search/index.tsx"),
				v = n("./src/reddit/layout/row/Inline/index.tsx"),
				x = n("./src/reddit/models/PostCreationForm/index.ts"),
				O = n("./src/reddit/selectors/postCollection.ts"),
				E = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				y = n("./src/reddit/components/HumanDate/index.tsx"),
				C = n("./src/reddit/helpers/name/index.ts"),
				j = n("./src/reddit/models/Subreddit/index.ts"),
				k = n("./src/reddit/models/User/index.ts"),
				I = n("./src/reddit/selectors/subreddit.ts"),
				S = n("./src/reddit/selectors/user.ts"),
				w = n("./src/reddit/components/PostCreationForm/CollectionListModal/CollectionListItem/index.m.less"),
				T = n.n(w),
				N = n("./src/lib/lessComponent.tsx");
			const {
				fbt: P
			} = n("./node_modules/fbt/lib/FbtPublic.js"), R = N.a.div("Container", T.a), A = N.a.h2("PostTitle", T.a), M = N.a.div("MetaLine", T.a), L = N.a.span("SubredditName", T.a), D = N.a.time("InfoSpan", T.a), F = Object(d.c)({
				subreddit: (e, t) => {
					let {
						collection: {
							subredditId: n
						}
					} = t;
					return n ? Object(I.Y)(e, {
						subredditId: n
					}) : void 0
				},
				user: S.l
			});
			class U extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.onClick = () => {
						this.props.onClick(this.props.collection.id)
					}
				}
				render() {
					const {
						collection: e,
						subreddit: t,
						user: n,
						onHoverActionText: s
					} = this.props, r = t && Object(j.i)(t) && n ? Object(C.e)(Object(k.e)(n)) : t ? t.displayText : "", o = e.postIds.length;
					return i.a.createElement(R, {
						onClick: this.onClick,
						className: T.a.container
					}, i.a.createElement(A, {
						"data-redditstyle": !0
					}, e.title), i.a.createElement(M, {
						"data-redditstyle": !0
					}, r && i.a.createElement(L, {
						"data-redditstyle": !0
					}, r), r && i.a.createElement(E.b, null), i.a.createElement(D, null, P._({
						"*": "{number of posts} posts",
						_1: "1 post"
					}, [P._plural(o, "number of posts")], {
						hk: "1Uy96U"
					})), i.a.createElement(E.b, null), i.a.createElement(D, null, P._("created {time}", [P._param("time", i.a.createElement(y.d, {
						seconds: e.createdAtUTC
					}))], {
						hk: "2cUc5m"
					}))), s && i.a.createElement("div", {
						className: T.a.onHoverActionText
					}, i.a.createElement("span", null, s)))
				}
			}
			var B = Object(a.b)(F)(U),
				q = n("./src/reddit/helpers/trackers/postCollection.ts"),
				G = n("./src/reddit/components/PostCreationForm/CollectionListModal/index.m.less"),
				H = n.n(G);
			const W = `${s.a.assetPath}/img/snoo-drafts.png`,
				V = N.a.div("TopRow", H.a),
				z = N.a.div("TitleRow", H.a),
				K = N.a.div("DetailsContainer", H.a),
				Q = N.a.wrapped(v.a, "ButtonRow", H.a),
				Y = N.a.div("CloseWrapper", H.a),
				J = N.a.wrapped(h.a, "Close", H.a),
				X = N.a.div("Empty", H.a),
				Z = N.a.img("EmptyImage", H.a),
				$ = N.a.p("EmptyText", H.a),
				ee = N.a.div("FilterWrapper", H.a),
				te = N.a.wrapped(f.a, "FilterInput", H.a),
				ne = N.a.wrapped(g.a, "SearchIcon", H.a),
				se = N.a.wrapped(_.a, "PlusIcon", H.a),
				re = N.a.wrapped(b.p, "CreateCollectionButton", H.a),
				oe = Object(l.a)((e, t) => {
					const n = t.toLowerCase();
					return e.filter(e => e.title.toLowerCase().includes(n))
				}),
				ie = Object(d.c)({
					collections: O.v
				}),
				ae = Object(a.b)(ie, (e, t) => {
					let {
						postId: n,
						isOverlay: s
					} = t;
					return {
						onOpenCreateCollectionModal: () => {
							let t = x.b;
							n && (t = Object(x.u)(n, !!s)), e(Object(u.z)(t))
						}
					}
				});
			class de extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						filterStr: ""
					}, this.close = () => {
						this.props.sendEvent(Object(q.c)()), this.props.onClose()
					}, this.handleEscapeKey = e => {
						e.keyCode === p.a.Escape && this.close()
					}, this.handleCreateCollectionClicked = () => {
						this.props.onOpenCreateCollectionModal(), this.props.sendEvent(Object(q.j)())
					}, this.handleCollectionSelected = e => {
						this.props.onSelectCollection(e), this.props.sendEvent(Object(q.q)())
					}, this.onFilterStringChange = e => {
						this.setState({
							filterStr: e.target.value
						})
					}, this.renderItem = e => i.a.createElement(B, {
						key: e.id,
						collection: e,
						onClick: () => this.handleCollectionSelected(e),
						onHoverActionText: this.props.onItemHoverActionText
					})
				}
				componentDidMount() {
					document.addEventListener("keydown", this.handleEscapeKey), this.props.sendEvent(Object(q.d)())
				}
				componentWillUnmount() {
					document.removeEventListener("keydown", this.handleEscapeKey)
				}
				renderNoCollections() {
					return i.a.createElement(X, null, i.a.createElement(Z, {
						src: W
					}), i.a.createElement($, null, r.fbt._("Your collections will live here", null, {
						hk: "FCxWg"
					})))
				}
				renderNoFilterMatches() {
					return i.a.createElement(X, null, i.a.createElement($, null, r.fbt._("No collection matching filter", null, {
						hk: "2vawdK"
					}), ";"))
				}
				render() {
					const {
						collections: e,
						titleText: t
					} = this.props;
					let n;
					if (0 === e.length) n = this.renderNoCollections();
					else {
						const t = oe(e, this.state.filterStr);
						n = 0 === t.length ? this.renderNoFilterMatches() : t.map(this.renderItem)
					}
					return i.a.createElement("div", {
						className: H.a.wrapper,
						"data-redditstyle": !0
					}, i.a.createElement(V, null, i.a.createElement(z, {
						"data-redditstyle": !0
					}, t || r.fbt._("My collections", null, {
						hk: "3yKovS"
					}), i.a.createElement(Y, {
						onClick: this.close
					}, i.a.createElement(J, {
						"data-redditstyle": !0
					}))), i.a.createElement(ee, null, i.a.createElement(ne, null), i.a.createElement(te, {
						placeholder: r.fbt._("Find a collection", null, {
							hk: "3DbFBU"
						}),
						value: this.state.filterStr,
						onChange: this.onFilterStringChange
					}))), i.a.createElement(K, null, n), i.a.createElement(Q, null, i.a.createElement(re, {
						onClick: this.handleCreateCollectionClicked
					}, i.a.createElement(se, null), r.fbt._("Create a collection", null, {
						hk: "37xJVm"
					}))))
				}
			}
			const ce = Object(c.a)(ae(Object(m.c)(de)));
			t.a = ce
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less": function(e, t, n) {
			e.exports = {
				Container: "_3vV_tKesULQ5WMGh38lX4b",
				container: "_3vV_tKesULQ5WMGh38lX4b",
				Content: "_11JSvybbRhcX_cfoagpne_",
				content: "_11JSvybbRhcX_cfoagpne_",
				TitleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				titleRow: "_3Ev4JRxdS9-3GTBR5M1yCP",
				Details: "_3Uw02TWwSQhLfCJkPsihqr",
				details: "_3Uw02TWwSQhLfCJkPsihqr",
				Footer: "_25MDqXgOCWDBjtAEBi2cmy",
				footer: "_25MDqXgOCWDBjtAEBi2cmy",
				CancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				cancelButton: "_2tLOIj2nClBaVRuMBIJE8X",
				CloseWrapper: "_GVnqGyX40oKfgIS56Q-k",
				closeWrapper: "_GVnqGyX40oKfgIS56Q-k",
				CloseIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				closeIcon: "_1GgoANMMbLQJ-gSefDJZuZ",
				Label: "_3QPFKpxsmu6j_gbiAuVgfW",
				label: "_3QPFKpxsmu6j_gbiAuVgfW",
				TitleInput: "ZEfw7a99aHsmkl4fx38l5",
				titleInput: "ZEfw7a99aHsmkl4fx38l5",
				AddCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				addCollectionIcon: "_30BNMMyQPTPvHEoL3-LXrM",
				PrimaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				primaryActionButton: "_22f_S1XUre_FujBgOgEHJe",
				LoadingIcon: "_3cD2qECfUUTwega16qDhBc",
				loadingIcon: "_3cD2qECfUUTwega16qDhBc",
				ErrorText: "GIQ2YnBHQtY1QM1yPEhCR",
				errorText: "GIQ2YnBHQtY1QM1yPEhCR"
			}
		},
		"./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/formatApiError/index.ts"),
				l = n("./src/reddit/actions/postCollection/index.ts"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/constants/postCreation.ts"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/index.tsx"),
				f = n("./src/reddit/controls/Input/index.tsx"),
				h = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				_ = n("./src/reddit/icons/svgs/AddCollection/index.tsx"),
				g = n("./src/reddit/icons/svgs/Close/index.tsx"),
				v = n("./src/reddit/layout/row/Inline/index.tsx"),
				x = n("./src/reddit/selectors/postCollection.ts"),
				O = n("./src/reddit/components/PostCreationForm/CreateOrEditCollectionModal/index.m.less"),
				E = n.n(O),
				y = n("./src/lib/lessComponent.tsx");
			const C = y.a.div("Container", E.a),
				j = y.a.div("Content", E.a),
				k = y.a.div("TitleRow", E.a),
				I = y.a.div("Details", E.a),
				S = y.a.wrapped(u.g, "Footer", E.a),
				w = y.a.wrapped(p.o, "CancelButton", E.a),
				T = y.a.div("CloseWrapper", E.a),
				N = y.a.wrapped(g.a, "CloseIcon", E.a),
				P = y.a.label("Label", E.a),
				R = y.a.wrapped(f.a, "TitleInput", E.a),
				A = y.a.wrapped(_.a, "AddCollectionIcon", E.a),
				M = y.a.wrapped(p.l, "PrimaryActionButton", E.a),
				L = y.a.wrapped(h.a, "LoadingIcon", E.a),
				D = y.a.wrapped(b.b, "ErrorText", E.a),
				F = Object(a.c)({
					collection: x.q,
					error: x.c,
					isPending: x.g
				}),
				U = Object(i.b)(F, (e, t) => ({
					onCreate: (t, n) => e(Object(l.b)(t, n)),
					onUpdate: n => e(Object(l.h)(t.collectionId, n))
				}));
			class B extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onTitleChange = e => {
						this.setState({
							collectionTitle: e.target.value
						})
					}, this.onPrimaryButtonClick = async () => {
						const {
							collectionId: e,
							subredditId: t
						} = this.props, {
							collectionTitle: n
						} = this.state;
						if (e) {
							await this.props.onUpdate(n) && this.props.onCollectionUpdated && this.props.onCollectionUpdated()
						} else {
							const e = await this.props.onCreate(n, t);
							e && this.props.onCollectionCreated && this.props.onCollectionCreated(e)
						}
					}, this.onClose = () => {
						this.props.onCancel()
					};
					const {
						collection: t
					} = e;
					this.state = {
						collectionTitle: t ? t.title : ""
					}
				}
				render() {
					const {
						collectionId: e,
						error: t,
						isPending: n
					} = this.props, r = !e, i = !!this.state.collectionTitle.trim(), a = r ? s.fbt._("Create", null, {
						hk: "Ijp7n"
					}) : s.fbt._("Save", null, {
						hk: "4yMsMq"
					});
					return o.a.createElement(C, null, o.a.createElement(T, {
						onClick: this.props.onCancel
					}, o.a.createElement(N, null)), o.a.createElement(j, null, r && o.a.createElement(o.a.Fragment, null, o.a.createElement(k, null, o.a.createElement(A, null), s.fbt._("Create a collection", null, {
						hk: "3ndxk5"
					})), o.a.createElement(I, null, s.fbt._("Group posts into one feed. Create a series of events or just a group of random things. Make something awesome!", null, {
						hk: "2eCAQw"
					}))), o.a.createElement(P, null, r ? s.fbt._("Give a title for your collection", null, {
						hk: "Uaqbe"
					}) : s.fbt._("Edit title", null, {
						hk: "1jzweg"
					}), o.a.createElement(R, {
						maxLength: m.e,
						onChange: this.onTitleChange,
						placeholder: s.fbt._("Enter title", null, {
							hk: "3B0iRI"
						}),
						value: this.state.collectionTitle
					}))), o.a.createElement(S, null, o.a.createElement(v.a, null, o.a.createElement(w, {
						onClick: this.props.onCancel
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(M, {
						onClick: this.onPrimaryButtonClick,
						disabled: n || !i
					}, n ? o.a.createElement(L, {
						sizePx: 10
					}) : a)), t && o.a.createElement(D, null, Object(c.a)(t))))
				}
			}
			t.a = Object(d.a)(U(B))
		},
		"./src/reddit/components/PostCreationForm/MediaInput/ImageGalleryDrop/constants.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = 20,
				r = 180
		},
		"./src/reddit/components/PostFlairPicker/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/flair.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/models/Flair/index.ts");
			const d = e => (e || []).find(e => e.type === a.f.Text || e.type === a.f.Image || e.type === a.f.Richtext);
			var c;
			! function(e) {
				e[e.InvalidTemplate = 0] = "InvalidTemplate", e[e.NoChanges = 1] = "NoChanges", e[e.NotSelected = 2] = "NotSelected", e[e.TextIsNotAllowed = 3] = "TextIsNotAllowed", e[e.TextIsEmpty = 4] = "TextIsEmpty", e[e.TextIsTooLong = 5] = "TextIsTooLong"
			}(c || (c = {}));
			const l = (e, t, n) => {
				if (n && !t) return {
					canSave: !0
				};
				if (!t) return {
					canSave: !1,
					reason: c.NotSelected
				};
				const s = e && t.templateId ? e[t.templateId] : void 0;
				if (!s) return {
					canSave: !1,
					reason: c.InvalidTemplate
				};
				const a = Object(i.g)(t).length;
				return 0 === a ? {
					canSave: !1,
					reason: c.TextIsEmpty
				} : a > o.g ? {
					canSave: !1,
					reason: c.TextIsTooLong
				} : Object(i.n)(t) && !Object(i.r)(s) ? {
					canSave: !1,
					reason: c.TextIsNotAllowed
				} : r()(n, t) ? {
					canSave: !1,
					reason: c.NoChanges
				} : {
					canSave: !0
				}
			}
		},
		"./src/reddit/components/PostFlairPicker/index.m.less": function(e, t, n) {
			e.exports = {
				buttonsRow: "cF9DU_4WDAKS4gs43ct2_",
				clearButton: "_3vB6Y9PiwJ0YV6c9MGbDwT"
			}
		},
		"./src/reddit/components/PostFlairPicker/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return C
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/components/TrackingHelper/index.tsx"),
				l = n("./src/higherOrderComponents/asModal/index.tsx"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/components/FlairPickerTitle/index.tsx"),
				p = n("./src/reddit/components/FlairPickerWrapper/index.tsx"),
				b = n("./src/reddit/components/FlairPreview/index.tsx"),
				f = n("./src/reddit/components/FlairSearch/index.tsx"),
				h = n("./src/reddit/controls/Button/index.tsx"),
				_ = n("./src/reddit/helpers/trackers/postComposer.ts"),
				g = n("./src/reddit/models/Flair/index.ts"),
				v = n("./src/reddit/selectors/postFlair.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/components/PostFlairPicker/helpers.ts"),
				E = n("./src/reddit/components/PostFlairPicker/index.m.less"),
				y = n.n(E);
			! function(e) {
				e.UNSET = "unset", e.MOD_FLATLIST = "postModFlatlist", e.POST_OVERFLOW = "postOverlay"
			}(s || (s = {}));
			const C = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : s.UNSET;
					return `PostFlair__Modal-[postId: ${e}]-isOverlay[${t}]-position[${n}]`
				},
				j = Object(d.c)({
					flairData: v.d,
					subreddit: x.Y
				});
			class k extends i.a.Component {
				constructor(e) {
					super(e), this.trackEvent = () => {
						this.props.sendEvent(Object(_.F)(this.props.subredditId))
					}, this.onApply = () => {
						const {
							previewFlair: e
						} = this.state, t = e && e.templateId;
						this.props.onFlairChanged({
							previewFlair: e,
							selectedTemplateId: t
						}), this.props.closeModal && this.props.closeModal(), this.trackEvent()
					}, this.onClear = () => {
						this.props.sendEvent(Object(_.b)()), this.setSelectedFlair(null)
					}, this.setSelectedFlair = e => {
						this.setState({
							previewFlair: e
						})
					};
					const t = Object(O.c)(e.flairs);
					this.state = {
						previewFlair: t || null
					}
				}
				canSave() {
					const {
						templates: e
					} = this.props.flairData, {
						previewFlair: t
					} = this.state, n = Object(O.c)(this.props.flairs) || null;
					return Object(O.b)(e, t, n)
				}
				render() {
					const {
						props: e
					} = this, {
						previewFlair: t
					} = this.state, {
						className: n,
						flairData: s,
						subreddit: o
					} = e, a = o.displayText, {
						templates: d,
						templateIds: c
					} = s, {
						canSave: l
					} = this.canSave();
					return i.a.createElement(p.a, {
						className: n
					}, i.a.createElement(m.a, {
						onClosePressed: e.closeModal,
						title: r.fbt._("Select {subredditName} flair", [r.fbt._param("subredditName", a)], {
							hk: "1lDMWS"
						})
					}), i.a.createElement(b.a, {
						flair: t,
						flairTemplateType: g.d.LinkFlair,
						placeholderText: r.fbt._("Post Title", null, {
							hk: "43RsbC"
						})
					}), i.a.createElement(f.a, {
						flair: t,
						flairTemplateType: g.d.LinkFlair,
						subredditId: o.id,
						templates: d,
						templateIds: c,
						onChange: this.setSelectedFlair
					}), i.a.createElement("div", {
						className: y.a.buttonsRow
					}, i.a.createElement(h.l, {
						disabled: !l,
						onClick: this.onApply
					}, r.fbt._("Apply", null, {
						hk: "3mAjVQ"
					})), i.a.createElement(h.o, {
						className: y.a.clearButton,
						onClick: this.onClear
					}, r.fbt._("Clear Flair", null, {
						hk: "3jvT0B"
					}))))
				}
			}
			const I = Object(a.b)(j, (e, t) => ({
				closeModal: () => e(Object(u.i)(t.modalId))
			}))(k);
			t.a = Object(l.a)(Object(c.c)(I))
		},
		"./src/reddit/components/PostFollow/index.m.less": function(e, t, n) {
			e.exports = {
				collectionFollow: "_1yF34mDRcD_ii0n-Ak0OdI",
				isFollowed: "gBrTiaH_Z7HT5D96vnUfJ",
				isEventFollow: "_1iTFEDTdpF-KFmOZvDuGHH"
			}
		},
		"./src/reddit/components/PostFollow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return f
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/post.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/helpers/trackers/postCollection.ts"),
				m = n("./src/reddit/components/PostFollow/index.m.less"),
				p = n.n(m);
			class b extends o.a.Component {
				constructor(e) {
					super(e), this.onFollowClick = () => {
						const {
							isEventFollow: e,
							onFollow: t,
							post: {
								id: n,
								isFollowed: s
							},
							sendEvent: r
						} = this.props, o = !!s;
						r(e ? Object(u.o)({
							postId: n,
							isFollowed: o
						}) : Object(u.g)({
							postId: n,
							isFollowed: o
						})), t && t()
					}, this.onMouseEnter = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						const e = this.props.post;
						e && e.isFollowed && this.setState({
							isHovered: !1
						})
					}, this.state = {
						isHovered: !1
					}
				}
				render() {
					const {
						className: e,
						isEventFollow: t,
						post: n
					} = this.props, r = this.state.isHovered, i = n.isFollowed;
					let a = i ? s.fbt._("Followed", null, {
						hk: "2oc9IH"
					}) : s.fbt._("Follow", null, {
						hk: "NkunG"
					});
					return i && r && (a = s.fbt._("Unfollow", null, {
						hk: "2sJ8xn"
					})), o.a.createElement("button", {
						className: Object(d.a)(p.a.collectionFollow, {
							[p.a.isFollowed]: !!n.isFollowed,
							[p.a.isEventFollow]: t
						}, e),
						onClick: this.onFollowClick,
						onMouseEnter: this.onMouseEnter,
						onMouseLeave: this.onMouseLeave
					}, a)
				}
			}
			const f = Object(i.b)(() => Object(a.c)({}), (e, t) => {
				let {
					post: n
				} = t;
				return {
					onFollow: () => e(Object(c.z)(n.isSponsored ? n.postId : n.id))
				}
			})(Object(l.c)(b))
		},
		"./src/reddit/components/PostMedia/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return ne
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/CrosspostBox/index.tsx"),
				i = n("./src/reddit/components/Media/index.tsx"),
				a = n("./src/reddit/models/Post/index.ts"),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/reddit/actions/post.ts"),
				l = n("./src/reddit/constants/adEvents.ts"),
				u = n("./src/reddit/constants/experiments.ts"),
				m = n("./src/reddit/helpers/chooseVariant/index.ts"),
				p = n("./node_modules/reselect/es/index.js");
			const b = Object(p.a)(e => Object(m.c)(e, {
				experimentEligibilitySelector: m.a,
				experimentName: u.wc
			}), e => e === u.Kd);
			var f = n("./node_modules/fbt/lib/FbtPublic.js"),
				h = n("./src/lib/classNames/index.ts"),
				_ = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				g = n("./src/reddit/components/SubredditIcon/index.tsx"),
				v = n("./src/reddit/selectors/posts.ts"),
				x = n("./src/reddit/selectors/subreddit.ts"),
				O = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostCommunityLink/index.m.less"),
				E = n.n(O);
			const y = e => {
				let {
					postId: t,
					className: n
				} = e;
				const s = Object(d.e)(e => Object(v.G)(e, {
						postId: t
					})),
					o = Object(d.e)(e => "subreddit" === (null == s ? void 0 : s.belongsTo.type) ? Object(x.Y)(e, {
						subredditId: s.belongsTo.id
					}) : null);
				return o ? r.a.createElement(_.a, {
					className: Object(h.a)(E.a.link, n),
					to: o.url
				}, f.fbt._("Posts via", null, {
					hk: "23e8m8"
				}), r.a.createElement(g.b, {
					className: E.a.subredditIcon,
					shouldHideNsfwIcon: !0,
					subredditOrProfile: o
				}), r.a.createElement("span", {
					className: E.a.subredditName
				}, o.displayText)) : null
			};
			var C = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				j = n("./src/reddit/connectors/PostViewable/index.ts"),
				k = n("./src/reddit/contexts/PageLayer/index.tsx"),
				I = n("./src/reddit/contexts/Post/index.tsx"),
				S = n("./src/reddit/helpers/path/index.ts"),
				w = n("./src/reddit/hooks/useClickSourceData.ts"),
				T = n("./src/reddit/hooks/useIsOverlay.ts"),
				N = n("./src/reddit/hooks/usePageLayer.ts"),
				P = n("./src/lib/prettyPrintNumber/index.ts"),
				R = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostInformation/index.m.less"),
				A = n.n(R);
			const M = e => {
				let {
					post: t
				} = e;
				const n = `${Object(P.b)(t.score)} ${f.fbt._("upvotes",null,{hk:"wJqPp"})}`,
					s = `${Object(P.b)(t.numComments)} ${f.fbt._("comments",null,{hk:"30aUyh"})}`;
				return r.a.createElement("div", {
					className: A.a.postInformation
				}, r.a.createElement("h5", {
					className: A.a.title
				}, t.title), r.a.createElement("div", {
					className: A.a.interactions
				}, r.a.createElement("p", null, n), r.a.createElement("p", null, s)))
			};
			var L = n("./src/lib/isUrl/index.ts"),
				D = n("./src/reddit/actions/profile/index.ts"),
				F = n("./src/reddit/components/Thumbnail/index.tsx"),
				U = n("./src/reddit/components/UserIcon/index.tsx"),
				B = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				q = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				G = n("./src/reddit/selectors/profile.ts"),
				H = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPostMedia/index.m.less"),
				W = n.n(H);
			const V = e => {
				let {
					post: t
				} = e;
				var n, o, i, a;
				const c = Object(d.d)(),
					l = Object(d.e)(Object(G.l)(t.author)),
					u = Object(s.useMemo)(() => Object(F.c)({
						post: t
					}), [t]),
					m = Object(s.useMemo)(() => Object(L.a)(u), [u]);
				Object(s.useEffect)(() => {
					m || c(Object(D.d)(t.author))
				}, [c, t.author, m]);
				const p = !m && Object(q.a)(null === (n = null == l ? void 0 : l.icon) || void 0 === n ? void 0 : n.url),
					b = Object(B.c)(null === (o = null == l ? void 0 : l.icon) || void 0 === o ? void 0 : o.url);
				return r.a.createElement("div", {
					className: W.a.media
				}, m ? r.a.createElement(F.b, {
					post: t,
					url: u,
					className: W.a.mediaThumbnail,
					removeLink: !0,
					containerClassName: W.a.mediaThumbnailContainer
				}) : null, !m && (null === (i = null == l ? void 0 : l.icon) || void 0 === i ? void 0 : i.url) && !l.isNSFW && r.a.createElement("div", {
					className: W.a.userIconContainer
				}, r.a.createElement(U.a, {
					className: Object(h.a)({
						[W.a.snoovatarUserIcon]: p,
						[W.a.defaultUserIcon]: b
					}, W.a.userIcon),
					iconUrl: null === (a = null == l ? void 0 : l.icon) || void 0 === a ? void 0 : a.url,
					userName: l.name,
					isNSFW: t.isNSFW,
					wrapperClassName: W.a.userIconWrapper
				})))
			};
			var z = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPost/index.m.less"),
				K = n.n(z);
			const Q = Object(j.a)(null);
			var Y = Object(I.b)(Q(e => {
					let {
						post: t
					} = e;
					const n = Object(N.a)(),
						s = Object(T.a)(),
						o = Object(w.a)(),
						i = Object(k.x)(n) && !s;
					return r.a.createElement(_.a, {
						"data-testid": `promoted-user-post-${t.id}`,
						to: i ? Object(S.b)(t.permalink) : Object(C.a)(t.permalink, !1, o)
					}, r.a.createElement("div", {
						className: K.a.container
					}, r.a.createElement(M, {
						post: t
					}), r.a.createElement(V, {
						post: t
					})))
				})),
				J = n("./src/reddit/components/PromotedUserPostsAd/PromotedUserPosts/index.m.less"),
				X = n.n(J);
			const Z = e => {
				let {
					postIds: t
				} = e;
				const n = t.map(e => r.a.createElement(Y, {
					postId: e,
					key: e
				}));
				return r.a.createElement("div", {
					className: X.a.container
				}, n)
			};
			var $ = n("./src/reddit/components/PromotedUserPostsAd/index.m.less"),
				ee = n.n($);
			const te = e => {
				let {
					post: t
				} = e;
				const n = Object(d.d)();
				if (!Object(d.e)(b) || !t.adPromotedUserPostIds || 0 === t.adPromotedUserPostIds.length) return null;
				const [s] = t.adPromotedUserPostIds;
				return r.a.createElement("div", {
					className: ee.a.container,
					onClick: () => n(Object(c.y)(t, l.a.Click))
				}, r.a.createElement(Z, {
					postIds: t.adPromotedUserPostIds
				}), r.a.createElement(y, {
					postId: s,
					className: ee.a.communityLink
				}))
			};

			function ne(e) {
				const {
					post: t
				} = e;
				return t.crosspostRootId ? r.a.createElement(o.c, {
					postId: t.crosspostRootId,
					mediaProps: {
						...e,
						availableWidth: e.availableWidth ? e.availableWidth - 2 * o.b - 2 * o.a : void 0,
						crosspost: t,
						primaryContent: !1
					}
				}) : Object(a.C)(t) && Object(a.B)(t) ? r.a.createElement(te, {
					post: t
				}) : r.a.createElement(i.a, {
					...e,
					primaryContent: !!e.showFull
				})
			}
		},
		"./src/reddit/components/PostMeta/index.m.less": function(e, t, n) {
			e.exports = {
				metaContainer: "Ywkt6EDfNWINeTr9lP29H",
				postTopMeta: "iaAYGvTNtknkTxuHArCzL",
				subredditName: "_1L0pdcPf58t25Jy6ljHIKR",
				SubscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				subscribeButton: "_2r87gmhJ9n0MsylKHkgDcp",
				addModNote: "CUh9f8Zri7XfZRUI18jS5"
			}
		},
		"./src/reddit/components/PostMeta/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/reddit/components/AwardBadges/index.tsx"),
				d = n("./src/reddit/components/CCM/AddModNoteCTA/index.tsx"),
				c = n("./src/reddit/components/Hovercards/SubredditHovercard/index.tsx"),
				l = n("./src/reddit/components/JSAPIContainers/index.tsx"),
				u = n("./src/reddit/components/PostBadges/index.tsx"),
				m = n("./src/reddit/components/PostTopMeta/index.tsx"),
				p = n("./src/reddit/components/QuarantinedLabel/index.tsx"),
				b = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				f = n("./src/reddit/components/SubscribeButton/Inline.tsx"),
				h = n("./src/reddit/constants/posts.ts"),
				_ = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				v = n("./src/reddit/helpers/trackers/post.ts"),
				x = n("./src/reddit/hooks/useClickSourceData.ts"),
				O = n("./src/reddit/models/Subreddit/index.ts"),
				E = n("./src/reddit/components/PostMeta/index.m.less"),
				y = n.n(E);
			t.a = e => {
				const {
					flairStyleTemplate: t,
					hideGildCta: n,
					inSubredditOrProfile: s,
					isCurrentUserProfilePost: E,
					isOverlay: C,
					isTopicPage: j,
					post: k,
					shouldShowSubscribeButton: I,
					subredditOrProfile: S,
					tooltipType: w
				} = e, T = !!j, N = Object(x.a)(), P = Object(o.e)(e => !!S && Object(i.i)(e, S.id));
				return r.a.createElement("div", {
					className: y.a.metaContainer
				}, !s && !k.isSponsored && S && r.a.createElement(c.a, {
					postId: k.id,
					subredditName: S.name
				}, r.a.createElement(b.a, {
					className: y.a.subredditName,
					"data-click-id": "subreddit",
					to: {
						pathname: S.url,
						state: N
					}
				}, S.displayText)), S && S.isQuarantined && r.a.createElement(p.a, null), !s && !k.isSponsored && S && I && !E && r.a.createElement(f.a, {
					className: y.a.SubscribeButton,
					getEventFactory: e => Object(v.k)(k.id, e ? "unsubscribe" : "subscribe"),
					identifier: {
						name: S.name,
						type: Object(O.i)(S) ? h.a.PROFILE : h.a.SUBREDDIT
					},
					postId: k.id,
					size: _.d.XXS,
					small: !0
				}), !s && !k.isSponsored && r.a.createElement(g.b, null), !s && !k.isSponsored && r.a.createElement(l.h, {
					type: k.belongsTo.type,
					id: k.belongsTo.id
				}), r.a.createElement(m.g, {
					className: y.a.postTopMeta,
					flairStyleTemplate: t,
					post: k,
					tooltipType: w,
					isModWithUserNotesPermissions: P
				}), r.a.createElement(u.a, {
					displayText: S ? S.displayText : null,
					inSubredditOrProfile: !!s,
					post: k,
					tooltipType: w
				}), !T && r.a.createElement(a.a, {
					hideCta: n,
					thing: k,
					tooltipType: C ? m.f.Lightbox : void 0
				}), P && r.a.createElement(d.a, {
					postOrComment: k,
					className: y.a.addModNote
				}))
			}
		},
		"./src/reddit/components/PostModModeDropdown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/higherOrderComponents/makeAsync.tsx"),
				r = n("./src/lib/loadWithRetries/index.ts");
			const o = () => null;
			t.a = Object(s.a)({
				ErrorComponent: o,
				getComponent: () => Object(r.a)(() => n.e("ModerationDropdowns").then(n.bind(null, "./src/reddit/components/PostModModeDropdown/_PostModModeDropdown.tsx"))).then(e => e.default),
				LoadingComponent: o
			})
		},
		"./src/reddit/components/PostOverflowMenu/index.m.less": function(e, t, n) {
			e.exports = {
				overflowMenu: "_1EbinKu2t3KjaT2gR156Qp",
				DropdownRow: "_1muOrgIRB6t41qDocDiXul",
				dropdownRow: "_1muOrgIRB6t41qDocDiXul",
				disabledRow: "_2Odc33_zXVGMHX8Um_2eO7",
				muteSubreddit: "_2Y6YEgvUcx5Ic2juj3VU95",
				HideIcon: "_3CksthIwbeJIolp7OYeQYv",
				hideIcon: "_3CksthIwbeJIolp7OYeQYv",
				Icon: "_2V4nGS1AmzWhA62lzdCu4r",
				icon: "_2V4nGS1AmzWhA62lzdCu4r"
			}
		},
		"./src/reddit/components/PostOverflowMenu/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return we
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/telemetry/index.ts"),
				l = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				u = n("./src/config.ts"),
				m = n("./src/lib/addQueryParams/index.ts"),
				p = n("./src/lib/classNames/index.ts"),
				b = n("./src/lib/lessComponent.tsx"),
				f = n("./src/reddit/actions/eventPosts/index.ts"),
				h = n("./src/reddit/actions/gold/modals.ts"),
				_ = n("./src/reddit/actions/modal.ts"),
				g = n("./src/reddit/actions/pinnedPost.ts"),
				v = n("./src/reddit/actions/post.ts"),
				x = n("./src/reddit/actions/postCreation/editing.ts"),
				O = n("./src/reddit/actions/reportFlow/index.ts"),
				E = n("./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx"),
				y = n("./src/reddit/constants/oneFeed.ts"),
				C = n("./src/reddit/constants/parameters.ts"),
				j = n("./src/reddit/constants/posts.ts"),
				k = n("./src/reddit/hooks/useRecommendationPostContext.ts");

			function I() {
				return (I = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var S = function(e) {
					function t(t) {
						const n = Object(k.a)();
						return o.createElement(e, I({}, t, {
							recommendationPostContext: n
						}))
					}
					const n = e.displayName || e.name || "Component";
					return t.displayName = `withRecommendationPostContext(${n})`, t
				},
				w = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				T = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				N = n("./src/reddit/icons/fonts/index.tsx"),
				P = n("./src/reddit/components/CreatorStats/Icon.tsx"),
				R = n("./src/reddit/components/OverflowMenu/index.tsx"),
				A = n("./src/reddit/components/ReportFlow/index.tsx"),
				M = n("./src/reddit/contexts/PageLayer/index.tsx"),
				L = n("./src/reddit/controls/CheckboxMenuItem/index.tsx"),
				D = n("./src/reddit/controls/Dropdown/Row.tsx"),
				F = n("./src/reddit/components/ModToolsFlatlist/constants.ts"),
				U = n("./src/reddit/components/ModToolsFlatlist/getModItemBreakpoints.ts"),
				B = n("./src/reddit/components/Flatlist/constants.ts"),
				q = n("./src/reddit/components/Flatlist/getFlatlistBreakpoints.ts"),
				G = n("./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx"),
				H = n("./src/reddit/constants/postLayout.ts"),
				W = n("./src/reddit/helpers/correlationIdTracker.ts"),
				V = n("./src/reddit/helpers/isCrosspost.ts"),
				z = n("./src/reddit/helpers/media/index.ts"),
				K = n("./src/reddit/helpers/postEvent.ts"),
				Q = n("./src/reddit/helpers/trackers/post.ts"),
				Y = n("./src/reddit/helpers/trackers/react.ts"),
				J = n("./src/reddit/models/Post/index.ts"),
				X = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				Z = n("./src/reddit/models/Subreddit/index.ts"),
				$ = n("./src/reddit/selectors/activeModalId.ts"),
				ee = n("./src/reddit/selectors/experiments/videoReactions.ts"),
				te = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				ne = n("./src/reddit/selectors/posts.ts"),
				se = n("./src/reddit/selectors/subreddit.ts"),
				re = n("./src/reddit/selectors/user.ts"),
				oe = n("./src/reddit/selectors/experiments/reportingRevampDesktop.ts"),
				ie = n("./src/reddit/components/ModalStyledComponents/Modal.tsx"),
				ae = n("./src/reddit/components/PostFlairPicker/index.tsx"),
				de = n("./src/reddit/components/ReportFlow/new.tsx"),
				ce = n("./src/reddit/selectors/experiments/antievil/index.tsx"),
				le = n("./src/reddit/selectors/experiments/reportAd.ts"),
				ue = n("./src/reddit/actions/postCollection/index.ts"),
				me = n("./src/reddit/contexts/Post/index.tsx"),
				pe = n("./src/reddit/helpers/trackers/postCollection.ts"),
				be = n("./src/reddit/models/PostCreationForm/index.ts"),
				fe = n("./src/reddit/selectors/postCollection.ts"),
				he = n("./node_modules/react-router/esm/react-router.js"),
				_e = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				ge = n("./src/reddit/components/ModalStyledComponents/MessageBox.tsx");
			const ve = Object(he.i)(e => {
				let {
					post: t,
					toggleConfirmDelete: n,
					handleDeletePost: r,
					location: o
				} = e;
				const {
					isPrediction: a,
					resolvedOptionId: d,
					totalVoteCount: c
				} = t.pollData || {}, l = a ? s.fbt._("Are you sure?", null, {
					hk: "2mIMwE"
				}) : s.fbt._("Delete post?", null, {
					hk: "3g7QoX"
				}), u = i.a.useMemo(() => {
					const e = c || 0;
					return a ? 0 === e ? s.fbt._("Deleting this post will cancel any predictions that have been made.", null, {
						hk: "1OCTd3"
					}) : 1 === e ? s.fbt._("Deleting this post will cancel the 1 prediction that have already been made.", null, {
						hk: "1MnrUP"
					}) : s.fbt._("Deleting this post will cancel the {votedUsersCount} predictions that have already been made.", [s.fbt._param("votedUsersCount", e.toString())], {
						hk: "1jBXxs"
					}) : s.fbt._("Are you sure you want to delete your post? You can't undo this.", null, {
						hk: "2eDKWP"
					})
				}, [a, c]), m = a ? s.fbt._("Delete", null, {
					hk: "3NNdm0"
				}) : s.fbt._("Delete post", null, {
					hk: "28hc1p"
				});
				return a && d ? i.a.createElement(ge.a, {
					title: s.fbt._("This post can't be deleted", null, {
						hk: "1sZ013"
					}),
					body: s.fbt._("Sorry about that. Once a prediction has been resolved, you can't delete the post.", null, {
						hk: "32l6dr"
					}),
					onClose: n
				}) : i.a.createElement(_e.a, {
					withOverlay: !0,
					toggleModal: n,
					onConfirm: () => r(o),
					onOverlayClick: n,
					actionText: m,
					headerText: l,
					modalText: u
				})
			});
			var xe = n("./src/reddit/actions/subreddit/muting.ts"),
				Oe = n("./src/reddit/helpers/trackers/subredditMuting.ts"),
				Ee = n("./src/devPlatform/components/ContextActions/ContextActionsLoader.tsx"),
				ye = n("./src/devPlatform/constants.ts"),
				Ce = n("./src/reddit/selectors/experiments/eventPosts.ts"),
				je = n("./src/reddit/components/PostOverflowMenu/index.m.less"),
				ke = n.n(je);
			const Ie = b.a.wrapped(D.b, "DropdownRow", ke.a),
				Se = Object(l.a)(),
				we = e => {
					let {
						gild: t = !0,
						save: n = !0,
						share: s = !0,
						report: r = !0,
						editPost: o = !0,
						hide: i = !0,
						insights: a = !0,
						mute: d = !0
					} = e;
					return {
						[B.a.Gild]: t,
						[B.a.Save]: n,
						[B.a.Share]: s,
						[B.a.Report]: r,
						[B.a.EditPost]: o,
						[B.a.Hide]: i,
						[B.a.Insights]: a,
						[B.a.Mute]: d
					}
				},
				Te = Object(a.b)(() => Object(d.c)({
					claimedFreeAward: te.b,
					isFutureEvent: fe.i,
					isPinned: ne.q,
					isAllowReactionsKillswitchEnabled: ee.a,
					subredditAboutInfo: ne.H,
					reportFlowIsOpen: (e, t) => {
						let {
							isOverlay: n,
							postId: s
						} = t;
						var r, o, i, a;
						return (null === (o = null === (r = e.features) || void 0 === r ? void 0 : r.reportFlow) || void 0 === o ? void 0 : o.openedFromModalPage) === n && (null === (a = null === (i = e.features) || void 0 === i ? void 0 : i.reportFlow) || void 0 === a ? void 0 : a.postOrCommentId) === s
					},
					showPinAction: (e, t) => {
						let {
							isProfilePostListing: n,
							userIsOp: s,
							post: r,
							pageLayer: o
						} = t;
						return Object(M.G)(e, {
							pageLayer: o
						}) && n && s && Object(re.Cb)(e, {
							userName: r.author
						})
					},
					hasSubredditRules: se.j,
					isPostPartOfACollection: fe.k,
					shouldRenderCollectionEditButtons: (e, t) => {
						let {
							post: n,
							subredditOrProfile: s
						} = t;
						if (n.isSponsored) return !1;
						if (!s) return !1;
						const r = s.type === Z.g.User;
						return Object(fe.r)(e, s.name, r)
					},
					reportingRevampEnabled: oe.a,
					videoShareModalOpen: (e, t) => {
						let {
							postId: n
						} = t;
						return Object($.a)(e) === Object(G.a)(n)
					},
					subredditName: (e, t) => {
						let {
							post: n
						} = t;
						return Object(se.i)(e, n)
					},
					isCommunityMutingEnabled: ce.a,
					isReportAnAdEnabled: le.a,
					isEventPostUiHidden: Ce.a
				}), (e, t) => {
					let {
						postId: n,
						isOverlay: s,
						isCommentsPage: r
					} = t;
					return {
						onCopyLink: t => e(Object(v.C)(t)),
						onDelete: t => e(Object(v.M)(n, t, s)),
						onDistinguishPost: t => e(Object(v.u)(n, t)),
						onGildClick: (t, s) => e(Object(h.d)({
							awardId: s,
							correlationId: t,
							thingId: n
						})),
						onToggleSave: () => e(Object(v.U)(n)),
						onToggleNSFW: () => e(Object(v.F)(n)),
						onToggleOC: () => e(Object(v.I)(n)),
						onTogglePinned: () => e(Object(g.i)(n)),
						onToggleSpoiler: () => e(Object(v.db)(n)),
						onHide: (t, r) => e(Object(v.eb)(n, !t, s, !r)),
						onReportClick: () => e(Object(O.c)(n, s)),
						onStartEventNow: () => {
							e((e, t) => Object(c.a)(Object(T.l)()(t()))), e(Object(f.startEventNowRequested)(n))
						},
						onEdit: () => {
							const t = !s && !r;
							e(Object(x.a)(n, t))
						},
						onFlairPost: () => e(Object(_.i)(Object(ae.b)(n, s))),
						onToggleSendReplies: () => e(Object(v.V)(n)),
						onToggleReactAllowed: () => e(Object(v.S)(n)),
						showCollectionsList: (t, n) => {
							e(Object(ue.e)(t)).then(() => {
								const t = Object(be.t)(n, s);
								e(_.i(t))
							})
						},
						onToggleVideoShareModal: () => e(Object(_.i)(Object(G.a)(n))),
						onMuteClick: (t, n) => e(Object(xe.c)({
							subredditId: t,
							subredditName: n
						}))
					}
				});
			class Ne extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.state = {
						isConfirmDeleteOpen: !1,
						showMuteSubredditModal: !1
					}, this.handlePostEvent = (e, t) => {
						const {
							isOverlay: n,
							post: s,
							sendEvent: r
						} = this.props;
						r(Object(Q.k)(s.id, e, n ? "post_detail" : "post", void 0, void 0, void 0, null == t ? void 0 : t.referralId))
					}, this.handleClickMenuButton = () => {
						this.handlePostEvent("post_overflow_menu")
					}, this.handleDeletePost = e => {
						e && (this.props.onDelete(e), this.handlePostEvent("delete"))
					}, this.handleEdit = () => {
						this.handlePostEvent("edit"), this.props.onEdit()
					}, this.handleGild = async () => {
						var e;
						const t = Object(W.d)(W.a.GildingFlow, !0);
						this.props.onGildClick(t, null === (e = this.props.claimedFreeAward) || void 0 === e ? void 0 : e.id);
						const {
							clickGildEvent: s
						} = await Promise.resolve().then(n.bind(null, "./src/reddit/helpers/trackers/gild.ts"));
						this.props.sendEvent(s(this.props.postId))
					}, this.onShowFewerOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(Q.n)(e)), t(y.a.SeeFewerPostsView)
					}, this.onShowMoreOfClick = () => {
						const {
							postId: e,
							recommendationPostContext: {
								setRecommendationFooterView: t
							},
							sendEvent: n
						} = this.props;
						n(Object(Q.o)(e)), t(y.a.ThankYouView)
					}, this.handleMuteModal = () => {
						this.setState(e => ({
							showMuteSubredditModal: !e.showMuteSubredditModal
						}))
					}, this.toggleHide = () => {
						const e = this.props.post.hidden ? "unhide" : "hide";
						this.props.isCommunityMutingEnabled || this.handlePostEvent(e), this.props.onHide(!!this.props.post.hidden, this.props.isCommunityMutingEnabled)
					}, this.toggleSave = () => {
						const e = this.props.post.saved ? "unsave" : "save";
						this.handlePostEvent(e), this.props.onToggleSave()
					}, this.handleReport = () => {
						this.handlePostEvent("report"), this.props.onReportClick()
					}, this.toggleOC = () => {
						this.handlePostEvent(this.props.post.isOriginalContent ? "unmark_original_content" : "mark_original_content"), this.props.onToggleOC()
					}, this.togglePinned = () => {
						this.handlePostEvent(this.props.isPinned ? "unpin" : "pin"), this.props.isPinned ? this.props.sendEvent(Object(Q.r)(this.props.post.id)) : this.props.sendEvent(Object(Q.h)(this.props.post.id)), this.props.onTogglePinned()
					}, this.toggleSpoiler = () => {
						this.handlePostEvent(this.props.post.isSpoiler ? "unmark_spoiler" : "mark_spoiler"), this.props.onToggleSpoiler()
					}, this.toggleNSFW = () => {
						this.handlePostEvent(this.props.post.isNSFW ? "unmark_nsfw" : "mark_nsfw"), this.props.onToggleNSFW()
					}, this.toggleDeleteConfirmation = () => {
						this.setState({
							isConfirmDeleteOpen: !this.state.isConfirmDeleteOpen
						})
					}, this.getBreakpointClass = e => {
						const {
							props: t
						} = this;
						if (!t.ignoreBreakpoints && t.useFlatlistBreakpoints[e]) return Object(q.b)({
							breakpointType: q.a.HideIfVWLarger,
							flatlistItem: e,
							isLoggedIn: !!t.currentUser,
							isUserOp: t.userIsOp
						})
					}, this.getBreakpointCx = (e, t) => Object(U.b)({
						breakpointType: q.a.HideIfVWLarger,
						flatlistItem: e,
						postLayout: t
					}), this.handleAddToCollection = () => {
						const {
							isPostPartOfACollection: e,
							showCollectionsList: t,
							post: n,
							sendEvent: s
						} = this.props;
						e || (s(Object(pe.b)(n.id)), t(n.belongsTo.id, n.id))
					}, this.onCloseShareModal = e => {
						e && (this.handlePostEvent("copy_link", {
							referralId: Se
						}), this.props.onCopyLink(e)), this.props.onToggleVideoShareModal()
					}, this.renderReportFlow = () => this.props.reportingRevampEnabled ? i.a.createElement(de.a, {
						withOverlay: !0,
						overlayCustomStyles: A.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					}) : i.a.createElement(A.a, {
						withOverlay: !0,
						overlayCustomStyles: A.b,
						postId: this.props.postId,
						timestamp: this.context.currentTime
					})
				}
				getOverflowMenuBreakpointClass() {
					const {
						currentUser: e,
						ignoreBreakpoints: t,
						ignoreOverflowMenuBreakpoints: n,
						isCommentsPage: s,
						isRecommendationPost: r,
						layout: o,
						modModeWithPost: i,
						recommendationPostContext: {
							hideRecommendationContext: a
						},
						userIsOp: d
					} = this.props, c = o === H.g.Classic;
					if (!(t || n || i || d || !s && !c || r && !a)) return Object(q.b)({
						breakpointType: q.a.HideIfVWLarger,
						flatlistItem: B.a.PostOverflowMenu,
						isLoggedIn: !!e,
						isUserOp: d
					})
				}
				renderDropdownIcons() {
					var e;
					const {
						props: t
					} = this, {
						currentUser: n,
						isFutureEvent: o,
						isOverlay: a,
						isPinned: d,
						isRecommendationPost: c,
						layout: l,
						onClickInsightsButton: m,
						onStartEventNow: b,
						post: f,
						recommendationPostContext: {
							hideRecommendationContext: h
						},
						shouldRenderCollectionEditButtons: _,
						shouldShowInsightsButton: g,
						showEditFlair: v,
						showPinAction: x,
						toggleAddEventStartTimeModal: O,
						toggleEditStartTimeModal: E,
						userIsOp: y,
						isCommunityMutingEnabled: C,
						subredditName: k,
						pageLayer: I,
						isReportAnAdEnabled: S,
						isEventPostUiHidden: w
					} = t, T = t.currentUser && t.currentUser.isEmployee, R = Object(V.a)(t.post), A = t.post.belongsTo.type === j.a.PROFILE || Object(Z.h)(t.subredditAboutInfo), M = t.post.belongsTo.type === j.a.PROFILE || Object(Z.j)(t.subredditAboutInfo), D = n && f.isGildable, U = Object(K.a)(t.post), q = a ? void 0 : l, G = "popular" === (null == I ? void 0 : I.urlParams.subredditName), H = "Frontpage" === (null === (e = null == I ? void 0 : I.routeMatch) || void 0 === e ? void 0 : e.route.chunk), W = C && !c && k && (G || H);
					return i.a.createElement("div", null, g && i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Insights),
						displayText: s.fbt._("Insights", null, {
							hk: "t7dpi"
						}),
						onClick: m
					}, i.a.createElement(P.a, {
						postCreated: f.created,
						subredditId: f.belongsTo.id
					})), D && i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Gild),
						displayText: s.fbt._("Give Award", null, {
							hk: "3mYeGJ"
						}),
						onClick: this.handleGild
					}, i.a.createElement(N.a, {
						name: "award",
						className: ke.a.Icon
					})), c && !h && i.a.createElement(i.a.Fragment, null, i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.ShowMoreLikeThis),
						displayText: s.fbt._("Show more posts like this", null, {
							hk: "2t0WMg"
						}),
						onClick: this.onShowMoreOfClick
					}, i.a.createElement(N.a, {
						name: "checkmark",
						className: ke.a.Icon
					})), i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.ShowFewerLikeThis),
						displayText: s.fbt._("Show fewer posts like this", null, {
							hk: "k9sBL"
						}),
						onClick: this.onShowFewerOfClick
					}, i.a.createElement(N.a, {
						name: "hide",
						className: ke.a.Icon
					}))), i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Share),
						displayText: s.fbt._("Copy link", null, {
							hk: "ETZxA"
						}),
						onClick: () => {
							const {
								permalink: e,
								post: n
							} = t;
							n && Object(J.r)(n) ? (t.onToggleVideoShareModal(), this.handlePostEvent("share")) : (this.handlePostEvent("share_copy"), t.onCopyLink(e))
						}
					}, i.a.createElement(N.a, {
						name: "link_post",
						className: ke.a.Icon
					})), i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Share),
						displayText: s.fbt._("Embed", null, {
							hk: "3u0v6r"
						}),
						onClick: () => {
							this.handlePostEvent("share_embed"), window.open(`${u.a.rebedMediaUrl}/embed?url=${t.post.permalink}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, i.a.createElement(N.a, {
						name: "embed",
						className: ke.a.Icon
					})), t.showEditPost && !Object(X.b)(this.props.post) && i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.EditPost),
						displayText: s.fbt._("Edit post", null, {
							hk: "3gVzz0"
						}),
						onClick: this.handleEdit,
						isSelected: t.post.hidden
					}, i.a.createElement(N.a, {
						name: "edit",
						className: ke.a.Icon
					})), v && i.a.createElement(Ie, {
						className: this.getBreakpointCx(F.a.Flair, q),
						displayText: s.fbt._("Edit Post Flair", null, {
							hk: "1pGISD"
						}),
						onClick: t.onFlairPost,
						isSelected: t.post.hidden
					}, i.a.createElement(N.a, {
						name: "tag",
						className: ke.a.Icon
					})), i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Save),
						displayText: t.post.saved ? s.fbt._("unsave", null, {
							hk: "HDDPm"
						}) : s.fbt._("save", null, {
							hk: "3bg2gs"
						}),
						onClick: this.toggleSave,
						isSelected: t.post.saved
					}, i.a.createElement(N.a, {
						name: t.post.saved ? "saved" : "save",
						className: ke.a.Icon
					})), x && i.a.createElement(Ie, {
						displayText: d ? s.fbt._("Unpin Post from Profile", null, {
							hk: "6DYfk"
						}) : s.fbt._("Pin Post to Profile", null, {
							hk: "2RWbNF"
						}),
						onClick: this.togglePinned
					}, i.a.createElement(N.a, {
						name: "pin",
						className: ke.a.Icon,
						isFilled: this.props.isPinned
					})), W && i.a.createElement(Ie, {
						className: Object(p.a)(ke.a.muteSubreddit, this.getBreakpointClass(B.a.Mute)),
						displayText: s.fbt._("Mute {name of subreddit to mute}", [s.fbt._param("name of subreddit to mute", `r/${k}`)], {
							hk: "1Jw2VW"
						}),
						onClick: this.handleMuteModal
					}, i.a.createElement(N.a, {
						name: "volume_mute",
						className: ke.a.Icon
					})), !t.post.isSponsored && i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Hide),
						displayText: t.post.hidden ? s.fbt._("unhide", null, {
							hk: "1P4IxC"
						}) : s.fbt._("hide", null, {
							hk: "48yKzW"
						}),
						onClick: this.toggleHide,
						isSelected: t.post.hidden
					}, i.a.createElement(N.a, {
						name: "hide",
						className: ke.a.HideIcon
					})), (!t.post.isSponsored || S) && !y && i.a.createElement(Ie, {
						className: this.getBreakpointClass(B.a.Report),
						displayText: s.fbt._("report", null, {
							hk: "128RPn"
						}),
						onClick: this.handleReport
					}, i.a.createElement(N.a, {
						name: "report",
						className: ke.a.Icon
					})), _ && o && b && !w && i.a.createElement(Ie, {
						onClick: b,
						displayText: s.fbt._("Start event now", null, {
							hk: "3VomTN"
						})
					}, i.a.createElement(N.a, {
						name: "live",
						className: ke.a.Icon
					})), _ && o && E && !w && i.a.createElement(Ie, {
						onClick: E,
						displayText: s.fbt._("Edit start time", null, {
							hk: "2typ17"
						})
					}, i.a.createElement(N.a, {
						name: "scheduled",
						className: ke.a.Icon
					})), _ && !U && O && !w && i.a.createElement(Ie, {
						displayText: s.fbt._("Add event start time", null, {
							hk: "1XXqzu"
						}),
						onClick: O
					}, i.a.createElement(N.a, {
						name: "scheduled",
						className: ke.a.Icon
					})), _ && i.a.createElement(Ie, {
						className: this.props.isPostPartOfACollection ? ke.a.disabledRow : void 0,
						displayText: s.fbt._("Add to collection", null, {
							hk: "3UNHgN"
						}),
						onClick: this.handleAddToCollection,
						noHover: this.props.isPostPartOfACollection
					}, i.a.createElement(N.a, {
						name: "collection",
						className: ke.a.Icon
					})), y && i.a.createElement(Ie, {
						displayText: s.fbt._("delete", null, {
							hk: "4kSfzC"
						}),
						onClick: this.toggleDeleteConfirmation
					}, i.a.createElement(N.a, {
						name: "delete",
						className: ke.a.Icon
					})), T && t.userIsOp && i.a.createElement(Ie, {
						displayText: t.post.distinguishType === r.J.ADMIN ? s.fbt._("undistinguish", null, {
							hk: "2chGON"
						}) : s.fbt._("Distinguish as admin", null, {
							hk: "2xltiM"
						}),
						onClick: () => t.post.distinguishType === r.J.ADMIN ? t.onDistinguishPost(r.J.NONE) : t.onDistinguishPost(r.J.ADMIN)
					}, i.a.createElement(N.a, {
						name: "admin",
						className: ke.a.Icon
					})), y && A && !R && i.a.createElement(L.a, {
						text: s.fbt._("Mark as OC", null, {
							hk: "2vGyoC"
						}),
						onClick: this.toggleOC,
						isSelected: this.props.post.isOriginalContent
					}), y && M && i.a.createElement(L.a, {
						text: s.fbt._("Mark as Spoiler", null, {
							hk: "3PJk7A"
						}),
						onClick: this.toggleSpoiler,
						isSelected: this.props.post.isSpoiler
					}), y && i.a.createElement(L.a, {
						text: s.fbt._("Mark as NSFW", null, {
							hk: "4qK6JN"
						}),
						onClick: this.toggleNSFW,
						isSelected: this.props.post.isNSFW
					}), y && f.domain === z.a && !this.props.isAllowReactionsKillswitchEnabled && i.a.createElement(L.a, {
						text: s.fbt._("Allow video threads", null, {
							hk: "DJXlU"
						}),
						onClick: () => {
							var e;
							t.onToggleReactAllowed(), this.props.sendEvent(Object(Y.a)({
								subredditId: null === (e = this.props.subredditOrProfile) || void 0 === e ? void 0 : e.id,
								postId: this.props.postId,
								reactionsEnabled: this.props.post.isReactAllowed
							}))
						},
						isSelected: this.props.post.isReactAllowed
					}), t.userIsOp && i.a.createElement(L.a, {
						text: s.fbt._("Send me reply notifications", null, {
							hk: "6AmTA"
						}),
						onClick: t.onToggleSendReplies,
						isSelected: this.props.post.sendReplies
					}), i.a.createElement(Ee.a, {
						contextType: ye.a.POST,
						contextData: f
					}))
				}
				render() {
					var e;
					const {
						props: t
					} = this, {
						subredditName: n,
						post: r,
						pageLayer: o
					} = t, a = r.belongsTo.id, d = "popular" === (null == o ? void 0 : o.urlParams.subredditName), c = "Frontpage" === (null === (e = null == o ? void 0 : o.routeMatch) || void 0 === e ? void 0 : e.route.chunk);
					return i.a.createElement("div", null, i.a.createElement(R.b, {
						className: Object(p.a)(ke.a.overflowMenu, this.getOverflowMenuBreakpointClass(), t.className),
						dropdownId: t.dropdownId,
						isFixed: t.isFixed,
						layout: t.layout,
						onClick: this.handleClickMenuButton
					}, this.renderDropdownIcons()), t.reportFlowIsOpen && t.subredditOrProfile && t.hasSubredditRules && this.renderReportFlow(), this.state.isConfirmDeleteOpen && i.a.createElement(ve, {
						post: this.props.post,
						toggleConfirmDelete: this.toggleDeleteConfirmation,
						handleDeletePost: this.handleDeletePost
					}), t.videoShareModalOpen && i.a.createElement(G.b, {
						className: ke.a.modalBody,
						onClose: this.onCloseShareModal,
						withOverlay: !1,
						url: Object(m.a)(Object(w.a)(t.postId), {
							[C.A]: Se,
							utm_source: "share",
							utm_medium: "web2x",
							utm_content: "rpan_stream"
						})
					}), this.state.showMuteSubredditModal && i.a.createElement(ie.a, {
						headerText: s.fbt._("Mute {name of subreddit to mute}", [s.fbt._param("name of subreddit to mute", `r/${n}`)], {
							hk: "4eAU3R"
						}),
						modalBody: s.fbt._("You won't see posts from {name of subreddit to mute} in your feeds or recommmendations anymore.", [s.fbt._param("name of subreddit to mute", `r/${n}`)], {
							hk: "1JNA6G"
						}),
						toggleModal: this.handleMuteModal,
						actionText: s.fbt._("YES, MUTE", null, {
							hk: "1eAO8C"
						}),
						cancelActionText: s.fbt._("CANCEL", null, {
							hk: "If1yt"
						}),
						onConfirm: () => {
							this.handleMuteModal(), t.onMuteClick(a, n), this.toggleHide(), c && this.props.sendEvent(Object(Oe.b)()), d && this.props.sendEvent(Object(Oe.c)())
						},
						withOverlay: !0
					}))
				}
			}
			Ne.contextType = E.a;
			t.a = S(Object(me.e)(Te(Ne)))
		},
		"./src/reddit/components/PostRailAndVotes/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_3a2ZHWaih05DgAOtvu6cIo",
				allowPointerEvents: "_2iiIcja5xIjg-5sI4ECvcV",
				checkbox: "_25sIJZLIxTa3eolXDWieo5"
			}
		},
		"./src/reddit/components/PostRailAndVotes/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/PostLeftRail/index.tsx"),
				a = n("./src/reddit/components/VerticalVotes/index.tsx"),
				d = n("./src/reddit/controls/Checkbox/index.tsx"),
				c = n("./src/reddit/helpers/isPost.ts"),
				l = n("./src/reddit/helpers/showReportIndicator/index.ts"),
				u = n("./src/reddit/components/PostRailAndVotes/index.m.less"),
				m = n.n(u);
			t.a = e => {
				const {
					model: t,
					handleVote: n,
					showBulkActionCheckbox: s = !1,
					isCheckboxSelected: u = !1,
					isCountAnimShadowTestEnabled: p,
					toggleCheckbox: b = (() => {}),
					flairStyleTemplate: f,
					redditStyle: h,
					isOverlay: _,
					isVoteCountAnimation: g,
					postId: v,
					shouldShowUpvoteRatioOnHover: x
				} = e, O = `upvote-button-${t.id}${_?"-overlay":""}`;
				return r.a.createElement(i.b, {
					isRemoved: !!t.bannedBy,
					isReported: Object(l.a)(t),
					isSponsored: !!Object(c.b)(t) && t.isSponsored,
					redditStyle: h
				}, s && r.a.createElement(d.a, {
					className: m.a.checkbox,
					isCheckboxSelected: u,
					toggleCheckbox: b
				}), r.a.createElement(a.a, {
					flairStyleTemplate: f,
					model: t,
					onVoteClick: n,
					redditStyle: h,
					upvoteTooltipId: O,
					isVoteCountAnimation: g,
					isCountAnimShadowTestEnabled: p,
					postId: v,
					scoreClassName: Object(o.a)(m.a.score, {
						[m.a.allowPointerEvents]: x
					}),
					shouldShowUpvoteRatioOnHover: x
				}))
			}
		},
		"./src/reddit/components/PostTitle/getLeftAndRightFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/Flair/index.ts");

			function o(e) {
				let {
					flair: t,
					isFlairPositionedLeft: n,
					showNSFWSpoilerFlairsOnly: o,
					hideNSFWSpoilerFlair: i
				} = e;
				const a = [],
					d = [],
					c = [];
				for (const m of t) m.type === r.f.Nsfw || m.type === r.f.Spoiler ? a.push(m) : Object(s.q)(m.type) ? d.push(m) : c.push(m);
				let l = [],
					u = [];
				return n ? o ? (l = a, u = []) : i ? (l = d, u = c) : (l = d, u = [...a, ...c]) : o ? (l = [], u = a) : i ? (l = [], u = [...d, ...c]) : (l = [], u = [...d, ...a, ...c]), {
					leftFlair: l,
					rightFlair: u
				}
			}
		},
		"./src/reddit/components/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				outboundLinkIcon: "qgDkGQIoFEpMMeNtfI0BY",
				pollMeta: "FKej75-i0z1XubMqeVh9Q",
				styledLink: "SQnoC3ObvgnGjWt90zD9Z",
				Title: "_2SdHzo12ISmrC8H86TgSCp",
				title: "_2SdHzo12ISmrC8H86TgSCp",
				titleContainer: "y8HYJ-y_lTUHkQIc1mdCq",
				isNoWrap: "_2_QBmCTk6VD4M3dvKqXD23",
				isVisitedEnabled: "_2INHSNB8V5eaWp4P0rY_mE",
				postTitleVisibility: "_1hLrLjnE1G_RBCNcN9MVQf",
				blur: "_1Y3R-LNfq0EOkZUcePSt1j",
				ExtraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				extraLarge: "_29WrubtjAcKqzJSPdQqQ4h",
				Large: "_3wqmjmv3tb_k-PROt7qFZe",
				large: "_3wqmjmv3tb_k-PROt7qFZe",
				Medium: "_1zpZYP8cFNLfLDexPY65Y7",
				medium: "_1zpZYP8cFNLfLDexPY65Y7",
				Small: "uWdXen_41bh0iwLrgzFkc",
				small: "uWdXen_41bh0iwLrgzFkc",
				ExtraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				extraSmall: "_1aqE18-N18ZIRlkE1wa7DP",
				Metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				metadata: "_2_YD0sbnnLrJvpCrMxBFaC",
				Component: "_2FCtq-QzlfuN-SwVMUZMM3",
				component: "_2FCtq-QzlfuN-SwVMUZMM3"
			}
		},
		"./src/reddit/components/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return D
			})), n.d(t, "a", (function() {
				return Y
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/polished/dist/polished.es.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				c = n("./node_modules/reselect/es/index.js"),
				l = n("./src/lib/ads/index.ts"),
				u = n("./src/lib/classNames/index.ts"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/contexts/PageLayer/index.tsx"),
				b = n("./src/reddit/controls/OutboundLink/index.tsx"),
				f = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				h = n("./src/lib/permalinkToOverlayLocation/index.ts"),
				_ = n("./src/reddit/actions/post.ts"),
				g = n("./src/reddit/helpers/path/index.ts"),
				v = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				x = n("./src/reddit/hooks/useClickSourceData.ts"),
				O = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts"),
				E = n("./src/reddit/hooks/usePostContext.ts"),
				y = n("./src/reddit/hooks/useTheme.ts"),
				C = n("./src/reddit/icons/fonts/index.tsx"),
				j = n("./src/reddit/models/Flair/index.ts"),
				k = n("./src/reddit/models/Media/index.ts"),
				I = n("./src/reddit/models/Prediction/Tournament/index.ts"),
				S = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				w = n("./src/lib/getShortenedLink.ts"),
				T = n("./src/reddit/components/FlairWrapper/index.tsx"),
				N = n("./node_modules/fbt/lib/FbtPublic.js"),
				P = n("./src/lib/prettyPrintNumber/index.ts"),
				R = n("./src/reddit/components/Poll/PollExpiry/index.tsx"),
				A = n("./src/reddit/components/Poll/PostTitleMetaData/index.m.less"),
				M = n.n(A);
			const L = Object(c.c)({
				poll: (e, t) => e.polls.models[t.pollId],
				resultsByVoters: (e, t) => e.polls.results.byVoters[t.pollId]
			});
			var D, F = Object(a.b)(L)((function(e) {
					const {
						poll: t,
						resultsByVoters: n
					} = e, s = n ? n.totalVotes : "0";
					return Object(O.a)() ? null : i.a.createElement("div", {
						className: Object(u.a)(e.className, M.a.proposalMetaData)
					}, i.a.createElement("span", null, N.fbt._({
						"*": "{count} votes",
						_1: "{count} vote"
					}, [N.fbt._param("count", Object(P.a)(s)), N.fbt._plural(parseInt(s))], {
						hk: "4rP1VK"
					})), t && i.a.createElement(R.a, {
						className: M.a.proposalExpiry,
						poll: t
					}))
				})),
				U = n("./src/reddit/components/SEOTitle/index.tsx"),
				B = n("./src/reddit/selectors/experiments/loggedOutBlockingInterstitial.ts"),
				q = n("./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				H = n("./src/telemetry/models/Outbound.ts"),
				W = n("./src/reddit/components/PostTitle/getLeftAndRightFlair.ts"),
				V = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				z = n("./src/reddit/components/PostTitle/index.m.less"),
				K = n.n(z);

			function Q() {
				return (Q = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}! function(e) {
				e[e.ExtraLarge = 0] = "ExtraLarge", e[e.Large = 1] = "Large", e[e.Medium = 2] = "Medium", e[e.Small = 3] = "Small", e[e.ExtraSmall = 4] = "ExtraSmall", e[e.Metadata = 5] = "Metadata"
			}(D || (D = {}));
			const Y = e => {
					let {
						size: t,
						titleColor: n,
						titleType: s,
						nowrap: r,
						children: o,
						className: a,
						redditStyle: d,
						shouldBlurTitle: c
					} = e;
					const l = Object(y.a)();
					let m = "";
					switch (t) {
						case D.ExtraLarge:
							m = K.a.ExtraLarge;
							break;
						case D.Large:
							m = K.a.Large;
							break;
						case D.Medium:
							m = K.a.Medium;
							break;
						case D.Small:
							m = K.a.Small;
							break;
						case D.ExtraSmall:
							m = K.a.ExtraSmall;
							break;
						case D.Metadata:
							m = K.a.Metadata
					}
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.Title, a, m, {
							[K.a.isNoWrap]: r,
							[K.a.blur]: c
						}),
						style: {
							"--posttitletextcolor": n || Object(S.a)({
								redditStyle: d,
								theme: l
							}).titleText
						}
					}, s ? i.a.createElement(U.b, {
						type: s
					}, o) : o)
				},
				J = e => {
					let {
						className: t,
						disableVisited: n,
						titleColor: s,
						children: r,
						...o
					} = e;
					return i.a.createElement(d.a, Q({}, o, {
						className: Object(u.a)(t, K.a.styledLink, {
							[K.a.isVisitedEnabled]: !n
						})
					}), r)
				},
				X = e => {
					let {
						disableVisited: t,
						nowrap: n,
						className: s,
						children: r
					} = e;
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.titleContainer, s, {
							[K.a.isNoWrap]: n,
							[K.a.isVisitedEnabled]: !t
						})
					}, r)
				},
				Z = Object(c.c)({
					flairPosition: (e, t) => {
						let {
							pageLayer: n
						} = t;
						return Object(p.r)(e, {
							pageLayer: n
						})
					},
					isNsfwBlurSubreddit: q.e,
					shouldOpenPostInNewTab: G.kb
				}),
				$ = e => {
					const {
						post: t,
						subreddit: n
					} = e, {
						isSponsored: s
					} = t, r = Object(a.d)(), o = Object(x.a)(), d = Object(a.e)(B.b), c = Object(a.e)(B.c), u = e => {
						!d && !c || t.media && Object(k.I)(t.media) || (e.preventDefault(), r(Object(_.ab)(Object(g.b)(t.permalink), t.id)))
					};
					if (e.isCommentsPage && !e.isCommentPermalink && !e.shouldLinkWrap) return i.a.createElement(X, {
						nowrap: e.nowrap
					}, i.a.createElement(ee, e));
					if (e.isCommentsPageAd && t.source && t.source.url) return i.a.createElement(b.b, {
						href: t.source.url,
						isSponsored: s,
						postId: t.id,
						source: t.source
					}, i.a.createElement(ee, e)); {
						const r = t.media && Object(k.I)(t.media) ? Object(v.c)(t.id, n.name) : t.permalink,
							a = e.isCommentPermalink ? Object(g.b)(r) : Object(h.a)(r, void 0, o);
						return i.a.createElement(X, {
							disableVisited: e.disableVisited,
							nowrap: e.nowrap
						}, s ? ((e, t) => {
							const {
								source: n
							} = Object(l.t)(e, t.imageGalleryCurrentItem);
							return n ? i.a.createElement(b.b, {
								href: n.url,
								isSponsored: e.isSponsored,
								postId: e.id,
								source: n
							}, i.a.createElement(ee, t)) : i.a.createElement(ee, t)
						})(t, e) : i.a.createElement(J, {
							className: e.titleLinkClassName,
							"data-click-id": "body",
							disableVisited: e.disableVisited,
							target: e.shouldOpenPostInNewTab ? "_blank" : void 0,
							titleColor: e.titleColor,
							to: a,
							onClick: u
						}, i.a.createElement(ee, e)))
					}
				},
				ee = e => {
					const {
						leftFlair: t,
						isCommentsPageAd: n,
						post: s
					} = e;
					let r = e.format ? e.format(s) : s.title;
					n && "string" == typeof r && (r = (e => {
						return e.length >= 250 ? e.slice(0, 250 - "...".length) + "..." : e
					})(r));
					const o = e.isCommentsPage ? U.a.PostComments : U.a.PostItem,
						a = !(!e.isNsfwBlurSubreddit || !e.post.isNSFW);
					return i.a.createElement(Y, {
						className: e.titleClassName,
						nowrap: e.nowrap,
						redditStyle: e.redditStyle || e.isCommentsPage || e.isCommentsPageAd,
						shouldBlurTitle: a,
						size: e.size,
						titleColor: e.titleColor,
						titleType: o
					}, t && i.a.createElement(T.a, {
						titleFlair: t,
						nowrap: !0,
						post: s,
						sendEvent: e.sendEvent
					}), r)
				},
				te = e => {
					const {
						hideSourceLink: t,
						isNsfwBlurSubreddit: n,
						post: s
					} = e, {
						isSponsored: r
					} = s, o = e.isCommentsPage ? H.SourceElement.PostLink : H.SourceElement.ListingPostLink;
					if (Object(O.a)()) return null;
					if (n && s.isNSFW) return null;
					const a = !t && !e.isCrosspost && e.size !== D.Large && !s.isSponsored && !(s.media && Object(k.I)(s.media)) && (s.source || s.media && (s.media.type === k.o.GIFVIDEO || s.media.type === k.o.IMAGE || s.media.type === k.o.EMBED));
					if (t || !e.isCommentsPage || e.isCommentPermalink || e.shouldLinkWrap) {
						if (a) return i.a.createElement(f.a, {
							className: e.outboundLinkClassName,
							href: Object(k.D)(s),
							isSponsored: r,
							postId: s.id,
							source: s.source,
							sourceElement: o
						}, Object(w.a)(s), !s.isSponsored && i.a.createElement(C.a, {
							name: "external_link",
							className: K.a.outboundLinkIcon
						}))
					} else if (s.source && !e.isCrosspost && e.size !== D.Large && e.size !== D.ExtraLarge) return i.a.createElement(f.a, {
						className: e.outboundLinkClassName,
						href: s.source.url,
						isSponsored: r,
						postId: s.id,
						source: s.source,
						sourceElement: o
					}, Object(w.a)(s), !s.isSponsored && i.a.createElement(C.a, {
						name: "external_link",
						className: K.a.outboundLinkIcon
					}));
					return null
				};
			class ne extends i.a.Component {
				getDynamicStyleTags() {
					return i.a.createElement("style", {
						dangerouslySetInnerHTML: {
							__html: `\n        .${this.props.post.id}.${K.a.Component} {\n          --postTitle-VisitedLinkColor: ${Object(r.c)(.45,Object(S.a)(this.props).titleText,"#FFFFFF")};\n          --postTitleLink-VisitedLinkColor: ${Object(r.c)(.45,this.props.titleColor||Object(S.a)(this.props).titleText,Object(S.a)(this.props).body)};\n          --postBodyLink-VisitedLinkColor: ${Object(r.c)(.45,Object(S.a)(this.props).bodyText,Object(S.a)(this.props).body)};\n        }\n      `
						}
					})
				}
				render() {
					const {
						className: e,
						disableFlair: t,
						flairPosition: n,
						isCommentsPage: r,
						isOverlay: o,
						poll: a,
						post: d,
						showNSFWSpoilerFlairsOnly: c,
						hideNSFWSpoilerFlair: l,
						onClick: m
					} = this.props, p = n === j.b.Left, b = Object(T.b)(d), {
						leftFlair: f,
						rightFlair: h
					} = Object(W.a)({
						flair: b,
						isFlairPositionedLeft: p,
						showNSFWSpoilerFlairsOnly: c,
						hideNSFWSpoilerFlair: l
					}), _ = !o && !r && !t, g = _ && f && f.length > 0, v = _ && h && h.length > 0;
					return i.a.createElement("div", {
						className: Object(u.a)(K.a.Component, e, d.id),
						ref: this.props.innerRef,
						"data-adclicklocation": V.a.TITLE,
						onClick: m
					}, !c && g && i.a.createElement(T.a, {
						isFlairFilter: !0,
						titleFlair: f,
						nowrap: !0,
						post: d,
						sendEvent: this.props.sendEvent
					}), !Object(I.b)(d) && i.a.createElement($, Q({}, this.props, {
						leftFlair: c ? f : void 0
					})), a && i.a.createElement(F, {
						className: K.a.pollMeta,
						pollId: a.id
					}), i.a.createElement(te, this.props), v && i.a.createElement(T.a, {
						isFlairFilter: !0,
						titleFlair: h,
						nowrap: !0,
						post: d,
						sendEvent: this.props.sendEvent
					}), i.a.createElement("div", {
						className: K.a.postTitleVisibility,
						dangerouslySetInnerHTML: {
							__html: `\n              <img alt="" src="${s.a.assetPath}/img/renderTimingPixel.png" style="width: 1px; height: 1px;" onLoad="(__markFirstPostVisible || function(){})();" />\n            `
						}
					}), this.getDynamicStyleTags())
				}
			}
			t.c = i.a.memo((function(e) {
				const t = Object(p.gb)(),
					n = Object(p.x)(t),
					s = Object(E.a)(),
					r = Object(a.e)(r => Z(r, {
						...s,
						...e,
						isCommentPermalink: n,
						pageLayer: t
					})),
					o = Object(y.a)(),
					d = Object(m.b)();
				return s ? i.a.createElement(ne, Q({
					pageLayer: t,
					isCommentPermalink: n
				}, s, r, e, {
					theme: o,
					sendEvent: d
				})) : null
			}))
		},
		"./src/reddit/components/PowerupsSettings/index.m.less": function(e, t, n) {
			e.exports = {
				contentContainer: "_2UnJkyErREO4UdPRO2_Nu_",
				formContainer: "_24DNbvpFOApkjl_aDxLQIe",
				emojiContainer: "KGb-9Fn_9opTkp9y4F7pK",
				emoteButtonContainer: "_3M018emNKEEexK1HjMZQTj",
				emoteButton: "_2f3AHI0QU_oQcjl8U5ZdRz",
				placeholderEmoteButton: "_2YQF3WYehiGNW2iR67S75X",
				uploadInput: "KmfMmSLuXzGdzc_3tPHy2",
				loadingContainer: "_2Z0VpSy4swcUtFNyxmSsg8",
				addButton: "_36wmuGVu3czQNqKncBoxBO",
				addButtonDisabled: "_3mYS-GLsakSC0Gu9a3ux8H",
				addIcon: "_3yRqzxOhoT1PNGoWZLh4bl"
			}
		},
		"./src/reddit/components/PowerupsSettings/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return R
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/config.ts"),
				a = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/reddit/hooks/useTracking.ts"),
				c = n("./src/reddit/actions/gold/powerups.ts"),
				l = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				u = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/reddit/actions/economics/powerups/index.ts"),
				b = n("./src/reddit/actions/toaster.ts"),
				f = n("./src/reddit/components/RichTextEditor/emotes/EmoteButton.tsx"),
				h = n("./src/reddit/components/RichTextEditor/emotes/Powerups/DeleteEmojiModal.tsx"),
				_ = n("./src/reddit/components/RichTextEditor/emotes/Powerups/useEmojiUpload.ts"),
				g = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				v = n("./src/reddit/helpers/trackers/powerups.ts"),
				x = n("./src/reddit/icons/svgs/AddSquare/index.tsx"),
				O = n("./src/reddit/models/Toast/index.ts"),
				E = n("./src/reddit/selectors/gold/powerups/index.ts"),
				y = n("./src/reddit/components/PowerupsSettings/index.m.less"),
				C = n.n(y);
			const j = e => {
				let {
					subredditId: t
				} = e;
				const n = Object(o.d)(),
					i = Object(d.a)(),
					[c, l] = Object(s.useState)(null),
					u = () => l(null),
					[y, j] = Object(s.useState)(!1),
					k = Object(o.e)(e => Object(E.c)(e, {
						subredditId: t
					})),
					{
						uploadInput: I,
						maxEmojisUploading: S,
						numUploading: w,
						onFileChange: T,
						onClickUpload: N
					} = Object(_.a)(t, k, e => {
						n(Object(b.f)({
							duration: b.a,
							kind: O.b.Error,
							text: a.fbt._({
								"*": "You can only add {number} more emojis.",
								_1: "You can only add 1 more emoji."
							}, [a.fbt._plural(e, "number")], {
								hk: "117Ker"
							})
						}))
					}, e => {
						i(Object(v.a)(e, "mod_tools"))
					}, e => {
						i(Object(v.e)(e, "mod_tools")), n(Object(b.f)({
							duration: b.a,
							kind: O.b.SuccessCommunity,
							text: a.fbt._({
								"*": "Looking good! Emojis added.",
								_1: "Looking good! Emoji added."
							}, [a.fbt._plural(e)], {
								hk: "43WkeN"
							})
						}))
					}, e => {
						n(Object(b.f)({
							duration: b.a,
							kind: O.b.Error,
							text: a.fbt._({
								"*": "Failed to upload {number} emojis",
								_1: "Failed to upload 1 emoji"
							}, [a.fbt._plural(e, "number")], {
								hk: "2s093I"
							})
						}))
					}),
					P = S;
				return r.a.createElement(r.a.Fragment, null, r.a.createElement("input", {
					ref: I,
					className: C.a.uploadInput,
					onChange: T,
					type: "file",
					accept: "image/png,image/jpeg",
					multiple: !0
				}), w ? r.a.createElement("div", {
					className: C.a.loadingContainer
				}, r.a.createElement(x.a, {
					className: C.a.addIcon
				})) : r.a.createElement("button", {
					className: Object(m.a)(C.a.emoteButton, C.a.addButton, {
						[C.a.addButtonDisabled]: P
					}),
					disabled: P,
					onClick: N,
					title: a.fbt._("Add Custom Emoji", null, {
						hk: "M580t"
					})
				}, r.a.createElement(x.a, {
					className: C.a.addIcon
				})), k.map(e => r.a.createElement(f.a, {
					key: e.id,
					className: C.a.emoteButton,
					containerClassName: C.a.emoteButtonContainer,
					imageClassName: C.a.customEmoteImage,
					imagePath: e.emoji.path,
					onClickDelete: () => l(e),
					mouseEnterBufferTime: 0
				})), [...Array(w)].map((e, t) => r.a.createElement("div", {
					key: t,
					className: Object(m.a)(C.a.emoteButton, C.a.placeholderEmoteButton)
				}, r.a.createElement(g.a, {
					sizePx: 12,
					center: !0
				}))), c && r.a.createElement(h.a, {
					emojiUrl: c.emoji.path,
					onCancel: u,
					onClose: u,
					onConfirm: async () => {
						if (c && !y) try {
							j(!0), await n(Object(p.a)({
								subredditId: t,
								emojiId: c.id
							})), u(), i(Object(v.b)(1, "mod_tools")), n(Object(b.f)({
								duration: b.a,
								kind: O.b.SuccessCommunity,
								text: a.fbt._("Emoji removed.", null, {
									hk: "3Ox8xb"
								})
							}))
						} catch (e) {
							n(Object(b.f)({
								duration: b.a,
								kind: O.b.Error,
								text: a.fbt._("Failed to delete emoji", null, {
									hk: "2GukOR"
								})
							}))
						} finally {
							j(!1)
						}
					}
				}))
			};
			var k = n("./src/reddit/components/Settings/shared/SectionHeading.tsx"),
				I = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				S = n("./src/reddit/models/Gold/Powerups/index.ts"),
				w = n("./src/reddit/selectors/experiments/econ/index.ts"),
				T = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				N = n("./src/reddit/selectors/gold/powerups/benefitSettings.ts"),
				P = n("./src/reddit/selectors/subreddit.ts");
			const R = e => {
				let {
					subredditId: t
				} = e;
				const n = Object(o.d)(),
					s = Object(d.a)(),
					m = Object(o.e)(e => Object(E.b)(e, {
						subredditId: t
					})),
					p = Object(o.e)(e => Object(P.Y)(e, {
						subredditId: t
					})),
					b = Object(o.e)(e => Object(N.a)(e, {
						subredditId: t
					})),
					f = (null == b ? void 0 : b[S.a.CommentsWithGifs]) || !1,
					h = Object(o.e)(T.b),
					_ = Object(o.e)(w.d);
				return r.a.createElement(u.a, {
					className: C.a.contentContainer
				}, r.a.createElement(u.b, null, a.fbt._("Powerups settings", null, {
					hk: "1OxM4K"
				}), r.a.createElement(l.a, {
					linkUrl: `${i.a.redditModHelpUrl}/hc/en-us/articles/4403699823629`
				})), r.a.createElement("div", {
					className: C.a.formContainer
				}, m && r.a.createElement(r.a.Fragment, null, r.a.createElement(k.a, null, a.fbt._("Comments", null, {
					hk: "1TCs6F"
				})), !h && r.a.createElement(I.p, {
					on: f,
					onClick: () => (e => {
						s(Object(v.f)("comments_with_gifs", e, !e)), n(Object(c.f)(t, {
							[S.a.CommentsWithGifs]: e
						}))
					})(!f),
					label: a.fbt._("Allow GIFs in comments", null, {
						hk: "2nJiHt"
					}),
					subtext: a.fbt._("It may take a few minutes to update", null, {
						hk: "aU7tk"
					})
				}), !_ && r.a.createElement(r.a.Fragment, null, r.a.createElement(I.l, {
					label: a.fbt._("{subreddit name} emojis", [a.fbt._param("subreddit name", p.displayText)], {
						hk: "4tuD3i"
					}),
					subtext: a.fbt._("Add up to 20 custom emojis. Images under 128kb with a transparent background work the best.", null, {
						hk: "EAXAA"
					})
				}), r.a.createElement("div", {
					className: C.a.emojiContainer
				}, r.a.createElement(j, {
					subredditId: t
				}))))))
			}
		},
		"./src/reddit/components/ProfileIdCard/AwardedLastMonth.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/config.ts"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./src/reddit/components/ProfileIdCard/index.m.less"),
				d = n.n(a);
			const {
				fbt: c
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class l extends r.a.PureComponent {
				render() {
					const {
						topAwardIcon: e,
						recentAwardings: t,
						username: n
					} = this.props;
					if (!t.topAward) return null;
					const {
						topAward: s,
						totalCount: a
					} = t, l = s.description ? s.description : s.name;
					return r.a.createElement("a", {
						className: d.a.AwardedLastMonth,
						href: `${o.a.oldRedditUrl}/user/${n}/gilded`
					}, r.a.createElement("div", {
						className: d.a.iconColumn
					}, r.a.createElement("img", {
						alt: l,
						className: d.a.icon,
						src: e
					}), a > 1 && r.a.createElement("span", {
						className: d.a.count
					}, `+${Object(i.b)(a-1)}`)), r.a.createElement("div", {
						className: d.a.textColumn
					}, c._({
						"*": "Received the {award-name} Award and more in the past 30 days",
						_1: "Received the {award-name} Award in the past 30 days"
					}, [c._param("award-name", s.name), c._plural(a)], {
						hk: "16MJHe"
					})))
				}
			}
			t.a = l
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less": function(e, t, n) {
			e.exports = {
				Banner: "_2ZyL7luKQghNeMnczY3gqW",
				banner: "_2ZyL7luKQghNeMnczY3gqW"
			}
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/models/Image/index.tsx"),
				a = n("./src/reddit/components/EditableImage/index.tsx"),
				d = n("./src/reddit/models/User/index.ts"),
				c = n("./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts"),
				l = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.m.less"),
				u = n.n(l);
			class m extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						isUpdating: !1
					}, this.updateProfileIcon = async (e, t) => {
						const n = await Object(i.e)(e);
						this.setState({
							isUpdating: !0
						}, async () => {
							await this.props.imageUpdateRequested(n, "profileBanner"), this.setState({
								isUpdating: !1
							})
						})
					}
				}
				render() {
					const {
						bannerUrl: e,
						className: t,
						currentUser: n,
						hideNSFWPref: r,
						isNSFW: i,
						userName: c
					} = this.props, {
						isUpdating: l
					} = this.state, m = e ? o.a.createElement("div", {
						className: u.a.Banner,
						style: {
							backgroundImage: `url(${e})`
						}
					}) : null;
					return n && Object(d.e)(n) === c ? o.a.createElement(a.a, {
						altText: s.fbt._("{userName} banner image", [s.fbt._param("userName", c)], {
							hk: "1PcEBS"
						}),
						className: t,
						isLoading: l,
						onFileSelected: this.updateProfileIcon
					}, m) : i && r ? null : m
				}
			}
			t.a = Object(c.a)(m)
		},
		"./src/reddit/components/ProfileIdCard/ProfileImage/connector.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/preferences.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = Object(r.c)({
					currentUser: i.l,
					hideNSFWPref: i.G
				}),
				d = Object(s.b)(a, e => ({
					imageUpdateRequested: (t, n) => e(Object(o.D)(t, n))
				}));
			t.a = d
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router/esm/react-router.js"),
				d = n("./src/reddit/actions/post.ts"),
				c = n("./src/reddit/actions/snoovatarModal.ts"),
				l = n("./src/reddit/components/TrackingHelper/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/helpers/trackers/snoovatar.ts"),
				p = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				b = n("./src/reddit/models/Vote/index.ts"),
				f = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				h = n.n(f);
			const {
				fbt: _
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = Object(a.i)(e => {
				let {
					isHovercard: t,
					username: n,
					isAvatarPost: a,
					post: f,
					share: g
				} = e;
				const v = Object(l.b)(),
					x = Object(i.d)(),
					O = f && f.id,
					E = f && f.voteState;
				let y = null;
				O || (y = t ? "user_hovercard" : "profile_overview");
				const C = Object(r.useCallback)(() => v(Object(m.h)(t ? "user_hovercard" : "profile_overview", n)), [t, v, n]);
				return o.a.createElement(u.t, {
					onClick: () => {
						a ? (v(m.i), O && E === b.a.notVoted && x(Object(d.jb)(O))) : C();
						const e = a ? "postify" : "copy";
						x(Object(c.b)({
							clickSource: y,
							share: g,
							source: e
						}))
					},
					className: Object(s.a)(h.a.snoovatarButton, h.a.snoovatarExtraPadding, h.a.compactButtonLayout, {
						[h.a.avatarPostifyButton]: a
					}),
					isFullWidth: !0
				}, o.a.createElement(p.a, {
					className: Object(s.a)({
						[h.a.shirtIcon]: !a,
						[h.a.avatarPostButtonShirtIcon]: a
					})
				}), _._("Try this Look", null, {
					hk: "dOuPb"
				}), o.a.createElement("div", {
					className: h.a.chevronIcon
				}))
			})
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarButton: "_3F1tNW0P4Ff182mO_CefIg",
				avatarPostifyButton: "_2Viile0fcrruho_hQqpnUx",
				snoovatarExtraPadding: "_3DnDqV66Np6rVEiI8QK7kl",
				shirtIcon: "_3gYTHRBO1S_S5AOddgqD6Z",
				avatarPostButtonShirtIcon: "ARFP2bx6U967JwMoJ2Xr5",
				compactButtonLayout: "VFbNvXfZXUhRFiCTDHO6f",
				chevronIcon: "_12pWM-aURvVUuSrUyqfNZh"
			}
		},
		"./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/icons/svgs/Shirt/index.tsx"),
				c = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.m.less"),
				l = n.n(c);
			const {
				fbt: u
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					compact: t,
					currentUserHasSnoovatar: n,
					className: s,
					isOwnProfile: c,
					onClick: m
				} = e;
				return r.a.createElement(i.t, {
					onClick: m,
					isFullWidth: !0,
					className: Object(o.a)(l.a.snoovatarButton, {
						[l.a.snoovatarExtraPadding]: !n && c,
						[l.a.compactButtonLayout]: t
					}, s)
				}, n ? r.a.createElement(d.a, {
					className: l.a.shirtIcon
				}) : r.a.createElement("div", {
					className: l.a.shirtIcon
				}), n ? u._("Style Avatar", null, {
					hk: "UEtBO"
				}) : c ? u._("Create Avatar", null, {
					hk: "2pJgje"
				}) : u._("Create Your Own Avatar", null, {
					hk: "22FFcO"
				}), n ? r.a.createElement("div", {
					className: l.a.chevronIcon
				}) : r.a.createElement(a.a, {
					name: "caret_right",
					className: l.a.chevronIcon
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less": function(e, t, n) {
			e.exports = {
				BannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				bannerWrapper: "_8AZ553JgDTNn5ZUmBdXkR",
				BannerImage: "_1IvROQ79nAJZ87_JkTFsLO",
				bannerImage: "_1IvROQ79nAJZ87_JkTFsLO"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				i = n("./src/reddit/icons/svgs/Close/index.tsx"),
				a = n("./src/reddit/components/ProfileIdCard/ProfileImage/ProfileBanner/index.tsx"),
				d = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.m.less"),
				c = n.n(d),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				u = n.n(l);
			t.a = function(e) {
				let {
					bannerBackgroundImage: t,
					isNSFW: n,
					username: s,
					editMode: d,
					isDeletingBanner: l,
					onDeleteBanner: m
				} = e;
				return r.a.createElement("div", {
					className: c.a.bannerWrapper
				}, r.a.createElement(a.a, {
					bannerUrl: t,
					isNSFW: n,
					userName: s
				}), d && t && (l ? r.a.createElement(o.a, {
					sizePx: 20,
					className: u.a.loadingIcon
				}) : r.a.createElement(i.a, {
					className: u.a.closeIcon,
					onClick: m
				})))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/InternalLink/index.tsx"),
				i = n("./src/reddit/components/HumanDate/index.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			t.a = function(e) {
				let {
					className: t,
					shouldDisplaySnoovatar: n,
					url: s,
					userCreated: d,
					username: c,
					...l
				} = e;
				const u = n ? r.a.createElement(r.a.Fragment, null, "u/", c, " · ", r.a.createElement(i.d, {
					seconds: d,
					noPostfix: !0,
					shortenedUnit: !0
				})) : `u/${c}`;
				return s ? r.a.createElement(o.default, a({}, l, {
					className: t,
					to: s
				}), u) : r.a.createElement("span", a({}, l, {
					className: t
				}), u)
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_2DTxp6tzlJMeNlZ-cjXWTs",
				closeIcon: "_2ioQgcdZvYlf34S0OEqBuQ",
				settingsIcon: "A4Iifg_NCOrfabq0ON3mW"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/components/Econ/Marketplace/NftProfileUnit/async.ts"),
				d = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				c = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				u = n.n(l);
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const m = 25;

			function p(e, t) {
				return Object.keys(t).filter(t => 0 === t.indexOf(e)).map(e => t[e])
			}

			function b(e) {
				return e[Math.floor(Math.random() * e.length)]
			}
			const f = p("particleDelay", u.a),
				h = p("particleX", u.a),
				_ = p("particleFloat", u.a),
				g = () => {
					const e = b(h),
						t = b(_),
						n = b(f);
					return Object(r.a)(u.a.particle, e, t, n)
				};
			class v extends i.a.Component {
				shouldComponentUpdate() {
					return !1
				}
				render() {
					const e = [];
					for (let t = 0; t < m; t++) e.push(this.createParticle(t));
					return i.a.createElement("div", {
						role: "presentation",
						className: u.a.particleWrapper
					}, e)
				}
				createParticle(e) {
					return i.a.createElement("div", {
						key: e,
						className: `${g()}`
					})
				}
			}
			var x = v;
			const O = e => {
				let {
					className: t,
					isGold: n,
					snoovatarUrl: o,
					prefersReducedAnimations: l,
					origin: m
				} = e;
				const p = o && Object(c.d)(o),
					b = m === d.a.Profile,
					f = m === d.a.Hovercard;
				return p ? i.a.createElement("div", {
					className: Object(r.a)({
						[u.a.profileTreatment]: b,
						[u.a.hovercardTreatment]: f
					})
				}, i.a.createElement("div", {
					className: u.a.nftProfileUnitContainer
				}, i.a.createElement(a.a, {
					className: u.a.nftProfileUnit,
					imageUrl: o,
					origin: m
				}))) : i.a.createElement("div", {
					className: Object(r.a)(u.a.snoovatarContainer, t)
				}, n && i.a.createElement(i.a.Fragment, null, i.a.createElement("div", {
					className: u.a.topGlow
				}), i.a.createElement("div", {
					className: u.a.bottomGlow
				}), !l && i.a.createElement(x, null)), i.a.createElement("img", {
					className: Object(r.a)(u.a.snoovatar, {
						[u.a.premiumGlow]: n
					}),
					src: o,
					alt: s.fbt._("User Avatar", null, {
						hk: "3aQoRV"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				d = n("./src/reddit/icons/svgs/Nsfw/index.tsx"),
				c = n("./src/reddit/icons/svgs/PremiumCircle/index.tsx"),
				l = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				u = n.n(l);
			t.a = e => {
				let {
					title: t,
					username: n,
					isEmployee: o,
					isGold: l,
					isNSFW: m
				} = e;
				return i.a.createElement("h1", {
					className: u.a.snoovatarUserTitle
				}, t || n, o && i.a.createElement(a.a, {
					className: u.a.snoovatarAdminIcon,
					title: r.fbt._("Reddit admin", null, {
						hk: "goUUb"
					})
				}), l && i.a.createElement("a", {
					title: r.fbt._("{username} has Reddit Premium", [r.fbt._param("username", n)], {
						hk: "3Fylv"
					}),
					href: `${s.a.redditUrl}/premium`
				}, i.a.createElement(c.a, {
					className: u.a.snoovatarPremiumIcon
				})), m && i.a.createElement(d.a, {
					className: u.a.snoovatarNsfwIcon,
					title: r.fbt._("NSFW - Adult Content", null, {
						hk: "2Iw7mN"
					})
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less": function(e, t, n) {
			e.exports = {
				snoovatarContainer: "_34XIqvI8-YT1wukR_W8vj6",
				profileTreatment: "_2xpFvOlDs0HF8bwR0pDmqt",
				hovercardTreatment: "_34eH8NsQ_ay5kowUWt9-6E",
				nftProfileUnitContainer: "OfvB_Czxn5wwXiBN6RVlG",
				nftProfileUnit: "n5OW4wkmX5R3yYizuJXw1",
				bottomGlow: "_18b8M-cZftX_frkYRy3DN1",
				topGlow: "_1-PwjX8ETMrfCu2hAkAHFd",
				snoovatar: "_2bLCGrtCCJIMNCZgmAMZFM",
				premiumGlow: "_18BjSGkpIVVfS1xJXL1eoW",
				snoovatarUserName: "_28nEhn86_R1ENZ59eAru8S",
				snoovatarUserTitle: "_3LM4tRaExed4x1wBfK1pmg",
				snoovatarSettingsLink: "PNl4tAYE2TRxhOc34iqcY",
				snoovatarAdminIcon: "kOKnXvA8jebkfk2wVIb9R",
				snoovatarNsfwIcon: "Wb4wBt474lETdwG0YpWID",
				snoovatarPremiumIcon: "_3NZUKOdsA_2X9TrZGSNQyP",
				particleWrapper: "_3sckwXGpSWEBLgH7dBHDSI",
				particle: "R8JC02qFTBSKsWVEamnnh",
				particleX0: "_2FHPkirHUUZZ53WuQRt_ku",
				particleX20: "DeM4CXWl9dmFhzxbChV3v",
				particleX40: "_2jQr36LfrhyZudo0c4r5qb",
				particleX60: "_2ThlCGLfserHkMW64od-w_",
				particleX80: "_2PoCUl_D7HnNn8GhlmyNMn",
				particleX100: "_3xLPb9tG5DMGKH5Qmq0lMn",
				particleFloat1: "_2Tlu1OsBOwuxXIF1MLT2k",
				floatUp1: "_1-74-z_0KhbvP-MLUh63RF",
				particleFloat2: "BW4L6Zj7IYZtY4carTDWz",
				floatUp2: "BhXouEsciSb0lIayg329d",
				particleFloat3: "UjQ0lRcZlylUigyKGCSrO",
				floatUp3: "_2cAI3EiKyyG1hMFOLbG7ka",
				particleFloat4: "_2_ke4gf08pfYrY6lP-aPZ_",
				floatUp1Left: "_2D7to5Dk7q0ZyKN3MMQfuJ",
				particleFloat5: "_2wM6_vp4fY0ziLkOrGaobV",
				floatUp2Left: "_3BR2d3YbOQLeA3LmAmwBJL",
				particleFloat6: "_23n0biPU5CQf96pEUSFupJ",
				floatUp3Left: "_3FnzyfIl1wHuAYA54rlkJH",
				particleDelay1: "_3meTYeYw1F3UdYO0v-gAYr",
				particleDelay2: "_3d8_fd8LwWsj0tyZWIeQdt",
				particleDelay3: "_2PLSBdnBk3jcotYknlKud1",
				particleDelay4: "_2pnTv5ZAxpIbkx38PkPJPg",
				particleDelay5: "_3j1NzwW_t2Ufnx4ed9QabN",
				particleDelay6: "_1hddWHnQ8DFnwilLlN9GEO",
				particleDelay7: "_3eRR1I_MwXC19q9sr8mKaR",
				particleDelay8: "_1sCUpg4sdajNDXrcNTP0qW",
				particleDelay9: "_3J5h1MCyY_xUf2QP7PDSHY",
				particleDelay10: "_2RqcLn9onSZQmKQgvKmSF7"
			}
		},
		"./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/helpers/trackers/marketplace/claims.ts"),
				d = n("./src/reddit/icons/fonts/index.tsx"),
				c = n("./src/reddit/selectors/experiments/econ/index.ts"),
				l = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/index.tsx"),
				u = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				m = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserBanner/index.tsx"),
				p = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserName.tsx"),
				b = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/index.m.less"),
				f = n.n(b),
				h = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserProfile.m.less"),
				_ = n.n(h),
				g = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/AvatarImage.tsx"),
				v = n("./src/reddit/components/ProfileIdCard/UserProfileOverview/UserSnoovatar/UserInformation.tsx");
			t.a = e => {
				let {
					bannerBackgroundImage: t,
					compact: n,
					currentUserHasSnoovatar: s,
					editMode: b,
					isDeletingBanner: h,
					isEmployee: x,
					isGold: O,
					isNSFW: E,
					isOwnProfile: y,
					onClickSnoovatar: C,
					onDeleteBanner: j,
					prefersReducedAnimations: k,
					snoovatarUrl: I,
					title: S,
					userCreated: w,
					username: T,
					url: N,
					isHovercard: P
				} = e;
				const R = Object(o.e)(e => !y && !!I && Object(c.c)(e));
				return r.a.createElement(r.a.Fragment, null, r.a.createElement(m.a, {
					bannerBackgroundImage: t,
					editMode: !!b,
					isNSFW: E,
					username: T,
					isDeletingBanner: !!h,
					onDeleteBanner: j
				}), !b && y && r.a.createElement(i.default, {
					to: "/settings/profile",
					className: f.a.snoovatarSettingsLink
				}, r.a.createElement(d.a, {
					name: "settings",
					className: _.a.settingsIcon
				})), r.a.createElement(g.a, {
					isGold: O,
					snoovatarUrl: I,
					prefersReducedAnimations: k,
					origin: P ? a.a.Hovercard : a.a.Profile
				}), r.a.createElement(v.a, {
					isEmployee: x,
					isGold: O,
					isNSFW: E,
					title: S,
					username: T
				}), r.a.createElement(p.a, {
					className: f.a.snoovatarUserName,
					shouldDisplaySnoovatar: !0,
					username: T,
					userCreated: w,
					url: N
				}), (y || !s && !!I) && r.a.createElement(l.a, {
					compact: n,
					currentUserHasSnoovatar: s,
					isOwnProfile: y,
					onClick: C
				}), R && r.a.createElement(u.a, {
					username: T,
					isHovercard: !!P,
					share: {
						username: T
					}
				}))
			}
		},
		"./src/reddit/components/ProfileIdCard/index.m.less": function(e, t, n) {
			e.exports = {
				actionItem: "_1l7CTV4NjDjmzX8DiiSgTL",
				AwardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				awardedLastMonth: "oZjk-MiWCU7KVYej9wPSw",
				textColumn: "_wi1DtT7oN7k_x5oIV8zm",
				iconColumn: "_32tzMaZn7x3dfQC5MXndJn",
				icon: "_12jN4wdttUosp76WHzuieI",
				count: "_6xPPP5HdELF-SZJL8layH",
				awardIcon: "_2Eq8z6UD7I0ul3wnZ-YT80",
				adminIcon: "_1sNQxemH_0rq1jtZAMyAZd",
				snoovatarAdminIcon: "_1rf3zLc4sH59mO7_BEXyze",
				snoovatarPremiumIcon: "_3QQFENUs15G6BHI5pjsswJ",
				button: "_2q1wcTx60QKM_bQ1Maev7b"
			}
		},
		"./src/reddit/components/ProgressBar/index.m.less": function(e, t, n) {
			e.exports = {
				innerBar: "Db3WJFTcyAR-IM0cIkpDG",
				outerBar: "i8kQtxHYBB8Sb3bPI4M_e"
			}
		},
		"./src/reddit/components/ProgressBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/ProgressBar/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					className: t,
					innerBarClassName: n,
					percent: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.outerBar, t)
				}, r.a.createElement("div", {
					className: Object(o.a)(a.a.innerBar, n),
					style: {
						width: `${s.toFixed(2)}%`
					}
				}))
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPost/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1FLO1Nek2YpspMr4ozmJCU"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostCommunityLink/index.m.less": function(e, t, n) {
			e.exports = {
				link: "_2sOYhKsA_6kr-jal5uxghX",
				subredditName: "Y6X1Z6XpPZ42HHxG6iPUg",
				subredditIcon: "_3KW4JGkWWYds_QkhJav3lV"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostInformation/index.m.less": function(e, t, n) {
			e.exports = {
				postInformation: "_1ykNwWxnTMBSi_9FpI1aS9",
				interactions: "_17rAVV4Z_xjSbW2Dnzd6GG",
				title: "_1hY0DyJaLGV23_ZN7lGZLl"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPostMedia/index.m.less": function(e, t, n) {
			e.exports = {
				media: "N08zT4c39PJ7xCbcR2dhy",
				mediaThumbnail: "_9U9c34f1Ov1YZrnCNbH_e",
				mediaThumbnailContainer: "OBfGp3Y3pfXQbQtgTek4B",
				userIconContainer: "_1Xl-Y2ofyQhQDptuCNW3gg",
				userIconWrapper: "F_vBi78s0CDuAiX2g82hg",
				userIcon: "_3Ba5v_JdXj-iGcinxrYkz6",
				defaultUserIcon: "_2Jv4FE0k7dgPuiylbWWXJg",
				snoovatarUserIcon: "X3oFujh1WDeA5ZdMgFl_h"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/PromotedUserPosts/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_2trYWJQru0_I7CsxK5kt7W"
			}
		},
		"./src/reddit/components/PromotedUserPostsAd/index.m.less": function(e, t, n) {
			e.exports = {
				container: "sMTOozCI4j186nHWW2jp4",
				communityLink: "_1iVqrl2JSOJGHlr6UhojWd"
			}
		},
		"./src/reddit/components/PublicAccessNetwork/LiveVideoPlayer/videoContext.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			const o = Object(s.createContext)({
					currentTime: 0,
					setCurrentTime: () => {},
					isLive: !1,
					setIsLive: () => {},
					totalTime: 0,
					setTotalTime: () => {}
				}),
				i = e => {
					let {
						children: t
					} = e;
					const [n, i] = Object(s.useState)(0), [a, d] = Object(s.useState)(!1), [c, l] = Object(s.useState)(0), u = {
						currentTime: n,
						setCurrentTime: i,
						isLive: a,
						setIsLive: d,
						totalTime: c,
						setTotalTime: l
					};
					return r.a.createElement(o.Provider, {
						value: u
					}, t)
				}
		},
		"./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			const r = e => `PublicAccessNetwork--VideoShare--Modal-${e}`,
				o = Object(s.a)({
					resolved: {},
					chunkName: () => "VideoShareModal",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("VideoShareModal").then(n.bind(null, "./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/VideoShareModal.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/VideoShareModal.tsx"
					}
				}, {
					ssr: !1
				});
			t.b = o
		},
		"./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less": function(e, t, n) {
			e.exports = {
				button: "_1i9YssSDgp0wmEC43VdLTX",
				prevButton: "_2IBDYNRoTxtwgs13LWRpeM",
				arrowIcon: "QD6Re7us6VNRFNYSiD6to",
				disabled: "_3Lm3n-nPFfEcJoNjVwcm3r"
			}
		},
		"./src/reddit/components/RecurringPostList/EditModal/async.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-RecurringPostList-EditModal",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-RecurringPostList-EditModal").then(n.bind(null, "./src/reddit/components/RecurringPostList/EditModal/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/RecurringPostList/EditModal/index.tsx"
				}
			})
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less": function(e, t, n) {
			e.exports = {
				contentRow: "Bt3uIal7yhwFSN9JorIng",
				contentRowMeta: "t6hD4d7F06TL2yv9vfp7h",
				title: "_3Evplg8YGmH6GDFsdQ0_nE",
				ownerName: "_215cUXwEuCE5hl0eYEIt_o",
				ownerNameContainer: "_2yAEv_Vw_ItUYbNbAjpSsL"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_29n8ITXzfA7e5YAUZXR5Tv",
				failedStateIndicator: "_3wJPsvksvDytrEsrrZd1vI",
				metaRow: "NjfRmSRZrEkWYNAACYBql",
				replayIcon: "_17pwQtUdmIHAeybqNegNzP",
				metaRowText: "qlCreM7NlHbkzV-xkEGE7",
				recurrenceRules: "rX2aiRDwgPF22x70hQxqp",
				parametricMetaData: "_3mlGpRO1Z1gZJkATQcRNHO",
				pencilIcon: "z5A_DxaYn2G2TQSSQCpi2"
			}
		},
		"./src/reddit/components/RecurringPostList/RecurringPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return A
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/telemetry/index.ts"),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/scheduledPosts/index.ts"),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/components/AuthorLink/index.tsx"),
				m = n("./src/reddit/components/Thumbnail/index.tsx"),
				p = n("./src/reddit/components/RecurringPostList/Thumbnail/index.m.less"),
				b = n.n(p);
			var f = e => {
					let {
						post: t
					} = e;
					return r.a.createElement("div", {
						className: b.a.thumbnailContainer
					}, r.a.createElement(m.b, {
						post: t,
						contentTypeClassName: b.a.placeholderIcon
					}))
				},
				h = n("./src/reddit/components/ScheduledPost/index.tsx"),
				_ = n("./src/reddit/models/ScheduledPost/index.ts"),
				g = n("./node_modules/reselect/es/index.js"),
				v = n("./src/reddit/components/RecurringPostList/RecurringPost/ContentMeta/index.m.less"),
				x = n.n(v);
			const {
				fbt: O
			} = n("./node_modules/fbt/lib/FbtPublic.js"), E = Object(g.c)({
				media: (e, t) => {
					let {
						scheduledPost: n
					} = t;
					const s = {
							...h.b
						},
						r = n.postKind === _.e.LINK;
					return r && (s.media = null), {
						...s,
						isNSFW: n.isNsfw,
						title: n.title,
						...r && {
							source: n.url
						},
						pollData: n.poll
					}
				}
			});
			var y = Object(o.b)(E)(e => {
					const {
						scheduledPost: t
					} = e, {
						isPostAsMetaMod: n,
						owner: s
					} = t, o = n ? l.m : Object(_.o)(s) ? s.name : void 0;
					return r.a.createElement("div", {
						className: Object(a.a)(x.a.contentRow, e.className)
					}, r.a.createElement(f, {
						post: e.media
					}), r.a.createElement("div", {
						className: x.a.contentRowMeta
					}, r.a.createElement("div", {
						className: x.a.title
					}, e.scheduledPost.title), r.a.createElement("div", {
						className: x.a.ownerNameContainer
					}, o && r.a.createElement("span", {
						className: x.a.ownerName
					}, O._("by {username}", [O._param("username", r.a.createElement(u.a, {
						author: o,
						isUnstyled: !0
					}, `u/${o}`))], {
						hk: "FAgpK"
					})), e.children)))
				}),
				C = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx");
			var j = Object(C.a)(e => r.a.createElement(r.a.Fragment, null, e.renderOverflowMenu())),
				k = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				I = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				S = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				w = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				T = n("./src/reddit/icons/svgs/Replay/index.tsx"),
				N = n("./src/reddit/components/RecurringPostList/RecurringPost/index.m.less"),
				P = n.n(N);
			const {
				fbt: R
			} = n("./node_modules/fbt/lib/FbtPublic.js"), A = "RECURRING_POSTS__EDIT", M = Object(o.b)(null, (e, t) => ({
				editRecurringPostRequested: () => {
					e(Object(c.c)({
						id: t.item.id,
						subredditId: t.item.subreddit.id
					})), e((e, t) => Object(i.a)(Object(S.e)()(t()))), e(Object(d.i)(A))
				},
				onOpenOverflow: () => {
					e((e, t) => Object(i.a)(Object(S.h)(!0)(t())))
				},
				onUpdateMetadata: n => e(Object(c.b)(n, t.item))
			}));
			class L extends r.a.PureComponent {
				render() {
					const {
						className: e,
						item: t,
						editRecurringPostRequested: n
					} = this.props, s = Object(I.e)(t), o = t.state === _.f.FAILED, {
						owner: i
					} = t, d = Object(_.o)(i) && i.prefixedName;
					return r.a.createElement("div", {
						className: Object(a.a)(e, P.a.container)
					}, o && r.a.createElement("div", {
						className: P.a.failedStateIndicator
					}, R._("Recurring post failed to submit. {Link: update recurring scheduled post} to reset", [R._param("Link: update recurring scheduled post", r.a.createElement(k.o, {
						onClick: n
					}, "Update schedule"))], {
						hk: "3Uitas"
					})), r.a.createElement("div", {
						className: P.a.metaRow
					}, r.a.createElement(T.a, {
						className: P.a.replayIcon
					}), r.a.createElement("div", {
						className: P.a.metaRowText
					}, r.a.createElement("div", {
						className: P.a.recurrenceRules,
						title: s
					}, s), r.a.createElement("div", null, R._("Scheduled by {=[post owner]}", [R._param("=[post owner]", r.a.createElement("span", {
						className: P.a.parametricMetaData
					}, R._("{post owner}", [R._param("post owner", d)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					}))), r.a.createElement("button", {
						onClick: n
					}, r.a.createElement(w.a, {
						className: P.a.pencilIcon
					}))), r.a.createElement(y, {
						scheduledPost: t
					}, r.a.createElement(j, {
						scheduledPost: t,
						onUpdateMetadata: this.props.onUpdateMetadata,
						onOpenOverflow: this.props.onOpenOverflow
					})))
				}
			}
			t.b = M(L)
		},
		"./src/reddit/components/RecurringPostList/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				placeholderIcon: "_2rWvDY38-Fa_14y347Il6W",
				thumbnailContainer: "_3cYCw7NYRAJwj6LvL8esBu"
			}
		},
		"./src/reddit/components/RecurringPostList/index.m.less": function(e, t, n) {
			e.exports = {
				titleContainer: "p9wLLlADU1pVQu4nx3HCF",
				postList: "_1qL48rnJIqcVj5nNuXkDSw",
				pageButtonPortal: "_3lBUQT-Vexm0jXk3WmIYJq",
				recurringPostsContainer: "_2UggIw0Xee7HvpOtrWrepd",
				lastRecurringPostItem: "dx2RjIkNec1E2-a1DyP07",
				emptyContainer: "_1Aurc-hBrd1zsfrQxHeZoq",
				icon: "_1BRYUIpfNcLUEr5L8DeJ8i",
				schedulePostLink: "_1mxUgytAdxfLqJuzRgGifT"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less": function(e, t, n) {
			e.exports = {
				DisplayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				displayContainer: "_3B7pbtNVM5jh1ozdZuJTfI",
				DropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				dropdownLabel: "_3MKcNYjenRkpopz-m6f8hM",
				ReasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				reasonTitle: "_1Ecdul4Q_dxU9eOJXmoQuK",
				Dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				dropdown: "_3z_HE15Esmqgf6bBaj3Epi",
				DropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				dropdownTriangle: "_2BZTmZOOcbQzMo7VdN3KB-",
				DropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				dropdownRow: "_3AVzUedTbFNFyaVtzLzahr",
				DropdownContainer: "_33sg6HoBYll4rCDqRzRUdu",
				dropdownContainer: "_33sg6HoBYll4rCDqRzRUdu"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/Dropdown/index.tsx"),
				d = n("./src/reddit/controls/Dropdown/Row.tsx"),
				c = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				u = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.m.less"),
				m = n.n(u);
			const p = i.a.wrapped(l.a, "DisplayContainer", m.a),
				b = i.a.div("DropdownLabel", m.a),
				f = i.a.div("ReasonTitle", m.a),
				h = e => o.a.createElement(p, null, o.a.createElement(b, null, e.dropdownLabel), e.selectedReason && o.a.createElement(f, null, e.selectedReason)),
				_ = i.a.wrapped(a.a, "Dropdown", m.a),
				g = i.a.wrapped(c.b, "DropdownTriangle", m.a),
				v = i.a.wrapped(d.b, "DropdownRow", m.a),
				x = i.a.div("DropdownContainer", m.a);
			t.a = e => o.a.createElement(x, {
				onClick: e.onToggleDropdown,
				"data-testid": "removal-reasons-dropdown"
			}, o.a.createElement(h, {
				dropdownLabel: e.isLoading ? s.fbt._("Loading...", null, {
					hk: "1bT6op"
				}) : s.fbt._("Reason for removal", null, {
					hk: "3C9ecg"
				}),
				selectedReason: e.selectedReason ? e.selectedReason.title : null
			}), o.a.createElement(g, null), e.isDropdownOpen && o.a.createElement(_, {
				isOverlay: !0
			}, o.a.createElement(v, {
				displayText: s.fbt._("None", null, {
					hk: "2443EZ"
				}),
				onClick: () => e.onSelectReason(null)
			}), e.subredditRemovalReasons.map((t, n) => o.a.createElement(v, {
				displayText: `${n+1}. ${t.title}`,
				key: t.title,
				onClick: () => e.onSelectReason(t)
			}))))
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less": function(e, t, n) {
			e.exports = {
				CharacterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				characterCountdown: "_3QAHANdA13oJnYRmkNk6sb",
				EmptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				emptyState: "_1Wu9eKXKrc5e52itaXM9ny",
				ModNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				modNoteDescription: "_2yxydSiZfhd3wo7e1VeMg3",
				PrimaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				primaryButton: "_3ECRi_xQqKANiwqaFL6bmr",
				RadioOption: "_30JuaHooKBU-I9UQwxEwhL",
				radioOption: "_30JuaHooKBU-I9UQwxEwhL",
				BoldText: "_22_ggqyuhsjDD3F2auyNjc",
				boldText: "_22_ggqyuhsjDD3F2auyNjc",
				ModNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				modNoteInput: "_1hTAtA-9TFnHvYJWXuSFsv",
				MessageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				messageInput: "_1PK5NQ4vO_RKB4KvIDUONs",
				Info: "_3Bf1PCbZnJJBM391IWRv8D",
				info: "_3Bf1PCbZnJJBM391IWRv8D",
				SmallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				smallInfoText: "ozxLnphBA3LqIKZJwfCoD",
				FormOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				formOptionsContainer: "_3fRFatQ34rHHRS3sO1Pacm",
				ModalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				modalFooter: "_3dFILDoNznUDwdP1jfpTz-",
				FooterRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				footerRow: "_1vxr-V4SeBtsrkFSGJB0O8",
				ButtonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				buttonRow: "_3zZmX0EjloIkzwt2-sRI2_",
				toggleLabel: "_3J1Bs_5dR0qoQB1_kO03HR",
				toggleLabelText: "jGFen5TvAvfaFKwfUboOg",
				toggle: "_1W9ZWSmEnnxTPwKV-PJWCP"
			}
		},
		"./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "dispatcher", (function() {
				return R
			})), n.d(t, "selector", (function() {
				return A
			})), n.d(t, "connector", (function() {
				return M
			})), n.d(t, "CharacterCountdown", (function() {
				return L
			})), n.d(t, "EmptyState", (function() {
				return D
			})), n.d(t, "MessageInput", (function() {
				return H
			})), n.d(t, "FormOptionsContainer", (function() {
				return z
			})), n.d(t, "ModalFooter", (function() {
				return K
			})), n.d(t, "ButtonRow", (function() {
				return Y
			})), n.d(t, "AddRemovalReasonModal", (function() {
				return J
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/higherOrderComponents/asModal/index.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/removalReasons/index.ts"),
				l = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				u = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				m = n("./src/reddit/components/TrackingHelper/index.tsx"),
				p = n("./src/reddit/controls/Button/index.tsx"),
				b = n("./src/reddit/controls/Checkbox/index.tsx"),
				f = n("./src/reddit/controls/InternalLink/index.tsx"),
				h = n("./src/reddit/controls/RadioInput/index.tsx"),
				_ = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				g = n("./src/reddit/controls/TextButton/index.tsx"),
				v = n("./src/reddit/icons/fonts/Info/index.tsx"),
				x = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				O = n("./src/reddit/models/RemovalReason/index.ts"),
				E = n("./src/reddit/selectors/removalReasons.ts"),
				y = n("./src/reddit/selectors/subreddit.ts"),
				C = n("./src/reddit/selectors/telemetry.ts"),
				j = n("./src/reddit/selectors/user.ts"),
				k = n("./src/reddit/selectors/experiments/cnc/index.ts"),
				I = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/RemovalReasonsDropdown.tsx"),
				S = n("./src/reddit/components/RemovalReasons/AddRemovalReasonModal/_AddRemovalReasonModal.m.less"),
				w = n.n(S);
			const {
				fbt: T
			} = n("./node_modules/fbt/lib/FbtPublic.js"), N = e => {
				switch (e) {
					case O.f.Private:
						return "private_subreddit";
					case O.f.PrivateExposed:
						return "private_personal";
					default:
						return e
				}
			}, P = {
				isDropdownOpen: !1,
				message: "",
				modNote: "",
				removalType: O.f.Public,
				selectedReason: null
			}, R = e => ({
				submitBulkRemovalReason: (t, n, s, r, o) => e(Object(c.submitBulkRemovalReason)(t, n, s, r, o)),
				submitRemovalReason: (t, n, s, r, o, i) => e(Object(c.submitRemovalReason)(t, n, s, r, o, i))
			}), A = Object(i.c)({
				currentUserName: e => {
					const t = Object(j.l)(e);
					if (t) return t.displayText
				},
				isLoading: E.a,
				removalReasons: E.c,
				isRemovalReasonLockCommentEnabled: k.e,
				subredditName: (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object(y.Y)(e, {
						subredditId: n
					}).name
				}
			}), M = Object(o.b)(A, R), L = d.a.wrapped(l.a, "CharacterCountdown", w.a), D = d.a.div("EmptyState", w.a), F = d.a.wrapped(u.o, "ModNoteDescription", w.a), U = d.a.wrapped(p.l, "PrimaryButton", w.a), B = d.a.wrapped(_.a, "RadioOption", w.a), q = d.a.span("BoldText", w.a), G = d.a.wrapped(u.t, "ModNoteInput", w.a), H = d.a.wrapped(u.t, "MessageInput", w.a), W = d.a.wrapped(v.a, "Info", w.a), V = d.a.div("SmallInfoText", w.a), z = d.a.div("FormOptionsContainer", w.a), K = d.a.wrapped(u.g, "ModalFooter", w.a), Q = d.a.div("FooterRow", w.a), Y = d.a.wrapped(Q, "ButtonRow", w.a);
			class J extends r.a.Component {
				constructor(e) {
					super(e), this.trackClick = e => t => {
						const n = 1 === this.props.itemIds.length ? this.props.itemIds[0] : void 0;
						this.props.sendEvent(s => ({
							source: "removal_reasons",
							action: "click",
							noun: e,
							comment: n && Object(C.h)({
								state: s,
								commentId: n
							}) || null,
							post: n && Object(C.K)(s, n) || null,
							screen: Object(C.cb)(s),
							subreddit: Object(C.lb)(s, this.props.subredditId),
							...t || {}
						}))
					}, this.onSelectRemovalType = e => {
						this.setState({
							removalType: e
						}), this.trackClick(`type_${N(e)}`)()
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onUpdateModNote = e => {
						this.setState({
							modNote: e.currentTarget.value
						})
					}, this.handleToggleDropdown = () => this.setState({
						isDropdownOpen: !this.state.isDropdownOpen
					}), this.closeDropdown = () => {
						this.state.isDropdownOpen && this.setState({
							isDropdownOpen: !1
						})
					}, this.onSelectReason = e => {
						this.setState({
							selectedReason: e
						}), this.trackClick("reason")(), e && this.setState({
							message: e.message
						}), this.closeDropdown()
					}, this.canSave = () => !(this.state.message.length > O.a || this.state.modNote.length > O.b) && (this.state.selectedReason ? this.state.message.trim().length > 0 : this.state.modNote.trim().length > 0), this.onSubmit = () => {
						const {
							props: e,
							state: t
						} = this;
						if (this.canSave()) {
							(t.removalContextType === O.e.Bulk ? e.submitBulkRemovalReason : e.submitRemovalReason)(e.itemIds, t.selectedReason, t.message.trim(), t.removalType, t.modNote.trim(), [O.f.Public, O.f.PublicAsSubreddit].includes(t.removalType) && t.removalContextType !== O.e.Bulk && this.props.isRemovalReasonLockCommentEnabled ? t.isLocked : void 0);
							const n = this.props.isRemovalReasonLockCommentEnabled ? {
								modAction: {
									removalreason: {
										notify: [O.f.Public, O.f.PublicAsSubreddit].includes(t.removalType) ? "comment" : "modmail",
										send_as: [O.f.Private, O.f.PublicAsSubreddit].includes(t.removalType) ? "subreddit" : "self",
										is_locked: t.isLocked
									}
								}
							} : void 0;
							this.trackClick("sent")(n), t.selectedReason && this.trackClick(`sent_${N(t.removalType)}`)(n), t.modNote && this.trackClick("sent_modnote")(), e.toggleModal()
						}
					}, this.toggleIsLocked = () => {
						this.setState({
							isLocked: !this.state.isLocked
						})
					}, this.onCancel = () => {
						this.props.toggleModal(), this.trackClick("cancel")()
					}, this.renderRemovalTypeOptions = () => {
						const {
							props: e,
							state: t
						} = this, n = [];
						return t.removalContextType !== O.e.Bulk && (n.push(r.a.createElement(B, {
							key: O.f.PublicAsSubreddit,
							showButton: !0,
							tabIndex: 0,
							value: O.f.PublicAsSubreddit
						}, r.a.createElement("div", null, t.removalContextType === O.e.Post ? T._("Public: Write a sticky comment on the post as Mod Team", null, {
							hk: "er8wA"
						}) : T._("Public: Write a reply to the comment as Mod Team", null, {
							hk: "1WMyjM"
						})))), n.push(r.a.createElement(B, {
							key: O.f.Public,
							showButton: !0,
							tabIndex: 0,
							value: O.f.Public
						}, r.a.createElement("div", null, t.removalContextType === O.e.Post ? T._("Public: Write a sticky comment on the post as {currentUserName}", [T._param("currentUserName", r.a.createElement(q, null, `u/${e.currentUserName}`))], {
							hk: "2jsvEB"
						}) : T._("Public: Write a reply to the comment as {currentUserName}", [T._param("currentUserName", r.a.createElement(q, null, `u/${e.currentUserName}`))], {
							hk: "LZfBm"
						}))))), n.push(r.a.createElement(B, {
							key: O.f.Private,
							showButton: !0,
							tabIndex: 0,
							value: O.f.Private
						}, r.a.createElement("div", null, T._("Private: send a Modmail from {subredditName} to the user", [T._param("subredditName", r.a.createElement(q, null, `r/${e.subredditName}`))], {
							hk: "1wUxMe"
						})))), e.currentUserName && n.push(r.a.createElement(B, {
							key: O.f.PrivateExposed,
							showButton: !0,
							tabIndex: 0,
							value: O.f.PrivateExposed
						}, r.a.createElement("div", null, T._("Private: send a Modmail from {currentUserName} to the user", [T._param("currentUserName", r.a.createElement(q, null, `u/${e.currentUserName}`))], {
							hk: "wFSJr"
						})))), n
					}, this.state = {
						...P,
						removalType: O.f.PublicAsSubreddit,
						removalContextType: Object(O.g)(e.itemIds),
						isLocked: !0
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return r.a.createElement(u.e, {
						onClick: this.closeDropdown
					}, e.isLoading || e.removalReasons.length > 0 && r.a.createElement(u.i, null, r.a.createElement(x.a, null, r.a.createElement(u.q, null, T._("Add a removal reason", null, {
						hk: "4odEgX"
					}), e.itemIds.length > 1 && T._("({number of items} posts/comments)", [T._param("number of items", e.itemIds.length)], {
						hk: "4u7ZzL"
					})), r.a.createElement(g.a, {
						onClick: this.onCancel
					}, r.a.createElement(u.b, null)))), r.a.createElement(u.l, {
						"data-testid": "add-removal-reason-modal"
					}, e.isLoading || e.removalReasons.length > 0 ? r.a.createElement(I.a, {
						isDropdownOpen: t.isDropdownOpen,
						isLoading: e.isLoading,
						onSelectReason: this.onSelectReason,
						onToggleDropdown: this.handleToggleDropdown,
						selectedReason: t.selectedReason,
						subredditRemovalReasons: e.removalReasons
					}) : r.a.createElement(D, null, T._("You don't have any removal reasons yet", null, {
						hk: "2cPgPy"
					}), r.a.createElement(f.default, {
						to: `/r/${e.subredditName}/about/removal`,
						target: "_blank"
					}, r.a.createElement(p.r, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, T._("Add a removal reason", null, {
						hk: "3MHM7e"
					})))), t.selectedReason && r.a.createElement(z, null, r.a.createElement(u.h, null, r.a.createElement(h.a, {
						name: "REMOVAL_REASON_INPUT",
						onChange: this.onSelectRemovalType,
						value: t.removalType
					}, this.renderRemovalTypeOptions())), r.a.createElement(H, {
						value: t.message,
						onChange: this.onMessageInputChange
					}), r.a.createElement(L, {
						maxChars: O.a,
						text: t.message.trim()
					}), r.a.createElement(V, null, t.removalType !== O.f.Public && t.removalType !== O.f.PublicAsSubreddit && r.a.createElement(r.a.Fragment, null, r.a.createElement(W, null), T._("A link to the removed content will be appended to your message", null, {
						hk: "1DbEGF"
					}))), (t.removalType === O.f.Public || t.removalType === O.f.PublicAsSubreddit) && this.props.isRemovalReasonLockCommentEnabled && t.removalContextType !== O.e.Bulk && r.a.createElement("label", {
						className: w.a.toggleLabel
					}, r.a.createElement(b.a, {
						className: w.a.toggle,
						isCheckboxSelected: !!t.isLocked,
						toggleCheckbox: this.toggleIsLocked
					}), r.a.createElement("span", {
						className: w.a.toggleLabelText
					}, T._("Lock removal reason comment thread", null, {
						hk: "1p3zeG"
					}))))), r.a.createElement(K, null, r.a.createElement(Q, null, r.a.createElement(F, null, T._("Mod note (Only mods will see this note)", null, {
						hk: "3InAsy"
					}))), r.a.createElement(Q, null, r.a.createElement(G, {
						placeholder: T._("This is a short note to your mod team on why the content was removed.", null, {
							hk: "4goqsC"
						}),
						value: t.modNote,
						onChange: this.onUpdateModNote
					})), r.a.createElement(Q, null, r.a.createElement(L, {
						maxChars: O.b,
						text: t.modNote.trim()
					})), r.a.createElement(Y, null, r.a.createElement(p.o, {
						onClick: this.onCancel,
						"data-redditstyle": !0
					}, T._("Cancel", null, {
						hk: "2TSLl5"
					})), r.a.createElement(U, {
						onClick: this.onSubmit,
						disabled: !this.canSave(),
						"data-redditstyle": !0
					}, T._("Submit", null, {
						hk: "4aU3dh"
					})))))
				}
			}
			t.default = Object(a.a)(M(Object(m.c)(J)))
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less": function(e, t, n) {
			e.exports = {
				GenericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				genericGreetingText: "_1RYmGXZkbjV_9GAwCiqmLp",
				DeleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				deleteReasonButton: "_3LU38GqHnVONELmzr-6CjS",
				PrimaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				primaryButton: "_1Qw31YEY4D8vZqqnidfBid",
				TextArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				textArea: "_2g19cC2dTjD8Ivp0iaxvPI",
				ModalFooter: "a8KANZ6wvta1y_8QSZmeS",
				modalFooter: "a8KANZ6wvta1y_8QSZmeS",
				Input: "tWupUgopHVvjD9_bZZVy0",
				input: "tWupUgopHVvjD9_bZZVy0"
			}
		},
		"./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less": function(e, t, n) {
			e.exports = {
				EditButton: "_3Z3niHttcaJCxThBE2-eNN",
				editButton: "_3Z3niHttcaJCxThBE2-eNN",
				Row: "_1ERpdeakuaRdyW5OEGvV_a",
				row: "_1ERpdeakuaRdyW5OEGvV_a",
				ReasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				reasonNumber: "_37ciCG1flXTYWdLXzWUVSP",
				ReasonText: "_3Vv7n3XK-P5uslyAy7Li0w",
				reasonText: "_3Vv7n3XK-P5uslyAy7Li0w"
			}
		},
		"./src/reddit/components/RemovalReasons/index.m.less": function(e, t, n) {
			e.exports = {
				Rules: "-z_XjylM-4VxXIVlUJupm",
				rules: "-z_XjylM-4VxXIVlUJupm",
				title: "_1wclVdwRTNycOnlbH1IkQU",
				subtext: "_2IxjljuOnx5CrtK0CMzstT",
				removalReasonsCount: "_1B3ouNDntikHo-PDWo9Gwk",
				tooltipContent: "_2KMnTQyMVHRHQBFfwLKxrJ",
				tooltip: "_3YCzepP6_mhRVOdUDnmkEo"
			}
		},
		"./src/reddit/components/RemovalReasons/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/reddit/constants/colors.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/removalReasons/index.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/ContentTooltip/index.tsx"),
				f = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				h = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				_ = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				g = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				v = n("./src/reddit/controls/Button/index.tsx"),
				x = n("./src/reddit/helpers/localStorage/index.ts"),
				O = n("./src/reddit/icons/fonts/index.tsx"),
				E = n("./src/reddit/models/RemovalReason/index.ts"),
				y = n("./src/reddit/selectors/activeModalId.ts"),
				C = n("./src/reddit/selectors/removalReasons.ts"),
				j = n("./src/higherOrderComponents/asModal/index.tsx"),
				k = n("./src/lib/lessComponent.tsx"),
				I = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				S = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				w = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				T = n("./src/reddit/controls/TextButton/index.tsx"),
				N = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				P = n("./src/reddit/components/RemovalReasons/RemovalReasonEditorModal.m.less"),
				R = n.n(P);
			const A = {
					message: "",
					title: ""
				},
				M = k.a.wrapped(S.f, "GenericGreetingText", R.a),
				L = k.a.wrapped(S.s, "DeleteReasonButton", R.a),
				D = k.a.wrapped(v.l, "PrimaryButton", R.a),
				F = k.a.wrapped(S.t, "TextArea", R.a),
				U = k.a.wrapped(S.g, "ModalFooter", R.a),
				B = k.a.wrapped(w.c, "Input", R.a);
			class q extends i.a.Component {
				constructor(e) {
					super(e), this.onTitleInputChange = e => {
						e.currentTarget.value.length <= E.d && this.setState({
							title: e.currentTarget.value
						})
					}, this.onMessageInputChange = e => {
						this.setState({
							message: e.currentTarget.value
						})
					}, this.onSave = () => {
						const e = {
							title: this.state.title.trim(),
							message: this.state.message.trim()
						};
						this.props.removalReason && (e.id = this.props.removalReason.id), this.props.onSubmit(e), this.props.sendEvent(), this.props.toggleModal()
					}, this.canSave = () => this.state.title.trim().length > 0 && this.state.title.trim().length <= E.d && this.state.message.trim().length > 0 && this.state.message.trim().length <= E.a, this.state = e.removalReason ? {
						title: e.removalReason.title,
						message: e.removalReason.message
					} : A
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(S.e, null, i.a.createElement(S.i, null, i.a.createElement(N.a, null, i.a.createElement(S.q, null, e.removalReason ? r.fbt._("Edit removal reason", null, {
						hk: "1P0jAw"
					}) : r.fbt._("Add new reason", null, {
						hk: "jDYo"
					})), i.a.createElement(T.a, {
						onClick: e.toggleModal
					}, i.a.createElement(S.b, null)))), i.a.createElement(S.l, null, i.a.createElement(S.h, null, i.a.createElement(B, {
						placeholder: r.fbt._("Removal reason title", null, {
							hk: "4hFurd"
						}),
						value: t.title,
						onChange: this.onTitleInputChange
					}), i.a.createElement(I.a, {
						text: t.title.trim(),
						maxChars: E.d
					})), i.a.createElement(S.o, null, r.fbt._("Reason message:", null, {
						hk: "yMtrM"
					})), i.a.createElement(M, null, r.fbt._("Hi u/username,", null, {
						hk: "NE4XP"
					})), i.a.createElement(F, {
						placeholder: r.fbt._("Write a message that will communicate to the user why their post was removed.", null, {
							hk: "4u5AVO"
						}),
						value: t.message,
						onChange: this.onMessageInputChange,
						"data-redditstyle": !0
					}), i.a.createElement(I.a, {
						text: t.message.trim(),
						maxChars: E.a
					})), i.a.createElement(U, null, i.a.createElement(D, {
						onClick: this.onSave,
						"data-redditstyle": !0,
						disabled: !this.canSave()
					}, e.removalReason ? r.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : r.fbt._("Add new reason", null, {
						hk: "34P0ii"
					})), i.a.createElement(S.a, {
						onClick: e.toggleModal,
						"data-redditstyle": !0
					}, r.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.removalReason && i.a.createElement(L, {
						onClick: e.onDeleteReason
					}, r.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var G = Object(j.a)(q),
				H = n("./src/reddit/layout/row/Inline/index.tsx"),
				W = n("./src/reddit/components/RemovalReasons/RemovalReasonItem.m.less"),
				V = n.n(W);
			const {
				fbt: z
			} = n("./node_modules/fbt/lib/FbtPublic.js"), K = k.a.wrapped(v.r, "EditButton", V.a), Q = k.a.wrapped(H.a, "Row", V.a), Y = k.a.div("ReasonNumber", V.a), J = k.a.div("ReasonText", V.a);
			var X = e => i.a.createElement(Q, null, i.a.createElement(Y, null, e.index + 1), i.a.createElement(J, null, e.removalReason.title), i.a.createElement(K, {
					onClick: e.onEdit,
					"data-redditstyle": !0
				}, z._("Edit", null, {
					hk: "1nftDt"
				}))),
				Z = n("./src/reddit/components/RemovalReasons/index.m.less"),
				$ = n.n(Z);
			const ee = "RemovalReasons--Tooltip",
				te = 1e4,
				ne = {
					reasonToEdit: null
				},
				se = Object(d.c)({
					isConfirmModalOpen: e => "RemovalReasons--Modal--DeleteConfirmation" === Object(y.a)(e),
					isRemovalReasonEditorModalOpen: e => "RemovalReasons--Editor--Modal" === Object(y.a)(e),
					removalReasons: C.c
				}),
				re = Object(a.b)(se, (e, t) => {
					let {
						subredditId: n
					} = t;
					return {
						addRemovalReason: t => e(Object(u.addRemovalReason)(n, t)),
						deleteRemovalReason: t => e(Object(u.deleteRemovalReason)(n, t)),
						editRemovalReason: t => e(Object(u.editRemovalReason)(n, t)),
						toggleConfirmationModal: () => e(Object(l.i)("RemovalReasons--Modal--DeleteConfirmation")),
						toggleReasonEditorModal: () => e(Object(l.i)("RemovalReasons--Editor--Modal")),
						onShowTooltip: t => e(Object(m.f)({
							tooltipId: t
						})),
						onHideTooltip: () => e(Object(m.i)())
					}
				});
			class oe extends i.a.Component {
				constructor(e) {
					super(e), this.onShowTooltip = () => {
						Object(x.v)() || (this.props.onShowTooltip(ee), setTimeout(() => {
							this.props.onHideTooltip()
						}, te), Object(x.Yb)())
					}, this.onAddReason = () => {
						this.setState({
							reasonToEdit: null
						}), this.props.toggleReasonEditorModal(), this.props.sendEventWithName("add_new")()
					}, this.onEditReason = e => () => {
						this.setState({
							reasonToEdit: e
						}), this.props.toggleReasonEditorModal(), e && this.props.sendEventWithName("edit")()
					}, this.onClickTooltip = () => {
						this.props.onHideTooltip()
					}, this.renderReasonEditorModal = () => i.a.createElement(G, {
						onDeleteReason: () => {
							this.props.toggleReasonEditorModal(), this.props.toggleConfirmationModal()
						},
						onSubmit: this.state.reasonToEdit ? this.props.editRemovalReason : this.props.addRemovalReason,
						removalReason: this.state.reasonToEdit,
						sendEvent: this.state.reasonToEdit ? this.props.sendEventWithName("edit_save") : this.props.sendEventWithName("new_save"),
						subredditId: this.props.subredditId,
						toggleModal: this.onEditReason(null),
						withOverlay: !0
					}), this.state = ne
				}
				componentDidMount() {
					this.onShowTooltip()
				}
				render() {
					const {
						deleteRemovalReason: e,
						isConfirmModalOpen: t,
						isRemovalReasonEditorModalOpen: n,
						removalReasons: o,
						sendEventWithName: a,
						toggleConfirmationModal: d
					} = this.props;
					return i.a.createElement(i.a.Fragment, null, i.a.createElement(_.c, null, i.a.createElement(v.l, {
						onClick: this.onAddReason,
						disabled: o.length >= E.c || n,
						"data-redditstyle": !0
					}, r.fbt._("Add removal reason", null, {
						hk: "2fHPVe"
					}))), i.a.createElement(_.a, null, i.a.createElement(_.b, {
						className: $.a.title
					}, r.fbt._("Removal reasons", null, {
						hk: "3IWxkH"
					}), i.a.createElement(h.a, {
						linkUrl: `${s.a.redditModHelpUrl}/hc/en-us/articles/360010094892`
					}), i.a.createElement(g.n, {
						className: $.a.subtext
					}, r.fbt._("Help people become better posters by giving a short reason why their post was removed.", null, {
						hk: "2X1Ma2"
					}), i.a.createElement("span", {
						className: $.a.removalReasonsCount,
						id: ee,
						onClick: this.onClickTooltip
					}, i.a.createElement(b.a, {
						className: $.a.tooltip,
						defaultTooltipPosition: "left",
						tooltipId: ee,
						caretColor: {
							right: c.a.alienblue
						}
					}, i.a.createElement("div", {
						className: $.a.tooltipContent
					}, r.fbt._("NEW! Add up to 50 removal reasons.", null, {
						hk: "1LM0MR"
					}))), o.length, "/", E.c))), o.length > 0 ? o.map((e, t) => i.a.createElement(X, {
						index: t,
						key: e.id,
						onEdit: this.onEditReason(e),
						removalReason: e
					})) : i.a.createElement(f.c, {
						text: r.fbt._("No removal reasons yet", null, {
							hk: "1j70G1"
						})
					}, i.a.createElement(O.a, {
						name: "rules",
						className: $.a.Rules
					}))), n && this.renderReasonEditorModal(), t && this.state.reasonToEdit && i.a.createElement(p.a, {
						actionText: r.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: r.fbt._("Delete reason", null, {
							hk: "q2qun"
						}),
						modalText: r.fbt._("Are you sure you want to delete this reason?", null, {
							hk: "1FTfMR"
						}),
						onConfirm: () => {
							this.state.reasonToEdit && e(this.state.reasonToEdit.id)
						},
						toggleModal: () => {
							d(), this.setState({
								reasonToEdit: null
							})
						},
						trackClick: a("delete"),
						withOverlay: !0
					}))
				}
			}
			t.a = re(oe)
		},
		"./src/reddit/components/ReportFlow/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
				backgroundColor: r.a.overlayReportFlow
			};
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "ReportFlow",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlow.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ReportFlow/_ReportFlow.tsx"
				}
			})
		},
		"./src/reddit/components/ReportFlow/new.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/reddit/constants/colors.ts");
			const o = {
					backgroundColor: r.a.overlayReportFlow
				},
				i = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlow",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("CommentsPage~Governance~Reddit~ReportFlow~Subreddit~reddit-components-BlankPost~reddit-components-Cl~5351df81"), n.e("Governance~ModListing~Reddit~ReportFlow~Subreddit"), n.e("ReportFlow")]).then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNewModal.tsx"
					}
				}),
				a = Object(s.a)({
					resolved: {},
					chunkName: () => "ReportFlowNew",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("ReportFlowNew").then(n.bind(null, "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/ReportFlow/_ReportFlowNew.tsx"
					}
				});
			t.b = a
		},
		"./src/reddit/components/ResizeSensor/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/raf/index.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o);
			class a extends i.a.Component {
				constructor(e) {
					super(e), this.isIE = () => /Trident/.test(navigator.userAgent), this.setContainerRef = e => {
						this.containerRef || (this.containerRef = e, this.createSensor())
					}, this.handleResize = () => {
						void 0 !== this.frame && r.a.cancel(this.frame), this.frame = r()(this.props.onResize)
					}, this.containerRef = e.containerRef
				}
				shouldComponentUpdate() {
					return !1
				}
				componentDidMount() {
					this.createSensor()
				}
				createSensor() {
					if (!this.containerRef || this.sensor) return;
					this.sensor = document.createElement("object"), this.sensor.setAttribute("style", "\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 100%;\n      width: 100%;\n      overflow: hidden;\n      pointer-events: none;\n      z-index: -1;\n    "), this.sensor.setAttribute("tabindex", "-1"), this.sensor.onload = () => {
						this.props.onResize(), this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.addEventListener("resize", this.handleResize)
					}, this.sensor.type = "text/html";
					const e = this.isIE();
					e && this.containerRef.appendChild(this.sensor), this.sensor.data = "about:blank", e || this.containerRef.appendChild(this.sensor), this.props.onResize()
				}
				componentWillUnmount() {
					this.sensor && (this.sensor && this.sensor.contentDocument && this.sensor.contentDocument.defaultView && this.sensor.contentDocument.defaultView.removeEventListener("resize", this.handleResize), this.containerRef && this.containerRef.removeChild(this.sensor))
				}
				render() {
					return i.a.createElement("div", {
						ref: this.setContainerRef
					})
				}
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.m.less": function(e, t, n) {
			e.exports = {
				removalReasonButton: "_3IEDcFIIs_TeXsZtKZGzUd",
				TextWrapper: "smOzqVIOoNqmSJcyBX2N6",
				textWrapper: "smOzqVIOoNqmSJcyBX2N6",
				Button: "_1rNBkuuOkN2SorEXyRkYjB",
				button: "_1rNBkuuOkN2SorEXyRkYjB",
				ApproveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				approveButton: "_2T9IigN7CfZvuc5KSKs2hx",
				RemoveButton: "_2OvUr_pd3kddsNP_f35S28",
				removeButton: "_2OvUr_pd3kddsNP_f35S28"
			}
		},
		"./src/reddit/components/RestrictedFlatlistButton/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RestrictedFlatlistButton/index.m.less"),
				d = n.n(a);
			const c = e => r.a.createElement("button", {
					className: Object(o.a)(d.a.Button, e.className),
					disabled: e.disabled,
					id: e.id,
					onClick: e.disabled ? void 0 : e.onClick,
					onMouseEnter: e.onMouseEnter,
					onMouseLeave: e.onMouseLeave
				}, e.children, e.text && r.a.createElement("span", {
					className: Object(o.a)(d.a.TextWrapper, e.textClassName)
				}, e.text, " ")),
				l = i.a.wrapped(c, "ApproveButton", d.a),
				u = i.a.wrapped(c, "RemoveButton", d.a),
				m = e => r.a.createElement("button", {
					className: Object(o.a)(d.a.removalReasonButton, e.className),
					onClick: e.onClick
				}, e.text)
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less": function(e, t, n) {
			e.exports = {
				tooltip: "ki2VbfBhU-qxg1S6VyET6",
				above: "_8fNGSBGvr1Ds8PbrsUGzN",
				below: "_38gWvHp3NJkR5r5ftUfbFG",
				HoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2",
				hoverTooltip: "Nb7NCPTlQuxN_WDPUg5Q2"
			}
		},
		"./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = i.a.wrapped(e => {
				const {
					children: t,
					className: n,
					renderBelow: s,
					text: i,
					tooltipContentClass: a,
					...l
				} = e;
				return r.a.createElement("div", c({}, l, {
					className: Object(o.a)(d.a.container, n)
				}), i ? r.a.createElement("div", {
					className: Object(o.a)(d.a.tooltip, a, s ? d.a.below : d.a.above)
				}, i) : null, t)
			}, "HoverTooltip", d.a)
		},
		"./src/reddit/components/RichTextEditor/emotes/EmoteButton.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s, r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				d = n("./src/reddit/components/RichTextEditor/emotes/emoteButton.m.less"),
				c = n.n(d);
			! function(e) {
				e[e.Inside = 0] = "Inside", e[e.Outside = 1] = "Outside"
			}(s || (s = {}));
			const l = 750,
				u = e => {
					let {
						className: t,
						containerClassName: n,
						imageClassName: d,
						disabled: u,
						id: m,
						imagePath: p,
						onClick: b,
						onKeyDown: f,
						title: h,
						onClickDelete: _,
						mouseEnterBufferTime: g = l
					} = e;
					const v = Object(r.useRef)(s.Outside),
						[x, O] = Object(r.useState)(!1);
					return o.a.createElement("div", {
						className: Object(i.a)(c.a.container, n),
						onMouseEnter: _ ? () => {
							v.current = s.Inside, setTimeout(() => {
								v.current === s.Inside && O(!0)
							}, g)
						} : void 0,
						onMouseLeave: _ ? () => {
							v.current = s.Outside, O(!1)
						} : void 0
					}, x && o.a.createElement("button", {
						className: c.a.deleteButton,
						onClick: _
					}, o.a.createElement(a.b, {
						className: c.a.deleteIcon
					})), o.a.createElement("button", {
						className: Object(i.a)(c.a.emoteButton, t),
						disabled: u,
						id: m,
						title: h,
						onClick: b,
						onKeyDown: f,
						tabIndex: 1
					}, o.a.createElement("div", {
						className: Object(i.a)(c.a.emoteImage, d),
						style: {
							backgroundImage: `url(${p})`
						}
					})))
				}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/DeleteEmojiModal.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				i = n("./src/reddit/components/RichTextEditor/emotes/Powerups/emotesSection.m.less"),
				a = n.n(i);
			const {
				fbt: d
			} = n("./node_modules/fbt/lib/FbtPublic.js"), c = e => {
				let {
					emojiUrl: t,
					onConfirm: n,
					onCancel: s,
					onClose: i
				} = e;
				return r.a.createElement(o.a, {
					onConfirm: n,
					onCancel: s,
					onClose: i,
					headerText: d._("Delete emoji", null, {
						hk: "27GEDb"
					}),
					modalText: r.a.createElement("p", {
						className: a.a.deleteModalContainer
					}, r.a.createElement("img", {
						className: a.a.deleteModalImage,
						src: t
					}), d._("Are you sure you want to delete this emoji?", null, {
						hk: "1bmNdu"
					})),
					actionText: d._("Delete", null, {
						hk: "4lt26q"
					}),
					cancelActionText: d._("Go back", null, {
						hk: "3zzMov"
					}),
					withOverlay: !0
				})
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/emotesSection.m.less": function(e, t, n) {
			e.exports = {
				addButton: "_131SsHx6UfUQsBbPHh8m1D",
				addButtonDisabled: "eRYyo8WYr0Hti7IAGe_gO",
				addIcon: "R3xFUrQvsMx3gn2gqGv0w",
				uploadInput: "_183AY4WVSatH9Qe_MAXDE-",
				loadingContainer: "_2xoHnDYYs7peY_5Im4vQDn",
				emoteButton: "_2s68zj-4Pb6nTX2IUDzLkz",
				placeholderEmoteButton: "_1xLXujnXEDJIfZl94qCnb6",
				customEmoteImage: "_3yyGg_Mez5tP41OCc9Nne8",
				emotePackTitle: "_2ukOHQG9KkBde1ztDLudOP",
				newIcon: "_3_QvdlHkxRkqBb9ZNRQZXx",
				emotePackSubtitle: "_1-OnXZrmw20X79pBvJWaEy",
				emotes: "DNWbRyf3z71g0nqfrzQ4T",
				freeEmotePack: "_13ylKQWUAkdhTJRIuHyJfq",
				disabled: "Ejq92_2ovDkhH3FjoerXW",
				deleteModalContainer: "_2JcZhkY3vXBVFEAMyuM8D5",
				deleteModalImage: "_1V2bCmzxzskT1fA3fY70lK"
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/Powerups/useEmojiUpload.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/actions/economics/powerups/index.ts");
			const i = (e, t, n, i, a, d) => {
				const c = Object(r.d)(),
					l = Object(s.useRef)(null),
					[u, m] = Object(s.useState)(0),
					p = async function(t) {
						let n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
							s = arguments.length > 2 ? arguments[2] : void 0;
						try {
							return await c(Object(o.b)({
								subredditId: e,
								file: t
							})), s(), {
								success: !0
							}
						} catch (r) {
							return n ? p(t, !1, s) : (s(), {
								success: !1,
								error: r.message
							})
						}
					}, b = () => m(e => e - 1);
				return {
					maxEmojisUploaded: t.length >= 20,
					maxEmojisUploading: t.length + u >= 20,
					onFileChange: async e => {
						const s = e.currentTarget.files;
						if (!(null == s ? void 0 : s.length)) return;
						if (s.length + t.length > 20) {
							const e = 20 - t.length;
							return null == n || n(e), void(l.current && (l.current.value = ""))
						}
						m(s.length), null == i || i(s.length);
						const r = await Promise.all([...s].map(e => p(e, !0, b))),
							o = r.reduce((e, t) => e + (t.success ? 1 : 0), 0);
						o > 0 && (null == a || a(o));
						const c = r.length - o;
						c > 0 && (null == d || d(c)), l.current && (l.current.value = ""), m(0)
					},
					numUploading: u,
					onClickUpload: () => {
						var e;
						null === (e = l.current) || void 0 === e || e.click()
					},
					uploadInput: l
				}
			}
		},
		"./src/reddit/components/RichTextEditor/emotes/emoteButton.m.less": function(e, t, n) {
			e.exports = {
				container: "_1xDkiINVQUjf0tjZcbF3a7",
				emoteButton: "_2-SqXmcI6RcjKEbTfkrLVe",
				emoteImage: "_1WpEszyqkHofX36kiLrJ8x",
				deleteButton: "_2mgKNuqCKnjSfh2dBW7iqI",
				deleteIcon: "_1BJNzscR61JS-t7pR4p3Ik"
			}
		},
		"./src/reddit/components/SEOTitle/constants.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e[e.Collection = 0] = "Collection", e[e.HeaderSelector = 1] = "HeaderSelector", e[e.PostComments = 2] = "PostComments", e[e.PostItem = 3] = "PostItem", e[e.TopicHeader = 4] = "TopicHeader", e[e.Widget = 5] = "Widget"
				}(s || (s = {})),
				function(e) {
					e[e.H1 = 1] = "H1", e[e.H2 = 2] = "H2", e[e.H3 = 3] = "H3", e[e.H4 = 4] = "H4", e[e.H5 = 5] = "H5", e[e.H6 = 6] = "H6"
				}(r || (r = {}))
		},
		"./src/reddit/components/SEOTitle/index.m.less": function(e, t, n) {
			e.exports = {
				Title: "_eYtD2XCVieq6emjKBH3m",
				title: "_eYtD2XCVieq6emjKBH3m"
			}
		},
		"./src/reddit/components/SEOTitle/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a.a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/components/SEOTitle/constants.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/reddit/helpers/postCollection.ts");
			const l = [d.Sb.COMMENTS, d.Sb.COLLECTION_COMMENTS],
				u = (e, t) => {
					if (!e) return [];
					const n = l.includes(e),
						s = e === d.Sb.COLLECTION_COMMENTS || t && Object(c.a)(t),
						r = d.ab.has(e),
						o = d.Hb.has(e),
						i = e === d.Sb.SUBREDDIT,
						u = e === d.Sb.TOPIC;
					let m, p, b;
					return r && !i || o ? m = a.a.HeaderSelector : s ? m = a.a.Collection : n ? m = a.a.PostComments : u && (m = a.a.TopicHeader), (r || o || s || n) && (p = a.a.Widget), (r || n) && (b = a.a.PostItem), [m, p, b]
				};
			var m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/selectors/platform.ts"),
				b = n("./src/reddit/components/SEOTitle/index.m.less"),
				f = n.n(b);
			const h = e => {
					let {
						level: t,
						children: n
					} = e;
					const s = `h${t}`;
					return r.a.createElement(s, {
						className: f.a.Title
					}, n)
				},
				_ = Object(m.v)(),
				g = Object(o.b)(() => Object(i.a)((e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && Object(p.o)(e, {
						page: n
					})
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return n && n.meta && n.meta.name
				}, (e, t) => {
					let {
						type: n
					} = t;
					return n
				}, (e, t, n) => ({
					level: u(t, e).indexOf(n) + 1 || void 0
				})));
			class v extends r.a.Component {
				render() {
					const {
						children: e,
						level: t
					} = this.props;
					return t ? r.a.createElement(h, {
						level: t
					}, e) : r.a.createElement(r.a.Fragment, null, e)
				}
			}
			t.b = _(g(v))
		},
		"./src/reddit/components/SaveIndicator/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_13ubiSSjUBWaeyJM-itH7X",
				titleFontH2: "_2V4_0G0gJO4R1v-_sO5D_j",
				titleFontH3: "_32Uo9qgINsZX5CSOtFM0e2",
				titleFontH4: "_2AWEwOuuK5wBnQGyiB5sSq",
				titleFontH5: "_8460KZXLwbKYkuLfDNr_-",
				titleFontH6: "_7GhKEQrcNu3JuSHqj9pJc",
				metadataFont: "qilOmvvpr4iY8iiHxuV5Y",
				flairFont: "SovT7HaLHcqz1BM9MWXPA",
				labelsFont: "_3Ngpaj84VwPqy3s6Tr3GEJ",
				actionFont: "_3RLwRjy5tGM8nl4kID8Tfg",
				smallButtonFont: "nb_OfRzzHKNkGteZC-TyY",
				largeButtonFont: "_2fhzAdDCEdDseFevwE6mBQ",
				strongTextFont: "_2vvi6WI_4yX2H2H-b2aBCF",
				tabFont: "_3E-egg7Cy7bL6JzsZuFTcn",
				buttonFontXS: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontXs: "_2ubuuRpTK-U-kDLRRU6pyd",
				buttonFontS: "_2fsKOual6xDsvmfB9Z_Gab",
				buttonFontM: "_3pHwBKAuUlalHSG7AJTpEP",
				buttonFontL: "fC3WZNZt7dm3kVDpkLV2",
				buttonFontXL: "_1A7d3cQhRmAUn05diOyF_D",
				buttonFontXl: "_1A7d3cQhRmAUn05diOyF_D",
				bodyFontH1: "_2_nWm6krUlDJnEF9pk7xNK",
				bodyFontH2: "_3zzd4vTmfrG1aK91i6m2j9",
				bodyFontH3: "_3tFwmsoGmyp52EFCoZ0GCV",
				bodyFontH4: "MdKdTVjxUaPPkDvG_msXr",
				bodyFontH5: "_2dNFOZceckCrwGYG8Avi-k",
				bodyFontH6: "_3sSb6LvOgvwy7eawwX4Gtq",
				bodyFontH6Small: "_1W_jjzqvHEQ70RO1EVPhFD",
				bodyFont: "_2fiuzofxgtB6yu9nAHLuqW",
				bodyFontSmall: "_2IcqO4djjAVsOalbW_Zpa9",
				bodyFontMono: "_2i_EmKzaFJfCskmkHdmmgJ",
				landingPageTitleFontH1: "_38v-SivLqoC13YgJLnTKY2",
				landingPageTitleFontH2: "_1hrSZ3nT5LOSDpPFUW2brX",
				landingPageTitleFontH3: "_3GRarSBJEUqY4ZXoU7J7Zj",
				icon: "cO908rcinWKz894i8I5jJ",
				pendingIcon: "U2dgL2i9_EJN8R_MLFTjS",
				savedIcon: "_1iGcF7LdvT-OMRgF7xKWqm",
				saveErrorIcon: "kWS-87C-v-iTlGGxQOmxu",
				caption: "_1MAESVWNqu44JbWmHGJsuI"
			}
		},
		"./src/reddit/components/ScheduledPost/ControlRow/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1xM2tjm8c7LuqnoEJG1Ws1",
				controlRow: "P7KCCrRfT4TO2wcnk_Kjv",
				controlRowItem: "_1AkGbjxtRpq3ZhKADdUTU3"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				content: "_297_pyPlxmqBF0tLkUhTME",
				icon: "_1n_ojuNDT8JeH9DxmHJZt9",
				author: "_1k9D_vEsQ8odWCNERbDOxX",
				modIcon: "_3ryKOTfQ_vqgap0EZsZHAl",
				stickyIcon: "qfjbZcX6-FZK2BGrOXezD"
			}
		},
		"./src/reddit/components/ScheduledPost/MetaLine/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/components/AuthorLink/index.tsx"),
				a = n("./src/reddit/components/SubredditNameLink/index.tsx"),
				d = n("./src/reddit/controls/MetaSeparator/index.tsx"),
				c = n("./src/reddit/icons/fonts/Sticky/index.tsx"),
				l = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				u = n("./src/reddit/models/ScheduledPost/index.ts"),
				m = n("./src/reddit/components/ScheduledPost/MetaLine/index.m.less"),
				p = n.n(m);
			class b extends r.a.PureComponent {
				render() {
					if (!Object(u.p)(this.props.subreddit)) return null;
					const {
						isModDistinguished: e,
						isPostAsMetaMod: t,
						subreddit: n,
						owner: s,
						isSticky: m
					} = this.props, b = t ? o.m : Object(u.o)(s) ? s.name : void 0;
					return r.a.createElement("span", {
						className: p.a.content
					}, r.a.createElement(a.a, {
						to: n.path
					}, n.prefixedName), b && r.a.createElement(r.a.Fragment, null, r.a.createElement(d.a, null), r.a.createElement(i.a, {
						className: p.a.author,
						author: b,
						isUnstyled: !0
					}, `u/${b}`)), e && r.a.createElement(l.a, {
						className: p.a.modIcon
					}), m && r.a.createElement(c.a, {
						className: p.a.stickyIcon
					}))
				}
			}
			t.a = b
		},
		"./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/reddit/components/OverflowMenu/index.tsx"),
				c = n("./src/reddit/controls/CheckboxMenuItem/index.tsx");
			var l = e => r.a.createElement(d.b, {
					dropdownId: `SCHEDULED_POST_DROPDOWN${e.scheduledPostId}`,
					onClick: e.onOpenOverflow
				}, r.a.createElement(c.a, {
					isSelected: e.isSticky,
					onClick: e.onToggleIsSticky,
					text: a.fbt._("Sticky post", null, {
						hk: "UOShB"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isModDistinguished,
					onClick: e.onToggleIsModDistinguished,
					text: a.fbt._("Distinguish as Mod", null, {
						hk: "3opu7K"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isOriginalContent,
					onClick: e.onToggleIsOC,
					text: a.fbt._("Mark as OC", null, {
						hk: "32LGcQ"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isNsfw,
					onClick: e.onToggleIsNsfw,
					text: a.fbt._("Mark as NSFW", null, {
						hk: "2qBIcp"
					})
				}), r.a.createElement(c.a, {
					isSelected: e.isSpoiler,
					onClick: e.onToggleIsSpoiler,
					text: a.fbt._("Mark as Spoiler", null, {
						hk: "rOev9"
					})
				})),
				u = n("./src/reddit/selectors/scheduledPosts/index.ts");
			const m = Object(i.c)({
					isLoading: u.j
				}),
				p = Object(o.b)(m);

			function b(e) {
				class t extends r.a.Component {
					constructor(e) {
						super(e), this.isSaving = !1, this.onToggleMetadata = e => {
							this.setState({
								...this.state,
								[e]: !this.state[e]
							}), this.isSaving = !0, this.props.onUpdateMetadata(e)
						}, this.onToggleIsSticky = () => this.onToggleMetadata("isSticky"), this.onToggleIsModDistinguished = () => this.onToggleMetadata("isModDistinguished"), this.onToggleIsOriginalContent = () => this.onToggleMetadata("isOriginalContent"), this.onToggleIsNsfw = () => this.onToggleMetadata("isNsfw"), this.onToggleIsSpoiler = () => this.onToggleMetadata("isSpoiler"), this.renderOverflowMenu = () => r.a.createElement(l, {
							scheduledPostId: this.props.scheduledPost.id,
							onOpenOverflow: this.props.onOpenOverflow,
							onToggleIsSticky: this.onToggleIsSticky,
							onToggleIsModDistinguished: this.onToggleIsModDistinguished,
							onToggleIsOC: this.onToggleIsOriginalContent,
							onToggleIsNsfw: this.onToggleIsNsfw,
							onToggleIsSpoiler: this.onToggleIsSpoiler,
							isModDistinguished: this.state.isModDistinguished,
							isOriginalContent: this.state.isOriginalContent,
							isNsfw: this.state.isNsfw,
							isSticky: this.state.isSticky,
							isSpoiler: this.state.isSpoiler
						}), this.state = {
							isModDistinguished: e.scheduledPost.isModDistinguished,
							isNsfw: e.scheduledPost.isNsfw,
							isOriginalContent: e.scheduledPost.isOriginalContent,
							isSpoiler: e.scheduledPost.isSpoiler,
							isSticky: !!e.scheduledPost.sticky && "NONE" !== e.scheduledPost.sticky
						}
					}
					componentDidUpdate(e) {
						e.isLoading && !this.props.isLoading && this.isSaving && (this.isSaving = !1, this.setState({
							isModDistinguished: this.props.scheduledPost.isModDistinguished || !1,
							isNsfw: this.props.scheduledPost.isNsfw || !1,
							isOriginalContent: this.props.scheduledPost.isOriginalContent || !1,
							isSpoiler: this.props.scheduledPost.isSpoiler || !1,
							isSticky: !!this.props.scheduledPost.sticky && "NONE" !== this.props.scheduledPost.sticky
						}))
					}
					render() {
						const {
							isLoading: t,
							scheduledPost: n,
							onUpdateMetadata: s,
							onOpenOverflow: o,
							...i
						} = this.props, a = {
							...i,
							renderOverflowMenu: this.renderOverflowMenu
						};
						return r.a.createElement(e, a)
					}
				}
				return t.displayName = `WithOverflowMenu(${e.displayName||e.name})`, p(t)
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.m.less": function(e, t, n) {
			e.exports = {
				title: "_3jA9JBnv4bqmmiAw3Akmug"
			}
		},
		"./src/reddit/components/ScheduledPost/PostTitle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ScheduledPost/PostTitle/index.m.less"),
				i = n.n(o);
			class a extends r.a.PureComponent {
				render() {
					return r.a.createElement("span", {
						className: i.a.title
					}, this.props.title)
				}
			}
			t.a = a
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_1YrhJ0z1RfTXg7jHYgApSr",
				error: "_2_f_ecVpbx4yoMzazJYkDP",
				retryButton: "_1KbjdUJVdbZQOJN8d6LTsX",
				parametricMetaData: "_2x3oXUTdLAKAob3BYLRkmH"
			}
		},
		"./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less": function(e, t, n) {
			e.exports = {
				container: "qDE3oDok1392-t8IDOBfk",
				clock: "_2sfIhl6E6vfZCwxx54EUNB",
				parametricMetaData: "_3bAfM2inJTjD3ZXNzO5nE5"
			}
		},
		"./src/reddit/components/ScheduledPost/index.m.less": function(e, t, n) {
			e.exports = {
				body: "_320l2eVngsr4Ord9dXc2er",
				container: "_26zeT5d9JKXWbWzOT4ncpg",
				thumbnailContainer: "_2UwJRJuqEbkRCV8O6REq8h",
				mainBody: "_3pHV3zwe-Q9-xNEB0iM3WT",
				backgroundWrapper: "_2KWv8ukh9RMgpOturAiV9z",
				content: "hAQclO6xLNG3WDMgkywGo",
				flairList: "_1-tY_25z_pkhbFvUz2-AqS",
				Icon: "_3XIOnqmz8vxSaPmPEY11Wh",
				icon: "_3XIOnqmz8vxSaPmPEY11Wh"
			}
		},
		"./src/reddit/components/ScheduledPost/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return ue
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/telemetry/index.ts"),
				l = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				u = n("./src/reddit/actions/scheduledPosts/index.ts"),
				m = n("./src/reddit/actions/scheduledPosts/delete.ts"),
				p = n("./src/reddit/actions/scheduledPosts/edit.ts"),
				b = n("./src/lib/makeActionCreator/index.ts"),
				f = n("./src/reddit/actions/scheduledPosts/constants.ts"),
				h = n("./src/reddit/actions/toaster.ts"),
				_ = n("./src/reddit/actions/urlRequested.ts"),
				g = n("./src/lib/makeGqlRequest/index.ts"),
				v = n("./src/redditGQL/operations/SubmitScheduledPost.json");
			var x = n("./src/reddit/models/Toast/index.ts");
			const O = Object(b.a)(f.l),
				E = (e, t) => async (n, s, r) => {
					let {
						gqlContext: o
					} = r;
					const i = Object(a.p)(s(), {
						subredditId: e,
						scheduledPostId: t
					});
					if (!i) return void n(Object(h.f)(Object(h.e)(f.u(), x.b.Error)));
					const d = await ((e, t) => Object(g.a)(e, {
						...v,
						variables: t
					}))(o(), {
						input: {
							id: i.id
						}
					});
					if (!d.ok) return void n(Object(h.f)(Object(h.e)(f.v(), x.b.Error, f.s(), E(e, t))));
					const c = d.body.data.submitScheduledPost.post.permalink;
					n(Object(_.a)(c, !1)), n(Object(h.f)(Object(h.e)(f.x(), x.b.SuccessCommunity))), n(O({
						subredditId: e,
						scheduledPostId: t
					}))
				};
			var y = n("./src/reddit/components/ClassicPost/Thumbnail.tsx"),
				C = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				j = n("./src/reddit/components/FlairList/index.tsx"),
				k = n("./src/reddit/components/PostLeftRail/index.tsx"),
				I = n("./src/reddit/components/VerticalVotes/DisabledVerticalVotes.tsx"),
				S = n("./src/reddit/constants/thumbnails.ts"),
				w = n("./src/reddit/helpers/styles/mixins/index.tsx"),
				T = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				N = n("./src/reddit/models/PostCreationForm/index.ts"),
				P = n("./src/reddit/models/ScheduledPost/index.ts"),
				R = n("./src/reddit/components/ScheduledPost/OverflowMenu/withOverflowMenu.tsx"),
				A = n("./src/lib/classNames/index.ts"),
				M = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				L = n("./src/reddit/icons/svgs/Post/index.tsx"),
				D = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				F = n("./src/reddit/components/ScheduledPost/ControlRow/index.m.less"),
				U = n.n(F);
			const B = e => {
				const {
					icon: t,
					onClick: n
				} = e;
				return o.a.createElement("span", {
					onClick: n,
					className: Object(A.a)(U.a.controlRowItem, e.className)
				}, o.a.createElement(t, {
					className: U.a.icon
				}), " ", e.text)
			};
			class q extends o.a.Component {
				render() {
					return o.a.createElement("span", {
						className: U.a.controlRow
					}, this.props.onSubmitPostNow && o.a.createElement(B, {
						icon: L.a,
						text: s.fbt._("Submit post now", null, {
							hk: "QkS4y"
						}),
						onClick: this.props.onSubmitPostNow
					}), o.a.createElement(B, {
						icon: M.a,
						text: s.fbt._("Edit", null, {
							hk: "1nftDt"
						}),
						onClick: this.props.onEditScheduledPost
					}), o.a.createElement(B, {
						icon: D.b,
						text: s.fbt._("Delete", null, {
							hk: "1uVY7w"
						}),
						onClick: this.props.onDeleteScheduledPost
					}), this.props.renderOverflowMenu())
				}
			}
			var G = Object(R.a)(q),
				H = n("./src/reddit/components/ScheduledPost/MetaLine/index.tsx"),
				W = n("./src/reddit/components/ScheduledPost/PostTitle/index.tsx"),
				V = n("./src/reddit/icons/svgs/ClearFilled/index.tsx"),
				z = n("./src/reddit/components/ScheduledPost/TopMetaLine/FailureMetaLine/index.m.less"),
				K = n.n(z);
			const {
				fbt: Q
			} = n("./node_modules/fbt/lib/FbtPublic.js");
			class Y extends o.a.PureComponent {
				componentDidMount() {
					this.props.onViewFailedPost()
				}
				render() {
					const {
						scheduledPost: e
					} = this.props, {
						owner: t
					} = e, n = Object(P.o)(t) && t.prefixedName;
					return o.a.createElement("div", {
						className: K.a.container
					}, o.a.createElement("div", null, o.a.createElement(V.a, {
						className: K.a.error
					}), Q._("Post failed to submit! Please {=retry}", [Q._param("=retry", o.a.createElement("button", {
						className: K.a.retryButton,
						onClick: this.props.onSubmitPostNow
					}, Q._("retry", null, {
						hk: "hER94"
					})))], {
						hk: "4yOnl8"
					})), o.a.createElement("div", null, Q._("Scheduled by {=[post owner]}", [Q._param("=[post owner]", o.a.createElement("span", {
						className: K.a.parametricMetaData
					}, Q._("{post owner}", [Q._param("post owner", n)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					})))
				}
			}
			var J = Object(i.b)(null, (e, t) => {
					let {
						scheduledPost: n
					} = t;
					return {
						onSubmitPostNow: () => {
							e(E(n.subreddit.id, n.id)), e((e, t) => Object(c.a)(Object(T.n)()(t())))
						},
						onViewFailedPost: () => e((e, t) => Object(c.a)(Object(T.w)()(t(), n)))
					}
				})(Y),
				X = n("./src/reddit/helpers/scheduledPosts/index.ts"),
				Z = n("./src/reddit/icons/svgs/Clock/index.tsx"),
				$ = n("./src/reddit/components/ScheduledPost/TopMetaLine/TemporalMetaLine/index.m.less"),
				ee = n.n($);
			const {
				fbt: te
			} = n("./node_modules/fbt/lib/FbtPublic.js"), ne = e => {
				return `${Object(X.c)(e.publishAt)} ${Object(X.d)(e.clientTimezone).displayText}`
			};
			class se extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props, {
						owner: t
					} = e, n = Object(P.o)(t) && t.prefixedName;
					return o.a.createElement("div", {
						className: ee.a.container
					}, o.a.createElement(Z.a, {
						className: ee.a.clock
					}), o.a.createElement("div", null, o.a.createElement("div", null, te._("This post is scheduled for {=[time]}", [te._param("=[time]", o.a.createElement("span", {
						className: ee.a.parametricMetaData
					}, te._("{time}", [te._param("time", ne(e))], {
						hk: "JrMs3"
					})))], {
						hk: "4gFrnr"
					})), o.a.createElement("div", null, te._("Scheduled by {=[post owner]}", [te._param("=[post owner]", o.a.createElement("span", {
						className: ee.a.parametricMetaData
					}, te._("{post owner}", [te._param("post owner", n)], {
						hk: "25fi1G"
					})))], {
						hk: "36vTyl"
					}))))
				}
			}
			var re = se;
			class oe extends o.a.PureComponent {
				render() {
					const {
						scheduledPost: e
					} = this.props;
					switch (e.state) {
						case P.f.FAILED:
							return o.a.createElement(J, {
								scheduledPost: e
							});
						case P.f.PROCESSING:
						case P.f.CREATED:
						default:
							return o.a.createElement(re, {
								scheduledPost: e
							})
					}
				}
			}
			var ie = oe,
				ae = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				de = n.n(ae),
				ce = n("./src/reddit/components/ScheduledPost/index.m.less"),
				le = n.n(ce);
			const ue = {
					isNSFW: !1,
					media: {
						content: "",
						markdownContent: "",
						isRichtextPreview: !0,
						mediaMetadata: null,
						obfuscated: null,
						richtextContent: {
							document: []
						},
						rteMode: N.i.RICH_TEXT,
						type: "rtjson"
					},
					thumbnail: {
						url: S.a.DEFAULT,
						width: null,
						height: null
					},
					title: "",
					source: null,
					isSponsored: !1
				},
				me = Object(d.c)({
					media: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						if (!r) return null;
						const o = {
								...ue
							},
							i = r.postKind === P.e.LINK;
						return i && (o.media = null), {
							...o,
							isNSFW: r.isNsfw,
							title: r.title,
							...i && {
								source: r.url
							},
							pollData: r.poll
						}
					},
					flair: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						const r = Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						});
						return r ? Object(a.m)({
							scheduledPost: r
						}) : null
					},
					scheduledPost: (e, t) => {
						let {
							scheduledPostId: n,
							subredditId: s
						} = t;
						return Object(a.p)(e, {
							subredditId: s,
							scheduledPostId: n
						})
					}
				}),
				pe = Object(i.b)(me, (e, t) => {
					let {
						scheduledPostId: n,
						subredditId: s
					} = t;
					return {
						onSubmitPostNow: () => {
							e(E(s, n)), e((e, t) => Object(c.a)(Object(T.n)()(t())))
						},
						onEditScheduledPost: () => {
							e(Object(p.b)(s, n)), e((e, t) => Object(c.a)(Object(T.d)()(t())))
						},
						onDeleteScheduledPost: () => e(Object(m.a)(s, n)),
						onOpenOverflow: () => {
							e((e, t) => Object(c.a)(Object(T.h)(!1)(t())))
						},
						onUpdateMetadata: t => e((e, r) => {
							const o = Object(a.p)(r(), {
								subredditId: s,
								scheduledPostId: n
							});
							o && e(Object(u.b)(t, o))
						})
					}
				});
			class be extends o.a.PureComponent {
				constructor(e) {
					super(e), this.onSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !0
					}), this.onCancelSubmitPostNow = () => this.setState({
						submitConfirmModalIsOpen: !1
					}), this.onConfirmSubmitPostNow = () => this.props.onSubmitPostNow(), this.onEditScheduledPost = () => {
						this.props.onEditScheduledPost()
					}, this.onDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !0
					}), this.onCancelDeleteScheduledPost = () => this.setState({
						deleteConfirmModalIsOpen: !1
					}), this.onConfirmDeleteScheduledPost = () => this.props.onDeleteScheduledPost(), this.state = {
						deleteConfirmModalIsOpen: !1,
						submitConfirmModalIsOpen: !1
					}
				}
				render() {
					const {
						media: e,
						flair: t,
						scheduledPost: n
					} = this.props;
					return e && t && n ? o.a.createElement("div", {
						className: le.a.container
					}, o.a.createElement(ie, {
						scheduledPost: n
					}), o.a.createElement("div", {
						className: de.a.classicPostStyles
					}, o.a.createElement(k.b, null, o.a.createElement(I.a, null)), o.a.createElement("div", {
						style: Object(w.c)(void 0, this.props),
						className: le.a.backgroundWrapper
					}, o.a.createElement("div", {
						className: le.a.mainBody
					}, o.a.createElement("div", {
						className: le.a.thumbnailContainer
					}, o.a.createElement(y.a, {
						post: e
					})), o.a.createElement("div", {
						className: le.a.content
					}, o.a.createElement("div", null, o.a.createElement(W.a, {
						title: n.title
					}), o.a.createElement(j.a, {
						className: le.a.flairList,
						flair: t
					})), o.a.createElement(H.a, {
						isModDistinguished: n.isModDistinguished,
						isPostAsMetaMod: n.isPostAsMetaMod,
						isSticky: !!n.sticky && "NONE" !== n.sticky,
						subreddit: n.subreddit,
						owner: n.owner
					}), o.a.createElement(G, {
						onSubmitPostNow: n.state === P.f.FAILED ? void 0 : this.onSubmitPostNow,
						onEditScheduledPost: this.onEditScheduledPost,
						onDeleteScheduledPost: this.onDeleteScheduledPost,
						onUpdateMetadata: this.props.onUpdateMetadata,
						scheduledPost: n,
						onOpenOverflow: this.props.onOpenOverflow
					}))))), this.state.deleteConfirmModalIsOpen && o.a.createElement(C.a, {
						onClose: this.onCancelDeleteScheduledPost,
						onCancel: this.onCancelDeleteScheduledPost,
						onConfirm: this.onConfirmDeleteScheduledPost,
						actionText: s.fbt._("Delete", null, {
							hk: "1WN0R6"
						}),
						modalText: s.fbt._("Are you sure you want to delete this scheduled post? This action cannot be undone.", null, {
							hk: "1EdQC7"
						}),
						withOverlay: !0
					}), this.state.submitConfirmModalIsOpen && o.a.createElement(C.a, {
						onClose: this.onCancelSubmitPostNow,
						onCancel: this.onCancelSubmitPostNow,
						onConfirm: this.onConfirmSubmitPostNow,
						actionText: s.fbt._("Submit", null, {
							hk: "3kl12J"
						}),
						modalText: s.fbt._("Are you sure you want to submit this scheduled post now? This action cannot be undone.", null, {
							hk: "18O8dB"
						}),
						withOverlay: !0
					})) : null
				}
			}
			t.a = Object(l.a)(pe(be))
		},
		"./src/reddit/components/SearchResultsContent/searchResultsPageTreatment/searchIgnoreClickContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js");
			const r = Object(s.createContext)(!1);

			function o() {
				return Object(s.useContext)(r)
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.m.less": function(e, t, n) {
			e.exports = {
				Component: "BotIImuktRA9aFAPP0O4Z",
				component: "BotIImuktRA9aFAPP0O4Z"
			}
		},
		"./src/reddit/components/Settings/shared/SectionHeading.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/Settings/shared/SectionHeading.m.less"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx");
			t.a = o.a.h3("Component", r.a)
		},
		"./src/reddit/components/Settings/shared/Widgets.m.less": function(e, t, n) {
			e.exports = {
				Label: "asxizthf5kZpmoY27VBKd",
				label: "asxizthf5kZpmoY27VBKd",
				HoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				hoverTooltip: "_1qQQ7O7znXpzgcC5RgQFtW",
				ControlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				controlContainer: "_1kylDjSQ2hay_ez0zF7BEP",
				TextContainer: "_3dLmvT0hpACHFxhncqzCOr",
				textContainer: "_3dLmvT0hpACHFxhncqzCOr",
				inModal: "_2O2JPVgOlh8J6OW_9ur4BQ",
				ActionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				actionContainer: "_1oREjd5ToMFah-VfX5Zt1z",
				Wrapper: "_2f63as5b5FASHMqGd5P1o0",
				wrapper: "_2f63as5b5FASHMqGd5P1o0",
				isCreateCommunity: "_38bDTwLcytTCF-174R0UXB",
				mColumn: "_1HH_g-CLQB1BPcqOhZcakt",
				mLast: "_3Lu6XJyVbSLDVKDx-wue2g",
				mIndent: "_2D65jEbgD16ae_sJ8BG4AD",
				mDisabled: "LvI7FSBTGgYo2skaf18Zv",
				Subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				subtext: "_1NdK7EwgYqUxJObBr3ym4o",
				RangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				rangeSlider: "_2J8tywkkd4Gotm3jZ2Gcv0",
				isNightModeOn: "KUWYDFs7fIjkQNSOL_BR6",
				Wrapper__LineBreak: "wVinKyEoajEmwhqwINYGd",
				wrapperLineBreak: "wVinKyEoajEmwhqwINYGd",
				ActionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				actionHintText: "_2sMk-Gi9c8T3BKYlxSopql",
				Link: "oFObIzV6ZJDQuG09BXh8u",
				link: "oFObIzV6ZJDQuG09BXh8u",
				SubtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				subtextLink: "_3MGA27y-8plrsOsPbyYwgs",
				LinkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				linkIcon: "_3gg7WkHbAGiySOBOzb9k6F",
				LinkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				linkButton: "_3I7YVr4pIJiOGmmJdgsEXK",
				ArrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				arrowRight: "_1oH-o0mDV86imeLnyfmCiD",
				NoColor: "mI7WmWMma8pZnlYRHtE56",
				noColor: "mI7WmWMma8pZnlYRHtE56",
				StyledFlair: "_1F2irboi-xRChkhyndP6ct",
				styledFlair: "_1F2irboi-xRChkhyndP6ct",
				SpoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				spoilerFlair: "_3mkE4WZP2_bhfSQvrpeIka",
				NSFWFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				nsfwFlair: "_1mPvZAvMvenP80lJ1RnQdE",
				DropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				dropdownWrapper: "_1D4YEzJAywC1b-Jx_on2cZ",
				DropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				dropdownRow: "_1ekKroexYAQllqx2MfTHbi",
				Row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				row: "_1QNl7IkO4tmBTG1Cp8_ZBk",
				DropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				dropdownTriangle: "_2VFl8Aqe76Ulg9-x85FKpH",
				DescriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				descriptionsRow: "H3CGfLrRo4H9tQdWd5vG9",
				Circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				circle: "_20H2GFMG6B0Lai4Q3DhIE2",
				RangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				rangeSliderInput: "_2ieOPsoffMpHmDwvrKLRjg",
				Ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				ticks: "_3BLGt0e8kYgLHkUbAeXTWG",
				TickText: "_1hEYjTFCxEu2ILobPvatAp",
				tickText: "_1hEYjTFCxEu2ILobPvatAp",
				PreSubText: "_2_hv6QgJ151j9WmCyETVfC",
				preSubText: "_2_hv6QgJ151j9WmCyETVfC",
				MultiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				multiLineInputSettingsBottomRow: "hgvQ7UQa9_0jmXSzQjqhF",
				ActionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				actionLinkContainer: "e4RehzaESS5nfk-O6pYoK",
				input: "_14_SnmD6g3FrozcKjTpqoH",
				tag: "_1GQzFyg5xYq94euL74ZaeJ"
			}
		},
		"./src/reddit/components/Settings/shared/Widgets.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "n", (function() {
				return W
			})), n.d(t, "k", (function() {
				return Y
			})), n.d(t, "o", (function() {
				return X
			})), n.d(t, "f", (function() {
				return $
			})), n.d(t, "l", (function() {
				return te
			})), n.d(t, "m", (function() {
				return oe
			})), n.d(t, "p", (function() {
				return ie
			})), n.d(t, "j", (function() {
				return pe
			})), n.d(t, "b", (function() {
				return be
			})), n.d(t, "g", (function() {
				return fe
			})), n.d(t, "a", (function() {
				return he
			})), n.d(t, "d", (function() {
				return ge
			})), n.d(t, "i", (function() {
				return ve
			})), n.d(t, "c", (function() {
				return xe
			})), n.d(t, "e", (function() {
				return Oe
			})), n.d(t, "h", (function() {
				return Ee
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/react-uid/dist/es2015/hooks.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/reddit/actions/tooltip.ts"),
				l = n("./src/higherOrderComponents/asTooltip.tsx"),
				u = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				m = n("./src/reddit/components/RichTextEditor/HoverTooltip/index.tsx"),
				p = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				b = n("./src/reddit/controls/Dropdown/index.tsx"),
				f = n("./src/reddit/controls/Dropdown/Row.tsx"),
				h = n("./src/reddit/controls/FormFields/index.tsx"),
				_ = n("./src/lib/lessComponent.tsx"),
				g = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				v = n("./src/reddit/controls/Select/index.m.less"),
				x = n.n(v);

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const E = _.a.span("Wrapper", x.a),
				y = _.a.select("Inner", x.a),
				C = _.a.wrapped(g.b, "Caret", x.a);

			function j(e) {
				let {
					className: t,
					innerClassName: n,
					...s
				} = e;
				const o = s.disabled ? {
					"data-disabled": s.disabled
				} : {};
				return r.a.createElement(E, {
					className: t
				}, r.a.createElement(y, O({
					className: n
				}, s)), r.a.createElement(C, O({
					isSubreddit: !0
				}, o)))
			}
			var k = n("./src/reddit/controls/ToggleSwitch/index.tsx"),
				I = n("./src/reddit/controls/Typography/index.tsx"),
				S = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				w = n("./src/reddit/icons/svgs/Circle/index.tsx"),
				T = n("./src/reddit/icons/svgs/OutboundLink/index.tsx"),
				N = n("./node_modules/lodash/range.js"),
				P = n.n(N),
				R = n("./src/reddit/controls/Button/index.tsx"),
				A = n("./src/reddit/layout/row/Inline/index.tsx"),
				M = n("./src/reddit/models/Flair/index.ts"),
				L = n("./src/reddit/selectors/tooltip.ts"),
				D = n("./src/reddit/selectors/user.ts"),
				F = n("./src/reddit/components/Settings/shared/Widgets.m.less"),
				U = n.n(F);

			function B() {
				return (B = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const q = Object(l.a)(b.a),
				G = _.a.wrapped(w.a, "Circle", U.a),
				H = _.a.h3("Label", U.a),
				W = _.a.wrapped(I.c, "Subtext", U.a),
				V = _.a.wrapped(m.a, "HoverTooltip", U.a),
				z = _.a.div("ControlContainer", U.a),
				K = _.a.div("TextContainer", U.a),
				Q = _.a.div("ActionContainer", U.a),
				Y = e => {
					let {
						className: t,
						direction: n,
						isCreateCommunity: s,
						inModal: o,
						isNightModeOn: i,
						disabled: a,
						indent: c,
						last: l,
						...u
					} = e;
					return r.a.createElement("div", B({}, u, {
						className: Object(d.a)(U.a.Wrapper, t, {
							[U.a.mColumn]: "column" === n,
							[U.a.mDisabled]: !!a,
							[U.a.mIndent]: !!c,
							[U.a.mLast]: !!l,
							[U.a.isCreateCommunity]: !!s,
							[U.a.inModal]: !!o,
							[U.a.isNightModeOn]: !!i
						})
					}))
				},
				J = _.a.a("Link", U.a),
				X = _.a.wrapped(J, "SubtextLink", U.a),
				Z = _.a.wrapped(T.a, "LinkIcon", U.a),
				$ = _.a.button("LinkButton", U.a),
				ee = _.a.wrapped(S.a, "ArrowRight", U.a),
				te = e => r.a.createElement(Y, {
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					isCreateCommunity: e.isCreateCommunity,
					last: e.last
				}, r.a.createElement(K, {
					className: e.textContainerClassName
				}, r.a.createElement(H, null, e.label, e.isRequired && r.a.createElement(G, null)), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, e.children)),
				ne = _.a.div("StyledFlair", U.a),
				se = _.a.wrapped(ne, "SpoilerFlair", U.a),
				re = _.a.wrapped(ne, "NSFWFlair", U.a),
				oe = e => {
					switch (e.flair) {
						case M.f.Nsfw:
							return r.a.createElement(re, null, "NSFW");
						case M.f.Spoiler:
							return r.a.createElement(se, null, "SPOILER");
						default:
							return null
					}
				},
				ie = e => {
					const t = Object(i.a)();
					return r.a.createElement(Y, {
						className: e.className,
						disabled: e.disabled,
						indent: e.indent,
						last: e.last
					}, r.a.createElement(K, null, r.a.createElement(A.a, null, r.a.createElement("label", {
						htmlFor: t,
						className: e.labelClassname
					}, r.a.createElement(H, null, e.label))), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(z, null, e.tooltip && r.a.createElement(V, {
						tooltipContentClass: e.tooltipContentClassName,
						text: e.tooltip
					}), r.a.createElement(k.a, {
						id: t,
						on: e.on,
						forceOn: e.forceOn,
						onToggle: e.onClick,
						disabled: e.disabled
					}))))
				},
				ae = _.a.input("RangeSliderInput", U.a),
				de = _.a.div("RangeSlider", U.a),
				ce = _.a.div("Ticks", U.a),
				le = _.a.div("TickText", U.a),
				ue = _.a.span("PreSubText", U.a),
				me = Object(a.c)({
					isNightModeOn: D.eb
				}),
				pe = Object(o.b)(me)(e => r.a.createElement(Y, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled,
					inModal: e.inModal,
					isNightModeOn: e.isNightModeOn,
					direction: e.direction,
					className: e.className
				}, r.a.createElement(K, {
					style: {
						flex: 5
					}
				}, !e.inModal && r.a.createElement(A.a, null, r.a.createElement(H, {
					className: e.labelClassname
				}, e.label)), !e.hideSubtext && r.a.createElement(W, null, " ", r.a.createElement(ue, {
					style: {
						color: e.ticks[e.value].color
					}
				}, " ", e.ticks[e.value].text + ": ", " "), " ", e.subtext)), r.a.createElement(Q, {
					style: {
						flex: 3,
						margin: "20px 20px 0 0"
					}
				}, r.a.createElement(de, null, r.a.createElement(ae, {
					style: {
						background: "linear-gradient(to right, " + P()(1, e.max + 1).map((t, n) => t <= e.value ? `${e.ticks[e.value].color} ${(t-1)/e.max*100}%,\n                    ${e.ticks[e.value].color} ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : t !== e.max ? `#c5c5c5 ${(t-1)/e.max*100}%, #c5c5c5 ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100-1}%,\n                    #fff ${t/e.max*100}%` : `#c5c5c5 ${(t-1)/e.max*100}%`) + ", #C5C5C5 100%)"
					},
					className: "range-slider-input",
					type: "range",
					min: e.min,
					max: e.max,
					step: e.step,
					value: e.value,
					onChange: e.onChange,
					onInput: e.onChange,
					disabled: e.disabled
				}), r.a.createElement(ce, null, Object.keys(e.ticks).map((t, n) => r.a.createElement(le, {
					key: t,
					style: {
						color: t === e.value.toString() ? e.ticks[t].color : "#878A8C"
					}
				}, e.ticks[t].text))))))),
				be = e => r.a.createElement(Y, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(A.a, null, r.a.createElement(H, null, e.label)), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(z, null, r.a.createElement(R.o, {
					onClick: e.onClick
				}, e.actionText)))),
				fe = e => r.a.createElement(Y, {
					className: e.className,
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(J, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, e.label, r.a.createElement(Z, null)), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, r.a.createElement(J, {
					href: e.link,
					onClick: e.onClick,
					target: e.openInNewTab ? "_blank" : void 0
				}, r.a.createElement(ee, null)))),
				he = e => r.a.createElement(Y, {
					className: e.className,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(K, null, r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				}, e.label), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, !!e.hintText && r.a.createElement("div", {
					className: U.a.ActionHintText
				}, e.hintText), r.a.createElement($, {
					onClick: e.onClick,
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				}, r.a.createElement(ee, {
					className: Object(d.a)({
						[U.a.NoColor]: e.color && "none" === e.color
					})
				})))),
				_e = Object(a.c)({
					isOpen: (e, t) => Object(L.b)(t.id)(e)
				}),
				ge = Object(o.b)(_e, (e, t) => ({
					openDropdown: () => {
						e(Object(c.h)({
							tooltipId: t.id
						}))
					}
				}))(e => r.a.createElement(Y, {
					last: e.last,
					indent: e.indent,
					disabled: e.disabled
				}, r.a.createElement(K, null, r.a.createElement(H, null, e.label), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, (e => r.a.createElement("div", {
					className: U.a.DropdownWrapper,
					onClick: e.openDropdown
				}, r.a.createElement("span", {
					className: U.a.Row,
					id: `SettingDropdown--${e.id}`
				}, e.displayTitle || e.selected), r.a.createElement(g.b, {
					className: U.a.DropdownTriangle
				}), r.a.createElement(q, {
					container: void 0,
					isOpen: e.isOpen,
					renderContentsHidden: !0,
					isOverlay: !1,
					tooltipId: `SettingDropdown--${e.id}`
				}, e.items.map((t, n) => r.a.createElement(f.b, {
					className: U.a.DropdownRow,
					displayText: e.displayItems ? e.displayItems[n] : t,
					isSelected: e.selected === t,
					onClick: () => e.onClick(t),
					key: "row--" + n,
					item: t
				}))), e.descriptions && r.a.createElement("div", {
					className: U.a.DescriptionsRow
				}, e.descriptions[e.items.indexOf(e.selected)] || e.displayItems && e.descriptions[e.displayItems.indexOf(e.selected)])))(e)))),
				ve = e => {
					let {
						disabled: t,
						last: n,
						onClick: o,
						onChange: i,
						...a
					} = e;
					const d = Object(s.useCallback)(e => i(e.target.value), [i]),
						{
							items: c
						} = a;
					return r.a.createElement(Y, {
						disabled: t
					}, r.a.createElement(K, null, r.a.createElement("label", {
						htmlFor: a.id
					}, r.a.createElement(H, {
						className: a.labelClassname
					}, a.label)), r.a.createElement(W, null, a.subtext)), r.a.createElement("div", {
						className: U.a.Wrapper__LineBreak
					}), r.a.createElement(Y, {
						last: n,
						indent: !0,
						disabled: t
					}, r.a.createElement(j, {
						id: a.id,
						className: "redditStyle",
						disabled: t || a.inputDisabled,
						onChange: d,
						value: a.selected
					}, c.map(e => {
						let {
							value: t,
							displayName: n
						} = e;
						return r.a.createElement("option", {
							key: t,
							value: t
						}, n)
					}))))
				},
				xe = e => r.a.createElement(Y, {
					className: e.className,
					direction: e.direction,
					disabled: e.disabled,
					indent: e.indent,
					last: e.last
				}, r.a.createElement(K, null, r.a.createElement(H, null, e.label), r.a.createElement(W, null, e.subtext)), r.a.createElement(Q, null, e.children)),
				Oe = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, e.isCreateCommunity && r.a.createElement("span", {
					className: U.a.tag
				}, "r/"), r.a.createElement(h.a, {
					className: e.isCreateCommunity ? U.a.input : void 0,
					disabled: !!e.disabled,
					onChange: e.onChange,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					type: "text",
					value: e.value,
					onBlur: e.onBlur
				}), !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value
				})),
				Ee = e => r.a.createElement(te, {
					isCreateCommunity: e.isCreateCommunity,
					isRequired: e.isRequired,
					label: e.label,
					subtext: e.subtext,
					direction: "column",
					textContainerClassName: e.textContainerClassName
				}, r.a.createElement(p.i, {
					disabled: !1,
					onChange: e.onChange,
					onFocus: e.onFocus,
					placeholder: e.placeholder,
					maxLength: e.maxChars,
					rows: e.rows || 4,
					style: {
						marginBottom: e.isCreateCommunity ? "4px" : 0,
						resize: e.isCreateCommunity ? "vertical" : "both"
					},
					value: e.value,
					onBlur: e.onBlur
				}), r.a.createElement("div", {
					className: U.a.MultiLineInputSettingsBottomRow
				}, !e.hideCountdown && r.a.createElement(u.a, {
					maxChars: e.maxChars,
					text: e.value || ""
				}), !!e.actionLink && r.a.createElement("div", {
					className: U.a.ActionLinkContainer
				}, e.actionLink)))
		},
		"./src/reddit/components/ShareMenu/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "PWY92ySDjTYrTAiutq4ty",
				dropdownRow: "_2snJGyyGyyH38duHobOUKE",
				linkIcon: "_1GObrri0j7y_9IWiGUfPjp",
				chatIcon: "_1PhtucoKocd-ADJ-JDEoiC",
				crosspostIcon: "_1m76BHzDzRsM1te7HBxUqd",
				embedIcon: "_3MSdPVJwGxrpakz-e1MQhO",
				modalBody: "T4VmKX-IOkP4UG-B4jUR-"
			}
		},
		"./src/reddit/components/ShareMenu/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				d = n("./src/config.ts"),
				c = n("./src/lib/addQueryParams/index.ts"),
				l = n("./src/reddit/actions/chat/toggle.ts"),
				u = n("./src/reddit/actions/modal.ts"),
				m = n("./src/reddit/actions/post.ts"),
				p = n("./src/reddit/actions/publicAccessNetwork/streams.ts"),
				b = n("./src/reddit/actions/tooltip.ts"),
				f = n("./src/reddit/components/OverlayAwareTooltip/index.tsx"),
				h = n("./src/reddit/components/PublicAccessNetwork/Modals/VideoShare/Loader.tsx"),
				_ = n("./src/reddit/constants/parameters.ts"),
				g = n("./src/reddit/controls/Dropdown/index.tsx"),
				v = n("./src/reddit/controls/Dropdown/Row.tsx"),
				x = n("./src/reddit/helpers/publicAccessNetwork/index.ts"),
				O = n("./src/reddit/helpers/trackers/shareToChat.ts"),
				E = n("./src/reddit/hooks/useTracking.ts"),
				y = n("./src/reddit/icons/fonts/index.tsx"),
				C = n("./src/reddit/models/Post/index.ts"),
				j = n("./src/reddit/models/Subreddit/index.ts"),
				k = n("./src/reddit/routes/postCreation/constants.ts"),
				I = n("./src/reddit/selectors/activeModalId.ts"),
				S = n("./src/reddit/selectors/tooltip.ts"),
				w = n("./src/reddit/components/ShareMenu/index.m.less"),
				T = n.n(w);
			const N = Object(f.a)(g.a),
				P = Object(a.a)(),
				R = e => {
					let {
						permalink: t,
						onShare: n
					} = e;
					return o.a.createElement(v.b, {
						id: "shareToChat",
						className: T.a.dropdownRow,
						displayText: s.fbt._("share to chat", null, {
							hk: "3EuIWT"
						}),
						onClick: () => {
							const e = Object(c.a)(t, {
								utm_source: "share",
								utm_medium: "web2x",
								context: 3
							});
							n(e)
						}
					}, o.a.createElement(y.a, {
						name: "chat",
						className: T.a.chatIcon
					}))
				},
				A = e => {
					let {
						permalink: t,
						sendEventWithName: n
					} = e;
					return o.a.createElement(v.b, {
						className: T.a.dropdownRow,
						displayText: s.fbt._("Embed", null, {
							hk: "2CcsuC"
						}),
						onClick: () => {
							n("share_embed"), window.open(`${d.a.rebedMediaUrl}/embed?url=${t}`, "RedditEmbed", "height=500,width=650,modal=yes,alwaysRaised=yes")
						}
					}, o.a.createElement(y.a, {
						name: "embed",
						className: T.a.embedIcon
					}))
				},
				M = e => {
					let {
						onCrosspost: t
					} = e;
					return o.a.createElement(v.b, {
						className: T.a.dropdownRow,
						displayText: s.fbt._("crosspost", null, {
							hk: "23zSN6"
						}),
						onClick: t
					}, o.a.createElement(y.a, {
						name: "crosspost",
						className: T.a.crosspostIcon
					}))
				},
				L = o.a.memo(e => {
					const t = Object(i.d)(),
						n = Object(E.a)(),
						a = Object(i.e)(t => Object(S.b)(e.dropdownId)(t)),
						d = Object(i.e)(t => Object(I.b)(Object(h.a)(e.dropdownId))(t)),
						f = Object(r.useCallback)(() => {
							t(Object(b.h)({
								tooltipId: e.dropdownId
							}))
						}, [t, e.dropdownId]),
						g = e => t(Object(m.C)(e)),
						w = Object(r.useCallback)(() => {
							e.post && (t(Object(p.d)(e.post.id)), t(Object(u.i)(Object(h.a)(e.post.id))))
						}, [t, e.post]),
						L = !e.subredditType || e.subredditType === j.g.Public,
						D = !!e.post && e.post.isCrosspostable && !e.post.isSponsored,
						F = Object(r.useCallback)(e => {
							t(Object(l.e)(e)), n(Object(O.a)())
						}, [t, n]);
					return o.a.createElement("div", {
						className: e.className,
						onClick: f,
						id: e.dropdownId
					}, e.children, o.a.createElement(N, {
						className: T.a.dropdown,
						isOpen: a,
						tooltipId: e.dropdownId
					}, o.a.createElement(v.b, {
						className: T.a.dropdownRow,
						displayText: s.fbt._("Copy link", null, {
							hk: "1tCqox"
						}),
						onClick: () => {
							const {
								permalink: t,
								post: n
							} = e;
							if (n && Object(C.r)(n)) e.sendEventWithName("share_copy", {
								referralId: P
							}), w();
							else {
								const n = Object(c.a)(t, {
									utm_source: "share",
									utm_medium: "web2x",
									context: 3
								});
								e.sendEventWithName("share_copy"), g(n)
							}
						}
					}, o.a.createElement(y.a, {
						name: "link_post",
						className: T.a.linkIcon
					})), D && o.a.createElement(M, {
						onCrosspost: () => {
							e.sendEventWithName("share_crosspost"), e.post && window.open(`${k.b}?source_id=${e.post.id}`, "_blank")
						}
					}), L && o.a.createElement(A, {
						permalink: e.permalink,
						sendEventWithName: e.sendEventWithName
					}), o.a.createElement(R, {
						permalink: e.permalink,
						onShare: F
					})), d && e.post && o.a.createElement(h.b, {
						className: T.a.modalBody,
						onClose: t => {
							t && (e.sendEventWithName("copy_link", {
								referralId: P
							}), g(t)), w()
						},
						url: Object(c.a)(Object(x.a)(e.post.id), {
							[_.A]: P,
							utm_source: "share",
							utm_medium: "web2x",
							utm_content: "rpan_stream"
						})
					}))
				});
			t.a = L
		},
		"./src/reddit/components/SourceLink/index.m.less": function(e, t, n) {
			e.exports = {
				OutboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				outboundLinkIcon: "_2WV2dTLgPlEXLVEmIexAxf",
				SourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				sourceLinkWrapper: "_10wC0aXnrUKfdJ4Ssz-o14",
				"m-comment": "_1-PD0_zreH-KVwpFoCLvQF",
				mComment: "_1-PD0_zreH-KVwpFoCLvQF"
			}
		},
		"./src/reddit/components/SourceLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/ads/index.ts"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/getShortenedLink.ts"),
				d = n("./node_modules/fbt/lib/FbtPublic.js");
			const c = 16765092,
				l = "https://i.redd.it/snoovatar",
				u = "snoovatars",
				m = "avatars";
			var p = n("./src/reddit/components/ProfileIdCard/SnoovatarButton/TryItOn.tsx"),
				b = n("./src/reddit/components/AvatarPost/index.m.less"),
				f = n.n(b);
			var h = e => {
					let {
						sourceUrl: t,
						username: n,
						post: s
					} = e;
					const [o, i] = new URL(t).pathname.split("/").slice(2), a = function(e) {
						return `${l}/${+e>=c?m:u}/shared/${e}.png`
					}(i);
					return r.a.createElement("div", {
						className: f.a.avatarPostContainer
					}, r.a.createElement("img", {
						className: f.a.avatarPostImage,
						src: a,
						alt: d.fbt._("User Shared Avatar", null, {
							hk: "FDRaA"
						})
					}), r.a.createElement(p.a, {
						isHovercard: !1,
						username: n,
						isAvatarPost: !0,
						post: s,
						share: {
							username: o,
							avatarId: i
						}
					}))
				},
				_ = n("./src/reddit/controls/OutboundLink/styled.tsx"),
				g = n("./src/reddit/hooks/useIsAvatarPost.ts"),
				v = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				x = n("./src/reddit/components/SourceLink/index.m.less"),
				O = n.n(x),
				E = n("./src/lib/lessComponent.tsx"),
				y = n("./src/telemetry/models/Outbound.ts"),
				C = n("./src/reddit/hooks/useIsRemovedOrDeletedPost.ts");
			const j = E.a.wrapped(v.a, "OutboundLinkIcon", O.a),
				k = E.a.div("SourceLinkWrapper", O.a);

			function I(e) {
				const {
					className: t,
					post: n,
					isCommentsPage: s,
					pageLayer: d
				} = e, c = s ? y.SourceElement.PostLink : y.SourceElement.ListingPostLink, {
					source: l
				} = n, u = n.isSponsored || Object(o.u)(d), m = Object(g.a)(n), p = Object(C.a)();
				return !l || p ? null : m ? r.a.createElement(h, {
					sourceUrl: l.url,
					username: n.author,
					post: n
				}) : r.a.createElement(k, {
					className: Object(i.a)({
						[O.a["m-comment"]]: s
					}, t)
				}, r.a.createElement(_.a, {
					href: l.url,
					isSponsored: u,
					postId: n.id,
					source: l,
					sourceElement: c
				}, Object(a.a)({
					...n,
					isSponsored: u
				}), r.a.createElement(j, {
					isFilled: !0
				})))
			}
		},
		"./src/reddit/components/Streaming/ModSettings/index.m.less": function(e, t, n) {
			e.exports = {
				container: "_16pMBJPhtfeyyncMfo7aDr",
				topBar: "_1DEjdLJpmb7fufFzhwqQm0",
				contentContainer: "ZV-o_W-prpE7EI4zyZ1hr",
				formBody: "_3xfSWCFu_alfjEX12_hBAB"
			}
		},
		"./src/reddit/components/Streaming/ModSettings/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/actions/modal.ts"),
				c = n("./src/reddit/actions/streaming/modSettings.ts"),
				l = n("./src/reddit/actions/toaster.ts"),
				u = n("./src/reddit/components/ApprovedSubmitterList/AddApprovedSubmitterModal.tsx"),
				m = n("./src/reddit/components/BlockNavigation/index.tsx"),
				p = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				b = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				f = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				h = n("./src/reddit/contexts/ApiContext.tsx"),
				_ = n("./src/reddit/controls/Button/index.tsx"),
				g = n("./src/reddit/controls/FormFields/index.tsx"),
				v = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				x = n("./src/reddit/models/Toast/index.ts"),
				O = n("./src/reddit/selectors/activeModalId.ts"),
				E = n("./src/reddit/selectors/platform.ts"),
				y = n("./src/reddit/selectors/streamingModSettings.ts"),
				C = n("./src/reddit/components/Streaming/ModSettings/index.m.less"),
				j = n.n(C);
			const k = "streaming-settings-discard-confirmation",
				I = e => Object(l.e)(e, x.b.Error),
				S = Object(a.c)({
					allowNavigationCallback: E.a,
					modSettings: y.e,
					isAddUserModalOpen: e => "ModerationPage--Streaming--AddUser" === Object(O.a)(e),
					isLivestreamingCurrentlyOn: y.d,
					isDiscardModalOpen: Object(O.b)(k),
					isModSettingsSaving: e => Object(y.a)(e)
				}),
				w = Object(i.b)(S, (e, t) => ({
					closeAllModals: () => e(Object(d.f)()),
					onSave: (t, n) => e(Object(c.f)(t, n)),
					onUserAdd: (t, n, s) => e(Object(c.d)(t, n, s)),
					onUserRemove: (t, n, s) => e(Object(c.e)(t, n, s)),
					showToast: t => e(Object(l.f)({
						...t,
						duration: l.a
					})),
					toggleAddUserModal: () => e(Object(d.i)("ModerationPage--Streaming--AddUser")),
					toggleDiscardChangesModal: () => e(Object(d.i)(k))
				})),
				T = e => parseInt(e, 10),
				N = {
					sunday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					monday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					tuesday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					wednesday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					thursday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					friday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}],
					saturday: [{
						startTime: "00:00:00.000000",
						endTime: "23:59:59.000000"
					}]
				},
				P = {
					sunday: [],
					monday: [],
					tuesday: [],
					wednesday: [],
					thursday: [],
					friday: [],
					saturday: []
				};
			class R extends o.a.Component {
				constructor(e) {
					super(e), this.onChange = e => {
						const t = {
							...this.state.changedModSettings,
							...e
						};
						let n = !1;
						Object.keys(t).forEach(e => {
							t[e] !== this.props.modSettings[e] && (n = !0)
						}), this.setState({
							changedModSettings: t,
							hasUnsavedChanges: n
						})
					}, this.onSaveClick = async () => {
						this.props.onSave(this.state.changedModSettings, this.props.subredditId), this.setState({
							hasUnsavedChanges: !1
						})
					}, this.onUserAdd = async (e, t) => {
						this.isDuplicateUser(t) ? await this.props.showToast(I(s.fbt._("'{username}' has already been added", [s.fbt._param("username", t)], {
							hk: "25Zkkf"
						}))) : this.props.onUserAdd(this.props.subredditId, t, this.props.modSettings)
					}, this.isDuplicateUser = e => !!this.props.modSettings.whitelistedUsers.find(t => t.name === e), this.onDiscardUnsavedChangesConfirmed = () => {
						this.performPendingNavigationIfNeeded()
					}, this.onCloseModal = () => {
						this.props.closeAllModals(), this.resetPendingNavigation()
					}, this.resetPendingNavigation = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!1)
					}, this.performPendingNavigationIfNeeded = () => {
						this.props.allowNavigationCallback && this.props.allowNavigationCallback(!0)
					}, this.onUserRemove = async e => {
						this.props.onUserRemove(this.props.subredditId, e, this.props.modSettings)
					}, this.onUserAddButtonClick = () => {
						this.props.toggleAddUserModal()
					}, this.getUpdatedSchedule = e => e ? P : N, this.renderAddUserModal = () => o.a.createElement(u.a, {
						ignoreDefaultFocus: !0,
						onAddSubmitter: this.onUserAdd,
						sendEventWithName: this.noopEventSend,
						subredditId: this.props.subredditId,
						toggleModal: this.props.toggleAddUserModal,
						username: "",
						withOverlay: !0
					}), this.noopEventSend = () => () => {}, this.state = {
						changedModSettings: {},
						livestreamingToggleStateOn: this.props.isLivestreamingCurrentlyOn,
						hasUnsavedChanges: !1
					}
				}
				render() {
					const e = {
							...this.props.modSettings,
							...this.state.changedModSettings
						},
						{
							maxLiveStreams: t,
							minKarma: n,
							minAccountAgeDays: r,
							durationLimitSeconds: i,
							broadcasterPrompt: a,
							isDiscoveryUnitShown: d,
							inSubMinKarma: c
						} = e;
					return o.a.createElement("div", {
						className: j.a.container
					}, o.a.createElement(b.c, {
						className: j.a.topBar
					}, o.a.createElement(_.l, {
						onClick: this.onSaveClick,
						disabled: this.props.isModSettingsSaving
					}, this.props.isModSettingsSaving ? o.a.createElement(v.a, {
						className: j.a.loadingIcon,
						sizePx: 14,
						center: !0
					}) : s.fbt._("Save changes", null, {
						hk: "1IXBxj"
					}))), o.a.createElement(b.a, {
						className: j.a.contentContainer
					}, o.a.createElement(b.b, null, s.fbt._("Broadcasting", null, {
						hk: "3WAsEz"
					})), o.a.createElement("div", {
						className: j.a.formBody
					}, o.a.createElement(f.p, {
						on: this.state.livestreamingToggleStateOn,
						label: s.fbt._("Allow RPAN Broadcasts", null, {
							hk: "2Jt8fz"
						}),
						subtext: s.fbt._("Allow live broadcasts to the Reddit Public Access Network (RPAN) in this community.", null, {
							hk: "2wjtPG"
						}),
						onClick: () => {
							const e = !this.state.livestreamingToggleStateOn;
							this.onChange({
								weeklySchedule: this.getUpdatedSchedule(this.state.livestreamingToggleStateOn)
							}), this.setState({
								livestreamingToggleStateOn: e,
								hasUnsavedChanges: e !== this.props.isLivestreamingCurrentlyOn
							})
						}
					}), o.a.createElement(f.p, {
						on: d,
						label: s.fbt._("Display RPAN Discovery Unit", null, {
							hk: "3mInib"
						}),
						subtext: s.fbt._("Allow discovery unit for Reddit Public Access Network (RPAN) to be displayed in this community.", null, {
							hk: "3MsZuO"
						}),
						onClick: () => {
							this.onChange({
								isDiscoveryUnitShown: !d
							})
						}
					}), o.a.createElement(f.l, {
						label: s.fbt._("Maximum live broadcasts", null, {
							hk: "bjAcp"
						}),
						direction: "row",
						subtext: s.fbt._("Set the number of broadcasts that can be live at the same time.", null, {
							hk: "fmNzG"
						})
					}, o.a.createElement(g.b, {
						onChange: e => this.onChange({
							maxLiveStreams: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1e3,
						value: t
					})), o.a.createElement(f.l, {
						label: s.fbt._("Required karma", null, {
							hk: "1UzH6K"
						}),
						direction: "row",
						subtext: s.fbt._("Set the amount of global Reddit comment karma someone needs to broadcast live.", null, {
							hk: "1Xa56V"
						})
					}, o.a.createElement(g.b, {
						onChange: e => this.onChange({
							minKarma: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: n
					})), o.a.createElement(f.l, {
						label: s.fbt._("Required community karma", null, {
							hk: "nSuPZ"
						}),
						direction: "row",
						subtext: s.fbt._("Set the amount of community comment karma someone needs to broadcast live.", null, {
							hk: "24qW8L"
						})
					}, o.a.createElement(g.b, {
						onChange: e => this.onChange({
							inSubMinKarma: T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						value: c
					})), o.a.createElement(f.l, {
						label: s.fbt._("Required Account Age", null, {
							hk: "3OXG2v"
						}),
						direction: "row",
						subtext: s.fbt._("Set how old (in days) someone’s Reddit account needs to be to broadcast live.", null, {
							hk: "24iax6"
						})
					}, o.a.createElement(g.b, {
						onChange: e => this.onChange({
							minAccountAgeDays: T(e.currentTarget.value)
						}),
						min: 0,
						type: "number",
						value: r
					})), o.a.createElement(f.l, {
						label: s.fbt._("Time Limit", null, {
							hk: "2x8YNI"
						}),
						direction: "row",
						subtext: s.fbt._("Broadcasts will end after hitting this limit (in minutes), unless viewers award them more time.", null, {
							hk: "4wwLJ4"
						})
					}, o.a.createElement(g.b, {
						onChange: e => this.onChange({
							durationLimitSeconds: 60 * T(e.currentTarget.value)
						}),
						type: "number",
						min: 0,
						max: 1440,
						value: Math.round(i || 0) / 60,
						disabled: !0
					})), o.a.createElement(f.h, {
						label: s.fbt._("RPAN Description", null, {
							hk: "1WiS6G"
						}),
						direction: "row",
						subtext: s.fbt._("Write a quick description of your community to help broadcasters know what you're about", null, {
							hk: "1fcoqh"
						}),
						onChange: e => this.onChange({
							broadcasterPrompt: e.currentTarget.value
						}),
						maxChars: 250,
						rows: 2,
						value: a || ""
					}))), this.props.isAddUserModalOpen && this.renderAddUserModal(), o.a.createElement(m.a, {
						blockOnBeforeUnload: !0,
						dialogId: k,
						enabled: this.state.hasUnsavedChanges
					}), this.props.isDiscardModalOpen && o.a.createElement(p.a, {
						actionText: s.fbt._("Discard", null, {
							hk: "1SiwLl"
						}),
						headerText: s.fbt._("Discard changes before leaving?", null, {
							hk: "354NTe"
						}),
						modalText: s.fbt._("You have made some changes to broadcasting settings, do you wish to discard the changes?", null, {
							hk: "20tlQp"
						}),
						onConfirm: this.onDiscardUnsavedChangesConfirmed,
						toggleModal: this.onCloseModal,
						withOverlay: !0
					}))
				}
			}
			t.a = Object(h.b)(w(R))
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less": function(e, t, n) {
			e.exports = {
				StyledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				styledChevron: "_2iNDx2lEuGuIyvMjz5ujOL",
				BreadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				breadcrumbElement: "_32_k0a9y4N9cAnw6gApo5X",
				BreadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbContainer: "_1PgkMUbe7dhkAqRt4-VPGe",
				breadcrumbTitle: "_2N7RnlFNJblZD8KUBuiBEQ"
			}
		},
		"./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/lessComponent.tsx"),
				i = n("./src/reddit/components/TrackingHelper/index.tsx"),
				a = n("./src/reddit/helpers/trackers/blade.ts"),
				d = n("./src/reddit/icons/svgs/Chevron/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.m.less"),
				l = n.n(c);
			const u = o.a.wrapped(d.a, "StyledChevron", l.a),
				m = o.a.div("BreadcrumbElement", l.a),
				p = o.a.div("BreadcrumbContainer", l.a);
			t.b = Object(i.c)(e => r.a.createElement(p, null, e.breadcrumbs.map(t => r.a.createElement(m, {
				key: t.title,
				onClick: () => {
					e.sendEvent(Object(a.a)()), e.onNavigate(t)
				}
			}, r.a.createElement(u, null), r.a.createElement("span", {
				className: l.a.breadcrumbTitle
			}, t.title)))))
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				ImageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				imageUploadIcon: "e9OxAKtFra_8aEeb27dTl",
				ImageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				imageIconRow: "_14ar_PmlmkOhLrVDBwohzK",
				ImageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				imageUploadText: "_3-gXMEj353M5u8pnC-tDG8",
				FileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				fileDrop: "_3n4Aj_eDE25JhXbxz3XpKf",
				ContainerUploading: "rOyNUbZnjJvWxtyInd1T8",
				containerUploading: "rOyNUbZnjJvWxtyInd1T8",
				Label: "_2ZFG2IQMaso9iA14qjicA_",
				label: "_2ZFG2IQMaso9iA14qjicA_",
				isOver: "_1B5UKMPaEBX3HOKKEBfp7o",
				ImageInput: "_362HLUlCiz7UbtVPniNjjW",
				imageInput: "_362HLUlCiz7UbtVPniNjjW"
			}
		},
		"./src/reddit/components/StructuredStyles/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/FileDrop/index.tsx"),
				d = n("./src/reddit/controls/ImageInput/index.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/svgs/ImageUpload/index.tsx"),
				u = n("./src/reddit/components/StructuredStyles/ImageUpload/index.m.less"),
				m = n.n(u);
			const {
				fbt: p
			} = n("./node_modules/fbt/lib/FbtPublic.js"), b = i.a.wrapped(l.a, "ImageUploadIcon", m.a), f = i.a.div("ImageIconRow", m.a), h = i.a.div("ImageUploadText", m.a), _ = i.a.wrapped(a.a, "FileDrop", m.a), g = i.a.div("ContainerUploading", m.a), v = e => r.a.createElement(g, {
				className: e.className
			}, r.a.createElement(f, null, r.a.createElement(c.a, {
				sizePx: 40,
				center: !0
			})), r.a.createElement(h, null, p._("Uploading...", null, {
				hk: "2ICpZ2"
			}))), x = i.a.label("Label", m.a);
			t.b = e => r.a.createElement(_, {
				className: e.className,
				onDrop: e.onChange,
				render: t => r.a.createElement(x, {
					className: Object(o.a)({
						[m.a.isOver]: t
					}, e.labelClassName)
				}, r.a.createElement(f, null, e.icon || r.a.createElement(b, null)), r.a.createElement(h, null, e.label), r.a.createElement(d.a, {
					className: m.a.ImageInput,
					name: e.name,
					value: e.value,
					onChange: e.onChange,
					multiple: e.multiple,
					tabIndex: e.tabIndex
				}))
			})
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less": function(e, t, n) {
			e.exports = {
				FormPage: "_9ZuQyDXhFth1qKJF4KNm8",
				formPage: "_9ZuQyDXhFth1qKJF4KNm8",
				HomePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				homePageBreadcrumb: "_2iNJX36LR2tMHx_unzEkVM",
				HomePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				homePageTitle: "_1JmnMJclrTwTPpAip5U_Hm",
				breadcrumbTitle: "_24r4TaTKqNLBGA3VgswFrN",
				HomePageGroup: "_306gA2lxjCHX44ssikUp3O",
				homePageGroup: "_306gA2lxjCHX44ssikUp3O",
				FormPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				formPageTitle: "_1Omf6afKRpv3RKNCWjIyJ4",
				FormPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				formPageSection: "_2Ss7VGMX-UPKt9NhFRtgTz",
				FormGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				formGroup: "_3vWu4F9B4X4Yc-Gm86-FMP",
				FormGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				formGroupTitle: "_2qAEe8HGjtHsuKsHqNCa9u",
				FormElement: "c5RWd-O3CYE-XSLdTyjtI",
				formElement: "c5RWd-O3CYE-XSLdTyjtI",
				FormGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				formGroupDescription: "_3whORKuQps-WQpSceAyHuF",
				FormItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				formItem: "_1Qk-ka6_CJz1fU3OUfeznu",
				FormElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				formElementTitle: "_3ds8Wk2l32hr3hLddQshhG",
				FormElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				formElementDescription: "_1h0r6vtgOzgWtu-GNBO6Yb",
				FormElementError: "horIoLCod23xkzt7MmTpC",
				formElementError: "horIoLCod23xkzt7MmTpC",
				FormElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				formElementSubGroup: "_33Iw1wpNZ-uhC05tWsB9xi",
				FormListItem: "_2M7LQbQxH40ingJ9h9RslL",
				formListItem: "_2M7LQbQxH40ingJ9h9RslL"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/forms.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return i
			})), n.d(t, "p", (function() {
				return a
			})), n.d(t, "n", (function() {
				return d
			})), n.d(t, "o", (function() {
				return c
			})), n.d(t, "m", (function() {
				return l
			})), n.d(t, "l", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			})), n.d(t, "d", (function() {
				return x
			})), n.d(t, "j", (function() {
				return O
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/components/StructuredStyles/StyledComponents/forms.m.less"),
				o = n.n(r);
			const i = s.a.section("FormPage", o.a),
				a = s.a.h1("HomePageTitle", o.a),
				d = s.a.button("HomePageBreadcrumb", o.a),
				c = s.a.div("HomePageGroup", o.a),
				l = s.a.h1("FormPageTitle", o.a),
				u = s.a.div("FormPageSection", o.a),
				m = s.a.div("FormGroup", o.a),
				p = s.a.h2("FormGroupTitle", o.a),
				b = s.a.div("FormElement", o.a),
				f = s.a.div("FormGroupDescription", o.a),
				h = s.a.div("FormItem", o.a),
				_ = s.a.h3("FormElementTitle", o.a),
				g = s.a.div("FormElementDescription", o.a),
				v = s.a.div("FormElementError", o.a),
				x = s.a.div("FormElementSubGroup", o.a),
				O = s.a.li("FormListItem", o.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less": function(e, t, n) {
			e.exports = {
				ModalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				modalInput: "_2-UQO_nq1P8ACGIq0yZJRz",
				Input: "_1BJV17HgWhhC-BxrpqGjM",
				input: "_1BJV17HgWhhC-BxrpqGjM",
				Checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				checkbox: "_29ZBtSa05ZCR4Sj1modCls",
				CheckboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				checkboxSelected: "_1UmPxfh5dZu-x2VK6n61BM",
				iconStyles: "_349rJ1BueyeldYiZniwYOz",
				RadioOff: "_23-RdhX276B0bg5nrt0cpf",
				radioOff: "_23-RdhX276B0bg5nrt0cpf",
				RadioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				radioOn: "_2tv2vEpNmUbYbUPoOrSuAh",
				Textarea: "_2gchCc4pmLk-CHEErYmFaP",
				textarea: "_2gchCc4pmLk-CHEErYmFaP",
				StyledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				styledLabel: "_3X0DVhTjHSRuQBMvaWD4N",
				StyledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN",
				styledFileInput: "_2kbxOlf5qlKAzRVdk0a0GN"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return v
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/ModalInput.tsx"),
				o = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				i = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.m.less"),
				l = n.n(c);
			const u = s.a.wrapped(r.a, "ModalInput", l.a),
				m = s.a.input("Input", l.a),
				p = s.a.wrapped(d.a, "RadioOn", l.a),
				b = s.a.wrapped(a.a, "RadioOff", l.a),
				f = s.a.wrapped(o.a, "Checkbox", l.a),
				h = s.a.wrapped(i.a, "CheckboxSelected", l.a),
				_ = s.a.textarea("Textarea", l.a),
				g = s.a.label("StyledLabel", l.a),
				v = s.a.input("StyledFileInput", l.a)
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less": function(e, t, n) {
			e.exports = {
				FormNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				formNavElement: "KLpkXNw-FZfqtRK9U_8HB",
				disabled: "_2omjYUqCweNidaShU2H5EC",
				DragCard: "ygS6b189jD1GHwzotinJB",
				dragCard: "ygS6b189jD1GHwzotinJB",
				isOverAndCanDrop: "_3_GRCa3UIhqQ68fvB00PLZ",
				isDragging: "_2yg01oNjKP8Gcb4HPjf58k"
			}
		},
		"./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
					let {
						disabled: t,
						...n
					} = e;
					return r.a.createElement("div", d({}, n, {
						className: Object(o.a)(a.a.FormNavElement, {
							[a.a.disabled]: t
						})
					}), n.children)
				},
				l = e => {
					let {
						canDrop: t,
						className: n,
						isDragging: s,
						isOver: i,
						disabled: c,
						...l
					} = e;
					return r.a.createElement("div", d({}, l, {
						className: Object(o.a)(a.a.DragCard, {
							[a.a.disabled]: c,
							[a.a.isDraffing]: s,
							[a.a.isOverAndCanDrop]: i && t
						}, n)
					}))
				}
		},
		"./src/reddit/components/SubredditContent/PredictionsContent/async.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-SubredditContent-PredictionsContent",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-SubredditContent-PredictionsContent").then(n.bind(null, "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/SubredditContent/PredictionsContent/index.tsx"
				}
			})
		},
		"./src/reddit/components/SubredditContent/ScheduledPostContent/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				d = n("./src/reddit/actions/scheduledPosts/index.ts"),
				c = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				l = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				u = n("./node_modules/reselect/es/index.js"),
				m = n("./src/lib/classNames/index.ts"),
				p = n("./src/reddit/actions/modal.ts"),
				b = n("./src/lib/CSSVariableProvider/index.tsx"),
				f = n("./src/reddit/controls/Button/index.tsx"),
				h = n("./src/reddit/components/Paginator/index.m.less"),
				_ = n.n(h);

			function g() {
				return (g = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const v = e => {
				const {
					isNextButton: t,
					isActive: n,
					...s
				} = e;
				return o.a.createElement(f.i, g({
					disabled: !n
				}, s))
			};
			class x extends o.a.Component {
				constructor(e) {
					super(e), this.onHandlePrev = () => this.onHandlePageChange(!1), this.onHandleNext = () => this.onHandlePageChange(!0), this.state = {
						currentCursor: void 0
					}
				}
				getCurrentCursorIdx() {
					const {
						items: e
					} = this.props, {
						currentCursor: t
					} = this.state;
					return t ? e.findIndex(e => e.id === t) : -1
				}
				getRenderableItems() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props, n = this.getCurrentCursorIdx() + 1;
					return e.slice(n, n + t)
				}
				hasPrevPage() {
					return !(this.getCurrentCursorIdx() <= 0)
				}
				hasNextPage() {
					const {
						items: e,
						itemsPerPage: t
					} = this.props;
					return !(this.getCurrentCursorIdx() + t > e.length - 2)
				}
				onHandlePageChange(e) {
					const {
						items: t,
						itemsPerPage: n
					} = this.props, s = this.getCurrentCursorIdx();
					if (e && !this.hasNextPage()) return;
					if (!e && !this.hasPrevPage()) return;
					const r = e ? Math.max(-1, Math.min(s + n, t.length - 2)) : Math.max(-1, s - n);
					this.setState({
						currentCursor: t[r] ? t[r].id : void 0
					})
				}
				renderControlRow() {
					const {
						usePortalForControlRow: e,
						controlRowPortal: t,
						pagerButton: n = v
					} = this.props, r = this.hasPrevPage(), i = this.hasNextPage();
					if (!r && !i) return null;
					const a = o.a.createElement("div", {
						className: _.a.controlRow
					}, o.a.createElement("span", {
						className: _.a.prevButtonContainer
					}, o.a.createElement(n, {
						className: _.a.prevButton,
						onClick: this.onHandlePrev,
						isNextButton: !1,
						isActive: r
					}, s.fbt._("Previous", null, {
						hk: "4hX0ue"
					}))), o.a.createElement("span", {
						className: _.a.nextButtonContainer
					}, o.a.createElement(n, {
						className: _.a.nextButton,
						onClick: this.onHandleNext,
						isNextButton: !0,
						isActive: i
					}, s.fbt._("Next", null, {
						hk: "2mEXAi"
					}))));
					return e && !t ? null : t ? Object(b.d)(a, t) : a
				}
				render() {
					const {
						className: e,
						lastItemClassName: t,
						itemComponent: n
					} = this.props, s = this.getRenderableItems();
					return o.a.createElement("div", {
						className: e
					}, s.map((e, r) => o.a.createElement(n, {
						className: t && r === s.length - 1 ? t : void 0,
						key: e.id,
						item: e
					})), this.renderControlRow())
				}
			}
			var O = x,
				E = n("./src/reddit/icons/svgs/ArrowRight/index.tsx"),
				y = n("./src/reddit/components/RecurringPostList/ChangePageButton/index.m.less"),
				C = n.n(y);
			var j = e => o.a.createElement("button", {
					className: Object(m.a)(C.a.button, e.className, {
						[C.a.prevButton]: !e.isNextButton,
						[C.a.disabled]: !e.isActive
					}),
					onClick: e.onClick,
					disabled: !e.isActive
				}, o.a.createElement(E.a, {
					className: C.a.arrowIcon
				})),
				k = n("./src/reddit/components/RecurringPostList/EditModal/async.tsx"),
				I = n("./src/reddit/components/RecurringPostList/RecurringPost/index.tsx"),
				S = n("./src/reddit/components/TrackingHelper/index.tsx"),
				w = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				T = n("./src/reddit/icons/fonts/index.tsx"),
				N = n("./src/reddit/routes/postCreation/index.ts"),
				P = n("./src/reddit/selectors/activeModalId.ts"),
				R = n("./src/reddit/selectors/scheduledPosts/index.ts"),
				A = n("./src/reddit/components/RecurringPostList/index.m.less"),
				M = n.n(A);
			const {
				fbt: L
			} = n("./node_modules/fbt/lib/FbtPublic.js"), D = 5, F = Object(u.c)({
				recurringPosts: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(R.l)(e, {
						subredditId: n.id
					})
				},
				editModalIsOpen: e => Object(P.a)(e) === I.a,
				editingRecurringPostId: R.d,
				editingRecurringPostSubredditId: R.e
			});
			class U extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.pageButtonPortalRef = o.a.createRef(), this.onEditModalSuccessfulSave = () => {
						this.props.editModalIsOpen && this.props.toggleModal()
					}, this.onClickLink = () => {
						this.props.sendEvent(Object(w.j)())
					}
				}
				renderEmptyState() {
					return o.a.createElement(c.c, {
						className: M.a.emptyContainer,
						text: L._("No recurring posts", null, {
							hk: "2G7szl"
						}),
						childrenPosition: "bottom"
					}, o.a.createElement(T.a, {
						name: "refresh",
						className: M.a.icon
					}), o.a.createElement(a.a, {
						className: M.a.schedulePostLink,
						onClick: this.onClickLink,
						to: Object(N.c)(this.props.subreddit.name)
					}, L._("Schedule recurring post", null, {
						hk: "1TrUPC"
					})))
				}
				render() {
					const {
						className: e,
						recurringPosts: t,
						editModalIsOpen: n,
						subreddit: s,
						editingRecurringPostSubredditId: r,
						editingRecurringPostId: i
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: Object(m.a)(e, M.a.postList)
					}, o.a.createElement("div", {
						className: M.a.titleContainer
					}, L._("Recurring posts", null, {
						hk: "30aHKv"
					}), o.a.createElement("div", {
						ref: this.pageButtonPortalRef,
						className: M.a.pageButtonPortal
					})), t.length ? o.a.createElement(O, {
						className: M.a.recurringPostsContainer,
						lastItemClassName: M.a.lastRecurringPostItem,
						itemsPerPage: D,
						items: t,
						itemComponent: I.b,
						pagerButton: j,
						usePortalForControlRow: !0,
						controlRowPortal: this.pageButtonPortalRef.current
					}) : this.renderEmptyState()), n && !!i && !!r && s.id === r && o.a.createElement(k.a, {
						scheduledPostId: i,
						subredditId: r,
						onSuccessfulSave: this.onEditModalSuccessfulSave,
						withOverlay: !0
					}))
				}
			}
			var B = Object(i.b)(F, (e, t) => ({
					toggleModal: () => e(Object(p.i)(I.a))
				}))(Object(S.c)(U)),
				q = n("./src/reddit/components/ScheduledPost/index.tsx"),
				G = n("./src/reddit/components/Scroller/Simple.tsx"),
				H = n("./src/reddit/components/SubredditContent/index.tsx"),
				W = n("./src/reddit/components/SubredditContent/index.m.less"),
				V = n.n(W),
				z = n("./src/reddit/models/ScheduledPost/index.ts");
			const K = Object(u.c)({
					isLoading: R.i,
					hasData: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.h)(e, {
							subredditId: n.id
						})
					},
					standalonePosts: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.q)(e, {
							subredditId: n.id
						})
					},
					loadMoreToken: (e, t) => {
						let {
							subreddit: n
						} = t;
						return Object(R.c)(e, {
							subredditId: n.id,
							type: z.g.standalonePosts
						})
					}
				}),
				Q = Object(i.b)(K, (e, t) => {
					let {
						subreddit: n
					} = t;
					return {
						onLoadMoreStandaloneScheduledPosts: () => e(Object(d.a)(n.id))
					}
				});
			class Y extends o.a.PureComponent {
				render() {
					const {
						hasData: e,
						standalonePosts: t,
						onLoadMore: n,
						loadMoreToken: s,
						renderEmptyState: r,
						subreddit: i
					} = this.props;
					return o.a.createElement("div", {
						className: V.a.contentContainer
					}, o.a.createElement("div", {
						className: V.a.standaloneContainer
					}, e && t.length ? o.a.createElement(G.b, {
						className: V.a.scroller,
						onLoadMore: n,
						loadMoreToken: s || void 0
					}, t.map(e => ({
						id: e.id,
						estHeight: 112,
						render: t => o.a.createElement(q.a, {
							key: `scheduled-post-id-${e.id}`,
							scheduledPostId: e.id,
							subredditId: e.subreddit.id
						})
					}))) : r()), o.a.createElement(B, {
						className: V.a.sidebar,
						subreddit: i
					}))
				}
			}
			class J extends o.a.PureComponent {
				constructor() {
					super(...arguments), this.renderStandaloneEmptyState = () => {
						const {
							subreddit: e
						} = this.props;
						return o.a.createElement(c.c, {
							className: V.a.emptyStateContainer,
							text: s.fbt._("No scheduled posts in r/{subredditName}", [s.fbt._param("subredditName", e.name)], {
								hk: "mUwQ4"
							}),
							childrenPosition: "bottom"
						}, o.a.createElement(T.a, {
							name: "history",
							className: V.a.icon
						}), o.a.createElement(a.a, {
							className: V.a.schedulePostLink,
							to: Object(N.c)(e.name)
						}, s.fbt._("Schedule post", null, {
							hk: "xI07X"
						})))
					}
				}
				renderBody() {
					const {
						hasData: e,
						loadMoreToken: t,
						onLoadMoreStandaloneScheduledPosts: n,
						standalonePosts: s,
						subreddit: r
					} = this.props;
					return o.a.createElement(Y, {
						renderEmptyState: this.renderStandaloneEmptyState,
						hasData: e,
						standalonePosts: s,
						onLoadMore: n,
						subreddit: r,
						loadMoreToken: t
					})
				}
				render() {
					const {
						isLoading: e,
						hasData: t,
						subreddit: n
					} = this.props;
					return o.a.createElement(o.a.Fragment, null, o.a.createElement(l.c, null, o.a.createElement(a.a, {
						to: Object(N.c)(n.name)
					}, o.a.createElement(f.l, null, s.fbt._("Schedule Post", null, {
						hk: "2Ygkzg"
					})))), o.a.createElement(l.a, null, o.a.createElement(l.b, {
						className: V.a.pageTitle
					}, s.fbt._("Scheduled posts", null, {
						hk: "28Qjmj"
					})), !t && e ? Object(H.a)() : this.renderBody(), t && e && Object(H.a)(1)))
				}
			}
			t.a = Q(J)
		},
		"./src/reddit/components/SubredditContent/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1N366WahaKnCqUlSezl6CQ",
				titleFontH2: "_2ySCAslCokkxUasLc4m7l0",
				titleFontH3: "_3Na_u-vwpkuPZfuuvUROk-",
				titleFontH4: "_30jImFPUovcaQMWasU-Ohq",
				titleFontH5: "_1fkIEAH9a9eCt2B8XAaUbq",
				titleFontH6: "bHSjFLbSCNEywMorkTrqn",
				metadataFont: "_2Qe8DvvY_RxPEkj-mRpX65",
				flairFont: "_1TXuHKPD3YeZiCgMqyoBBe",
				labelsFont: "_1MiMOmZyBl0g5x8oLzodW8",
				actionFont: "_3USAKL0kbrc0ZhCvZS-J4j",
				smallButtonFont: "_2JaNUow_hy9X8yw0QFNOSg",
				largeButtonFont: "_2QdyaDMXRLLL3gChJ0NOE9",
				strongTextFont: "_3qauH8UCZvDtHIr65uebN5",
				tabFont: "_1bq9fxhlMVaxA2GQdVomf4",
				buttonFontXS: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontXs: "_7W4YggPAccJm6b7j_5tM_",
				buttonFontS: "_2ZBn3QtRUE4GU3UTdoCOzY",
				buttonFontM: "_1FF_0_g8KF3VAe3NMA-Lu6",
				buttonFontL: "_12R7hgqLzyY_mHo7tL6VIy",
				buttonFontXL: "_1c2eC_5e586qF7hV3NBVj_",
				buttonFontXl: "_1c2eC_5e586qF7hV3NBVj_",
				bodyFontH1: "_2qU2oh77HnIxSqTey1ZezW",
				bodyFontH2: "_2XZkZ1zrfSvpi64O-KP4IB",
				bodyFontH3: "_1icF_z4wcZT687-ao6Mzr7",
				bodyFontH4: "ZRi07Zo9aba1n7XQY_Xio",
				bodyFontH5: "_1dhvcwu2KcypL8_En9Aa7I",
				bodyFontH6: "_1FGIk1pK7xZjRbWXhruioE",
				bodyFontH6Small: "gX_Loj9AWtmLld5X2fYAM",
				bodyFont: "_3xTpswgMylBeM6Y-XFNTUD",
				bodyFontSmall: "_3U8U5anYwaLfjJvSrrhIKo",
				bodyFontMono: "_1VL2XaMyhrq5PiMxCa8tkv",
				landingPageTitleFontH1: "_3U33V1TLB1wNZLhlm76iyw",
				landingPageTitleFontH2: "_1qRVc7UgXT9O9JIwEy17WP",
				landingPageTitleFontH3: "Jt9WK82aCYMXRtfrdkHBw",
				icon: "_1wICBaO2ARQK5N8CBXP8kI",
				schedulePostLink: "_3hO2emEyTZ-txWczRsI6lb",
				betaIndicator: "q9zqS5nIMgIr22a55zflg",
				pageTitle: "_2HS4U5X7Rt3fT__Kpgmp9M",
				contentContainer: "_2i38uCMOvjLO0N4T-QGmV1",
				scroller: "_2toQcR3aw1_hj1A49e4wi7",
				sidebar: "_3Pz5gIKK5q2FYttguHTNa3",
				emptyStateContainer: "_3uHuaRL_-Tec711luXRhl8",
				standaloneContainer: "Q7W5RJknO1UJ-qscCW0k6",
				eventPostContainer: "_1WvFOm4w7Qt8CpM_XKK9y8"
			}
		},
		"./src/reddit/components/SubredditContent/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/ClassicPost/Placeholder.tsx");

			function i() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
				const t = [];
				for (let n = 0; n < e; n++) t.push(r.a.createElement(o.b, {
					isLoading: !0
				}));
				return r.a.createElement(r.a.Fragment, null, t)
			}
		},
		"./src/reddit/components/SubredditCreationModal/Layout/index.m.less": function(e, t, n) {
			e.exports = {
				Content: "gGAX8JwsFcDSDsT5KcKrL",
				content: "gGAX8JwsFcDSDsT5KcKrL",
				Container: "_1J0hJj-EXr49KppYTmtS9S",
				container: "_1J0hJj-EXr49KppYTmtS9S",
				ContainerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				containerExp: "_3Cb_x0VK1tr3QTaBDGU_-K",
				OuterContainer: "_1wLNhgzYyv0-JBg0BfYf3Y",
				outerContainer: "_1wLNhgzYyv0-JBg0BfYf3Y"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.m.less": function(e, t, n) {
			e.exports = {
				sublabel: "_1l4AkEjhz6oh1lmsJv-6Oo",
				subtitle: "SJ8r-Lx8GZVAGXaT954wj",
				radioDescription: "_1FBE2BnOrrXe8bCr6ZLfGq",
				buttonContainer: "pllx1jz7x_s-pSUC5f15v",
				field: "_2m493sVo9iDo-3EBxQrAJc",
				isCreatePending: "_39K9U8eGRvjiN3lSUWfoXF",
				subredditCreation: "_3O95baBiXBhn2SNtTQXPun",
				container: "o5ISTIh6L_lvDC1gObc76",
				title: "_2d-OkUXQj6P8CRIrcoi1i9",
				nsfw: "_3bx-zSg4-Vgfi3x1IUw6QP",
				createButton: "_2shIfL3K7ivaojvZFjvI-Z",
				pendingText: "A8PHuGr_4pbV_7t_GaokO",
				metaFieldDescription: "HsJgPFCmZ8OKgFe3tYiOB",
				numCommunityTopicsSelected: "_3-RTBwxKbhnYzfNZydOubp",
				subtextContainer: "_1V3LfcGf8bnGW9vw7JkOOs",
				radioContainer: "_247NCf2PSxl4rhmx2dDhDC",
				radioContent: "_2QiRZZs4K5lTjMTuSaMgDC",
				textButton: "c6YtB-MsWwD2pwSxCRQWE",
				fullWidthTextContainer: "_39cm2YKltxh0YW0O1f54y3",
				Info: "_16_IgJ4BqtadthCKIpnW1g",
				info: "_16_IgJ4BqtadthCKIpnW1g",
				RadioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				radioOption: "_12umGu0WfWJw9rxGq4ykrZ",
				StyledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				styledTooltip: "j2Jvuy8Yu-jexJED1Ap51",
				RadioIcon: "_1g89RGQdzecmnfVeXck6JL",
				radioIcon: "_1g89RGQdzecmnfVeXck6JL",
				Employee: "_2gDVAtwwxskByrxI2Zr9BL",
				employee: "_2gDVAtwwxskByrxI2Zr9BL",
				Private: "_1Ma7YYe0ShiEmNSS16r18H",
				private: "_1Ma7YYe0ShiEmNSS16r18H",
				Public: "_3WyydSidemq34inFmhA1SE",
				public: "_3WyydSidemq34inFmhA1SE",
				Restricted: "CodbGPlWjCpPE6jWVhkOn",
				restricted: "CodbGPlWjCpPE6jWVhkOn",
				CloseButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				closeButton: "_1P7Eow5rs9Xxm1uqMMEr2h",
				ErrorText: "_2dXAoHGf_uRg0D6ofrpJbr",
				errorText: "_2dXAoHGf_uRg0D6ofrpJbr"
			}
		},
		"./src/reddit/components/SubredditCreationModal/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "radioOptions", (function() {
				return ae
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/higherOrderComponents/asModal/index.tsx"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/reddit/actions/modal.ts"),
				u = n("./src/reddit/actions/subredditCreation.ts"),
				m = n("./src/reddit/actions/tooltip.ts"),
				p = n("./src/reddit/components/EmailInvitePaintedDoor/loader.tsx"),
				b = n("./src/reddit/components/InfoTextTooltip/index.tsx"),
				f = n("./src/reddit/components/Settings/shared/Widgets.tsx"),
				h = n("./src/reddit/contexts/NavbarExp.ts"),
				_ = n("./src/reddit/components/SubredditCreationModal/Layout/index.m.less"),
				g = n.n(_);
			var v = e => {
					const t = Object(r.useContext)(h.a);
					return o.a.createElement("div", {
						className: g.a.OuterContainer
					}, o.a.createElement("div", {
						className: Object(c.a)(e.className, g.a.Container)
					}, o.a.createElement("div", {
						className: Object(c.a)(g.a.Content, {
							[g.a.ContainerExp]: t
						})
					}, e.children)))
				},
				x = n("./src/reddit/components/TrackingHelper/index.tsx"),
				O = n("./src/reddit/constants/modals.ts"),
				E = n("./src/reddit/controls/Button/index.tsx"),
				y = n("./src/reddit/controls/CheckboxInput/index.tsx"),
				C = n("./src/reddit/controls/ErrorText/index.tsx"),
				j = n("./src/reddit/controls/RadioInput/index.tsx"),
				k = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				I = n("./src/reddit/controls/TextButton/index.tsx"),
				S = n("./src/reddit/helpers/trackers/emailInvite.ts"),
				w = n("./src/reddit/helpers/trackers/screenview.ts"),
				T = n("./src/reddit/helpers/trackers/subredditCreation.ts"),
				N = n("./src/reddit/icons/svgs/Admin/index.tsx"),
				P = n("./src/reddit/icons/svgs/Close/index.tsx"),
				R = n("./src/reddit/icons/svgs/Eye/index.tsx"),
				A = n("./src/reddit/icons/svgs/Info/index.tsx"),
				M = n("./src/reddit/icons/svgs/Lock/index.tsx"),
				L = n("./src/reddit/icons/svgs/User/index.tsx"),
				D = n("./src/reddit/models/Subreddit/index.ts"),
				F = n("./src/reddit/models/SubredditRestrictions/index.ts"),
				U = n("./src/reddit/selectors/experiments/emailInvite.ts"),
				B = n("./src/reddit/selectors/subreddit.ts"),
				q = n("./src/reddit/selectors/tags.ts"),
				G = n("./src/reddit/selectors/user.ts"),
				H = n("./src/lib/formatApiError/index.ts");
			const W = (e, t) => {
				if (!e) return {};
				const n = e.fields && e.fields.length && e.fields[0] && e.fields[0].field,
					r = e.type;
				if ("name" === n) {
					if ("NO_TEXT" === r) return {
						name: s.fbt._("A community name is required", null, {
							hk: "QIlYS"
						})
					};
					if ("BAD_SR_NAME" === r) return {
						name: s.fbt._("Community names must be between 3–21 characters, and can only contain letters, numbers, or underscores.", null, {
							hk: "2rmVgd"
						})
					};
					if ("SUBREDDIT_EXISTS" === r) return {
						name: s.fbt._("Sorry, r/{subreddit name attempt} is taken. Try another.", [s.fbt._param("subreddit name attempt", t)], {
							hk: "CLwzs"
						})
					};
					if ("SUBREDDIT_UNAVAILABLE" === r) return {
						name: s.fbt._("This community name is unavailable", null, {
							hk: "15j6BB"
						})
					}
				}
				return {
					generic: Object(H.a)(e)
				}
			};
			var V = n("./src/reddit/components/SubredditCreationModal/index.m.less"),
				z = n.n(V),
				K = n("./src/lib/lessComponent.tsx");
			const Q = 21,
				Y = "create-title-info",
				J = K.a.wrapped(A.a, "Info", z.a),
				X = K.a.wrapped(k.a, "RadioOption", z.a),
				Z = K.a.wrapped(b.c, "Tooltip", z.a),
				$ = K.a.wrapped(L.a, "Public", z.a),
				ee = K.a.wrapped(R.a, "Restricted", z.a),
				te = K.a.wrapped(M.a, "Private", z.a),
				ne = K.a.wrapped(N.a, "Employee", z.a),
				se = K.a.wrapped(P.a, "CloseButton", z.a),
				re = K.a.wrapped(C.b, "ErrorText", z.a),
				oe = Object(a.c)({
					error: B.f,
					isCreatePending: B.l,
					isEmailInviteExperimentEnabled: U.a,
					isEmployee: G.O,
					crosspostId: B.k,
					userDoesNotHaveEnoughExpToCreateCommunity: e => !Object(G.qb)(e),
					userIsSuspended: G.Y,
					allTags: q.e,
					existingTags: q.f,
					newTags: q.g,
					selectedPrimaryTagId: q.h
				}),
				ie = Object(i.b)(oe, e => ({
					createCommunity: t => e(Object(u.h)(t)),
					clearErrors: () => e(Object(u.f)()),
					onCloseModal: () => e(Object(l.g)(O.a.SUBREDDIT_CREATION_MODAL_ID)),
					onShowTooltip: () => e(Object(m.f)({
						tooltipId: Y
					})),
					onHideTooltip: () => e(Object(m.i)()),
					validateSubredditName: t => e(Object(u.i)(t))
				})),
				ae = (e, t) => [o.a.createElement(X, {
					key: "public",
					showButton: !0,
					value: "public"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement($, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Public", null, {
					hk: "DK992"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Anyone can view, post, and comment to this community", null, {
					hk: "1PfFUA"
				}))))), o.a.createElement(X, {
					key: "restricted",
					showButton: !0,
					value: "restricted"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ee, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Restricted", null, {
					hk: "1iBTDq"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, Object(F.g)(t))))), o.a.createElement(X, {
					key: "private",
					showButton: !0,
					value: "private"
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(te, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Private", null, {
					hk: "3q5SYn"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Only approved users can view and submit to this community", null, {
					hk: "3z8OI6"
				}))))), o.a.createElement(X, {
					key: "employees_only",
					showButton: !0,
					value: "employees_only",
					hidden: !e
				}, o.a.createElement("div", {
					className: z.a.radioContent
				}, o.a.createElement("div", null, o.a.createElement(ne, null)), o.a.createElement("div", {
					className: z.a.radioContainer
				}, o.a.createElement("div", {
					className: z.a.sublabel
				}, s.fbt._("Employees only", null, {
					hk: "1arrQC"
				})), o.a.createElement("div", {
					className: Object(c.a)(z.a.metafieldDescription, z.a.radioDescription)
				}, s.fbt._("Only Reddit employees can view and submit to this community", null, {
					hk: "3ty23C"
				})))))];
			class de extends o.a.Component {
				constructor(e) {
					super(e), this.onNameChange = e => {
						this.setState({
							name: e.target.value
						}), this.props.clearErrors()
					}, this.update = (e, t) => this.setState({
						[t]: e
					}), this.onTypeChange = e => {
						this.setState({
							type: e
						})
					}, this.onInviteViaEmailClick = () => {
						const {
							sendEvent: e
						} = this.props;
						e(Object(S.a)("community_creation")), this.setState({
							showEmailInviteModal: !0
						})
					}, this.onCloseInviteViaEmailModal = () => {
						this.setState({
							showEmailInviteModal: !1
						})
					}, this.onCreateCommunityClick = () => {
						this.props.isCreatePending || (clearTimeout(this.timeout), this.props.createCommunity({
							name: this.state.name,
							publicDescription: "",
							type: this.state.type,
							over18: this.state.over18,
							restrictCommenting: this.state.restrictCommenting,
							restrictPosting: this.state.restrictPosting,
							allTags: this.props.allTags,
							newTags: this.props.newTags,
							crosspostId: this.state.crosspostId,
							existingTags: this.props.existingTags,
							primaryTagId: this.props.selectedPrimaryTagId || void 0
						}), this.timeout = window.setTimeout(() => {
							this.props.isCreatePending && this.setState({
								waitingForSuccessfulCommunity: !0
							})
						}, 2e3))
					}, this.onValidateSubredditName = () => this.props.validateSubredditName(this.state.name), this.onCloseModal = () => {
						this.props.sendEvent(Object(T.b)()), this.props.onCloseModal()
					}, this.onCancelCreation = () => {
						this.props.onCloseModal(), this.props.sendEvent(Object(T.b)())
					}, this.onUpdateOver18 = () => this.update(!this.state.over18, "over18"), this.state = {
						name: "",
						type: D.g.Public,
						crosspostId: e.crosspostId,
						over18: !1,
						waitingForSuccessfulCommunity: !1,
						restrictCommenting: !1,
						restrictPosting: !0,
						showEmailInviteModal: !1
					}
				}
				componentDidMount() {
					const {
						sendEvent: e
					} = this.props;
					e(Object(w.x)())
				}
				componentWillUnmount() {
					clearTimeout(this.timeout), this.props.clearErrors()
				}
				render() {
					const {
						error: e,
						isCreatePending: t,
						isEmailInviteExperimentEnabled: n,
						isEmployee: r,
						onHideTooltip: i,
						onShowTooltip: a,
						sendEvent: d,
						userDoesNotHaveEnoughExpToCreateCommunity: l,
						userIsSuspended: u
					} = this.props, m = W(e, this.state.name), {
						over18: b,
						showEmailInviteModal: h,
						waitingForSuccessfulCommunity: _
					} = this.state;
					return o.a.createElement(v, {
						className: z.a.subredditCreation
					}, o.a.createElement("div", {
						className: z.a.container
					}, o.a.createElement("h1", {
						className: z.a.title
					}, s.fbt._("Create a community", null, {
						hk: "SlFa7"
					}), o.a.createElement(se, {
						onClick: this.onCloseModal
					})), l ? o.a.createElement("h2", {
						className: z.a.sublabel
					}, s.fbt._("To prevent spam, accounts must be at least 30 days old and have enough positive karma to create communities.", null, {
						hk: "44qhJp"
					})) : u ? o.a.createElement("h2", {
						className: z.a.sublabel
					}, s.fbt._("Accounts banned from the site can not create communities until the ban is lifted.", null, {
						hk: "3trJMZ"
					})) : o.a.createElement(o.a.Fragment, null, o.a.createElement(f.e, {
						isCreateCommunity: !0,
						label: s.fbt._("Name", null, {
							hk: "3OIzgl"
						}),
						textContainerClassName: z.a.fullWidthTextContainer,
						onBlur: this.onValidateSubredditName,
						onChange: this.onNameChange,
						maxChars: Q,
						value: this.state.name,
						subtext: o.a.createElement("span", {
							className: z.a.subtextContainer
						}, s.fbt._("Community names including capitalization cannot be changed.", null, {
							hk: "VjrZg"
						}), o.a.createElement("span", {
							id: Y,
							onMouseEnter: a,
							onMouseLeave: i,
							className: z.a.info
						}, o.a.createElement(J, null), o.a.createElement(Z, {
							className: z.a.StyledTooltip,
							caretOnTop: !0,
							tooltipId: Y,
							text: s.fbt._('Names cannot have spaces (e.g., "r/bookclub" not "r/book club"), must be between 3-21 characters, and underscores ("_") are the only special characters allowed. Avoid using solely trademarked names (e.g., "r/FansOfAcme" not "r/Acme").', null, {
								hk: "3RsycS"
							})
						})))
					}), m.name && o.a.createElement(re, null, m.name), o.a.createElement(f.l, {
						label: s.fbt._("Community type", null, {
							hk: "152EhZ"
						}),
						direction: "column",
						isCreateCommunity: !0,
						textContainerClassName: z.a.fullWidthTextContainer
					}, o.a.createElement(j.a, {
						value: this.state.type,
						name: "type",
						onChange: this.onTypeChange
					}, ae(r, "post"))), o.a.createElement("div", {
						className: Object(c.a)(z.a.field, {
							[z.a.isCreatePending]: t
						})
					}, o.a.createElement("div", {
						className: z.a.subtitle
					}, s.fbt._("Adult content", null, {
						hk: "20arB"
					})), o.a.createElement(y.a, {
						name: "over18",
						value: b,
						onChange: this.onUpdateOver18,
						disabled: t
					}, o.a.createElement("div", {
						className: z.a.nsfw
					}, "NSFW"), o.a.createElement("div", {
						className: z.a.sublabel
					}, s.fbt._("18+ year old community", null, {
						hk: "1XxZMV"
					})))), n && o.a.createElement("div", {
						className: Object(c.a)(z.a.field, {
							[z.a.isCreatePending]: t
						})
					}, o.a.createElement(I.a, {
						className: z.a.textButton,
						onClick: this.onInviteViaEmailClick
					}, s.fbt._("Invite members via email", null, {
						hk: "2uViIf"
					}))), m.generic && o.a.createElement(re, null, m.generic), _ && o.a.createElement("div", {
						className: z.a.pendingText
					}, s.fbt._("Your community is being created...", null, {
						hk: "3dSTrq"
					})), o.a.createElement("div", {
						className: z.a.buttonContainer
					}, o.a.createElement(E.t, {
						disabled: t,
						className: z.a.createButton,
						onClick: this.onCancelCreation,
						priority: E.c.Secondary
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), o.a.createElement(E.t, {
						disabled: t,
						className: z.a.createButton,
						onClick: this.onCreateCommunityClick
					}, s.fbt._("Create Community", null, {
						hk: "QE8Y3"
					}))))), h && o.a.createElement(p.a, {
						onClose: this.onCloseInviteViaEmailModal,
						sendEvent: d
					}))
				}
			}
			t.default = Object(d.a)(Object(x.c)(ie(de)))
		},
		"./src/reddit/components/SubredditForkingCTA/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			})), n.d(t, "a", (function() {
				return S
			}));
			var s = n("./node_modules/core-js/modules/web.dom.iterable.js"),
				r = n.n(s),
				o = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				i = n("./node_modules/react/index.js"),
				a = n.n(i),
				d = n("./node_modules/react-redux/es/index.js"),
				c = n("./src/reddit/constants/comments.ts"),
				l = n("./src/reddit/models/Subreddit/index.ts"),
				u = n("./src/reddit/selectors/comments.ts"),
				m = n("./src/reddit/selectors/posts.ts"),
				p = n("./src/reddit/selectors/user.ts"),
				b = n("./node_modules/reselect/es/index.js"),
				f = n("./src/lib/cache/index.ts"),
				h = n("./src/lib/makeCommentsPageKey/index.ts"),
				_ = n("./src/reddit/helpers/trackers/subredditForking.ts"),
				g = n("./src/reddit/components/TrackingHelper/index.tsx");
			const v = Object(o.a)({
					resolved: {},
					chunkName: () => "SubredditForkingCTA",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("Governance~Reddit~SubredditForkingCTA"), n.e("SubredditForkingCTA")]).then(n.bind(null, "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditForkingCTA/SubredditForkingCTA.tsx"
					}
				}),
				x = [{
					low: 0,
					high: 1e5,
					threshold: 100
				}, {
					low: 1e5,
					high: 3e5,
					threshold: 200
				}, {
					low: 3e5,
					high: 8e5,
					threshold: 300
				}, {
					low: 8e5,
					high: 1 / 0,
					threshold: 500
				}],
				O = "subreddit-forking.dismissals",
				E = (e, t) => {
					const n = Object(p.l)(e),
						s = Object(h.a)(t.postId),
						r = Object(m.G)(e, t),
						o = Object(u.o)(e, {
							...t,
							commentsPageKey: s
						}),
						i = Object(u.k)(e, {
							...t,
							commentsPageKey: s
						}).reduce((t, n) => {
							var s;
							const r = Object(u.l)(e, {
								commentLink: n
							});
							return n.type !== c.a.Comment && 0 !== (null === (s = o[n.id]) || void 0 === s ? void 0 : s.depth) || t.push(r), t
						}, []).sort((e, t) => t.score - e.score).slice(0, 5);
					return (null == n ? void 0 : n.id) === r.authorId || !!i.find(e => e.authorId === (null == n ? void 0 : n.id))
				},
				y = e => {
					let t = Object(f.b)(O);
					const n = Object.entries(t || {});
					n.length >= 99 && (t = n.sort((e, t) => {
						let [, n] = e, [, s] = t;
						return s - n
					}).splice(0, 99).reduce((e, t) => {
						let [n, s] = t;
						return e[n] = s, e
					}, {})), Object(f.d)(O, {
						...t,
						[e]: Date.now()
					}, Date.now() + 2592e3)
				},
				C = (e, t) => {
					var n;
					if (!Object(p.R)(e)) return !1;
					if (null === (n = Object(f.b)(O)) || void 0 === n ? void 0 : n[t.postId]) return !1;
					const s = Object(m.G)(e, t),
						r = Object(m.V)(e, {
							...t,
							disallowProfile: !0
						});
					if ((null == r ? void 0 : r.type) !== l.g.Public || r.isNSFW || r.isQuarantined || (null == s ? void 0 : s.isNSFW) || (null == s ? void 0 : s.source)) return !1;
					const o = x.find(e => {
						let {
							low: t,
							high: n
						} = e;
						return n >= r.subscribers && r.subscribers > t
					});
					return !(!o || !s.numComments || o.threshold > s.numComments) && !!E(e, t)
				},
				j = () => Object(b.c)({
					shouldLoadCTA: C
				}),
				k = Object(d.b)(j),
				I = e => {
					let {
						shouldLoadCTA: t,
						postId: n,
						sendEvent: s
					} = e;
					const [r, o] = Object(i.useState)(!1);
					return r || !t ? null : a.a.createElement(v, {
						onClose: () => {
							y(n), o(!0), s(Object(_.b)(n))
						},
						postId: n
					})
				},
				S = Object(i.memo)(k(Object(g.c)(I)))
		},
		"./src/reddit/components/SubredditIcon/index.m.less": function(e, t, n) {
			e.exports = {
				Image: "_34CfAAowTqdbNDYXz5tBTW",
				image: "_34CfAAowTqdbNDYXz5tBTW",
				UserIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				userIcon: "_3-8BEp7zk8HU_Tq2SjmosX",
				blur: "_2P3jpibqK9Q2k2UJYzBNIy",
				PlanetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				planetIcon: "_2WM2ef3imxyCFqHx0Nx5M4",
				BackupImage: "RK004G8fbNOkGdNLEzm67",
				backupImage: "RK004G8fbNOkGdNLEzm67",
				iconContainer: "_7nyhK_sDI_8i22XNdcMzb",
				editableIcon: "_1AxWRIyg1lV9-r_CmqYj0o",
				flexContainer: "-Mpi2pdgifDBOdpUYX2vh",
				clickableUploadText: "_3H6u2CWhsluIPVF14GpEaA",
				inTopBar: "_1UpdjN7u66BU606z97t4HS",
				emptyUploadButton: "ndkYE2hc8Y-V3NHpSYvxA",
				transition: "_1iA7YdCRjbU9Rd_2VNGvsw",
				emptyEditableIcon: "_1h9JeZaSDxkh67Ns3QVUP2",
				emptyPlusButton: "Dh1qxsy_tIctL9f4LEzv9",
				imageUploader: "JBITiVY1zX1mMDq-sHkru",
				loadingIcon: "_3Dk8QRKhQImYqds2lSF6G4",
				loadingIconInTopBar: "_1U3KLnHX2TdXL5lNrrv4EW",
				emptyEditableIconInTopBar: "_3-i_fdY8zqHIo3CjuVzTYE",
				defaultCommunityIcon: "_1xvdfUtOPDANqHjxzxKX5b",
				mNightmode: "_1TI6C7sqGL9TRdsq1jRks",
				iconLink: "_35ahToY-XcU6llULyYdy2A"
			}
		},
		"./src/reddit/components/SubredditIcon/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return y
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/lessComponent.tsx"),
				l = n("./src/reddit/components/UserIcon/index.tsx"),
				u = n("./src/reddit/constants/colors.ts"),
				m = n("./src/reddit/contexts/PageLayer/index.tsx"),
				p = n("./src/reddit/helpers/getSubredditOrProfileIconData/index.tsx"),
				b = n("./src/reddit/icons/fonts/index.tsx"),
				f = n("./src/reddit/models/Subreddit/index.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/reddit/components/SubredditIcon/index.m.less"),
				g = n.n(_);

			function v() {
				return (v = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const x = c.a.wrapped(l.a, "UserIcon", g.a),
				O = c.a.img("Image", g.a),
				E = e => {
					let {
						iconColor: t,
						...n
					} = e;
					return i.a.createElement(O, v({
						style: {
							backgroundColor: t || ""
						}
					}, n))
				},
				y = c.a.div("BackupImage", g.a),
				C = Object(m.v)();
			t.b = C(e => {
				var t;
				const n = Object(a.e)(h.eb);
				let o, c, l;
				if (e.subredditOrProfile) {
					const {
						url: t,
						color: n
					} = Object(p.a)({
						shouldHideNsfwIcon: !!e.shouldHideNsfwIcon,
						subredditOrProfile: e.subredditOrProfile
					});
					Object(f.i)(e.subredditOrProfile) ? l = i.a.createElement(x, {
						className: e.className,
						iconUrl: t,
						isNSFW: e.subredditOrProfile.isNSFW,
						userName: e.subredditOrProfile.name
					}) : (o = t, c = n)
				} else o = e.shouldHideNsfwIcon ? `${s.a.assetPath}/img/avatar_over18.png` : e.iconUrl, c = e.primaryColor || u.a.alienblue;
				return o ? l = i.a.createElement(E, {
					alt: r.fbt._("Subreddit Icon", null, {
						hk: "134aM1"
					}),
					className: Object(d.a)(e.className, {
						[g.a.blur]: e.shouldBlurSubredditIcon
					}),
					iconColor: c,
					role: "presentation",
					src: o
				}) : l || (l = i.a.createElement(b.a, {
					name: "community",
					isFilled: !n,
					className: Object(d.a)(g.a.defaultCommunityIcon, e.className, {
						[g.a.mNightmode]: n,
						[g.a.blur]: e.shouldBlurSubredditIcon
					}),
					style: n ? {
						backgroundColor: e.redditStyle ? u.a.alienblue : c
					} : {
						color: e.redditStyle ? u.a.alienblue : c
					}
				})), e.linkTo ? i.a.createElement("a", v({}, null !== (t = e.linkProps) && void 0 !== t ? t : {}, {
					href: e.linkTo,
					className: g.a.iconLink
				}), l) : i.a.createElement(i.a.Fragment, null, l)
			})
		},
		"./src/reddit/components/SubredditModerationSearch/index.m.less": function(e, t, n) {
			e.exports = {
				SearchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				searchIcon: "_2LL7WLn2-4Pv8zCUsmDPv9",
				NoResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				noResultsContainer: "_38zxhEjlOjKTVFYaSwtDTL",
				Container: "_3RNapyf_4ZQOEfoJhVRMEO",
				container: "_3RNapyf_4ZQOEfoJhVRMEO",
				SearchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				searchStatusBar: "_3yWFGY3HrViWVFFUCsTUjv",
				SearchStatus: "uTK2QKUebu8hg0gYZWTI7",
				searchStatus: "uTK2QKUebu8hg0gYZWTI7",
				Bold: "_2u65S50DJfsU-z8bR0G2DQ",
				bold: "_2u65S50DJfsU-z8bR0G2DQ"
			}
		},
		"./src/reddit/components/SubredditModerationSearch/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				d = n("./src/reddit/controls/Button/index.tsx"),
				c = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				l = n("./src/reddit/layout/row/Inline/index.tsx"),
				u = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				m = n("./src/reddit/icons/svgs/Search/index.tsx"),
				p = n("./src/reddit/components/SubredditModerationSearch/index.m.less"),
				b = n.n(p);
			const f = i.a.wrapped(m.a, "SearchIcon", b.a),
				h = i.a.wrapped(a.a, "NoResultsContainer", b.a),
				_ = i.a.div("Container", b.a),
				g = i.a.wrapped(l.a, "SearchStatusBar", b.a),
				v = i.a.div("SearchStatus", b.a),
				x = i.a.span("Bold", b.a);

			function O(e) {
				if (e.searchPending) return null;
				const t = Object(c.a)(e.searchTerm);
				return e.noResultsFound ? o.a.createElement(h, null, o.a.createElement(f, null), o.a.createElement(a.b, null, s.fbt._("No results for {searchTerm}", [s.fbt._param("searchTerm", `u/${t}`)], {
					hk: "1nDAlG"
				})), o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				}))) : o.a.createElement(_, null, o.a.createElement(g, null, o.a.createElement(v, null, s.fbt._("1 search result for {=[searchTerm]}", [s.fbt._param("=[searchTerm]", o.a.createElement(x, {
					"data-redditstyle": !0
				}, s.fbt._("{searchTerm}", [s.fbt._param("searchTerm", `'${t}':`)], {
					hk: "1B9ZWG"
				})))], {
					hk: "iAcV5"
				})), o.a.createElement(u.a, null, o.a.createElement(d.r, {
					onClick: e.cancelSearch
				}, s.fbt._("See all", null, {
					hk: "3aLS8s"
				})))), e.children)
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.m.less": function(e, t, n) {
			e.exports = {
				topBarRow: "_3H6HwkSZ2zUC1pwaIMv-EY",
				searchBar: "_2LvB93iPopVPdhNBxBnfAH",
				searchIcon: "_1lo1uHsqx3-EkgYDL4xKEB",
				searchInput: "_1ox94KT4YX0mmZgLO51PG_",
				searchButton: "_3-3xbjG4pcuzlB7SzgBvzg"
			}
		},
		"./src/reddit/components/SubredditModerationTopBar/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/helpers/normalizeUsername/index.tsx"),
				d = n("./src/reddit/icons/svgs/Search/index.tsx"),
				c = n("./src/reddit/components/SubredditModerationTopBar/index.m.less"),
				l = n.n(c);
			const u = i.a.div("topBarRow", l.a);
			class m extends o.a.Component {
				constructor(e) {
					super(e), this.onSearchChange = e => {
						Object(a.a)(e.currentTarget.value).length < 21 && this.setState({
							searchInputText: e.currentTarget.value
						})
					}, this.onKeyPress = e => {
						"Enter" === e.key && this.onSearch()
					}, this.onSearch = () => {
						this.props.onSearch(this.state.searchInputText)
					}, this.state = {
						searchInputText: ""
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					this.props.activeSearchQuery && null === e.activeSearchQuery && this.setState({
						searchInputText: ""
					})
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return o.a.createElement("div", {
						className: l.a.topBarRow
					}, e.positionSearchRight && e.children, o.a.createElement("div", {
						className: l.a.searchBar
					}, o.a.createElement("input", {
						className: l.a.searchInput,
						onChange: this.onSearchChange,
						onKeyPress: this.onKeyPress,
						placeholder: s.fbt._("Search for a user", null, {
							hk: "1yTo6e"
						}),
						type: "text",
						value: t.searchInputText
					}), o.a.createElement("button", {
						className: l.a.searchButton,
						onClick: this.onSearch
					}, o.a.createElement(d.a, {
						className: l.a.searchIcon
					}))), !e.positionSearchRight && e.children)
				}
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.m.less": function(e, t, n) {
			e.exports = {
				Row: "_2O5kmPXewMHlCcrRWrjEB_",
				row: "_2O5kmPXewMHlCcrRWrjEB_",
				Username: "_1sIhmckJjyRyuR_z7M5kbI",
				username: "_1sIhmckJjyRyuR_z7M5kbI",
				RightAlign: "_3f00u5KR-M4rdaonscLX8k",
				rightAlign: "_3f00u5KR-M4rdaonscLX8k",
				Description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				description: "_3YjnH6nyw9xU3dQ5hTVmEg",
				AdditionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				additionalText: "_2FHMhpmaJ7uKirIBSL-nfq",
				ChevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				chevronDown: "_13LaWwDlCX3ERr0EUCo3Lx",
				ChevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				chevronUp: "_2wUaFuEtiqP0eWtfI9dDoI",
				ExpandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				expandoContainer: "_2AQcG05ynImXmYdd8D8PMU",
				Bullet: "_1VQtDRh-JtZQghS8jetaHR",
				bullet: "_1VQtDRh-JtZQghS8jetaHR",
				PlaceholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				placeholderItem: "_3KdpSC_L0JbYqsU7OmeaGX",
				EmptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				emptyUserIcon: "iNRbW9Tpfe2qsnXftvupu",
				EmptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				emptyDetails: "_16EL0HBUzdiC9vh2S9H5Ee",
				UsersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg",
				usersLoadingContainer: "_1s6c6XYRhTyY6FWEkJHQg"
			}
		},
		"./src/reddit/components/SubredditModerationUserItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return A
			}));
			var s = n("./node_modules/lodash/times.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/lessComponent.tsx"),
				d = n("./src/reddit/components/TrackingHelper/index.tsx"),
				c = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				l = n("./src/reddit/components/IdentityAndIcon/index.tsx"),
				u = n("./src/reddit/controls/Button/index.tsx"),
				m = n("./src/reddit/icons/svgs/ChevronDown/index.tsx"),
				p = n("./src/reddit/icons/svgs/ChevronUp/index.tsx"),
				b = n("./src/reddit/layout/row/Inline/index.tsx"),
				f = n("./src/reddit/layout/row/RightAlign/index.tsx"),
				h = n("./src/reddit/components/SubredditModerationUserItem/index.m.less"),
				_ = n.n(h);
			const {
				fbt: g
			} = n("./node_modules/fbt/lib/FbtPublic.js"), v = (e, t) => {
				const n = `UserInfoTooltip--${e}`;
				return t ? `${n}--${t}` : n
			}, x = a.a.wrapped(b.a, "Row", _.a), O = a.a.div("Username", _.a), E = a.a.wrapped(f.a, "RightAlign", _.a), y = a.a.div("Description", _.a), C = a.a.div("AdditionalText", _.a), j = a.a.wrapped(m.a, "ChevronDown", _.a), k = a.a.wrapped(p.a, "ChevronUp", _.a), I = a.a.div("ExpandoContainer", _.a), S = a.a.span("Bullet", _.a), w = a.a.div("PlaceholderItem", _.a), T = a.a.wrapped(w, "EmptyUserIcon", _.a), N = a.a.wrapped(w, "EmptyDetails", _.a), P = a.a.div("UsersLoadingContainer", _.a), R = () => i.a.createElement(x, null, i.a.createElement(T, null), i.a.createElement(N, null), i.a.createElement(N, null)), A = e => i.a.createElement(P, {
				className: e.className
			}, r()(e.rows || 10, e => i.a.createElement(R, {
				key: e
			})));
			class M extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleExpandedComponent = () => {
						this.props.pageName && !this.state.isExpanded && this.props.sendEvent(c.a("more_detail", this.props.pageName)), this.setState({
							isExpanded: !this.state.isExpanded
						})
					}, this.sendHoverCardEvent = () => {
						this.props.pageName && this.props.sendEvent(c.c(this.props.pageName))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return i.a.createElement(i.a.Fragment, null, i.a.createElement(x, null, i.a.createElement(O, null, i.a.createElement(l.a, {
						username: e.username,
						userIcon: e.userIcon,
						tooltipId: v(e.username, e.moderatorType),
						subredditId: e.subredditId,
						sendHoverCardEvent: this.sendHoverCardEvent
					})), i.a.createElement(y, null, e.timeAgo, e.description && i.a.createElement(i.a.Fragment, null, i.a.createElement(S, null, "•"), e.description)), i.a.createElement(E, null, e.additionalText && i.a.createElement(C, null, e.additionalText), e.primaryButton, e.secondaryButton, e.tertiaryButton, e.expandedComponent && i.a.createElement(u.r, {
						onClick: this.onToggleExpandedComponent
					}, g._("More Details", null, {
						hk: "KnMc6"
					}), t.isExpanded ? i.a.createElement(k, null) : i.a.createElement(j, null)))), t.isExpanded && i.a.createElement(I, null, e.expandedComponent))
				}
			}
			t.b = Object(d.c)(M)
		},
		"./src/reddit/components/SubredditNameLink/index.m.less": function(e, t, n) {
			e.exports = {
				SubredditName: "_3ryJoIoycVkA88fy40qNJc",
				subredditName: "_3ryJoIoycVkA88fy40qNJc"
			}
		},
		"./src/reddit/components/SubredditNameLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				r = n("./src/reddit/components/SubredditNameLink/index.m.less"),
				o = n.n(r);
			const i = n("./src/lib/lessComponent.tsx").a.wrapped(s.a, "SubredditName", o.a);
			t.a = i
		},
		"./src/reddit/components/SubredditRules/index.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_1fQ3jmS7djNiAnk2kVsPko",
				titleFontH2: "_39dtESYDu10VI6hZlt8jT_",
				titleFontH3: "_2_Ya84laiZ_AK4zBLZeXmE",
				titleFontH4: "_2k9S2SK_mdrMw9dXzIJka3",
				titleFontH5: "_3hrj37O_iGAZk7ssKstspL",
				titleFontH6: "_2KYRCY7gyTJjBx_Vr5pjqd",
				metadataFont: "_2hHNLn3quM7R0Znfoal7Wi",
				flairFont: "KkD9-eQEXAm_GdJAbixZ5",
				labelsFont: "_1xgXWixwTrYRf6JjxPm7ft",
				actionFont: "_1HQtdMEzh4gag8do4e9j7Z",
				smallButtonFont: "zWcRyj2-0oiXHbpM-5L1A",
				largeButtonFont: "_2PIOcp6QTxVygtl2u9ji_a",
				strongTextFont: "_2adE8ldKa4w_dETRAs-vdP",
				tabFont: "UtQUA6_scmmMeiLaweTg2",
				buttonFontXS: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontXs: "_10ruUMhuBmxZqA1yF_MlA9",
				buttonFontS: "_1TFRBw_YwgrsDelv1Pi-SM",
				buttonFontM: "_2H_oQnXKALaCioWB1K9l-O",
				buttonFontL: "_2gy3VLIz6UYY1qlR5-fcVm",
				buttonFontXL: "_1drcPUSEFqtlwYnTDdJsro",
				buttonFontXl: "_1drcPUSEFqtlwYnTDdJsro",
				bodyFontH1: "_3lbK38dxFajKo78JrAEtIe",
				bodyFontH2: "_1CH0HVqZd3qMaT2gzU5mYn",
				bodyFontH3: "xk7ESbG2cmLPdln3D1fVi",
				bodyFontH4: "_29_oVfDyKoOggix5Gj6kah",
				bodyFontH5: "_1RoE8VrwOjvkyDDc-a8RZ_",
				bodyFontH6: "_3jwZ9V_jg7YZ4T-0cmGzxY",
				bodyFontH6Small: "_3WMZAYheSFIrrjKgM6FOG1",
				bodyFont: "_2iji_FM7kTNPRlaRGrPpq8",
				bodyFontSmall: "oJpqQ5hwA0NwwwlDu-EZH",
				bodyFontMono: "_2nUMbdZlQ1fQpJ_LaDNrbn",
				landingPageTitleFontH1: "_2cEdGJGz8oV3sN_gTRGtCx",
				landingPageTitleFontH2: "_3suYS5xyzArxtj-MdsUF-5",
				landingPageTitleFontH3: "_1rB8J25cUM1_ndaSDpWLAC",
				duplicateName: "_31Visb7b2S-tj09Ls_2Acy",
				emptyDetails: "_8PDfWWfcYPlmlmOr2Notr",
				emptyIcon: "_2tEWDkQudqJGiBAQsXSYXE",
				emptyRightIcon: "aF9GyLBXjDrRFO_7BTOYU",
				expandDetails: "_19etb4qzR1xpaHDy7AVdRr",
				header: "_2Xb_1g-T9iGzHDDy3_XpMD",
				DragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragCard: "_1KNUx1QX0DDrtynCc-GRE_",
				dragIcon: "RR4AdUs4L9geua2bjCoqQ",
				icon: "PbUpiwMGWTjzrcYfCTdc0",
				iconButton: "_138C3cC0PAtIwsXoIAfGvJ",
				iconWrapper: "Ep3vJhfng2q2-wfiIgstP",
				loadingContainer: "ve35wYJQyEHavtRQYDY7V",
				metadata: "_1xQ_DrqnJXDZq1ptXHxYIB",
				middleMeta: "_2OWUxJA0Dhi0onvygJk3_i",
				middleMetaBlock: "n1lY8o9sGnqcqSfVzm5Vs",
				modalCloseButton: "zKQ8lyAF3pYyDoSlTpTjA",
				modalDescriptionBlock: "_26a81Mk5bsppGjI9AXbmWS",
				modalDescriptionField: "_1brIoxFWlohWpvu34OwZQP",
				modalFooter: "R-9ebJbU9igzPDfUi4Txg",
				modalRadioButton: "_1KFGHoJGHbU05yh6-sQIr5",
				modalRadioText: "_360Lh4DKj256s8RdElARFo",
				modalReasonField: "_1hdSGf--gQDRwsU96bzao1",
				modalRemoveButton: "_2yAePObDkhgZql3P1FHRu1",
				modalReportMeta: "_21sqmEi4OnC4uXlcUGDT_T",
				modalReportTitle: "_1y0X9006mE_5nlHfol1nc2",
				modalRule: "_1AlCnggMuPLxxDUbWWhG2q",
				modalRuleField: "QP-_TXfrh6G1-IRJif4Cy",
				modalRuleTitle: "_2I1A_fyvhaC7TYrYwA047Y",
				modalSubmitButton: "hHFW3BkgX7tSn5Nev-ooY",
				placeholderRow: "hv6YY1IfCww5loDzbkuMS",
				row: "_1LfPdWXylWmVTmLinhd4xl",
				rulesHeader: "_3MOq7UPqtI4o9EnAyCWkEQ",
				rulesIcon: "_29Fl8s_IvZwHxUPNV2ARiW",
				rulesInfo: "KTZ0Ir6xknUXuN4WMI7RN",
				ruleMetaText: "iVYauV_t6_ChREoxhNGsU",
				ruleMetaTitle: "ffGjaCMPoTUkhkVp6rHw5",
				emptyWrapper: "_2-xwKK1EqJlzI2dO7SIrbF",
				ruleNumber: "_3DEhjnxmn1BzXcJ_ml7kSQ",
				ruleText: "_1ZwBW5sLL75ZAZvQreMjn-",
				PrimaryButton: "_3GOmWOjCh6hPWZg1j-zPkr",
				primaryButton: "_3GOmWOjCh6hPWZg1j-zPkr"
			}
		},
		"./src/reddit/components/SubredditRules/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/config.ts"),
				o = n("./node_modules/lodash/isEqual.js"),
				i = n.n(o),
				a = n("./node_modules/lodash/times.js"),
				d = n.n(a),
				c = n("./node_modules/react/index.js"),
				l = n.n(c),
				u = n("./node_modules/react-redux/es/index.js"),
				m = n("./node_modules/reselect/es/index.js"),
				p = n("./src/lib/lessComponent.tsx"),
				b = n("./src/reddit/actions/modal.ts"),
				f = n("./src/lib/makeActionCreator/index.ts"),
				h = n("./src/reddit/actions/subredditRules/constants.ts"),
				_ = n("./src/reddit/actions/toaster.ts"),
				g = n("./src/reddit/endpoints/subreddit/rules.ts"),
				v = n("./src/reddit/models/Toast/index.ts"),
				x = n("./src/reddit/selectors/subreddit.ts");
			const O = Object(f.a)(h.e),
				E = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = Object(x.Y)(r(), {
							subredditId: e
						}).name,
						d = `success-block-${t.rule}`,
						c = `error-block-${t.rule}`,
						l = await Object(g.a)(i(), a, t);
					if (l.ok) {
						const t = l.body;
						n(O({
							rules: t,
							subredditId: e
						})), n(_.f({
							id: d,
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Rule added", null, {
								hk: "4D4jbP"
							})
						}))
					} else n(_.f({
						id: c,
						kind: v.b.Error,
						text: l.json.errors ? l.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "2C9b4N"
						})
					}))
				}, y = Object(f.a)(h.f), C = Object(f.a)(h.g), j = Object(f.a)(h.d), k = (e, t) => async (n, r, o) => {
					let {
						apiContext: i
					} = o;
					const a = Object(x.Y)(r(), {
							subredditId: e
						}).name,
						d = Object(x.U)(r(), {
							subredditId: e
						}),
						c = `success-block-${e}`,
						l = `error-block-${e}`,
						u = await Object(g.e)(i(), a, t);
					if (u.ok) {
						const t = u.body;
						n(j({
							rules: t,
							subredditId: e
						})), n(_.f({
							id: c,
							kind: v.b.SuccessCommunityGreen,
							text: s.fbt._("Rule order updated", null, {
								hk: "3bmmvl"
							}),
							buttonText: s.fbt._("Undo", null, {
								hk: "1RYWKC"
							}),
							buttonAction: k(e, d)
						}))
					} else n(_.f({
						id: l,
						kind: v.b.Error,
						text: "explanation" in u ? u.explanation : u.json && "errors" in u.json ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
							hk: "1XJ2UQ"
						})
					}))
				};
			var I = n("./src/reddit/components/ConfirmUserActionModal/index.tsx"),
				S = n("./src/reddit/components/ModerationPagesEmptyList/index.tsx"),
				w = n("./src/reddit/components/ModHub/InfoLink/index.tsx"),
				T = n("./src/reddit/components/ModHub/StyledComponents/index.tsx"),
				N = n("./src/reddit/components/TrackingHelper/index.tsx"),
				P = n("./src/reddit/controls/Button/index.tsx"),
				R = n("./src/reddit/controls/Sortable/index.tsx"),
				A = n("./src/reddit/selectors/telemetry.ts");
			const M = e => ({
					subreddit: A.kb(e),
					profile: A.T(e),
					userSubreddit: A.ub(e)
				}),
				L = e => t => ({
					source: "rules",
					action: "click",
					noun: e,
					...M(t)
				}),
				D = (e, t) => n => ({
					source: "rules",
					action: "click",
					noun: e,
					actionInfo: A.d(n, {
						count: t
					}),
					...M(n)
				});
			var F = n("./src/reddit/icons/fonts/index.tsx"),
				U = n("./src/reddit/layout/row/Inline/index.tsx"),
				B = n("./src/reddit/models/ModeratingSubreddits/index.ts"),
				q = n("./src/reddit/models/Rule/index.ts"),
				G = n("./src/reddit/selectors/activeModalId.ts"),
				H = n("./src/reddit/selectors/moderatorPermissions.ts"),
				W = n("./src/reddit/components/SubredditRules/index.m.less"),
				V = n.n(W),
				z = n("./src/reddit/components/StructuredStyles/StyledComponents/navs.tsx"),
				K = n("./src/reddit/icons/svgs/Grapple/index.tsx");
			const Q = p.a.wrapped(z.a, "DragCard", V.a);
			var Y = e => l.a.createElement(Q, {
					isDragging: e.isDragging,
					isOver: e.isOver,
					canDrop: e.canDrop
				}, l.a.createElement(U.a, {
					className: V.a.row
				}, l.a.createElement("span", {
					className: V.a.ruleNumber
				}, e.index + 1), l.a.createElement("span", {
					className: V.a.ruleText
				}, e.shortName), l.a.createElement("span", {
					className: V.a.iconWrapper
				}, l.a.createElement(K.a, {
					className: V.a.dragIcon,
					title: s.fbt._("Drag", null, {
						hk: "dBKmA"
					})
				})))),
				J = n("./src/higherOrderComponents/asModal/index.tsx"),
				X = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				Z = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				$ = n("./src/reddit/controls/RadioInput/index.tsx"),
				ee = n("./src/reddit/controls/RadioInput/RadioOption/index.tsx"),
				te = n("./src/reddit/controls/TextButton/index.tsx"),
				ne = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx");
			const se = {
					rule: "",
					kind: "all",
					reportReason: "",
					description: ""
				},
				re = Object(u.b)(null, (e, t) => ({
					createRule: n => e(E(t.subredditId, n)),
					updateRule: (n, r) => e(((e, t, n) => async (r, o, i) => {
						let {
							apiContext: a
						} = i;
						const d = Object(x.Y)(o(), {
								subredditId: e
							}).name,
							c = `success-block-${t.rule}`,
							l = `error-block-${t.rule}`,
							u = await Object(g.f)(a(), d, t, n);
						if (u.ok) {
							const t = u.body;
							r(y({
								rules: t,
								subredditId: e,
								oldName: n
							})), r(_.f({
								id: c,
								kind: v.b.SuccessCommunityGreen,
								text: s.fbt._("Rule updated", null, {
									hk: "1ljetO"
								})
							}))
						} else r(_.f({
							id: l,
							kind: v.b.Error,
							text: u.json.errors ? u.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "2acjBM"
							})
						}))
					})(t.subredditId, n, r))
				}));
			class oe extends l.a.Component {
				constructor(e) {
					super(e), this.onRuleInputChange = e => {
						e.currentTarget.value.trim().length <= q.g && this.setState({
							rule: e.currentTarget.value
						})
					}, this.onReportReasonInputChange = e => {
						e.currentTarget.value.trim().length <= q.f && this.setState({
							reportReason: e.currentTarget.value
						})
					}, this.onDescriptionInputChange = e => {
						e.currentTarget.value.trim().length <= q.a && this.setState({
							description: e.currentTarget.value
						})
					}, this.onSave = () => {
						const {
							props: e,
							state: t
						} = this, n = {
							rule: t.rule.trim(),
							kind: t.kind,
							reason: t.reportReason.trim(),
							description: t.description.trim()
						};
						e.rule ? e.updateRule(n, e.rule.shortName) : e.createRule(n), e.toggleModal(), e.sendEvent()
					}, this.canSave = () => {
						const {
							props: e,
							state: t
						} = this, n = t.rule.trim(), s = t.reportReason.trim(), r = t.description.trim(), o = !e.ruleNames.includes(n) || e.ruleNames.includes(n) && e.rule && e.rule.shortName === n, i = !e.rule || (e.rule.shortName !== n || e.rule.violationReason !== t.reportReason || e.rule.kind !== t.kind || e.rule.description !== r);
						return o && i && n.length > 0 && n.length <= q.g && s.length <= q.f && r.length <= q.a && t.kind
					}, this.selectRuleKind = e => {
						this.setState({
							kind: e
						})
					}, this.isDuplicateRuleName = () => {
						const {
							props: e,
							state: t
						} = this, n = !e.rule || e.rule.shortName !== t.rule.trim(), s = e.ruleNames.includes(t.rule.trim());
						return 0 !== t.rule.trim().length && n && s
					}, this.state = e.rule ? {
						rule: e.rule.shortName,
						kind: e.rule.kind,
						reportReason: e.rule.violationReason || "",
						description: e.rule.description || ""
					} : se
				}
				render() {
					const {
						props: e,
						state: t
					} = this;
					return l.a.createElement(Z.e, null, l.a.createElement(Z.i, null, l.a.createElement(ne.a, null, l.a.createElement(Z.q, null, e.rule ? s.fbt._("Edit rule", null, {
						hk: "2zflTO"
					}) : s.fbt._("Add rule", null, {
						hk: "1xqo5O"
					})), l.a.createElement(te.a, {
						className: V.a.modalCloseButton,
						onClick: e.toggleModal
					}, l.a.createElement(Z.b, null)))), l.a.createElement(Z.l, null, l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalRule
					}, s.fbt._("Rule", null, {
						hk: "1W7esG"
					})), l.a.createElement(Z.t, {
						className: V.a.modalRuleField,
						onChange: this.onRuleInputChange,
						placeholder: s.fbt._('Rule displayed (e.g. "No photos")', null, {
							hk: "GdEW"
						}),
						value: t.rule
					}), this.isDuplicateRuleName() && l.a.createElement("span", {
						className: V.a.duplicateName
					}, s.fbt._("You have another rule with this title. Please change.", null, {
						hk: "2EPSGv"
					})), l.a.createElement(X.a, {
						maxChars: q.g,
						text: t.rule.trim()
					})), l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalRuleTitle
					}, s.fbt._("Applies to", null, {
						hk: "Pzu3b"
					})), l.a.createElement($.a, {
						name: "RULE_KIND_PICKER",
						onChange: this.selectRuleKind,
						value: t.kind
					}, l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: q.b.all,
						value: q.b.all,
						selected: t.kind === q.b.all,
						showButton: !0,
						tabIndex: t.kind === q.b.all ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Posts & comments", null, {
						hk: "tHmQq"
					}))), l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: q.b.post,
						value: q.b.post,
						selected: t.kind === q.b.post,
						showButton: !0,
						tabIndex: t.kind === q.b.post ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Posts only", null, {
						hk: "16dDBr"
					}))), l.a.createElement(ee.a, {
						className: V.a.modalRadioButton,
						key: q.b.comment,
						value: q.b.comment,
						selected: t.kind === q.b.comment,
						showButton: !0,
						tabIndex: t.kind === q.b.comment ? 0 : -1
					}, l.a.createElement(Z.p, {
						className: V.a.modalRadioText
					}, s.fbt._("Comments only", null, {
						hk: "2V8qUA"
					}))))), l.a.createElement(Z.h, null, l.a.createElement(Z.p, {
						className: V.a.modalReportTitle
					}, s.fbt._("Report reason", null, {
						hk: "3ShjE9"
					})), l.a.createElement(Z.m, {
						className: V.a.modalReportMeta
					}, s.fbt._("Defaults to rule name if left blank", null, {
						hk: "2xObiU"
					})), l.a.createElement(Z.t, {
						className: V.a.modalReasonField,
						onChange: this.onReportReasonInputChange,
						placeholder: t.rule.trim().length > 0 && 0 === t.reportReason.trim().length ? t.rule : s.fbt._('Reason rule is broken (e.g. "This is a photo")', null, {
							hk: "2Op1SL"
						}),
						value: t.reportReason
					}), l.a.createElement(X.a, {
						maxChars: q.f,
						text: t.reportReason.trim()
					})), l.a.createElement("div", {
						className: V.a.modalDescriptionBlock
					}, l.a.createElement(Z.p, {
						className: V.a.modalRuleTitle
					}, s.fbt._("Full description", null, {
						hk: "4CTvQy"
					})), l.a.createElement(Z.t, {
						className: V.a.modalDescriptionField,
						onChange: this.onDescriptionInputChange,
						placeholder: s.fbt._("Enter the full description of the rule.", null, {
							hk: "3EyaJe"
						}),
						value: t.description
					}), l.a.createElement(X.a, {
						maxChars: q.a,
						text: t.description.trim()
					}))), l.a.createElement(Z.g, {
						className: V.a.modalFooter
					}, l.a.createElement(P.l, {
						className: V.a.modalSubmitButton,
						onClick: this.onSave,
						disabled: !this.canSave()
					}, e.rule ? s.fbt._("Save", null, {
						hk: "4yMsMq"
					}) : s.fbt._("Add new rule", null, {
						hk: "2dy0gV"
					})), l.a.createElement(Z.a, {
						onClick: e.toggleModal
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), e.rule && l.a.createElement(Z.s, {
						className: V.a.modalRemoveButton,
						onClick: e.onDelete
					}, s.fbt._("Delete", null, {
						hk: "4lt26q"
					}))))
				}
			}
			var ie = Object(J.a)(re(oe)),
				ae = n("./src/lib/timeAgo/index.ts"),
				de = n("./src/reddit/components/HumanDate/index.tsx"),
				ce = n("./src/reddit/components/RawHTMLDisplay/index.tsx"),
				le = n("./src/reddit/components/RichTextJson/index.tsx"),
				ue = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx"),
				me = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx"),
				pe = n("./src/reddit/icons/svgs/Pencil/index.tsx"),
				be = n("./src/reddit/models/RichTextJson/index.ts");
			const fe = {};
			class he extends l.a.Component {
				constructor(e) {
					super(e), this.toggleExpandDetails = () => {
						this.setState(e => ({
							isExpanded: !e.isExpanded
						}))
					}, this.state = {
						isExpanded: !1
					}
				}
				render() {
					const {
						hasConfigPerms: e,
						index: t,
						onEdit: n,
						subredditRule: r
					} = this.props, o = r.descriptionRichText ? JSON.parse(r.descriptionRichText).document : void 0, i = Object(ae.c)(r.createdUtc) >= 1;
					return l.a.createElement(l.a.Fragment, null, l.a.createElement(U.a, {
						className: V.a.row
					}, l.a.createElement("span", {
						className: V.a.ruleNumber
					}, t + 1), l.a.createElement("span", {
						className: V.a.ruleText
					}, r.shortName), l.a.createElement("span", {
						className: V.a.iconWrapper
					}, e && l.a.createElement("button", {
						className: V.a.iconButton,
						onClick: n
					}, l.a.createElement(pe.a, {
						className: V.a.icon,
						title: s.fbt._("Edit", null, {
							hk: "1nftDt"
						})
					})), l.a.createElement("button", {
						className: V.a.iconButton,
						onClick: this.toggleExpandDetails
					}, this.state.isExpanded ? l.a.createElement(ue.a, {
						className: V.a.icon,
						title: s.fbt._("Collapse", null, {
							hk: "eGqwd"
						})
					}) : l.a.createElement(me.a, {
						className: V.a.icon,
						title: s.fbt._("Expand", null, {
							hk: "4dMVPg"
						})
					})))), this.state.isExpanded && l.a.createElement(U.a, {
						className: V.a.expandDetails
					}, l.a.createElement("span", {
						className: V.a.metadata
					}, l.a.createElement("span", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Report reason", null, {
						hk: "2RH1DJ"
					})), l.a.createElement("span", {
						className: V.a.ruleMetaText
					}, r.violationReason && 0 !== r.violationReason.length ? r.violationReason : r.shortName)), l.a.createElement("span", {
						className: V.a.middleMeta
					}, l.a.createElement("div", {
						className: V.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Applies to", null, {
						hk: "19eYpy"
					})), l.a.createElement("div", {
						className: V.a.ruleMetaText
					}, r.kind === q.b.all ? s.fbt._("Posts & comments", null, {
						hk: "34PjHx"
					}) : r.kind === q.b.post ? s.fbt._("Posts only", null, {
						hk: "3MllWy"
					}) : s.fbt._("Comments only", null, {
						hk: "StCEa"
					}))), l.a.createElement("div", {
						className: V.a.middleMetaBlock
					}, l.a.createElement("div", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Created", null, {
						hk: "gSE9w"
					})), l.a.createElement("div", {
						className: V.a.ruleMetaText
					}, i ? l.a.createElement(de.b, {
						seconds: r.createdUtc
					}) : l.a.createElement(de.d, {
						seconds: r.createdUtc
					})))), l.a.createElement("span", {
						className: V.a.metadata
					}, l.a.createElement("span", {
						className: V.a.ruleMetaTitle
					}, s.fbt._("Full description", null, {
						hk: "20Lgcg"
					})), l.a.createElement("span", {
						className: V.a.ruleMetaText
					}, o && !Object(be.H)({
						document: o
					}) ? l.a.createElement(le.b, {
						className: V.a.ruleMetaText,
						content: {
							document: o
						},
						rtJsonElementProps: fe
					}) : r.descriptionHtml ? l.a.createElement(ce.a, {
						className: V.a.ruleMetaText,
						html: r.descriptionHtml
					}) : r.description))))
				}
			}
			var _e = he;
			const ge = p.a.wrapped(P.l, "PrimaryButton", V.a),
				ve = () => l.a.createElement(U.a, {
					className: V.a.placeholderRow
				}, l.a.createElement("span", {
					className: V.a.emptyWrapper
				}, l.a.createElement("span", {
					className: V.a.emptyIcon
				})), l.a.createElement("span", {
					className: V.a.emptyDetails
				}), l.a.createElement("span", {
					className: V.a.iconWrapper
				}, l.a.createElement("span", {
					className: V.a.emptyRightIcon
				}), l.a.createElement("span", {
					className: V.a.emptyRightIcon
				}))),
				xe = () => l.a.createElement("div", {
					className: V.a.loadingContainer
				}, d()(15, e => l.a.createElement(ve, {
					key: e
				}))),
				Oe = Object(m.c)({
					hasModConfigPerms: (e, t) => Object(H.b)(B.c.config)(e, {
						subredditId: t.subreddit.id
					}),
					isConfirmModalOpen: e => "SubredditRule--Modal--DeleteConfirmation" === Object(G.a)(e),
					isRuleEditorOpen: e => "SubredditRule--Editor--Modal" === Object(G.a)(e),
					isSubredditRulesPending: e => Object(x.W)(e),
					ruleOrder: (e, t) => Object(x.U)(e, {
						subredditId: t.subreddit.id
					}),
					subredditRules: (e, t) => Object(x.X)(e, {
						subredditId: t.subreddit.id
					})
				}),
				Ee = Object(u.b)(Oe, (e, t) => ({
					removeRule: (n, r) => e(((e, t, n) => async (r, o, i) => {
						let {
							apiContext: a
						} = i;
						const d = Object(x.Y)(o(), {
								subredditId: e
							}).name,
							c = Object(x.X)(o(), {
								subredditId: e
							})[n],
							l = `success-block-${t}`,
							u = `error-block-${t}`,
							m = await Object(g.d)(a(), d, t);
						if (m.ok) {
							const t = m.body;
							r(C({
								rules: t,
								subredditId: e
							})), r(_.f({
								id: l,
								kind: v.b.SuccessCommunityGreen,
								text: s.fbt._("Rule deleted", null, {
									hk: "2Kwoph"
								}),
								buttonText: s.fbt._("Undo", null, {
									hk: "1RYWKC"
								}),
								buttonAction: E(e, {
									rule: c.shortName,
									kind: c.kind,
									reason: c.violationReason,
									description: c.description
								})
							}))
						} else r(_.f({
							id: u,
							kind: v.b.Error,
							text: m.json.errors ? m.json.errors[0][1] : s.fbt._("An error has occured. Please try again later", null, {
								hk: "37ELrZ"
							})
						}))
					})(t.subreddit.id, n, r)),
					reorderRules: n => {
						e(k(t.subreddit.id, n))
					},
					toggleConfirmationModal: () => e(Object(b.i)("SubredditRule--Modal--DeleteConfirmation")),
					toggleRuleEditorModal: () => e(Object(b.i)("SubredditRule--Editor--Modal"))
				}));
			class ye extends l.a.Component {
				constructor(e) {
					super(e), this.deleteRule = () => {
						const e = this.state.ruleToEdit;
						e && this.props.removeRule(e.shortName, e.priority)
					}, this.onConfirmDeleteRule = () => {
						this.props.toggleConfirmationModal()
					}, this.onEditRule = e => {
						this.setState({
							ruleToEdit: e
						}), this.props.toggleRuleEditorModal()
					}, this.handleDrop = (e, t, n) => this.setState({
						ruleOrder: n,
						numRulesMoved: this.state.numRulesMoved + 1
					}), this.reorderRules = () => {
						this.props.reorderRules(this.state.ruleOrder), this.props.sendEvent(D("save_reorder", this.state.numRulesMoved)), this.stopReorder()
					}, this.startReorder = () => {
						this.setState({
							isReordering: !0,
							ruleOrder: this.props.ruleOrder
						})
					}, this.stopReorder = () => this.setState({
						isReordering: !1,
						numRulesMoved: 0
					}), this.toggleConfirmationModal = () => {
						this.props.toggleConfirmationModal(), this.setState({
							ruleToEdit: null
						})
					}, this.toggleEditorModal = () => {
						this.props.toggleRuleEditorModal(), this.setState({
							ruleToEdit: null
						})
					}, this.trackClick = e => this.props.sendEvent(L(e)), this.trackEdit = () => this.state.ruleToEdit ? this.trackClick("save_edit") : this.trackClick("save_new"), this.trackDelete = () => this.trackClick("delete"), this.state = {
						numRulesMoved: 0,
						ruleToEdit: null,
						ruleOrder: e.ruleOrder,
						isReordering: !1
					}
				}
				render() {
					const {
						hasModConfigPerms: e,
						isConfirmModalOpen: t,
						isRuleEditorOpen: n,
						isSubredditRulesPending: o,
						subreddit: a,
						subredditRules: d
					} = this.props;
					return l.a.createElement(l.a.Fragment, null, e && l.a.createElement(T.c, null, this.state.isReordering ? l.a.createElement(P.o, {
						onClick: this.stopReorder
					}, s.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})) : l.a.createElement(P.r, {
						onClick: this.startReorder,
						disabled: d.length <= 1
					}, s.fbt._("Reorder rules", null, {
						hk: "1qh7V6"
					})), this.state.isReordering ? l.a.createElement(ge, {
						onClick: this.reorderRules,
						disabled: i()(d.map(e => e.shortName), this.state.ruleOrder)
					}, s.fbt._("Save", null, {
						hk: "4yMsMq"
					})) : l.a.createElement(ge, {
						onClick: this.toggleEditorModal,
						disabled: o || d.length >= q.e
					}, s.fbt._("Add rule", null, {
						hk: "6GEk0"
					}))), d.length ? l.a.createElement(T.a, null, l.a.createElement("div", {
						className: V.a.header
					}, l.a.createElement(T.b, {
						className: V.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(w.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					})), !this.state.isReordering && l.a.createElement("div", {
						className: V.a.rulesInfo
					}, s.fbt._("These are rules that visitors must follow to participate. They can be used as reasons to report or ban posts, comments, and users. Communities can have a maximum of 15 rules.", null, {
						hk: "1C2Vjc"
					}))), this.state.isReordering ? l.a.createElement(R.a, {
						values: this.state.ruleOrder,
						render: (e, t, n, s, r) => l.a.createElement(Y, {
							isDragging: n,
							isOver: s,
							canDrop: r,
							index: t,
							shortName: e
						}),
						onDrop: this.handleDrop
					}) : d.map((t, n) => l.a.createElement(_e, {
						hasConfigPerms: e,
						index: n,
						key: `${a.name}-${t.shortName}`,
						onEdit: () => this.onEditRule(t),
						subredditRule: t
					}))) : l.a.createElement(T.a, null, l.a.createElement("div", {
						className: V.a.header
					}, l.a.createElement(T.b, {
						className: V.a.rulesHeader
					}, s.fbt._("Rules", null, {
						hk: "41SmPR"
					}), l.a.createElement(w.a, {
						linkUrl: `${r.a.redditModHelpUrl}/hc/en-us/articles/360023379211`
					}))), o ? l.a.createElement(xe, null) : l.a.createElement(S.c, {
						text: s.fbt._("No rules yet", null, {
							hk: "pYLkV"
						})
					}, l.a.createElement(F.a, {
						name: "rules",
						className: V.a.rulesIcon
					}))), n && l.a.createElement(ie, {
						onDelete: this.onConfirmDeleteRule,
						rule: this.state.ruleToEdit,
						ruleNames: d.map(e => e.shortName),
						sendEvent: this.trackEdit,
						subredditId: a.id,
						toggleModal: this.toggleEditorModal,
						withOverlay: !0
					}), t && this.state.ruleToEdit && l.a.createElement(I.a, {
						actionText: s.fbt._("Delete", null, {
							hk: "4lt26q"
						}),
						headerText: s.fbt._("Delete rule", null, {
							hk: "5q2Ri"
						}),
						modalText: s.fbt._("Are you sure you want to delete this rule?", null, {
							hk: "2diD6u"
						}),
						onConfirm: this.deleteRule,
						toggleModal: this.toggleConfirmationModal,
						trackClick: this.trackDelete,
						withOverlay: !0
					}))
				}
			}
			t.a = Ee(Object(N.c)(ye))
		},
		"./src/reddit/components/SubredditSearchCarousel/async.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./src/reddit/selectors/experiments/joinOptimizations.ts");
			const d = Object(s.a)({
					resolved: {},
					chunkName: () => "SubredditSearchCarousel",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => n.e("SubredditSearchCarousel").then(n.bind(null, "./src/reddit/components/SubredditSearchCarousel/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/components/SubredditSearchCarousel/index.tsx"
					}
				}),
				c = e => {
					const t = Object(i.e)(a.e),
						n = Object(i.e)(a.a);
					return t || n ? o.a.createElement(d, e) : null
				}
		},
		"./src/reddit/components/SubscribeButton/Base.m.less": function(e, t, n) {
			e.exports = {
				BaseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				baseButton: "_1LHxa-yaHJwrPK8kuyv_Y4",
				UnsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				unsubscribeButtonDefault: "_31L3r0EWsU0weoMZvEJcUA",
				UnsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW",
				unsubscribeButtonHover: "_11Zy7Yp4S1ZArNqhUQ0jZW"
			}
		},
		"./src/reddit/components/SubscribeButton/Base.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				d = n("./src/reddit/components/SubscribeButton/Base.m.less"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts");

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const m = (e, t, n) => null != n ? n : t ? e : i.c.Plain,
				p = e => {
					let {
						border: t,
						priority: n,
						small: s,
						...r
					} = e;
					return o.a.createElement(i.t, u({}, r, {
						priority: m(i.c.Primary, t, n),
						className: Object(l.a)(r.className, c.a.BaseButton),
						size: s ? i.d.S : i.d.M
					}))
				},
				b = e => o.a.createElement(o.a.Fragment, null, o.a.createElement("span", {
					className: c.a.UnsubscribeButtonDefault
				}, "subreddit" === e ? s.fbt._("Joined", null, {
					hk: "1MTmIz"
				}) : s.fbt._("Following", null, {
					hk: "1wQlVR"
				})), o.a.createElement("span", {
					className: c.a.UnsubscribeButtonHover
				}, "subreddit" === e ? s.fbt._("Leave", null, {
					hk: "2lLnnn"
				}) : s.fbt._("Unfollow", null, {
					hk: "2b5ERD"
				}))),
				f = e => {
					let {
						buttonType: t,
						border: n,
						priority: s,
						small: r,
						...a
					} = e;
					return o.a.createElement(i.t, u({}, a, {
						priority: m(i.c.Secondary, n, s),
						className: Object(l.a)(a.className, c.a.BaseButton),
						size: r ? i.d.S : i.d.M,
						text: b(t)
					}))
				};
			class h extends o.a.Component {
				constructor() {
					super(...arguments), this.onClick = e => {
						if (this.props.userIsSubscriber ? (this.props.onUnsubscribe(), this.props.afterUnsubscribeAction && this.props.afterUnsubscribeAction()) : this.props.onSubscribe(), this.props.onClick && this.props.onClick(e), this.props.getEventFactory) {
							const e = this.props.getEventFactory(this.props.userIsSubscriber);
							e && this.props.sendEvent(e)
						}
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						border: e = !0,
						className: t,
						id: n,
						priority: s,
						small: r = !1,
						isFullWidth: i = !1,
						style: d
					} = this.props, c = {
						border: e,
						className: t,
						onClick: this.onClick,
						priority: s,
						small: r,
						isFullWidth: i,
						style: d
					};
					return this.props.userIsSubscriber ? o.a.createElement(f, u({}, c, {
						buttonType: this.props.identifier.type
					})) : o.a.createElement(p, u({}, c, {
						id: n
					}), this.props.children, Object(a.a)({
						type: this.props.identifier.type,
						key: "subscribe"
					}))
				}
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.m.less": function(e, t, n) {
			e.exports = {
				ButtonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				buttonSpacer: "vXXjS_s-Ic4QZpFsPjThV",
				Checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				checkmark: "_2qm48d8K8lTcwSJiHL9KLT",
				Plus: "_2zcGm9WDxG67GYyNNvHzlA",
				plus: "_2zcGm9WDxG67GYyNNvHzlA"
			}
		},
		"./src/reddit/components/SubscribeButton/Inline.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/components/TrackingHelper/index.tsx"),
				i = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				a = n("./src/reddit/controls/Button/index.tsx"),
				d = n("./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts"),
				c = n("./src/reddit/components/SubscribeButton/Inline.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const m = n("./src/lib/lessComponent.tsx").a.div("ButtonSpacer", l.a);
			class p extends r.a.Component {
				constructor(e) {
					super(e), this.onMouseEnter = () => {
						this.setState({
							isHovered: !0
						})
					}, this.onMouseLeave = () => {
						this.setState({
							isHovered: !1
						})
					}, this.onClick = e => {
						const {
							props: t
						} = this;
						if (t.userIsSubscriber ? t.onUnsubscribe() : (this.setState({
								hasJustSubscribed: !0
							}), t.onSubscribe()), t.onClick && t.onClick(e), t.getEventFactory) {
							const e = t.getEventFactory(t.userIsSubscriber);
							e && t.sendEvent(e)
						}
					}, this.renderUnsubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: s,
							postId: o,
							sendEvent: i,
							size: c,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: b,
							...f
						} = this.props, h = this.state.isHovered, _ = Object(d.a)({
							type: t.type,
							key: h ? "unsubscribe" : "subscribed"
						});
						return r.a.createElement(a.t, u({
							className: e,
							priority: f.shouldReverseColor ? a.c.Primary : a.c.Secondary,
							text: _,
							onClick: this.onClick,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave,
							size: a.d.XSP
						}, f))
					}, this.renderSubscribeButton = () => {
						const {
							className: e,
							identifier: t,
							onSubscribe: n,
							onUnsubscribe: s,
							postId: o,
							sendEvent: i,
							size: c,
							userIsSubscriber: l,
							doNotHideOtherSubscribeButtons: m,
							getEventFactory: p,
							onSubscriptionsRequested: b,
							...f
						} = this.props, h = Object(d.a)({
							type: t.type,
							key: "subscribe"
						});
						return r.a.createElement(a.t, u({
							className: e,
							priority: f.shouldReverseColor ? a.c.Secondary : a.c.Primary,
							size: a.d.XSP,
							text: h,
							onClick: this.onClick
						}, f, {
							id: `subscribe-button-${o}`,
							onMouseEnter: this.onMouseEnter,
							onMouseLeave: this.onMouseLeave
						}))
					}, this.state = {
						hasJustSubscribed: !1,
						isHovered: !1
					}
				}
				componentDidMount() {
					this.props.onSubscriptionsRequested()
				}
				render() {
					const {
						small: e = !1,
						userIsSubscriber: t,
						doNotHideOtherSubscribeButtons: n
					} = this.props;
					return t ? this.state.hasJustSubscribed || n ? this.renderUnsubscribeButton() : e ? null : r.a.createElement(m, null) : this.renderSubscribeButton()
				}
			}
			t.a = Object(i.a)(Object(o.c)(p))
		},
		"./src/reddit/components/SubscribeButton/helpers/actionTemplateSource.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			const r = e => {
					let {
						type: t
					} = e;
					return "subreddit" === t ? "subredditActions" : "profileActions"
				},
				o = {
					subredditActions: {
						subscribe: () => s.fbt._("Join", null, {
							hk: "3Nhj3V"
						}),
						subscribed: () => s.fbt._("Joined", null, {
							hk: "1YGago"
						}),
						unsubscribe: () => s.fbt._("Leave", null, {
							hk: "299znK"
						})
					},
					profileActions: {
						subscribe: () => s.fbt._("Follow", null, {
							hk: "18PRa5"
						}),
						subscribed: () => s.fbt._("Following", null, {
							hk: "sjS3y"
						}),
						unsubscribe: () => s.fbt._("Unfollow", null, {
							hk: "3c0uwF"
						})
					}
				},
				i = e => {
					let {
						type: t,
						key: n
					} = e;
					return o[r({
						type: t
					})][n]()
				}
		},
		"./src/reddit/components/SubscribeButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx"),
				r = n("./src/reddit/connectors/SubscribeButton/index.ts"),
				o = n("./src/reddit/components/SubscribeButton/Base.tsx");
			t.a = Object(r.a)(Object(s.c)(o.a))
		},
		"./src/reddit/components/Thumbnail/index.m.less": function(e, t, n) {
			e.exports = {
				blurredThumbnail: "GnWcY6GPzeZ5rzsiQ98fo",
				container: "_2MkcR85HDnYngvlVW2gMMa",
				contentType: "_2hIvPRO2xz4rn9LXAJXYDa",
				hasType: "_10qSZsDWnOBwx4bc7GJ1QF",
				hiddenImage: "_25ZOvQhQdAqwdxPd5z-KFB",
				imageThumbnail: "_33Pa96SGhFVpZeI6a7Y_Pl",
				verticallyCenterThumbnail: "Fq7oYOARH1VVCaLAuAh37",
				linkIcon: "m0n699kowSp8Wfa40lqpF",
				outboundLinkIcon: "_2rOixIHGmpfZB93ihJsw3V",
				placeholderThumbnail: "_2YO2O4rMRYYMeH_t2y8M5w",
				thumbnail: "_2c1ElNxHftd8W_nZtcG9zf",
				usePreview: "_78ohNtfA1urjgUhnN1jLi",
				LinkText: "_3HXDOeeCKnmgu_pIdoLofi",
				linkText: "_3HXDOeeCKnmgu_pIdoLofi"
			}
		},
		"./src/reddit/components/Thumbnail/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			})), n.d(t, "c", (function() {
				return P
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				d = n("./src/lib/lessComponent.tsx"),
				c = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				l = n("./src/reddit/components/ImageWithFallback/index.tsx"),
				u = n("./src/reddit/controls/ContentType/index.tsx"),
				m = n("./src/reddit/controls/OutboundLink/index.tsx"),
				p = n("./src/reddit/icons/fonts/OutboundLink/index.tsx"),
				b = n("./src/reddit/models/Media/index.ts"),
				f = n("./src/reddit/models/Theme/index.ts"),
				h = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				_ = n("./src/telemetry/models/Outbound.ts"),
				g = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				v = n("./src/reddit/components/Thumbnail/index.m.less"),
				x = n.n(v);

			function O() {
				return (O = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const E = e => e.placeholderImage || Object(h.a)(e).placeholderImage,
				y = e => e.placeholderImage ? "cover" : Object(h.a)(e).placeholderImagePosition,
				C = d.a.span("LinkText", x.a),
				j = e => {
					let {
						className: t,
						onClick: n,
						children: s
					} = e;
					return o.a.createElement("div", {
						onClick: n,
						className: Object(i.a)(x.a.linkIcon, t)
					}, s)
				},
				k = e => o.a.createElement("img", {
					alt: e.alt,
					className: Object(i.a)(x.a.hiddenImage, e.className)
				}),
				I = e => {
					const t = o.a.createRef(),
						{
							src: n,
							errorSrc: s
						} = e;
					return n && s && Object(l.b)(n).catch(() => {
						t.current && (t.current.style.backgroundImage = `url(${s})`)
					}), o.a.createElement("div", {
						"aria-label": e.alt,
						className: Object(i.a)(x.a.thumbnail, x.a.imageThumbnail, e.className),
						"data-click-id": "image",
						"data-adclicklocation": g.a.MEDIA,
						ref: t,
						role: "img",
						style: {
							backgroundImage: `url(${e.src})`,
							borderColor: e.isOutbound ? Object(h.a)(e).button : Object(h.a)(e).line
						}
					}, e.isOutbound && o.a.createElement(j, {
						className: e.linkIconClassName
					}, o.a.createElement(p.a, {
						className: Object(i.a)(x.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(C, {
						className: e.linkTextClassName
					}, e.text)), o.a.createElement(k, {
						alt: e.alt,
						className: "hiddenImg"
					}))
				},
				S = e => e.isOutbound ? Object(h.a)(e).button : e.placeholderImage ? "transparent" : Object(h.a)(e).line,
				w = e => {
					const t = E(e),
						n = t && {
							background: Object(f.g)(Object(h.a)(e).placeholder, t, y(e))
						};
					return o.a.createElement("div", {
						className: Object(i.a)(x.a.thumbnail, x.a.placeholderThumbnail, e.className),
						"data-click-id": "image",
						style: {
							...n,
							borderColor: S(e)
						}
					}, (!e.placeholderImage || e.showContentType) && o.a.createElement(u.a, {
						className: Object(i.a)(e.contentTypeClassName, x.a.contentType, {
							[x.a.hasType]: e.type && !e.isOutbound
						}),
						type: e.isMeta || e.isPoll ? "meta" : e.type
					}), e.isOutbound && o.a.createElement(j, {
						className: e.linkIconClassName
					}, o.a.createElement(p.a, {
						className: Object(i.a)(x.a.outboundLinkIcon, e.outboundLinkIconClassName),
						isFilled: !0
					}), e.text && o.a.createElement(C, {
						className: e.linkTextClassName
					}, e.text)))
				},
				T = e => o.a.createElement(I, O({}, e, {
					className: Object(i.a)(x.a.blurredThumbnail, e.className)
				})),
				N = Object(a.a)(e => {
					const {
						className: t,
						containerClassName: n,
						contentTypeClassName: r,
						crosspost: a,
						forceShowNSFW: d,
						isCommentsPage: c,
						isMeta: l,
						linkIconClassName: u,
						linkTextClassName: p,
						outboundLinkIconClassName: f,
						post: h,
						redditStyle: g,
						removeLink: v,
						showContentType: O,
						templatePlaceholderImage: y,
						text: C,
						theme: j,
						usePreview: k
					} = e, I = !j.subredditContext.shouldShowNSFWContent && (h.isNSFW || !(!a || !a.isNSFW)) && !d, S = E({
						placeholderImage: y,
						redditStyle: g,
						theme: j
					}), w = P(e), T = c ? _.SourceElement.PostImage : _.SourceElement.ListingPostImage, N = A(h, t, S, I, C, j, w, l, O, v, g, u, p, f, r), R = Object(b.D)(h);
					return Object(s.a)(R) && !v && R.indexOf("redditmedia") < 0 ? o.a.createElement("div", {
						className: Object(i.a)(x.a.container, k ? x.a.usePreview : "", n)
					}, o.a.createElement(m.b, {
						href: Object(b.D)(h),
						isSponsored: h.isSponsored,
						postId: h.id,
						source: h.source,
						sourceElement: T
					}, N)) : o.a.createElement("div", {
						className: Object(i.a)(x.a.container, k ? x.a.usePreview : "", n)
					}, N)
				}),
				P = e => {
					let {
						crosspost: t,
						post: n,
						url: s,
						usePreview: r
					} = e;
					if (s) return s;
					const {
						preview: o,
						media: i,
						thumbnail: a
					} = t || n;
					return r && o ? o.url : n.isSponsored && o && "default" === a.url ? o.url : R(i) ? i.scrubberThumbSource : a.url
				},
				R = e => !!e && e.type === b.o.LIVEVIDEO,
				A = (e, t, n, r, a, d, l, u, m, p, b, f, h, _, g) => {
					const v = (e => e.source && !e.isSponsored || !1)(e);
					if (Object(s.a)(l)) {
						const n = R(e.media),
							s = n ? {
								errorSrc: c.U
							} : {},
							u = Object(i.a)(t, {
								[x.a.verticallyCenterThumbnail]: n
							});
						return r ? o.a.createElement(T, O({
							"data-click-id": "image",
							src: l
						}, s, {
							className: u,
							isOutbound: v && !p,
							linkIconClassName: f,
							linkTextClassName: h,
							outboundLinkIconClassName: _,
							redditStyle: b,
							text: a,
							theme: d
						})) : o.a.createElement(I, O({
							alt: e.title,
							className: u,
							src: l
						}, s, {
							isOutbound: v && !p,
							linkIconClassName: f,
							linkTextClassName: h,
							outboundLinkIconClassName: _,
							redditStyle: b,
							text: a,
							theme: d
						}))
					}
					return o.a.createElement(w, {
						className: t,
						contentTypeClassName: g,
						placeholderImage: n,
						isMeta: u,
						isOutbound: v && !p,
						linkIconClassName: f,
						linkTextClassName: h,
						outboundLinkIconClassName: _,
						redditStyle: b,
						showContentType: m,
						text: a,
						theme: d,
						type: e.media ? e.media.type : null,
						isPoll: !!e.pollData
					})
				};
			t.b = N
		},
		"./src/reddit/components/TrackingHelper/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = r.a.createContext(() => {});

			function l(e) {
				let {
					children: t
				} = e;
				const n = Object(o.f)(),
					d = Object(s.useCallback)(e => {
						{
							const t = n.getState(),
								s = e(t);
							Object(a.a)({
								...i.o(t),
								...s
							})
						}
					}, [n]);
				return r.a.createElement(c.Provider, {
					value: d
				}, t ? r.a.Children.only(t) : null)
			}

			function u() {
				return Object(s.useContext)(c)
			}

			function m(e) {
				function t(t) {
					const n = u();
					return r.a.createElement(e, d({}, t, {
						sendEvent: n
					}))
				}
				const n = e.name || e.displayName;
				return t.displayName = `Tracked(${n})`, t.WrappedComponent = e, t
			}
		},
		"./src/reddit/components/UserIcon/PresenceDot.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				a = n("./src/reddit/icons/svgs/PresenceCircle/index.tsx"),
				d = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				c = n.n(d);
			t.default = e => {
				const {
					showPresence: t,
					onceInViewport: n
				} = e, d = Object(s.useRef)(null), l = Object(s.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t
						} = e;
						t && n && n()
					})
				}, [n]);
				return Object(i.a)(d, l), r.a.createElement(a.a, {
					ref: d,
					className: Object(o.a)(c.a.presenceDot, {
						[c.a.isLit]: t
					}),
					isHighlighted: e.isHighlighted,
					outlineClassName: e.outlineClassName
				})
			}
		},
		"./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				d = n.n(a);
			t.a = function(e) {
				let {
					backgroundClassName: t,
					className: n,
					headshot: r,
					hasNftBorder: a,
					style: c
				} = e;
				return o.a.createElement("div", {
					className: Object(i.a)(d.a.snoovatarWrapper, n, {
						[d.a.hasNftBorder]: Boolean(a)
					}),
					style: c
				}, o.a.createElement("div", {
					className: Object(i.a)(d.a.snoovatarBackground, t)
				}), o.a.createElement("div", {
					className: d.a.snoovatarHeadshotContainer
				}, o.a.createElement("img", {
					alt: s.fbt._("User avatar", null, {
						hk: "12gjW8"
					}),
					className: d.a.snoovatarHeadshot,
					src: r
				})))
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.m.less": function(e, t, n) {
			e.exports = {
				currentUserIconWrapper: "efdkOLo3oigH_95whTYCp",
				userIconWrapper: "_2p14AQvJBvTrEEa4csiW9v",
				isProfileIcon: "_1lxVpLf3223Gve3gRhbG-R",
				DefaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				defaultUserIcon: "_3utuhrSAkEkzgaswqglvpN",
				UserIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				userIcon: "_2TN8dEgAQbSyKntWpSPYM7",
				mNightmode: "_2aVSEFJsIE0M-4uRE-U24H",
				nftAnimation: "_3fhlcUDP9SJN47QMfuzW_j",
				nftBackground: "_3ppYbU2ZS369JSNSb8585I",
				nftBorder: "_1AX7t-EP7R4ZoVC41DG-Jx",
				snoovatarWrapper: "_1cyAeeYDGrx7MPL_jRwKZ",
				snoovatarBackground: "_2_QqG5dG916znjlVV8ZCbw",
				hasNftBorder: "_3Bn5QwbgKslkdt4UwkP9r9",
				snoovatarHeadshotContainer: "_1XJXnCAngvZLEeLpB3oa4L",
				snoovatarHeadshot: "ScrrUjzznpAqm92uwgnvO",
				presenceDot: "_2dn5Ncenn0BSD4tCSmxQhA",
				isLit: "GpWjjkZl5_kV4yZYWBaT2",
				hasHeadShotWrapper: "_1TENjLYSaj4L4uJMZa3DRe"
			}
		},
		"./src/reddit/components/UserIcon/UserIcon.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/config.ts"),
				r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/icons/svgs/SnooSilhouette/index.tsx"),
				c = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				l = n.n(c);
			const u = `${s.a.assetPath}/img/avatar_over18_square.png`,
				m = e => !e || e.includes("avatar_default_");
			t.b = e => {
				const {
					className: t,
					iconUrl: n,
					isCurrentUser: s,
					isNightMode: o,
					isNSFW: c,
					nsfwIconUrl: p,
					shouldHideNSFW: b,
					style: f
				} = e;
				if (s && m(n) || !s && !n) return i.a.createElement(d.a, {
					className: Object(a.a)(l.a.DefaultUserIcon, t, {
						[l.a.mNightmode]: o
					}),
					style: f
				});
				const h = !s && c && b ? p || u : n;
				return i.a.createElement("img", {
					alt: r.fbt._("User avatar", null, {
						hk: "X43nA"
					}),
					className: Object(a.a)(l.a.UserIcon, t),
					src: h,
					style: f
				})
			}
		},
		"./src/reddit/components/UserIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/realtime/GQLSubscription/async.tsx"),
				c = n("./src/reddit/helpers/userSnoovatar/index.ts"),
				l = n("./src/reddit/hooks/useIntersectionObserver.ts"),
				u = n("./src/reddit/models/User/index.ts"),
				m = n("./src/config.ts"),
				p = n("./src/reddit/components/LottieAnimation/index.tsx");
			var b = e => {
					let {
						className: t
					} = e;
					return o.a.createElement("svg", {
						className: t,
						fill: "none",
						viewBox: "0 0 32 32",
						xmlns: "http://www.w3.org/2000/svg"
					}, o.a.createElement("radialGradient", {
						id: "a",
						cx: "0",
						cy: "0",
						gradientTransform: "matrix(20.06268 6.0999 -3097.55815 10187.91225 -3.1 11.6)",
						gradientUnits: "userSpaceOnUse",
						r: "1"
					}, o.a.createElement("stop", {
						offset: "0",
						stopColor: "#1185b5"
					}), o.a.createElement("stop", {
						offset: ".29",
						stopColor: "#d7f7ff"
					}), o.a.createElement("stop", {
						offset: ".53",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".84",
						stopColor: "#5ef6d8"
					}), o.a.createElement("stop", {
						offset: ".87",
						stopColor: "#1990b9"
					}), o.a.createElement("stop", {
						offset: "1",
						stopColor: "#3f9fc6"
					})), o.a.createElement("path", {
						d: "M13.77 1.1c.76-.41 1.7-.41 2.46 0L28 7.58c.75.42 1.2 1.17 1.2 1.96v12.94c0 .79-.45 1.54-1.2 1.95L16.23 30.9c-.76.42-1.7.42-2.46 0L2 24.42a2.25 2.25 0 0 1-1.2-1.95V9.53C.8 8.74 1.24 8 2 7.57z",
						stroke: "url(#a)",
						strokeLinejoin: "round",
						strokeWidth: "1.59"
					}))
				},
				f = n("./src/reddit/components/UserIcon/UserIcon.m.less"),
				h = n.n(f);
			var _ = e => {
					let {
						iconUrl: t
					} = e;
					return Object(c.c)(t) ? o.a.createElement(p.a, {
						className: h.a.nftAnimation,
						assetUrl: `${m.a.assetPath}/img/snoovatars/comment-animations/nft_comment_animation.json`,
						loop: !0
					}) : o.a.createElement(o.a.Fragment, null, o.a.createElement("div", {
						className: h.a.nftBackground
					}), o.a.createElement(b, {
						className: h.a.nftBorder
					}))
				},
				g = n("./src/reddit/components/UserIcon/PresenceDot.tsx"),
				v = n("./src/reddit/components/UserIcon/SnoovatarHeadshot.tsx"),
				x = n("./src/reddit/components/UserIcon/UserIcon.tsx"),
				O = n("./src/reddit/selectors/user.ts");

			function E() {
				return (E = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const y = () => {},
				C = Object(a.c)({
					currentUser: O.l,
					isNightMode: O.eb,
					shouldHideNSFW: O.G,
					user: O.Bb
				}),
				j = Object(i.b)(C);
			t.a = j(e => {
				const {
					authorId: t,
					collapsed: n,
					currentUser: i,
					iconUrl: a,
					isCommentAuthorBlocked: m,
					isHighlighted: p,
					isNft: b,
					isNSFW: f,
					shouldUseOnlineOverride: O,
					isOnlineOverrideValue: C,
					isOnlineStatusLoadTest: j,
					isProfileIcon: k,
					omitResponsivePresenceWrapper: I,
					onPresenceIndicatorInViewport: S,
					shouldShowPresenceIndicator: w,
					user: T,
					userName: N,
					wrapperClassName: P,
					style: R,
					...A
				} = e, M = !!i && Object(u.e)(i) === N, L = M ? i : T, D = L && L.accountIcon || a, F = T ? T.isNSFW : f, U = Object(c.a)(D) && !m, B = U ? o.a.createElement(v.a, {
					headshot: D,
					className: e.className,
					hasNftBorder: b && Object(c.d)(a),
					style: R
				}) : o.a.createElement(x.b, E({}, A, {
					iconUrl: m && n ? "https://www.redditstatic.com/avatars/defaults/v2/avatar_default_3.png" : D,
					isCurrentUser: M,
					isNSFW: F,
					style: R
				})), [q, G] = Object(r.useState)(!1), H = Object(r.useMemo)(() => ({
					input: {
						channel: {
							teamOwner: "CONTENT_AND_COMMUNITIES",
							category: "ONLINE_STATUS_INDICATOR",
							userID: t
						}
					}
				}), [t]), W = Object(r.useCallback)(e => {
					const {
						isOnline: t
					} = e.subscribe.data;
					G(t)
				}, []), V = Object(r.useRef)(null), [z, K] = Object(r.useState)(!1), Q = Object(r.useCallback)(e => {
					e.forEach(e => {
						const {
							isIntersecting: t,
							intersectionRatio: n
						} = e, s = 1 !== n;
						t ? K(!0) : s && K(!1)
					})
				}, []), Y = Object(r.useRef)({
					rootMargin: "750px 0px 1000px 0px"
				});
				return Object(l.a)(V, Q, Y.current), I ? B : o.a.createElement("div", {
					className: Object(s.a)(h.a.userIconWrapper, {
						[h.a.hasHeadShotWrapper]: U,
						[h.a.isProfileIcon]: k
					}, P),
					ref: V
				}, b && o.a.createElement(_, {
					iconUrl: a
				}), B, w && (q || O && C) && o.a.createElement(g.default, {
					showPresence: !0,
					isHighlighted: p,
					onceInViewport: S
				}), (w || j) && !O && z && o.a.createElement(d.a, {
					variables: H,
					onData: w ? W : y,
					queryKey: "isUserOnline"
				}))
			})
		},
		"./src/reddit/components/VerticalVotes/DisabledVerticalVotes.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				d = n("./src/reddit/controls/Score/index.tsx"),
				c = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/components/VerticalVotes/index.m.less"),
				u = n.n(l);
			class m extends o.a.PureComponent {
				render() {
					const {
						className: e,
						scoreClassName: t
					} = this.props;
					return o.a.createElement("div", {
						className: Object(i.a)(e, u.a.votesContainer)
					}, o.a.createElement("button", {
						className: u.a.disabledVoteIcon,
						"aria-label": s.fbt._("Upvote", null, {
							hk: "4aEt1X"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(a.d, {
						compact: !1,
						voteState: c.a.notVoted,
						interactive: !1
					})), o.a.createElement(d.a, {
						disableInlineColor: !0,
						className: Object(i.a)(u.a.Score, u.a.disabledScore, t),
						score: 0,
						voteState: c.a.notVoted,
						isScoreHidden: !0
					}), o.a.createElement("button", {
						className: u.a.disabledVoteIcon,
						"aria-label": s.fbt._("downvote", null, {
							hk: "4xXpvV"
						}),
						"aria-pressed": !1,
						disabled: !0
					}, o.a.createElement(a.c, {
						compact: !1,
						voteState: c.a.notVoted,
						interactive: !1
					})))
				}
			}
			t.a = m
		},
		"./src/reddit/components/VerticalVotes/index.m.less": function(e, t, n) {
			e.exports = {
				votesContainer: "_1E9mcoVn4MYnuBQSVDt1gC",
				bounceUp: "nmB1I04Z-G4nY3g3s_17F",
				bounceDown: "_1L6r7KisMt3CYUGWSEMGiR",
				disabledScore: "_3WPd5t8B-7mtiGONFotWAM",
				disabledVoteIcon: "mvlZFfW9BWm1bmljE_0Rg"
			}
		},
		"./src/reddit/components/VerticalVotes/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return y
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./node_modules/react-redux/es/index.js"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				l = n("./src/reddit/constants/elementClassNames.ts"),
				u = n("./src/reddit/controls/Score/index.tsx"),
				m = n("./src/reddit/components/VerticalVotes/votes.tsx"),
				p = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				b = n("./src/reddit/models/Vote/index.ts"),
				f = n("./src/reddit/selectors/posts.ts"),
				h = n("./src/reddit/selectors/user.ts"),
				_ = n("./src/higherOrderComponents/withAdClickLocation/Locations.ts"),
				g = n("./src/reddit/components/VerticalVotes/index.m.less"),
				v = n.n(g);
			const x = Object(a.c)({
					isNightMode: h.eb,
					isAnimatingUpvotePostId: f.k
				}),
				O = Object(i.b)(x),
				E = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.upvoteInactive && Object(p.a)(e).voteIcons.upvoteActive,
				y = e => !e.isCustomIconDisabled && !0 !== e.redditStyle && Object(p.a)(e).voteIcons.downvoteInactive && Object(p.a)(e).voteIcons.downvoteActive;
			class C extends o.a.Component {
				constructor() {
					super(...arguments), this.state = {
						voted: b.a.notVoted
					}, this.onUpvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.upvoted), this.setState({
							voted: e !== b.a.upvoted ? b.a.upvoted : b.a.notVoted
						})
					}, this.onDownvote = () => {
						const {
							voteState: e
						} = this.props.model, {
							onVoteClick: t
						} = this.props;
						t(b.a.downvoted), this.setState({
							voted: e !== b.a.downvoted ? b.a.downvoted : b.a.notVoted
						})
					}
				}
				render() {
					const e = this.props,
						{
							downvoteButtonClassName: t,
							isCountAnimShadowTestEnabled: n,
							isNightMode: r,
							isAnimatingUpvotePostId: i,
							shouldShowUpvoteRatioOnHover: a,
							isVoteCountAnimation: c,
							shouldShowScore: p = !0,
							upvoteButtonClassName: f,
							containerRef: h,
							model: g,
							postId: x
						} = e,
						O = E(e),
						C = y(e),
						j = g.voteState,
						k = i === x;
					return o.a.createElement("div", {
						className: Object(d.a)(v.a.votesContainer, e.className),
						id: `vote-arrows-${g.id}`,
						ref: h
					}, O ? o.a.createElement(m.b, {
						"aria-label": s.fbt._("upvote", null, {
							hk: "G6dJB"
						}),
						"aria-pressed": j === b.a.upvoted,
						"data-click-id": "upvote",
						"data-adclicklocation": _.b.UPVOTE,
						compact: e.compact,
						className: e.upvoteClassName,
						id: e.upvoteTooltipId,
						isNightMode: r,
						onClick: this.onUpvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("upvote", null, {
							hk: "RguWS"
						}),
						"aria-pressed": j === b.a.upvoted,
						className: Object(d.a)(l.n, f, {
							[v.a.bounceUp]: k
						}),
						onClick: this.onUpvote,
						"data-click-id": "upvote",
						"data-adclicklocation": _.b.UPVOTE,
						id: e.upvoteTooltipId
					}, o.a.createElement(m.d, {
						compact: e.compact,
						className: e.upvoteClassName,
						voteState: j
					})), !e.compact && p && o.a.createElement(u.a, {
						className: Object(d.a)(v.a.Score, e.scoreClassName),
						flairStyleTemplate: e.flairStyleTemplate,
						light: e.light,
						score: e.model.score,
						voteState: j,
						shouldShowUpvoteRatioOnHover: a,
						isScoreHidden: e.model.isScoreHidden,
						isVoteCountAnimation: !!c,
						isCountAnimShadowTestEnabled: !!n,
						postId: x
					}), C ? o.a.createElement(m.a, {
						"aria-label": s.fbt._("downvote", null, {
							hk: "tNfDV"
						}),
						"aria-pressed": j === b.a.downvoted,
						"data-click-id": "downvote",
						"data-adclicklocation": _.b.DOWNVOTE,
						className: e.downvoteClassName,
						compact: e.compact,
						isNightMode: r,
						onClick: this.onDownvote,
						voteState: j
					}) : o.a.createElement("button", {
						"aria-label": s.fbt._("downvote", null, {
							hk: "1mDjTw"
						}),
						"aria-pressed": j === b.a.downvoted,
						className: Object(d.a)(l.n, t),
						onClick: this.onDownvote,
						"data-click-id": "downvote",
						"data-adclicklocation": _.b.DOWNVOTE
					}, o.a.createElement(m.c, {
						className: e.downvoteClassName,
						compact: e.compact,
						voteState: j
					})))
				}
			}
			const j = Object(c.a)(O(C));
			t.a = j
		},
		"./src/reddit/components/VerticalVotes/votes.m.less": function(e, t, n) {
			e.exports = {
				customDownvote: "ceU_3ot04pOVIcrrXH9fY",
				compact: "_3sO1xEnOT_9CQBjRzczQjS",
				voted: "_8dpZTfzgKPKCUTjp9SAn1",
				customUpvote: "_2k73nZrjAYiwAj9hv7K-kq"
			}
		},
		"./src/reddit/components/VerticalVotes/votes.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return T
			})), n.d(t, "b", (function() {
				return N
			})), n.d(t, "c", (function() {
				return P
			})), n.d(t, "d", (function() {
				return R
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/CSSVariableProvider/withTheme.tsx");
			const a = (e, t, n) => s => {
				const r = e(s),
					i = t(s),
					a = !r && i;
				return Object(o.a)(n.baseClassName, s.className, {
					[n.mIsInteractive]: i,
					[n.mIsActive]: r,
					[n.mIsVoteable]: a
				})
			};
			var d = n("./src/reddit/icons/fonts/Downvote/index.tsx"),
				c = n("./src/reddit/models/Vote/index.ts"),
				l = n("./src/reddit/controls/Downvote/index.m.less"),
				u = n.n(l);
			const m = {
					...u.a,
					baseClassName: u.a.Downvote
				},
				p = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.downvoted
				},
				b = a(p, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, m);
			var f = e => r.a.createElement(d.a, {
					className: b(e),
					compact: e.compact,
					isFilled: p(e)
				}),
				h = n("./src/reddit/icons/fonts/Upvote/index.tsx"),
				_ = n("./src/reddit/controls/Upvote/index.m.less"),
				g = n.n(_);
			const v = {
					...g.a,
					baseClassName: g.a.Upvote
				},
				x = e => {
					let {
						voteState: t
					} = e;
					return t === c.a.upvoted
				},
				O = a(x, e => {
					let {
						interactive: t
					} = e;
					return !1 !== t
				}, v);
			var E = e => r.a.createElement(h.b, {
					className: O(e),
					compact: e.compact,
					isFilled: x(e)
				}),
				y = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				C = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				j = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				k = n("./src/reddit/components/VerticalVotes/votes.m.less"),
				I = n.n(k);

			function S() {
				return (S = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const w = e => Object(o.a)({
					[I.a.compact]: e.compact,
					[I.a.dark]: Object(C.b)(Object(y.a)(e)),
					[I.a.nightmode]: e.isNightMode
				}),
				T = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(j.a)(e), n = {
						"--verticalvotes-customdownvote-active": `url(${t.downvoteActive})`,
						"--verticalvotes-customdownvote-inactive": `url(${t.downvoteInactive})`
					}, {
						theme: s,
						isNightMode: i,
						voteState: a,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", S({}, l, {
						className: Object(o.a)(I.a.customDownvote, w(e), {
							[I.a.voted]: e.voteState === c.a.downvoted
						}, e.className),
						style: n
					}))
				}),
				N = Object(i.a)(e => {
					const {
						voteIcons: t
					} = Object(j.a)(e), n = {
						"--verticalvotes-customupvote-active": `url(${t.upvoteActive})`,
						"--verticalvotes-customupvote-inactive": `url(${t.upvoteInactive})`
					}, {
						theme: s,
						isNightMode: i,
						voteState: a,
						compact: d,
						...l
					} = e;
					return r.a.createElement("button", S({}, l, {
						className: Object(o.a)(I.a.customUpvote, w(e), {
							[I.a.voted]: e.voteState === c.a.upvoted
						}, e.className),
						style: n
					}))
				}),
				P = f,
				R = E
		},
		"./src/reddit/components/ViewReportsDropdown/Loader.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js");
			t.a = Object(s.a)({
				resolved: {},
				chunkName: () => "reddit-components-ViewReportsDropdown-index",
				isReady(e) {
					const t = this.resolve(e);
					return !1 !== this.resolved[t] && !!n.m[t]
				},
				importAsync: () => n.e("reddit-components-ViewReportsDropdown-index").then(n.bind(null, "./src/reddit/components/ViewReportsDropdown/index.tsx")),
				requireAsync(e) {
					const t = this.resolve(e);
					return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
				},
				requireSync(e) {
					const t = this.resolve(e);
					return n(t)
				},
				resolve() {
					return "./src/reddit/components/ViewReportsDropdown/index.tsx"
				}
			})
		},
		"./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less": function(e, t, n) {
			e.exports = {
				modalBody: "_1bgWTt9jbjzFmQBe0xzfBc",
				notice: "_19wd_7K0Gqdp6cf0Pno6jX",
				sectionTitle: "_2eB-lbdBJ7yGnpy9iCXf27",
				primaryButton: "_1Wp9oAwAZieyVMe4wA5SeL",
				dropdownContainer: "_2-waVlosIHdWwUa_OBavKm",
				dropdownTarget: "_1mcRpBQSnN5ALeKix2x4Py",
				targetText: "_3QRCCOc1SfjMkk4bZCW5lD",
				dropdown: "_1Uq_MgLQhUk4iL9iHGz3qL",
				dropdownRow: "_2UfNC6z3v6GQsT_TQn-eoZ",
				errorText: "_31tw_6Xr1vH0KRVUnoJEdv"
			}
		},
		"./src/reddit/connectors/PostViewable/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/actions/post.ts");
			t.a = (e, t) => Object(s.b)(e, function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
				return {
					...e,
					onPostViewable: r.P
				}
			}(t))
		},
		"./src/reddit/connectors/SubscribeButton/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/actions/subscription/index.ts"),
				i = n("./src/reddit/selectors/subreddit.ts");
			t.a = Object(s.b)(() => Object(r.c)({
				userIsSubscriber: i.kb
			}), (e, t) => {
				let {
					identifier: n
				} = t;
				return {
					onSubscribe: () => e(o.d([n], !0)),
					onSubscriptionsRequested: () => e(o.e()),
					onUnsubscribe: () => e(o.d([n], !1))
				}
			})
		},
		"./src/reddit/constants/componentSizes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "p", (function() {
				return p
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "t", (function() {
				return h
			})), n.d(t, "s", (function() {
				return _
			})), n.d(t, "u", (function() {
				return g
			})), n.d(t, "v", (function() {
				return v
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "b", (function() {
				return O
			})), n.d(t, "m", (function() {
				return E
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "o", (function() {
				return C
			}));
			const s = 284,
				r = 450,
				o = 800,
				i = 284,
				a = 48,
				d = 640,
				c = 1600,
				l = 40,
				u = 48,
				m = 24,
				p = 24,
				b = 312,
				f = 40,
				h = 270,
				_ = 106,
				g = 5,
				v = 16,
				x = 1250,
				O = 82,
				E = 48,
				y = 36,
				C = 40
		},
		"./src/reddit/constants/componentTestIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = "comment",
				r = "comment-submission-form-markdown",
				o = "comment-submission-form-richtext",
				i = "comments-page-link-num-comments",
				a = "post-content"
		},
		"./src/reddit/constants/elementClassNames.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "k", (function() {
				return a
			})), n.d(t, "m", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "n", (function() {
				return l
			})), n.d(t, "j", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "l", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			}));
			const s = "DraftEditor-contentwrapper",
				r = "public-DraftStyleDefault-block",
				o = "data-offset-key",
				i = "hovered",
				a = "scrollerItem",
				d = "threadline",
				c = "header-user-dropdown",
				l = "voteButton",
				u = "RichTextJSON-root",
				m = "ImageBox-image",
				p = "content-type-link",
				b = "styled-outbound-link",
				f = "ListingLayout-backgroundContainer",
				h = "ListingLayout-outerContainer"
		},
		"./src/reddit/constants/elementIds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			const s = "AppRouter-main-content",
				r = "bladeContainer",
				o = "header",
				i = "overlayScrollContainer",
				a = "collectionPostListScrollContainer"
		},
		"./src/reddit/constants/errors.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.BannedProfile = "BANNED", e.DeletedProfile = "DELETED", e.NotFoundProfile = "NOT_FOUND", e.ForbiddenProfile = "FORBIDDEN"
				}(s || (s = {})),
				function(e) {
					e.Unknown = "Unknown"
				}(r || (r = {}))
		},
		"./src/reddit/constants/gold.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			}));
			const s = "ModerationPage--Modal--AddAward",
				r = "ModerationPage--Modal--DeleteAwardConfirmation",
				o = 20,
				i = 4,
				a = 1e4,
				d = .2,
				c = .1,
				l = .1,
				u = 500
		},
		"./src/reddit/constants/graphql.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Card = "CARD", e.Classic = "CLASSIC", e.Compact = "COMPACT"
				}(s || (s = {}))
		},
		"./src/reddit/constants/jsapiEvents.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = "reddit",
				r = "reddit.ready",
				o = "reddit.urlChanged"
		},
		"./src/reddit/constants/keycodes.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e[e.ArrowDown = 40] = "ArrowDown", e[e.ArrowLeft = 37] = "ArrowLeft", e[e.ArrowRight = 39] = "ArrowRight", e[e.ArrowUp = 38] = "ArrowUp", e[e.Backspace = 8] = "Backspace", e[e.Delete = 46] = "Delete", e[e.Enter = 13] = "Enter", e[e.Escape = 27] = "Escape", e[e.F = 70] = "F", e[e.K = 75] = "K", e[e.Space = 32] = "Space", e[e.Tab = 9] = "Tab", e[e.Comma = 188] = "Comma"
				}(s || (s = {})),
				function(e) {
					e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.ArrowUp = "ArrowUp", e.Backspace = "Backspace", e.Enter = "Enter", e.Escape = "Escape", e.F = "f", e.Tab = "Tab", e.Space = " ", e.Comma = ","
				}(r || (r = {}))
		},
		"./src/reddit/constants/livebar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = "live_bar_nav"
		},
		"./src/reddit/constants/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "h", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "i", (function() {
				return h
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "l", (function() {
				return g
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/icons.ts"),
				o = n("./src/redditGQL/types.ts");
			const i = ["Anti-Evil Operations", "Reddit Legal"];
			var a;
			! function(e) {
				e.DATE = "date", e.ACTION = "action", e.MODERATOR = "moderator"
			}(a || (a = {}));
			const d = {
					[o.v.Awards]: () => s.fbt._("Awards", null, {
						hk: "MZQfH"
					}),
					[o.v.Comments]: () => s.fbt._("Comments", null, {
						hk: "2lDGmG"
					}),
					[o.v.CrowdControl]: () => s.fbt._("CrowdControl", null, {
						hk: "36Hdke"
					}),
					[o.v.Members]: () => s.fbt._("Members", null, {
						hk: "3XMB94"
					}),
					[o.v.ModTeam]: () => s.fbt._("Mod Team", null, {
						hk: "3PHzgJ"
					}),
					[o.v.Posts]: () => s.fbt._("Posts", null, {
						hk: "4anDQX"
					}),
					[o.v.PostsAndComments]: () => s.fbt._("Posts and Comments", null, {
						hk: "2wSR4X"
					}),
					[o.v.Rules]: () => s.fbt._("Rules", null, {
						hk: "1Se158"
					}),
					[o.v.Settings]: () => s.fbt._("Settings", null, {
						hk: "uTh33"
					}),
					[o.v.Wiki]: () => s.fbt._("Wiki", null, {
						hk: "2f4T1a"
					})
				},
				c = {
					[o.v.Awards]: r.a.award,
					[o.v.Comments]: r.a.comment,
					[o.v.CrowdControl]: r.a.crowd_control,
					[o.v.Members]: r.a.profile,
					[o.v.ModTeam]: r.a.mod,
					[o.v.Posts]: r.a.text_post,
					[o.v.PostsAndComments]: r.a.list_bulleted,
					[o.v.Rules]: r.a.rules,
					[o.v.Settings]: r.a.settings,
					[o.v.Wiki]: r.a.wiki
				},
				l = {
					[o.v.Awards]: "#FFD5C6",
					[o.v.Comments]: "#FFCCD2",
					[o.v.CrowdControl]: "#FFC5EC",
					[o.v.Members]: "#F2C8FF",
					[o.v.ModTeam]: "#D8D4FF",
					[o.v.Posts]: "#C6DCFF",
					[o.v.PostsAndComments]: "#D2DADD",
					[o.v.Rules]: "#B6E9FF",
					[o.v.Settings]: "#BFEEB8",
					[o.v.Wiki]: "#FFE88F"
				},
				u = {
					[o.v.Awards]: "#FFBEA6",
					[o.v.Comments]: "#FFADB8",
					[o.v.CrowdControl]: "#FFA5E3",
					[o.v.Members]: "#EEA7FF",
					[o.v.ModTeam]: "#C3BDFF",
					[o.v.Posts]: "#A7CCFF",
					[o.v.PostsAndComments]: "#A0B0B5",
					[o.v.Rules]: "#95DCFB",
					[o.v.Settings]: "#A3E398",
					[o.v.Wiki]: "#FADB61"
				},
				m = {
					ALL_ACTIONS: () => s.fbt._("All actions", null, {
						hk: "3sHzD4"
					}),
					ACCEPT_MODERATOR_INVITE: () => s.fbt._("Accept moderator invite", null, {
						hk: "3WJot2"
					}),
					ADD_COMMUNITY_TOPICS: () => s.fbt._("Add community topics", null, {
						hk: "4xgglk"
					}),
					ADD_CONTRIBUTOR: () => s.fbt._("Add contributor", null, {
						hk: "444ZK"
					}),
					ADD_MODERATOR: () => s.fbt._("Add moderator", null, {
						hk: "4rRghF"
					}),
					ADD_NOTE: () => s.fbt._("Add note", null, {
						hk: "2UjBm"
					}),
					ADD_REMOVAL_REASON: () => s.fbt._("Add removal reason", null, {
						hk: "jCC35"
					}),
					ADJUST_POST_CROWD_CONTROL_LEVEL: () => s.fbt._("Adjust post crowd control level", null, {
						hk: "Eqwnv"
					}),
					ENABLE_POST_CROWD_CONTROL_FILTER: () => s.fbt._("Enable post crowd control filter", null, {
						hk: "1uzJGq"
					}),
					DISABLE_POST_CROWD_CONTROL_FILTER: () => s.fbt._("Disable post crowd control filter", null, {
						hk: "UrQCB"
					}),
					APPROVE_COMMENT: () => s.fbt._("Approve comment", null, {
						hk: "1gvHWC"
					}),
					APPROVE_LINK: () => s.fbt._("Approve link", null, {
						hk: "2LqFt4"
					}),
					BAN_USER: () => s.fbt._("Ban user", null, {
						hk: "4DmPqi"
					}),
					COLLECTIONS: () => s.fbt._("Collections", null, {
						hk: "3a39Wa"
					}),
					COMMUNITY_STYLING: () => s.fbt._("Community styling", null, {
						hk: "386ps9"
					}),
					COMMUNITY_WIDGETS: () => s.fbt._("Community widgets", null, {
						hk: "4ml45n"
					}),
					CREATE_AWARD: () => s.fbt._("Create award", null, {
						hk: "bWa9w"
					}),
					CREATE_REMOVAL_REASON: () => s.fbt._("Create removal reason", null, {
						hk: "i1LIy"
					}),
					CREATE_RULE: () => s.fbt._("Create rule", null, {
						hk: "28uE69"
					}),
					CREATE_SCHEDULED_POST: () => s.fbt._("Create scheduled post", null, {
						hk: "mVbI1"
					}),
					DELETE_AWARD: () => s.fbt._("Delete award", null, {
						hk: "3xYaZ7"
					}),
					DELETE_REMOVAL_REASON: () => s.fbt._("Delete removal reason", null, {
						hk: "3FdYhk"
					}),
					DELETE_RULE: () => s.fbt._("Delete rule", null, {
						hk: "2lWdRL"
					}),
					DELETE_SCHEDULED_POST: () => s.fbt._("Delete scheduled post", null, {
						hk: "MhwRy"
					}),
					DELETE_OVERRIDDEN_CLASSIFICATION: () => s.fbt._("Delete overridden classification", null, {
						hk: "3hPfDT"
					}),
					DELETE_NOTE: () => s.fbt._("Delete note", null, {
						hk: "1P0prb"
					}),
					DISABLE_AWARD: () => s.fbt._("Disable award", null, {
						hk: "2yFBt7"
					}),
					DISTINGUISH: () => s.fbt._("Distinguish", null, {
						hk: "3cWniK"
					}),
					EDIT_FLAIR: () => s.fbt._("Edit flair", null, {
						hk: "mD0CV"
					}),
					EDIT_POST_REQUIREMENTS: () => s.fbt._("Edit post requirements", null, {
						hk: "1SLqNE"
					}),
					EDIT_RULE: () => s.fbt._("Edit rule", null, {
						hk: "2T4TJx"
					}),
					EDIT_SCHEDULED_POST: () => s.fbt._("Edit scheduled post", null, {
						hk: "1XCmsI"
					}),
					EDIT_SETTINGS: () => s.fbt._("Edit settings", null, {
						hk: "3o8q46"
					}),
					ENABLE_AWARD: () => s.fbt._("Enable award", null, {
						hk: "3zYir4"
					}),
					HIDDEN_AWARD: () => s.fbt._("Hide award", null, {
						hk: "31lRN8"
					}),
					EVENTS: () => s.fbt._("Events", null, {
						hk: "4Bq9wt"
					}),
					IGNORE_REPORTS: () => s.fbt._("Ignore reports", null, {
						hk: "1defIy"
					}),
					INVITE_MODERATOR: () => s.fbt._("Invite moderator", null, {
						hk: "1DbgL5"
					}),
					INVITE_SUBSCRIBER: () => s.fbt._("Invite subscriber", null, {
						hk: "4yEMNb"
					}),
					LOCK: () => s.fbt._("Lock", null, {
						hk: "39hTi5"
					}),
					MARK_NSFW: () => s.fbt._("Mark nsfw", null, {
						hk: "3bo45o"
					}),
					MARK_ORIGINAL_CONTENT: () => s.fbt._("Mark original content", null, {
						hk: "SadHO"
					}),
					MOD_AWARD_GIVEN: () => s.fbt._("Mod award given by moderators", null, {
						hk: "35cQgR"
					}),
					MODMAIL_ENROLLMENT: () => s.fbt._("Modmail enrollment", null, {
						hk: "4ee1XK"
					}),
					MUTE_USER: () => s.fbt._("Mute user", null, {
						hk: "3kPYe4"
					}),
					OVERRIDE_CLASSIFICATION: () => s.fbt._("Override classification", null, {
						hk: "2VPY6n"
					}),
					REMOVE_COMMENT: () => s.fbt._("Remove comment", null, {
						hk: "vEI4S"
					}),
					REMOVE_COMMUNITY_TOPICS: () => s.fbt._("Remove community topics", null, {
						hk: "1tLjxQ"
					}),
					REMOVE_CONTRIBUTOR: () => s.fbt._("Remove contributor", null, {
						hk: "4FMLz6"
					}),
					REMOVE_LINK: () => s.fbt._("Remove link", null, {
						hk: "tmjch"
					}),
					REMOVE_MODERATOR: () => s.fbt._("Remove moderator", null, {
						hk: "1FHVTB"
					}),
					REMOVE_WIKI_CONTRIBUTOR: () => s.fbt._("Remove wiki contributor", null, {
						hk: "1PcCja"
					}),
					REORDER_MODERATORS: () => s.fbt._("Reorder moderators", null, {
						hk: "3Csxj8"
					}),
					REORDER_RULES: () => s.fbt._("Reorder rules", null, {
						hk: "306Bqx"
					}),
					SET_CONTEST_MODE: () => s.fbt._("Set contest mode", null, {
						hk: "1pERnU"
					}),
					SET_PERMISSIONS: () => s.fbt._("Set permissions", null, {
						hk: "3UzkKU"
					}),
					SET_SUGGESTEDSORT: () => s.fbt._("Set suggested sort", null, {
						hk: "208T6K"
					}),
					SHOW_COMMENT: () => s.fbt._("Show comment", null, {
						hk: "n5M3i"
					}),
					SNOOZE_REPORTS: () => s.fbt._("Snooze reports", null, {
						hk: "3gOkDV"
					}),
					SPAM_COMMENT: () => s.fbt._("Spam comment", null, {
						hk: "2ROyTD"
					}),
					SPAM_LINK: () => s.fbt._("Spam link", null, {
						hk: "2G5xg3"
					}),
					SPOILER: () => s.fbt._("Spoiler", null, {
						hk: "2nfv1a"
					}),
					STICKY: () => s.fbt._("Sticky", null, {
						hk: "1W6JrJ"
					}),
					SUBMIT_CONTENT_RATING_SURVEY: () => s.fbt._("Submit content rating survey", null, {
						hk: "1F1ead"
					}),
					SUBMIT_SCHEDULED_POST: () => s.fbt._("Submit scheduled post", null, {
						hk: "1i2VUH"
					}),
					UNBAN_USER: () => s.fbt._("Unban user", null, {
						hk: "4m2iNP"
					}),
					UNIGNORE_REPORTS: () => s.fbt._("Unignore reports", null, {
						hk: "1wfp99"
					}),
					UNINVITE_MODERATOR: () => s.fbt._("Uninvite moderator", null, {
						hk: "3E6UkD"
					}),
					UNLOCK: () => s.fbt._("Unlock", null, {
						hk: "2BHnOC"
					}),
					UNMUTE_USER: () => s.fbt._("Unmute user", null, {
						hk: "25tct2"
					}),
					UNSET_CONTEST_MODE: () => s.fbt._("Unset contest mode", null, {
						hk: "AxsDk"
					}),
					UNSNOOZE_REPORTS: () => s.fbt._("Unsnooze reports", null, {
						hk: "4nlwcg"
					}),
					UNSPOILER: () => s.fbt._("Unspoiler", null, {
						hk: "2gE1K1"
					}),
					UNSTICKY: () => s.fbt._("Unsticky", null, {
						hk: "U5tvd"
					}),
					UPDATE_REMOVAL_REASON: () => s.fbt._("Update removal reason", null, {
						hk: "aDPHp"
					}),
					WIKI_BANNED: () => s.fbt._("Wiki banned", null, {
						hk: "1nk4H7"
					}),
					WIKI_CONTRIBUTOR: () => s.fbt._("Wiki contributor", null, {
						hk: "1W6zn3"
					}),
					WIKI_PAGE_LISTED: () => s.fbt._("Wiki page listed", null, {
						hk: "4aghdO"
					}),
					WIKI_PERM_LEVEL: () => s.fbt._("Wiki perm level", null, {
						hk: "4waHE"
					}),
					WIKI_REVISE: () => s.fbt._("Wiki revise", null, {
						hk: "3FZuIJ"
					}),
					WIKI_UNBANNED: () => s.fbt._("Wiki unbanned", null, {
						hk: "1fAtKd"
					})
				},
				p = {
					added_event_times: () => s.fbt._("added event times to post", null, {
						hk: "1TpgVq"
					}),
					added_flair_styling: () => s.fbt._("added flair styling", null, {
						hk: "zQ6Tv"
					}),
					added_styling: () => s.fbt._("modified community styling", null, {
						hk: "xSJ7B"
					}),
					added_to_collection: () => s.fbt._("added post to collection", null, {
						hk: "3V4fk0"
					}),
					added_widget: () => s.fbt._("added widget", null, {
						hk: "1eVJg6"
					}),
					allow_discovery: () => s.fbt._("toggle allow in search/onboarding/discovery", null, {
						hk: "3on6Qf"
					}),
					allow_top: () => s.fbt._("toggle allow in default/trending lists", null, {
						hk: "DikzW"
					}),
					collapse_deleted_comments: () => s.fbt._("toggle collapse deleted/removed comments", null, {
						hk: "22QPzD"
					}),
					comment_score_hide_mins: () => s.fbt._("comment score hide period", null, {
						hk: "21jsup"
					}),
					confirm_ham: () => s.fbt._("approved", null, {
						hk: "3xh84x"
					}),
					confirm_spam: () => s.fbt._("confirm spam", null, {
						hk: "2yAos0"
					}),
					created_collection: () => s.fbt._("created collection", null, {
						hk: "3vtmUM"
					}),
					css_on_cname: () => s.fbt._("toggle custom css from cname", null, {
						hk: "LTlcB"
					}),
					del_banner: () => s.fbt._("delete banner image", null, {
						hk: "2HRlu"
					}),
					del_header: () => s.fbt._("delete header image", null, {
						hk: "2k08m2"
					}),
					del_icon: () => s.fbt._("delete icon image", null, {
						hk: "43ObSQ"
					}),
					del_image: () => s.fbt._("delete image", null, {
						hk: "4ztzG0"
					}),
					deleted_collection: () => s.fbt._("deleted collection", null, {
						hk: "1T8FDF"
					}),
					description: () => s.fbt._("sidebar description", null, {
						hk: "3gBQBx"
					}),
					domain: () => s.fbt._("domain", null, {
						hk: "37Eg7w"
					}),
					edit_post_requirements: () => s.fbt._("edited post requirements", null, {
						hk: "CoMF6"
					}),
					edited_collection_description: () => s.fbt._("edited collection description", null, {
						hk: "ViGod"
					}),
					edited_collection_display_layout: () => s.fbt._("edited collection display layout", null, {
						hk: "xGExq"
					}),
					edited_collection_title: () => s.fbt._("edited collection title", null, {
						hk: "2x6aKQ"
					}),
					edited_event_body: () => s.fbt._("edited event post body", null, {
						hk: "2uwjvL"
					}),
					edited_event_times: () => s.fbt._("edited event post times", null, {
						hk: "3HNoa4"
					}),
					edited_event_title: () => s.fbt._("edited event post title", null, {
						hk: "4itZHA"
					}),
					edited_widget: () => s.fbt._("edited widget", null, {
						hk: "4eaNe6"
					}),
					enable_award: () => s.fbt._("enabled award", null, {
						hk: "3Ehki9"
					}),
					exclude_banned_modqueue: () => s.fbt._("toggle exclude banned users posts from modqueue", null, {
						hk: "j41F1"
					}),
					flair_clear_template: () => s.fbt._("clear flair template", null, {
						hk: "1IMRYi"
					}),
					flair_csv: () => s.fbt._("edit flair by csv", null, {
						hk: "480ZDT"
					}),
					flair_delete_template: () => s.fbt._("delete flair template", null, {
						hk: "bJ8f2"
					}),
					flair_add: () => s.fbt._("add flair", null, {
						hk: "281rsb"
					}),
					flair_delete: () => s.fbt._("delete flair", null, {
						hk: "2UkqAp"
					}),
					flair_edit: () => s.fbt._("edit flair", null, {
						hk: "3oxZYq"
					}),
					flair_enabled: () => s.fbt._("toggle flair enabled", null, {
						hk: "9WUzt"
					}),
					flair_position: () => s.fbt._("toggle user flair position", null, {
						hk: "4cwkk5"
					}),
					flair_self_enabled: () => s.fbt._("toggle user assigned flair enabled", null, {
						hk: "4q13ZR"
					}),
					flair_template: () => s.fbt._("add/edit flair templates", null, {
						hk: "NSSHD"
					}),
					free_form_reports: () => s.fbt._("toggle allow free form reports by users", null, {
						hk: "3MBfJn"
					}),
					header_title: () => s.fbt._("header title", null, {
						hk: "40Y0QO"
					}),
					ignore_reports: () => s.fbt._("ignore reports", null, {
						hk: "h7fov"
					}),
					lang: () => s.fbt._("language", null, {
						hk: "2xhrR8"
					}),
					link_flair_position: () => s.fbt._("toggle link flair position", null, {
						hk: "3j33wQ"
					}),
					link_flair_self_enabled: () => s.fbt._("toggle submitter assigned link flair enabled", null, {
						hk: "43EykN"
					}),
					link_type: () => s.fbt._("link type", null, {
						hk: "2FuNM"
					}),
					over_18: () => s.fbt._("toggle viewers must be over 18", null, {
						hk: "PRgas"
					}),
					permanent: () => s.fbt._("permanent ban", null, {
						hk: "3MeL5T"
					}),
					permission_moderator_invite: () => s.fbt._("set permissions on moderator invitation", null, {
						hk: "hA7I9"
					}),
					permission_moderator: () => s.fbt._("set permissions on moderator", null, {
						hk: "1yq3O2"
					}),
					public_description: () => s.fbt._("description", null, {
						hk: "JizZj"
					}),
					public_traffic: () => s.fbt._("toggle public traffic stats page", null, {
						hk: "qIXty"
					}),
					remove_self: () => s.fbt._("removed self", null, {
						hk: "I5wgr"
					}),
					remove: () => s.fbt._("remove", null, {
						hk: "mAXhe"
					}),
					removed_from_collection: () => s.fbt._("removed post from collection", null, {
						hk: "2dwuxr"
					}),
					removed_styling: () => s.fbt._("removed community styling", null, {
						hk: "1p7Io9"
					}),
					removed_widget: () => s.fbt._("removed widget", null, {
						hk: "43WUko"
					}),
					show_cname_sidebar: () => s.fbt._("toggle show sidebar from cname", null, {
						hk: "4nlv2A"
					}),
					show_media: () => s.fbt._("toggle show thumbnail images of content", null, {
						hk: "2XmVTJ"
					}),
					spam: () => s.fbt._("spam", null, {
						hk: "3usg93"
					}),
					stylesheet: () => s.fbt._("stylesheet", null, {
						hk: "1TOdUF"
					}),
					submit_link_label: () => s.fbt._("submit link button label", null, {
						hk: "4BdL19"
					}),
					submit_text_label: () => s.fbt._("submit text post button label", null, {
						hk: "4wc8qi"
					}),
					title: () => s.fbt._("title", null, {
						hk: "3tlhiX"
					}),
					type: () => s.fbt._("type", null, {
						hk: "14BQua"
					}),
					unspam: () => s.fbt._("unspam", null, {
						hk: "3SxHQ4"
					}),
					upload_image_banner: () => s.fbt._("upload image banner", null, {
						hk: "1ocFEe"
					}),
					upload_image_header: () => s.fbt._("upload image header", null, {
						hk: "3J6pke"
					}),
					upload_image_icon: () => s.fbt._("upload image icon", null, {
						hk: "4jr6Eg"
					}),
					upload_image: () => s.fbt._("upload image", null, {
						hk: "2KN9ig"
					}),
					copyright_removal: () => s.fbt._("copyright removal", null, {
						hk: "9vN6G"
					}),
					copyright_restoration: () => s.fbt._("copyright restoration", null, {
						hk: "35qFx5"
					})
				};
			var b, f;
			! function(e) {
				e.AWARD = "Award", e.COMMENT = "Comment", e.FLAIR = "Flair", e.MULTIPLE = "Multiple", e.POST = "Post", e.REDDITOR = "Redditor", e.SETTINGS = "Settings", e.WIKI = "Wiki", e.COLLECTION = "Collection", e.EVENT = "Event", e.NOTE = "Note"
			}(b || (b = {})),
			function(e) {
				e.NONE = "none", e.POSITIVE = "positive", e.NEGATIVE = "negative"
			}(f || (f = {}));
			const h = "https://www.redditinc.com/policies/content-policy",
				_ = "https://reddit.zendesk.com/hc/en-us/sections/360008810152-Copyright-Help-Center",
				g = {
					[o.h.Rule_1]: () => s.fbt._("Sitewide Rule 1", null, {
						hk: "3jk6cs"
					}),
					[o.h.Rule_2]: () => s.fbt._("Sitewide Rule 2", null, {
						hk: "4xT4lX"
					}),
					[o.h.Rule_3]: () => s.fbt._("Sitewide Rule 3", null, {
						hk: "3BFdeS"
					}),
					[o.h.Rule_4]: () => s.fbt._("Sitewide Rule 4", null, {
						hk: "4COU2Q"
					}),
					[o.h.Rule_5]: () => s.fbt._("Sitewide Rule 5", null, {
						hk: "QU0F5"
					}),
					[o.h.Rule_6]: () => s.fbt._("Sitewide Rule 6", null, {
						hk: "45NxT7"
					}),
					[o.h.Rule_7]: () => s.fbt._("Sitewide Rule 7", null, {
						hk: "1uFtlD"
					}),
					[o.h.Rule_8]: () => s.fbt._("Sitewide Rule 8", null, {
						hk: "4Gj2wR"
					}),
					[o.h.Dmca]: () => s.fbt._("Copyright Violation", null, {
						hk: "4ekSIy"
					}),
					[o.h.Unknown]: () => s.fbt._("Sitewide Rule", null, {
						hk: "16haBr"
					})
				}
		},
		"./src/reddit/constants/postCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			}));
			const s = "PostCreation-AddEventButton",
				r = 500,
				o = "PostCreation-CollectionEducationTooltip",
				i = "PostCreation-EventEducationTooltip",
				a = 300,
				d = a,
				c = "PostCreation-AddToCollectionButton"
		},
		"./src/reddit/constants/screenWidths.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = 480,
				r = 960,
				o = 1200
		},
		"./src/reddit/constants/shortcuts.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "d", (function() {
					return s
				})), n.d(t, "c", (function() {
					return r
				})), n.d(t, "b", (function() {
					return o
				})), n.d(t, "a", (function() {
					return i
				})),
				function(e) {
					e.CommentPage = "CommentPage", e.Global = "Global", e.Lightbox = "Lightbox", e.Listing = "Listing", e.Modqueue = "Modqueue"
				}(s || (s = {})),
				function(e) {
					e.Close = "CLOSE", e.CollapseOrLoad = "COLLAPSE_OR_LOAD", e.Downvote = "DOWNVOTE", e.Expando = "EXPANDO", e.Hide = "HIDE", e.Konami = "KONAMI", e.NewPost = "NEW_POST", e.NextComment = "NEXT_COMMENT", e.NextPost = "NEXT_POST", e.OpenIndex = "OPEN_INDEX", e.OpenLightbox = "OPEN_LIGHTBOX", e.OpenLink = "OPEN_LINK", e.PrevComment = "PREV_COMMENT", e.PrevPost = "PREV_POST", e.Reply = "REPLY", e.Save = "SAVE", e.Upvote = "UPVOTE"
				}(r || (r = {}));
			const o = "SHORTCUT_FOCUSABLE_DIV",
				i = [9, 13, 32]
		},
		"./src/reddit/constants/zIndex.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "g", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			}));
			const s = 4,
				r = 60,
				o = 70,
				i = 90,
				a = 99,
				d = 100,
				c = 100
		},
		"./src/reddit/contexts/InsideOverlay.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const i = r.a.createContext(!1);

			function a(e) {
				function t(t) {
					return r.a.createElement(i.Consumer, null, n => r.a.createElement(e, o({}, t, {
						isOverlay: n
					})))
				}
				return t.displayName = `WithOverlay(${e.displayName||e.name})`, t
			}
		},
		"./src/reddit/contexts/NavbarExp.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = r.a.createContext(!1)
		},
		"./src/reddit/contexts/Post/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return _
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/constants/posts.ts"),
				a = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				d = n("./src/reddit/hooks/useUserContext.ts"),
				c = n("./src/reddit/models/User/index.ts"),
				l = n("./src/reddit/selectors/posts.ts"),
				u = n("./src/reddit/selectors/subreddit.ts");

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = r.a.createContext(null);

			function b(e) {
				const t = Object(o.e)(t => Object(l.G)(t, {
						postId: e
					})),
					{
						currentUser: n
					} = Object(d.a)();
				let s = Object(o.e)(e => t ? Object(u.Q)(e, {
					identifier: t.belongsTo
				}) : null);
				s || (null == t ? void 0 : t.belongsTo.type) !== i.a.PROFILE || (s = t.profile);
				const r = (null == t ? void 0 : t.belongsTo.type) === i.a.SUBREDDIT ? s : null,
					m = !(!n || (null == t ? void 0 : t.author) !== Object(c.e)(n)),
					p = Object(o.e)(o => ({
						currentUser: n,
						imageGalleryCurrentItem: Object(l.i)(o, {
							postId: e
						}),
						isModerator: !(!r || !o.moderatingSubreddits[r.name]),
						post: t,
						postId: e,
						subreddit: r,
						subredditOrProfile: s,
						userIsOp: m
					}));
				return Object(a.a)(p)
			}

			function f(e) {
				const {
					postId: t,
					children: n
				} = e, s = b(t);
				return r.a.createElement(p.Provider, {
					value: s
				}, n)
			}

			function h(e) {
				const t = e.displayName || e.name;

				function n(n) {
					return r.a.createElement(p.Consumer, null, s => {
						if (!s) throw new Error(`No Post context for <${t}/>!`);
						return r.a.createElement(e, m({}, n, s))
					})
				}
				return n.displayName = `PostContext(${t})`, n
			}

			function _(e) {
				const t = e.displayName || e.name;

				function n(t) {
					const n = b(t.postId);
					return r.a.createElement(p.Provider, {
						value: n
					}, r.a.createElement(e, m({}, t, n)))
				}
				return n.displayName = `PostProvider(${t})`, n
			}
			t.c = p
		},
		"./src/reddit/contexts/User/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/hooks/useMemoShallowEqual.ts"),
				a = n("./src/reddit/reducers/user/prefs/index.ts"),
				d = n("./src/reddit/selectors/user.ts");

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = r.a.createContext({
				currentUser: null,
				modModeEnabled: !1,
				nightmodeEnabled: !1,
				prefs: a.a,
				isLoggedIn: !1
			});

			function u() {
				const e = Object(o.e)(e => ({
					currentUser: Object(d.l)(e),
					modModeEnabled: e.modModeEnabled,
					nightmodeEnabled: Object(d.eb)(e),
					prefs: e.user.prefs,
					isLoggedIn: Object(d.R)(e)
				}));
				return Object(i.a)(e)
			}

			function m(e) {
				return r.a.createElement(l.Provider, {
					value: u()
				}, e.children)
			}

			function p(e) {
				const t = e.displayName || e.name;

				function n(t) {
					return r.a.createElement(l.Consumer, null, n => r.a.createElement(e, c({}, t, n)))
				}
				return n.displayName = `UserContext(${t})`, n
			}
		},
		"./src/reddit/controls/Button/index.m.less": function(e, t, n) {
			e.exports = {
				Button: "_2iuoyPiKHN3kfOoeIQalDT",
				button: "_2iuoyPiKHN3kfOoeIQalDT",
				isFullWidth: "_34mIRHpFtnJ0Sk97S2Z3D9",
				xxsmallButtonStyles: "_1h6qKGhVsgNfytYFlo8m3f",
				Icon: "_1mvTX6krm3Q2d1CSyUm28s",
				icon: "_1mvTX6krm3Q2d1CSyUm28s",
				isLeft: "_1HHR_ND8U6x6YrIqKFeXZy",
				isRight: "_3tKmDp5VAtgWvabEmFkJ7T",
				xsmallButtonStyles: "_3uJP0daPEH2plzVEYyTdaH",
				xsmallBigPaddingButtonStyles: "UEPNkU0rd1-nvbkOcBatc",
				smallButtonStyles: "HNozj_dKjQZ59ZsfEegz8",
				mediumButtonStyles: "_3ukcnQySDskQwK_wB2iXYl",
				largeButtonStyles: "_1J4mN6_wNfCtSyMDUNGQqN",
				xlargeButtonStyles: "XpD6n11mOiKNg8ZKtvgVR",
				primary: "_10BQ7pjWbeYP63SAPNS8Ts",
				active: "_39a0Mt5b1i2joAqIaEHOWJ",
				redditStyle: "_2nelDm85zKKmuD94NequP0",
				DangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				dangerButtonColors: "_1t63zWyh9UUgsyQc6acROM",
				GoldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				goldButtonColors: "_10UWrWSil1Xu6pdSaa_3-K",
				PremiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				premiumButtonColors: "q_unSaY23rpdd3lDvGZ-",
				secondary: "_2tU8R9NTqhvBrhoNAXWWcP",
				tertiary: "_4Glnzr5LA7bNBGMWGW4pU",
				plain: "_3zbhtNO0bdck0oYbYRhjMC",
				isIconOnly: "_1tPpYVD73ugqp4k-VMFRki",
				isSquare: "_3ojSE1JW7jxNzUzZK8kt7m",
				ExtraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				extraSmallBaseButton: "_2v8rCfSRT4mr5y4pwEhX41",
				InlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				inlineTextButton: "_3kfXQpuyMJIMeWQCwjZKfw",
				ChatButton: "_13twe55MPRo1LqypxB-LJx",
				chatButton: "_13twe55MPRo1LqypxB-LJx",
				PlainLinkButton: "_2UhHcZFBOYxMULbf2p-skl",
				plainLinkButton: "_2UhHcZFBOYxMULbf2p-skl"
			}
		},
		"./src/reddit/controls/Button/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "m", (function() {
				return v
			})), n.d(t, "n", (function() {
				return x
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "p", (function() {
				return E
			})), n.d(t, "q", (function() {
				return y
			})), n.d(t, "o", (function() {
				return C
			})), n.d(t, "s", (function() {
				return j
			})), n.d(t, "r", (function() {
				return k
			})), n.d(t, "f", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "k", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "i", (function() {
				return N
			})), n.d(t, "j", (function() {
				return P
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/InternalLink/index.tsx"),
				a = n("./src/reddit/controls/Button/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = {
				role: "button",
				tabIndex: 0
			};
			var u, m, p, b;
			! function(e) {
				e.XXS = "xxsmallButtonStyles", e.XS = "xsmallButtonStyles", e.XSP = "xsmallBigPaddingButtonStyles", e.S = "smallButtonStyles", e.M = "mediumButtonStyles", e.L = "largeButtonStyles", e.XL = "xlargeButtonStyles"
			}(u || (u = {})),
			function(e) {
				e.Primary = "primary", e.Secondary = "secondary", e.Tertiary = "tertiary", e.Plain = "plain", e.PlainLink = "plainLink"
			}(m || (m = {})),
			function(e) {
				e.L = "left", e.R = "right", e.C = "center"
			}(p || (p = {})),
			function(e) {
				e.Button = "button", e.ExternalLink = "external-link", e.InternalLink = "internal-link"
			}(b || (b = {}));
			const f = e => {
					const {
						"data-redditstyle": t,
						Icon: n,
						iconClassName: s,
						iconPosition: i = p.C,
						isFullWidth: a = !1,
						isSquare: f = !1,
						children: v,
						className: x,
						kind: O = b.Button,
						priority: E = m.Primary,
						redditStyle: y,
						size: C = u.S,
						text: j,
						textClassName: k,
						...I
					} = e, S = (e => {
						let {
							baseClassName: t,
							redditStyle: n,
							dataRedditStyle: s,
							Icon: r,
							isFullWidth: i,
							isSquare: a,
							priority: c,
							size: l,
							text: u
						} = e;
						return Object(o.a)(t, d.a.Button, c && d.a[c], l && d.a[l], {
							[d.a.isFullWidth]: i,
							[d.a.isIconOnly]: !!r && !u,
							[d.a.isSquare]: a,
							[d.a.redditStyle]: !(!n && !s)
						})
					})({
						baseClassName: x,
						children: v,
						dataRedditStyle: t,
						Icon: n,
						isFullWidth: a,
						isSquare: f,
						priority: E,
						redditStyle: y,
						size: C,
						text: j
					}), w = (e => {
						let {
							children: t,
							text: n,
							Icon: s,
							iconClassName: i,
							iconPosition: a,
							priority: c,
							textClassName: l
						} = e;
						return !s && n ? r.a.createElement("span", {
							className: l
						}, n) : r.a.createElement(r.a.Fragment, null, s && (a === p.C || a === p.L) && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, i, {
								[d.a.isLeft]: a === p.L
							}),
							isFilled: c === m.Primary
						}), n && r.a.createElement("span", {
							className: Object(o.a)(d.a.Text, l)
						}, n), t && t, s && a === p.R && r.a.createElement(s, {
							className: Object(o.a)(d.a.Icon, i, d.a.isRight),
							isFilled: c === m.Primary
						}))
					})({
						children: v,
						text: j,
						Icon: n,
						iconClassName: s,
						iconPosition: i,
						priority: E,
						textClassName: k
					});
					return O === b.InternalLink && (e => "to" in e)(I) ? r.a.createElement(h, c({}, l, I, {
						className: S
					}), w) : O === b.ExternalLink && (e => "href" in e)(I) ? r.a.createElement(_, c({}, l, I, {
						className: S
					}), w) : r.a.createElement(g, c({}, l, I, {
						className: S
					}), w)
				},
				h = e => r.a.createElement(i.default, e),
				_ = e => r.a.createElement("a", e),
				g = e => r.a.createElement("button", e),
				v = e => r.a.createElement(f, c({
					kind: b.ExternalLink,
					priority: m.Primary
				}, e)),
				x = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Primary
				}, e)),
				O = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Primary
				}, e)),
				E = e => r.a.createElement(f, c({
					kind: b.ExternalLink,
					priority: m.Secondary
				}, e)),
				y = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Secondary
				}, e)),
				C = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Secondary
				}, e)),
				j = e => r.a.createElement(f, c({
					kind: b.InternalLink,
					priority: m.Plain
				}, e)),
				k = e => r.a.createElement(f, c({
					kind: b.Button,
					priority: m.Plain
				}, e)),
				I = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						priority: m.Primary,
						className: Object(o.a)(t, d.a.DangerButtonColors)
					}, n))
				},
				S = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.GoldButtonColors)
					}, n))
				},
				w = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PremiumButtonColors)
					}, n))
				},
				T = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.ChatButton)
					}, n))
				},
				N = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.InlineTextButton)
					}, n))
				},
				P = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(f, c({
						kind: b.Button,
						className: Object(o.a)(t, d.a.PlainLinkButton),
						priority: m.PlainLink
					}, n))
				};
			t.t = f
		},
		"./src/reddit/controls/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				CheckboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				checkboxIcon: "WYS1s7GjzJiaX4fu-xZOJ",
				redditStyle: "J_lIqJrnicKj84OhD29vQ",
				disabled: "n0Me225oxRbL3aLt7kQA8"
			}
		},
		"./src/reddit/controls/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				a = n("./src/reddit/controls/Checkbox/index.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isHalfCheckboxSelected ? "mixed" : e.isCheckboxSelected,
				className: e.className,
				onClick: t => {
					e.toggleCheckbox && (t.stopPropagation(), e.toggleCheckbox())
				},
				disabled: e.disabled
			}, r.a.createElement(i.a, {
				name: e.isHalfCheckboxSelected ? "checkbox_dismiss_fill" : e.isCheckboxSelected ? "checkbox_fill" : "checkbox",
				className: Object(o.a)({
					[d.a.redditStyle]: e.redditStyle,
					[d.a.disabled]: e.disabled
				}),
				style: e.checkBoxStyle
			}))
		},
		"./src/reddit/controls/CheckboxInput/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxInput: "_2BPowd18EKTnfZFrj5kY3G",
				disabled: "_303iMx_S0pgrbpYhsYTV6K",
				checkboxSelected: "_2VtQ8EjxlJXdicVJhc73gQ"
			}
		},
		"./src/reddit/controls/CheckboxInput/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				d = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/CheckboxInput/index.m.less"),
				u = n.n(l);
			t.a = e => {
				const t = e.onChange && !e.disabled ? t => {
						t.key !== i.b.Enter && t.key !== i.b.Space || e.onChange(!e.value)
					} : void 0,
					n = e.onChange && !e.disabled ? () => e.onChange(!e.value) : void 0;
				return r.a.createElement(c.a, {
					"aria-checked": !!e.value,
					"aria-disabled": e.disabled,
					"aria-labelledby": e.name,
					className: Object(o.a)(e.className, u.a.checkboxInput, e.disabled ? u.a.disabled : null),
					onClick: n,
					onKeyPress: t,
					role: "checkbox",
					tabIndex: 0
				}, r.a.createElement("input", {
					value: e.value ? e.value.toString() : "",
					type: "hidden"
				}), e.value ? r.a.createElement(d.a, {
					className: u.a.checkboxSelected
				}) : r.a.createElement(a.a, null), e.children)
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.m.less": function(e, t, n) {
			e.exports = {
				checkboxIcon: "_3Ebr0mkLD0A7HiowzExNW-",
				checkboxMenuItem: "_2eawLPCtwzvTZhWKtaUgZQ",
				expandRight: "_34Odk7t6y-rCPxPcYJa4Nw",
				postCheckboxMenuItem: "_3LyKu57c-QkPvlFvAgWop5"
			}
		},
		"./src/reddit/controls/CheckboxMenuItem/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/index.tsx"),
				a = n("./src/reddit/layout/twoCol/ExpandRight/index.tsx"),
				d = n("./src/reddit/controls/CheckboxMenuItem/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const u = e => r.a.createElement("div", {
					className: Object(o.a)(c.a.checkboxMenuItem, e.className),
					onClick: e.onClick
				}, r.a.createElement(a.a, {
					className: c.a.expandRight
				}, r.a.createElement(i.a, {
					name: "checkbox",
					isFilled: e.isSelected,
					className: c.a.checkboxIcon
				}), e.text)),
				m = e => {
					let {
						className: t,
						...n
					} = e;
					return r.a.createElement(u, l({
						className: Object(o.a)(c.a.postCheckboxMenuItem, t)
					}, n))
				}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_21CrWSXdmd-ue61gDl6zRs",
				checkboxSelected: "_1xT_z2uw_7yX0esEUZVFwf",
				sharedIconStyles: "_1NVucoiiTLKJiKzRTPVKaW",
				checkboxLabel: "_1H6-wE3jxCdsIeXW5AMjj8",
				labelContent: "-kceiAQn0jpWOpu7qZRjD"
			}
		},
		"./src/reddit/controls/CheckboxWithLabel/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.tsx"),
				a = n("./src/reddit/icons/svgs/CheckboxSelected/index.tsx"),
				d = n("./src/reddit/controls/CheckboxWithLabel/index.m.less"),
				c = n.n(d);
			t.a = e => r.a.createElement("button", {
				"aria-checked": e.isSelected,
				"aria-disabled": e.disabled,
				autoFocus: e.autoFocus,
				className: Object(o.a)(c.a.checkboxLabel, e.className),
				disabled: e.disabled,
				onClick: e.onClick,
				type: "button",
				role: "checkbox"
			}, r.a.createElement("span", {
				tabIndex: -1,
				className: c.a.labelContent
			}, e.isSelected ? r.a.createElement(a.a, {
				className: c.a.checkboxSelected
			}) : r.a.createElement(i.a, {
				className: c.a.checkbox
			}), e.text))
		},
		"./src/reddit/controls/ContentType/index.m.less": function(e, t, n) {
			e.exports = {
				contentTypeIcon: "_3CquMWJ6RMh8E9D-_84AtZ"
			}
		},
		"./src/reddit/controls/ContentType/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/constants/icons.ts"),
				a = n("./src/reddit/icons/fonts/index.tsx"),
				d = n("./src/reddit/constants/elementClassNames.ts"),
				c = n("./src/reddit/controls/ContentType/index.m.less"),
				l = n.n(c);
			const u = e => Object(o.a)(l.a.contentTypeIcon, e.className),
				m = {
					embed: i.a.embed,
					gallery: i.a.media_gallery,
					gifvideo: i.a.gif_post,
					image: i.a.image_post,
					meta: i.a.poll_post,
					rpan: i.a.video_live,
					rtjson: i.a.text_post,
					text: i.a.text_post,
					video: i.a.video_post,
					liveaudio: i.a.audio
				};

			function p(e) {
				const t = u(e),
					n = e.type && m[e.type] || i.a.link_post;
				return r.a.createElement(a.a, {
					name: n,
					className: Object(o.a)({
						[d.a]: n === i.a.link_post
					}, t)
				})
			}
		},
		"./src/reddit/controls/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				Downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				downvote: "Q0BxYHtCOJ_rNSPJMU2Y7",
				mIsInteractive: "_2fe-KdD2OM0ciaiux-G1EL",
				mIsActive: "_3emIxnIscWEPB7o5LgU_rn",
				mIsVoteable: "_3yQIOwaIuF6gn8db96Gu7y"
			}
		},
		"./src/reddit/controls/Dropdown/Row.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return _
			}));
			var s = n("./node_modules/lodash/throttle.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/UnstyledInternalLink/index.tsx"),
				c = n("./src/reddit/icons/fonts/DropdownTriangle/index.tsx"),
				l = n("./src/reddit/icons/svgs/Checkmark/index.tsx"),
				u = n("./src/reddit/layout/row/InlineButton/index.tsx"),
				m = n("./src/reddit/controls/Dropdown/index.m.less"),
				p = n.n(m),
				b = n("./src/reddit/controls/Dropdown/row.m.less"),
				f = n.n(b);

			function h() {
				return (h = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class _ extends i.a.Component {
				constructor() {
					super(...arguments), this.handleMouseMove = r()(() => {
						const {
							props: e
						} = this;
						e.handleActivateRow && e.handleActivateRow(e.index)
					}, 500)
				}
				render() {
					const {
						props: e
					} = this, t = e.skipRoleAttr ? null : {
						role: "menuitem"
					}, n = Object(a.a)(f.a.iconWrapper, e.iconWrapperClassName);
					return e.href ? i.a.createElement(d.a, h({}, t, {
						id: e.id,
						className: e.className,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onMouseDown: e.onMouseDown,
						onMouseMove: this.handleMouseMove,
						onKeyDown: e.onKeydown,
						rel: e.rel,
						to: e.href,
						disabled: e.disabled
					}), e.children && i.a.createElement("span", {
						className: n
					}, e.children), i.a.createElement("span", {
						className: Object(a.a)(f.a.text, e.textClassName)
					}, e.displayText)) : i.a.createElement(u.a, h({}, t, {
						id: e.id,
						className: e.className,
						disabled: e.disabled,
						onBlur: e.onBlur,
						onClick: e.onClick,
						onKeyDown: e.onKeydown,
						onMouseDown: e.onMouseDown,
						onMouseMove: r()(this.handleMouseMove, 500)
					}), e.children && (e.noIcon ? i.a.createElement("div", null, e.children) : i.a.createElement("span", {
						className: n
					}, e.children)), e.displayText && i.a.createElement("span", {
						className: Object(a.a)(f.a.text, e.textClassName)
					}, e.displayText), e.showSelectedCheckmark && e.isSelected && i.a.createElement(l.a, {
						className: f.a.checkmark
					}), e.showDropdownTriangle && i.a.createElement(c.a, {
						className: p.a.dropdownTriangle
					}))
				}
			}
			t.b = e => {
				let {
					className: t,
					...n
				} = e;
				const s = Object(a.a)(f.a.row, t, {
					[f.a.mIsInteractive]: !n.noHover,
					[f.a.mIsSelected]: n.isSelected,
					[f.a.topics]: n.isTopicsStyle
				});
				return i.a.createElement(_, h({
					className: s
				}, n))
			}
		},
		"./src/reddit/controls/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownTriangle: "_1oxgVV3q47KbjEKqP5CHuM",
				dropdown: "_2uYY-KeuYHKiwl-9aF0UiL"
			}
		},
		"./src/reddit/controls/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/domUtils/index.ts"),
				a = n("./src/reddit/constants/zIndex.ts"),
				d = n("./src/reddit/controls/Dropdown/index.m.less"),
				c = n.n(d);
			class l extends r.a.Component {
				componentDidMount() {
					this.props.onDropdownMounted && this.props.onDropdownMounted(), this.props.noFocus || this.ref && this.ref.focus({
						preventScroll: this.props.isOverlay
					})
				}
				componentWillUnmount() {
					Object(i.a)(this.props.tooltipId)
				}
				render() {
					const e = this.props,
						t = {};
					return (e.isFixed || e.isOverlay) && (e.isFixed && (t.position = "fixed"), e.isOverlay && (t.zIndex = e.isFixed ? a.d + 1 : a.c)), r.a.createElement("div", {
						className: Object(o.a)(c.a.dropdown, e.className),
						id: this.props.id,
						ref: e => this.ref = e,
						role: "menu",
						style: {
							...t,
							...e.style
						},
						tabIndex: -1,
						onScroll: e.onScroll
					}, e.children)
				}
			}
		},
		"./src/reddit/controls/Dropdown/row.m.less": function(e, t, n) {
			e.exports = {
				iconWrapper: "pthKOcceozMuXLYrLlbL1",
				text: "_2-cXnP74241WI7fpcpfPmg",
				row: "_3LwUIE7yX7CZQKmD2L87vf",
				topics: "kR_ljR-F8vtc-ORj1uipB",
				checkmark: "_3Iua3qlR9JiTwjjk6NKye1",
				muteSubreddit: "ui39KJ4PwbdKkxvIBbLbV",
				modNotes: "sK8_uuNiAqPNlw-HoD2HG",
				mIsSelected: "_1IKtbRloF_LV1hPqMzP3MC",
				mIsInteractive: "_1oYEKCssGFjqxQ9jJMNj5G"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.m.less": function(e, t, n) {
			e.exports = {
				dropdownMenu: "_1PLoXiZH4WKzHTfmYIt34X",
				selector: "apk_M-7ks6NcaiMN8cotM",
				selectorContent: "Ot99igbaJ5id3P1tw6wow",
				disabled: "FVIZ8GUq5tMGZlJ7y28ll",
				compact: "_1qaMsHCBrTmejbIUPjsRVI",
				caretDown: "_2i4dyr-iTBOmkZ4fL_M70P",
				topics: "qWs3cMcSjquK-OXl-9jH5",
				loadingIcon: "_3WxhmmhQ3cYt1J7mtfcoKG",
				menuItems: "_3ssvFhIB2HAXL261eWf7G0",
				isClosed: "_3sZzbLftdYnJNnJ7m7ImmO",
				menuOption: "_1Qm1phX3yfiJHnjgi_O_9V",
				buttonIcon: "_1J0h3Uv7HEaVZiJLcCUlQw"
			}
		},
		"./src/reddit/controls/DropdownSelector/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/controls/DropdownSelector/index.m.less"),
				i = n.n(o),
				a = n("./src/lib/classNames/index.ts"),
				d = n("./src/reddit/controls/Dropdown/Row.tsx"),
				c = n("./src/reddit/controls/LoadingIcon/index.tsx"),
				l = n("./src/reddit/icons/fonts/index.tsx");
			const u = e => {
				e.preventDefault()
			};
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.dropdownButton = r.a.createRef(), this.menuItems = r.a.createRef(), this.containerRef = r.a.createRef(), this.state = {
						isOpen: !1
					}, this.handleDocumentClick = e => {
						this.containerRef && this.containerRef.current && (this.containerRef.current.contains(e.target) || this.setState({
							isOpen: !1
						}))
					}, this.onSelectOption = (e, t, n) => {
						const {
							onSelect: s
						} = this.props;
						e.preventDefault(), e.stopPropagation(), e.nativeEvent.stopPropagation(), s(t), n && this.dropdownButton.current && this.dropdownButton.current.focus(), this.setState({
							isOpen: !1
						})
					}, this.onOptionClick = (e, t) => {
						this.onSelectOption(e, t)
					}, this.handleDropdownClick = e => {
						e.preventDefault(), e.stopPropagation(), this.props.onOpen && this.props.onOpen(), this.setState({
							isOpen: !this.state.isOpen
						})
					}, this.handleDropdownBlur = e => {
						let t = !1;
						if (e.relatedTarget === this.dropdownButton.current) t = !0;
						else {
							if (!this.menuItems.current) return;
							const n = this.menuItems.current.getElementsByClassName(i.a.menuOption);
							for (let s = 0; s < n.length; s++) e.relatedTarget === n[s] && (t = !0)
						}
						this.setState({
							isOpen: t
						})
					}, this.handleDropdownKeyDown = e => {
						if (!this.state.isOpen && [40, 32, 13].includes(e.keyCode)) return e.preventDefault(), void this.setState({
							isOpen: !0
						}, this.focusOnFirstOption);
						40 === e.keyCode && (e.preventDefault(), this.focusOnFirstOption()), 27 === e.keyCode && this.state.isOpen && (e.stopPropagation(), e.nativeEvent.stopPropagation(), e.nativeEvent.stopImmediatePropagation(), this.setState({
							isOpen: !1
						}))
					}, this.handleOptionKeyDown = (e, t) => {
						if (32 === e.keyCode || 13 === e.keyCode) this.onSelectOption(e, t, !0);
						else if (38 === e.keyCode || 40 === e.keyCode) {
							if (e.preventDefault(), !this.menuItems.current) return;
							const t = this.menuItems.current.getElementsByClassName(i.a.menuOption);
							for (let n = 0; n < t.length; n++) t[n] === e.target && (38 === e.keyCode && n > 0 && t[n - 1].focus(), 40 === e.keyCode && n < t.length - 1 && t[n + 1].focus())
						}
					}
				}
				componentDidMount() {
					document.body.addEventListener("click", this.handleDocumentClick, !1)
				}
				componentWillUnmount() {
					document.body.removeEventListener("click", this.handleDocumentClick, !1)
				}
				focusOnFirstOption() {
					if (!this.menuItems.current) return;
					const e = this.menuItems.current.getElementsByClassName(i.a.menuOption);
					e.length && e[0].focus()
				}
				getDropdownMenuItems() {
					const {
						options: e,
						showSelectedCheckmark: t,
						isTopicsStyle: n,
						menuOptionClassName: s
					} = this.props;
					return e.map((e, o) => r.a.createElement(d.b, {
						key: o + e.displayText,
						className: Object(a.a)(i.a.menuOption, s, {
							[i.a.topics]: n
						}),
						noIcon: Boolean(e.icon),
						onKeydown: t => this.handleOptionKeyDown(t, e),
						onMouseDown: t => this.onOptionClick(t, e),
						onBlur: this.handleDropdownBlur,
						showSelectedCheckmark: t,
						isSelected: void 0 !== e.isSelected ? e.isSelected : void 0,
						isTopicsStyle: n
					}, e.icon && e.icon, e.displayText))
				}
				render() {
					const {
						buttonClassName: e,
						className: t,
						displayText: n,
						isCompactStyle: s,
						isTopicsStyle: o,
						menuItemsClassName: d,
						name: m,
						isSaving: p,
						buttonIcon: b,
						disabled: f
					} = this.props, {
						isOpen: h
					} = this.state;
					return r.a.createElement("div", {
						ref: this.containerRef,
						id: this.props.id,
						className: Object(a.a)(i.a.dropdownMenu, t, {
							[i.a.topics]: o
						})
					}, r.a.createElement("button", {
						onClick: f ? void 0 : this.handleDropdownClick,
						className: Object(a.a)(e, i.a.selector, {
							[i.a.compact]: s
						}, {
							[i.a.topics]: o
						}, {
							[i.a.disabled]: f
						}),
						name: m,
						role: "menu",
						ref: this.dropdownButton,
						onBlur: f ? void 0 : this.handleDropdownBlur,
						onKeyDown: f ? void 0 : this.handleDropdownKeyDown
					}, r.a.createElement("span", {
						className: i.a.selectorContent,
						tabIndex: -1
					}, b && r.a.createElement("span", {
						className: i.a.buttonIcon
					}, b), n), f ? null : p ? r.a.createElement(c.a, {
						sizePx: 8,
						className: i.a.loadingIcon
					}) : r.a.createElement(l.a, {
						name: "caret_down"
					})), r.a.createElement("div", {
						className: Object(a.a)(i.a.menuItems, d, {
							[i.a.topics]: o,
							[i.a.isClosed]: !h
						}),
						onMouseDown: u,
						ref: this.menuItems
					}, !f && h && this.getDropdownMenuItems()))
				}
			}
			t.b = m
		},
		"./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2AfJEqW9tv4b_kolKEuS9K",
				titleRow: "p4QfstubN5cRxd-gy8gFH",
				detailsContainer: "_2V3KEAhexNh-mP3TbrVClC",
				buttonRow: "_1fcbQFwN65ik28DNmWnpX4",
				confirmButton: "zcMEJWBL7q-mYGOPSpjN-"
			}
		},
		"./src/reddit/controls/ErrorText/index.m.less": function(e, t, n) {
			e.exports = {
				wrapper: "_2hGJP-9xfXBXd0wqhBLHhY",
				description: "_3h_9YwxjuOr77VhScPrjCI",
				moreText: "_1Y0BrhDgcSTeSYvmSPYepI"
			}
		},
		"./src/reddit/controls/ErrorText/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return x
			})), n.d(t, "c", (function() {
				return O
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/uniqueId.js"),
				o = n.n(r),
				i = n("./node_modules/raf/index.js"),
				a = n.n(i),
				d = n("./node_modules/react/index.js"),
				c = n.n(d),
				l = n("./src/lib/classNames/index.ts"),
				u = n("./src/higherOrderComponents/asModal/index.tsx"),
				m = n("./src/reddit/controls/Button/index.tsx"),
				p = n("./src/reddit/layout/row/Inline/index.tsx"),
				b = n("./src/reddit/controls/ErrorText/SeeAllTextModal/index.m.less"),
				f = n.n(b);
			var h = Object(u.a)(e => {
					const {
						children: t,
						title: n
					} = e;
					return c.a.createElement("div", {
						className: f.a.wrapper
					}, c.a.createElement(p.a, {
						className: f.a.titleRow
					}, n), c.a.createElement("div", {
						className: f.a.detailsContainer
					}, t), c.a.createElement(p.a, {
						className: f.a.buttonRow
					}, c.a.createElement(m.l, {
						className: f.a.confirmButton,
						onClick: e.onConfirmed
					}, s.fbt._("Ok", null, {
						hk: "2Giu9U"
					}))))
				}),
				_ = n("./src/reddit/controls/ErrorText/index.m.less"),
				g = n.n(_);
			class v extends c.a.Component {
				constructor(e) {
					super(e), this.spanRef = c.a.createRef(), this.toggleModal = () => {
						this.setState({
							isModalOpen: !this.state.isModalOpen
						})
					}, this.state = {
						textHasOverflowed: !1,
						modalId: `ErrorTextModal--${o()()}`,
						isModalOpen: !1
					}
				}
				componentDidMount() {
					this.calcTextDidOverflow()
				}
				componentDidUpdate() {
					this.calcTextDidOverflow()
				}
				calcTextDidOverflow() {
					a()(() => {
						const e = this.spanRef.current;
						if (!e) return;
						const t = e.scrollWidth > e.clientWidth;
						this.setState(e => e.textHasOverflowed !== t ? {
							textHasOverflowed: t
						} : null)
					})
				}
				render() {
					const {
						children: e,
						className: t,
						errorModalBody: n,
						errorModalTitle: r = s.fbt._("Error", null, {
							hk: "2nPF4G"
						}),
						moreText: o = s.fbt._("More", null, {
							hk: "1bCAQ0"
						})
					} = this.props, {
						textHasOverflowed: i,
						isModalOpen: a
					} = this.state;
					return c.a.createElement("div", {
						className: Object(l.a)(g.a.wrapper, t)
					}, c.a.createElement("span", {
						className: g.a.description,
						ref: this.spanRef
					}, e), i && c.a.createElement("span", {
						className: g.a.moreText,
						onClick: this.toggleModal
					}, o), a && c.a.createElement(h, {
						onConfirmed: this.toggleModal,
						title: r
					}, n || e))
				}
			}
			const x = e => {
					const {
						className: t,
						errorClassName: n,
						errorModalTitle: s,
						fallbackMessage: r,
						messages: o = []
					} = e, i = o.length ? o : r ? [r] : [];
					return i.length ? c.a.createElement("div", {
						className: t
					}, i.map((e, t) => c.a.createElement(v, {
						className: n,
						errorModalTitle: s,
						key: t
					}, e))) : null
				},
				O = e => c.a.createElement(x, {
					fallbackMessage: s.fbt._("Something went wrong", null, {
						hk: "Cw1BT"
					}),
					messages: e
				});
			t.b = v
		},
		"./src/reddit/controls/FileDrop/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/flow.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-dnd/lib/index.js"),
				d = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				c = n("./src/reddit/helpers/dragDropContext/index.ts");
			const l = d.NativeTypes.FILE,
				u = r()(Object(a.DropTarget)(l, {
					drop: (e, t) => {
						if (t && t.didDrop() || !t) return;
						const n = t.getItem();
						n.files && e.onDrop(n.files)
					}
				}, (e, t) => ({
					connectDropTarget: e.dropTarget(),
					isOver: t.isOver(),
					canDrop: t.canDrop()
				})), c.a);
			class m extends i.a.Component {
				render() {
					return this.props.connectDropTarget ? this.props.connectDropTarget(i.a.createElement("div", {
						className: this.props.className
					}, this.props.render(this.props.isOver, this.props.canDrop))) : null
				}
			}
			t.a = u(m)
		},
		"./src/reddit/controls/FormFields/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3CWuMoFPzdbJCxYJVmEw00",
				label: "J4DegnzzIY1-C2PFzYkrA",
				mHasValue: "t09kxBqaSw0Is_F5sUdQ1",
				inputWrapper: "_3TCLGRXxb1PXK-_sziBD2q",
				mIsInvalid: "_1pMjk4nL9CObVggXCSuELu",
				inputMovingLabelWrapper: "_2-meAmTwsZSCNYrpbEy7BX",
				mIsRedditStyle: "_3ONm7CsU4BtjX9jO5WYv2X",
				trash: "_2YUtyje1Y5rUty_3zgPOGM",
				trashContainer: "_2wjFyjW1rwWs4WFcSc7xNl",
				plus: "_3o11DwChSYlSiDT6FYqOIE",
				addValueButton: "_1Dm7EZTfDne90O5xANs501",
				multiInputWrapper: "_3CjWcr8XyX0xN32ADxPngu",
				errorText: "_2JNX-DiHbrfxhFYgkcBNaK"
			}
		},
		"./src/reddit/controls/FormFields/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return v
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/reddit/controls/ErrorText/index.tsx"),
				d = n("./src/reddit/icons/svgs/Plus/index.tsx"),
				c = n("./src/reddit/icons/svgs/Trash2/index.tsx"),
				l = n("./src/reddit/controls/FormFields/index.m.less"),
				u = n.n(l);

			function m() {
				return (m = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const p = i.a.input("input", u.a),
				b = e => {
					"LABEL" === e.target.tagName && (e.target.parentElement.firstElementChild.focus(), e.stopPropagation())
				},
				f = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						className: i,
						isInvalid: a,
						...d
					} = e;
					const c = void 0 !== d.value && "" !== d.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputWrapper, i, {
							[u.a.mIsInvalid]: a
						}),
						onClick: b
					}, r.a.createElement(p, m({
						"aria-invalid": a,
						innerRef: s
					}, d)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: c
						})
					}, t), n)
				},
				h = e => {
					let {
						label: t,
						children: n,
						inputRef: s,
						isInvalid: i,
						className: a,
						redditStyle: d,
						...c
					} = e;
					const l = void 0 !== c.value && "" !== c.value;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.inputMovingLabelWrapper, a, {
							[u.a.mIsInvalid]: i,
							[u.a.mIsRedditStyle]: d
						}),
						onClick: b
					}, r.a.createElement(p, m({
						innerRef: s
					}, c)), t && r.a.createElement("label", {
						className: Object(o.a)(u.a.label, {
							[u.a.mHasValue]: l
						})
					}, t), n)
				},
				_ = e => r.a.createElement("div", {
					className: Object(o.a)(u.a.addValueButton, e.className),
					onClick: e.onClick
				}, e.text, " ", r.a.createElement(d.a, {
					className: u.a.plus
				}));
			var g;
			! function(e) {
				e[e.ADD = 0] = "ADD", e[e.REMOVE = 1] = "REMOVE"
			}(g || (g = {}));
			class v extends r.a.Component {
				constructor() {
					super(...arguments), this.state = {
						addingNewInputs: !1
					}, this.addValue = () => {
						const e = this.props.values.slice();
						this.props.buttonOnTop ? e.unshift("") : e.push(""), this.props.onChange(e), this.props.onEvent && this.props.onEvent({
							action: g.ADD
						})
					}, this.updateValue = (e, t) => {
						const n = this.props.values.slice();
						n[t] = e.target.value, this.props.onChange(n)
					}, this.removeValue = e => {
						const t = this.props.values.slice(),
							n = t[e];
						t.splice(e, 1), this.props.onChange(t), this.props.onEvent && this.props.onEvent({
							action: g.REMOVE,
							value: n,
							index: e
						})
					}
				}
				componentWillReceiveProps(e) {
					e.values.length > this.props.values.length && this.setState({
						addingNewInputs: !0
					})
				}
				componentDidUpdate() {
					this.focusedInput && this.state.addingNewInputs && (this.focusedInput.focus(), this.setState({
						addingNewInputs: !1
					}))
				}
				setInputRef(e, t) {
					this.state.addingNewInputs && (!this.props.buttonOnTop || this.props.buttonOnTop && !t) && (this.focusedInput = e)
				}
				renderFields() {
					const {
						values: e,
						disabled: t,
						label: n,
						placeholder: s,
						errors: o = []
					} = this.props;
					return e.map((e, i) => r.a.createElement(f, {
						inputRef: e => this.setInputRef(e, i),
						isInvalid: !!o[i],
						disabled: t,
						type: "text",
						label: n,
						onChange: e => this.updateValue(e, i),
						placeholder: s,
						value: e,
						style: {
							paddingRight: "36px"
						}
					}, r.a.createElement("div", {
						className: u.a.trashContainer,
						onClick: () => this.removeValue(i)
					}, r.a.createElement(c.b, {
						className: u.a.trash
					})), !!o[i] && r.a.createElement(a.b, {
						className: u.a.errorText
					}, o[i])))
				}
				render() {
					const {
						className: e,
						buttonOnTop: t,
						values: n,
						maxLength: s,
						addValueText: i,
						disabled: a
					} = this.props;
					this.focusedInput = null;
					const d = !(!!s && n.length >= s) && !a;
					return r.a.createElement("div", {
						className: Object(o.a)(u.a.multiInputWrapper, e)
					}, t && d && r.a.createElement(_, {
						onClick: this.addValue,
						text: i
					}), this.renderFields(), !t && d && r.a.createElement(_, {
						onClick: this.addValue,
						text: i
					}))
				}
			}
		},
		"./src/reddit/controls/ImageDisplay/index.m.less": function(e, t, n) {
			e.exports = {
				imageDisplay: "_1OSym2TYADlQNpSDWNxtjB"
			}
		},
		"./src/reddit/controls/ImageDisplay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/ImageDisplay/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					backgroundImage: t,
					children: n,
					className: s
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.imageDisplay, s),
					style: {
						backgroundImage: `url('${t}')`
					},
					children: n
				})
			}
		},
		"./src/reddit/controls/ImageInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			class o extends r.a.Component {
				constructor(e) {
					super(e), this.onFileInput = e => {
						const t = e.currentTarget.files,
							n = this.props.multiple ? [...t] : t[0];
						this.props.onChange(n), this.setState(() => ({
							value: n
						}))
					}, this.state = {
						value: e.value || ""
					}
				}
				static getDerivedStateFromProps(e, t) {
					return {
						value: t.value || e.value || ""
					}
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = "string" == typeof t.value ? t.value : "", s = "object" == typeof t.value ? t.value : null, o = n || s;
					return r.a.createElement("div", {
						className: e.className
					}, n && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						readOnly: !0,
						type: "text",
						value: n,
						tabIndex: e.tabIndex
					}), (!o || e.multiple || void 0 !== e.isPending && !e.isPending) && r.a.createElement("input", {
						id: e.inputId,
						ref: e.inputRef,
						name: e.name,
						type: "file",
						onChange: this.onFileInput,
						accept: "image/x-png,image/jpeg",
						multiple: e.multiple || !1,
						tabIndex: e.tabIndex
					}))
				}
			}
		},
		"./src/reddit/controls/Input/ModalInput.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/actions/modal.ts"),
				d = n("./src/reddit/constants/keycodes.ts"),
				c = n("./src/reddit/controls/Input/index.m.less"),
				l = n.n(c);

			function u() {
				return (u = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.handleKeyDown = e => {
						let {
							keyCode: t
						} = e;
						t === d.a.Escape && this.props.closeModal()
					}
				}
				render() {
					const {
						className: e,
						closeModal: t,
						...n
					} = this.props;
					return r.a.createElement("input", u({
						className: Object(i.a)(l.a.input, e),
						onKeyDown: this.handleKeyDown
					}, n))
				}
			}
			t.a = Object(o.b)(null, {
				closeModal: a.f
			})(m)
		},
		"./src/reddit/controls/Input/index.m.less": function(e, t, n) {
			e.exports = {
				input: "_3eoXtlBWKbkFYoOHUIcIgK"
			}
		},
		"./src/reddit/controls/Input/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Input/index.m.less"),
				o = n.n(r);
			t.a = s.a.input("input", o.a)
		},
		"./src/reddit/controls/InternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				disabledLink: "_1tQt2CUWT3M7NNSMoh_o_4"
			}
		},
		"./src/reddit/controls/InternalLink/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "default", (function() {
				return u
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-router-dom/esm/react-router-dom.js"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/helpers/path/index.ts"),
				d = n("./src/reddit/controls/InternalLink/index.m.less"),
				c = n.n(d);

			function l() {
				return (l = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}

			function u(e) {
				let {
					children: t,
					className: n,
					disabled: s,
					replace: d,
					to: u,
					...m
				} = e;
				return s ? r.a.createElement("span", {
					className: Object(i.a)(c.a.disabledLink, n)
				}, t) : ("string" == typeof u && (u = Object(a.b)(u)), r.a.createElement(o.a, l({
					className: n,
					to: u
				}, m), t))
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.m.less": function(e, t, n) {
			e.exports = {
				invisibleText: "_1RIl585IYPW6cmNXwgRz0J"
			}
		},
		"./src/reddit/controls/InvisibleScreenReaderText/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InvisibleScreenReaderText/index.m.less"),
				o = n.n(r);
			t.a = s.a.span("invisibleText", o.a)
		},
		"./src/reddit/controls/LoadingIcon/index.m.less": function(e, t, n) {
			e.exports = {
				loadingIcon: "_3LwT7hgGcSjmJ7ng7drAuq",
				spin: "ibDwUVR1CAykturOgqOS5",
				mCentered: "_2qr28EeyPvBWAsPKl-KuWN"
			}
		},
		"./src/reddit/controls/LoadingIcon/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/LoadingIcon/index.m.less"),
				a = n.n(i);
			t.a = e => {
				let {
					center: t,
					className: n,
					sizePx: s = 10
				} = e;
				return r.a.createElement("div", {
					className: Object(o.a)(a.a.loadingIcon, n, {
						[a.a.mCentered]: t
					}),
					style: {
						"--sizePx": `${s}px`
					},
					"data-testid": "LoadingIcon"
				})
			}
		},
		"./src/reddit/controls/MetaData/index.m.less": function(e, t, n) {
			e.exports = {
				metaText: "_2ETuFsVzMBxiHia6HfJCTQ"
			}
		},
		"./src/reddit/controls/MetaData/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/lib/lessComponent.tsx"),
				a = n("./src/lib/prettyPrintNumber/index.ts"),
				d = (n("./src/lib/timeAgo/index.ts"), n("./src/reddit/controls/MetaData/index.m.less")),
				c = n.n(d);
			const l = i.a.span("metaText", c.a),
				u = e => o.a.createElement(l, e, " · "),
				m = e => {
					let {
						isScoreHidden: t,
						score: n,
						useUpvotes: r,
						...i
					} = e;
					const d = Object(a.b)(n),
						c = s.fbt._({
							"*": "{number} upvotes",
							_1: "1 upvote"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "2L3T21"
						}),
						u = t ? s.fbt._("Score hidden", null, {
							hk: "SDk6B"
						}) : r ? c : s.fbt._({
							"*": "{number} points",
							_1: "1 point"
						}, [s.fbt._plural(n, "number", d)], {
							hk: "gf67v"
						});
					return o.a.createElement(l, i, u)
				},
				p = e => o.a.createElement(l, null, s.fbt._({
					"*": "{number} comments",
					_1: "1 comment"
				}, [s.fbt._plural(e, "number", Object(a.b)(e))], {
					hk: "3bVMk9"
				}))
		},
		"./src/reddit/controls/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return I
			})), n.d(t, "c", (function() {
				return S
			}));
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./node_modules/query-string/index.js"),
				i = n.n(o),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./node_modules/reselect/es/index.js"),
				u = n("./src/lib/addQueryParams/index.ts");
			var m = (e, t) => t ? Object(u.a)(e, {
				user_id: t
			}) : e;
			var p = n("./src/lib/opener/index.ts"),
				b = n("./src/lib/redditId/index.ts"),
				f = n("./src/reddit/actions/post.ts"),
				h = n("./src/reddit/constants/adEvents.ts"),
				_ = n("./src/reddit/helpers/getVendorMetadata.ts"),
				g = n("./src/reddit/helpers/trackers/ads.ts"),
				v = n("./src/reddit/hooks/useOutboundClickTracking.ts"),
				x = n("./src/reddit/selectors/posts.ts"),
				O = n("./src/reddit/selectors/telemetry.ts"),
				E = n("./src/reddit/selectors/user.ts");

			function y() {
				return (y = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const C = Object(l.a)(E.b, E.l, (e, t) => {
					let {
						isSponsored: n,
						postId: s
					} = t;
					return n && s ? Object(x.b)(e, s) : null
				}, x.G, O.d, (e, t, n, s, r) => ({
					allowClickTracking: e,
					basePixelMetadata: n,
					userId: t ? Object(b.a)(t.id) : null,
					post: s,
					pageType: r.pageType
				})),
				j = Object(c.b)(C, e => ({
					fireAdPixelsOfType: (t, n) => e(Object(f.y)(t, n))
				})),
				k = (e, t, n, s) => {
					const r = t.outboundUrlExpiration && t.outboundUrlExpiration > Date.now();
					s && t.outboundUrl && r && (e.href = m(t.outboundUrl, n), e.href = function(e) {
						return Object(u.a)(e, {
							web_redirect: "true"
						})
					}(e.href))
				},
				I = (e, t, n) => {
					let s, r = null;
					if (e && t && /^(http|https):\/\/([a-z]+\.)?reddit.com/.test(n)) {
						r = Object(_.a)(e, t, h.a.Click);
						const {
							url: o,
							query: a
						} = i.a.parseUrl(n);
						s = i.a.stringifyUrl({
							url: o,
							query: {
								...a,
								...r
							}
						})
					} else s = n;
					return {
						url: s,
						metadata: r
					}
				},
				S = (e, t, n) => {
					const s = I(t, n, e.href);
					return e.href = s.url, s.metadata
				},
				w = e => {
					let {
						isSponsored: t,
						source: n
					} = e;
					return !!(t && (null == n ? void 0 : n.outboundUrl))
				},
				T = j(e => {
					const t = Object(a.useRef)(null),
						n = Object(v.a)(),
						{
							allowClickTracking: s,
							basePixelMetadata: o,
							commentId: i,
							fireAdPixelsOfType: c,
							href: l,
							isSponsored: u,
							pageType: m,
							post: b,
							postId: f,
							source: _,
							sourceElement: x,
							userId: O
						} = e;
					let E = r()(e, ["allowClickTracking", "basePixelMetadata", "fireAdPixelsOfType", "isSponsored", "postId", "post", "commentId", "source", "sourceElement", "userId", "pageType"]);
					const C = _ && _.outboundUrl && u ? _.outboundUrl : l;
					return E = {
						...E,
						href: C,
						rel: u ? p.b : p.a,
						target: p.d.BLANK
					}, !_ || (e => {
						const {
							outboundUrlCreated: t,
							outboundUrlReceived: n
						} = e;
						return !(!t || !n) && (t > n + 3e5 || t < n - 36e5)
					})(_) ? d.a.createElement("a", y({}, E, {
						onClick: () => n(l, x, i, f)
					})) : d.a.createElement("a", y({}, E, {
						onMouseDown: n => {
							if (!w(e)) return !(1 !== n.button && 2 !== n.button && !n.ctrlKey) || void k(n.currentTarget, _, O, s);
							t.current = S(n.currentTarget, f, o)
						},
						onClick: () => {
							b && (w(e) && Object(g.a)(b, m), c(b, h.a.Click), n(l, x, i, f))
						},
						onMouseLeave: e => {
							u || ((e, t) => {
								e.href = t
							})(e.currentTarget, C)
						},
						onTouchStart: e => k(e.currentTarget, _, O, s),
						"data-testid": "outbound-link"
					}))
				});
			t.b = T
		},
		"./src/reddit/controls/OutboundLink/styled.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/constants/elementClassNames.ts"),
				o = n("./src/reddit/controls/OutboundLink/index.tsx"),
				i = n("./src/reddit/controls/OutboundLink/styles.m.less"),
				a = n.n(i);
			t.a = s.a.wrapped(o.b, "styledOutboundLink", {
				styledOutboundLink: `${a.a.styledOutboundLink} ${r.l}`
			})
		},
		"./src/reddit/controls/OutboundLink/styles.m.less": function(e, t, n) {
			e.exports = {
				styledOutboundLink: "_13svhQIUZqD9PVzFcLwOKT"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.m.less": function(e, t, n) {
			e.exports = {
				radioOption: "_2e6fJknJ4noSygWYov8-F1",
				radioOff: "_1lzSnSABNXX12WerTnwqI3",
				radioOn: "_3PYsg_uRJ6AGptv-hi7kqu"
			}
		},
		"./src/reddit/controls/RadioInput/RadioOption/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/constants/keycodes.ts"),
				a = n("./src/reddit/icons/svgs/RadioOff/index.tsx"),
				d = n("./src/reddit/icons/svgs/RadioOn/index.tsx"),
				c = n("./src/reddit/layout/row/Inline/index.tsx"),
				l = n("./src/reddit/controls/RadioInput/RadioOption/index.m.less"),
				u = n.n(l);
			class m extends r.a.Component {
				constructor() {
					super(...arguments), this.ref = null, this.onKeyPress = e => {
						const {
							props: t
						} = this;
						t.disabled || e.key !== i.b.Enter && e.key !== i.b.Space || (t.onClick && t.onClick(t.value), e.preventDefault())
					}
				}
				componentDidUpdate(e) {
					this.props.selected && !e.selected && this.ref && this.ref.focus()
				}
				render() {
					const {
						props: e
					} = this;
					return e.hidden ? null : r.a.createElement(c.a, {
						"aria-checked": e.selected,
						className: Object(o.a)(e.className, u.a.radioOption),
						innerRef: e => this.ref = e,
						onClick: e.disabled ? void 0 : e.onClick,
						onKeyPress: this.onKeyPress,
						role: "radio",
						tabIndex: e.tabIndex
					}, e.showButton && (e.selected ? r.a.createElement(d.a, {
						className: u.a.radioOn,
						role: "presentation"
					}) : r.a.createElement(a.a, {
						className: u.a.radioOff,
						role: "presentation"
					})), e.children)
				}
			}
			t.a = m
		},
		"./src/reddit/controls/RadioInput/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/keycodes.ts");
			class i extends r.a.Component {
				constructor(e) {
					super(e), this.handleClick = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props;
						t || this.state.value !== e && (n(e), this.setState({
							value: e
						}))
					}, this.getValues = () => {
						const e = [];
						return r.a.Children.forEach(this.props.children, t => {
							t.props.hidden || t.props.disabled || e.push(t.props.value)
						}), e
					}, this.onKeyDown = e => {
						const {
							disabled: t,
							onChange: n
						} = this.props, {
							value: s
						} = this.state;
						if (t) return;
						const r = e.key === o.b.ArrowUp,
							i = e.key === o.b.ArrowDown;
						if (r || i) {
							const t = this.getValues();
							if (!t.length) return;
							const o = s ? t.indexOf(s) : 0,
								i = t[((r ? o - 1 : o + 1) + t.length) % t.length];
							n(i), this.setState({
								value: i
							}), e.preventDefault()
						}
					}, this.state = {
						value: e.value || null
					}
				}
				UNSAFE_componentWillReceiveProps(e) {
					e.value !== this.props.value && this.setState({
						value: e.value || null
					})
				}
				render() {
					const {
						props: e
					} = this, {
						value: t
					} = this.state;
					return r.a.createElement("div", {
						"aria-label": e.name,
						className: e.className,
						role: "radiogroup",
						onKeyDown: this.onKeyDown
					}, r.a.createElement("input", {
						disabled: e.disabled,
						type: "hidden",
						value: t || ""
					}), r.a.Children.map(e.children, (n, s) => {
						const o = 0 === s,
							i = n.props.value === t,
							a = null !== t ? i ? 0 : -1 : o ? 0 : -1;
						return r.a.cloneElement(n, {
							disabled: e.disabled,
							onClick: e => this.handleClick(n.props.value),
							selected: i,
							tabIndex: a
						})
					}))
				}
			}
		},
		"./src/reddit/controls/Score/index.m.less": function(e, t, n) {
			e.exports = {
				score: "_1rZYMD_4xY3gRcSS3p8ODO",
				dot: "uFieChpcVxrPI9VvCKqZu",
				viewCount: "_3bAGP2FKe97ijgBAGQOYsk"
			}
		},
		"./src/reddit/controls/Score/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/classNames/index.ts"),
				o = n("./src/lib/CSSVariableProvider/withTheme.tsx"),
				i = n("./src/lib/prettyPrintNumber/index.ts"),
				a = n("./node_modules/react/index.js"),
				d = n.n(a),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/reddit/actions/post.ts"),
				u = n("./src/reddit/components/CountAnimation/index.tsx"),
				m = n("./src/reddit/components/InfoTextTooltip/Hooked.tsx"),
				p = n("./src/reddit/components/PostContent/ViewCount.tsx"),
				b = n("./src/reddit/constants/colors.ts"),
				f = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				h = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				_ = n("./src/reddit/hooks/useInfoTextTooltip.ts"),
				g = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				v = n("./src/reddit/models/Vote/index.ts"),
				x = n("./src/reddit/selectors/experiments/postActionBarAnimation.ts"),
				O = n("./src/reddit/selectors/meta.ts"),
				E = n("./src/reddit/selectors/posts.ts"),
				y = n("./node_modules/reselect/es/index.js"),
				C = n("./src/reddit/controls/Score/index.m.less"),
				j = n.n(C);
			const k = {
					placement: "right"
				},
				I = e => e.voteState === v.a.downvoted ? Object(g.a)(e).voteText.downvote : e.voteState === v.a.upvoted ? Object(g.a)(e).voteText.upvote : Object(h.a)(Object(f.a)(e)),
				S = Object(y.c)({
					locale: e => Object(O.j)(e),
					post: (e, t) => {
						let {
							shouldShowUpvoteRatioOnHover: n,
							postId: s
						} = t;
						if (n && s) return Object(E.G)(e, {
							postId: s
						})
					}
				}),
				w = () => 0,
				T = Object(c.b)(S),
				N = Object(o.a)(e => {
					const t = {
							color: e.light ? b.a.lightboxHeaderText : I(e)
						},
						{
							score: n,
							postId: o = "",
							locale: f,
							isVoteCountAnimation: h,
							isCountAnimShadowTestEnabled: g,
							shouldShowUpvoteRatioOnHover: v,
							post: O
						} = e,
						E = Object(c.d)(),
						y = null == f ? void 0 : f.startsWith("en"),
						C = e.isScoreHidden ? y ? s.fbt._("Vote", null, {
							hk: "2TMson"
						}) : d.a.createElement("span", {
							className: j.a.dot
						}, "•") : Object(i.b)(n),
						S = Object(a.useCallback)(e => {
							const {
								voteCountChange: t
							} = e.subscribe.data;
							0 !== t && E(Object(l.H)({
								postId: o,
								delta: t
							}))
						}, [E, o]),
						T = Object(a.useRef)({
							input: {
								channel: {
									teamOwner: "CONTENT_AND_COMMUNITIES",
									category: "VOTE_COUNT_UPDATE",
									postID: o
								}
							}
						}),
						N = !e.isScoreHidden && h && n < x.a,
						P = Object(_.a)(k),
						R = n < 0 ? 0 : n;
					return d.a.createElement("div", {
						className: Object(r.a)(j.a.score, e.className),
						style: e.disableInlineColor ? void 0 : t,
						onMouseEnter: v ? P.show : void 0,
						onMouseLeave: v ? P.hide : void 0,
						ref: v ? P.target.ref : void 0
					}, (N || g) && d.a.createElement(d.a.Fragment, null, d.a.createElement(u.b, {
						initialDisplayCount: R,
						countToUpperBound: R,
						initialDelay: w,
						subsequentRecurringDelay: w,
						incrementDelta: w,
						shouldDisjointAnimation: !0,
						postId: o,
						featureName: u.a.Vote,
						queryKey: "postVoteCount",
						queryVariables: T.current,
						onDataCB: S,
						isLoadTestOnly: g && !N
					})), !N && C, v && O && d.a.createElement(m.a, P, d.a.createElement(p.a, {
						className: j.a.viewCount,
						post: O,
						showViewCount: !1
					})))
				});
			t.a = T(N)
		},
		"./src/reddit/controls/SearchBar/index.m.less": function(e, t, n) {
			e.exports = {
				searchContainer: "_13yLxNALfY3_F48PYybgUr",
				search: "RxQA71ktKLBiPThTT7ita",
				mRightAlignedIcon: "_1NR83qzzPFX9KcVm-fxGFg",
				searchIconContainer: "_1IUrembT3LfQzzy388S8eF",
				mClickable: "_1K9n38-jQENV0_njgPIo_x",
				mRightAligned: "_1fLhMe5y6XbNg-lgHQrh5e"
			}
		},
		"./src/reddit/controls/SearchBar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Search/index.tsx"),
				a = n("./src/reddit/controls/SearchBar/index.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("label", {
				className: Object(o.a)(d.a.searchContainer, e.className)
			}, r.a.createElement("input", {
				"data-testid": "SEARCH_BAR_TEST_ID",
				className: Object(o.a)(d.a.search, {
					[d.a.mRightAlignedIcon]: e.rightAlignedIcon
				}),
				autoFocus: e.autoFocus,
				type: "text",
				onChange: e.onTextChange,
				onKeyPress: e.onKeyPress,
				placeholder: e.placeholder,
				ref: e.innerRef,
				value: e.value
			}), r.a.createElement("div", {
				className: Object(o.a)(d.a.searchIconContainer, {
					[d.a.mClickable]: !!e.onSearch,
					[d.a.mRightAligned]: e.rightAlignedIcon
				}),
				role: e.onSearch && "submit",
				onClick: e.onSearch
			}, r.a.createElement(i.a, null)))
		},
		"./src/reddit/controls/Select/index.m.less": function(e, t, n) {
			e.exports = {
				Wrapper: "DuuuuIp9EubfvJyrdxytL",
				wrapper: "DuuuuIp9EubfvJyrdxytL",
				Caret: "_8fOXBcWxu_c3tlrAKMR3R",
				caret: "_8fOXBcWxu_c3tlrAKMR3R",
				Inner: "_3-_epznhOfLDNH3-plYM6l",
				inner: "_3-_epznhOfLDNH3-plYM6l",
				active: "wFEhEmBm9HI3jG6QDUnaw",
				redditStyle: "_2PDExzXmSTOdxzNjRB1Pww"
			}
		},
		"./src/reddit/controls/Sortable/index.tsx": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/helpers/dragDropContext/index.ts"),
				i = n("./node_modules/lodash/flow.js"),
				a = n.n(i),
				d = n("./node_modules/react-dnd/lib/index.js");
			class c extends r.a.Component {
				constructor() {
					super(...arguments), this.handleClick = () => {
						this.props.onClick && this.props.onClick(this.props.id, this.props.index)
					}
				}
				render() {
					const {
						props: e
					} = this;
					return e.connectDropTarget && e.connectDragSource ? a()(e.connectDropTarget, e.connectDragSource)(r.a.createElement("div", {
						onClick: this.handleClick
					}, e.render(e.id, e.index, e.isDragging, e.isOver, e.canDrop))) : null
				}
			}
			var l = a()(Object(d.DragSource)("card", {
				beginDrag: e => ({
					id: e.id,
					index: e.index
				}),
				endDrag: (e, t) => {
					if (t && t.didDrop()) {
						const n = t.getDropResult();
						e.onDrop(e.id, n.id)
					}
				}
			}, (e, t) => ({
				connectDragSource: e.dragSource(),
				isDragging: t.isDragging()
			})), Object(d.DropTarget)("card", {
				drop: (e, t) => {
					if (!t || !t.didDrop()) return {
						id: e.id,
						index: e.index
					}
				},
				canDrop: (e, t) => {
					if (!t) return !1;
					const n = t.getItem();
					return e.id !== n.id
				}
			}, (e, t) => ({
				connectDropTarget: e.dropTarget(),
				isOver: t.isOver(),
				canDrop: t.canDrop()
			})))(c);
			class u extends r.a.Component {
				constructor(e) {
					super(e), this.onDrop = (e, t) => {
						this.setState(n => {
							const s = n.values.slice(),
								r = s.indexOf(e),
								o = s.splice(r, 1)[0];
							let i = s.indexOf(t);
							return r <= i && (i += 1), s.splice(i, 0, o), this.props.onDrop(e, t, s), {
								values: s
							}
						})
					}, this.state = {
						values: e.values
					}
				}
				componentWillReceiveProps(e) {
					this.setState(() => ({
						values: e.values
					}))
				}
				render() {
					const {
						className: e,
						getReactKey: t,
						onClick: n,
						render: s
					} = this.props;
					return r.a.createElement("div", {
						className: e
					}, this.state.values.map((e, o) => r.a.createElement(l, {
						id: e,
						key: t && t(e, o),
						index: o,
						render: s,
						onDrop: this.onDrop,
						onClick: n
					})))
				}
			}
			t.a = Object(o.a)(u)
		},
		"./src/reddit/controls/TextButton/index.m.less": function(e, t, n) {
			e.exports = {
				textButton: "qYzY57HWQ8W424hj3s10-"
			}
		},
		"./src/reddit/controls/TextButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/TextButton/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("button", {
				children: e.children,
				className: Object(o.a)(a.a.textButton, e.className),
				disabled: e.disabled,
				onClick: e.onClick
			})
		},
		"./src/reddit/controls/ToggleSwitch/index.m.less": function(e, t, n) {
			e.exports = {
				toggleDisplay: "_2FKpII1jz0h6xCAw1kQAvS",
				toggleSwitch: "_2e2g485kpErHhJQUiyvvC2",
				redditStyle: "_3kUvbpMbR21zJBboDdBH7D",
				mActive: "_1L5kUnhRYhUJ4TkMbOTKkI",
				mDisabled: "_3clF3xRMqSWmoBQpXv8U5z",
				xs: "_1asGWL2_XadHoBuUlNArOq",
				s: "_1hku5xiXsbqzLmszstPyR3",
				m: "_10hZCcuqkss2sf5UbBMCSD",
				l: "_1fCdbQCDv6tiX242k80-LO",
				xl: "_2Jp5Pv4tgpAsTcnUzTsXgO"
			}
		},
		"./src/reddit/controls/ToggleSwitch/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/controls/ToggleSwitch/index.m.less"),
				d = n.n(a);
			t.a = Object(s.memo)(Object(s.forwardRef)((e, t) => {
				const n = e.size || i.d.XS;
				return r.a.createElement("button", {
					"aria-checked": e.on,
					className: Object(o.a)(d.a.toggleSwitch, e.className, {
						[d.a.xs]: n === i.d.XS,
						[d.a.s]: n === i.d.S,
						[d.a.m]: n === i.d.M,
						[d.a.l]: n === i.d.L,
						[d.a.xl]: n === i.d.XL,
						[d.a.mActive]: e.on && !e.disabled || e.forceOn && e.on,
						[d.a.mDisabled]: e.disabled,
						[d.a.redditStyle]: e.redditStyle
					}),
					style: e.on && !e.disabled && e.activeColorOverride ? {
						backgroundColor: e.activeColorOverride
					} : void 0,
					id: e.id,
					role: "switch",
					tabIndex: e.tabIndex,
					type: "button",
					onClick: () => !e.disabled && e.onToggle && e.onToggle(),
					ref: t
				}, r.a.createElement("div", {
					className: d.a.toggleDisplay
				}))
			}))
		},
		"./src/reddit/controls/Typography/index.m.less": function(e, t, n) {
			e.exports = {
				heading1: "_37JeV292IJA7_x1qej_-2H",
				heading2: "p13k-tsMcatGBlVpJBZmw",
				heading3: "_1nHvvYpmn7q9eWDAGzKcce",
				heading4: "_1-rwUWsB5F8WmYI8F66dai",
				heading5: "_22RKdGqihAj6MFumW6DuRV",
				heading6: "_4xqrI_N1UdqsK9E1RSisG",
				body1: "_2HJOIn4SJm4z1NeCv_hNFu",
				body2: "_3ImIPX9rfoPmUrZ1R8KGqS",
				actionFont: "_3uShGanwyVFBaTiPMFzfAC",
				metadata: "_2nyJGeaFJbXTqTh9OGwxfu",
				metadata3: "_3BIqvjJkJKZfH4vtC11dGF"
			}
		},
		"./src/reddit/controls/Typography/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/Typography/index.m.less"),
				o = n.n(r);
			s.a.h1("heading1", o.a), s.a.h2("heading2", o.a), s.a.h3("heading3", o.a), s.a.h4("heading4", o.a);
			const i = s.a.h5("heading5", o.a),
				a = (s.a.h6("heading6", o.a), s.a.p("body1", o.a), s.a.p("body2", o.a)),
				d = (s.a.p("actionFont", o.a), s.a.p("metadata", o.a));
			s.a.p("metadata3", o.a)
		},
		"./src/reddit/controls/UnstyledInternalLink/index.m.less": function(e, t, n) {
			e.exports = {
				unstyledInternalLink: "_39Glgtoolpdt4PIzcnjPSW"
			}
		},
		"./src/reddit/controls/UnstyledInternalLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/controls/InternalLink/index.tsx"),
				o = n("./src/reddit/controls/UnstyledInternalLink/index.m.less"),
				i = n.n(o);
			t.a = s.a.wrapped(r.default, "unstyledInternalLink", i.a)
		},
		"./src/reddit/controls/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				Upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				upvote: "_3SUsITjKNQ7Tp0Wi2jGxIM",
				mIsInteractive: "qW0l8Af61EP35WIG6vnGk",
				mIsActive: "Z3lT0VGlALek4Q9j0ZQCr",
				mIsVoteable: "_3edNsMs0PNfyQYofMNVhsG"
			}
		},
		"./src/reddit/customMiddleware/recentSubreddits.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/chat/customMiddleware/noop.ts"),
				r = n("./src/lib/cache/index.ts"),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/localStorageAvailable/index.ts"),
				a = n("./src/reddit/actions/recentSubreddits/constants.ts");
			const d = Object(r.c)(o.t.RECENT_SUBREDDITS, "recent_subreddits"),
				c = () => Object(i.a)() && Object(r.b)(d) || [];
			t.a = e => "undefined" == typeof window ? s.a : e => t => {
				const n = e(t);
				switch (t.type) {
					case a.e: {
						const e = c() || [],
							n = {
								...t.payload,
								lastVisited: Date.now()
							},
							{
								id: s
							} = n;
						if (s) {
							const t = e.findIndex(e => e.id === s); - 1 !== t && e.splice(t, 1), e.unshift(n), e.splice(a.c), Object(r.d)(d, e, o.ub)
						}
						break
					}
				}
				return n
			}
		},
		"./src/reddit/endpoints/comment/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return v
			})), n.d(t, "m", (function() {
				return x
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			})), n.d(t, "h", (function() {
				return C
			})), n.d(t, "e", (function() {
				return j
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "j", (function() {
				return I
			})), n.d(t, "g", (function() {
				return S
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "d", (function() {
				return N
			})), n.d(t, "b", (function() {
				return P
			}));
			var s = n("./src/config.ts"),
				r = n("./src/redditGQL/operations/ModApprove.json"),
				o = n("./src/redditGQL/operations/ModRemove.json"),
				i = n("./src/redditGQL/operations/UpdateCommentDistinguishState.json"),
				a = n("./src/redditGQL/operations/UpdateCommentStickyState.json"),
				d = n("./src/redditGQL/types.ts"),
				c = n("./src/lib/constants/index.ts"),
				l = n("./src/lib/makeApiRequest/index.ts"),
				u = n("./src/lib/makeGqlRequest/index.ts"),
				m = n("./src/lib/omitHeaders/index.ts"),
				p = n("./src/reddit/constants/headers.ts"),
				b = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				f = n("./src/reddit/models/Comment/addProfileImgParam.ts"),
				h = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				_ = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				g = n("./src/redditGQL/operations/GetCommentById.json");
			const v = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/save`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				x = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unsave`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				O = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/lock`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				E = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: Object(b.a)(`${e.apiUrl}/api/unlock`),
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				y = (e, t) => Object(u.a)(e, {
					...r,
					variables: {
						input: {
							id: t
						}
					}
				}),
				C = (e, t, n) => Object(u.a)(e, {
					...o,
					variables: {
						input: {
							id: t,
							isSpam: n
						}
					}
				}),
				j = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/ignore_reports`,
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				k = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/unignore_reports`,
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				I = (e, t) => Object(l.a)(Object(m.a)(e, [p.a]), {
					endpoint: `${e.apiUrl}/api/show_comment`,
					method: c.ob.POST,
					data: {
						id: t
					}
				}),
				S = (e, t, n, r) => {
					let o = Object(b.a)(Object(_.a)(Object(h.a)(`${s.a.gatewayUrl}/desktopapi/v1/morecomments/${t}`)));
					return r && (o = Object(f.a)(o)), Object(l.a)(e, {
						data: n,
						endpoint: o,
						method: c.ob.POST,
						type: "json",
						traceRequestName: "more_comments"
					})
				},
				w = {
					[c.J.NONE]: d.n.None,
					[c.J.MODERATOR]: d.n.ModDistinguished,
					[c.J.ADMIN]: d.n.AdminDistinguished,
					[c.J.ALUMNI_ADMIN]: d.n.AlumniDistinguished
				};

			function T(e, t, n) {
				const s = function(e, t) {
					return {
						input: {
							commentId: e,
							distinguishState: t === c.J.NONE ? d.e.None : d.e.Distinguished,
							distinguishType: w[t]
						}
					}
				}(t, n);
				return Object(u.a)(e, {
					...i,
					variables: s
				})
			}

			function N(e, t, n) {
				return Object(u.a)(e, {
					...a,
					variables: {
						input: {
							commentId: t,
							sticky: n
						}
					}
				})
			}
			const P = async (e, t) => {
				return await Object(u.a)(e, {
					...g,
					variables: {
						id: t
					}
				})
			}
		},
		"./src/reddit/endpoints/economics/predictions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "p", (function() {
				return O
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "i", (function() {
				return C
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "k", (function() {
				return I
			})), n.d(t, "l", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "o", (function() {
				return T
			})), n.d(t, "f", (function() {
				return N
			})), n.d(t, "g", (function() {
				return P
			})), n.d(t, "h", (function() {
				return R
			})), n.d(t, "c", (function() {
				return A
			})), n.d(t, "b", (function() {
				return M
			})), n.d(t, "d", (function() {
				return L
			})), n.d(t, "m", (function() {
				return D
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/makeRequest/index.ts"),
				o = n("./src/redditGQL/operations/AddPredictionDrafts.json"),
				i = n("./src/redditGQL/operations/CancelPrediction.json"),
				a = n("./src/redditGQL/operations/ChangePrediction.json"),
				d = n("./src/redditGQL/operations/ChangePredictionVote.json"),
				c = n("./src/redditGQL/operations/CreatePredictionTournament.json"),
				l = n("./src/redditGQL/operations/EndPredictionTournament.json"),
				u = n("./src/redditGQL/operations/GetPredictionChipPackages.json"),
				m = n("./src/redditGQL/operations/GetPredictionCreationAllowance.json"),
				p = n("./src/redditGQL/operations/GetPredictionToken.json"),
				b = n("./src/redditGQL/operations/GetTournaments.json"),
				f = n("./src/redditGQL/operations/GetTournamentsBaseInfo.json"),
				h = n("./src/redditGQL/operations/ResolvePrediction.json"),
				_ = n("./src/redditGQL/operations/SubredditTopPredictors.json"),
				g = n("./src/redditGQL/operations/SubredditTournamentLeaderboard.json"),
				v = n("./src/redditGQL/operations/UpdatePredictionTournament.json"),
				x = n("./src/redditGQL/operations/VotePrediction.json");
			const O = async (e, t) => {
				let {
					postId: n,
					optionId: o,
					coinPackageId: i,
					price: a
				} = t;
				var d;
				const c = await Object(s.a)(e, {
					...x,
					variables: {
						input: {
							postId: n,
							optionId: o,
							coinPackageId: i,
							price: a
						}
					}
				});
				if (!Object(r.c)(c) || c.error || !(null === (d = c.body.data.votePrediction) || void 0 === d ? void 0 : d.ok)) throw new Error("Failed to make prediction");
				return c.body.data.votePrediction.poll
			}, E = (e, t) => {
				let {
					postId: n,
					optionId: r
				} = t;
				return Object(s.a)(e, {
					...h,
					variables: {
						input: {
							postId: n,
							optionId: r
						}
					}
				})
			};
			var y;
			! function(e) {
				e.AllTime = "ALL_TIME", e.Monthly = "MONTHLY"
			}(y || (y = {}));
			const C = async (e, t) => {
				let {
					subredditId: n,
					period: o = y.AllTime,
					top: i = 100,
					includeCurrentRank: a
				} = t;
				const d = await Object(s.a)(e, {
					..._,
					variables: {
						subredditId: n,
						period: o,
						top: i,
						includeCurrentRank: a
					}
				});
				if (!Object(r.c)(d) || d.error) throw new Error("Failed to fetch subreddit top predictors");
				if (!d.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return d.body.data.subredditInfoById
			}, j = async (e, t) => {
				let {
					subredditId: n,
					tournamentId: o,
					includeCurrentRank: i
				} = t;
				const a = await Object(s.a)(e, {
					...g,
					variables: {
						subredditId: n,
						tournamentId: o,
						includeCurrentRank: i
					}
				});
				if (!Object(r.c)(a) || a.error) throw new Error("Failed to fetch subreddit tournament");
				if (!a.body.data.subredditInfoById) throw new Error("Subreddit has no prediction winners");
				return a.body.data.subredditInfoById
			}, k = async (e, t) => {
				const n = await Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error || !n.body.data.createPredictionTournament.tournament) throw new Error("Failed to create tournament");
				return n.body.data.createPredictionTournament.tournament
			}, I = async (e, t) => {
				const n = await Object(s.a)(e, {
					...b,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, S = async (e, t) => {
				const n = await Object(s.a)(e, {
					...f,
					variables: t
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to fetch tournaments");
				return n.body.data.subredditInfoByName.predictionTournaments || []
			}, w = async (e, t) => {
				const n = await Object(s.a)(e, {
					...o,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to create prediction");
				const {
					errors: i,
					tournament: a
				} = n.body.data.addPredictionDrafts;
				if (null == i ? void 0 : i.length) throw new Error(i[0].message);
				if (!a) throw new Error("Failed to create prediction");
				return a
			}, T = async (e, t) => {
				const n = await Object(s.a)(e, {
					...v,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || n.error) throw new Error("Failed to update prediction tournament");
				const {
					tournament: o
				} = n.body.data.updatePredictionTournament;
				if (!o) throw new Error("Failed to update prediction tournament");
				return o
			}, N = (e, t) => Object(s.a)(e, {
				...l,
				variables: {
					input: t
				}
			}), P = (e, t) => Object(s.a)(e, {
				...u,
				variables: t
			}), R = (e, t) => Object(s.a)(e, {
				...p,
				variables: t
			}), A = async (e, t) => {
				const n = await Object(s.a)(e, {
					...a,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(n) || !n.body.data.changePrediction.ok) throw new Error("Unable to update prediction");
				return n.body.data.changePrediction.poll
			}, M = async (e, t) => {
				let {
					postId: n
				} = t;
				var o, a;
				const d = await Object(s.a)(e, {
					...i,
					variables: {
						input: {
							postId: n
						}
					}
				});
				if (!Object(r.c)(d) || !(null === (o = d.body.data.cancelPrediction) || void 0 === o ? void 0 : o.ok) || !(null === (a = d.body.data.cancelPrediction) || void 0 === a ? void 0 : a.poll)) throw new Error("Unable to cancel prediction");
				return d.body.data.cancelPrediction.poll
			}, L = async (e, t) => {
				var n, o;
				const i = await Object(s.a)(e, {
					...d,
					variables: {
						input: t
					}
				});
				if (!Object(r.c)(i) || !(null === (n = i.body.data.changePredictionVote) || void 0 === n ? void 0 : n.ok) || !(null === (o = i.body.data.changePredictionVote) || void 0 === o ? void 0 : o.poll)) throw new Error("Unable to change prediction.");
				return i.body.data.changePredictionVote.poll
			}, D = async (e, t) => {
				const n = await Object(s.a)(e, {
					...m,
					variables: t
				});
				return !!Object(r.c)(n) && n.body.data.identity.isPredictionCreationAllowed
			}
		},
		"./src/reddit/endpoints/economics/uploadedAssets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			}));
			var s, r, o = n("./src/config.ts"),
				i = n("./src/reddit/endpoints/governance/requester.ts");

			function a(e, t, n, s) {
				const r = `assetType=${n}&assetStatus=${s}`;
				return Object(i.a)(e, {
					method: "get",
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets?${r}`
				})
			}

			function d(e, t, n) {
				const r = new FormData;
				return r.append("assetType", n.assetType), r.append("assetName", n.assetName), r.append("upfile", n.imageFile), n.assetType === s.Badge && (r.append("badgeColor", n.badgeColor || ""), r.append("badgeDescription", n.badgeDescription || "")), Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets`,
					method: "post",
					type: null,
					data: r
				})
			}

			function c(e, t, n, s, r) {
				return Object(i.a)(e, {
					endpoint: `${o.a.metaUrl}/modtools/${t}/assets/${n}s/${s}`,
					method: "patch",
					data: r
				})
			}! function(e) {
				e.Badge = "badge", e.Emote = "emote"
			}(s || (s = {})),
			function(e) {
				e.Uploaded = "uploaded", e.Approved = "approved", e.Rejected = "rejected"
			}(r || (r = {}))
		},
		"./src/reddit/endpoints/geotagging/setSubredditGeoPlace.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SetSubredditGeoPlace.json");
			const o = e => ({
				input: {
					subredditId: e.subredditId,
					geoPlace: {
						id: e.placeId,
						source: e.source,
						sessionId: e.sessionId
					}
				}
			});
			t.a = async (e, t) => Object(s.a)(e, {
				...r,
				variables: o(t)
			})
		},
		"./src/reddit/endpoints/gold/powerups/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/CreateCustomEmoji.json"),
				o = n("./src/redditGQL/operations/DeleteCustomEmoji.json"),
				i = n("./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json"),
				a = n("./src/redditGQL/operations/RedditorPowerups.json"),
				d = n("./src/redditGQL/operations/SubredditPowerups.json"),
				c = n("./src/redditGQL/operations/SubredditPowerupsFull.json"),
				l = n("./src/redditGQL/operations/UpdatePowerupsSettings.json"),
				u = n("./src/redditGQL/operations/UserPowerups.json");
			const m = e => Object(s.a)(e, u, {
					traceRequestName: "user_powerups"
				}),
				p = (e, t) => Object(s.a)(e, {
					variables: {
						id: t
					},
					...a
				}, {
					traceRequestName: "redditor_powerups"
				}),
				b = (e, t, n) => Object(s.a)(e, {
					...d,
					variables: {
						subredditId: t,
						includeIdentity: n
					}
				}, {
					traceRequestName: "subreddit_powerups"
				}),
				f = (e, t, n, r) => Object(s.a)(e, {
					...c,
					variables: {
						subredditId: t,
						includeIdentity: n,
						skipMediaPacks: r
					}
				}, {
					traceRequestName: "subreddit_powerups_full"
				}),
				h = (e, t) => Object(s.a)(e, {
					...i,
					variables: t
				}),
				_ = (e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}),
				g = (e, t) => Object(s.a)(e, {
					...o,
					variables: t
				}),
				v = async (e, t, n) => {
					const r = {
						input: {
							subredditId: t,
							powerupsSettings: {
								benefitSettings: n
							}
						}
					};
					return Object(s.a)(e, {
						...l,
						variables: r
					})
				}
		},
		"./src/reddit/endpoints/gold/topAwarded.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/TopAwardedPosts.json"),
				o = n("./src/redditGQL/operations/TopAwardersLeaderboard.json");
			const i = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						...t,
						includeListingMetadata: !!t.includeListingMetadata
					}
				}),
				a = (e, t) => Object(s.a)(e, {
					...o,
					variables: t
				})
		},
		"./src/reddit/endpoints/goodContent/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s, r = n("./node_modules/fbt/lib/FbtPublic.js"),
				o = n("./src/lib/loadWithRetries/index.ts");
			! function(e) {
				e.PopularCommunities = "Popular Communities", e.Gaming = "Gaming", e.Sports = "Sports", e.TV = "TV", e.Travel = "Travel", e.HealthAndFitness = "Health & Fitness", e.Fashion = "Fashion"
			}(s || (s = {}));
			const i = {
					[s.PopularCommunities]: () => r.fbt._("Popular Communities", null, {
						hk: "2K4vGY"
					}),
					[s.Gaming]: () => r.fbt._("Gaming", null, {
						hk: "16rFc7"
					}),
					[s.Sports]: () => r.fbt._("Sports", null, {
						hk: "1cmqIR"
					}),
					[s.TV]: () => r.fbt._("TV", null, {
						hk: "2rVWoK"
					}),
					[s.Travel]: () => r.fbt._("Travel", null, {
						hk: "35HRB5"
					}),
					[s.HealthAndFitness]: () => r.fbt._("Health & Fitness", null, {
						hk: "2vstHj"
					}),
					[s.Fashion]: () => r.fbt._("Fashion", null, {
						hk: "3mkHju"
					})
				},
				a = e => {
					const t = i[e];
					return t ? t() : e
				},
				d = async () => (await Object(o.a)(() => n.e("FrontpageLinks").then(n.t.bind(null, "./src/reddit/endpoints/goodContent/frontpageLinks.json", 3)))).default
		},
		"./src/reddit/endpoints/governance/crypto.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "j", (function() {
				return i
			})), n.d(t, "i", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "l", (function() {
				return c
			})), n.d(t, "k", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "n", (function() {
				return g
			}));
			var s, r = n("./src/config.ts"),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "Ethereum Main Network";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "Rinkeby Test Network"
				}
				return e + " Network"
			}

			function a(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "https://meta-api.reddit.com/ethereum/ethereum";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "https://meta-api.reddit.com/ethereum/rinkeby";
					case s.ArbitrumRinkeby:
						return "https://meta-api.reddit.com/ethereum/ethereum:5391184";
					case s.ArbitrumNitroDevnet:
						return "https://meta-api.reddit.com/ethereum/nitroDevnet";
					case s.ArbitrumMainnet:
						return "https://a4ba.arbitrum.io/rpc";
					default:
						return `https://meta-api.reddit.com/ethereum/${e}`
				}
			}

			function d(e) {
				switch (e) {
					case s.Ethereum:
					case s.EthTraderEthereum:
						return "homestead";
					case s.Rinkeby:
					case s.EthTraderRinkeby:
						return "rinkeby";
					case s.ArbitrumRinkeby:
						return 5391184;
					case s.ArbitrumNitroDevnet:
						return 421612;
					case s.ArbitrumMainnet:
						return 42170;
					default: {
						const [, t] = e.split(":");
						return t
					}
				}
			}

			function c(e) {
				return e === s.ArbitrumRinkeby ? 5e3 : 3e4
			}
			async function l(e, t, n) {
				return Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/challenges`,
					data: {
						challengeType: "registration-challenge-EIP712",
						address: n
					}
				})
			}
			async function u(e, t, n) {
				return await Object(o.a)(e, {
					method: "post",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations`,
					data: n
				})
			}
			async function m(e, t, n) {
				return await Object(o.a)(e, {
					method: "delete",
					endpoint: `${r.a.metaUrl}/crypto/${t}/registrations/${n}`
				})
			}! function(e) {
				e.Ethereum = "ethereum:1", e.Rinkeby = "ethereum:4", e.ArbitrumNova = "ethereum:42170", e.ArbitrumRinkeby = "ethereum:5391184", e.ArbitrumNitroDevnet = "ethereum:421612", e.ArbitrumMainnet = "ethereum:42170", e.EthTraderEthereum = "ethereum:1:ethtrader", e.EthTraderRinkeby = "ethereum:4:ethtrader"
			}(s || (s = {}));
			const p = (e, t, n) => ({
					type: "burn-link",
					subredditId: e,
					amount: t,
					burnMemo: n
				}),
				b = e => ({
					type: "convert-to-coins",
					subredditId: e
				}),
				f = e => ({
					type: "claim",
					subredditId: e
				}),
				h = e => ({
					type: "subscribe",
					subredditId: e
				}),
				_ = (e, t, n, s) => ({
					type: "transfer",
					subredditId: e,
					recipient: t,
					recipientAddress: n,
					amount: s
				});
			async function g(e, t) {
				return await Object(o.a)(e, {
					method: "put",
					endpoint: `${r.a.metaUrl}/crypto/ethereum/transaction-intent`,
					data: t
				})
			}
		},
		"./src/reddit/endpoints/governance/posts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/reddit/models/Poll/index.ts"), n("./src/reddit/endpoints/governance/requester.ts"));

			function o(e, t, n) {
				return Object(r.a)(e, {
					method: "get",
					endpoint: `${s.a.metaUrl}/polls/${t}?postIds=${n.join(",")}`
				})
			}
		},
		"./src/reddit/endpoints/governance/requester.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/lib/makeApiRequest/index.ts");

			function r(e, t) {
				return Object(s.a)(e, {
					type: "json",
					...t
				}).then(e => {
					if (e.ok) return {
						body: e.body,
						ok: !0,
						status: e.status
					};
					return {
						error: e.error && e.error.fields && e.error.fields[0] ? e.error.fields[0].msg : {
							...e.body,
							code: e.status
						},
						ok: !1,
						status: e.status
					}
				})
			}
		},
		"./src/reddit/endpoints/governance/wallet.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = (n("./src/lib/bigNumberUtils/percent.ts"), n("./src/lib/constants/index.ts")),
				o = n("./src/reddit/endpoints/governance/requester.ts");

			function i(e, t) {
				return Object(o.a)(e, {
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}/me`,
					method: r.ob.GET
				}).then(e => {
					if (e.ok) {
						const n = e.body,
							s = {
								[t.subredditId]: n
							};
						return {
							...e,
							body: s
						}
					}
					return e
				})
			}

			function a(e, t) {
				return Object(o.a)(e, {
					headers: {
						"X-HTTP-Method-Override": "GET"
					},
					endpoint: `${s.a.metaUrl}/wallets/${t.subredditId}`,
					method: r.ob.POST,
					data: t.userIds
				}).then(e => e.ok ? {
					...e,
					body: {
						wallets: e.body
					}
				} : e)
			}
		},
		"./src/reddit/endpoints/me/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const a = e => Object(o.a)(e, {
				endpoint: Object(i.a)(`${s.a.gatewayUrl}/desktopapi/v1/me`),
				method: r.ob.GET
			})
		},
		"./src/reddit/endpoints/messages/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/ReportMessage.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			const l = (e, t) => Object(o.a)(Object(a.a)(e, [d.a]), {
					endpoint: Object(c.a)(`${e.apiUrl}/api/compose`),
					method: r.ob.POST,
					data: t
				}),
				u = (e, t) => Object(i.a)(e, {
					...s,
					variables: t
				})
		},
		"./src/reddit/endpoints/modQueue/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/models/RichTextJson/addEmotesAsImagesParam.ts"),
				l = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				u = n("./src/redditGQL/operations/ModQueueItems.json");
			const m = (e, t, n) => Object(o.a)(e, {
					endpoint: Object(l.a)(Object(c.a)(`${s.a.gatewayUrl}/desktopapi/v1/${t}`)),
					method: r.ob.GET,
					data: {
						moderated_limit: 25,
						...n
					}
				}),
				p = (e, t, n) => Object(o.a)(Object(a.a)(e, [d.a]), {
					endpoint: `${e.apiUrl}/api/v1/modactions/${t}`,
					method: r.ob.POST,
					type: "json",
					data: n
				}),
				b = (e, t) => Object(i.a)(e, {
					...u,
					variables: t
				})
		},
		"./src/reddit/endpoints/moderator/moderatingSubreddits.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts");
			t.a = async e => Object(r.a)(Object(o.a)(e, [i.a]), {
				endpoint: `${e.apiUrl}/subreddit_permissions`,
				method: s.ob.GET,
				traceRequestName: "get_subreddit_permissions"
			})
		},
		"./src/reddit/endpoints/notificationsSettings/layoutByChannelEndpoint.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json"),
				o = n("./src/redditGQL/operations/UpdateNotificationPreferences.json");
			const i = (e, t) => Object(s.a)(e, {
					...r,
					variables: t
				}),
				a = (e, t) => Object(s.a)(e, {
					...o,
					variables: {
						input: {
							preferences: [t]
						}
					}
				})
		},
		"./src/reddit/endpoints/page/popularFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/lib/env/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				d = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				c = n("./src/reddit/models/Onboarding/index.ts"),
				l = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				u = n("./src/redditGQL/operations/PopularFeedElements.json");
			const m = async (e, t) => {
				var n, m, p, b;
				const f = await ((e, t) => Object(s.a)(e, {
					...u,
					variables: t
				}))(e, t);
				if (!f.ok && !(null === (p = null === (m = null === (n = f.body) || void 0 === n ? void 0 : n.data) || void 0 === m ? void 0 : m.popular) || void 0 === p ? void 0 : p.elements)) return f;
				const h = f.body,
					_ = ((e, t) => {
						let {
							identity: n,
							popular: s,
							recentPosts: u,
							trendingSubreddits: m
						} = e;
						const p = {};
						let b;
						const [f, h] = s.elements.edges.reduce((e, t, n) => {
							var s, r, o, l;
							const [u, m] = e, f = t.node;
							if (Object(i.k)(f)) {
								const e = f;
								e.subreddit = {
									...e.subreddit
								}, u.push(f), (null === (r = null === (s = f.flair) || void 0 === s ? void 0 : s.template) || void 0 === r ? void 0 : r.id) && (null === (l = null === (o = f.flair) || void 0 === o ? void 0 : o.template) || void 0 === l ? void 0 : l.postStyle) && (p[f.flair.template.id] = Object(d.a)(f.flair.template.postStyle))
							} else if (Object(c.g)(f)) {
								const e = Object(a.a)(f.interestTopicRecommendations.recommendationTopics);
								e.topics.length && (b = {
									interests: e,
									index: n
								})
							} else m.push(f);
							return [u, m]
						}, [
							[],
							[]
						]);
						if (h.length) {
							const e = `Received unhandled ${h.length} elements when processing subreddit data: "${h[0].__typename}"`;
							Object(r.b)() || console.warn(e), o.c.captureMessage(e)
						}
						u && f.push(...u);
						const _ = s.elements.dist,
							g = s.elements.geoFilter,
							v = null == u ? void 0 : u.map(e => e.id),
							x = Object(l.b)(f, m, n, v);
						return x.subredditAboutInfo = {}, b && (x.interestTopicRecommendations = b), {
							...x,
							...null !== _ && {
								dist: _
							},
							...void 0 !== g && {
								geoFilter: g
							},
							...void 0 !== t.sort && {
								listingSort: t.sort
							}
						}
					})(h.data, t);
				return {
					...f,
					ok: !!(null === (b = h.data.popular) || void 0 === b ? void 0 : b.elements.edges.length),
					status: 200,
					body: _
				}
			}
		},
		"./src/reddit/endpoints/page/subredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			}));
			var s = n("./src/config.ts"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/isAdHocMultireddit/index.ts"),
				i = n("./src/lib/isFakeSubreddit/index.ts"),
				a = n("./src/lib/makeApiRequest/index.ts"),
				d = n("./src/lib/makeGqlRequest/index.ts"),
				c = n("./src/lib/performanceTimings/index.tsx"),
				l = n("./src/reddit/constants/graphql.ts"),
				u = n("./src/reddit/constants/page.ts"),
				m = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				p = n("./src/reddit/helpers/getPostLimitForMobile/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts"),
				h = n("./src/reddit/models/Subreddit/index.ts"),
				_ = n("./src/reddit/selectors/adsSignals.ts"),
				g = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				v = n("./src/reddit/selectors/experiments/devPlatform.ts"),
				x = n("./src/reddit/selectors/experiments/econ/index.ts"),
				O = n("./src/reddit/selectors/platform.ts"),
				E = n("./src/reddit/selectors/subreddit.ts"),
				y = n("./src/reddit/selectors/user.ts"),
				C = n("./src/redditGQL/operations/SubredditPage.json");
			const j = (e, t, n, s) => {
					var r, a;
					const {
						after: d,
						geo_filter: c,
						isMobile: m,
						layout: b,
						limit: f,
						recentPostIds: h,
						sort: C,
						t: j
					} = n, k = Object(y.ab)(e), I = Object(O.r)(e), S = Object(o.a)(t), w = Object(i.a)(t), T = Object(E.X)(e, {
						subredditId: Object(E.I)(e, t)
					}).length > 0, N = Object(y.p)(e), P = Object(y.ob)(e), {
						adsSeenCount: R,
						totalPostsSeenCount: A,
						sessionStartTime: M
					} = Object(_.a)(e), L = Object(x.d)(e), D = Object(v.a)(e), F = Object(g.c)(e), U = {
						name: t,
						includeIdentity: k && !e.user.account,
						adContext: {
							layout: b ? b.toUpperCase() : l.a.Card,
							clientSignalSessionData: {
								adsSeenCount: R,
								totalPostsSeenCount: A,
								sessionStartTime: M
							}
						},
						isFake: w,
						includeAchievementFlairs: s && !w,
						includeAppliedFlair: !w && k && s,
						includeCustomEmojis: s && !w && L,
						includeDevPlatformMetadata: D,
						includePowerups: s && !w,
						includeQuestions: s && k && !w,
						includeRecents: w && h && h.length > 0 || !1,
						includeRedditorKarma: s && k && !(null === (a = null === (r = e.user.account) || void 0 === r ? void 0 : r.karma) || void 0 === a ? void 0 : a.total),
						includeRules: s && !w && !T,
						includeSubredditLinks: s && !w && !k,
						includeTopicLinks: s && !w && !k,
						includeTrending: w,
						includeSubredditRankings: F,
						isAdHocMulti: S,
						isAll: t === u.d.All,
						isLoggedOutGatedOptedin: N,
						isLoggedOutQuarantineOptedin: P,
						isPopular: t === u.d.Popular,
						recentPostIds: h || [],
						subredditNames: S ? t.split("+") : []
					};
					return C && (U.sort = C.toUpperCase()), j && (U.range = j.toUpperCase()), m ? U.pageSize = Object(p.a)(b) : f && (U.pageSize = f), I && I.ad && (U.forceAds = {
						ad: I.ad
					}), (I && I.geo_filter || c) && (U.region = I && I.geo_filter || c), d && (U.after = btoa(d)), U
				},
				k = async (e, t, n) => {
					const s = Date.now(),
						o = await ((e, t) => Object(d.a)(e, {
							...C,
							variables: t
						}))(e, t),
						i = Date.now();
					if (!o.ok || !o.body) return o;
					const a = o.body,
						l = Date.now(),
						u = Object(b.a)(a.data),
						m = Date.now(),
						p = [{
							duration: i - s,
							logKeyType: c.a.gqlFetchTiming
						}, {
							duration: m - l,
							logKeyType: c.a.gqlNormalizationTiming
						}];
					return Object(c.h)({
						name: r.u.SUBREDDIT,
						isLoggedIn: n,
						metrics: p
					}), {
						...o,
						ok: !!a.data.subredditInfoByName && !Object(h.k)(a.data.subredditInfoByName),
						status: I(a.data),
						body: u
					}
				}, I = e => {
					if (!e.subredditInfoByName) return 404;
					if (Object(h.k)(e.subredditInfoByName)) {
						if (e.subredditInfoByName.forbiddenReason === h.d.Banned) return 404;
						if (e.subredditInfoByName.forbiddenReason === h.d.GoldOnly || e.subredditInfoByName.forbiddenReason === h.d.Private || e.subredditInfoByName.forbiddenReason === h.d.Quarantined || e.subredditInfoByName.forbiddenReason === h.d.Gated) return 403
					}
					return 200
				}, S = e => {
					let {
						recentPostIds: t,
						...n
					} = e;
					return t && t.length ? {
						...n,
						recentPostIds: t.join(",")
					} : n
				};
			t.a = (e, t, n) => Object(a.a)(e, {
				endpoint: Object(m.a)(Object(f.a)(`${s.a.gatewayUrl}/desktopapi/v1/subreddits/${t}`)),
				method: r.ob.GET,
				data: n && S(n) || {},
				traceRequestName: "get_subreddit_page"
			})
		},
		"./src/reddit/endpoints/page/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditWiki.json");
			const o = (e, t) => Object(s.a)(e, {
				...r,
				variables: t
			})
		},
		"./src/reddit/endpoints/post/convert.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/makeApiRequest/index.ts"),
				o = n("./src/lib/omitHeaders/index.ts"),
				i = n("./src/reddit/constants/headers.ts"),
				a = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts");
			t.a = (e, t, n) => {
				const c = {
					output_mode: "markdown" === t ? t : "rtjson"
				};
				return t === d.i.MARKDOWN ? c.richtext_json = n : c.markdown_text = n, Object(r.a)(Object(o.a)(e, [i.a]), {
					endpoint: Object(a.a)(`${e.apiUrl}/api/convert_rte_body_format`),
					method: s.ob.POST,
					data: c
				})
			}
		},
		"./src/reddit/endpoints/post/create.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "b", (function() {
				return E
			})), n.d(t, "a", (function() {
				return y
			}));
			var s = n("./node_modules/node-libs-browser/node_modules/url/url.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/omitHeaders/index.ts"),
				a = n("./src/reddit/constants/headers.ts"),
				d = n("./src/reddit/helpers/addRedesignIdentifier/index.ts"),
				c = n("./src/reddit/helpers/flair.ts"),
				l = n("./src/reddit/helpers/name/index.ts"),
				u = n("./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts"),
				m = n("./src/reddit/models/Poll/index.ts"),
				p = n("./src/reddit/models/Post/index.ts"),
				b = n("./src/reddit/models/PostCreationForm/index.ts"),
				f = n("./src/reddit/models/RichTextJson/addRTJParam.ts");

			function h(e) {
				return Math.floor(e.valueOf() / 1e3)
			}
			const _ = e => {
					switch (e.kind) {
						case b.p.CROSSPOST:
							return b.p.CROSSPOST;
						case b.p.LINK:
							return b.p.LINK;
						case b.p.POLL:
							return b.p.POLL;
						case b.p.MEDIA:
							return e.makeGif ? b.p.VIDEO_GIF : e.mediaType;
						default:
							return "self"
					}
				},
				g = e => {
					switch (e.kind) {
						case b.p.RICH_TEXT:
							return {
								richtext_json: JSON.stringify({
									document: e.document
								})
							};
						case b.p.MARKDOWN:
							return {
								text: e.markdown
							};
						case b.p.LINK:
						case b.p.MEDIA:
							return {
								url: e.url
							};
						case b.p.CROSSPOST:
							return {
								crosspost_fullname: e.sourcePostId
							};
						case b.p.POLL:
							return e.poll.type === m.a.Prediction ? {
								duration: 999999,
								end_timestamp: h(e.poll.endDate),
								options: e.poll.options.map(e => e.text),
								prediction: !0,
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							} : {
								duration: Math.floor(e.poll.duration / 864e5),
								options: e.poll.options.map(e => e.text),
								text: e.markdown,
								raw_rtjson: "markdown" in e ? null : JSON.stringify({
									document: e.document
								})
							}
					}
				},
				v = e => {
					const t = Object(l.i)(e.destSubreddit.name);
					return {
						...e.destSubreddit.isProfile ? {
							sr: `u_${t}`,
							submit_type: "profile"
						} : {
							sr: t,
							submit_type: "subreddit"
						},
						api_type: "json",
						show_error_list: !0,
						draft_id: e.draftId || void 0,
						title: e.title,
						discussion_type: e.isChatPost ? p.b.Chat : void 0,
						spoiler: e.isSpoiler,
						nsfw: e.isNSFW,
						...e.kind !== b.p.POLL ? {
							kind: _(e),
							original_content: e.isOC
						} : {},
						post_to_twitter: e.postToTwitter,
						sendreplies: e.sendReplies,
						...e.gRecaptchaResponse ? {
							"g-recaptcha-response": e.gRecaptchaResponse
						} : {},
						resubmit: e.resubmit,
						...g(e),
						...e.kind === b.p.MEDIA && "video" === e.mediaType ? {
							video_poster_url: e.videoThumbnailUrl
						} : {},
						...e.kind === b.p.MEDIA && e.makeGif ? {
							make_gif: "on"
						} : {},
						...e.flair ? {
							flair_id: e.flair.templateId,
							flair_text: Object(c.g)(e.flair)
						} : {},
						...e.validate_on_submit ? {
							validate_on_submit: e.validate_on_submit
						} : {},
						...e.eventSchedule && {
							event_start: e.eventSchedule.startDate,
							event_end: e.eventSchedule.endDate,
							event_tz: e.eventSchedule.timezoneName,
							unlist: e.eventSchedule.submitTime === b.j.AtEventTime
						},
						...e.collectionId && {
							collection_id: e.collectionId
						}
					}
				},
				x = e => {
					const t = /comments\/(\w+)\/.*$/.exec(e),
						n = t && t[1];
					return n ? `${r.Nb.Post}_${n}` : ""
				},
				O = async (e, t) => {
					if (!e.ok) return Object(u.b)(e);
					const n = e.body.json.data;
					let r = n.url;
					r || t.kind !== b.p.MEDIA || (r = await ((e, t) => new Promise(n => {
						const s = new WebSocket(e),
							r = e => {
								s.close(), clearTimeout(o), n(e)
							},
							o = setTimeout(() => {
								r("")
							}, t);
						s.onmessage = e => {
							const t = JSON.parse(e.data),
								n = "success" === t.type ? t.payload.redirect : "";
							r(n)
						}, s.onerror = e => {
							r("")
						}
					}))(n.websocket_url, 3e4));
					const o = n.id || x(r),
						i = Object(s.parse)(r).path,
						a = n.drafts_count;
					return {
						...e,
						body: {
							id: o,
							path: i,
							draftsCount: a
						}
					}
				}, E = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit_poll_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: v(t),
					type: "json"
				}).then(e => O(e, t)), y = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
					endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit_gallery_post.json?resubmit=true`)),
					method: r.ob.POST,
					data: {
						...v(t),
						items: t.galleryItems.map(e => ({
							caption: e.caption,
							outbound_url: e.url,
							media_id: e.assetId
						}))
					},
					type: "json"
				}).then(e => O(e, t));
			t.c = (e, t) => Object(o.a)(Object(i.a)(e, [a.a]), {
				endpoint: Object(f.a)(Object(d.a)(`${e.apiUrl}/api/submit?resubmit=true`)),
				method: r.ob.POST,
				data: v(t)
			}).then(async e => await O(e, t))
		},
		"./src/reddit/endpoints/post/draft/helpers.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/models/PostDraft/index.ts");
			const o = e => ({
					id: e.json.data.id,
					draftsCount: e.json.data.drafts_count
				}),
				i = e => e.destSubreddit.id ? {
					subreddit: e.destSubreddit.id,
					target: e.destSubreddit.isProfile ? "profile" : "subreddit"
				} : {},
				a = e => {
					switch (e.kind) {
						case r.b.Link:
							return "link";
						case r.b.Markdown:
							return "markdown";
						case r.b.RichText:
							return "richtext";
						default:
							return "self"
					}
				},
				d = e => {
					switch (e) {
						case "link":
							return r.b.Link;
						case "markdown":
							return r.b.Markdown;
						case "richtext":
							return r.b.RichText;
						default:
							return "self"
					}
				},
				c = e => e.title.substring(0, 300),
				l = e => {
					switch (e.kind) {
						case r.b.Link:
						case r.b.Markdown:
							return e.body;
						case r.b.RichText:
							return JSON.stringify({
								document: e.body
							})
					}
				},
				u = e => e ? {
					flair_id: e.templateId || null,
					flair_text: Object(s.g)(e) || null,
					flair_text_color: e.textColor || null,
					flair_background_color: e.backgroundColor || null
				} : {
					flair_id: null,
					flair_text: null,
					flair_text_color: null,
					flair_background_color: null
				},
				m = e => ({
					id: e.draftId || void 0,
					...i(e),
					kind: a(e),
					title: c(e),
					body: l(e),
					spoiler: e.isSpoiler,
					nsfw: e.isNSFW,
					original_content: e.isOC,
					...u(e.flair),
					send_replies: e.sendReplies,
					is_public_link: e.isPublicLink
				})
		},
		"./src/reddit/endpoints/publicAccessNetwork/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "f", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "g", (function() {
				return I
			})), n.d(t, "h", (function() {
				return S
			})), n.d(t, "i", (function() {
				return w
			})), n.d(t, "j", (function() {
				return M
			})), n.d(t, "a", (function() {
				return L
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/lodash/omit.js"),
				o = n.n(r),
				i = n("./src/config.ts"),
				a = n("./src/lib/addQueryParams/index.ts"),
				d = n("./src/lib/constants/index.ts"),
				c = n("./src/lib/constants/headers.ts"),
				l = n("./src/lib/makeGqlRequest/index.ts"),
				u = n("./src/lib/makeRequest/index.ts"),
				m = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				p = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				b = n("./src/reddit/featureFlags/useProductionStreamingApi.ts"),
				f = n("./src/reddit/helpers/comment/index.ts"),
				h = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				_ = n("./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts"),
				g = n("./src/reddit/models/PostCreationForm/index.ts"),
				v = n("./src/reddit/models/Vote/index.ts"),
				x = n("./src/redditGQL/operations/LiveVideoPosts.json");

			function O() {
				return Object(b.b)() ? "https://strapi.reddit.com" : i.a.streamingApiUrl
			}
			const E = async (e, t) => {
				let n;
				return n = t === m.R ? "/config" : `/${t}/config`, Object(u.b)({
					endpoint: `${O()}${n}`,
					method: d.ob.GET,
					headers: o()(e.headers(), [c.d, c.c, c.a]),
					timeoutMs: void 0
				}).then(R)
			}, y = (e, t) => {
				let {
					subredditId: n,
					options: s
				} = t;
				return Object(l.a)(e, {
					...x,
					variables: {
						feedContext: {
							subredditId: n
						},
						first: null == s ? void 0 : s.pageSize,
						after: null == s ? void 0 : s.cursor
					}
				})
			}, C = async (e, t) => Object(u.b)({
				endpoint: `${O()}/videos/${t}`,
				method: d.ob.GET,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), j = async (e, t, n) => {
				let s;
				s = t === m.R ? "/broadcasts" : `/${t}/broadcasts`;
				const r = Object(a.a)(s, {
					cursor: null == n ? void 0 : n.cursor,
					page_size: null == n ? void 0 : n.pageSize
				});
				return Object(u.b)({
					endpoint: `${O()}${r}`,
					method: d.ob.GET,
					headers: o()(e.headers(), [c.d, c.c, c.a])
				}).then(R)
			}, k = async e => Object(u.b)({
				endpoint: `${O()}/recommended_viewer_subreddits`,
				method: d.ob.GET,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), I = async (e, t, n) => Object(u.b)({
				endpoint: `${O()}/videos/${t}/vote/${A(n)}`,
				method: d.ob.POST,
				headers: o()(e.headers, [c.d, c.c, c.a])
			}).then(R), S = async (e, t) => Object(u.b)({
				endpoint: `${O()}/videos/${t}/heartbeat`,
				method: d.ob.POST,
				headers: o()(e.headers(), [c.d, c.c, c.a])
			}).then(R), w = async (e, t, n, s) => {
				const r = P(n);
				return r ? T(e, t, r).then(e => Object(u.c)(e) && e.body && e.body.data ? {
					...e,
					body: {
						parentId: t,
						comment: {
							...Object(_.a)(e.body.data.r2_comment),
							media: N(n)
						},
						automuteLevel: e.body.data.auto_mute_status.level
					},
					error: void 0
				} : e) : Promise.reject(new Error("Cannot send empty message"))
			}, T = async (e, t, n) => Object(u.b)({
				endpoint: `${O()}/broadcasts/${t}/comment_v2`,
				method: d.ob.POST,
				headers: o()(e.headers, [c.d, c.c, c.a]),
				data: {
					text: n
				},
				type: "json"
			}).then(R), N = e => ({
				type: "rtjson",
				richtextContent: Object(f.d)(e),
				rteMode: g.i.RICH_TEXT
			}), P = e => e.rteState ? p.a.getRawText(e.rteState) : e.rtJson ? Object(h.c)(e.rtJson) : void 0, R = e => {
				if (e.ok) return {
					...e,
					error: void 0
				}; {
					const t = {
						type: 404 === e.status ? d.L.NOT_FOUND_ERROR : d.L.SERVER_ERROR
					};
					return 429 === e.status && (t.fields = [{
						field: "",
						msg: s.fbt._("Try again later", null, {
							hk: "3BBLIU"
						})
					}]), {
						...e,
						error: t
					}
				}
			}, A = e => e === v.a.upvoted ? "up" : e === v.a.downvoted ? "down" : "unset", M = async (e, t, n) => Object(u.b)({
				endpoint: `${O()}/broadcasts/${t}`,
				method: d.ob.PUT,
				headers: o()(e.headers, [c.d, c.c, c.a]),
				data: {
					data: {
						chat_disabled: n
					}
				},
				type: "json"
			}).then(R), L = async (e, t) => Object(u.b)({
				endpoint: `${O()}/broadcasts/${t}/auto_mute_status`,
				method: d.ob.GET,
				headers: o()(e.headers, [c.d, c.c, c.a])
			}).then(R)
		},
		"./src/reddit/endpoints/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "a", (function() {
				return E
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/reddit/helpers/flair.ts"),
				o = n("./src/reddit/helpers/richTextJson/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/ScheduledPost/index.ts"),
				c = n("./src/redditGQL/operations/CreateScheduledPost.json"),
				l = n("./src/redditGQL/operations/SubredditScheduledPosts.json");
			const u = (e, t) => Object(s.a)(e, {
					...l,
					variables: {
						...t,
						includeRecurring: !(!t.includeRecurring || !t.includeRecurring.recurringFirst),
						includeStandalone: !(!t.includeStandalone || !t.includeStandalone.standaloneFirst),
						recurringAfter: t.includeRecurring ? t.includeRecurring.recurringAfter : void 0,
						recurringFirst: t.includeRecurring ? t.includeRecurring.recurringFirst : void 0,
						standaloneAfter: t.includeStandalone ? t.includeStandalone.standaloneAfter : void 0,
						standaloneFirst: t.includeStandalone ? t.includeStandalone.standaloneFirst : void 0
					}
				}),
				m = (e, t) => {
					if (!e.ok || !e.body) return !1;
					const n = e.body;
					return !!(n.data && n.data.subredditInfoById && n.data.subredditInfoById.scheduledPosts && n.data.subredditInfoById.scheduledPosts[t] && n.data.subredditInfoById.scheduledPosts[t].edges)
				},
				p = (e, t) => !(!e.ok || !e.body) && (!(t.includeStandalone && !(e => m(e, d.g.standalonePosts))(e)) && !(t.includeRecurring && !(e => m(e, d.g.recurringPosts))(e))),
				b = e => {
					let {
						poll: t,
						schedule: n,
						submission: s,
						subredditId: o
					} = e;
					return {
						collectionId: s.collectionId || "",
						discussionType: s.isChatPost ? i.b.Chat : i.b.Comment,
						isContestMode: s.isContestMode,
						isPostAsMetaMod: s.isPostAsMetaMod,
						isSpoiler: s.isSpoiler,
						isNsfw: s.isNSFW,
						poll: t && O(t),
						title: s.title,
						isOriginalContent: s.isOC,
						flair: s.flair ? {
							id: s.flair.templateId,
							text: Object(r.g)(s.flair)
						} : {},
						sticky: s.sticky,
						subredditId: o,
						suggestedCommentSort: s.suggestedSort,
						isSendReplies: s.sendReplies,
						...f(n),
						...v(s),
						assetIds: x(s)
					}
				},
				f = e => ({
					scheduling: {
						publishAt: e.submitDate,
						clientTimezone: e.timezoneName,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					}
				}),
				h = e => ({
					scheduling: Object.keys(e).length > 0 ? {
						clientTimezone: e.timezoneName || void 0,
						publishAt: e.submitDate || void 0,
						frequency: e.recurrenceInfo ? e.recurrenceInfo.frequency : void 0,
						interval: e.recurrenceInfo ? e.recurrenceInfo.interval : void 0,
						byMonthDays: e.recurrenceInfo ? e.recurrenceInfo.byMonthDays : void 0,
						byWeekDays: e.recurrenceInfo ? e.recurrenceInfo.byWeekDays : void 0
					} : void 0
				}),
				_ = e => {
					let {
						poll: t,
						schedule: n,
						scheduledPostId: s,
						submission: r,
						subredditId: o
					} = e;
					const i = b({
						poll: t,
						schedule: n,
						submission: r,
						subredditId: o
					});
					return {
						id: s,
						...i,
						flair: Object.keys(i.flair || {}).length ? {
							...i.flair
						} : {
							id: "",
							text: ""
						}
					}
				},
				g = e => /^https?:\/\//i.test(e) ? e : `http://${e}`,
				v = e => {
					switch (e.kind) {
						case a.p.RICH_TEXT:
							return {
								content: {
									richText: JSON.stringify({
										document: e.document
									})
								}
							};
						case a.p.MARKDOWN:
							return {
								content: {
									markdown: e.markdown
								}
							};
						case a.p.LINK:
							return {
								content: {}, link: {
									url: g(e.url)
								}
							};
						default:
							return {
								content: {}
							}
					}
				},
				x = e => {
					let t = [];
					if (e.document) {
						const n = e.document || [];
						t = Object(o.e)(n)
					}
					return t
				},
				O = e => {
					if (e && e.options && e.duration && (e.options = e.options.map(e => ({
							text: e.text.trim()
						})).filter(e => !!e.text), e.options.length)) return e.duration = Math.floor(e.duration / 864e5), e
				},
				E = (e, t) => Object(s.a)(e, {
					...c,
					variables: {
						input: t
					}
				})
		},
		"./src/reddit/endpoints/scheduledPosts/update.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/redditGQL/operations/UpdateScheduledPost.json"),
				r = n("./src/lib/makeGqlRequest/index.ts");
			const o = (e, t) => Object(r.a)(e, {
				...s,
				variables: {
					input: t
				}
			})
		},
		"./src/reddit/endpoints/subreddit/about.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/SubredditAbout.json");
			t.a = (e, t, n) => Object(s.a)(e, {
				...r,
				variables: {
					subredditName: t,
					includeSubreddit: n
				}
			})
		},
		"./src/reddit/endpoints/subreddit/notificationSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/redditGQL/operations/FetchSubredditsNotificationSettings.json"),
				r = n("./src/redditGQL/operations/UpdateSubredditNotificationSettings.json"),
				o = n("./src/lib/makeGqlRequest/index.ts");
			const i = (e, t) => Object(o.a)(e, {
					...s,
					variables: {
						subredditIds: [t]
					}
				}),
				a = (e, t, n) => Object(o.a)(e, {
					...r,
					variables: {
						input: {
							...n,
							subredditId: t
						}
					}
				})
		},
		"./src/reddit/endpoints/subreddit/rules.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return h
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "d", (function() {
				return O
			})), n.d(t, "e", (function() {
				return y
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/camelCase.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/mapKeys.js"),
				i = n.n(o),
				a = n("./src/lib/constants/index.ts"),
				d = n("./src/lib/makeApiRequest/index.ts"),
				c = n("./src/lib/makeGqlRequest/index.ts"),
				l = n("./src/lib/omitHeaders/index.ts"),
				u = n("./src/redditGQL/operations/SubredditRules.json"),
				m = n("./src/reddit/constants/headers.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				b = n("./src/reddit/models/Rule/index.ts");
			const f = e => {
					let {
						rules: t
					} = e;
					return {
						rules: t.map(e => ({
							...i()(e, (e, t) => r()(t)),
							kind: "link" === e.kind ? "post" : e.kind
						}))
					}
				},
				h = (e, t) => Object(c.a)(e, {
					...u,
					variables: {
						subredditName: t
					}
				}).then(e => {
					var t, n, s;
					return e.ok && e.body && (e => Object.keys(e).length > 0)(e.body) && (null === (s = null === (n = null === (t = e.body) || void 0 === t ? void 0 : t.data) || void 0 === n ? void 0 : n.subreddit) || void 0 === s ? void 0 : s.rules) ? e.body = Object(p.a)(e.body.data.subreddit.rules) : e.body = {
						rules: []
					}, e
				}),
				_ = (e, t) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/user/${t}/about/rules.json`,
					method: a.ob.GET
				}).then(e => (e.ok && e.body.rules && (e.body = f(e.body)), e)),
				g = e => e.ok ? (e.body = Object(b.h)(JSON.parse(e.body.json.data.rules)), e) : e.body,
				v = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/add_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => g(e)), x = async (e, t, n, s) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/update_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n.rule,
						kind: n.kind === b.b.post ? "link" : n.kind,
						violation_reason: n.reason,
						description: n.description,
						old_short_name: s,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => g(e)), O = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/remove_subreddit_rule`,
					method: a.ob.POST,
					data: {
						r: t,
						short_name: n,
						api_type: "json",
						raw_json: 1
					}
				}).then(e => g(e)), E = e => e.map(e => encodeURIComponent(e)).join(), y = async (e, t, n) => Object(d.a)(Object(l.a)(e, [m.a]), {
					endpoint: `${e.apiUrl}/api/reorder_subreddit_rules`,
					method: a.ob.POST,
					data: {
						r: t,
						new_rule_order: E(n),
						api_type: "json",
						raw_json: 1
					}
				}).then(e => g(e))
		},
		"./src/reddit/endpoints/subreddit/subscriptions.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./src/redditGQL/operations/SubscribedSubreddits.json"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/makeApiRequest/index.ts"),
				i = n("./src/lib/makeGqlRequest/index.ts"),
				a = n("./src/lib/omitHeaders/index.ts"),
				d = n("./src/reddit/constants/headers.ts"),
				c = n("./src/reddit/helpers/addRedesignIdentifier/index.ts");
			t.a = e => Object(i.a)(e, s);
			const l = (e, t) => {
					let {
						subredditIds: n,
						subredditNames: s,
						subscribe: i
					} = t;
					return Object(o.a)(Object(a.a)(e, [d.a]), {
						method: r.ob.POST,
						endpoint: Object(c.a)(`${e.apiUrl}/api/subscribe`),
						data: {
							action: i ? "sub" : "unsub",
							sr: n && n.join(",") || void 0,
							sr_name: s && s.join(",") || void 0,
							api_type: "json"
						}
					})
				},
				u = (e, t, n) => Object(o.a)(Object(a.a)(e, [d.a]), {
					method: r.ob.POST,
					endpoint: `${e.apiUrl}/api/favorite`,
					data: {
						make_favorite: n ? "true" : "false",
						sr_name: t,
						api_type: "json"
					}
				})
		},
		"./src/reddit/endpoints/subredditModeration/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/lib/makeGqlRequest/index.ts"),
				r = n("./src/redditGQL/operations/AllModerators.json"),
				o = n("./src/redditGQL/operations/FetchModerationLogActions.json"),
				i = n("./src/redditGQL/operations/FetchModerationLogActionsImproved.json"),
				a = n("./src/redditGQL/operations/ModerationActionCategories.json");
			const d = (e, t, n) => Object(s.a)(e, {
					...o,
					variables: {
						subredditName: t,
						...n
					}
				}),
				c = (e, t) => Object(s.a)(e, {
					...r,
					variables: {
						subredditName: t
					}
				}),
				l = (e, t, n) => Object(s.a)(e, {
					...i,
					variables: {
						subredditName: t,
						...n
					}
				}),
				u = e => Object(s.a)(e, {
					...a,
					variables: {}
				})
		},
		"./src/reddit/featureFlags/component.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./node_modules/reselect/es/index.js"),
				a = n("./src/reddit/featureFlags/index.ts");

			function d(e, t, n) {
				const s = Object(i.c)({
					featureEnabled: t => a.d[e](t)
				});
				return Object(o.b)(s)(e => {
					const {
						featureEnabled: s,
						...o
					} = e, i = o;
					return s ? r.a.createElement(t, i) : void 0 !== n ? r.a.createElement(n, i) : null
				})
			}
		},
		"./src/reddit/helpers/addSupplementaryTextInfoToAdPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/endpoints/post/convert.ts"),
				r = n("./src/reddit/models/Post/index.ts"),
				o = n("./src/reddit/selectors/experiments/supportingLinkAds.ts");
			const i = e => !(!Object(r.C)(e) || !e.adSupplementaryText || "string" != typeof e.adSupplementaryText),
				a = async (e, t) => {
					try {
						const n = await Object(s.a)(e, "rtjson", t.adSupplementaryText);
						return {
							...t,
							adSupplementaryText: n.body.output
						}
					} catch (n) {
						return t
					}
				}, d = async (e, t, n) => {
					if (!Object(o.a)(n) || !t) return t;
					const s = {};
					for (const [r, o] of Object.entries(t)) s[r] = i(o) ? await a(e, o) : o;
					return s
				}
		},
		"./src/reddit/helpers/author.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => !!e && e.endsWith("-ModTeam")
		},
		"./src/reddit/helpers/awards/isEligibleForCommunityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/models/Subreddit/index.ts");
			const r = new Set(["goins", "gold_testing", "inthesoulstone", "lounge", "lssgoldnormal", "maymodsguide1", "maymodsguide2", "megalounge", "pan2", "pan3", "venkman_bookclub", "whatssnoo", "translation_piglatin", "translation_pirate", "translation_initials", "translation_german", "translation_british", "translation_french_fr", "translation_es_mx", "translation_br_pt", "german_translation", "lssgoldnormal_13", "test_automation_001"]),
				o = new Set([s.g.Private, s.g.User]),
				i = e => !(!e || !e.name) && (!!r.has(e.name.toLowerCase()) || !e.isNSFW && !e.isQuarantined && !o.has(e.type));
			t.a = i
		},
		"./src/reddit/helpers/awards/isEligibleForGlobalAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_22cerq"]),
				r = e => s.has(e);
			t.a = r
		},
		"./src/reddit/helpers/awards/isEligibleForTemporaryAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const s = new Set(["t5_q0gj4", "t5_z5gli", "t5_22cerq", "t5_3j0kj"]),
				r = e => s.has(e)
		},
		"./src/reddit/helpers/brandSafety/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/models/WhitelistStatus/index.ts");
			const r = (e, t) => {
				const n = e.some(e => e.isNSFW),
					r = t.some(e => e.wls === s.b.NO_ADS);
				return !n && !r
			}
		},
		"./src/reddit/helpers/canAccessModerationPage/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Subreddit/index.ts");
			t.a = e => {
				let {
					pageName: t,
					moderatorPermissions: n,
					canCreateScheduledPosts: o,
					isEmployee: i,
					isStreamingEnabled: a,
					isTalkHostsEnabled: d,
					subredditType: c,
					isContributor: l
				} = e;
				switch (t) {
					case s.mc.Awards:
						return !!n;
					case s.mc.Powerups:
						return !!(null == n ? void 0 : n.config);
					case s.mc.SubredditRules:
					case s.mc.Moderators:
						return !0;
					case s.mc.Modlog:
						return !!n;
					case s.mc.Muted:
						return !!(n && n.access && n.mail);
					case s.mc.Banned:
						return !(!n || !n.access);
					case s.mc.Contributors:
						return !!(n && n.access || c === r.g.Restricted || c === r.g.Private && l);
					case s.mc.Flair:
					case s.mc.PostFlair:
					case s.mc.UserFlair:
						return !(!n || !n.flair);
					case s.mc.CommunitySettings:
						return !(!n || !n.config);
					case s.mc.Modqueue:
					case s.mc.Reports:
					case s.mc.Edited:
					case s.mc.Spam:
					case s.mc.Unmoderated:
					case s.mc.ContentControls:
					case s.mc.Removal:
						return !(!n || !n.posts);
					case s.mc.Badges:
					case s.mc.Emojis:
						return !!n;
					case s.mc.Emotes:
						return !(!n || !n.config);
					case s.mc.Streaming:
						return !!(n && n.all && a);
					case s.mc.Wiki:
					case s.mc.WikiBanned:
					case s.mc.WikiContributors:
						return !(!n || !n.wiki);
					case s.mc.Traffic:
						return i || !!n;
					case s.mc.EventPostContent:
					case s.mc.ScheduledPostContent:
						return !!o;
					case s.mc.Predictions:
						return !(!n || !n.posts);
					case s.mc.TalkHosts:
						return !!d && !!n;
					default:
						return !1
				}
			}
		},
		"./src/reddit/helpers/comment/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/uuid/dist/esm-browser/v4.js"),
				r = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = n("./src/reddit/constants/things.ts"),
				i = n("./src/reddit/models/Upload/index.ts"),
				a = n("./src/reddit/models/Vote/index.ts");
			const d = (e, t) => e.rteState ? r.a.toRichTextJSON(e.rteState, t) : e.rtJson || e.text,
				c = (e, t) => {
					let n = [];
					return e.rteState ? n = r.a.toRichTextJSON(e.rteState, t).document : e.rtJson && (n = e.rtJson.document), {
						document: n
					}
				},
				l = (e, t) => JSON.stringify(c(e, t));

			function u() {
				return `${o.a}_${Object(s.a)()}`
			}

			function m(e) {
				let {
					temporalId: t,
					draft: n,
					post: s,
					author: r,
					subredditId: o,
					parentId: i
				} = e;
				return {
					id: t,
					postId: s.postId,
					subredditId: o,
					author: r.displayText || "",
					authorId: r.id,
					collapsed: !1,
					collapsedBecauseCrowdControl: null,
					created: Math.floor(Date.now() / 1e3),
					distinguishType: null,
					ignoreReports: !1,
					isAdmin: !1,
					isApproved: !1,
					isDeleted: !1,
					isGildable: !1,
					isLocked: !1,
					isMod: !1,
					isOp: !1,
					isRemoved: !1,
					isScoreHidden: !1,
					isSpam: !1,
					isStickied: !1,
					isSaved: !1,
					isSystem: !1,
					media: {
						type: "rtjson",
						rteMode: n.commentMode,
						richtextContent: c(n)
					},
					parentId: i,
					permalink: "",
					postAuthor: s.author,
					postTitle: null,
					score: 1,
					sendReplies: !1,
					modReports: [],
					numReports: 0,
					voteState: a.a.notVoted,
					userReports: []
				}
			}

			function p(e, t) {
				for (const n of Object.keys(t)) {
					const s = t[n],
						r = s.url ? Object(i.b)(s.url) : null;
					if (r && e.includes(r)) return s
				}
				return null
			}
		},
		"./src/reddit/helpers/commentList/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/reddit/constants/comments.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts");
			const a = (e, t) => t().features.comments.models[e],
				d = e => {
					switch (e.commentLink.type) {
						case s.a.Comment:
							return e.commentsDict[e.commentLink.id];
						case s.a.MoreComments:
							return e.moreCommentsDict[e.commentLink.id];
						case s.a.ContinueThread:
							return e.continueThreadDict[e.commentLink.id]
					}
				},
				c = (e, t) => e.type === s.a.MoreComments ? t[e.id].numComments : 1,
				l = (e, t, n, s) => {
					let o = Object(r.n)(s, {
							commentLink: t,
							commentsPageKey: e
						}),
						i = t;
					for (; o && o.depth > n && o.prev && (i = o.prev, (o = Object(r.n)(s, {
							commentLink: i,
							commentsPageKey: e
						})) && !(o.depth <= n)););
					return i.id
				},
				u = (e, t, n) => {
					const {
						commentLists: s,
						comments: r
					} = e, {
						head: a
					} = s[t];
					if (a) return Object.keys(r).filter(e => {
						const t = r[e];
						return !(!t.isStickied || !((e, t) => {
							const n = Object(i.c)(e, {
								experimentEligibilitySelector: i.a,
								experimentName: o.E,
								expEventOverride: t
							});
							return !!(Object(o.rg)(n) ? void 0 : n)
						})(n)) || (e => !1 !== e.collapsed)(t)
					})
				}
		},
		"./src/reddit/helpers/counters/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/sample/index.ts"),
				o = n("./src/telemetry/helpers/sendCounter.ts");
			const i = (e, t) => {
					Object(o.b)(s.o.Redesign, {
						type: o.a.GenderCollection,
						data: {
							gender: e,
							submitSuccess: t
						}
					})
				},
				a = (e, t) => {
					Object(r.b)(10) && Object(o.b)(s.o.Redesign, {
						type: o.a.ReonboardingFlow,
						data: {
							type: e,
							variant: t
						}
					})
				}
		},
		"./src/reddit/helpers/crypto/vaultActionLink.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				return e.match(/^https:\/\/www\.reddit\.com\/vault\/burn/)
			}

			function r(e) {
				const {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} = e;
				return t && n && s && r ? {
					subreddit: t,
					amount: n,
					memo: s,
					cta: r
				} : (console.error("subreddit, amount, and memo query params required for vault action"), null)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/dom/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./node_modules/lodash/map.js"),
				r = n.n(s),
				o = n("./src/lib/FocusTrap/index.ts");
			const i = e => "INPUT" === e.tagName.toUpperCase() || "TEXTAREA" === e.tagName.toUpperCase() || "DIV" === e.tagName.toUpperCase() && e.isContentEditable,
				a = e => {
					let t = e;
					do {
						if (i(t)) return !0
					} while (t = t.parentElement);
					return !1
				},
				d = () => {
					const e = document.getSelection();
					return !!e && (e.rangeCount > 0 && e.getRangeAt(0).toString().length > 0)
				},
				c = () => d() ? (() => {
					const e = document.getSelection();
					if (!e) return [];
					const t = e.getRangeAt(0).cloneContents().childNodes;
					return r()(t, e => e.textContent || "")
				})() : null,
				l = (e, t) => {
					const n = document.createRange();
					return n.selectNode(t), e.compareBoundaryPoints(Range.END_TO_START, n) < 0 && e.compareBoundaryPoints(Range.START_TO_END, n) > 0
				},
				u = e => {
					const t = window.getSelection();
					if (1 !== t.rangeCount) return;
					const n = t.getRangeAt(0);
					if (!l(n, e)) return;
					const {
						startContainer: s,
						startOffset: r,
						endContainer: o,
						endOffset: i
					} = n, a = document.createRange();
					a.selectNode(e);
					let d = !0;
					if (-1 === a.compareBoundaryPoints(Range.START_TO_START, n) && (a.setStart(s, r), d = !1), 1 === a.compareBoundaryPoints(Range.END_TO_END, n) && (a.setEnd(o, i), d = !1), d) return [e];
					const c = document.createElement("div");
					return c.appendChild(a.cloneContents()), [...c.childNodes]
				},
				m = (e, t, n) => {
					let s = e;
					for (; s && (!n || !n(s));) {
						if (s && t(s)) return s;
						s = s.parentElement
					}
				},
				p = e => e && e.parentElement && m(e.parentElement, e => "static" !== window.getComputedStyle(e).getPropertyValue("position")),
				b = e => {
					e.querySelectorAll(o.a).forEach(e => {
						e.tabIndex = -1
					})
				}
		},
		"./src/reddit/helpers/dragDropContext/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react-dnd/lib/index.js"),
				r = n("./node_modules/react-dnd-html5-backend/lib/index.js"),
				o = n.n(r);
			t.a = Object(s.DragDropContext)(o.a)
		},
		"./src/reddit/helpers/economics/sortBadges.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				if (e.placement && !t.placement) return -1;
				if (t.placement && !e.placement) return 1;
				if (e.position && !t.position) return -1;
				if (t.position && !e.position) return 1;
				let n = 0;
				return e.placement && t.placement && (n = e.placement.localeCompare(t.placement)), 0 === n && e.position && t.position && (n = e.position - t.position), 0 === n && (n = e.title.localeCompare(t.title)), n
			}

			function r(e) {
				return [...e].sort(s)
			}
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}))
		},
		"./src/reddit/helpers/filterListingResponse/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/findLastIndex.js"),
				r = n.n(s),
				o = n("./src/reddit/models/WhitelistStatus/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/index.ts");
			const d = (e, t) => {
				let {
					subreddits: n,
					profiles: s
				} = t;
				const r = n[e.belongsTo.id] || s[e.belongsTo.id];
				return !e.isNSFW && r && o.a.has(r.wls || o.b.NO_ADS)
			};
			t.a = (e, t, n) => {
				let {
					postIds: s,
					posts: o,
					subreddits: c,
					profiles: l,
					...u
				} = n;
				const m = e.listings.postOrder.ids[t],
					p = (s || []).filter(e => !m || !m.includes(e)),
					b = m.map(t => e.posts.models[t]),
					f = b.length - (r()(b, e => e.isSponsored) + 1),
					h = p.map(e => o[e]);
				let _;
				const g = [],
					v = {
						subreddits: c,
						profiles: l
					};
				for (let r = 0; r < h.length; r++) {
					const n = h[r];
					let s = !1;
					if (n.isSponsored) {
						const e = r > 0 && h[r - 1],
							t = r < h.length - 1 && h[r + 1];
						e && d(e, v) && t && d(t, v) && (s = !0)
					}
					n.isSponsored && s && (null == _ && f + r >= 3 || r - _ >= 3) ? (_ = r, g.push(n.id)) : n.isSponsored ? n.isSponsored && Object(a.a)({
						source: "feed",
						action: "remove",
						noun: "ad",
						...i.o(e),
						listing: i.z(e, t)
					}) : g.push(n.id)
				}
				return {
					...u,
					subreddits: c,
					profiles: l,
					posts: o,
					postIds: g
				}
			}
		},
		"./src/reddit/helpers/genericServerError/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/constants/index.ts");
			t.a = () => ({
				type: r.L.SERVER_ERROR,
				fields: [{
					field: "",
					msg: s.fbt._("Something went wrong.", null, {
						hk: "RcX5A"
					})
				}]
			})
		},
		"./src/reddit/helpers/getPostLimitForMobile/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/postLayout.ts");

			function r(e) {
				return e ? s.c[e] : s.f
			}
		},
		"./src/reddit/helpers/getSubredditErrorProps/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/models/ContentGate.ts");
			t.a = (e, t, n) => {
				let r, o, i, a, d, c, l, u, m, p, b;
				return e ? e.quarantinedSubreddit ? (o = s.a.QuarantinedSubreddit, a = e.quarantineMessage, d = e.quarantineMessageHtml, c = e.quarantineRequiresEmail) : e.privateSubreddit ? (o = s.a.PrivateSubreddit, i = e.subredditDescription, l = e.isContributorRequestsDisabled, u = e.isContributorRequestTimestamp) : e.goldSubreddit ? o = s.a.GoldSubreddit : e.subredditBanned ? (o = s.a.SubredditBanned, r = e.subredditBanMessage) : e.subredditDoesNotExist ? o = s.a.SubredditDoesNotExist : e.subredditBlockedForLegalReason ? o = s.a.SubredditBlockedForLegalReason : e.interstitialWarningMessage && (o = s.a.GatedSubreddit, m = e.interstitialWarningMessage, p = e.interstitialWarningMessageHtml, b = e.interstitialWarningMessageRTJson) : t && (o = s.a.Nsfw), o && n ? {
					banMessage: r,
					contentGateType: o,
					isContributorRequestsDisabled: l,
					isContributorRequestTimestamp: u,
					subredditDescription: i,
					subredditName: n,
					quarantineMessage: a,
					quarantineMessageHtml: d,
					quarantineRequiresEmail: c,
					interstitialWarningMessage: m,
					interstitialWarningMessageHtml: p,
					interstitialWarningMessageRTJson: b
				} : void 0
			}
		},
		"./src/reddit/helpers/getTimeSortForListing/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/lib/listingSort/index.ts");
			t.a = (e, t) => {
				if (e) return Object(r.a)(e) ? t || s.pc : void 0
			}
		},
		"./src/reddit/helpers/governanceErrorText/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js");

			function r(e) {
				return e[0].toUpperCase() + e.slice(1)
			}

			function o(e) {
				return "extra" in e ? "string" == typeof e.extra ? e.extra : Object.keys(e.extra).map(t => e.extra[t]).map(r).join(" ") : s.fbt._("Something went wrong. Please try again later.", null, {
					hk: "16ibYk"
				})
			}

			function i(e) {
				const t = `${e.type} (${e.code})`;
				return "message" in e ? `${t}: ${e.message}` : t
			}
		},
		"./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				id: e.id,
				name: e.name,
				topic: e.title,
				children: e.isRoot ? [] : null
			});
			t.a = e => (e => {
				let {
					edges: t,
					schemeName: n
				} = e;
				return {
					topics: t.reduce((e, t) => {
						let {
							node: n
						} = t;
						const r = n.topic.parents.map(e => e.nodeId),
							o = r.length <= 0,
							i = n.id,
							a = {
								id: i,
								isRoot: o,
								parents: r,
								title: n.topic.title,
								name: n.topic.name
							};
						return o ? (e.topics.push(s(a)), e.dict[i] = e.topics.length - 1) : r.forEach(t => {
							var n;
							const r = e.dict[t];
							if ("number" == typeof r) {
								null === (n = e.topics[r].children) || void 0 === n || n.push(s(a))
							}
						}), e
					}, {
						topics: [],
						dict: {}
					}).topics,
					schemeName: n
				}
			})(e)
		},
		"./src/reddit/helpers/graphql/normalizeModActivityFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts");
			const r = e => {
				const {
					moderation: t,
					...n
				} = e, {
					lastModActionAt: r,
					activeModerators: o
				} = (null == t ? void 0 : t.modActivitySummary) || {}, i = [], a = {};
				null == o || o.edges.map(e => {
					if (!(null == e ? void 0 : e.node)) return;
					const {
						lastModAction: t,
						moderator: n
					} = e.node;
					if (!n) return;
					const s = null == n ? void 0 : n.id;
					s && (i.push(s), a[s] || (a[s] = {
						info: {},
						lastModAction: {}
					}), a[s].info = n, a[s].lastModAction = {
						...t
					})
				});
				const d = {
					lastModActionAt: r,
					activeMods: i
				};
				return {
					subreddit: Object(s.a)(n),
					summary: {
						sub: d,
						mods: a
					}
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeModerationLogFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/helpers/graphql/helpers.ts");
			const r = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							action: e,
							actionCategory: r,
							actionNotes: o,
							createdAt: i,
							details: a,
							id: d,
							moderator: c,
							moderatorInfo: l,
							subredditName: u,
							target: m,
							takedownContentPreview: p
						} = n, b = {
							action: e,
							actionCategory: r,
							actionNotes: o,
							createdAt: Object(s.g)(i),
							details: a,
							id: d,
							moderator: c,
							moderatorInfo: l,
							subredditName: u,
							target: m,
							takedownContentPreview: p
						};
						t.push(b)
					}
					return t
				},
				o = e => {
					const t = [];
					for (const {
							node: n
						} of e.edges) {
						const {
							id: e,
							name: s,
							icon: r
						} = n, o = {
							id: e,
							name: s,
							icon: r
						};
						t.push(o)
					}
					return t
				}
		},
		"./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => ({
				...e.id && {
					id: e.id
				},
				...e.postBackgroundColor && {
					postBackgroundColor: e.postBackgroundColor
				},
				...e.postBackgroundImage && {
					postBackgroundImage: e.postBackgroundImage
				},
				...e.postPlaceholderImage && {
					postPlaceholderImage: e.postPlaceholderImage
				},
				...e.postTitleColor && {
					postTitleColor: e.postTitleColor
				}
			})
		},
		"./src/reddit/helpers/graphql/normalizePostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts");
			const r = e => {
				let {
					edges: t
				} = e;
				const n = [];
				for (const {
						node: r
					} of t) n.push(Object(s.f)(r));
				return n
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			const s = e => ({
				communityIcon: e.styles && e.styles.icon || void 0,
				iconUrl: e.styles && e.styles.legacyIcon && e.styles.legacyIcon.url || void 0,
				id: e.id,
				isNSFW: e.isNSFW || !1,
				isSubscribed: e.isSubscribed,
				name: e.name,
				primaryColor: e.styles && e.styles.primaryColor || void 0,
				subscribers: e.subscribers,
				type: "subreddit"
			});
			t.a = e => {
				var t;
				return {
					subreddits: (null === (t = e.data.subredditInfoById) || void 0 === t ? void 0 : t.linkedSubreddits) ? e.data.subredditInfoById.linkedSubreddits.map(s) : []
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditPageFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return T
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/lib/env/index.ts"),
				o = n("./src/lib/sentry/index.ts"),
				i = n("./src/reddit/actions/gold/achievementFlairs.ts"),
				a = n("./src/reddit/actions/gold/customEmojis.ts"),
				d = n("./src/reddit/actions/gold/powerups.ts"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/models/RichTextJson/index.ts"),
				u = n("./src/reddit/models/Subreddit/index.ts"),
				m = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				p = n("./src/reddit/helpers/graphql/normalizeInterestTopicsFromGql/index.ts"),
				b = n("./src/reddit/helpers/graphql/normalizePostFlairFromGql/index.ts"),
				f = n("./src/reddit/helpers/graphql/normalizePostFlairStyleTemplateFromGql/index.ts"),
				h = n("./src/reddit/helpers/graphql/normalizePostFromGql/index.ts"),
				_ = n("./src/reddit/helpers/graphql/normalizePreferencesFromGql/index.ts"),
				g = n("./src/reddit/helpers/graphql/normalizeProfileFromGql/index.ts"),
				v = n("./src/reddit/helpers/graphql/normalizeSubredditAboutFromGql/index.ts"),
				x = n("./src/reddit/helpers/graphql/normalizeSubredditFromGql/index.ts"),
				O = n("./src/reddit/helpers/graphql/normalizeSubredditLinksFromGql/index.ts"),
				E = n("./src/reddit/helpers/graphql/normalizeSubredditModPermissions/index.ts"),
				y = n("./src/reddit/helpers/graphql/normalizeSubredditRulesFromGql/index.ts"),
				C = n("./src/reddit/helpers/graphql/normalizeSubredditStylesFromGql/index.ts"),
				j = n("./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts"),
				k = n("./src/reddit/helpers/graphql/normalizeSubredditWidgetsFromGql/index.ts"),
				I = n("./src/reddit/helpers/graphql/normalizeUserFromGql/index.ts"),
				S = n("./src/reddit/models/Onboarding/index.ts"),
				w = n("./src/reddit/helpers/graphql/helpers.ts");
			const T = (e, t, n, i) => {
				const a = {
						account: null,
						authorFlair: {},
						interestTopicRecommendations: void 0,
						postIds: [],
						postInstances: {},
						posts: {},
						postFlair: {},
						powerups: {},
						predictionTournaments: null,
						preferences: null,
						profiles: {},
						questions: {},
						recentPostIds: [],
						structuredStyles: {},
						subredditAboutInfo: {},
						subredditLinks: {},
						subredditPermissions: void 0,
						subredditRules: [],
						subreddits: {},
						subredditTopicLinks: void 0,
						token: "",
						trendingSubredditIds: [],
						userFlair: {}
					},
					d = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						if (Object(c.j)(e) || Object(c.i)(e)) return null;
						if (a.posts[e.id]) return e.id;
						const n = Object(h.f)(e);
						a.posts[n.id] = n;
						const {
							crosspostRoot: l
						} = e;
						l && l.type === c.a.Post && l.postInfo && d(l.postInfo, !0), Object(c.o)(e).forEach(e => d(e, !0));
						let u = n.id;
						if (e.authorFlair && (a.authorFlair[n.belongsTo.id] || (a.authorFlair[n.belongsTo.id] = {}), a.authorFlair[n.belongsTo.id][n.author] = Object(m.a)(e.authorFlair)[0]), Object(c.l)(e)) a.profiles[e.profile.id] || (a.profiles[e.profile.id] = Object(g.a)(e.profile));
						else if (Object(c.n)(e)) a.subreddits[e.subreddit.id] || (a.subreddits[e.subreddit.id] = Object(x.a)(e.subreddit)), a.postFlair[e.subreddit.id] || (a.postFlair[e.subreddit.id] = Object(b.a)(e.subreddit));
						else if (Object(c.h)(e)) {
							const t = Object(h.b)(e);
							if (!t) return null;
							u = t, a.posts[t] = {
								...n,
								id: t,
								permalink: `${n.permalink}?instanceId=${encodeURIComponent(t)}`
							}, a.posts[n.id] || (a.posts[n.id] = {
								...n,
								events: []
							}), a.postInstances[e.id] || (a.postInstances[e.id] = []), a.postInstances[e.id].push(t)
						} else try {
							Object(s.a)(e)
						} catch (f) {
							const t = `Received unhandled element type when processing subreddit posts: "${e.__typename}"`;
							Object(r.b)() || console.warn(t), o.c.captureMessage(t)
						}
						const p = i && i.includes(u);
						return t || !u || p || a.postIds.push(u), u
					};
				if (e.forEach(e => d(e)), t) {
					a.trendingSubredditIds = t.map(e => e.id);
					for (const e of t) a.subreddits[e.id] = Object(x.a)(e)
				}
				const l = a.postIds.length - 1;
				return a.token = l >= 0 ? a.postIds[l] : "", n && (a.account = Object(I.a)(n), a.preferences = n.preferences && Object(_.a)(n.preferences, n.interactions) || null), a
			};
			t.a = e => {
				let {
					adhocMultiredditByNames: t,
					all: n,
					identity: s,
					popular: b,
					recentPosts: h,
					subredditInfoByName: _,
					trendingSubreddits: g
				} = e;
				var x, P, R, A, M, L, D, F, U, B, q, G;
				if (!_) return {
					reason: u.f.NotFoundSubreddit,
					data: {
						account: s && Object(I.a)(s) || null
					}
				};
				if (Object(u.k)(_)) {
					const {
						banMessage: e,
						publicDescriptionText: t,
						quarantineMessage: n,
						isEmailRequiredForQuarantineOptin: r,
						interstitialWarningMessage: o
					} = _;
					return {
						reason: N(_.forbiddenReason),
						data: {
							account: s && Object(I.a)(s) || null,
							banMessage: e || void 0,
							description: t,
							quarantineRequiresEmailOptin: r,
							...n ? {
								quarantineMessage: n.markdown,
								quarantineMessageRTJson: Object(w.h)(n.richtext, l.i)
							} : {},
							interstitialWarningMessage: null == o ? void 0 : o.markdown,
							interstitialWarningMessageRTJson: Object(w.h)(null == o ? void 0 : o.richtext, l.i)
						}
					}
				}
				const H = {},
					W = _.devPlatformMetadata;
				let V;
				const z = _ || b || n || t,
					[K, Q] = z.elements.edges.reduce((e, t, n) => {
						var s, r, o, i;
						const [a, d] = e, l = t.node;
						if (Object(c.k)(l)) {
							const e = l;
							e.subreddit = {
								...e.subreddit,
								devPlatformMetadata: W
							}, a.push(l), (null === (r = null === (s = l.flair) || void 0 === s ? void 0 : s.template) || void 0 === r ? void 0 : r.id) && (null === (i = null === (o = l.flair) || void 0 === o ? void 0 : o.template) || void 0 === i ? void 0 : i.postStyle) && (H[l.flair.template.id] = Object(f.a)(l.flair.template.postStyle))
						} else if (Object(S.g)(l)) {
							const e = Object(p.a)(l.interestTopicRecommendations.recommendationTopics);
							e.topics.length && (V = {
								interests: e,
								index: n
							})
						} else d.push(l);
						return [a, d]
					}, [
						[],
						[]
					]);
				if (Q.length) {
					const e = `Received unhandled ${Q.length} elements when processing subreddit data: "${Q[0].__typename}"`;
					Object(r.b)() || console.warn(e), o.c.captureMessage(e)
				}
				h && K.push(...h);
				const Y = z.elements.dist,
					J = T(K, g, s);
				_.styles && (J.structuredStyles = {
					data: {
						style: Object(C.a)(_.styles)
					}
				}), J.structuredStyles = {
					data: {
						..._.styles ? {
							style: Object(C.a)(_.styles)
						} : {},
						content: {
							widgets: Object(k.a)(_)
						},
						flairTemplate: H
					}
				}, J.subredditAboutInfo = Object(v.a)(_), _.modPermissions && (J.subredditPermissions = Object.keys(_.modPermissions).length > 0 ? Object(E.a)(_.modPermissions) : void 0), _.rules && (J.subredditRules = Object(y.a)(_.rules).rules), ((null == _ ? void 0 : _.answerableQuestions) || _.contentRatingSurvey || _.communityProgressModule) && (J.questions = {
					answerableQuestions: null == _ ? void 0 : _.answerableQuestions,
					contentRatingSurvey: null == _ ? void 0 : _.contentRatingSurvey,
					communityProgressModule: null == _ ? void 0 : _.communityProgressModule
				}), Object(u.k)(_) || Object.assign(J, Object(i.b)(_), Object(a.b)(_), {
					powerups: Object(d.b)(_, s)
				}), J.subredditLinks = Object(O.a)({
					data: {
						subredditInfoById: _
					}
				}), J.subredditTopicLinks = Object(j.a)({
					data: {
						subredditInfoById: _
					}
				});
				const X = [],
					Z = {};
				return null === (P = null === (x = null == _ ? void 0 : _.userFlairTemplates) || void 0 === x ? void 0 : x.edges) || void 0 === P || P.map(e => {
					const t = null == e ? void 0 : e.node;
					t && t.id && (X.push(t.id), Z[t.id] = Object(m.b)(t))
				}), J.userFlair = {
					[_.id]: {
						displaySettings: {
							isEnabled: !!(null === (R = _.authorFlairSettings) || void 0 === R ? void 0 : R.isEnabled),
							isSelfAssignable: !!(null === (A = _.authorFlairSettings) || void 0 === A ? void 0 : A.isSelfAssignable),
							isUserEnabled: !!(null === (M = _.authorFlairSettings) || void 0 === M ? void 0 : M.isOwnFlairEnabled),
							position: null === (D = null === (L = _.authorFlairSettings) || void 0 === L ? void 0 : L.position) || void 0 === D ? void 0 : D.toLowerCase()
						},
						permissions: {
							canAssignOwn: !!(null === (F = _.authorFlairSettings) || void 0 === F ? void 0 : F.isSelfAssignable),
							canUserChange: !!((null === (U = _.authorFlairSettings) || void 0 === U ? void 0 : U.isSelfAssignable) && (null === (B = _.authorFlairSettings) || void 0 === B ? void 0 : B.isEnabled) || (null === (q = J.subredditPermissions) || void 0 === q ? void 0 : q.flair) || (null === (G = J.account) || void 0 === G ? void 0 : G.isAdmin))
						},
						applied: _.authorFlair ? Object(m.a)(_.authorFlair)[0] : void 0,
						templates: Z,
						templateIds: X
					}
				}, V && (J.interestTopicRecommendations = V), J.predictionTournaments = _.predictionTournaments || [], {
					...J,
					...null !== Y && {
						dist: Y
					}
				}
			};
			const N = e => {
				switch (e) {
					case u.d.Banned:
						return u.f.BannedSubreddit;
					case u.d.GoldOnly:
						return u.f.GoldSubreddit;
					case u.d.Private:
						return u.f.PrivateSubreddit;
					case u.d.Quarantined:
						return u.f.QuarantinedSubreddit;
					case u.d.Gated:
						return u.f.GatedSubreddit;
					case u.d.Unknown:
						return u.f.ForbiddenSubreddit
				}
			}
		},
		"./src/reddit/helpers/graphql/normalizeSubredditScheduledPostsFromGql/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "d", (function() {
				return f
			}));
			const s = e => e.subredditInfoById.scheduledPosts.recurringPosts ? {
					recurringPosts: {
						models: p(e.subredditInfoById.scheduledPosts.recurringPosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.recurringPosts.pageInfo
						}
					},
					recurringPostsIds: e.subredditInfoById.scheduledPosts.recurringPosts.edges.map(e => e.node.id)
				} : {},
				r = e => e.subredditInfoById.scheduledPosts.standalonePosts ? {
					standalonePosts: {
						models: u(e.subredditInfoById.scheduledPosts.standalonePosts.edges),
						pageInfo: {
							...e.subredditInfoById.scheduledPosts.standalonePosts.pageInfo
						}
					},
					standalonePostsIds: e.subredditInfoById.scheduledPosts.standalonePosts.edges.map(e => e.node.id)
				} : {},
				o = e => ({
					...e,
					subredditInfoById: {
						id: e.subredditInfoById.id,
						scheduledPosts: {
							...s(e),
							...r(e)
						}
					}
				}),
				i = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.recurringPosts && !!e.subredditInfoById.scheduledPosts.recurringPostsIds,
				a = e => e.subredditInfoById.scheduledPosts && !!e.subredditInfoById.scheduledPosts.standalonePosts && !!e.subredditInfoById.scheduledPosts.standalonePostsIds,
				d = e => i(e) && a(e),
				c = e => !i(e) && a(e),
				l = e => i(e) && !a(e),
				u = e => e.map(e => m(e.node)),
				m = e => ({
					id: e.id,
					title: e.title,
					body: e.body,
					postKind: e.postKind,
					collectionId: e.collections.edges.length ? e.collections.edges[0].node.id : void 0,
					discussionType: e.discussionType,
					isContestMode: e.isContestMode,
					isPostAsMetaMod: e.isPostAsMetaMod,
					isSpoiler: e.isSpoiler,
					isNsfw: e.isNsfw,
					isOriginalContent: e.isOriginalContent,
					isSendReplies: e.isSendReplies,
					isSticky: !!e.sticky && "NONE" !== e.sticky,
					mediaAssets: e.mediaAssets,
					subreddit: {
						...e.subreddit
					},
					suggestedCommentSort: e.suggestedCommentSort,
					owner: {
						...e.owner
					},
					poll: e.poll,
					contentType: e.contentType,
					clientTimezone: e.clientTimezone,
					publishAt: e.publishAt.split(".")[0],
					state: e.state,
					flair: e.flair ? {
						...e.flair
					} : void 0,
					sticky: e.sticky,
					isModDistinguished: "MODERATOR" === e.distinguishedAs,
					url: e.url
				}),
				p = e => e.map(e => b(e.node)),
				b = e => ({
					...m(e),
					frequency: e.frequency,
					byMonthDays: e.byMonthDays || [],
					byWeekDays: e.byWeekDays || [],
					interval: e.interval || 1
				}),
				f = e => (e => !!e.frequency && !!e.interval)(e) ? b(e) : m(e)
		},
		"./src/reddit/helpers/graphql/normalizeSubredditTopicLinksFromGql/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				var t, n;
				return (null === (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.subredditInfoById) || void 0 === n ? void 0 : n.topicLinks) || void 0
			}
		},
		"./src/reddit/helpers/graphql/normalizeUploadLeaseFromGql/index.ts": function(e, t, n) {
			"use strict";

			function s(e) {
				let {
					uploadLeaseUrl: t,
					uploadLeaseHeaders: n
				} = e;
				return {
					action: t,
					fields: (null == n ? void 0 : n.map(e => {
						let {
							header: t,
							value: n
						} = e;
						return {
							name: t,
							value: n
						}
					})) || []
				}
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/helpers/hasModFlairPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.flair
		},
		"./src/reddit/helpers/hasModFullPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.all
		},
		"./src/reddit/helpers/hasModPostPermissions/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e && !!e.posts
		},
		"./src/reddit/helpers/isArrayEqual.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/lodash/isEqual.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/xorWith.js"),
				i = n.n(o);
			t.a = (e, t) => {
				const n = i()(e, t, r.a);
				return !(!n || 0 !== n.length)
			}
		},
		"./src/reddit/helpers/isCrosspost.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				return !!e && !!e.crosspostRootId
			}
		},
		"./src/reddit/helpers/isRemoved.ts": function(e, t, n) {
			"use strict";
			t.a = e => !!e.bannedBy && !e.isSpam
		},
		"./src/reddit/helpers/isValidUsername/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/normalizeUsername/index.tsx");
			t.a = e => {
				const t = Object(s.a)(e.trim());
				return t.length > 2 && t.length <= 20
			}
		},
		"./src/reddit/helpers/locales.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return d
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/fbt.js"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				i = n("./src/reddit/selectors/user.ts"),
				a = n("./node_modules/reselect/es/index.js");
			const d = e => Object.entries(e).map(e => {
					let [t, n] = e;
					return {
						value: t,
						displayName: n.displayName
					}
				}),
				c = Object.freeze({
					[s.GERMAN_LOCALE]: Object.freeze({
						bcp47: s.GERMAN_LOCALE,
						displayName: "Deutsch",
						englishName: "German",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.GERMAN_LOCALE),
						rtl: !1
					}),
					[s.DEFAULT_LOCALE]: Object.freeze({
						bcp47: s.DEFAULT_LOCALE,
						displayName: "English (US)",
						englishName: "English (US)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.DEFAULT_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_LOCALE,
						displayName: "Español (ES)",
						englishName: "Spanish (ES)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_LOCALE),
						rtl: !1
					}),
					[s.SPANISH_MEXICAN_LOCALE]: Object.freeze({
						bcp47: s.SPANISH_MEXICAN_LOCALE,
						displayName: "Español (MX)",
						englishName: "Spanish (MX)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.SPANISH_MEXICAN_LOCALE),
						rtl: !1
					}),
					"fr-FR": Object.freeze({
						bcp47: "fr-FR",
						displayName: "Français",
						englishName: "French",
						fbtLocale: Object(r.isoLocaleToFbtLocale)("fr-FR"),
						rtl: !1
					}),
					[s.ITALIAN_LOCALE]: Object.freeze({
						bcp47: s.ITALIAN_LOCALE,
						displayName: "Italiano",
						englishName: "Italian",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.ITALIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_BRAZILIAN_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_BRAZILIAN_LOCALE,
						displayName: "Português (BR)",
						englishName: "Portuguese (BR)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_BRAZILIAN_LOCALE),
						rtl: !1
					}),
					[s.PORTUGUESE_LOCALE]: Object.freeze({
						bcp47: s.PORTUGUESE_LOCALE,
						displayName: "Português (PT)",
						englishName: "Portuguese (PT)",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PORTUGUESE_LOCALE),
						rtl: !1
					})
				}),
				l = Object.freeze({
					[s.BENGALI_BANGLADESHI_LOCALE]: Object.freeze({
						bcp47: s.BENGALI_BANGLADESHI_LOCALE,
						displayName: "বাংলা",
						englishName: "Bengali",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.BENGALI_BANGLADESHI_LOCALE),
						rtl: !1
					}),
					[s.HINDI_LOCALE]: Object.freeze({
						bcp47: s.HINDI_LOCALE,
						displayName: "हिन्दी",
						englishName: "Hindi",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.HINDI_LOCALE),
						rtl: !1
					})
				}),
				u = Object.freeze({
					[s.PSEUDO_LOCALE]: Object.freeze({
						bcp47: s.PSEUDO_LOCALE,
						displayName: "Pseudo",
						englishName: "Pseudo",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_LOCALE),
						rtl: !1
					}),
					[s.PSEUDO_AUTO]: Object.freeze({
						bcp47: s.PSEUDO_AUTO,
						displayName: "Pseudo Auto",
						englishName: "Pseudo Auto",
						fbtLocale: Object(r.isoLocaleToFbtLocale)(s.PSEUDO_AUTO),
						rtl: !1
					})
				}),
				m = Object(a.a)(i.O, o.b, (e, t) => e || t ? {
					...c,
					...l,
					...u
				} : c);
			const p = async (e, t) => {
				0
			}
		},
		"./src/reddit/helpers/modTooltipTemplates/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/lib/humanizeUTCDate/index.tsx");
			const o = e => e.approvedBy && "string" == typeof e.approvedBy && e.approvedAtUTC ? s.fbt._("Approved by {username} at {time}", [s.fbt._param("username", e.approvedBy), s.fbt._param("time", Object(r.a)(e.approvedAtUTC))], {
					hk: "3G807D"
				}) : s.fbt._("Approved", null, {
					hk: "3CbKag"
				}),
				i = e => {
					let t = e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
						hk: "2Ey569"
					}) : s.fbt._("Removed", null, {
						hk: "238xK9"
					});
					return e.modReasonBy && e.modRemovalReason && (t = t + "\n" + s.fbt._("Reason by {username}:", [s.fbt._param("username", `u/${e.bannedBy}`)], {
						hk: "3qLdNZ"
					}) + e.modRemovalReason), e.modNote && (t = t + "\n" + s.fbt._("Note:", null, {
						hk: "2LD4vO"
					}) + e.modNote), t
				},
				a = e => s.fbt._({
					"*": "{number} Reports",
					_1: "1 Report"
				}, [s.fbt._plural(e, "number")], {
					hk: "3S0yx6"
				}),
				d = e => e.bannedBy && "string" == typeof e.bannedBy && e.bannedAtUTC ? s.fbt._("Removed as spam by {username} at {time}", [s.fbt._param("username", e.bannedBy), s.fbt._param("time", Object(r.a)(e.bannedAtUTC))], {
					hk: "2uutjk"
				}) : s.fbt._("Removed as spam", null, {
					hk: "1hD9G0"
				})
		},
		"./src/reddit/helpers/moderationLog/getGqlQueryParamsFromUrlQuery.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			var s = n("./src/reddit/constants/parameters.ts");
			const r = 50;
			t.b = (e, t) => {
				const n = {
					subredditName: e
				};
				return t[s.u] && (n[s.u] = t[s.u].split(",")), t[s.a] && (n[s.a] = t[s.a]), t[s.d] && (n[s.d] = t[s.d]), t[s.s] && (n[s.s] = t[s.s].split(",")), t[s.y] && (n[s.y] = t[s.y].split(",")), t[s.K] && (n[s.K] = t[s.K]), t[s.g] && (n[s.g] = t[s.g]), t[s.M] && (n[s.M] = t[s.M].split(",")), t[s.o] && (n[s.o] = parseInt(t[s.o], 10)), t[s.i] && (n[s.i] = parseInt(t[s.i], 10)), n
			}
		},
		"./src/reddit/helpers/onboarding/reonboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/customMiddleware/recentSubreddits.ts"),
				o = n("./src/reddit/helpers/featureThrottling/store/index.ts"),
				i = n("./src/reddit/helpers/onboarding/postsConsumedWeekly.ts"),
				a = n("./src/reddit/models/Onboarding/index.ts");
			const d = () => {
					const e = Date.now() - s.xc,
						t = Object(r.b)().filter(t => t.lastVisited >= e),
						n = Object(i.a)();
					return t.length < 3 || n < 50
				},
				c = () => !(() => !o.a.isReady || o.a.isFeatureThrottled(a.e.FeatureGate) || o.a.isFeatureThrottled(a.e.Dismissed))() && d(),
				l = () => !(() => !o.a.isReady || o.a.throttlingData[a.e.FeatureGate] || o.a.isFeatureThrottled(a.e.Triggered) || o.a.isFeatureThrottled(a.e.Dismissed))() && d(),
				u = () => {
					o.a.isFeatureThrottled(a.e.Triggered) || (o.a.throttleFeature(a.e.FeatureGate), o.a.throttleFeature(a.e.Triggered))
				},
				m = () => {
					o.a.throttleFeature(a.e.Dismissed)
				}
		},
		"./src/reddit/helpers/ordinal/index.ts": function(e, t, n) {
			"use strict";
			t.a = function(e) {
				const t = ["th", "st", "nd", "rd"],
					n = e % 100;
				return e + (t[(n - 20) % 10] || t[n] || t[0])
			}
		},
		"./src/reddit/helpers/pageActionLoginRedirect.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/history/esm/history.js"), n("./src/reddit/actions/platform.ts");
			var s = n("./src/config.ts");
			t.a = (e, t) => {
				const n = t.platform.currentPage && t.platform.currentPage.url;
				let r = `${s.a.accountManagerOrigin}/login/`;
				const o = window.location.origin;
				n && (r += `?dest=${encodeURIComponent(`${o}${n}`)}`), window.location.href = r
			}
		},
		"./src/reddit/helpers/r2/normalizeCommentFromR2/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/isComment.ts"),
				o = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				i = n("./src/reddit/models/Vote/index.ts"),
				a = e => !0 === e ? i.a.upvoted : !1 === e ? i.a.downvoted : i.a.notVoted,
				d = n("./src/reddit/models/Comment/index.ts");
			t.a = e => {
				const t = {
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					author: e.author,
					authorId: e.author_fullname,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					body: e.body_html,
					bodyMD: e.body,
					collapsed: e.collapsed,
					collapsedReason: e.collapsed_reason,
					collapsedReasonCode: e.collapsed_reason_code,
					collapsedBecauseCrowdControl: e.collapsed_because_crowd_control,
					commentType: e.comment_type,
					created: e.created_utc,
					deletedBy: l(e),
					distinguishType: e.distinguished || "",
					editedAt: null,
					id: e.name,
					ignoreReports: e.ignore_reports,
					isAdmin: "admin" === e.distinguished,
					isAuthorPremium: !!e.author_premium,
					isApproved: e.approved,
					isDeleted: e.author === s.H,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isMod: "moderator" === e.distinguished,
					isOp: e.is_submitter,
					isRemoved: e.removed,
					isScoreHidden: e.score_hidden,
					isSpam: e.spam,
					isStickied: e.stickied,
					isSaved: e.isSaved,
					isSystem: !1,
					subredditId: e.subreddit_id,
					markdown: e.body,
					media: {
						mediaMetadata: e.media_metadata,
						type: "rtjson",
						richtextContent: c(e.rtjson),
						rteMode: e.rte_mode
					},
					modReports: e.mod_reports,
					modReportsDismissed: e.mod_reports_dismissed,
					numReports: e.num_reports,
					parentId: Object(r.a)(e.parent_id) ? e.parent_id : null,
					permalink: e.permalink,
					postAuthor: e.link_author || null,
					postId: e.link_id,
					postTitle: e.link_title || null,
					sendReplies: e.send_replies,
					score: e.score,
					treatmentTags: e.treatment_tags,
					userReports: e.user_reports,
					userReportsDismissed: e.user_reports_dismissed,
					voteState: a(e.likes)
				};
				return e.all_awardings && (t.allAwardings = Object(o.a)(e.all_awardings)), e.awarders && (t.awarders = e.awarders), e.associated_award && (t.associatedAwardId = e.associated_award.id, t.associatedAward = Object(o.b)(e.associated_award)), t
			};
			const c = e => "string" == typeof e ? JSON.parse(e) : e,
				l = e => e.author !== s.H ? null : e.body === s.I ? d.c.User : e.body === s.Qb ? d.c.Moderator : null
		},
		"./src/reddit/helpers/r2/normalizePostFromR2/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/helpers/r2/normalizeAwardingsFromR2.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/Media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				a = n("./src/reddit/models/Vote/index.ts");
			const d = e => {
					const t = [];
					return e.link_flair_richtext && e.link_flair_richtext.length && t.push({
						richtext: e.link_flair_richtext,
						type: r.f.Richtext,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.link_flair_text && t.push({
						text: e.link_flair_text,
						type: r.f.Text,
						textColor: e.link_flair_text_color || "dark",
						backgroundColor: e.link_flair_background_color || "",
						templateId: e.link_flair_template_id
					}), e.spoiler && t.push({
						text: "spoiler",
						type: r.f.Spoiler
					}), e.over_18 && t.push({
						text: "nsfw",
						type: r.f.Nsfw
					}), t
				},
				c = e => e ? e.map(e => ({
					categoryId: e.category_id,
					categoryName: e.category_name
				})) : [],
				l = e => {
					const t = e.preview && e.preview.enabled;
					let n = !1,
						s = null,
						r = {},
						a = {};
					const d = e.over_18 || e.spoiler;
					if (e.preview && (n = !!(a = e.preview.images[0].variants).mp4, r = e.preview.images[0].source, d && (s = a.obfuscated.source.url)), e.is_self) return {
						content: e.selftext_html,
						type: o.o.TEXT,
						markdownContent: e.selftext,
						obfuscated: s,
						rteMode: e.rte_mode || i.i.RICH_TEXT,
						...e.rtjson && {
							richtextContent: e.rtjson,
							type: o.o.RTJSON,
							mediaMetadata: e.media_metadata
						}
					};
					if (e.secure_media && e.secure_media.oembed || e.is_survey_ad) return {
						content: e.secure_media_embed.media_domain_url,
						type: o.o.EMBED,
						width: e.secure_media.oembed.width || 0,
						height: e.secure_media.oembed.height || 0,
						obfuscated: s,
						provider: e.secure_media.oembed.provider_name || ""
					};
					if (e.media && e.media.reddit_video) {
						const t = e.media.reddit_video;
						return {
							hlsUrl: t.hls_url,
							dashUrl: t.dash_url,
							isGif: t.is_gif,
							scrubberThumbSource: t.scrubber_media_url,
							obfuscated: s,
							posterUrl: t.url,
							width: t.width,
							height: t.height,
							type: o.o.VIDEO
						}
					}
					if (e.media && e.media.rpan_video) {
						const t = e.media.rpan_video;
						return {
							hlsUrl: t.hls_url,
							scrubberThumbSource: t.scrubber_media_url,
							type: o.o.LIVEVIDEO
						}
					}
					if (t && n) return {
						content: a.mp4.source.url,
						type: o.o.GIFVIDEO,
						width: a.mp4.source.width,
						height: a.mp4.source.height,
						gifBackgroundImage: r.url,
						gifBackgroundResolutions: e.preview.images[0].resolutions,
						obfuscated: s,
						resolutions: a.mp4.resolutions
					};
					if (t) {
						const t = a.gif ? a.gif.resolutions : e.preview.images[0].resolutions;
						return {
							content: r.url,
							type: o.o.IMAGE,
							width: r.width,
							height: r.height,
							obfuscated: s,
							resolutions: t
						}
					}
					return null
				},
				u = e => {
					const t = {};
					if (e.promoted && e.outbound_link || !e.is_self && !e.is_reddit_media_domain) {
						if (t.displayText = e.domain, t.url = e.url, e.outbound_link) {
							const n = e.outbound_link;
							t.outboundUrl = n.url, t.outboundUrlExpiration = n.expiration, t.outboundUrlCreated = n.created
						}
						return t
					}
					return null
				};
			t.a = e => {
				return {
					adPromotedUserPostIds: [],
					adSupplementaryText: null,
					allAwardings: e.all_awardings ? Object(s.a)(e.all_awardings) : [],
					awarders: e.awarders,
					author: e.author,
					authorId: e.author_fullname,
					authorIsBlocked: e.author_is_blocked,
					audioRoom: e.audioRoom,
					approvedAtUTC: e.approved_at_utc,
					approvedBy: e.approved_by,
					bannedAtUTC: e.banned_at_utc,
					bannedBy: e.banned_by,
					belongsTo: {
						type: "user" === e.subreddit_type ? "profile" : "subreddit",
						id: e.subreddit_id || ""
					},
					callToAction: e.call_to_action || null,
					contestMode: e.contest_mode,
					created: 1e3 * e.created,
					crosspostParentId: e.cross_post_parent_id || null,
					crosspostRootId: e.cross_post_root_id || null,
					discussionType: e.discussion_type || null,
					distinguishType: e.distinguish_type || null,
					domain: e.domain,
					domainOverride: e.domain_override || null,
					events: e.events || [],
					flair: d(e),
					hidden: e.hidden,
					id: e.name,
					ignoreReports: e.ignore_reports,
					impressionId: e.impression_id ? String(e.impression_id) : null,
					impressionIdStr: e.impression_id_str,
					isApproved: e.approved,
					isArchived: e.archived,
					isAuthorPremium: e.author_premium,
					isBlank: e.is_blank,
					isCreatedFromAdsUi: e.is_created_from_ads_ui,
					isCrosspostable: e.is_crosspostable,
					isEligibleForQASchema: !1,
					isFollowed: e.is_followed || !1,
					isGildable: e.can_gild,
					isLocked: e.locked,
					isReactAllowed: !1,
					reactedFrom: null,
					attributionInfo: null,
					isMediaOnly: e.media_only,
					isMeta: e.is_meta,
					isNSFW: e.over_18,
					isOriginalContent: e.is_original_content,
					isPinned: e.pinned,
					isRemoved: e.removed,
					isSpam: e.spam,
					isSpoiler: e.spoiler,
					isSponsored: e.promoted,
					isSurveyAd: !!e.is_survey_ad,
					isStickied: e.stickied,
					liveCommentsWebsocket: e.liveCommentsWebsocket || e.websocket_url,
					media: l(e),
					modNote: e.mod_note || null,
					modReports: e.mod_reports,
					numComments: e.num_comments,
					numCrossposts: e.num_crossposts || 0,
					numDuplicates: e.num_duplicates,
					numReports: e.num_reports || 0,
					permalink: `https://www.reddit.com${e.permalink}`,
					postCategories: c(e.post_categories),
					preview: e.preview && e.preview.images && e.preview.images[0] && e.preview.images[0].source ? {
						url: e.preview.images[0].source.url,
						width: e.preview.images[0].source.width,
						height: e.preview.images[0].source.height
					} : void 0,
					previewComments: [],
					previousVisits: e.previous_visits,
					postId: e.name,
					modRemovalReason: e.mod_reason_title,
					modReasonBy: e.mod_reason_by,
					removedBy: e.removed_by,
					removedByCategory: e.removed_by_category,
					saved: e.saved,
					score: e.score,
					topAwardedType: e.top_awarded_type && e.top_awarded_type.toUpperCase(),
					treatmentTags: e.treatment_tags,
					isScoreHidden: !!e.hide_score,
					sendReplies: e.send_replies,
					source: u(e),
					suggestedSort: e.suggested_sort,
					thumbnail: {
						url: e.thumbnail,
						width: e.thumbnail_width,
						height: e.thumbnail_height
					},
					title: e.title,
					userReports: e.user_reports,
					upvoteRatio: e.upvote_ratio,
					viewCount: e.view_count || 0,
					voteState: Object(a.d)(e.likes)
				}
			}
		},
		"./src/reddit/helpers/r2/normalizeR2APIErrors/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/lib/constants/index.ts");
			const r = e => {
					for (const t of e) {
						const e = t[0] || "";
						switch (e) {
							case s.L.NO_STRIPE_SUBSCRIPTION:
							case s.L.USER_DOESNT_EXIST:
							case s.L.USER_REQUIRED_ERROR:
							case s.L.VALIDATION_ERROR:
								return e;
							case s.L.NO_USER:
							case s.L.NO_TEXT:
							case s.L.NO_URL:
								return s.L.VALIDATION_ERROR;
							case s.L.CREDIT_CARD_FAILURE:
							case s.L.CREDIT_CARD_FAILURE_GENERIC:
								return s.L.CREDIT_CARD_FAILURE;
							default:
								if (e.startsWith("SUBMIT_VALIDATION")) return s.L.SUBMIT_VALIDATION_ERROR
						}
					}
					return s.L.VALIDATION_ERROR
				},
				o = e => {
					const t = e.body;
					return {
						type: r(t.json.errors),
						fields: t.json.errors.map(e => ({
							field: e[2] || "",
							msg: e[1]
						}))
					}
				},
				i = e => {
					const t = e.body;
					return !e.ok && t && t.json && t.json.errors ? {
						...e,
						error: o(e)
					} : e
				};
			t.a = o
		},
		"./src/reddit/helpers/readOnlyMode/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})), n.d(t, "c", (function() {
					return o
				})),
				function(e) {
					e.editable = "editable", e.focusableReadOnly = "focusablereadonly", e.readOnly = "readonly"
				}(s || (s = {}));
			const r = e => o(e) || e === s.focusableReadOnly,
				o = e => e === s.readOnly
		},
		"./src/reddit/helpers/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			})), n.d(t, "e", (function() {
				return E
			})), n.d(t, "h", (function() {
				return y
			})), n.d(t, "g", (function() {
				return C
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js");
			n("./node_modules/react/index.js");
			const r = function(e) {
				if (void 0 === e) throw new Error("invariant(...): Second argument must be a string.")
			};

			function o(e, t) {
				for (var n = arguments.length, s = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++) s[o - 2] = arguments[o];
				if (r(t), !e) {
					let e;
					if (void 0 === t) e = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
					else {
						let n = 0;
						(e = new Error(t.replace(/%s/g, () => String(s[n++])))).name = "Invariant Violation"
					}
					throw e.framesToPop = 1, e
				}
			}
			const i = {
					AND: "AND",
					NONE: "NONE",
					OR: "OR"
				},
				a = {
					COMMA: "COMMA",
					SEMICOLON: "SEMICOLON"
				};
			var d = function(e, t, n) {
					const r = e.length;
					if (0 === r) return "";
					if (1 === r) return e[0];
					const d = e[r - 1];
					let c = e[0];
					for (let o = 1; o < r - 1; ++o) switch (n) {
						case a.SEMICOLON:
							c = s.fbt._("{previous items}; {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "4hs4xq"
							});
							break;
						default:
							c = s.fbt._("{previous items}, {following items}", [s.fbt._param("previous items", c), s.fbt._param("following items", e[o])], {
								hk: "2z8RMb"
							})
					}
					return function(e, t, n, r) {
						switch (n) {
							case i.AND:
								return s.fbt._("{list of items} and {last item }", [s.fbt._param("list of items", e), s.fbt._param("last item ", t)], {
									hk: "1ylan1"
								});
							case i.OR:
								return s.fbt._("{list of items} or {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
									hk: "3q8AmB"
								});
							case i.NONE:
								switch (r) {
									case a.SEMICOLON:
										return s.fbt._("{previous item}; {last item}", [s.fbt._param("previous item", e), s.fbt._param("last item", t)], {
											hk: "1h77rJ"
										});
									default:
										return s.fbt._("{list of items}, {last item}", [s.fbt._param("list of items", e), s.fbt._param("last item", t)], {
											hk: "3Q0iaX"
										})
								}
								default:
									o(!1, "Invalid conjunction %s provided to intlList", n)
						}
					}(c, d, t || i.AND, n || a.COMMA)
				},
				c = n("./src/lib/timezone/index.ts"),
				l = n("./src/reddit/helpers/isArrayEqual.ts"),
				u = n("./src/reddit/helpers/ordinal/index.ts"),
				m = n("./src/reddit/models/ScheduledPost/index.ts");
			const p = e => {
					return `${e.toLocaleDateString(void 0,{month:"numeric",day:"numeric"})} @ ${e.toLocaleTimeString(void 0,{hour:"numeric",minute:"numeric"}).replace(" ","").toLowerCase()}`
				},
				b = (e, t) => {
					if (e && t) {
						const n = Object(c.f)(h(e, t)),
							r = p(n);
						return s.fbt._("At {time}", [s.fbt._param("time", r)], {
							hk: "25s5Tg"
						})
					}
					return s.fbt._("Submit post at scheduled event time", null, {
						hk: "lYsoU"
					})
				},
				f = e => e.slice(0, 5),
				h = (e, t) => `${e}T${f(t)}:00`,
				_ = e => {
					const [t, n] = e.split("T");
					return [t, f(n)]
				},
				g = e => {
					const [t, n] = _(e);
					if (t && n) {
						const e = Object(c.f)(h(t, n));
						return p(e)
					}
					return ""
				},
				v = e => {
					const t = Object(c.d)(e);
					let n, s = e;
					if (t) {
						n = t.offset, s = `(GMT${Object(c.e)(t.offset)}) ${e.replace("/"," - ").replace(/_/g," ")}`
					}
					return {
						name: e,
						displayText: s,
						offset: n
					}
				},
				x = e => "string" == typeof e,
				O = e => {
					const t = new Date,
						n = e - t.getDay();
					return t.setDate(t.getDate() + n), t.toLocaleDateString(void 0, {
						weekday: "long"
					})
				},
				E = e => {
					const t = (e => {
						const [t, n] = _(e);
						if (t && n) {
							return Object(c.f)(h(t, n)).toLocaleTimeString(void 0, {
								hour: "numeric",
								minute: "numeric"
							})
						}
						return ""
					})(e.publishAt);
					if (e.frequency === m.d.Hourly) return 2 === e.interval ? s.fbt._("Every other hour", null, {
						hk: "64vzK"
					}) : e.interval > 1 ? s.fbt._("Every {hour interval} hours", [s.fbt._param("hour interval", e.interval.toString())], {
						hk: "3x8zaD"
					}) : s.fbt._("Every hour", null, {
						hk: "1VzCs"
					});
					if (e.frequency === m.d.Daily) return 2 === e.interval ? s.fbt._("Every other day at {start time}", [s.fbt._param("start time", t)], {
						hk: "yTynp"
					}) : e.interval > 1 ? s.fbt._("Every {day interval} days at {start time}", [s.fbt._param("day interval", e.interval.toString()), s.fbt._param("start time", t)], {
						hk: "2OoGlG"
					}) : s.fbt._("Every day at {start time}", [s.fbt._param("start time", t)], {
						hk: "1cvwm2"
					});
					if (e.frequency === m.d.Weekly) {
						const n = (e => d(e.map(m.l).sort((e, t) => e - t).map(O), i.AND, a.COMMA))(e.byWeekDays);
						return 2 === e.interval ? s.fbt._("Every other week on {days of week } at {start time}", [s.fbt._param("days of week ", n), s.fbt._param("start time", t)], {
							hk: "43xwaa"
						}) : e.interval > 1 ? s.fbt._("Every {interval} weeks on {days of week} at {start time}", [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2IVbH"
						}) : s.fbt._("Every week on {days of week} at {start time}", [s.fbt._param("days of week", n), s.fbt._param("start time", t)], {
							hk: "2Zl0L"
						})
					}
					const n = (e => d(e.sort((e, t) => e - t).map(u.a), i.AND, a.COMMA))(e.byMonthDays);
					return 2 === e.interval ? s.fbt._({
						"*": "Every other month on the {days of month} days at {start time}",
						_1: "Every other month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "okH9o"
					}) : e.interval > 1 ? s.fbt._({
						"*": "Every {interval} months on the {days of month} days at {start time}",
						_1: "Every {interval} months on the {days of month} day at {start time}"
					}, [s.fbt._param("interval", e.interval.toString()), s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "KqN3x"
					}) : s.fbt._({
						"*": "Every month on the {days of month} days at {start time}",
						_1: "Every month on the {days of month} day at {start time}"
					}, [s.fbt._param("days of month", n), s.fbt._plural(e.byMonthDays.length), s.fbt._param("start time", t)], {
						hk: "1jBuYc"
					})
				},
				y = e => {
					let t = null;
					e.frequency && (t = e.frequency), (e.byWeekDays.length > 1 || e.byMonthDays.length > 1 || e.interval > 1) && (t = m.b);
					const n = Object(c.f)(e.publishAt),
						s = Object(m.r)(n.getDay()),
						r = n.getDate();
					return 1 === e.byWeekDays.length && e.byWeekDays[0] !== s && (t = m.b), 1 === e.byMonthDays.length && e.byMonthDays[0] !== r && (t = m.b), {
						recurrenceInfo: e.frequency ? {
							frequency: e.frequency,
							byMonthDays: e.byMonthDays,
							byWeekDays: e.byWeekDays,
							interval: e.interval
						} : null,
						frequencyOption: t,
						submitDate: e.publishAt,
						timezoneName: e.clientTimezone
					}
				},
				C = (e, t) => {
					if (!e && t || e && !t) return !1;
					if (!e && !t) return !0;
					for (const n in e) {
						if (!t) return !1;
						if (e.hasOwnProperty(n)) {
							if (Array.isArray(e[n]) && (!Array.isArray(t[n]) || !Object(l.a)(e[n], t[n]))) return !1;
							if (e[n] !== t[n]) return !1
						}
					}
					return !0
				}
		},
		"./src/reddit/helpers/sessionStorage/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "d", (function() {
					return o
				})), n.d(t, "b", (function() {
					return i
				})), n.d(t, "a", (function() {
					return a
				})), n.d(t, "c", (function() {
					return d
				})),
				function(e) {
					e.COMMENT_BEFORE_SIGNUP_STORAGE = "comment_before_signup_storage"
				}(s || (s = {}));
			const r = e => {
					if (window.sessionStorage) {
						const t = window.sessionStorage.getItem(e);
						if (t) return JSON.parse(t)
					}
					return null
				},
				o = e => {
					((e, t) => {
						window.sessionStorage && window.sessionStorage.setItem(e, JSON.stringify(t))
					})(s.COMMENT_BEFORE_SIGNUP_STORAGE, e)
				},
				i = () => r(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				a = () => (e => {
					window.sessionStorage && window.sessionStorage.removeItem(e)
				})(s.COMMENT_BEFORE_SIGNUP_STORAGE),
				d = () => {
					return !!r(s.COMMENT_BEFORE_SIGNUP_STORAGE)
				}
		},
		"./src/reddit/helpers/showReportIndicator/index.ts": function(e, t, n) {
			"use strict";
			t.a = e => !e.ignoreReports && (e.numReports || 0) > 0
		},
		"./src/reddit/helpers/styles/mixins/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			})), n.d(t, "d", (function() {
				return _
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/helpers/styles/postBackgroundColor.ts"),
				o = n("./src/reddit/helpers/styles/smartTextColor.ts"),
				i = n("./src/reddit/models/NewStructuredStyles/index.ts"),
				a = n("./src/reddit/models/Theme/index.ts"),
				d = n("./src/reddit/models/Theme/NewColorSystem/index.ts"),
				c = n("./src/reddit/helpers/styles/mixins/index.m.less"),
				l = n.n(c);
			const u = {},
				m = e => Object(a.g)(Object(d.a)(e).post, Object(d.a)(e).backgroundImage, Object(d.a)(e).backgroundImagePosition),
				p = (e, t) => {
					if (e) {
						if (e.postBackgroundImage) return {
							background: Object(a.g)(e.postBackgroundColor || Object(d.a)(t).post, e.postBackgroundImage, Object(d.a)(t).backgroundImagePosition)
						};
						if (e.postBackgroundColor) return {
							background: Object(a.g)(e.postBackgroundColor, null, null)
						}
					}
					return {
						background: m(t)
					}
				},
				b = e => Object(s.k)(.2, e),
				f = e => e && e.postBackgroundColor ? {
					backgroundColor: b(e.postBackgroundColor)
				} : u,
				h = e => e.isActive ? l.a.mIsActive : void 0,
				_ = e => {
					const t = Object(o.a)(Object(r.a)(e), i.a.actionIcon, i.b.actionIcon);
					return {
						color: t,
						cursor: "pointer",
						fill: t
					}
				}
		},
		"./src/reddit/helpers/styles/mixins/loading.m.less": function(e, t, n) {
			e.exports = {
				loadingBackground: "fzTkuBRFT8iIn1XnJX_Yn",
				"m-loading": "_34yMY7-6MNnz3utfjExvIq",
				mLoading: "_34yMY7-6MNnz3utfjExvIq",
				gradientAnimation: "vnt666wwqSK5qL63sBn9P",
				loadingBar: "_3giTODNeZ-Po90u8Ghs4aI",
				loadingContainer: "VRC9QT7CgUxvhK0ceQSrn"
			}
		},
		"./src/reddit/helpers/styles/mixins/loading.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/lib/classNames/index.ts"),
				r = n("./src/reddit/helpers/styles/mixins/loading.m.less"),
				o = n.n(r);
			const i = e => {
					let {
						isLoading: t
					} = e;
					return Object(s.a)(o.a.loadingBackground, {
						[o.a["m-loading"]]: t
					})
				},
				a = e => Object(s.a)(o.a.loadingBar, i(e))
		},
		"./src/reddit/helpers/styles/postBackgroundColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			}));
			n("./node_modules/polished/dist/polished.es.js");
			var s = n("./src/reddit/models/Theme/NewColorSystem/index.ts");

			function r(e) {
				return e.flairStyleTemplate && e.flairStyleTemplate.postBackgroundColor ? e.flairStyleTemplate.postBackgroundColor : Object(s.a)(e).post
			}
		},
		"./src/reddit/helpers/styles/smartTextColor.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/polished/dist/polished.es.js"),
				r = n("./src/reddit/models/NewStructuredStyles/index.ts");
			const o = e => Object(s.b)(e) < .6;

			function i(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a.bodyText,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r.b.bodyText;
				return o(e) ? n : t
			}
		},
		"./src/reddit/helpers/tabBadging/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s = n("./src/config.ts");
			const r = `${s.a.assetPath}/img/favicon/badged-favicon-32x32.png`,
				o = `${s.a.assetPath}/img/favicon/badged-favicon-16x16.png`,
				i = `${s.a.assetPath}/img/favicon/favicon-32x32.png`,
				a = `${s.a.assetPath}/img/favicon/favicon-16x16.png`,
				d = "badgeCountSync",
				c = e => window.document.querySelector(`link[href="${e}"]`),
				l = function() {
					let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					const t = c(e ? i : r),
						n = c(e ? a : o);
					t && n && (t.href = e ? r : i, n.href = e ? o : a)
				},
				u = e => {
					navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
						command: d,
						badgeCounts: e
					})
				}
		},
		"./src/reddit/helpers/tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s);
			const o = e => r()(e).sort((t, n) => {
					const s = e[t.tag.id].tag.text.toLowerCase(),
						r = e[n.tag.id].tag.text.toLowerCase();
					return s < r ? -1 : s > r ? 1 : 0
				}),
				i = e => !e.id && !!e.action
		},
		"./src/reddit/helpers/toggleBodyScroll/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/reddit/constants/elementIds.ts");
			let r;
			const o = () => {
					const e = document.body.dataset.previousOverflow;
					if (!e) return;
					document.body.removeAttribute("data-previous-overflow");
					const t = document.getElementById(s.d);
					document.body.style.overflow = e, document.body.style.marginRight = "", t && (t.style.marginRight = "")
				},
				i = () => {
					if (document.body.dataset.previousOverflow) return;
					const e = document.body.style.overflow || "auto";
					document.body.dataset.previousOverflow = e, r || (r = d(document.body)), document.body.style.overflow = "hidden", document.body.style.marginRight = `${r}px`;
					const t = document.getElementById(s.d);
					t && (t.style.marginRight = `${r}px`)
				},
				a = e => {
					e ? o() : i()
				},
				d = e => {
					const t = e.getBoundingClientRect();
					return window.innerWidth - (t.left + t.right)
				},
				c = e => {
					if (!e || !document.body) return 0;
					const t = d(document.body),
						n = e.offsetWidth - e.scrollWidth;
					return t || n
				}
		},
		"./src/reddit/helpers/trackers/ads.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/helpers/localStorage/index.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			const i = (e, t, n) => r => ({
					source: "post",
					action: "view",
					noun: "programmatic_ad",
					...o.o(r),
					subreddit: o.kb(r),
					programmatic: {
						adUnit: null !== e && null !== t ? `DESKTOP ${e}x${t} ${n}` : `DESKTOP ${n}`,
						count: 1,
						type: s.h.SWITCH_HOUSE_AD
					}
				}),
				a = (e, t) => {
					t && (Object(r.Eb)(e.postId), Object(r.Nb)(t)), e.impressionIdStr ? Object(r.Fb)(e.impressionIdStr) : e.impressionId && Object(r.Fb)(e.impressionId)
				}
		},
		"./src/reddit/helpers/trackers/blade.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "j", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "k", (function() {
				return g
			}));
			var s = n("./src/reddit/constants/blade.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => n => ({
					...r.o(n),
					source: s.c.Appearance,
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: t
					}),
					subreddit: r.kb(n)
				}),
				i = e => o("save_style", e),
				a = e => o("cancel_style", e),
				d = e => t => ({
					source: s.c.Structure,
					action: "click",
					noun: e,
					screen: r.cb(t),
					subreddit: r.kb(t)
				}),
				c = e => t => ({
					source: s.c.Appearance,
					action: "click",
					noun: e,
					screen: r.cb(t),
					subreddit: r.kb(t)
				}),
				l = (e, t) => n => ({
					source: "colorpicker",
					action: "click",
					noun: e,
					actionInfo: r.d(n, {
						paneName: s.f[t]
					}),
					screen: r.cb(n),
					subreddit: r.kb(n)
				}),
				u = e => t => ({
					source: s.g[e],
					action: "click",
					noun: "colorpicker",
					actionInfo: r.d(t, {
						paneName: s.f[e]
					}),
					screen: r.cb(t),
					subreddit: r.kb(t)
				}),
				m = e => ({
					screen: r.cb(e),
					subreddit: r.kb(e)
				}),
				p = () => e => ({
					source: s.c.Appearance,
					action: "view",
					noun: "blade",
					...m(e)
				}),
				b = e => t => ({
					source: s.a[e],
					action: "click",
					noun: s.b[e],
					...m(t)
				}),
				f = () => e => ({
					source: s.c.Appearance,
					action: "click",
					noun: "back",
					...m(e)
				}),
				h = e => t => ({
					source: s.c.PostFlairManagement,
					action: "click",
					noun: e,
					...m(t)
				}),
				_ = (e, t) => ({
					...r.o(e),
					...h(t)(e)
				}),
				g = e => t => ({
					source: s.c.MenuLinks,
					action: "click",
					noun: e ? "wiki_link_on" : "wiki_link_off",
					screen: r.cb(t),
					subreddit: r.kb(t),
					userSubreddit: r.ub(t)
				})
		},
		"./src/reddit/helpers/trackers/comment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			}));
			var s = n("./src/telemetry/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => ({
					profile: r.T(e),
					post: r.K(e, t),
					media: r.C(e, t),
					subreddit: r.kb(e),
					comment: r.h({
						state: e,
						commentId: t
					})
				}),
				i = e => {
					let {
						state: t,
						commentId: n,
						collapsed: i
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "view",
						noun: i ? "collapsed_comment" : "comment",
						...r.o(t),
						...o(t, n)
					})
				},
				a = e => {
					let {
						state: t,
						commentId: n,
						collapsed: i
					} = e;
					return Object(s.a)({
						source: "comment",
						action: "consume",
						noun: i ? "collapsed_comment" : "comment",
						...r.o(t),
						...o(t, n)
					})
				},
				d = e => t => ({
					source: "online_presence",
					action: "view",
					noun: "user",
					user: r.sb(t),
					subreddit: r.kb(t),
					post: r.K(t, e),
					actionInfo: r.d(t),
					app: r.f(t),
					referrer: r.Z(t),
					session: r.gb(t)
				}),
				c = e => t => ({
					source: "post_detail",
					action: "click",
					noun: "comment_image",
					...r.o(t),
					...o(t, e)
				})
		},
		"./src/reddit/helpers/trackers/commentsChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return l
			})), n.d(t, "j", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "e", (function() {
				return _
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "l", (function() {
				return v
			})), n.d(t, "g", (function() {
				return x
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "k", (function() {
				return E
			}));
			var s = n("./src/lib/makeCommentsPageKey/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/comments.ts"),
				i = n("./src/reddit/selectors/commentSelector.ts"),
				a = n("./src/reddit/selectors/telemetry.ts"),
				d = n("./src/telemetry/models/Event.ts");
			const c = (e, t) => ({
					...Object(a.o)(e),
					subreddit: Object(a.kb)(e),
					profile: Object(a.T)(e),
					post: Object(a.K)(e, t),
					comment: Object(a.h)({
						state: e,
						commentId: t
					})
				}),
				l = (e, t) => {
					const n = Object(i.b)(e, {
							commentId: t
						}),
						r = n && Object(s.a)(n.postId);
					if (!n || !r) return null;
					const d = {
							commentId: t,
							commentsPageKey: r
						},
						c = t && r && Object(o.j)(e, d) || 0;
					return Object(a.z)(e, void 0, {
						depth: c
					})
				},
				u = e => {
					var t;
					return null !== (t = e.split("chat_reaction_")[1]) && void 0 !== t ? t : ""
				},
				m = (e, t) => n => ({
					action: "load",
					noun: e,
					post: Object(a.K)(n, t),
					source: d.b.ChatView,
					subreddit: Object(a.kb)(n)
				}),
				p = (e, t) => n => ({
					...c(n, t),
					source: "live_post",
					action: r.c.CLICK,
					noun: e,
					actionInfo: {
						reason: "live_post",
						pageType: "actions_menu"
					},
					listing: l(n, t)
				}),
				b = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "last_message"
				}),
				f = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.SUBMIT,
					noun: "reply",
					post: Object(a.K)(t, e),
					comment: Object(a.h)({
						state: t,
						commentId: e
					}),
					actionInfo: Object(a.d)(t, {
						reason: "live_post",
						type: "live_post"
					})
				}),
				h = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLICK,
					noun: "comment",
					actionInfo: Object(a.d)(t, {
						pageType: "user_mention",
						reason: "live_post",
						type: "live_post"
					})
				}),
				_ = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.VIEW,
					noun: "warning",
					post: Object(a.K)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				g = e => t => ({
					...c(t, e),
					source: "chat_post",
					action: r.c.CLOSE,
					noun: "warning",
					post: Object(a.K)(t, e),
					actionInfo: {
						pageType: "spam_rate_countdown"
					}
				}),
				v = e => t => ({
					...c(t, e),
					source: "global",
					action: r.c.VIEW,
					noun: "screen",
					actionInfo: {
						reason: "live_post",
						pageType: "given_awards_list"
					},
					listing: l(t, e)
				}),
				x = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.CLICK,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				}),
				O = (e, t, n) => s => ({
					...c(s, t),
					source: d.b.Chat,
					action: r.c.DELETE,
					noun: "reaction",
					actionInfo: {
						pageType: n,
						reason: u(e)
					},
					chat: {
						type: "live_post"
					},
					listing: l(s, t)
				}),
				E = () => e => {
					var t;
					return {
						...Object(a.o)(e),
						subreddit: Object(a.kb)(e),
						profile: Object(a.T)(e),
						actionInfo: {
							...Object(a.d)(e),
							paneName: (null === window || void 0 === window ? void 0 : window.parent) !== window ? "chat_tab" : (null === (t = null == e ? void 0 : e.platform.currentPage) || void 0 === t ? void 0 : t.locationState.clickSource) || ""
						},
						source: "chat_post",
						action: r.c.VIEW,
						noun: "hint"
					}
				}
		},
		"./src/reddit/helpers/trackers/commentsPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "k", (function() {
				return O
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "l", (function() {
				return C
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/models/PostDraft/index.ts"),
				a = n("./src/reddit/selectors/comments.ts"),
				d = n("./src/reddit/selectors/platform.ts"),
				c = n("./src/reddit/selectors/telemetry.ts"),
				l = n("./src/telemetry/index.ts"),
				u = n("./src/reddit/constants/richTextJson.ts");
			const m = e => {
					const t = Object(d.p)(e);
					return {
						source: "comment_composer",
						action: r.c.CLICK,
						...Object(c.o)(e),
						screen: Object(c.cb)(e),
						subreddit: Object(c.kb)(e),
						post: t ? Object(c.K)(e, t) : null,
						profile: Object(c.T)(e),
						correlationId: Object(o.c)(o.a.CommentComposer)
					}
				},
				p = async (e, t, s, r, o) => {
					const i = {
							commentId: o,
							commentsPageKey: s
						},
						d = o && Object(a.j)(e, i) || 0,
						{
							getFlairData: u
						} = await n.e("getFlairData").then(n.bind(null, "./src/reddit/helpers/trackers/features/getFlairData.ts")),
						p = r ? "image" : void 0;
					return Object(l.a)({
						noun: "comment",
						...m(e),
						comment: o ? Object(c.h)({
							state: e,
							commentId: o,
							contentType: p
						}) : null,
						listing: Object(c.z)(e, void 0, {
							depth: d
						}),
						commentComposer: {
							editorMode: t
						},
						userFlair: u(e),
						media: {
							mimetype: null == r ? void 0 : r.mimetype,
							size: null == r ? void 0 : r.size
						}
					})
				}, b = e => {
					let {
						state: t,
						bodyText: n,
						postId: r,
						error: o,
						parentId: i,
						uploadMetadata: a
					} = e;
					const d = m(t),
						c = o.type === s.Pb ? "karma_rate_limit" : o.fields && o.fields.length > 0 ? o.fields[0].msg : void 0,
						p = a ? "image" : function(e) {
							return e.includes(`"id":"${u.c}`)
						}("string" == typeof n ? n : JSON.stringify(n)) ? "giphy" : void 0;
					return Object(l.a)({
						...d,
						source: o.type === s.Pb ? "backend" : "comment_composer",
						actionInfo: {
							...d.actionInfo,
							reason: c
						},
						action: "error",
						noun: "comment",
						comment: {
							bodyText: n,
							parentId: i,
							postId: r,
							contentType: p
						},
						media: {
							mimetype: null == a ? void 0 : a.mimetype,
							size: null == a ? void 0 : a.size
						}
					})
				}, f = e => Object(l.a)({
					noun: "cancel",
					...m(e)
				}), h = (e, t) => {
					t === i.c.replyToPost && Object(l.a)({
						noun: "input",
						...m(e)
					})
				}, _ = (e, t) => Object(l.a)({
					source: "comment",
					noun: "delete",
					action: "click",
					...Object(c.o)(t),
					screen: Object(c.cb)(t),
					subreddit: Object(c.kb)(t),
					post: Object(c.K)(t, e)
				}), g = e => Object(l.a)({
					noun: "edit",
					...m(e)
				}), v = e => Object(l.a)({
					noun: "save_edit",
					...m(e)
				}), x = (e, t) => n => {
					const s = "image_upload" === e || "video_upload" === e;
					return {
						...m(n),
						noun: s ? e : "text_option",
						commentComposer: {
							textType: e,
							finalStatus: t ? "on" : "off"
						}
					}
				}, O = () => e => ({
					...m(e),
					action: "open",
					noun: "gif_tooltip"
				}), E = e => t => ({
					...m(t),
					action: "change",
					noun: "gif_tooltip_search",
					search: {
						query: e
					}
				}), y = () => e => ({
					...m(e),
					action: "select",
					noun: "gif_tooltip_result"
				}), C = () => e => ({
					...m(e),
					source: "comment_composer",
					action: "open",
					noun: "images_tooltip"
				})
		},
		"./src/reddit/helpers/trackers/communityAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			}));
			var s = n("./src/reddit/models/Gold/Award.ts"),
				r = n("./src/reddit/selectors/telemetry.ts"),
				o = n("./src/reddit/helpers/correlationIdTracker.ts"),
				i = n("./src/reddit/helpers/trackers/gild.ts");
			const a = e => ({
					...r.o(e),
					screen: r.cb(e),
					subreddit: r.kb(e),
					userSubreddit: r.ub(e)
				}),
				d = e => ({
					awardId: e.id,
					awardName: e.name,
					isModAward: e.awardType === s.f.Moderator,
					isTemporatyAward: !!e.endsAt,
					numberCoins: e.coinPrice,
					numberMonths: Math.floor((e.daysOfPremium || 0) / 30),
					numberCoinsToRecipient: e.coinReward || 0,
					numberCoinsToCommunity: e.subredditCoinReward || 0,
					type: Object(i.getAwardTypeFromAward)(e)
				}),
				c = () => e => ({
					...a(e),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create"
				}),
				l = e => t => ({
					...a(t),
					source: "awards",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardDeletionFlow),
					noun: "delete",
					goldPurchase: e ? d(e) : null,
					media: e ? {
						url: e.icon.url
					} : null
				}),
				u = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n
				}),
				m = (e, t, n, s) => r => ({
					...a(r),
					source: "create_award",
					action: "upload",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "image",
					actionInfo: s ? {
						reason: s
					} : {
						success: !0
					},
					media: t ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						uploadDuration: n,
						url: e,
						width: t.width
					} : null
				}),
				p = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: "click",
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: "create",
					media: t && e ? {
						fileName: t.file.name,
						height: t.height,
						id: t.id,
						mimetype: t.file.type,
						size: t.file.size,
						type: "image",
						url: e,
						width: t.width
					} : null,
					goldPurchase: n ? d(n) : null
				}),
				b = (e, t, n) => s => ({
					...a(s),
					source: "create_award",
					action: e,
					correlationId: Object(o.c)(o.a.AwardCreationFlow),
					noun: t,
					goldPurchase: n ? d(n) : null
				}),
				f = (e, t, n) => s => ({
					...a(s),
					source: "awards",
					action: "click",
					noun: n,
					goldPurchase: d(e),
					profile: r.U(s, t),
					subreddit: r.lb(s, t)
				}),
				h = (e, t) => f(e, t, "disable_in_community"),
				_ = (e, t) => f(e, t, "enable_in_community")
		},
		"./src/reddit/helpers/trackers/communitySettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "g", (function() {
				return _
			})), n.d(t, "a", (function() {
				return g
			})), n.d(t, "c", (function() {
				return v
			}));
			var s = n("./node_modules/lodash/snakeCase.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = {
					contentOptions: "link_type",
					contentVisible: "allow_top",
					subredditType: "type",
					welcomeMessageText: "welcome_message"
				},
				d = {
					allowChatPostCreation: o.nc.Posts,
					allowDiscovery: o.nc.Safety,
					allowGalleries: o.nc.Posts,
					allowImages: o.nc.Posts,
					allowPolls: o.nc.Posts,
					allowPostCrossposts: o.nc.Posts,
					collapseDeletedComments: o.nc.Posts,
					commentScoreHideMins: o.nc.Posts,
					contentOptions: o.nc.Posts,
					contentVisible: o.nc.Safety,
					crowdControlChatLevel: o.nc.Safety,
					crowdControlPostLevel: o.nc.Safety,
					crowdControlLevel: o.nc.Safety,
					crowdControlFilter: o.nc.Safety,
					crowdControlMode: o.nc.Safety,
					disableContributorRequests: o.nc.Community,
					excludeBannedModqueue: o.nc.Safety,
					over18: o.nc.Community,
					publicDescription: o.nc.Community,
					restrictCommenting: o.nc.Community,
					restrictPosting: o.nc.Community,
					spamComments: o.nc.Posts,
					spamLinks: o.nc.Posts,
					spamSelfposts: o.nc.Posts,
					spoilersEnabled: o.nc.Posts,
					subredditType: o.nc.Community,
					suggestedCommentSort: o.nc.Posts,
					toxicityThresholdChatLevel: o.nc.Safety,
					welcomeMessageEnabled: o.nc.Community,
					welcomeMessageText: o.nc.Community,
					wikiEditAge: o.nc.Wikis,
					wikiEditKarma: o.nc.Wikis,
					wikimode: o.nc.Wikis
				},
				c = {
					[o.nc.Community]: "community_settings_details",
					[o.nc.Notifications]: "community_settings_notifications",
					[o.nc.Safety]: "community_settings_safety",
					[o.nc.Posts]: "community_settings_content",
					[o.nc.Wikis]: "community_settings_wiki",
					[o.nc.ContentTag]: "content_tag"
				},
				l = e => a[e] || r()(e),
				u = e => {
					const t = d[e];
					return t && c[t] || "community_settings"
				};

			function m(e) {
				return "object" == typeof e ? JSON.stringify(e) : String(e)
			}
			const p = (e, t, n) => s => ({
					source: u(e),
					action: "click",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: i.kb(s),
					...i.o(s)
				}),
				b = (e, t, n) => s => ({
					source: u(e),
					action: "save",
					noun: l(e),
					setting: {
						value: m(t),
						oldValue: m(n)
					},
					subreddit: i.kb(s),
					...i.o(s)
				}),
				f = e => t => ({
					source: "community_settings",
					action: "click",
					noun: c[e],
					...i.o(t)
				}),
				h = e => t => ({
					source: c[e],
					action: "click",
					noun: "r2_community_settings",
					...i.o(t)
				}),
				_ = (e, t, n, s) => r => ({
					...i.o(r),
					source: "mod_tools",
					action: e,
					noun: t,
					...void 0 !== n && void 0 !== s && {
						setting: {
							value: String(n),
							oldValue: String(s)
						}
					},
					subreddit: i.kb(r),
					actionInfo: i.d(r, {
						reason: "welcome_message"
					})
				}),
				g = (e, t) => n => {
					var s;
					return {
						...i.o(n),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "click",
						noun: e,
						subreddit: i.kb(n),
						subredditId: null === (s = i.kb(n)) || void 0 === s ? void 0 : s.id,
						actionInfo: {
							settingValue: String(t)
						}
					}
				},
				v = (e, t, n) => s => {
					var r;
					return {
						...i.o(s),
						source: "language" === e.toLowerCase() ? "mod_tools" : "community_settings",
						action: "save",
						noun: e,
						subreddit: i.kb(s),
						subredditId: null === (r = i.kb(s)) || void 0 === r ? void 0 : r.id,
						setting: {
							value: String(t),
							oldValue: String(n)
						},
						actionInfo: {
							settingValue: String(t)
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/communityTopics.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "d", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "g", (function() {
				return g
			}));
			var s, r = n("./src/reddit/selectors/tags.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/telemetry/index.ts");
			! function(e) {
				e.communitySettings = "community_settings", e.idCard = "id_card"
			}(s || (s = {}));
			const a = (e, t, n) => {
					const s = Object(r.x)(e, {
						subredditId: t
					});
					return !!s && s.id === n
				},
				d = (e, t) => Object(r.u)(e, {
					itemId: t
				}).reduce((e, t) => {
					let {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					} = e;
					return n.push(t.tag.id), s.push(t.tag.text), r.push(t.tag.type), {
						topicTagIds: n,
						topicTagContents: s,
						topicTagTypes: r
					}
				}, {
					topicTagIds: [],
					topicTagContents: [],
					topicTagTypes: []
				}),
				c = (e, t, n) => {
					if (!n.id) return {
						content: n.displayText
					};
					const s = Object(r.b)(e)[n.id] || Object(r.d)(e, {
						subredditId: t
					})[n.id];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: a(e, t, s.id)
					} : null
				},
				l = (e, t, n) => {
					if (!n) return null;
					const s = Object(r.b)(e)[n] || Object(r.d)(e, {
						subredditId: t
					})[n];
					return s ? {
						id: s.id,
						content: s.text,
						type: s.type,
						isPrimary: a(e, t, s.id)
					} : null
				},
				u = (e, t, n) => ({
					...o.o(e),
					subreddit: {
						...o.kb(e) || {},
						id: t,
						...d(e, t)
					},
					source: n.context,
					action: "click"
				}),
				m = (e, t, n) => {
					Object(i.a)(((e, t, n) => ({
						...u(e, t.subredditId, n),
						noun: t.isRelevant ? "restore_related_topic" : "remove_related_topic",
						topicTag: l(e, t.subredditId, t.tagId)
					}))(e, t, n))
				},
				p = (e, t, n, s) => {
					Object(i.a)({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "add_related_topic"
					})
				},
				b = (e, t, n, s) => {
					return !Object(r.i)(e, {
						subredditId: t
					}) && n.id ? Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_suggest"
					}))(e, t, n, s)) : n.id ? Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_auto_complete"
					}))(e, t, n, s)) : Object(i.a)(((e, t, n, s) => ({
						...u(e, t, s),
						topicTag: c(e, t, n),
						noun: "topic_add_new"
					}))(e, t, n, s))
				},
				f = (e, t, n, s) => Object(i.a)({
					...u(e, t, s),
					topicTag: c(e, t, n),
					noun: "topic_remove"
				}),
				h = (e, t, n) => Object(i.a)({
					...u(e, t, n),
					noun: "topic_tag_field"
				}),
				_ = (e, t, n) => Object(i.a)({
					...u(e, t, n),
					noun: n.context === s.communitySettings ? "save" : "save_community_topics"
				}),
				g = (e, t, n, s) => {
					const r = u(e, t, s);
					Object(i.a)({
						...r,
						action: "view",
						noun: "error",
						actionInfo: {
							...r.actionInfo,
							reason: n
						}
					})
				}
		},
		"./src/reddit/helpers/trackers/contentTag.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return s
			})), n.d(t, "g", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "l", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "j", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "m", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "d", (function() {
				return _
			}));
			const s = () => () => ({
					source: "content_tag",
					action: "view",
					noun: "verify_topics_module"
				}),
				r = () => () => ({
					source: "content_tag",
					action: "click",
					noun: "verify_topics_module"
				}),
				o = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_intro",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				i = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "start",
					actionInfo: {
						pageType: "survey_intro"
					}
				}),
				a = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "mature_themes_prompt",
					actionInfo: {
						pageType: "survey_mature_themes"
					}
				}),
				d = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: e,
					actionInfo: {
						pageType: e
					}
				}),
				c = e => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "survey_answer",
					actionInfo: {
						pageType: e
					}
				}),
				l = (e, t) => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "next",
					actionInfo: {
						reason: t.join(),
						pageType: e
					}
				}),
				u = e => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "back",
					actionInfo: {
						pageType: e
					}
				}),
				m = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_summary",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				p = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "submit_survey",
					actionInfo: {
						pageType: "survey_rating_summary"
					}
				}),
				b = () => () => ({
					source: "content_tag_survey",
					action: "view",
					noun: "survey_rating_review",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				f = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "take_survey",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				h = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "message_modsupport",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				}),
				_ = () => () => ({
					source: "content_tag_survey",
					action: "click",
					noun: "learn_more",
					actionInfo: {
						pageType: "survey_rating_review"
					}
				})
		},
		"./src/reddit/helpers/trackers/emailInvite.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					action: "click",
					noun: "invite_via_email",
					...r.o(t),
					subreddit: r.kb(t),
					actionInfo: r.d(t),
					correlationId: Object(s.d)(s.a.SubredditCreation, !1)
				}),
				i = () => e => ({
					source: "email_invite_painted_door",
					action: "view",
					noun: "modal",
					...r.o(e),
					subreddit: r.kb(e),
					actionInfo: r.d(e),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				a = e => t => ({
					source: "email_invite_painted_door",
					action: "click",
					noun: e,
					...r.o(t),
					subreddit: r.kb(t),
					actionInfo: r.d(t),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				})
		},
		"./src/reddit/helpers/trackers/features/powerupsFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/comments.ts"),
				o = n("./src/reddit/selectors/gold/powerups/flairs.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, n) => a => {
					const d = Object(r.e)(a, {
							commentId: e
						}),
						c = Object(o.f)(a, {
							subredditId: t,
							userId: n
						});
					return {
						source: "meta",
						action: "hover",
						noun: "achieve_flair",
						...i.o(a),
						subreddit: {
							id: t
						},
						userFlair: {
							id: null == d ? void 0 : d.templateId,
							title: d ? Object(s.g)(d) : void 0,
							achievementFlairId: null == c ? void 0 : c.type,
							achievementFlairTitle: null == c ? void 0 : c.name
						}
					}
				},
				d = () => e => ({
					source: "powerups",
					action: "click",
					noun: "view_your_achievements",
					...i.o(e)
				})
		},
		"./src/reddit/helpers/trackers/feed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/index.ts");
			const o = e => t => Object(r.a)({
					...s.o(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "load",
					noun: "serving",
					feed: s.r(t)
				}),
				i = e => t => Object(r.a)({
					...s.o(t),
					actionInfo: s.d(t, {
						reason: e
					}),
					source: "feed",
					action: "fail",
					noun: "serving",
					feed: s.r(t)
				})
		},
		"./src/reddit/helpers/trackers/freeAwardOffer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/trackers/goldPayment.ts"),
				o = n("./src/reddit/models/Gold/ProductOffer.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = e => ({
					...Object(r.h)(e, {
						offerContext: o.a.StorefrontFreeAward
					}),
					correlationId: Object(s.d)(s.a.GoldPayment, !1),
					profile: i.T(e),
					subreddit: i.kb(e)
				}),
				d = () => e => ({
					source: "free_award_offer",
					action: "view",
					noun: "page",
					...a(e)
				}),
				c = e => t => ({
					source: "free_award_offer",
					action: "click",
					noun: e,
					...a(t)
				}),
				l = () => e => ({
					source: "tooltip",
					action: "view",
					noun: "try_free_award",
					...a(e)
				})
		},
		"./src/reddit/helpers/trackers/gild.ts": function(e, t, n) {
			"use strict";
			n.r(t), n.d(t, "getAwardTypeFromAward", (function() {
				return u
			})), n.d(t, "clickGildEvent", (function() {
				return b
			})), n.d(t, "clickRpanGiveAward", (function() {
				return f
			})), n.d(t, "clickAddAward", (function() {
				return h
			})), n.d(t, "clickHideAward", (function() {
				return _
			})), n.d(t, "clickConfirmHideAward", (function() {
				return g
			})), n.d(t, "clickCancelHideAward", (function() {
				return v
			})), n.d(t, "clickAwardReportFlow", (function() {
				return O
			})), n.d(t, "clickCancelAwardReportFlow", (function() {
				return E
			})), n.d(t, "clickFlagAwardUsage", (function() {
				return y
			})), n.d(t, "clickCancelFlagAwardUsage", (function() {
				return C
			})), n.d(t, "clickConfirmFlagAwardUsage", (function() {
				return j
			})), n.d(t, "clickReportAward", (function() {
				return k
			})), n.d(t, "clickCancelReportAward", (function() {
				return I
			})), n.d(t, "clickConfirmReportAward", (function() {
				return S
			})), n.d(t, "viewGildModalEvent", (function() {
				return w
			})), n.d(t, "clickSelectAwardEvent", (function() {
				return T
			})), n.d(t, "triggerAnonymousEvent", (function() {
				return N
			})), n.d(t, "clickMessageInputEvent", (function() {
				return P
			})), n.d(t, "typeMessageInputEvent", (function() {
				return R
			})), n.d(t, "clickLearnMoreLinkEvent", (function() {
				return A
			})), n.d(t, "clickQuestionMarkEvent", (function() {
				return M
			})), n.d(t, "clickConfirmAwardEvent", (function() {
				return L
			})), n.d(t, "clickGetPremiumEvent", (function() {
				return D
			})), n.d(t, "clickAddCoinsButtonEvent", (function() {
				return F
			})), n.d(t, "clickNextButtonEvent", (function() {
				return U
			})), n.d(t, "clickCloseGildModalEvent", (function() {
				return B
			})), n.d(t, "viewKarmaSuccessEvent", (function() {
				return q
			})), n.d(t, "clickFilterEvent", (function() {
				return G
			})), n.d(t, "clickNextFiltersEvent", (function() {
				return H
			})), n.d(t, "clickPreviousFiltersEvent", (function() {
				return W
			}));
			var s = n("./src/reddit/helpers/trackers/commentsChat.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/telemetry.ts"),
				a = n("./src/telemetry/models/GoldPurchase.ts"),
				d = n("./src/reddit/helpers/correlationIdTracker.ts"),
				c = n("./src/reddit/helpers/isComment.ts"),
				l = n("./src/reddit/selectors/gild.ts");
			const u = e => e.awardType === r.f.Global && e.awardSubType === r.d.Appreciation ? a.GoldPurchaseType.GidAppreciation : e.awardType === r.f.Global && e.awardSubType === r.d.Premium ? a.GoldPurchaseType.GidPremium : e.awardSubType === r.d.Group ? a.GoldPurchaseType.GidGroup : e.awardType === r.f.Community ? a.GoldPurchaseType.GidCommunity : e.awardType === r.f.Moderator ? a.GoldPurchaseType.GidMod : e.awardType === r.f.Global && e.awardSubType === r.d.Global ? a.GoldPurchaseType.GidGlobal : a.GoldPurchaseType.GidUnknown,
				m = (e, t) => ({
					awardId: e.id,
					awardName: e.name,
					isTemporaryAward: !!e.endsAt,
					numberCoinsToRecipient: e.coinReward,
					type: u(e),
					...t
				}),
				p = (e, t, n) => {
					const r = t && Object(o.f)(e, {
						commentId: t
					});
					return {
						...i.o(e),
						actionInfo: i.d(e, {
							reason: r ? "live_post" : void 0,
							...n
						}),
						comment: t ? i.h({
							state: e,
							commentId: t
						}) : void 0,
						correlationId: Object(l.b)(e) || Object(d.d)(d.a.GildingFlow, !1),
						post: t ? i.K(e, t) : void 0,
						screen: i.cb(e),
						subreddit: i.kb(e),
						userSubreddit: i.ub(e),
						listing: t ? Object(s.i)(e, t) : void 0
					}
				},
				b = (e, t) => n => ({
					...p(n, e, t),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "give_gold",
					feed: i.r(n)
				}),
				f = e => t => ({
					...p(t, e),
					source: "stream_player",
					action: "click",
					noun: "give_gold"
				}),
				h = e => t => ({
					...p(t, e),
					source: Object(c.a)(e) ? "comment" : "post",
					action: "click",
					noun: "add_award",
					feed: i.r(t)
				}),
				_ = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "hide_award",
					goldPurchase: m(e)
				}),
				g = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "confirm_hide_award",
					goldPurchase: m(e)
				}),
				v = (e, t) => n => ({
					...p(n, t),
					source: Object(c.a)(t) ? "comment" : "post",
					action: "click",
					noun: "cancel_hide_award",
					goldPurchase: m(e)
				}),
				x = e => (t, n) => s => ({
					...p(s, n),
					source: Object(c.a)(n) ? "comment" : "post",
					action: "click",
					noun: e,
					goldPurchase: m(t)
				}),
				O = x("award_hovercard_report"),
				E = x("cancel_award_hovercard_report"),
				y = x("flag_award"),
				C = x("cancel_flag_award"),
				j = x("confirm_flag_award"),
				k = x("report_community_award"),
				I = x("cancel_report_community_award"),
				S = x("confirm_report_community_award"),
				w = (e, t, n) => s => ({
					...p(s, n),
					source: "give_gold",
					action: "view",
					noun: "page",
					goldPurchase: {
						defaultOption: e,
						defaultAnonymous: t
					}
				}),
				T = (e, t, n) => s => ({
					...p(s, t),
					source: "give_gold",
					action: "click",
					noun: "award",
					goldPurchase: m(e, n)
				}),
				N = (e, t) => n => ({
					...p(n, t),
					source: "give_gold",
					action: e,
					noun: "anonymous"
				}),
				P = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "message_input"
				}),
				R = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "type",
					noun: "message_input"
				}),
				A = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "learn_more"
				}),
				M = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "question"
				}),
				L = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "confirm",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				D = (e, t) => n => ({
					...p(n, e),
					source: "give_gold",
					action: "click",
					noun: "get_premium",
					goldPurchase: {
						contentType: Object(c.a)(e) ? "comment" : "post",
						...m(t)
					}
				}),
				F = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "add_coins"
				}),
				U = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "next"
				}),
				B = e => t => ({
					...p(t, e),
					source: "give_gold",
					action: "click",
					noun: "close"
				}),
				q = e => {
					let {
						award: t,
						awardeeKarmaEarned: n,
						awarderKarmaEarned: s,
						numberCoins: r,
						thingId: o
					} = e;
					return e => ({
						...p(e, o),
						source: "give_gold",
						action: "view",
						noun: "karma_success",
						goldPurchase: {
							contentType: Object(c.a)(o) ? "comment" : "post",
							awardeeKarmaEarned: n,
							awarderKarmaEarned: s,
							numberCoins: r,
							...m(t)
						}
					})
				},
				G = e => t => ({
					...p(t),
					source: "give_gold",
					action: "click",
					noun: "filter",
					goldPurchase: {
						filterId: e.tag,
						filterName: e.content.markdown
					}
				}),
				H = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "next_filters"
				}),
				W = () => e => ({
					...p(e),
					source: "give_gold",
					action: "click",
					noun: "previous_filters"
				})
		},
		"./src/reddit/helpers/trackers/goldPayment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "a", (function() {
				return O
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "i", (function() {
				return y
			})), n.d(t, "j", (function() {
				return C
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/models/Gold/ProductOffer.ts"),
				o = n("./src/reddit/selectors/gold/giveAwards.ts"),
				i = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				a = n("./src/reddit/selectors/goldPurchaseModals.ts"),
				d = n("./src/reddit/selectors/telemetry.ts"),
				c = n("./src/telemetry/models/GoldPurchase.ts"),
				l = n("./src/telemetry/models/Payment.ts"),
				u = n("./src/reddit/helpers/trackers/gild.ts"),
				m = n("./src/reddit/helpers/correlationIdTracker.ts"),
				p = n("./src/reddit/helpers/isComment.ts"),
				b = n("./src/reddit/helpers/trackers/communityAwards.ts");
			const f = (e, t) => {
					const {
						thingId: n,
						packageId: l
					} = t, f = !!n, h = o.b(e), _ = h ? Object(u.getAwardTypeFromAward)(h) : null, g = f ? _ : a.p(e) ? c.GoldPurchaseType.Premium : c.GoldPurchaseType.Coins, v = n ? Object(p.a)(n) ? "comment" : "post" : void 0, x = l || a.u(e), O = [...Object(i.d)(e), ...Object(i.f)(e)].filter(e => e.mobileId === x)[0], E = t.offerContext || (h && 0 === h.coinPrice ? r.a.StorefrontFreeAward : Object(r.d)(O, f)), y = O ? Math.round(1e4 * (O.baselinePennies - O.pennies) / O.baselinePennies) / 100 : 0, C = O ? Math.round(1e4 * (O.coins - O.baselineCoins) / O.coins) / 100 : 0, j = O ? O.baselinePennies !== O.pennies ? `${y}_percent_price` : O.baselineCoins !== O.coins ? `${C}_percent_bonus` : void 0 : void 0, k = g === c.GoldPurchaseType.Premium ? s.Db : O ? O.pennies : void 0;
					return {
						...d.o(e),
						comment: n ? d.h({
							state: e,
							commentId: n
						}) : null,
						correlationId: a.s(e) || Object(m.d)(m.a.GoldPayment, !1),
						post: n ? d.K(e, n) : null,
						screen: d.cb(e),
						subreddit: n ? d.kb(e) : null,
						goldPurchase: {
							...h ? Object(b.a)(h) : null,
							type: g,
							gildedContent: f,
							contentType: v,
							numberCoins: O ? O.coins : void 0,
							offerContext: E,
							offerType: j
						},
						payment: {
							currency: "USD",
							amountInSmallestDenom: k
						},
						purchase: {
							priceMicros: k
						}
					}
				},
				h = (e, t, n) => s => ({
					...f(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					}),
					source: "gold_payment",
					action: "click",
					noun: "close"
				}),
				_ = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "paypal"
				}),
				g = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "continue_paypal"
				}),
				v = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "credit_card"
				}),
				x = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "click",
					noun: "complete_credit_card"
				}),
				O = (e, t) => n => ({
					...f(n, {
						packageId: e,
						offerContext: t
					}),
					source: "gold_payment",
					action: "click",
					noun: "confirm"
				}),
				E = e => t => ({
					...f(t, {
						thingId: e
					}),
					source: "gold_payment",
					action: "display",
					noun: "error"
				}),
				y = (e, t, n) => s => {
					const r = f(s, {
						packageId: t,
						thingId: e,
						offerContext: n
					});
					return {
						...r,
						source: "gold_payment",
						action: "view",
						noun: "page",
						payment: {
							...r.payment,
							defaultOption: l.PaymentMethod.Paypal
						},
						goldPurchase: {
							...r.goldPurchase,
							source: e ? c.GiveGold : a.p(s) ? c.PremiumMarketing : c.CoinsMarketing
						}
					}
				},
				C = e => t => {
					var n;
					const s = f(t, {
						thingId: e
					});
					return {
						...s,
						source: "gold_payment",
						action: "view",
						noun: "success",
						payment: {
							...s.payment,
							method: (null === (n = t.platform.currentPage) || void 0 === n ? void 0 : n.queryParams.thanks) ? l.PaymentMethod.Paypal : l.PaymentMethod.CreditCard
						}
					}
				}
		},
		"./src/reddit/helpers/trackers/inbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return s
			})), n.d(t, "e", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "y", (function() {
				return m
			})), n.d(t, "v", (function() {
				return p
			})), n.d(t, "t", (function() {
				return b
			})), n.d(t, "u", (function() {
				return f
			})), n.d(t, "r", (function() {
				return h
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "w", (function() {
				return v
			})), n.d(t, "x", (function() {
				return x
			})), n.d(t, "D", (function() {
				return O
			})), n.d(t, "k", (function() {
				return E
			})), n.d(t, "z", (function() {
				return y
			})), n.d(t, "a", (function() {
				return C
			})), n.d(t, "l", (function() {
				return j
			})), n.d(t, "E", (function() {
				return k
			})), n.d(t, "s", (function() {
				return I
			})), n.d(t, "n", (function() {
				return S
			})), n.d(t, "m", (function() {
				return w
			})), n.d(t, "i", (function() {
				return T
			})), n.d(t, "h", (function() {
				return N
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "A", (function() {
				return A
			})), n.d(t, "p", (function() {
				return M
			})), n.d(t, "B", (function() {
				return L
			})), n.d(t, "C", (function() {
				return D
			})), n.d(t, "q", (function() {
				return F
			}));
			var s, r, o, i, a, d, c = n("./src/reddit/constants/tracking.ts"),
				l = n("./src/reddit/selectors/telemetry.ts"),
				u = n("./src/telemetry/index.ts");
			! function(e) {
				e.Activity = "activity", e.Messages = "messages"
			}(s || (s = {})),
			function(e) {
				e.HideNotifications = "hide_notification", e.HideSubreddit = "hide_subreddit", e.BlockAwarder = "block_awarder", e.DecreaseSubredditUpdates = "disable_frequent"
			}(r || (r = {})),
			function(e) {
				e.MiniInbox = "mini-inbox", e.Inbox = "inbox"
			}(o || (o = {})),
			function(e) {
				e.Inbox = "inbox", e.Nav = "nav", e.Settings = "notification_app_settings"
			}(i || (i = {})),
			function(e) {
				e[e.FIRST = 1] = "FIRST", e[e.SECOND = 2] = "SECOND"
			}(a || (a = {})),
			function(e) {
				e.Confirm = "confirm"
			}(d || (d = {}));
			const m = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.VIEW,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				},
				p = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.VIEW,
						noun: "notification",
						source: "in_app_notification",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				},
				b = () => e => ({
					...l.o(e),
					action: c.c.RECEIVE,
					noun: "notification",
					source: "in_app_notification"
				}),
				f = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => {
						Object(u.a)({
							...l.o(e),
							action: "receive",
							noun: "inbox_notification",
							source: i.Inbox,
							inbox: {
								id: t,
								isClicked: n,
								isViewed: s
							},
							notification: {
								type: r
							},
							goldPurchase: {
								awardId: o
							}
						})
					}
				},
				h = e => {
					let {
						dnPromptAction: t
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "inbox_banner",
						source: "inbox",
						banner: {
							id: "inbox_dn_banner"
						},
						actionInfo: {
							pageType: "dn_prompt",
							type: t
						}
					})
				},
				_ = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o,
						position: i,
						postId: a,
						subredditId: d
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "inbox_notification",
						source: "inbox",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						},
						actionInfo: {
							position: i
						},
						subreddit: d ? {
							id: d
						} : null,
						post: a ? {
							id: a
						} : null
					})
				},
				g = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o,
						position: i,
						postId: a,
						subredditId: d
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "notification",
						source: "in_app_notification",
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						},
						actionInfo: {
							position: i
						},
						subreddit: d ? {
							id: d
						} : null,
						post: a ? {
							id: a
						} : null
					})
				},
				v = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.VIEW,
						noun: "inbox",
						source: i.Inbox,
						inbox: {
							badgeCount: t,
							tab: n
						}
					})
				},
				x = e => {
					let {
						badgeCount: t,
						tab: n
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.VIEW,
						noun: "mini-inbox",
						source: i.Inbox,
						inbox: {
							badgeCount: t,
							tab: s.Activity
						}
					})
				},
				O = e => {
					let {
						badgeCount: t
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "inbox",
						source: i.Nav,
						inbox: {
							badgeCount: t
						}
					})
				},
				E = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r,
						awardId: o
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "inbox_notification_overflow",
						source: i.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						},
						goldPurchase: {
							awardId: o
						}
					})
				},
				y = e => {
					let {
						id: t,
						isClicked: n,
						isViewed: s,
						type: r
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.VIEW,
						noun: "inbox_notification_overflow",
						source: i.Inbox,
						inbox: {
							id: t,
							isClicked: n,
							isViewed: s
						},
						notification: {
							type: r
						}
					})
				};
			var C;
			! function(e) {
				e.Cats = "cats", e.Memes = "memes", e.Karma = "karma_free_subs", e.PN_perms = "pn_perms", e.Email_perms = "email_perms"
			}(C || (C = {}));
			const j = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "overflow_option",
						source: i.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				k = e => {
					let {
						actionInfoType: t,
						id: n,
						isClicked: s,
						isViewed: r,
						type: o
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.UNDO,
						noun: "overflow_option",
						source: i.Inbox,
						inbox: {
							id: n,
							isClicked: s,
							isViewed: r
						},
						notification: {
							type: o
						},
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				I = e => {
					let {
						actionInfoType: t
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "empty_state_cta",
						source: i.Inbox,
						actionInfo: {
							...l.d(e),
							type: t
						}
					})
				},
				S = e => t => ({
					...l.o(t),
					action: c.c.CLICK,
					noun: "notification_app_settings",
					source: i.Inbox,
					actionInfo: {
						...l.d(t),
						pageType: e
					}
				}),
				w = () => e => ({
					...l.o(e),
					action: c.c.CLICK,
					noun: "see_all",
					source: i.Inbox,
					actionInfo: {
						...l.d(e),
						pageType: o.MiniInbox
					}
				}),
				T = () => e => ({
					...l.o(e),
					action: c.c.CLICK,
					noun: "messages",
					source: i.Inbox
				}),
				N = e => {
					let {
						isMiniInbox: t
					} = e;
					return e => ({
						...l.o(e),
						action: c.c.CLICK,
						noun: "mark_all_as_read",
						source: i.Inbox,
						actionInfo: t ? {
							...l.d(e),
							pageType: o.MiniInbox
						} : {}
					})
				};
			var P;
			! function(e) {
				e.DISMISS = "dismiss", e.BANNER = "banner", e.CTA_1 = "cta1", e.CTA_2 = "cta2"
			}(P || (P = {}));
			const R = (e, t) => n => ({
					...l.o(n),
					action: c.c.CLICK,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(n),
						type: t
					},
					banner: {
						id: e
					}
				}),
				A = (e, t) => n => ({
					...l.o(n),
					action: c.c.CLICK,
					noun: "inbox_banner",
					source: "mini-inbox",
					actionInfo: {
						...l.d(n),
						type: t
					},
					banner: {
						id: e
					}
				}),
				M = e => t => ({
					...l.o(t),
					action: c.c.RECEIVE,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				L = e => t => ({
					...l.o(t),
					action: c.c.RECEIVE,
					noun: "inbox_banner",
					source: "mini-inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				D = e => t => ({
					...l.o(t),
					action: c.c.VIEW,
					noun: "inbox_banner",
					source: "mini-inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				}),
				F = e => t => ({
					...l.o(t),
					action: c.c.VIEW,
					noun: "inbox_banner",
					source: "inbox",
					actionInfo: {
						...l.d(t)
					},
					banner: {
						id: e
					}
				})
		},
		"./src/reddit/helpers/trackers/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			}));
			var s, r = n("./src/reddit/constants/tracking.ts"),
				o = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.SubredditInlineTooltip = "subreddit_inline_tooltip", e.EditSubredditIcon = "edit_subreddit_icon", e.EditSubredditDescription = "edit_subreddit_description", e.SaveDescription = "save_description", e.Error = "error"
			}(s || (s = {}));
			const i = e => ({
					subreddit: o.kb(e),
					userSubreddit: o.ub(e)
				}),
				a = e => ({
					source: "subreddit_tooltip",
					noun: s.SubredditInlineTooltip,
					action: r.c.VIEW,
					...i(e)
				}),
				d = e => ({
					source: "id_card",
					noun: s.EditSubredditIcon,
					action: r.c.CLICK,
					...i(e)
				}),
				c = e => ({
					source: "id_card",
					noun: s.EditSubredditDescription,
					action: r.c.CLICK,
					...i(e)
				}),
				l = (e, t) => n => ({
					source: "id_card",
					noun: s.SaveDescription,
					action: r.c.CLICK,
					setting: {
						value: String(e),
						oldValue: String(t)
					},
					...i(n)
				}),
				u = (e, t) => ({
					source: "id_card",
					noun: s.Error,
					action: r.c.VIEW,
					...i(e),
					...o.o(e),
					actionInfo: o.d(e, {
						reason: t
					})
				})
		},
		"./src/reddit/helpers/trackers/lightbox.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/telemetry/index.ts"),
				o = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				i = n("./src/reddit/selectors/platform.ts"),
				a = n("./src/reddit/selectors/telemetry.ts");
			const d = e => ({
					profile: a.T(e),
					screen: a.cb(e),
					subreddit: a.kb(e)
				}),
				c = (e, t, n) => s => ({
					source: Object(i.j)(s) || n ? "post_lightbox" : "post_detail",
					action: "click",
					noun: t,
					...d(s),
					post: a.K(s, e)
				}),
				l = (e, t, n, s) => r => {
					const i = n ? a.h({
							state: r,
							commentId: n
						}) : null,
						{
							sortToUse: d
						} = Object(o.a)(r, e);
					return {
						...c(e, t, s)(r),
						comment: i,
						listing: {
							sort: d
						}
					}
				},
				u = (e, t) => n => {
					const s = a.k(n);
					return s ? c(s.id, e, t)(n) : {
						source: Object(i.j)(n) || t ? "post_lightbox" : "post_detail",
						action: "click",
						noun: e,
						...d(n)
					}
				},
				m = (e, t) => n => Object(r.a)({
					...c(e, t)(n),
					...a.o(n)
				}),
				p = e => t => ({
					source: "id_card",
					action: s.c.CLICK,
					noun: e,
					...d(t),
					post: a.k(t),
					userSubreddit: a.ub(t)
				})
		},
		"./src/reddit/helpers/trackers/marketplace/claims.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = () => e => ({
					...Object(s.o)(e),
					source: "marketplace",
					action: "view",
					noun: "claim_post_unit"
				}),
				o = () => e => ({
					...Object(s.o)(e),
					source: "marketplace",
					action: "click",
					noun: "claim_post_unit"
				}),
				i = () => e => ({
					...Object(s.o)(e),
					source: "marketplace",
					action: "close",
					noun: "claim_post_unit"
				});
			var a;
			! function(e) {
				e.Profile = "profile", e.Hovercard = "hovercard"
			}(a || (a = {}));
			const d = e => t => {
				const n = Object(s.o)(t);
				return {
					...n,
					source: "marketplace",
					action: "view",
					noun: "product_detail_page",
					actionInfo: {
						...n.actionInfo,
						reason: e,
						pageType: "product_detail_page"
					}
				}
			}
		},
		"./src/reddit/helpers/trackers/modHub.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					screen: s.cb(e),
					subreddit: s.kb(e),
					profile: s.T(e),
					userSubreddit: s.ub(e)
				}),
				o = e => t => ({
					source: "mod_hub_nav",
					action: "click",
					noun: e,
					...r(t)
				}),
				i = () => e => ({
					source: "breadcrumb",
					action: "click",
					noun: "subreddit",
					...r(e)
				}),
				a = () => e => ({
					source: "id_card",
					action: "click",
					noun: "mod_hub_nav",
					...r(e)
				}),
				d = (e, t) => n => ({
					...r(n),
					source: "modmanagement",
					action: "click",
					noun: "permission",
					setting: {
						value: e,
						values: t
					}
				}),
				c = (e, t, n) => s => ({
					...r(s),
					source: "modmanagement",
					action: "click",
					noun: e,
					setting: {
						value: "",
						values: n
					},
					chat: {
						recipient_user_id: t
					}
				})
		},
		"./src/reddit/helpers/trackers/modLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "h", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "o", (function() {
				return p
			})), n.d(t, "p", (function() {
				return b
			})), n.d(t, "k", (function() {
				return f
			})), n.d(t, "l", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "m", (function() {
				return x
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => ({
					subreddit: s.kb(e),
					userSubreddit: s.ub(e)
				}),
				o = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				i = () => e => ({
					source: "mod_filter_dropdown",
					action: "click",
					noun: "moderator",
					...r(e),
					actionInfo: s.d(e)
				}),
				a = i,
				d = () => e => ({
					source: "mod_log",
					action: "click",
					noun: "mod_action_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				c = e => t => ({
					source: "mod_action_dropdown",
					action: "click",
					noun: e.toLowerCase(),
					...r(t),
					actionInfo: s.d(t)
				}),
				l = () => e => ({
					source: "mod_action_dropdown",
					action: "click",
					noun: "action",
					...r(e),
					actionInfo: s.d(e)
				}),
				u = () => e => ({
					source: "moderator",
					action: "click",
					noun: "date_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				m = () => e => ({
					source: "moderator",
					action: "filter",
					noun: "date_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				p = () => e => ({
					source: "moderator",
					action: "click",
					noun: "author_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				b = () => e => ({
					source: "moderator",
					action: "filter",
					noun: "author_filter_dropdown",
					...r(e),
					actionInfo: s.d(e)
				}),
				f = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "user_profile",
						post: n,
						comment: r,
						...s.o(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				h = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: (null == r ? void 0 : r.id) ? "comment" : "post",
						post: n,
						comment: r,
						...s.o(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				_ = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "content_policy",
						post: n,
						comment: r,
						...s.o(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				g = e => {
					let {
						violatedContentPolicyRule: t,
						post: n,
						comment: r
					} = e;
					return e => ({
						source: "mod_log",
						action: "click",
						noun: "show_details",
						post: n,
						comment: r,
						...s.o(e),
						actionInfo: s.d(e, {
							reason: t
						})
					})
				},
				v = () => e => ({
					source: "moderator",
					action: "click",
					noun: "pagesize",
					...s.o(e),
					actionInfo: s.d(e)
				}),
				x = () => e => ({
					source: "moderator",
					action: "click",
					noun: "modlog_helpcenter",
					...s.o(e),
					actionInfo: s.d(e)
				})
		},
		"./src/reddit/helpers/trackers/modNote.ts": function(e, t, n) {
			"use strict";
			n.d(t, "w", (function() {
				return a
			})), n.d(t, "r", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "o", (function() {
				return f
			})), n.d(t, "p", (function() {
				return h
			})), n.d(t, "q", (function() {
				return _
			})), n.d(t, "x", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "k", (function() {
				return x
			})), n.d(t, "l", (function() {
				return O
			})), n.d(t, "y", (function() {
				return E
			})), n.d(t, "s", (function() {
				return y
			})), n.d(t, "n", (function() {
				return C
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "u", (function() {
				return k
			})), n.d(t, "t", (function() {
				return I
			})), n.d(t, "v", (function() {
				return S
			})), n.d(t, "j", (function() {
				return w
			})), n.d(t, "b", (function() {
				return T
			})), n.d(t, "c", (function() {
				return N
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t) => {
					var n, s, r, o, i, a, d, c, l, u, m;
					const {
						modNote: p,
						subredditId: b,
						userId: f,
						postId: h,
						commentId: _,
						subredditSearch: g,
						filteredType: v,
						filteredSubredditId: x
					} = t, O = _ || (null === (s = null === (n = p) || void 0 === n ? void 0 : n.commentInfo) || void 0 === s ? void 0 : s.id), E = h || (null === (o = null === (r = p) || void 0 === r ? void 0 : r.postInfo) || void 0 === o ? void 0 : o.id);
					return {
						modnote: {
							type: null == p ? void 0 : p.itemType,
							content: null === (i = p) || void 0 === i ? void 0 : i.note,
							label: null === (d = null === (a = p) || void 0 === a ? void 0 : a.label) || void 0 === d ? void 0 : d.toLowerCase(),
							operatorId: null === (c = null == p ? void 0 : p.operator) || void 0 === c ? void 0 : c.id,
							subredditSearch: g,
							filteredType: null == v ? void 0 : v.toLowerCase(),
							filteredSubredditId: null == x ? void 0 : x.toLowerCase()
						},
						modAction: {
							targetUserId: f || (null === (l = null == p ? void 0 : p.user) || void 0 === l ? void 0 : l.id),
							action: null === (m = null === (u = p) || void 0 === u ? void 0 : u.actionType) || void 0 === m ? void 0 : m.toLowerCase()
						},
						...O ? {
							comment: {
								id: O,
								postId: E || "none"
							}
						} : null,
						...E ? {
							post: {
								id: E
							}
						} : null,
						subreddit: {
							id: b
						}
					}
				},
				i = "moderator",
				a = e => t => ({
					source: i,
					action: "view",
					noun: "modnote_quickaccess",
					correlationId: Object(s.d)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				d = e => t => {
					const n = {
						source: i,
						action: "close",
						noun: "modnote_quickaccess",
						correlationId: Object(s.c)(s.a.ModNotes),
						...r.o(t),
						...o(0, e)
					};
					return Object(s.b)(s.a.ModNotes), n
				},
				c = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				l = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				u = e => t => ({
					source: i,
					action: "click",
					noun: "relatedcontent_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				m = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modlog_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				p = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modlog_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				b = e => t => ({
					source: i,
					action: "click",
					noun: "expand_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				f = e => t => ({
					source: i,
					action: "click",
					noun: "username_modnote_quickaccess",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				h = e => t => ({
					source: i,
					action: "click",
					noun: "mod_username_modnote_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				_ = e => t => ({
					source: i,
					action: "click",
					noun: "username_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				g = e => t => ({
					source: i,
					action: "view",
					noun: "user_profile_hovercard",
					correlationId: Object(s.d)(s.a.ModNotes, !1),
					...r.o(t),
					...o(0, e)
				}),
				v = e => t => ({
					source: i,
					action: "click",
					noun: "add_note_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				x = e => t => ({
					source: i,
					action: "click",
					noun: "user_mod_log_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				O = e => t => ({
					source: i,
					action: "click",
					noun: "send_modmail_user_profile_hovercard",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				E = e => t => ({
					source: i,
					action: "view",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				y = e => t => ({
					source: i,
					action: "close",
					noun: "modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				C = e => t => ({
					source: i,
					action: "click",
					noun: "type_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				j = e => t => ({
					source: i,
					action: "click",
					noun: "subreddit_filter_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				k = e => t => ({
					source: i,
					action: "select",
					noun: "type_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				I = e => t => ({
					source: i,
					action: "select",
					noun: "subreddit_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				S = e => t => ({
					source: i,
					action: "submit",
					noun: "submit_note_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				w = e => t => ({
					source: i,
					action: "click",
					noun: "delete_modnote_modlog",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				T = e => t => ({
					source: i,
					action: "click",
					noun: "cancel_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				}),
				N = e => t => ({
					source: i,
					action: "click",
					noun: "delete_deletemodnote",
					correlationId: Object(s.c)(s.a.ModNotes),
					...r.o(t),
					...o(0, e)
				})
		},
		"./src/reddit/helpers/trackers/modTools.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return i
			})), n.d(t, "l", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "m", (function() {
				return f
			})), n.d(t, "j", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "n", (function() {
				return g
			})), n.d(t, "h", (function() {
				return v
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: Object(r.cb)(e),
					profile: Object(r.T)(e),
					subreddit: Object(r.kb)(e),
					userSubreddit: Object(r.ub)(e)
				}),
				i = e => t => ({
					source: "nav",
					action: "click",
					noun: e ? "mod_mode_on" : "mod_mode_off",
					...o(t)
				}),
				a = (e, t) => n => ({
					source: "post_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					...o(n)
				}),
				d = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					media: {
						mimetype: Object(r.j)(n, t)
					},
					...o(n)
				}),
				c = (e, t) => n => ({
					source: "comment",
					action: s.c.CLICK,
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					actionInfo: {
						pageType: "chat_live_post"
					},
					...o(n)
				}),
				l = (e, t) => n => ({
					source: "comment",
					action: s.c.UNDO,
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				u = (e, t) => n => ({
					source: "comment_overflow_menu",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				m = (e, t) => n => ({
					source: "mod_distinguish_menu",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				p = (e, t) => n => ({
					source: "comment_mod_action_menu",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					...o(n)
				}),
				b = (e, t) => n => ({
					source: "comment_report_menu",
					action: "click",
					noun: e,
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					post: Object(r.K)(n, t),
					...o(n)
				}),
				f = (e, t) => n => ({
					source: "post_report_menu",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					...o(n)
				}),
				h = (e, t) => n => ({
					source: "post",
					action: "click",
					noun: e,
					post: Object(r.K)(n, t),
					subreddit: Object(r.nb)(n, t)
				}),
				_ = (e, t) => n => ({
					source: "comment",
					action: "click",
					noun: e,
					comment: Object(r.h)({
						state: n,
						commentId: t
					}),
					post: Object(r.K)(n, t),
					subreddit: Object(r.nb)(n, t)
				}),
				g = (e, t, n, s) => o => ({
					source: e ? "comment" : "post",
					action: "click",
					noun: t ? "unsnooze_reporter" : "snooze_reporter",
					post: Object(r.K)(o, n),
					subreddit: Object(r.nb)(o, n),
					actionInfo: {
						reason: s
					},
					...e && {
						comment: Object(r.h)({
							state: o,
							commentId: n
						})
					}
				}),
				v = () => e => ({
					...o(e),
					source: "modqueue",
					noun: "content_type_live_post",
					action: "view",
					actionInfo: {
						pageType: "chat_live_post"
					}
				})
		},
		"./src/reddit/helpers/trackers/moderationPages.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					screen: r.cb(e),
					profile: r.T(e),
					subreddit: r.kb(e)
				}),
				i = e => {
					switch (e) {
						case s.mc.Banned:
							return "banned";
						case s.mc.Muted:
							return "muted";
						case s.mc.Contributors:
							return "contributors";
						case s.mc.Moderators:
							return "modmanagement";
						case s.mc.Removal:
							return "set_removal_reasons";
						case s.mc.CommunitySettings:
							return "edit";
						default:
							return e
					}
				},
				a = (e, t) => n => ({
					source: i(t),
					noun: e,
					action: "click",
					...o(n)
				}),
				d = e => t => ({
					source: i(e),
					noun: "hover_user_hovercard",
					action: "view",
					...o(t)
				})
		},
		"./src/reddit/helpers/trackers/postCollection.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "n", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "b", (function() {
				return g
			})), n.d(t, "p", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "q", (function() {
				return E
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "l", (function() {
				return C
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			}));
			var s, r, o = n("./src/reddit/constants/tracking.ts"),
				i = n("./src/reddit/helpers/trackers/postEvent.ts"),
				a = n("./src/reddit/selectors/platform.ts"),
				d = n("./src/reddit/selectors/telemetry.ts");
			! function(e) {
				e.collection = "collection", e.collectionComposer = "collection_composer", e.postComposer = "post_composer", e.postOverflowMenu = "post_overflow_menu"
			}(s || (s = {})),
			function(e) {
				e.post = "post", e.follow = "follow", e.unfollow = "unfollow", e.screen = "screen", e.eventEducation = "event_education", e.eventEducationGotIt = "event_education_got_it", e.collectionEducation = "collection_education", e.collectionEducationGotIt = "collection_education_got_it", e.collectionCancel = "cancel", e.collectionCreate = "collection_create", e.collectionSelect = "collection_select", e.collectionDelete = "collection_delete", e.collectionEdit = "collection_edit", e.collectionAddPost = "collection_add_post", e.collectionRemovePost = "remove_post_from_collection", e.startEvent = "start_event"
			}(r || (r = {}));
			const c = e => t => ({
					source: s.collection,
					noun: r.post,
					...m(t, e)
				}),
				l = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: s.collection,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				u = e => {
					let {
						postId: t,
						isFollowed: n
					} = e;
					return e => ({
						source: i.a.postEvent,
						noun: n ? r.unfollow : r.follow,
						...m(e, t)
					})
				},
				m = (e, t) => {
					const n = {
						...d.o(e),
						action: o.c.CLICK,
						subreddit: d.kb(e)
					};
					return void 0 === t ? n : {
						...n,
						post: d.K(e, t),
						postCollection: d.M(e, {
							postId: t
						}),
						postEvent: d.N(e, {
							postId: t
						})
					}
				},
				p = e => ({
					..._(e),
					action: o.c.VIEW,
					noun: r.collectionEducation
				}),
				b = e => ({
					..._(e),
					action: o.c.CLICK,
					noun: r.collectionEducationGotIt
				}),
				f = e => ({
					..._(e),
					action: o.c.VIEW,
					noun: r.eventEducation
				}),
				h = e => ({
					..._(e),
					action: o.c.CLICK,
					noun: r.eventEducationGotIt
				}),
				_ = e => ({
					...d.o(e),
					subreddit: d.kb(e),
					source: s.postComposer
				}),
				g = (e, t) => n => ({
					...m(n, e),
					source: t || s.postOverflowMenu,
					noun: r.collectionAddPost
				}),
				v = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.collectionRemovePost
				}),
				x = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionCancel
				}),
				O = () => e => {
					const t = Object(a.p)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						noun: r.collectionCreate
					}
				},
				E = () => e => ({
					...m(e),
					source: s.collectionComposer,
					noun: r.collectionSelect
				}),
				y = e => t => ({
					...d.o(t),
					subreddit: d.kb(t),
					source: s.collectionComposer,
					action: o.c.CLICK,
					noun: r.collectionDelete,
					postCollection: d.L(t, {
						collectionId: e
					})
				}),
				C = e => t => ({
					...m(t),
					source: s.collectionComposer,
					noun: r.collectionEdit,
					postCollection: d.L(t, {
						collectionId: e
					})
				}),
				j = e => t => ({
					...m(t, e),
					source: s.collectionComposer,
					noun: r.startEvent
				}),
				k = () => e => {
					const t = Object(a.p)(e) || void 0;
					return {
						...m(e, t),
						source: s.collectionComposer,
						action: o.c.VIEW,
						noun: r.screen
					}
				}
		},
		"./src/reddit/helpers/trackers/postComposer.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return v
			})), n.d(t, "e", (function() {
				return x
			})), n.d(t, "K", (function() {
				return O
			})), n.d(t, "I", (function() {
				return E
			})), n.d(t, "C", (function() {
				return y
			})), n.d(t, "z", (function() {
				return C
			})), n.d(t, "A", (function() {
				return j
			})), n.d(t, "M", (function() {
				return k
			})), n.d(t, "B", (function() {
				return I
			})), n.d(t, "m", (function() {
				return S
			})), n.d(t, "E", (function() {
				return w
			})), n.d(t, "D", (function() {
				return T
			})), n.d(t, "t", (function() {
				return N
			})), n.d(t, "s", (function() {
				return P
			})), n.d(t, "L", (function() {
				return R
			})), n.d(t, "p", (function() {
				return A
			})), n.d(t, "o", (function() {
				return M
			})), n.d(t, "q", (function() {
				return L
			})), n.d(t, "f", (function() {
				return F
			})), n.d(t, "r", (function() {
				return B
			})), n.d(t, "j", (function() {
				return G
			})), n.d(t, "g", (function() {
				return H
			})), n.d(t, "h", (function() {
				return W
			})), n.d(t, "d", (function() {
				return V
			})), n.d(t, "H", (function() {
				return z
			})), n.d(t, "i", (function() {
				return K
			})), n.d(t, "c", (function() {
				return Q
			})), n.d(t, "v", (function() {
				return J
			})), n.d(t, "u", (function() {
				return X
			})), n.d(t, "G", (function() {
				return Z
			})), n.d(t, "w", (function() {
				return $
			})), n.d(t, "k", (function() {
				return ee
			})), n.d(t, "F", (function() {
				return te
			})), n.d(t, "y", (function() {
				return ne
			})), n.d(t, "b", (function() {
				return se
			})), n.d(t, "n", (function() {
				return re
			})), n.d(t, "x", (function() {
				return oe
			})), n.d(t, "l", (function() {
				return ie
			})), n.d(t, "J", (function() {
				return ae
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/helpers/correlationIdTracker.ts"),
				o = n("./src/reddit/helpers/media/index.ts"),
				i = n("./src/reddit/models/PostCreationForm/index.ts"),
				a = n("./src/reddit/models/PostDraft/index.ts"),
				d = n("./src/reddit/selectors/experiments/postCreationSubRec.ts"),
				c = n("./src/reddit/selectors/postDraft.ts"),
				l = n("./src/reddit/selectors/subreddit.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/reddit/selectors/user.ts"),
				p = n("./src/telemetry/index.ts"),
				b = n("./src/telemetry/models/PostComposer.ts"),
				f = n("./src/telemetry/models/PostDraft.ts");
			const h = {
					imageOnly: "image",
					linkOnly: "link",
					media: "media",
					poll: "poll",
					post: "self",
					prediction: "prediction",
					crosspost: "crosspost",
					talk: "talk"
				},
				_ = e => ({
					source: "post_composer",
					action: s.c.CLICK,
					...u.o(e),
					screen: u.cb(e),
					correlationId: Object(r.c)(r.a.PostComposer)
				}),
				g = (e, t) => "self" !== t ? {} : {
					editorMode: e.user.prefs.editorMode === i.i.MARKDOWN ? "markdown" : "rte"
				},
				v = e => {
					Object(p.a)({
						noun: "cancel",
						..._(e)
					})
				},
				x = e => {
					Object(p.a)({
						noun: "discard",
						..._(e)
					})
				},
				O = e => t => ({
					..._(t),
					noun: "subreddit_choice",
					subreddit: e ? u.lb(t, e) : void 0,
					actionInfo: u.g(t)
				}),
				E = () => e => ({
					..._(e),
					noun: "subreddit_selector"
				}),
				y = (e, t) => {
					Object(p.a)({
						noun: "post_type_selector",
						postComposer: {
							type: h[t]
						},
						..._(e)
					})
				},
				C = () => e => ({
					noun: "add_option",
					..._(e)
				}),
				j = () => e => ({
					noun: "voting_length",
					..._(e)
				}),
				k = (e, t, n) => {
					"image_upload" === t || "video_upload" === t ? Object(p.a)({
						noun: t,
						..._(e)
					}) : Object(p.a)({
						noun: "text_option",
						postComposer: {
							textType: t,
							finalStatus: n ? "on" : "off"
						},
						..._(e)
					})
				},
				I = (e, t, n, s) => {
					Object(p.a)({
						noun: "post",
						subreddit: u.kb(e),
						postComposer: {
							type: t,
							...g(e, t)
						},
						post: n ? u.K(e, n) : null,
						..._(e),
						correlationId: s
					})
				},
				S = (e, t) => {
					const n = t === i.i.MARKDOWN ? "markdown_mode" : "rte_mode";
					Object(p.a)({
						noun: n,
						..._(e)
					})
				},
				w = (e, t) => {
					Object(p.a)({
						noun: "save",
						subreddit: u.kb(e),
						postComposer: {
							type: t,
							...g(e, t)
						},
						..._(e)
					})
				},
				T = (e, t) => {
					const n = e.uploads[t];
					n.error && Object(p.a)({
						..._(e),
						noun: "media",
						action: s.c.REJECT,
						actionInfo: {
							...u.d(e),
							reason: JSON.stringify(n.error)
						}
					})
				},
				N = (e, t) => {
					t.forEach(t => {
						const n = Object(o.g)(t.type);
						n && Object(p.a)({
							..._(e),
							action: s.c.DRAG,
							noun: n
						})
					})
				},
				P = (e, t, n) => {
					Object(p.a)({
						..._(e),
						noun: "input",
						postComposer: {
							inputType: n
						},
						action: t,
						actionInfo: u.g(e)
					})
				},
				R = (e, t, n) => {
					Object(p.a)({
						..._(e),
						noun: n,
						action: Object(b.getToggleAction)(t),
						actionInfo: u.g(e)
					})
				},
				A = e => D("input", e),
				M = () => D("add"),
				L = () => D("remove_image"),
				D = (e, t) => n => ({
					..._(n),
					noun: e,
					postComposer: {
						inputType: t,
						type: h.imageOnly
					},
					action: s.c.CLICK
				}),
				F = e => {
					Object(p.a)({
						..._(e),
						noun: "hide_oc_description",
						action: s.c.CLICK
					})
				},
				U = (e, t) => {
					if (t) {
						const n = u.lb(e, t);
						if (n) return {
							subreddit: n
						};
						const s = u.U(e, t);
						if (s) return {
							profile: s
						}
					}
				},
				B = (e, t) => {
					const {
						draftId: n,
						destSubreddit: s
					} = t, r = Object(m.l)(e), o = Object(c.d)(e, {
						draftId: n
					}), i = {
						authorId: r ? r.id : void 0,
						createdTimestamp: o ? o.created : void 0,
						id: n || void 0,
						nsfw: t.isNSFW,
						originalContent: t.isOC,
						spoiler: t.isSpoiler,
						titleLength: t.title.length
					};
					switch (t.kind) {
						case a.b.Link:
							i.type = f.DraftType.Link, i.urlLength = t.body.length;
							break;
						case a.b.Markdown:
							i.type = f.DraftType.Self, i.bodyTextLength = t.body.length;
							break;
						case a.b.RichText:
							i.type = f.DraftType.RichText, t.documentStats && (i.bodyTextLength = t.documentStats.textLength, i.numberRteImages = t.documentStats.rteImagesCount, i.numberRteVideos = t.documentStats.rteVideosCount);
							break;
						case a.b.Image:
							i.type = f.DraftType.Image;
							break;
						case a.b.Video:
							i.type = f.DraftType.Video
					}
					return {
						postDraft: i,
						...U(e, s.id)
					}
				},
				q = (e, t) => {
					const n = Object(m.l)(e),
						s = {
							authorId: n ? n.id : void 0,
							createdTimestamp: t.created,
							id: t.id,
							nsfw: t.isNSFW,
							originalContent: t.isOriginalContent,
							spoiler: t.isSpoiler,
							titleLength: t.title.length
						};
					switch (t.kind) {
						case a.b.Link:
							s.type = f.DraftType.Link, s.urlLength = (t.body || "").length;
							break;
						case a.b.Markdown:
							s.type = f.DraftType.Self, s.bodyTextLength = (t.body || "").length;
							break;
						case a.b.RichText:
							s.type = f.DraftType.RichText
					}
					return {
						postDraft: s,
						...U(e, t.subredditId)
					}
				},
				G = (e, t) => {
					Object(p.a)({
						noun: "draft_load",
						..._(e),
						...B(e, t)
					})
				},
				H = (e, t) => {
					Object(p.a)({
						noun: t.draftId ? "draft_update" : "draft_create",
						..._(e),
						...B(e, t)
					})
				},
				W = (e, t) => {
					Object(p.a)({
						noun: "draft_delete",
						..._(e),
						...q(e, t)
					})
				},
				V = e => {
					Object(p.a)({
						..._(e),
						noun: "social_connect_link",
						action: s.c.CLICK
					})
				},
				z = (e, t) => {
					Object(p.a)({
						..._(e),
						noun: "twitter_share_checkbox",
						action: Object(b.getToggleAction)(t)
					})
				},
				K = (e, t, n) => {
					Object(p.a)({
						..._(e),
						...B(e, t),
						noun: "draft_share",
						action: n ? s.c.ENABLE : s.c.DISABLE
					})
				},
				Q = e => {
					Object(p.a)({
						..._(e),
						noun: "create_community",
						actionInfo: {
							...u.d(e),
							pageType: "post_select_community"
						}
					})
				},
				Y = "community_recommendation",
				J = () => e => ({
					..._(e),
					action: s.c.VIEW,
					noun: Y,
					listing: {
						links: Object(d.c)(e).map(t => Object(l.I)(e, t.name))
					}
				}),
				X = (e, t) => n => ({
					..._(n),
					action: s.c.CLICK,
					noun: Y,
					actionInfo: {
						...u.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(l.I)(n, e)
					}
				}),
				Z = e => {
					Object(p.a)({
						..._(e),
						action: s.c.SKIP,
						noun: Y
					})
				},
				$ = (e, t) => n => ({
					..._(n),
					action: s.c.VIEW,
					noun: `${Y}_hover`,
					actionInfo: {
						...u.d(n),
						position: t
					},
					subreddit: {
						name: e,
						id: Object(l.I)(n, e)
					}
				}),
				ee = e => t => ({
					..._(t),
					action: s.c.CLICK,
					noun: "draft_preview",
					actionInfo: {
						...u.d(t),
						count: e
					}
				}),
				te = e => t => ({
					..._(t),
					action: "add",
					noun: "flair",
					subreddit: u.lb(t, e)
				}),
				ne = () => e => ({
					..._(e),
					action: s.c.CLICK,
					noun: "flair_dropdown"
				}),
				se = () => e => ({
					..._(e),
					action: "clear",
					noun: "flair"
				}),
				re = () => e => ({
					..._(e),
					action: "search",
					noun: "flair"
				}),
				oe = e => {
					let {
						actionInfoType: t,
						subredditId: n = "",
						noun: o = "create_post"
					} = e;
					return e => ({
						..._(e),
						action: s.c.CLICK,
						noun: o,
						actionInfo: {
							...u.d(e),
							type: t
						},
						correlationId: Object(r.d)(r.a.PostComposer, !1),
						subreddit: n ? u.lb(e, n) : void 0
					})
				},
				ie = () => e => ({
					..._(e),
					action: s.c.CLICK,
					noun: "edit_post"
				}),
				ae = e => t => ({
					..._(t),
					action: "type",
					noun: "subreddit_search",
					actionInfo: {
						...u.d(t),
						type: e
					}
				})
		},
		"./src/reddit/helpers/trackers/postEvent.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "f", (function() {
				return b
			})), n.d(t, "g", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			})), n.d(t, "b", (function() {
				return _
			})), n.d(t, "c", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			}));
			var s, r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/eventTools/index.ts"),
				i = n("./src/lib/timezone/index.ts"),
				a = n("./src/reddit/constants/tracking.ts"),
				d = n("./src/reddit/models/PostCreationForm/index.ts"),
				c = n("./src/reddit/selectors/platform.ts"),
				l = n("./src/reddit/selectors/postCreations.ts"),
				u = n("./src/reddit/selectors/telemetry.ts"),
				m = n("./src/telemetry/index.ts");
			! function(e) {
				e.postEvent = "post_event", e.postComposer = "post_composer", e.eventComposer = "event_composer"
			}(s || (s = {}));
			const p = e => u.d(e, {
					pageType: "event_submit"
				}),
				b = e => {
					Object(m.a)({
						...u.o(e),
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_create",
						subreddit: u.kb(e)
					})
				},
				f = e => {
					Object(m.a)({
						...u.o(e),
						source: s.postComposer,
						action: a.c.CLICK,
						noun: "event_edit",
						subreddit: u.kb(e),
						postEvent: x(e),
						postComposer: O(e)
					})
				},
				h = () => e => ({
					source: s.eventComposer,
					action: a.c.VIEW,
					noun: a.b.SCREEN,
					actionInfo: p(e),
					postEvent: x(e)
				}),
				_ = e => t => ({
					...C(t, Object(c.p)(t)),
					source: s.postComposer,
					noun: "apply",
					postComposer: E(e)
				}),
				g = () => e => ({
					...C(e, Object(c.p)(e)),
					noun: "cancel",
					actionInfo: p(e)
				}),
				v = e => t => ({
					...C(t, Object(c.p)(t)),
					noun: "delete",
					actionInfo: p(t),
					postComposer: O(t),
					postEvent: y(e)
				}),
				x = e => {
					const t = Object(l.p)(e);
					return t && y(t)
				},
				O = e => E(Object(l.p)(e)),
				E = e => {
					return {
						postScheduled: !!e,
						submitScheduledTime: e && e.submitTime === d.j.AtEventTime ? Object(i.f)(e.startDate).getTime() / r.Xb : void 0
					}
				},
				y = e => {
					const t = Object(i.f)(e.startDate).getTime() / r.Xb,
						n = Object(i.f)(e.endDate).getTime() / r.Xb;
					return {
						eventStartTimestamp: t,
						eventEndTimestamp: n,
						eventState: Object(o.e)(t, n)
					}
				},
				C = (e, t) => {
					const n = {
						source: s.eventComposer,
						action: a.c.CLICK,
						subreddit: u.kb(e)
					};
					return t ? {
						...n,
						post: u.K(e, t),
						postEvent: u.N(e, {
							postId: t
						}),
						postCollection: u.M(e, {
							postId: t
						})
					} : n
				}
		},
		"./src/reddit/helpers/trackers/postFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/helpers/flair.ts"),
				a = n("./src/reddit/helpers/search/searchImpressionId.ts");
			const d = (e, t) => n => {
					const i = `flair_name:'${t.postFlairName}'`;
					return {
						source: "post",
						action: "click",
						noun: "post_flair",
						...o.o(n),
						actionInfo: o.d(n),
						correlationId: Object(s.c)(s.a.SearchResults),
						post: o.K(n, e),
						search: {
							...o.O(n, t),
							query: i,
							queryId: o.eb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP)
						},
						subreddit: o.kb(n)
					}
				},
				c = e => t => ({
					source: "post_flair_widget",
					action: "click",
					noun: "post_flair_search",
					...o.o(t),
					actionInfo: o.d(t),
					correlationId: Object(s.c)(s.a.SearchResults),
					search: o.O(t, e),
					subreddit: o.kb(t)
				}),
				l = e => t => {
					const n = Object(i.g)(e);
					return {
						...o.o(t),
						action: "click",
						noun: "post_flair",
						source: "post_flair_widget",
						subreddit: o.kb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				u = () => e => ({
					...o.o(e),
					action: "click",
					noun: "overflow",
					source: "post_flair_widget",
					subreddit: o.kb(e)
				}),
				m = e => t => {
					const n = Object(i.g)(e);
					return {
						...o.o(t),
						action: "click",
						noun: "clear",
						source: "post_flair_widget",
						subreddit: o.kb(t),
						postFlair: {
							id: e.templateId,
							title: n
						}
					}
				},
				p = (e, t) => n => {
					const s = Object(i.g)(e),
						d = o.K(n, t),
						c = `flair_name:'${s}'`;
					return {
						...o.o(n),
						action: "click",
						noun: "post_flair",
						source: "post",
						subreddit: o.kb(n),
						postFlair: {
							id: e.templateId,
							title: s
						},
						post: d,
						search: {
							query: c,
							subredditId: d ? d.subredditId : void 0,
							subredditName: d ? d.subredditName : void 0,
							postFlairName: s,
							originElement: "post_flair",
							queryId: o.eb(n, r.a.SERP),
							impressionId: a.a.get(r.a.SERP),
							originPageType: n.platform.currentPage ? o.v(n.platform.currentPage) : void 0
						},
						feed: o.r(n)
					}
				}
		},
		"./src/reddit/helpers/trackers/powerups.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = (e, t, n) => ({
					...r.o(e),
					correlationId: Object(s.d)(s.a.PowerupsFlow, !1),
					profile: r.T(e),
					subreddit: r.kb(e),
					powerups: {
						...r.pb(e),
						freeCount: t,
						paidCount: n
					}
				}),
				i = () => e => ({
					source: "meta",
					action: "open",
					noun: "emote_picker",
					...o(e)
				}),
				a = (e, t) => n => ({
					source: t,
					action: "click",
					noun: "add_custom_emojis",
					...o(n),
					powerups: {
						...r.pb(n),
						emojiCount: e
					}
				}),
				d = (e, t) => n => ({
					source: t,
					action: "save",
					noun: "custom_emojis",
					...o(n),
					powerups: {
						...r.pb(n),
						emojiCount: e
					}
				}),
				c = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 ? arguments[1] : void 0;
					return n => ({
						source: t,
						action: "delete",
						noun: "custom_emojis",
						...o(n),
						powerups: {
							...r.pb(n),
							emojiCount: e
						}
					})
				},
				l = (e, t) => n => ({
					source: "meta",
					action: "open",
					noun: "gif_tooltip",
					subreddit: t ? r.lb(n, t) : void 0,
					...o(n),
					correlationId: e
				}),
				u = (e, t, n) => s => ({
					source: "powerups_settings",
					action: "click",
					noun: e,
					setting: {
						value: String(t),
						oldValue: String(n)
					},
					subreddit: r.kb(s),
					...r.o(s)
				})
		},
		"./src/reddit/helpers/trackers/scheduledPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return a
			})), n.d(t, "y", (function() {
				return d
			})), n.d(t, "m", (function() {
				return c
			})), n.d(t, "p", (function() {
				return l
			})), n.d(t, "q", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "r", (function() {
				return f
			})), n.d(t, "k", (function() {
				return h
			})), n.d(t, "f", (function() {
				return _
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "n", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "g", (function() {
				return E
			})), n.d(t, "l", (function() {
				return y
			})), n.d(t, "t", (function() {
				return C
			})), n.d(t, "j", (function() {
				return j
			})), n.d(t, "e", (function() {
				return k
			})), n.d(t, "x", (function() {
				return I
			})), n.d(t, "u", (function() {
				return S
			})), n.d(t, "a", (function() {
				return w
			})), n.d(t, "s", (function() {
				return T
			})), n.d(t, "v", (function() {
				return N
			})), n.d(t, "w", (function() {
				return P
			}));
			var s = n("./src/reddit/models/ScheduledPost/index.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => ({
					...r.o(e),
					screen: r.cb(e),
					subreddit: r.kb(e),
					userSubreddit: r.ub(e)
				}),
				i = e => ({
					id: e.id,
					publishAt: e.publishAt,
					clientTimezone: e.clientTimezone,
					isRecurring: Object(s.q)(e)
				}),
				a = () => e => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post",
					...o(e)
				}),
				d = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "schedule_post_composer",
					...o(e)
				}),
				c = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_date",
					...o(e)
				}),
				l = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_time",
					...o(e)
				}),
				u = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "submit_timezone",
					...o(e)
				}),
				m = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "apply",
					...o(e)
				}),
				p = () => e => ({
					source: "scheduled_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				b = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_submit",
					...o(t),
					scheduledPost: i(e)
				}),
				f = e => t => ({
					source: "post_composer",
					action: "click",
					noun: "schedule_post_update_submit",
					...o(t),
					scheduledPost: i(e)
				}),
				h = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "scheduled_posts",
					...o(e)
				}),
				_ = () => e => ({
					source: "mod_hub_nav",
					action: "click",
					noun: "event_posts",
					...o(e)
				}),
				g = () => e => ({
					source: "post",
					action: "click",
					noun: "edit_post",
					...o(e)
				}),
				v = () => e => ({
					source: "post",
					action: "click",
					noun: "submit_post_now",
					...o(e)
				}),
				x = e => t => ({
					source: "post",
					action: "click",
					noun: "overflow_menu",
					...o(t),
					actionInfo: r.d(t, {
						pageType: e ? "recurring_posts" : "scheduled_posts"
					})
				}),
				O = {
					[s.d.Hourly]: "hourly_frequency",
					[s.d.Daily]: "daily_frequency",
					[s.d.Weekly]: "weekly_frequency",
					[s.d.Monthly]: "monthly_frequency",
					[s.b]: "custom_frequency"
				},
				E = e => t => ({
					source: "scheduled_post_composer_submit_frequency",
					action: "click",
					noun: null === e ? "one_time_frequency" : O[e],
					...o(t)
				}),
				y = () => e => ({
					source: "post",
					action: "click",
					noun: "start_event_now",
					...o(e)
				}),
				C = (e, t, n) => i => ({
					source: "post",
					action: "click",
					noun: Object(s.m)(e),
					...o(i),
					actionInfo: r.d(i, {
						settingValue: t ? "true" : "false",
						pageType: n ? "recurring_posts" : "scheduled_posts"
					})
				}),
				j = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "schedule_post_cta",
					...o(e)
				}),
				k = () => e => ({
					source: "recurring_post_module",
					action: "click",
					noun: "edit_recurring_post",
					...o(e)
				}),
				I = () => e => ({
					source: "recurring_post_composer",
					action: "view",
					noun: "recurring_post_composer",
					...o(e)
				}),
				S = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "update",
					...o(e),
					scheduledPost: i(t)
				}),
				w = () => e => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "cancel",
					...o(e)
				}),
				T = () => (e, t) => ({
					source: "recurring_post_composer",
					action: "click",
					noun: "delete",
					...o(e),
					scheduledPost: i(t)
				}),
				N = () => e => ({
					source: "scheduled_post_composer",
					action: "view",
					noun: "custom_schedule_post_composer",
					...o(e)
				}),
				P = () => (e, t) => {
					const n = o(e);
					return {
						source: "post",
						action: "view",
						noun: "error",
						...n,
						actionInfo: {
							...n.actionInfo,
							reason: "failed_post"
						},
						scheduledPost: i(t)
					}
				}
		},
		"./src/reddit/helpers/trackers/screenview.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return S
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "q", (function() {
				return N
			})), n.d(t, "r", (function() {
				return P
			})), n.d(t, "o", (function() {
				return R
			})), n.d(t, "s", (function() {
				return A
			})), n.d(t, "c", (function() {
				return M
			})), n.d(t, "l", (function() {
				return L
			})), n.d(t, "p", (function() {
				return D
			})), n.d(t, "i", (function() {
				return F
			})), n.d(t, "j", (function() {
				return U
			})), n.d(t, "g", (function() {
				return B
			})), n.d(t, "b", (function() {
				return H
			})), n.d(t, "a", (function() {
				return W
			})), n.d(t, "n", (function() {
				return V
			})), n.d(t, "m", (function() {
				return z
			})), n.d(t, "t", (function() {
				return J
			})), n.d(t, "x", (function() {
				return X
			})), n.d(t, "e", (function() {
				return Z
			})), n.d(t, "d", (function() {
				return ee
			})), n.d(t, "v", (function() {
				return se
			})), n.d(t, "u", (function() {
				return re
			})), n.d(t, "w", (function() {
				return oe
			})), n.d(t, "h", (function() {
				return ie
			}));
			var s = n("./node_modules/lodash/pick.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/makePostDraftPageKey/index.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/reddit/constants/tracking.ts"),
				c = n("./src/reddit/helpers/getCommentsPageSort/index.ts"),
				l = n("./src/reddit/helpers/routeKey/index.ts"),
				u = n("./src/reddit/helpers/trackers/postComposer.ts"),
				m = n("./src/reddit/helpers/trackers/profileSettings.ts"),
				p = n("./src/reddit/models/Comment/index.ts"),
				b = n("./src/reddit/models/Post/index.ts"),
				f = n("./src/reddit/routes/subreddit/index.ts"),
				h = n("./src/reddit/selectors/profile.ts"),
				_ = n("./src/reddit/selectors/subreddit.ts"),
				g = n("./src/lib/makePostCreationPageKey/index.ts"),
				v = n("./src/lib/makeSearchKey/index.ts"),
				x = n("./src/reddit/constants/livebar.ts"),
				O = n("./src/reddit/helpers/correlationIdTracker.ts"),
				E = n("./src/reddit/helpers/search/SearchTelemetrySource.ts"),
				y = n("./src/reddit/helpers/trackers/searchResults.ts"),
				C = n("./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts"),
				j = n("./src/reddit/selectors/postDraft.ts"),
				k = n("./src/reddit/selectors/telemetry.ts"),
				I = n("./src/telemetry/index.ts");
			const S = (e, t, n, s, d, u) => {
					const {
						route: h
					} = e, {
						name: _
					} = h.meta;
					if (!_) return;
					const x = t.platform.currentPage;
					switch (_) {
						case o.Sb.COMMENTS: {
							const {
								partialCommentId: r,
								partialPostId: o
							} = e.match.params, i = Object(b.z)(o), a = Object(l.a)(e, t, t.posts.models[i]);
							if (!a) return;
							const d = r && Object(p.h)(r),
								{
									sortToUse: u
								} = Object(c.a)(t, i);
							Object(I.a)(M(a, i, d, n, s, u)(t));
							break
						}
						case o.Sb.COMMUNITY_HUBS:
							Object(I.a)(Q()(t));
							break;
						case o.Sb.INDEX:
						case o.Sb.LISTING:
						case o.Sb.MULTIREDDIT:
						case o.Sb.SUBREDDIT: {
							const r = Object(l.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: i,
								queryParams: a,
								path: d
							} = e.match, {
								sort: c = (r.sort ? r.sort : o.bb.HOT)
							} = i, u = a.t, m = d === f.a;
							Object(I.a)(T({
								key: r.listingKey,
								sort: c,
								timerType: n,
								timerMillis: s,
								timeSort: u,
								isPredictionsPage: m
							})(t));
							break
						}
						case o.Sb.TOPIC: {
							const r = Object(l.c)(e, t);
							if (!r.listingKey) return;
							const {
								params: i
							} = e.match, a = r.sort ? r.sort : o.cb, {
								sort: d = a
							} = i;
							Object(I.a)(T({
								key: r.listingKey,
								sort: d,
								timerType: n,
								timerMillis: s
							})(t));
							break
						}
						case o.Sb.PROFILE_OVERVIEW: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								params: i,
								queryParams: a
							} = e.match, {
								sort: d = o.Jb
							} = i, c = a.t;
							Object(I.a)(N(r, d, n, s, c)(t));
							break
						}
						case o.Sb.PROFILE_POSTS: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								queryParams: i
							} = e.match, {
								sort: a = o.Jb,
								t: d = o.Kb
							} = i;
							Object(I.a)(P(r, a, n, s, d)(t));
							break
						}
						case o.Sb.PROFILE_COMMENTS: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							const {
								queryParams: i
							} = e.match, {
								sort: a = o.Jb,
								t: d = o.Kb
							} = i;
							Object(I.a)(R(r, a, n, s, d)(t));
							break
						}
						case o.Sb.PROFILE_PRIVATE: {
							const r = Object(l.d)(e, t);
							if (!r) return;
							Object(I.a)(A(r)(s, n)(t));
							break
						}
						case o.Sb.FOLLOWERS:
							q(t);
							break;
						case o.Sb.PROFILE_MODERATION:
							u && D(t, !0);
							break;
						case o.Sb.SETTINGS: {
							const r = e;
							Object(I.a)(Y(n, s)(t)), r.match.params.page === o.jc.Profile && Object(m.l)(t);
							break
						}
						case o.Sb.POST_CREATION:
							if (u && d) {
								const e = Object(g.a)(d);
								Object(I.a)(L(e, n, s)(t))
							}
							break;
						case o.Sb.POST_DRAFT: {
							const {
								draftId: r
							} = e.match.params, o = Object(i.a)(e.match.params);
							if (!o) return;
							G(t, o, r, n, s);
							break
						}
						case o.Sb.SUBREDDIT_WIKI:
							Object(I.a)($(n, s)(t));
							break;
						case o.Sb.COINS:
							Object(I.a)(H(n, s)(t)), Object(I.a)(W()(t));
							break;
						case o.Sb.PREMIUM:
							Object(I.a)(V(n, s)(t)), Object(I.a)(z()(t));
							break;
						case o.Sb.APPEAL:
							Object(I.a)(K(n, s)(t));
							break;
						case o.Sb.INBOX_PAGES:
							u && B(t);
							break;
						case o.Sb.MODERATION_PAGES:
							u && F(t, !0, d ? d.subredditName : null, d ? d.profileName : null);
							break;
						case o.Sb.COLLECTION_COMMENTS:
							u && oe(t, !0);
							break;
						case o.Sb.MODQUEUE_PAGES:
							u && U(t, d ? d.subredditName : null, d ? d.profileName : null);
							break;
						case o.Sb.SUBREDDIT_LEADERBOARD:
							u && Object(I.a)(Z()(t));
							break;
						case o.Sb.SEARCH_RESULTS:
							if (u) {
								const o = Object(l.e)(e);
								if (!o) return;
								Object(I.a)(se(o, Object(v.e)(r()(x && x.queryParams || {}, a.D)), n, s, x)(t))
							}
							break;
						case o.Sb.PUBLIC_ACCESS_NETWORK:
							u && Object(I.a)(J()(t));
							break;
						case o.Sb.GEOTAGGING:
							u && Object(I.a)(ee()(t));
							break;
						case o.Sb.SUBREDDIT_CREATION:
							u && Object(I.a)(X()(t));
							break;
						case o.Sb.MOD_LISTING:
							u && ie(t, !0)
					}
				},
				w = e => ({
					...k.o(e),
					userPreferences: k.tb(e)
				}),
				T = e => {
					let {
						key: t,
						sort: n,
						timerType: s,
						timerMillis: r,
						timeSort: o,
						flairTitle: i,
						isPredictionsPage: a
					} = e;
					return e => {
						const {
							api: d
						} = e.listings.postOrder, c = !d.error[t] && !d.pending[t], l = a ? {
							paneName: "predictions",
							reason: "predictions_tournament"
						} : {}, u = Object(C.b)(e);
						return {
							source: "global",
							action: "view",
							noun: "screen",
							...w(e),
							actionInfo: k.d(e, {
								success: c,
								...l
							}),
							customFeed: k.m(e),
							listing: k.z(e, t, {
								sort: n,
								sortTime: o
							}),
							subreddit: k.kb(e),
							timer: k.qb(s, r),
							userSubreddit: k.ub(e),
							adblock: k.e(e),
							postFlair: {
								title: i
							},
							predictions: a ? Object(k.R)(e) : void 0,
							...(null == u ? void 0 : u.internalLinkUrl) ? {
								seo: u
							} : void 0
						}
					}
				},
				N = (e, t, n, s, r) => o => {
					const i = k.z(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.listings.postOrder, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...w(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.T(o),
						snoovatar: k.hb(o),
						subreddit: k.kb(o),
						timer: k.qb(n, s),
						userSubreddit: k.ub(o),
						adblock: k.e(o)
					}
				},
				P = (e, t, n, s, r) => o => {
					const i = k.z(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.listings.postOrder, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...w(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.T(o),
						subreddit: k.kb(o),
						timer: k.qb(n, s),
						userSubreddit: k.ub(o),
						adblock: k.e(o)
					}
				},
				R = (e, t, n, s, r) => o => {
					const i = k.W(o, e);
					i && (i.sort = t, r && (i.sortTime = r));
					const {
						api: a
					} = o.profileCommentsPage, d = !a.error[e] && !a.pending[e];
					return {
						listing: i,
						source: "global",
						action: "view",
						noun: "screen",
						...w(o),
						actionInfo: k.d(o, {
							success: d
						}),
						profile: k.T(o),
						subreddit: k.kb(o),
						timer: k.qb(n, s),
						userSubreddit: k.ub(o),
						adblock: k.e(o)
					}
				},
				A = e => (t, n) => s => {
					const r = !s.profilePrivatePage.api.error[e] && !s.profilePrivatePage.api.pending[e];
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...w(s),
						actionInfo: k.d(s, {
							success: r
						}),
						profile: k.T(s),
						subreddit: k.kb(s),
						timer: k.qb(n, t),
						userSubreddit: k.ub(s),
						adblock: k.e(s)
					}
				},
				M = (e, t, n, s, r, o) => i => {
					const {
						api: a
					} = i.pages.comments, d = !a.error[e] && !a.pending[e], c = new URLSearchParams(window.location.search).has(x.a), l = Object(C.b)(i), u = {
						source: "global",
						action: "view",
						noun: "screen",
						...w(i),
						actionInfo: k.d(i, {
							success: d,
							...c ? {
								reason: "live_bar"
							} : {}
						}),
						post: k.K(i, t),
						profile: k.T(i),
						subreddit: k.kb(i),
						timer: k.qb(s, r),
						userSubreddit: k.ub(i),
						adblock: k.e(i),
						postEvent: k.N(i, {
							postId: t
						}),
						postCollection: k.M(i, {
							postId: t
						}),
						listing: k.z(i, void 0, {
							sort: o
						})
					};
					return n && (u.comment = k.h({
						state: i,
						commentId: n
					})), (null == l ? void 0 : l.internalLinkUrl) && (u.seo = l), u
				},
				L = (e, t, n) => s => {
					const r = s.creations.api.page.fetched[e],
						o = s.platform.currentPage ? s.platform.currentPage.queryParams.source_id : void 0;
					return {
						source: "global",
						action: "view",
						noun: "screen",
						...w(s),
						actionInfo: k.d(s, {
							success: r
						}),
						post: o ? k.K(s, o) : void 0,
						subreddit: k.kb(s),
						timer: k.qb(t, n),
						userSubreddit: k.ub(s),
						adblock: k.e(s)
					}
				},
				D = (e, t) => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				},
				F = (e, t, n, s) => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e, {
							success: t
						}),
						profile: k.U(e, Object(h.o)(e, s)),
						subreddit: k.lb(e, Object(_.I)(e, n)),
						userSubreddit: k.ub(e),
						adblock: k.e(e)
					})
				},
				U = (e, t, n) => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						profile: k.U(e, Object(h.o)(e, n)),
						subreddit: k.lb(e, Object(_.I)(e, t)),
						userSubreddit: k.ub(e),
						adblock: k.e(e)
					})
				},
				B = e => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e)
					})
				},
				q = e => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e)
					})
				},
				G = (e, t, n, s, r) => {
					const o = e.creations.api.page.pending[t],
						i = !e.creations.api.page.error[t] && !o && !!n,
						a = Object(j.h)(e, n);
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e, {
							success: i
						}),
						subreddit: k.kb(e),
						timer: k.qb(s, r),
						userSubreddit: k.ub(e),
						adblock: k.e(e),
						...a ? Object(u.r)(e, a) : {}
					})
				},
				H = (e, t) => n => ({
					source: "coins_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(O.c)(O.a.GoldPayment),
					...w(n),
					timer: k.qb(e, t),
					adblock: k.e(n)
				}),
				W = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(e)
				}),
				V = (e, t) => n => ({
					source: "premium_marketing",
					action: "view",
					noun: "page",
					correlationId: Object(O.c)(O.a.GoldPayment),
					...w(n),
					timer: k.qb(e, t),
					adblock: k.e(n)
				}),
				z = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(e)
				}),
				K = (e, t) => n => ({
					source: "appeal",
					action: "view",
					noun: "page",
					...w(n),
					timer: k.qb(e, t)
				}),
				Q = () => e => ({
					action: "view",
					source: "global",
					noun: "screen",
					...w(e)
				}),
				Y = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(n),
					timer: k.qb(e, t)
				}),
				J = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					subreddit: k.kb(e),
					...w(e)
				}),
				X = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(e)
				}),
				Z = () => e => ({
					action: "view",
					source: "global",
					noun: "screen",
					...w(e)
				}),
				$ = (e, t) => n => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(n),
					customFeed: k.m(n),
					subreddit: k.kb(n),
					timer: k.qb(e, t),
					userSubreddit: k.ub(n),
					adblock: k.e(n)
				}),
				ee = () => e => ({
					source: "global",
					action: "view",
					noun: "screen",
					...w(e)
				}),
				te = {
					source: "global",
					action: d.c.VIEW,
					noun: "screen"
				},
				ne = e => !!e && {
					correlationId: Object(O.c)(O.a.SearchResults)
				},
				se = (e, t, n, s, r, i) => a => {
					var d, c;
					let l = !0;
					if (t.type.indexOf(o.ic.Posts) > -1) {
						const {
							api: t
						} = a.listings.listingOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					if (t.type.indexOf(o.ic.Subreddits) > -1 || t.type.indexOf(o.ic.Users) > -1) {
						const {
							api: t
						} = a.listings.postOrder;
						l = l && !t.error[e] && !t.pending[e]
					}
					const u = k.H(a, r);
					return {
						...y.g(a, t),
						...te,
						...k.o(a),
						actionInfo: k.d(a, {
							success: l,
							paneName: u
						}),
						timer: k.qb(n, s),
						search: {
							...k.db(a, t, E.a.SERP, r || void 0),
							sort: null !== (d = t.sort) && void 0 !== d ? d : o.Vb,
							range: null !== (c = t.t) && void 0 !== c ? c : o.Wb
						},
						...ne(i),
						userPreferences: k.fb(a)
					}
				},
				re = (e, t, n) => s => ({
					...k.o(s),
					...te,
					actionInfo: {
						...k.d(s),
						pageType: "search_dropdown"
					},
					search: k.db(s, e, E.a.Typeahead, t || void 0),
					...ne(n),
					userPreferences: k.fb(s)
				}),
				oe = (e, t) => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				},
				ie = (e, t) => {
					Object(I.a)({
						source: "global",
						action: "view",
						noun: "screen",
						...w(e),
						actionInfo: k.d(e, {
							success: t
						})
					})
				}
		},
		"./src/reddit/helpers/trackers/shareToChat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
				...Object(r.o)(e),
				source: "post",
				action: s.c.CLICK,
				noun: "share_chat",
				subreddit: Object(r.kb)(e)
			})
		},
		"./src/reddit/helpers/trackers/snoovatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "i", (function() {
				return l
			})), n.d(t, "r", (function() {
				return u
			})), n.d(t, "l", (function() {
				return m
			})), n.d(t, "n", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "q", (function() {
				return _
			})), n.d(t, "e", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "j", (function() {
				return E
			})), n.d(t, "b", (function() {
				return y
			})), n.d(t, "p", (function() {
				return j
			})), n.d(t, "d", (function() {
				return k
			})), n.d(t, "a", (function() {
				return S
			})), n.d(t, "o", (function() {
				return w
			}));
			var s = n("./src/reddit/models/Gold/ProductOffer.ts"),
				r = n("./src/reddit/selectors/avatarMarketing.ts"),
				o = n("./src/reddit/selectors/telemetry.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = {
					goldPurchase: {
						offerContext: s.a.AvatarNewGear
					}
				},
				d = e => t => {
					const n = {
						source: e,
						action: "click",
						noun: "edit_snoovatar",
						...o.o(t)
					};
					return Object(r.a)(t) && Object.assign(n, a), n
				},
				c = (e, t) => n => {
					const {
						id: s
					} = Object(i.Bb)(n, {
						userName: t
					});
					return {
						source: e,
						action: "click",
						noun: "copy_avatar",
						...o.o(n),
						snoovatar: {
							userGenerated: s
						}
					}
				},
				l = e => ({
					...o.o(e),
					source: "avatar",
					action: "click",
					noun: "try_this_look_post",
					snoovatar: o.ib(e)
				}),
				u = e => ({
					...o.o(e),
					source: "global",
					action: "view",
					noun: "screen",
					actionInfo: {
						pageType: "snoovatar_builder"
					},
					snoovatar: o.ib(e)
				}),
				m = e => ({
					...o.o(e),
					source: "avatar_builder",
					action: "click",
					noun: "close",
					snoovatar: o.ib(e)
				}),
				p = e => ({
					source: "nav",
					action: "view",
					noun: "avatar_marketing",
					...o.o(e),
					...a
				}),
				b = e => ({
					source: "nav",
					action: "click",
					noun: "avatar_marketing",
					...o.o(e),
					...a
				}),
				f = e => t => ({
					...o.o(t),
					source: "snoovatar",
					action: "set_to_profile",
					noun: "snoovatar",
					snoovatar: {
						userGeneratedSource: e
					}
				}),
				h = e => t => n => ({
					source: "avatar",
					action: e,
					noun: "community_spaces",
					...o.o(n),
					snoovatar: o.ib(n),
					actionInfo: {
						paneName: "avatar_community_spaces" + (t ? "_control" : "")
					}
				}),
				_ = h("view"),
				g = h("click"),
				v = h("dismiss"),
				x = (e, t, n) => () => s => ({
					source: e,
					action: t,
					noun: n,
					...o.o(s),
					snoovatar: o.ib(s)
				}),
				O = x("anniversary_achievement", "view", "anniversary_achievement"),
				E = x("anniversary_achievement", "click", "close"),
				y = x("anniversary_achievement", "click", "equip"),
				C = e => () => t => ({
					...o.o(t),
					source: "gold_top_nav",
					action: e,
					noun: "quick_create_cta"
				}),
				j = C("view"),
				k = C("click"),
				I = (e, t, n) => s => ({
					source: e,
					action: t,
					noun: n,
					...o.o(s),
					actionInfo: {
						pageType: "onboarding"
					},
					snoovatar: o.ib(s)
				}),
				S = e => I("onboarding", "click", e),
				w = () => I("avatar", "view", "onboarding")
		},
		"./src/reddit/helpers/trackers/socialLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			}));
			var s = n("./src/reddit/constants/tracking.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => {
					let {
						socialLinkType: t,
						outboundUrl: n,
						name: s,
						position: r,
						isNew: o,
						currentList: i
					} = e;
					return {
						socialLink: {
							type: t.toLowerCase(),
							url: n,
							name: s,
							position: r,
							isNew: o,
							currentList: i
						}
					}
				},
				i = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "add_social_link",
					source: e
				}),
				a = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "add_social_link",
					...o({
						socialLinkType: e
					})
				}),
				d = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "save",
					source: "add_social_link",
					...o(e)
				}),
				c = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "edit_social_link",
					source: "profile_settings",
					...o(e)
				}),
				l = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "delete_social_link",
					source: "profile_settings",
					...o(e)
				}),
				u = e => t => ({
					...Object(r.o)(t),
					action: s.c.CLICK,
					noun: "social_link",
					source: "profile",
					profile: Object(r.T)(t),
					...o(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditCreation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			}));
			var s = n("./src/reddit/helpers/correlationIdTracker.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = e => t => ({
					source: e,
					noun: "create_community_button",
					action: "click",
					...r.o(t),
					actionInfo: r.d(t, {
						settingValue: t.user.account && t.user.account.isMod ? "existing_mod" : "new_mod"
					}),
					correlationId: Object(s.d)(s.a.SubredditCreation, !0)
				}),
				i = (e, t, n) => o => ({
					source: "community_form",
					noun: "save_community_button",
					action: "click",
					...r.o(o),
					actionInfo: r.d(o, {
						settingValue: e
					}),
					subreddit: {
						id: n,
						name: t.name,
						publicDescription: t.publicDescription,
						nsfw: t.over18,
						accessType: t.type,
						topicTagContents: t.allTags,
						topicTagPrimaryId: t.primaryTagId
					},
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				a = () => e => ({
					source: "community_form",
					noun: "cancel",
					action: "click",
					...r.o(e),
					actionInfo: r.d(e),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				d = (e, t) => n => ({
					source: "community_form",
					noun: "error_message",
					action: "view",
					...r.o(n),
					actionInfo: r.d(n, {
						reason: e,
						settingValue: t
					}),
					correlationId: Object(s.c)(s.a.SubredditCreation)
				}),
				c = () => e => ({
					source: "user_dropdown",
					noun: "create_community",
					action: "click",
					...r.o(e),
					actionInfo: r.d(e)
				}),
				l = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "view",
					...r.o(e),
					actionInfo: r.d(e)
				}),
				u = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "click",
					...r.o(e),
					actionInfo: r.d(e)
				}),
				m = () => e => ({
					source: "community_first_post",
					noun: "modal",
					action: "dismiss",
					...r.o(e),
					actionInfo: r.d(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditForking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			}));
			var s = n("./src/reddit/selectors/telemetry.ts");
			const r = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "click",
					...s.o(e),
					actionInfo: s.d(e, {
						settingValue: e.user.account && e.user.account.isMod ? "existing_mod" : "new_mod"
					})
				}),
				o = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "dismiss",
					...s.o(e),
					actionInfo: s.d(e)
				}),
				i = e => e => ({
					source: "post",
					noun: "forking_module",
					action: "view",
					...s.o(e),
					actionInfo: s.d(e)
				})
		},
		"./src/reddit/helpers/trackers/subredditMuting.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "h", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./src/reddit/selectors/telemetry.ts"),
				r = n("./src/telemetry/models/Event.ts");
			const o = () => e => ({
					source: r.f.HomeFeed,
					action: r.d.Click,
					noun: r.e.MuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				i = () => e => ({
					source: r.f.UserPreferences,
					action: r.d.Click,
					noun: r.e.UnmuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				a = () => e => ({
					source: r.f.UserPreferences,
					action: r.d.Click,
					noun: r.e.MuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				d = () => e => ({
					source: r.f.CommunityNotificationsSettings,
					action: r.d.Click,
					noun: r.e.UnmuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				c = () => e => ({
					source: r.f.PopularFeed,
					action: r.d.Click,
					noun: r.e.MuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				l = () => e => ({
					source: r.f.SubredditIdBanner,
					action: r.d.Click,
					noun: r.e.UnmuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				u = () => e => ({
					source: r.f.AboutCommunityOverflow,
					action: r.d.Click,
					noun: r.e.MuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				}),
				m = () => e => ({
					source: r.f.AboutCommunityOverflow,
					action: r.d.Click,
					noun: r.e.UnmuteSubreddit,
					targetUser: {
						id: s.sb(e).id
					},
					...s.o(e)
				})
		},
		"./src/reddit/helpers/trackers/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			var s = n("./src/reddit/helpers/flair.ts"),
				r = n("./src/reddit/selectors/telemetry.ts");
			const o = () => e => ({
					source: "id_card",
					action: "click",
					noun: "user_flair_picker",
					...r.o(e)
				}),
				i = e => t => {
					const n = r.kb(t),
						{
							userFlair: o,
							achievementFlair: i
						} = e;
					return {
						source: "user_flair_picker",
						action: "click",
						noun: "user_flair",
						...r.o(t),
						subreddit: n,
						userFlair: {
							id: null == o ? void 0 : o.id,
							title: o ? Object(s.g)(o) : void 0,
							isActive: !!o || void 0,
							achievementFlairId: null == i ? void 0 : i.type,
							achievementFlairTitle: null == i ? void 0 : i.name,
							isLocked: null == i ? void 0 : i.isLocked
						}
					}
				},
				a = () => e => ({
					source: "user_flair_picker",
					action: "click",
					noun: "edit_user_flair",
					...r.o(e)
				}),
				d = e => t => ({
					source: "user_flair_picker",
					action: "click",
					noun: "enable_powerups_flair",
					setting: {
						value: e ? "0" : "1",
						oldValue: e ? "1" : "0"
					},
					subreddit: r.kb(t),
					...r.o(t)
				})
		},
		"./src/reddit/helpers/validateFlairCssClass.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./src/reddit/constants/flair.ts");
			const o = new RegExp(`^[a-zA-Z0-9-]{1,${r.f}}$`);
			t.a = e => {
				if (!e) return;
				const t = e.split(" ").filter(Boolean);
				if (t.length > r.c) return s.fbt._("Too many class names", null, {
					hk: "musK5"
				});
				const n = t.find(e => !e.match(o));
				return n ? n.length > r.f ? s.fbt._("Class name should not be longer than 100 characters", null, {
					hk: "2nBmgP"
				}) : s.fbt._("Class name contains an invalid character", null, {
					hk: "4kdVCU"
				}) : void 0
			}
		},
		"./src/reddit/helpers/wiki/buildWikiPagesTree.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/sortBy.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/wiki.ts");
			const i = e => {
				return r()(e, e => `${e.path}/`.startsWith(`${o.i}/`) ? `\0${e.path}` : e.path).filter(e => !o.l.includes(e.path))
			};
			t.a = e => {
				const t = new Map,
					n = [];
				return i(e).forEach(e => {
					const s = {
							...e,
							children: []
						},
						r = s.parent ? t.get(s.parent) : null;
					r ? r.children.push(s) : n.push(s), t.set(s.path, s)
				}), n
			}
		},
		"./src/reddit/helpers/wiki/makeComparisonDiffKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const {
					comparisonRevisionId: t,
					revisionId: n,
					subredditName: s,
					wikiPageName: r
				} = e;
				return `[${s}]--[${r}]--[rev1:${n}]--[rev2:${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeRevisionsListingKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				const t = e.isRecent ? "(recent)" : e.wikiPageName;
				return `[${e.subredditName}]--[${t}]`.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/makeWikiPageKey.ts": function(e, t, n) {
			"use strict";
			t.a = e => {
				let t = `[${e.subredditName}]--[${e.wikiPageName}]`;
				return e.revisionId && (t += `--[rev:${e.revisionId}]`), t.toLowerCase()
			}
		},
		"./src/reddit/helpers/wiki/validatePageName.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./src/reddit/constants/wiki.ts");
			const r = new RegExp(`^[-\\w]+(?:\\/[-\\w]+){0,${s.c}}$`),
				o = /^[-\w]+$/;
			var i;
			! function(e) {
				e[e.InvalidPageName = 1] = "InvalidPageName", e[e.RestrictedPageName = 2] = "RestrictedPageName", e[e.MaxLengthExceed = 3] = "MaxLengthExceed", e[e.PageAlreadyExists = 4] = "PageAlreadyExists"
			}(i || (i = {}));
			const a = e => {
					if (!o.test(e.toLowerCase())) return i.InvalidPageName
				},
				d = (e, t) => {
					const n = e.toLowerCase(),
						o = n.split("/")[0],
						a = s.b.has(o),
						d = s.f.has(o) && n !== s.h && n !== s.k;
					if (a || d) return i.RestrictedPageName;
					if (!r.test(n)) return i.InvalidPageName;
					if (t) {
						if (t.some(e => e.path.toLowerCase() === n)) return i.PageAlreadyExists
					}
					return n.length > s.d ? i.MaxLengthExceed : void 0
				}
		},
		"./src/reddit/helpers/wiki/wikiRevision.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			}));
			const s = e => e.startsWith("WikiRevision_") ? e : "WikiRevision_" + e,
				r = e => e.startsWith("WikiRevision_") ? e.slice("WikiRevision_".length) : e
		},
		"./src/reddit/hooks/useClickSourceData.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js"),
				o = n("./src/reddit/helpers/clickSourceData/index.ts");

			function i() {
				const e = Object(r.e)(e => e.platform.currentPage),
					[t, n] = Object(s.useState)({});
				return Object(s.useEffect)(() => {
					n(Object(o.b)(e))
				}, [e]), t
			}
		},
		"./src/reddit/hooks/useDesktopNotificationsPromptSeen.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/helpers/localStorage/index.ts");

			function o(e) {
				const [t, n] = Object(s.useState)(Object(r.t)(e));
				return [t, Object(s.useCallback)(() => {
					n(!0), Object(r.sb)(e)
				}, [])]
			}
		},
		"./src/reddit/hooks/useExperimentVariant.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");

			function o(e) {
				let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.a;
				return Object(s.e)(n => Object(r.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: t
				}))
			}
		},
		"./src/reddit/hooks/useInfoTextTooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/icepick/icepick.js"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/lib/hooks/useTooltip.ts");
			const i = Object(s.freeze)({
				name: "offset",
				options: {
					offset: [0, 6]
				}
			});

			function a(e) {
				const t = Object(r.useMemo)(() => {
					const t = Object(o.a)(e);
					return Object(s.updateIn)(t, ["modifiers"], e => Object(s.push)(e, i))
				}, [e]);
				return Object(o.b)(t)
			}
		},
		"./src/reddit/hooks/useIntersectionObserver.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js");
			t.a = function(e, t, n) {
				Object(s.useEffect)(() => {
					const s = e && e.current;
					if (!s || "undefined" == typeof IntersectionObserver) return;
					const r = new IntersectionObserver(t, n);
					return r.observe(s), () => {
						r.unobserve(s)
					}
				}, [e, t, n])
			}
		},
		"./src/reddit/hooks/useIsAvatarPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react-redux/es/index.js");
			const r = ["t2_83axfjo9", "t2_5ybo8iyi", "t2_7yef0w0w", "t2_fvlxukt", "t2_16060o", "t2_364me452", "t2_46dwatoq", "t2_86xzqcqi", "t2_97lsdz5t", "t2_8394tzuq ", "t2_b46ms2wj", "t2_btxoz0zb"],
				o = ["t5_q0gj4", "t5_2rjli"],
				i = new RegExp(/https:\/\/(www\.)?reddit.com\/avatar\/.*\/\d+$/);
			var a = n("./src/reddit/selectors/experiments/econ/index.ts");
			const d = e => Object(s.e)(t => {
				return !!(e => {
					let {
						adminId: t,
						subredditId: n,
						avatarShareUrl: s
					} = e;
					const a = i.test(s.trim()),
						d = r.includes(t),
						c = o.includes(n);
					return a && d && c
				})({
					adminId: e.authorId,
					subredditId: e.belongsTo.id,
					avatarShareUrl: e.source ? e.source.url : ""
				}) && Object(a.a)(t)
			})
		},
		"./src/reddit/hooks/useIsRemovedOrDeletedPost.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/selectors/removedPosts.ts");
			const o = () => Object(s.e)(e => Object(r.d)(e))
		},
		"./src/reddit/hooks/useLocale.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/index.js"),
				r = n("./node_modules/@reddit/i18n-tools/runtime/helpers/locale/constants.js"),
				o = n("./node_modules/react-redux/es/index.js"),
				i = n("./src/reddit/selectors/meta.ts");
			const a = "undefined" == typeof document ? function() {
				const e = Object(o.e)(i.j) || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			} : function() {
				const e = document.documentElement.lang || r.DEFAULT_LOCALE;
				return Object(s.isPseudoLocale)(e) ? r.DEFAULT_LOCALE : e
			};
			t.a = a;
			const d = () => {
				const e = a(),
					t = Object(o.e)(i.b);
				return t ? e.replace(/([a-z]+-)([A-Z]+)/, `$1${t}`) : e
			}
		},
		"./src/reddit/hooks/useMemoShallowEqual.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./node_modules/react-redux/es/index.js");

			function o(e) {
				const t = Object(s.useRef)(e);
				return t.current === e || Object(r.c)(t.current, e) || (t.current = e), t.current
			}
		},
		"./src/reddit/hooks/useOutboundClickTracking.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			const r = /^https?:\/\/([\w\.\-]+\.)?(reddit(media|static)?\.com|redd\.it)(\/|$)/;
			var o = n("./src/reddit/helpers/trackers/socialLinks.ts"),
				i = n("./src/reddit/selectors/telemetry.ts");
			const a = (e, t, n, s, r) => a => {
				const d = {
					noun: "outbound_link",
					action: "click",
					source: "link",
					...Object(i.o)(a),
					actionInfo: Object(i.d)(a),
					geo: Object(i.t)(a),
					screen: Object(i.cb)(a),
					subreddit: Object(i.kb)(a),
					outbound: Object(i.G)(a, e, t, s, n)
				};
				return n && (d.comment = Object(i.h)({
					state: a,
					commentId: n
				})), s && (d.post = Object(i.K)(a, s)), r && (d.socialLink = Object(o.g)({
					socialLinkType: r
				}).socialLink), d
			};
			var d = n("./src/lib/serviceWorker/index.ts"),
				c = n("./node_modules/react-redux/es/index.js"),
				l = n("./src/telemetry/helpers/getSerializedThriftJSON.ts"),
				u = n("./src/telemetry/helpers/getSignatureHeader.ts"),
				m = n("./src/telemetry/models/Event.ts");
			const p = () => {
				const e = Object(c.f)();
				return t => {
					const n = t(e.getState()),
						s = m.g(n),
						r = Object(l.a)(s),
						o = Object(u.b)(r);
					Object(d.b)("sendV2EventsData", {
						data: r,
						headers: o
					})
				}
			};

			function b() {
				const e = Object(s.b)(),
					t = p();
				return (n, s, o, i, d) => {
					var c, l;
					if (s && function(e) {
							return !e.startsWith("/") && null == e.match(r)
						}(n)) {
						const r = a(n, s, o, i, d);
						(null === (l = null === (c = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === c ? void 0 : c.serviceWorker) || void 0 === l ? void 0 : l.controller) ? t(r): e(r)
					}
				}
			}
		},
		"./src/reddit/hooks/usePageLayer.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/contexts/PageLayer/index.tsx");
			t.a = s.gb
		},
		"./src/reddit/hooks/usePostContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/lib/sentry/index.ts"),
				r = n("./node_modules/react/index.js"),
				o = n("./src/reddit/contexts/Post/index.tsx");

			function i() {
				const e = Object(r.useContext)(o.c);
				return e || s.c.captureMessage("No post context provided"), e
			}
		},
		"./src/reddit/hooks/useTheme.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/lib/CSSVariableProvider/index.tsx");

			function o() {
				return Object(s.useContext)(r.b)
			}
		},
		"./src/reddit/hooks/useTracking.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/components/TrackingHelper/index.tsx");
			t.a = s.b
		},
		"./src/reddit/hooks/useUserContext.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n("./src/reddit/contexts/User/index.tsx");

			function o() {
				return Object(s.useContext)(r.a)
			}
		},
		"./src/reddit/icons/fonts/Approve/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("approve", e.isFilled), d.a.approveIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Archived/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("archived", e.isFilled), d.a.archivedIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Calendar/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("scheduled", e.isFilled), d.a.calendarIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Comment/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("i", c({
					className: Object(o.a)(Object(i.b)("comment", n.isFilled), d.a.commentIcon, t)
				}, n))
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactDownvote: "_2GCoZTwJW7199HSwNZwlHk",
				compactDownvoteWrapper: "jR747Vd1NbfaLusf5bHre",
				downvote: "ZyxIIl4FP5gHGrJDzNpUC",
				downvoteWrapper: "_1iKd82bq_nqObFvSH1iC_Q"
			}
		},
		"./src/reddit/icons/fonts/Downvote/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Downvote/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("downvote", e.isFilled), d.a.downvote, e.className)
			});
			t.a = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactDownvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactDownvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.downvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/DropdownTriangle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("caret_down",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less": function(e, t, n) {
			e.exports = {
				CollapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI",
				collapseIcon: "_3D7Ev4BX__nKnbqb-KPpvI"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Expandos/Arrows/Collapse/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("collapse",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "CollapseIcon", a.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less": function(e, t, n) {
			e.exports = {
				ExpandIcon: "QOwFub52NskNmv0MdMa2_",
				expandIcon: "QOwFub52NskNmv0MdMa2_"
			}
		},
		"./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Expandos/Arrows/Expand/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				className: `${Object(o.b)("expand",e.isFilled)} ${e.className}`,
				onClick: e.onClick,
				title: e.title
			}), "ExpandIcon", a.a);
			t.a = d
		},
		"./src/reddit/icons/fonts/Gift/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/index.tsx");

			function i() {
				return (i = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement(o.a, i({
				name: "award"
			}, e))
		},
		"./src/reddit/icons/fonts/IgnoreReport/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("ignore_reports",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("info",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Live/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("live", e.isFilled), d.a.liveIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("lock", e.isFilled), d.a.lockIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/ModActions/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("i", c({}, e, {
				className: Object(o.a)(Object(i.b)("mod", e.isFilled), d.a.modActions, e.className)
			}))
		},
		"./src/reddit/icons/fonts/OutboundLink/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("external_link",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Premium/index.m.less": function(e, t, n) {
			e.exports = {
				PremiumIcon: "dLp3R7pmxclGjLS87yr5S",
				premiumIcon: "dLp3R7pmxclGjLS87yr5S"
			}
		},
		"./src/reddit/icons/fonts/Premium/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx"),
				i = n("./src/reddit/icons/fonts/Premium/index.m.less"),
				a = n.n(i);
			const d = n("./src/lib/lessComponent.tsx").a.wrapped(e => r.a.createElement("i", {
				title: e.title,
				className: `${Object(o.b)("premium",e.isFilled)} ${e.className}`
			}), "PremiumIcon", a.a)
		},
		"./src/reddit/icons/fonts/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("remove", e.isFilled), d.a.removeIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Report/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("report", e.isFilled), d.a.reportIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Share/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("share", e.isFilled), d.a.shareIcon, e.className)
			})
		},
		"./src/reddit/icons/fonts/Spam/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("spam", e.isFilled), d.a.spamIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Sticky/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/commonStyles.m.less"),
				d = n.n(a);
			t.a = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("pin", e.isFilled), d.a.stickyIcon, e.className),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement(i.a, null, e.desc))
		},
		"./src/reddit/icons/fonts/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.tsx");
			t.a = e => r.a.createElement("i", {
				className: `${Object(o.b)("tag",e.isFilled)} ${e.className}`
			})
		},
		"./src/reddit/icons/fonts/Upvote/index.m.less": function(e, t, n) {
			e.exports = {
				compactUpvote: "_39UOLMgvssWenwbRxz_iEn",
				compactUpvoteWrapper: "_3wVayy5JvIMI67DheMYra2",
				upvote: "_2Jxk822qXs4DaXwsN7yyHA",
				upvoteWrapper: "_2q7IQ0BUOWeEZoeAxN555e"
			}
		},
		"./src/reddit/icons/fonts/Upvote/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx"),
				a = n("./src/reddit/icons/fonts/Upvote/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const l = e => r.a.createElement("i", {
				className: Object(o.a)(Object(i.b)("upvote", e.isFilled), d.a.upvote, e.className)
			});
			t.b = e => {
				let {
					compact: t,
					isFilled: n,
					...s
				} = e;
				return t ? r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.compactUpvoteWrapper, s.className)
				}), r.a.createElement(l, {
					className: d.a.compactUpvote,
					isFilled: n
				})) : r.a.createElement("span", c({}, s, {
					className: Object(o.a)(d.a.upvoteWrapper, s.className)
				}), r.a.createElement(l, {
					isFilled: n
				}))
			}
		},
		"./src/reddit/icons/fonts/commonStyles.m.less": function(e, t, n) {},
		"./src/reddit/icons/fonts/helpers.m.less": function(e, t, n) {
			e.exports = {
				TooltipDesc: "_37iEJpUpWXN00_fpZKHglg",
				tooltipDesc: "_37iEJpUpWXN00_fpZKHglg"
			}
		},
		"./src/reddit/icons/fonts/helpers.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/icons/fonts/helpers.m.less"),
				i = n.n(o),
				a = n("./src/lib/constants/icons.ts"),
				d = n("./src/lib/lessComponent.tsx");
			const c = (e, t) => `icon icon-${e}${t&&!e.includes("fill")&&a.a[`${e}_fill`]?"_fill":""}`,
				l = d.a.wrapped(e => r.a.createElement("span", {
					className: e.className
				}, e.children), "TooltipDesc", i.a)
		},
		"./src/reddit/icons/fonts/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/fonts/helpers.tsx");

			function a() {
				return (a = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const d = e => {
				let {
					className: t,
					isFilled: n,
					name: s,
					...d
				} = e;
				return r.a.createElement("i", a({
					className: Object(o.a)(t, Object(i.b)(s, n))
				}, d))
			};
			d.displayName = "Icon";
			const c = (e, t) => n => r.a.createElement(d, a({
				name: e
			}, t, n, {
				isFilled: (null == t ? void 0 : t.isFilled) || (null == n ? void 0 : n.isFilled),
				className: Object(o.a)(null == t ? void 0 : t.className, null == n ? void 0 : n.className)
			}));
			t.a = d
		},
		"./src/reddit/icons/svgs/AddCollection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 24 24"
			}, r.a.createElement("defs", null, r.a.createElement("path", {
				id: "svg-add-collection",
				d: "M19.2 2.4a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V4.8a2.4 2.4 0 0 1 2.4-2.4h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v.936a3.577 3.577 0 0 0-2.4-.936H4.8c-.925 0-1.763.361-2.4.936V8.4A2.4 2.4 0 0 1 4.8 6h14.4zm0 3.6a2.4 2.4 0 0 1 2.4 2.4v7.2a2.4 2.4 0 0 1-2.4 2.4H4.8a2.4 2.4 0 0 1-2.4-2.4V12a2.4 2.4 0 0 1 2.4-2.4h14.4zm-3.806 5.1H12.9v-2.494a.9.9 0 1 0-1.8 0V14.7H8.607a.9.9 0 1 0 0 1.8H11.1v2.494a.9.9 0 1 0 1.8 0V16.5h2.494a.9.9 0 0 0 0-1.8z"
			})), r.a.createElement("use", {
				fill: "inherit",
				xlinkHref: "#svg-add-collection",
				fillRule: "evenodd"
			}))
		},
		"./src/reddit/icons/svgs/Admin/index.m.less": function(e, t, n) {
			e.exports = {
				admin: "_1PeZajQI0Wm8P3B45yshR",
				mEnabled: "_3axV0unm-cpsxoKWYwKh2x"
			}
		},
		"./src/reddit/icons/svgs/Admin/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Admin/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, a.a.admin, {
					[a.a.mEnabled]: e.enabled
				}),
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 -0.75 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M19.99,9.3125 C19.99,8.104375 19.010625,7.125 17.8025,7.125 C17.213125,7.125 16.67875,7.359375 16.285625,7.73875 C14.8075,6.6725 12.776875,5.98 10.514375,5.886875 L11.491875,1.2875 L14.695625,1.96875 C14.775,2.756875 15.433125,3.375 16.2425,3.375 C17.105625,3.375 17.805,2.675625 17.805,1.8125 C17.805,0.949375 17.105625,0.25 16.2425,0.25 C15.6575,0.25 15.154375,0.575 14.88625,1.050625 L11.228125,0.273125 C11.10625,0.24625 10.98,0.270625 10.875625,0.338125 C10.77125,0.40625 10.698125,0.5125 10.6725,0.63375 L9.556875,5.8825 C7.26,5.960625 5.1975,6.65625 3.7,7.735 C3.306875,7.358125 2.775,7.125 2.1875,7.125 C0.979375,7.125 0,8.104375 0,9.3125 C0,10.20125 0.530625,10.965 1.2925,11.306875 C1.25875,11.524375 1.24,11.745 1.24,11.96875 C1.24,15.334375 5.1575,18.0625 9.99,18.0625 C14.8225,18.0625 18.74,15.334375 18.74,11.96875 C18.74,11.746875 18.721875,11.5275 18.68875,11.31125 C19.455,10.97125 19.99,10.205 19.99,9.3125"
			})), r.a.createElement("g", {
				fill: "none",
				fillRule: "evenodd"
			}, r.a.createElement("polygon", {
				points: "0 20 20 20 20 0 0 0"
			}), r.a.createElement("g", {
				transform: "translate(0 1)"
			})))
		},
		"./src/reddit/icons/svgs/ArrowRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 11.4 11.4",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "m11.17929,5.99479c0.08081,-0.19519 0.08081,-0.41599 0,-0.61118c-0.0408,-0.0984 -0.0992,-0.1864 -0.17361,-0.2608l-4.79963,-4.79911c-0.31283,-0.3128 -0.81847,-0.3128 -1.1313,0c-0.31283,0.31279 -0.31283,0.81918 0,1.13118l3.43471,3.43433l-7.66949,0c-0.44244,0 -0.80007,0.3584 -0.80007,0.79999c0,0.44159 0.35763,0.79999 0.80007,0.79999l7.66949,0l-3.43471,3.43433c-0.31283,0.3128 -0.31283,0.81919 0,1.13118c0.15601,0.156 0.36083,0.2344 0.56565,0.2344c0.20482,0 0.40964,-0.0784 0.56565,-0.2344l4.79963,-4.79911c0.07441,-0.0744 0.13281,-0.1624 0.17361,-0.2608"
			})))
		},
		"./src/reddit/icons/svgs/Checkbox/index.m.less": function(e, t, n) {
			e.exports = {
				checkbox: "_1vmueUAOJJg7fhS7wxztWa"
			}
		},
		"./src/reddit/icons/svgs/Checkbox/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Checkbox/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => {
				let {
					className: t,
					...n
				} = e;
				return r.a.createElement("svg", d({
					xmlns: "http://www.w3.org/2000/svg",
					width: "20",
					height: "20",
					viewBox: "0 0 20 20",
					className: Object(o.a)(a.a.checkbox, t)
				}, n), r.a.createElement("path", {
					fill: "inherit",
					d: "M1.66666667,3.34755033 L1.66666667,16.6524497 C1.66666667,17.5781756 2.42112363,18.3333333 3.34755033,18.3333333 L16.6524497,18.3333333 C17.5781756,18.3333333 18.3333333,17.5788764 18.3333333,16.6524497 L18.3333333,3.34755033 C18.3333333,2.42182438 17.5788764,1.66666667 16.6524497,1.66666667 L3.34755033,1.66666667 C2.42182438,1.66666667 1.66666667,2.42112363 1.66666667,3.34755033 Z M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z"
				}))
			}
		},
		"./src/reddit/icons/svgs/CheckboxSelected/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				xmlns: "http://www.w3.org/2000/svg",
				width: "20",
				height: "20",
				viewBox: "0 0 20 20"
			}, e), r.a.createElement("path", {
				fill: "inherit",
				d: "M0,3.34755033 C0,1.49874933 1.5032506,0 3.34755033,0 L16.6524497,0 C18.5012507,0 20,1.5032506 20,3.34755033 L20,16.6524497 C20,18.5012507 18.4967494,20 16.6524497,20 L3.34755033,20 C1.49874933,20 0,18.4967494 0,16.6524497 L0,3.34755033 Z M8.50575,15.1995 L15.797625,7.907625 C16.25325,7.452625 16.25325,6.71325 15.797625,6.25825 C15.342,5.802625 14.602625,5.802625 14.147625,6.25825 L7.7295,12.676375 L5.635125,10.327625 C5.20575,9.846375 4.46825,9.805125 3.987625,10.23325 C3.506375,10.662625 3.4645,11.400125 3.89325,11.88075 L6.810125,15.151375 C7.023875,15.39075 7.327,15.531375 7.647625,15.54075 C7.658875,15.54075 7.6695,15.541375 7.68075,15.541375 C7.990125,15.541375 8.287,15.41825 8.50575,15.1995 Z"
			}))
		},
		"./src/reddit/icons/svgs/Checkmark/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 22",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/CheckmarkFitted/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "3 4 14 14",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8.9310375,15.1995 C8.70135,15.41825 8.38963125,15.541375 8.0647875,15.541375 C8.052975,15.541375 8.04181875,15.54075 8.03000625,15.54075 C7.69335,15.531375 7.37506875,15.39075 7.15063125,15.151375 L4.0879125,11.88075 C3.637725,11.400125 3.68169375,10.662625 4.18700625,10.23325 C4.6916625,9.805125 5.4660375,9.846375 5.91688125,10.327625 L8.115975,12.676375 L14.8550063,6.25825 C15.3327563,5.802625 16.1091,5.802625 16.5875063,6.25825 C17.0659125,6.71325 17.0659125,7.452625 16.5875063,7.907625 L8.9310375,15.1995 Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/ChevronDown/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/ChevronUp/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 12 12",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				transform: "translate(6.029200, 6.044700) scale(1, -1) translate(-6.029200, -6.044700)",
				points: "11.0584 4.0602 6.0292 9.0894 1 4.0602 2.0608 3 6.0292 6.9684 9.9982 3"
			})))
		},
		"./src/reddit/icons/svgs/Circle/index.m.less": function(e, t, n) {
			e.exports = {
				circle: "_17IuRdA-NY8vFk-Tt991sn"
			}
		},
		"./src/reddit/icons/svgs/Circle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Circle/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.circle, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 8 8"
			}, r.a.createElement("g", {
				fill: "inherit",
				stroke: "none"
			}, r.a.createElement("circle", {
				r: "4",
				cy: "4",
				cx: "4"
			})))
		},
		"./src/reddit/icons/svgs/ClearFilled/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				onClick: e.onClick,
				onMouseUp: e.onMouseUp,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("path", {
				d: "M20 2.5C10.3 2.5 2.5 10.3 2.5 20c0 9.7 7.8 17.5 17.5 17.5S37.5 29.7 37.5 20C37.5 10.3 29.7 2.5 20 2.5zM24.2 27.7L20 23.5l-4.2 4.2c-1.1 1.1-2.5 1.1-3.5 0-1.1-1.1-1.1-2.4 0-3.5l4.2-4.2-4.2-4.2c-1.1-1.1-1.1-2.5 0-3.5 1.1-1.1 2.4-1.1 3.5 0l4.2 4.2 4.2-4.2c1.1-1.1 2.5-1.1 3.5 0 1.1 1.1 1.1 2.4 0 3.5L23.5 20l4.2 4.2c1.1 1.1 1.1 2.5 0 3.5C26.7 28.8 25.3 28.8 24.2 27.7z"
			}))
		},
		"./src/reddit/icons/svgs/Clock/index.m.less": function(e, t, n) {
			e.exports = {
				clock: "_3dezPhiKJXkVFXj94zLKcs"
			}
		},
		"./src/reddit/icons/svgs/Clock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Clock/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.clock, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 11 11"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M5 3.75C5 3.47388 5.22363 3.25 5.5 3.25C5.77637 3.25 6 3.47388 6 3.75V5.53735L7.81689 6.58643C8.05615 6.72449 8.13818 7.03027 8 7.26941C7.86182 7.50861 7.55615 7.59052 7.31689 7.45245L5.25049 6.25934C5.07861 6.16028 4.98779 5.97504 5.00146 5.78992L5 5.75V3.75Z",
				fill: "inherit"
			}), r.a.createElement("path", {
				fillRule: "evenodd",
				clipRule: "evenodd",
				d: "M11 5.5C11 8.53754 8.5376 11 5.5 11C2.4624 11 0 8.53754 0 5.5C0 2.46246 2.4624 0 5.5 0C8.5376 0 11 2.46246 11 5.5ZM10 5.5C10 7.98529 7.98535 10 5.5 10C3.01465 10 1 7.98529 1 5.5C1 3.01471 3.01465 1 5.5 1C7.98535 1 10 3.01471 10 5.5Z",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Close/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("polygon", {
				fill: "inherit",
				points: "11.649 9.882 18.262 3.267 16.495 1.5 9.881 8.114 3.267 1.5 1.5 3.267 8.114 9.883 1.5 16.497 3.267 18.264 9.881 11.65 16.495 18.264 18.262 16.497"
			}))
		},
		"./src/reddit/icons/svgs/Collection/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M14 0H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 2h12c.77 0 1.468.301 2 .78V2a2 2 0 0 0-2-2zm0 3H2a2 2 0 0 0-2 2v.78A2.979 2.979 0 0 1 2 5h12c.77 0 1.468.301 2 .78V5a2 2 0 0 0-2-2zM2 6h12a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z"
			})))
		},
		"./src/reddit/icons/svgs/Crosspost/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("path", {
				d: "M9.06,8.64c1.12-1.26,2.2-2.45,4.44-2.6V7.5a1,1,0,0,0,.6.92,1,1,0,0,0,.41.09,1,1,0,0,0,.67-.26l3.16-2.9a.5.5,0,0,0,0-.74L15.18,1.7a1,1,0,0,0-1.68.74V4c-3.14.17-4.69,1.88-5.93,3.28C6.58,8.42,6,9,5,9H2a1,1,0,0,0,0,2H5C6.93,11,8,9.82,9.06,8.64Z"
			}), r.a.createElement("path", {
				d: "M15.18,11.76a1,1,0,0,0-1.68.74V14c-2.23-.16-3.29-1.32-4.39-2.56-.21-.24-.43-.48-.66-.72a5.63,5.63,0,0,1-1.77,1.06,13.34,13.34,0,0,1,.94,1A7.85,7.85,0,0,0,13.5,16v1.59a1,1,0,0,0,.6.92,1,1,0,0,0,.41.09,1,1,0,0,0,.67-.26l3.16-2.9a.5.5,0,0,0,0-.74Z"
			}))
		},
		"./src/reddit/icons/svgs/Dropdown/index.m.less": function(e, t, n) {
			e.exports = {
				dropdown: "XHbKeEqnW58ib9mTN6jnS",
				mRedditStyle: "u_kypUXmB-k1A5TcC8MI9"
			}
		},
		"./src/reddit/icons/svgs/Dropdown/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Dropdown/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const c = e => {
				let {
					className: t,
					isSubreddit: n,
					...s
				} = e;
				return r.a.createElement("svg", d({
					className: Object(o.a)(a.a.dropdown, {
						[a.a.mRedditStyle]: !n
					}, t),
					viewBox: "0 0 20 20",
					xmlns: "http://www.w3.org/2000/svg"
				}, s), r.a.createElement("path", {
					d: "M14.17,9.35,10,13.53,5.83,9.35a.5.5,0,0,1,.35-.85h7.64a.5.5,0,0,1,.35.85"
				}))
			};
			t.b = c
		},
		"./src/reddit/icons/svgs/Event/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M4 16h12V9H4v7zM17 4h-2V3a1 1 0 0 0-2 0v1H7V3a1 1 0 0 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z"
			})))
		},
		"./src/reddit/icons/svgs/Eye/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o(e) {
				return r.a.createElement("svg", {
					className: e.className,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 40 40"
				}, r.a.createElement("g", null, r.a.createElement("path", {
					d: "M20,8C9.1,8,0.5,14,0.5,21.7h4c0-3.6,3.4-6.9,8.2-8.5C11,15,10,17.4,10,20c0,5.5,4.5,10,10,10s10-4.5,10-10c0-2.6-1-5-2.7-6.8c4.8,1.7,8.2,4.9,8.2,8.5h4C39.5,14,30.9,8,20,8z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Gild/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("g", {
				stroke: "none",
				strokeWidth: "1",
				fillRule: "evenodd"
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "m15.1275768 8.9935-2.059 2.204.371 2.992c.022.181-.055.359-.203.466-.087.064-.19.096-.294.096-.072 0-.144-.016-.211-.047l-2.73200003-1.277-2.731 1.277c-.164.076-.359.059-.506-.049-.148-.107-.225-.285-.202-.466l.37-2.992-2.059-2.204c-.124-.133-.166-.323-.11-.496s.202-.302.381-.336l2.96-.573 1.46-2.639c.175-.318.69900003-.318.87500003 0l1.46 2.639 2.959.573c.179.034.325.163.381.336s.014.363-.11.496m2.911-2.985-6.586-4.786c-.869-.63-2.03700003-.63-2.90600003 0v.001l-6.586 4.785c-.869.631-1.23 1.742-.898 2.764l2.515 7.743c.332 1.021 1.278 1.708 2.352 1.708h8.14000003c1.075 0 2.02-.687 2.352-1.708l2.516-7.743c.332-1.022-.03-2.133-.899-2.764"
			}))))
		},
		"./src/reddit/icons/svgs/Grapple/index.m.less": function(e, t, n) {
			e.exports = {
				grapple: "_23XYJUJn_XitrV-LLkNyCQ",
				mIsDragging: "_1jCsYjqdUw4PYY-s3mGB47"
			}
		},
		"./src/reddit/icons/svgs/Grapple/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Grapple/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(e.className, a.a.grapple, {
					[a.a.mIsDragging]: e.isDragging
				}),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M8,2 C8.553,2 9,2.447 9,3 L9,5 C9,5.553 8.553,6 8,6 L6,6 C5.447,6 5,5.553 5,5 L5,3 C5,2.447 5.447,2 6,2 L8,2 Z M14,2 C14.553,2 15,2.447 15,3 L15,5 C15,5.553 14.553,6 14,6 L12,6 C11.447,6 11,5.553 11,5 L11,3 C11,2.447 11.447,2 12,2 L14,2 Z M8,8 C8.553,8 9,8.447 9,9 L9,11 C9,11.553 8.553,12 8,12 L6,12 C5.447,12 5,11.553 5,11 L5,9 C5,8.447 5.447,8 6,8 L8,8 Z M14,8 C14.553,8 15,8.447 15,9 L15,11 C15,11.553 14.553,12 14,12 L12,12 C11.447,12 11,11.553 11,11 L11,9 C11,8.447 11.447,8 12,8 L14,8 Z M8,14 C8.553,14 9,14.447 9,15 L9,17 C9,17.553 8.553,18 8,18 L6,18 C5.447,18 5,17.553 5,17 L5,15 C5,14.447 5.447,14 6,14 L8,14 Z M14,14 C14.553,14 15,14.447 15,15 L15,17 C15,17.553 14.553,18 14,18 L12,18 C11.447,18 11,17.553 11,17 L11,15 C11,14.447 11.447,14 12,14 L14,14 Z"
			})))
		},
		"./src/reddit/icons/svgs/ImageUpload/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_2irXdPA4C5flwkupsFkN9-"
			}
		},
		"./src/reddit/icons/svgs/ImageUpload/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/ImageUpload/index.m.less"),
				a = n.n(i);
			t.a = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("g", null, r.a.createElement("polygon", {
				fill: "inherit",
				opacity: "0",
				points: "0.610673352 20 20.625 20 20.625 0 0.610673352 0"
			}), r.a.createElement("path", {
				d: "M17.451,9.14823765 C17.03,5.40791696 13.8555,2.5 10,2.5 C6.1445,2.5 2.97,5.40791696 2.549,9.14823765 C1.0455,9.84024195 0,11.3551568 0,13.1173944 C0,15.531665 1.959,17.4892627 4.375,17.4892627 L7.8125,17.4892627 L7.8125,12.8051181 L5,12.8051181 C4.8735,12.8051181 4.7595,12.7291725 4.7115,12.6122563 C4.6625,12.49534 4.6895,12.3614359 4.779,12.272 L9.779,7.2755791 C9.901,7.15366643 10.099,7.15366643 10.221,7.2755791 L15.187,12.2375247 C15.2665,12.2944839 15.3185,12.3874173 15.3185,12.4928418 C15.3185,12.6652183 15.1785,12.8051181 15.006,12.8051181 L15,12.8051181 L12.1875,12.8051181 L12.1875,17.4892627 L15.625,17.4892627 C18.041,17.4892627 20,15.531665 20,13.1173944 C20,11.3551568 18.954,9.84024195 17.451,9.14823765",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Info/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", null, r.a.createElement("path", {
				d: "M10,8.5 C10.553,8.5 11,8.948 11,9.5 L11,13.5 C11,14.052 10.553,14.5 10,14.5 C9.447,14.5 9,14.052 9,13.5 L9,9.5 C9,8.948 9.447,8.5 10,8.5 Z M10.7002,5.79 C10.8012,5.89 10.8702,6 10.9212,6.12 C10.9712,6.24 11.0002,6.37 11.0002,6.5 C11.0002,6.57 10.9902,6.63 10.9802,6.7 C10.9712,6.76 10.9502,6.82 10.9212,6.88 C10.9002,6.94 10.8702,7 10.8302,7.05 C10.7902,7.11 10.7502,7.16 10.7002,7.21 C10.6602,7.25 10.6102,7.29 10.5512,7.33 C10.5002,7.37 10.4402,7.4 10.3812,7.42 C10.3202,7.45 10.2612,7.47 10.1902,7.48 C10.1312,7.49 10.0602,7.5 10.0002,7.5 C9.7402,7.5 9.4802,7.39 9.2902,7.21 C9.1102,7.02 9.0002,6.77 9.0002,6.5 C9.0002,6.37 9.0302,6.24 9.0802,6.12 C9.1312,5.99 9.2002,5.89 9.2902,5.79 C9.5202,5.56 9.8702,5.46 10.1902,5.52 C10.2612,5.53 10.3202,5.55 10.3812,5.58 C10.4402,5.6 10.5002,5.63 10.5512,5.67 C10.6102,5.71 10.6602,5.75 10.7002,5.79 Z M10,16 C6.691,16 4,13.309 4,10 C4,6.691 6.691,4 10,4 C13.309,4 16,6.691 16,10 C16,13.309 13.309,16 10,16 M10,2 C5.589,2 2,5.589 2,10 C2,14.411 5.589,18 10,18 C14.411,18 18,14.411 18,10 C18,5.589 14.411,2 10,2"
			})))
		},
		"./src/reddit/icons/svgs/Location/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 13 16",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "m10.4442 10.9445c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5m0-8.944c-3.554 0-6.444 2.891-6.444 6.444 0 3.32 5.143 8.658 5.73 9.256.189.192.446.3.714.3.269 0 .526-.108.714-.3.587-.598 5.73-5.936 5.73-9.256 0-3.553-2.89-6.444-6.444-6.444",
				fill: "inherit",
				fillRule: "evenodd",
				transform: "translate(-4 -2)"
			}))
		},
		"./src/reddit/icons/svgs/Lock/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 40 40",
				xmlns: "http://www.w3.org/2000/svg",
				fill: e.fill
			}, r.a.createElement("g", null, r.a.createElement("rect", {
				x: "7.5",
				y: "12.5",
				width: "0",
				height: "0"
			}), r.a.createElement("path", {
				fill: "inherit",
				d: "M32.5,17.5v-2.6c0-6.8-5.6-12.4-12.4-12.4h-0.2c-6.8,0-12.4,5.6-12.4,12.4v2.6C6.1,17.5,5,18.6,5,20v10c0,5.5,4.5,10,10,10h10c5.5,0,10-4.5,10-10V20C35,18.6,33.9,17.5,32.5,17.5z M12.5,17.5v-2.6c0-4.1,3.3-7.4,7.4-7.4h0.2c4.1,0,7.4,3.3,7.4,7.4v2.6H12.5z"
			})))
		},
		"./src/reddit/icons/svgs/ModLogPosts/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M15.5,7.75 L12.5,7.75 C12.224,7.75 12,7.526 12,7.25 C12,6.974 12.224,6.75 12.5,6.75 L15.5,6.75 C15.776,6.75 16,6.974 16,7.25 C16,7.526 15.776,7.75 15.5,7.75 Z M15.5,10.5 L12.5,10.5 C12.224,10.5 12,10.276 12,10 C12,9.724 12.224,9.5 12.5,9.5 L15.5,9.5 C15.776,9.5 16,9.724 16,10 C16,10.276 15.776,10.5 15.5,10.5 Z M15.5,13.25 L4.5,13.25 C4.224,13.25 4,13.026 4,12.75 C4,12.474 4.224,12.25 4.5,12.25 L15.5,12.25 C15.776,12.25 16,12.474 16,12.75 C16,13.026 15.776,13.25 15.5,13.25 Z M4.5,16 C4.224,16 4,15.776 4,15.5 C4,15.224 4.224,15 4.5,15 L15.5,15 C15.776,15 16,15.224 16,15.5 C16,15.776 15.776,16 15.5,16 L4.5,16 Z M4,4.5 C4,4.224 4.224,4 4.5,4 L9.813,4 C10.089,4 10.313,4.224 10.313,4.5 L10.313,10 C10.313,10.276 10.089,10.5 9.813,10.5 L4.5,10.5 C4.224,10.5 4,10.276 4,10 L4,4.5 Z M3,2 C2.447,2 2,2.447 2,3 L2,17 C2,17.553 2.447,18 3,18 L17,18 C17.553,18 18,17.553 18,17 L18,3 C18,2.447 17.553,2 17,2 L3,2 Z"
			})))
		},
		"./src/reddit/icons/svgs/Moderate/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/constants/colors.ts");
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.desc && r.a.createElement("desc", null, e.desc), r.a.createElement("path", {
				d: "M1.88,3.32V9a11.53,11.53,0,0,0,8,11L10,20l.08,0a11.53,11.53,0,0,0,8-11V3.32A11.57,11.57,0,0,1,10,0,11.57,11.57,0,0,1,1.88,3.32"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "5",
				fill: e.isUnread ? "white" : "none"
			}), r.a.createElement("circle", {
				cx: "18",
				cy: "3",
				r: "4",
				fill: e.isUnread ? o.a.orangered : "none"
			}))
		},
		"./src/reddit/icons/svgs/Negative/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 10 10"
			}, r.a.createElement("path", {
				d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M6.2103,5.78636 C6.3275,5.90356 6.3275,6.09356 6.2103,6.21076 C6.1519,6.26916 6.0751,6.29836 5.9983,6.29836 C5.9211,6.29836 5.8447,6.26916 5.7859,6.21076 L4.9983,5.42276 L4.2103,6.21076 C4.1519,6.26916 4.0751,6.29836 3.9983,6.29836 C3.9211,6.29836 3.8447,6.26916 3.7859,6.21076 C3.6687,6.09356 3.6687,5.90356 3.7859,5.78636 L4.5739,4.99836 L3.7859,4.21076 C3.6687,4.09356 3.6687,3.90356 3.7859,3.78636 C3.9031,3.66916 4.0931,3.66916 4.2103,3.78636 L4.9983,4.57436 L5.7859,3.78636 C5.9031,3.66916 6.0931,3.66916 6.2103,3.78636 C6.3275,3.90356 6.3275,4.09356 6.2103,4.21076 L5.4223,4.99836 L6.2103,5.78636 Z M7.4023,2.59436 C6.0767,1.26836 3.9195,1.26916 2.5939,2.59436 C1.2687,3.91996 1.2687,6.07716 2.5939,7.40276 C3.2567,8.06556 4.1275,8.39676 4.9983,8.39676 C5.8687,8.39676 6.7395,8.06556 7.4023,7.40276 C8.7279,6.07716 8.7279,3.91996 7.4023,2.59436 Z"
			}))
		},
		"./src/reddit/icons/svgs/Nsfw/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				viewBox: "0 0 40 40",
				version: "1.1",
				xmlns: "http://www.w3.org/2000/svg"
			}, e.title && r.a.createElement("title", null, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M38.5,16.5l-15-15c-2-2-5.1-2-7.1,0l-15,15c-2,2-2,5.1,0,7.1l15,15c2,2,5.1,2,7.1,0l15-15 C40.5,21.6,40.5,18.4,38.5,16.5z M17.7,8.3C17.7,7,18.7,6,20,6s2.3,1,2.3,2.3v14.3c0,1.3-1,2.3-2.3,2.3s-2.3-1-2.3-2.3V8.3z M20,33.7c-1.7,0-3.1-1.4-3.1-3.1c0-1.7,1.4-3.1,3.1-3.1s3.1,1.4,3.1,3.1C23.1,32.4,21.7,33.7,20,33.7z"
			})))
		},
		"./src/reddit/icons/svgs/Pencil/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("title", {
				id: `${e.title}-title`
			}, e.title), r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M15.75,7.834625 L12,4.084625 L12.808,3.276625 C13.8435,2.241125 15.5225,2.241125 16.558,3.276625 C17.5935,4.312125 17.5935,5.991125 16.558,7.026625 L15.75,7.834625 Z M11.366,5 L15.116,8.75 L7.25,16.616 L3.5,12.866 L11.366,5 Z M2.5035,13.5 L6.1125,17.109 L1,18.6125 L2.5035,13.5 Z"
			})))
		},
		"./src/reddit/icons/svgs/Plus/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				version: "1.1"
			}, r.a.createElement("g", {
				stroke: "none"
			}, r.a.createElement("g", {
				transform: "translate(-34.000000, -136.000000)",
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M45.2,147.2 L48.8,147.2 C49.46272,147.2 50,146.66272 50,146 C50,145.33728 49.46272,144.8 48.8,144.8 L45.2,144.8 L45.2,141.2 C45.2,140.53728 44.66272,140 44,140 C43.33728,140 42.8,140.53728 42.8,141.2 L42.8,144.8 L39.2,144.8 C38.53728,144.8 38,145.33728 38,146 C38,146.66272 38.53728,147.2 39.2,147.2 L42.8,147.2 L42.8,150.8 C42.8,151.46272 43.33728,152 44,152 C44.66272,152 45.2,151.46272 45.2,150.8 L45.2,147.2 Z"
			}))))
		},
		"./src/reddit/icons/svgs/Positive/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 10 10"
			}, r.a.createElement("path", {
				d: "M2,0 L8,0 C9.1045695,-2.02906125e-16 10,0.8954305 10,2 L10,8 C10,9.1045695 9.1045695,10 8,10 L2,10 C0.8954305,10 1.3527075e-16,9.1045695 0,8 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 Z M8.0828,3.27736 L7.5232,2.71736 C7.448,2.64216 7.3464,2.60016 7.2404,2.60016 C7.134,2.60016 7.0324,2.64216 6.9576,2.71736 L4.16,5.51456 L3.0428,4.39736 C2.8868,4.24096 2.6336,4.24096 2.4772,4.39736 L1.9172,4.95736 C1.7608,5.11376 1.7608,5.36696 1.9172,5.52296 L3.8772,7.48296 C3.9556,7.56096 4.0576,7.60016 4.16,7.60016 C4.2624,7.60016 4.3648,7.56096 4.4428,7.48296 L8.0828,3.84296 C8.2392,3.68656 8.2392,3.43376 8.0828,3.27736 Z"
			}))
		},
		"./src/reddit/icons/svgs/Post/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M5,15a1,1,0,0,1-1-1V11.17a1,1,0,0,1,.29-.7l8.09-8.09a1,1,0,0,1,1.41,0l2.83,2.83a1,1,0,0,1,0,1.41L8.54,14.71a1,1,0,0,1-.71.29Zm12,1a1,1,0,0,1,0,2H3a1,1,0,0,1,0-2Z"
			}))
		},
		"./src/reddit/icons/svgs/Premium/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M13.535 15.785c-1.678.244-2.883.742-3.535 1.071v-5.113a2 2 0 0 0-2-2H4.217c.044-.487.076-1.016.076-1.629 0-1.692-.489-2.968-.884-3.722L4.8 3.001H10v4.742a2 2 0 0 0 2 2h3.783c.06.67.144 1.248.22 1.742.097.632.182 1.177.182 1.745 0 1.045-.829 2.291-2.65 2.555m5.028-12.249l-2.242-2.242a1 1 0 0 0-.707-.293H4.386a1 1 0 0 0-.707.293L1.436 3.536a1 1 0 0 0-.069 1.337c.009.011.926 1.2.926 3.241 0 1.304-.145 2.24-.273 3.065-.106.684-.206 1.33-.206 2.051 0 1.939 1.499 4.119 4.364 4.534 2.086.304 3.254 1.062 3.261 1.065a1.016 1.016 0 0 0 1.117.004c.011-.007 1.18-.765 3.266-1.069 2.864-.415 4.363-2.595 4.363-4.534 0-.721-.099-1.367-.206-2.051-.128-.825-.272-1.761-.272-3.065 0-2.033.893-3.199.926-3.241a.999.999 0 0 0-.07-1.337"
			}))
		},
		"./src/reddit/icons/svgs/PremiumCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("rect", {
				width: "20",
				height: "20",
				rx: "10",
				fill: "url(#gradient)"
			}), r.a.createElement("path", {
				d: "M12.121 13.471c-1.007.146-1.73.445-2.121.643v-3.068a1.2 1.2 0 00-1.2-1.2H6.53c.027-.292.046-.61.046-.978 0-1.015-.294-1.78-.53-2.233l.834-.834H10v2.845a1.2 1.2 0 001.2 1.2h2.27c.036.402.086.749.132 1.045.058.38.109.706.109 1.047 0 .627-.497 1.375-1.59 1.533zm3.017-7.35l-1.345-1.345a.6.6 0 00-.425-.175H6.632a.6.6 0 00-.425.175L4.862 6.122a.6.6 0 00-.042.802c.006.006.556.72.556 1.944 0 .783-.087 1.344-.164 1.84-.064.41-.124.797-.124 1.23 0 1.163.9 2.471 2.619 2.72 1.251.183 1.952.638 1.956.64a.61.61 0 00.67.002c.007-.004.709-.46 1.96-.642 1.719-.249 2.618-1.557 2.618-2.72 0-.433-.06-.82-.124-1.23a11.026 11.026 0 01-.163-1.84c0-1.22.536-1.919.556-1.944a.6.6 0 00-.042-.802z",
				fill: "#fff"
			}), r.a.createElement("defs", null, r.a.createElement("linearGradient", {
				id: "gradient",
				x1: "0",
				y1: "20",
				x2: "20.021",
				y2: "19.979",
				gradientUnits: "userSpaceOnUse"
			}, r.a.createElement("stop", {
				stopColor: "#EC0623"
			}), r.a.createElement("stop", {
				offset: "1",
				stopColor: "#FF8717"
			}))))
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.m.less": function(e, t, n) {
			e.exports = {
				defaultInactiveState: "_1g3Xfh9mljLHWv24M9A3Rw",
				outline: "_3SlBAJb2MbUHwgBZFH8eL7",
				highlighted: "_1-JQy00VxG8hpTxxdxV32y"
			}
		},
		"./src/reddit/icons/svgs/PresenceCircle/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/PresenceCircle/index.m.less"),
				a = n.n(i);
			t.a = Object(s.forwardRef)((e, t) => {
				let {
					className: n,
					isHighlighted: s,
					outlineClassName: i
				} = e;
				return r.a.createElement("svg", {
					className: Object(o.a)(a.a.defaultInactiveState, n),
					viewBox: "0 0 12 12",
					xmlns: "http://www.w3.org/2000/svg",
					width: "12",
					height: "12",
					ref: t
				}, r.a.createElement("circle", {
					cx: "6",
					cy: "6",
					r: "4"
				}), r.a.createElement("path", {
					className: Object(o.a)(a.a.outline, i, {
						[a.a.highlighted]: s
					}),
					fillRule: "evenodd",
					clipRule: "evenodd",
					d: "M12 6C12 9.31371 9.31371 12 6 12C2.68629 12 0 9.31371 0 6C0 2.68629 2.68629 0 6 0C9.31371 0 12 2.68629 12 6ZM6 10C8.20914 10 10 8.20914 10 6C10 3.79086 8.20914 2 6 2C3.79086 2 2 3.79086 2 6C2 8.20914 3.79086 10 6 10Z"
				}))
			})
		},
		"./src/reddit/icons/svgs/RadioOff/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_11Rht_b1e-kmk12gkz7Lug"
			}
		},
		"./src/reddit/icons/svgs/RadioOff/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/RadioOff/index.m.less"),
				a = n.n(i);

			function d() {
				return (d = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", d({}, e, {
				className: Object(o.a)(a.a.icon, e.className),
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,1.66666667 C5.39762708,1.66666667 1.66666667,5.39762708 1.66666667,10 C1.66666667,14.6023729 5.39762708,18.3333333 10,18.3333333 C14.6023729,18.3333333 18.3333333,14.6023729 18.3333333,10 C18.3333333,5.39762708 14.6023729,1.66666667 10,1.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/RadioOn/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M10,6.66666667 C8.15905083,6.66666667 6.66666667,8.15905083 6.66666667,10 C6.66666667,11.8409492 8.15905083,13.3333333 10,13.3333333 C11.8409492,13.3333333 13.3333333,11.8409492 13.3333333,10 C13.3333333,8.15905083 11.8409492,6.66666667 10,6.66666667 Z M10,0 C15.5228475,-1.01453063e-15 20,4.4771525 20,10 C20,15.5228475 15.5228475,20 10,20 C4.4771525,20 6.76353751e-16,15.5228475 0,10 C-6.76353751e-16,4.4771525 4.4771525,1.01453063e-15 10,0 Z"
			})))
		},
		"./src/reddit/icons/svgs/Redditor/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({
				viewBox: "0 0 250 250",
				xmlns: "http://www.w3.org/2000/svg"
			}, e), r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M146.8 142.6h-37.6c-31.1 0-56.5 25.3-56.5 56.5 0 5.2 4.2 9.4 9.4 9.4h131.8c5.2 0 9.4-4.2 9.4-9.4 0-31.2-25.3-56.5-56.5-56.5zM128 130.7c20.1 0 36.4-16.3 36.4-36.4v-9.4c0-20.1-16.3-36.4-36.4-36.4S91.6 64.8 91.6 84.9v9.4c0 20.1 16.3 36.4 36.4 36.4z"
			})))
		},
		"./src/reddit/icons/svgs/Remove/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				tabIndex: e.tabIndex,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick,
				onMouseEnter: e.onMouseEnter,
				onMouseLeave: e.onMouseLeave
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fillRule: "evenodd",
				d: "M13.5559061,14.5 C13.5559061,14.776 13.3283409,15 13.0479481,15 C12.7675552,15 12.53999,14.776 12.53999,14.5 L12.53999,9 C12.53999,8.724 12.7675552,8.5 13.0479481,8.5 C13.3283409,8.5 13.5559061,8.724 13.5559061,9 L13.5559061,14.5 Z M10.508158,14.5 C10.508158,14.776 10.2805928,15 10.0002,15 C9.71980718,15 9.49224199,14.776 9.49224199,14.5 L9.49224199,9 C9.49224199,8.724 9.71980718,8.5 10.0002,8.5 C10.2805928,8.5 10.508158,8.724 10.508158,9 L10.508158,14.5 Z M7.46040996,14.5 C7.46040996,14.776 7.23284477,15 6.95245195,15 C6.67205913,15 6.44449394,14.776 6.44449394,14.5 L6.44449394,9 C6.44449394,8.724 6.67205913,8.5 6.95245195,8.5 C7.23284477,8.5 7.46040996,8.724 7.46040996,9 L7.46040996,14.5 Z M15.492242,6 C15.7736507,6 16.0002,6.224 16.0002,6.5 L16.0002,16.5 C16.0002,17.327 15.3164885,18 14.476326,18 L5.52407403,18 C4.68391148,18 4.0002,17.327 4.0002,16.5 L4.0002,6.5 C4.0002,6.224 4.22674927,6 4.50815801,6 L15.492242,6 Z M15.491585,3 C15.7719541,3 15.9995,3.224 15.9995,3.5 L15.9995,4.5 C15.9995,4.776 15.7719541,5 15.491585,5 L4.50741501,5 C4.22704592,5 3.9995,4.776 3.9995,4.5 L3.9995,3.5 C3.9995,3.224 4.22704592,3 4.50741501,3 L7.51325603,3 L8.26598607,2.167 C8.36248993,2.061 8.50064281,2 8.6459065,2 L11.3541093,2 C11.4983572,2 11.6365101,2.061 11.7340298,2.167 L12.485744,3 L15.491585,3 Z"
			})))
		},
		"./src/reddit/icons/svgs/Replay/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);

			function o() {
				return (o = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = e => r.a.createElement("svg", o({}, e, {
				viewBox: "13 12 23 23",
				xmlns: "http://www.w3.org/2000/svg"
			}), r.a.createElement("g", null, r.a.createElement("path", {
				d: "M32.5 23.3c-.7 0-1.2.5-1.2 1.2 0 4-3.2 7.2-7.2 7.2s-7.2-3.2-7.2-7.2c0-3.6 2.7-6.6 6.2-7.1v1.7c0 .2.1.4.3.5.1 0 .2.1.3.1.1 0 .3 0 .4-.1l3.6-3c.1-.1.2-.3.2-.5s-.1-.3-.2-.5l-3.7-3c-.2-.1-.4-.2-.6-.1-.2.1-.4.3-.4.6V15c-4.8.5-8.6 4.6-8.6 9.5 0 5.3 4.3 9.6 9.6 9.6s9.6-4.3 9.6-9.6c.1-.7-.5-1.2-1.1-1.2",
				fill: "inherit"
			})))
		},
		"./src/reddit/icons/svgs/Search/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				d: "M15.59,13.91l2.78,2.69a1.25,1.25,0,1,1-1.74,1.8l-2.82-2.73a8,8,0,1,1,1.78-1.76ZM14.64,9.2A5.45,5.45,0,1,0,9.2,14.64,5.45,5.45,0,0,0,14.64,9.2Z"
			}))
		},
		"./src/reddit/icons/svgs/Settings/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				id: e.id,
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "M7.03093403,10 C7.03093403,8.36301971 8.36301971,7.03093403 10,7.03093403 C11.6369803,7.03093403 12.9679409,8.36301971 12.9679409,10 C12.9679409,11.6369803 11.6369803,12.969066 10,12.969066 C8.36301971,12.969066 7.03093403,11.6369803 7.03093403,10 M16.4016617,8.49127796 C16.2362761,7.79148295 15.9606334,7.13669084 15.5916096,6.5437777 L16.5231696,5.06768276 C16.7526843,4.70315931 16.7684353,4.22387849 16.5231696,3.83572852 C16.1833977,3.29794393 15.4712269,3.13593351 14.9323172,3.47683044 L13.4562223,4.40839036 C12.8633092,4.03936662 12.208517,3.76259882 11.508722,3.59833825 L11.1250724,1.89947899 C11.0294412,1.47982699 10.7020452,1.12992949 10.2542664,1.02867298 C9.63322641,0.888038932 9.01556168,1.27843904 8.87492764,1.89947899 L8.49127796,3.59833825 C7.79148295,3.76259882 7.13669084,4.03936662 6.54265263,4.40726528 L5.06768276,3.47683044 C4.70315931,3.24731568 4.22387849,3.23156466 3.83572852,3.47683044 C3.29794393,3.81660229 3.13593351,4.5287731 3.47683044,5.06768276 L4.40726528,6.54265263 C4.03936662,7.13669084 3.76259882,7.79148295 3.59721318,8.49127796 L1.89947899,8.87492764 C1.47982699,8.97055879 1.12992949,9.29795485 1.02867298,9.74573365 C0.888038932,10.3667736 1.27843904,10.9844383 1.89947899,11.1250724 L3.59721318,11.508722 C3.76259882,12.208517 4.03936662,12.8633092 4.40726528,13.4573474 L3.47683044,14.9323172 C3.24731568,15.2968407 3.23156466,15.7761215 3.47683044,16.1642715 C3.81660229,16.7020561 4.5287731,16.8640665 5.06768276,16.5231696 L6.54265263,15.5927347 C7.13669084,15.9606334 7.79148295,16.2374012 8.49127796,16.4016617 L8.87492764,18.100521 C8.97055879,18.520173 9.29795485,18.8700705 9.74573365,18.971327 C10.3667736,19.1119611 10.9844383,18.721561 11.1250724,18.100521 L11.508722,16.4016617 C12.208517,16.2374012 12.8633092,15.9606334 13.4562223,15.5916096 L14.9323172,16.5231696 C15.2968407,16.7526843 15.7749964,16.7684353 16.1631464,16.5231696 C16.7020561,16.1833977 16.8629414,15.4712269 16.5231696,14.9323172 L15.5916096,13.4562223 C15.9606334,12.8633092 16.2362761,12.208517 16.4016617,11.508722 L18.100521,11.1250724 C18.520173,11.0294412 18.8700705,10.7020452 18.971327,10.2542664 C19.1119611,9.63322641 18.721561,9.01556168 18.100521,8.87492764 L16.4016617,8.49127796 Z"
			})))
		},
		"./src/reddit/icons/svgs/Shirt/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = function(e) {
				let {
					className: t
				} = e;
				return r.a.createElement("svg", {
					className: t,
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 20 20"
				}, r.a.createElement("g", {
					fill: "inherit"
				}, r.a.createElement("path", {
					d: "M7 1.75a.486.486 0 01.487.4 2.574 2.574 0 005.085 0 .488.488 0 01.488-.4h1.583A.5.5 0 0115 1.9l3.951 4.09a.5.5 0 01-.006.7l-1.931 1.938a.5.5 0 01-.649.05l-1.482-1.084.007 10.156a.5.5 0 01-.5.5H5.385a.5.5 0 01-.5-.5l.007-10.156L3.7 8.626a.5.5 0 01-.677-.026L1.115 6.694a.5.5 0 01-.006-.7L5.06 1.9a.5.5 0 01.359-.153z"
				})))
			}
		},
		"./src/reddit/icons/svgs/Show/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M17.71,10.29,14.95,7.54a7,7,0,0,0-9.9,0L2.29,10.29a1,1,0,0,0,1.41,1.41L6.46,8.95c.07-.07.14-.11.21-.17a4,4,0,1,0,6.65,0c.07.06.15.11.21.17l2.76,2.76a1,1,0,0,0,1.41-1.41Z"
			}))
		},
		"./src/reddit/icons/svgs/SnooHappy/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 24 25",
				xmlns: "http://www.w3.org/2000/svg"
			}, r.a.createElement("path", {
				fill: "#000",
				d: "M19.7 9.4c-.6.2-1.1 0-1.6-.3-1.3-.8-2.6-1.4-4.2-1.5-1.2-.1-1.8-.1-2.3 0-1.1.2-2.2.4-3.2.7-.6.2-1.1.6-1.7.8-.2.1-.5.2-.7.2-2.3-.6-4.1.2-5.4 2.2-1.1 1.7-.4 4.4.9 5.3.2.2.5.5.5.8.1 2.1 1.2 3.6 2.7 4.8.1.1.2.1.3.2.6.4 1.9 1.2 3 1.5 1.5.5 3 .7 4.5.7 1.5-.1 3-.1 4.4-.6.4-.2 2.3-1.1 3.4-2.2 1.2-1.5 2.3-3 2.5-4.9.1-1 .4-1.8.9-2.7.2-.3.2-.6.3-.9.4-2.5-2-5-4.3-4.1z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M20.9 10c-.4-.1-.8 0-1.4 0 1 1.1 1.8 2.1 2.2 3.4-2.2-3.2-5.3-5.1-9.1-5.1s-7 1.6-9.2 4.9c-.1-.3-.3-.6-.2-.7.5-1 1.2-1.9 2.3-2.5-1.7-.5-3.5.4-4.4 2.2-.7 1.4-.3 3.3.9 4.1l.3-1.2c.1-.4.4-.7.6-1 .1.2.1.3 0 .4-.5 1.5-.3 3 .2 4.5.5 1 1.1 2 2.1 2.8 3.9 2.9 9.4 3.6 13.8.5 1.9-1.3 2.9-3.3 3.1-5.7.1-.6.1-1.2.1-1.8.1 0 .1.1.2.1.2-.2.6-.3.7-.5.7-1.7-.4-3.9-2.2-4.4z"
			}), r.a.createElement("path", {
				fill: "#000",
				d: "M10.1 15.4s-.3-.1-.4-.2l-.6-.6c-.8-.5-1.6-.3-2.2.5-.2.3-.3.5-.5.8-.1.1-.3.2-.5.3-.1-.2-.2-.4-.2-.6.1-.4.3-.7.3-.9 1.1-1.7 3.3-1.8 4.1-.3.1.2.2.3.2.5s-.1.4-.2.5zm3.1 6.5c-2.3 0-4-1.6-4.4-3.4 0-.1.3-.4.6-.5 2-.8 5-1.1 7.2-.4.2.1.5.2.5.3 0 .1-.3.2-.3.3-.4 1.7-1.5 3.7-3.6 3.7zm5.9-6.5c-.1 0-.3-.1-.4-.2-.1 0-.1-.1-.1-.2-.6-.9-1.4-1-2.2-.3-.2.2-.5.2-.7.4.1-.3 0-.7.2-.9.7-.9 1.8-1.1 2.7-.5.2.2.6.9.8 1.4-.1.1-.2.3-.3.3zM16.6.5c-.5-.4-1.4-.7-2.3-.2-.4.2-.7.5-.8.7-.2.7-.2 1.1-.1 1.5-1 1-2.2 1.6-3.6 1.7-.2 0-.4.2-.4.4-.1.5.1.9.4 1.4.5.7.7 1.2.9 1.9V8c.1.2.2.2.4.2.1 0 .2-.1.3-.1.1-.1.1-.2.1-.3v-.2c0-.1-.1-.3-.1-.4-.1-.3-.2-.6-.3-.8-.1-.2-.2-.3-.3-.4-.1-.3-.3-.8-.3-1.1.5-.1 1.1-.2 1.6-.5.4-.2.7-.5 1-.8.2-.2.3-.3.5-.4.4.5.8.7 1.6.8h.2c.4 0 .9-.2 1.3-.5s.6-.8.6-1.4c.1-.6-.2-1.2-.7-1.6z"
			}), r.a.createElement("path", {
				fill: "#FFF",
				d: "M14 1.9c-.1-.6.4-1.1 1.1-1.2.8-.1 1.4.3 1.5 1 .1.7-.5 1.5-1.1 1.6-.7.1-1.4-.6-1.5-1.4z"
			}))
		},
		"./src/reddit/icons/svgs/SnooSilhouette/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 320 320",
				xmlns: "http://www.w3.org/2000/svg",
				style: e.style
			}, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("path", {
				d: "m124.91 237.79c-53.47 32.9-28.3 109.77-9.81 76.9"
			}), r.a.createElement("path", {
				d: "m115.13 314.7a9.86 9.86 0 0 1 -1.44 3l-.85 1.22c-.34.4-.68.85-1.09 1.28a11.46 11.46 0 0 1 -3 2.34 7.26 7.26 0 0 1 -4.16.82 8.13 8.13 0 0 1 -3.86-1.63 14 14 0 0 1 -2.64-2.62 26.58 26.58 0 0 1 -1.7-2.45c-3.11-5.09-4.59-11.37-5.16-17.65a66.18 66.18 0 0 1 6.12-33.55 69 69 0 0 1 3.7-6.66 68.22 68.22 0 0 1 4.3-5.93 62.51 62.51 0 0 1 9.65-9.4 61.54 61.54 0 0 1 9.62-6.13c-2.15 2.3-5.35 5.36-8.11 8.41s-5.19 6-6.61 7.42a56.91 56.91 0 0 0 -7.33 9.28 58.25 58.25 0 0 0 -5 10 60.67 60.67 0 0 0 -4 20 53 53 0 0 0 2.33 17.65 28.76 28.76 0 0 0 3.32 7.14c1.39 2 3.15 3.76 5.17 4.28a5.79 5.79 0 0 0 3.36-.19 11.09 11.09 0 0 0 3.45-2.14 29.87 29.87 0 0 0 3.93-4.49z"
			}), r.a.createElement("path", {
				d: "m194.69 240.89c45.74 25.85 23.37 107.54 4.1 73.8"
			}), r.a.createElement("path", {
				d: "m198.81 314.67a17 17 0 0 1 2 2.41 16.1 16.1 0 0 0 4.54 4.16 6.1 6.1 0 0 0 3.23.79 5.88 5.88 0 0 0 3-1.15 12.67 12.67 0 0 0 3.58-4.37c2.39-4.65 3.64-10.3 4.24-16a71.58 71.58 0 0 0 -.3-17 66.16 66.16 0 0 0 -9-25.89 54.68 54.68 0 0 0 -15.7-16.28 30.16 30.16 0 0 1 10.19 5 29.29 29.29 0 0 1 7.11 7.13 68.35 68.35 0 0 1 8.62 21.25 81.56 81.56 0 0 1 2 19.91 58.88 58.88 0 0 1 -2.83 17.4 27.36 27.36 0 0 1 -3.67 7.28 13.8 13.8 0 0 1 -2.85 2.86 7.81 7.81 0 0 1 -3.8 1.51 6.82 6.82 0 0 1 -4.21-1 11.92 11.92 0 0 1 -3.25-3 24.69 24.69 0 0 1 -2.9-5.01z"
			}), r.a.createElement("path", {
				d: "m125.46 236.86c32.07-45.32 77.78-13.73 79.92 56.7-.5 46.56-23 35.27-51.14 35.27s-42.05 9.17-44.66-24.83c-1.5-19.46-.66-20.87 3.28-33"
			}), r.a.createElement("path", {
				d: "m112.89 271a23.38 23.38 0 0 1 -.68 2.76c-.41 1.47-1 3.44-1.61 5.81a38.08 38.08 0 0 0 -1.14 8.22c-.12 3.08.07 6.43.29 9.9.51 6.92 1 14.41 3.16 20.71a16.43 16.43 0 0 0 4.9 7.54 13.56 13.56 0 0 0 6.7 2.65 56.37 56.37 0 0 0 11.6-.1c4-.32 8-.71 12.18-.92a124.9 124.9 0 0 1 12.55-.09c4.2.16 8.4.49 12.56.7 2.08.1 4.15.18 6.2.15a40.17 40.17 0 0 0 6.05-.44 22.51 22.51 0 0 0 5.6-1.55 14.89 14.89 0 0 0 4.6-3.17 17.38 17.38 0 0 0 3.27-4.6l.33-.64.29-.67.56-1.34c.3-.93.65-1.84.9-2.79a62.06 62.06 0 0 0 1.9-11.66 108.3 108.3 0 0 0 -.63-20.6 130.55 130.55 0 0 0 -3.86-20 94.18 94.18 0 0 0 -7.15-18.4 59.18 59.18 0 0 0 -11-15.23c-4.38-4.24-9.48-7.58-15-9a27.57 27.57 0 0 0 -16.33.49 39.21 39.21 0 0 0 -13.41 7.9 74.8 74.8 0 0 0 -9.76 10.58 61.55 61.55 0 0 1 8.78-11.74 39.25 39.25 0 0 1 14.45-9.6 31.64 31.64 0 0 1 8.59-1.83h2.12a13 13 0 0 1 2.08.09 28.29 28.29 0 0 1 3.93.63 31.93 31.93 0 0 1 11.28 5.06 50.46 50.46 0 0 1 12 12.46 74.93 74.93 0 0 1 7.89 14.59 117.86 117.86 0 0 1 7.81 30.35c.15 1.25.31 2.5.46 3.75s.22 2.49.32 3.73c.26 2.48.3 5 .43 7.41a34.56 34.56 0 0 1 0 3.67c0 1.22-.07 2.44-.16 3.64s-.14 2.41-.28 3.6-.23 2.38-.43 3.56-.34 2.36-.6 3.52-.51 2.32-.82 3.46a16.49 16.49 0 0 1 -.52 1.69c-.19.56-.36 1.12-.57 1.68a32.08 32.08 0 0 1 -1.48 3.21 19.92 19.92 0 0 1 -4.28 5.58 18.29 18.29 0 0 1 -6 3.5 37.52 37.52 0 0 1 -13.18 1.66c-4.33-.07-8.53-.42-12.65-.67s-8.17-.43-12.14-.36-7.88.29-11.73.58-7.66.61-11.47.63a34.51 34.51 0 0 1 -5.73-.4 17.16 17.16 0 0 1 -5.52-1.82 13.8 13.8 0 0 1 -4.34-3.84 19.11 19.11 0 0 1 -2.64-4.9 44.16 44.16 0 0 1 -2.39-10.24c-.44-3.22-.63-7-.81-11a93.65 93.65 0 0 1 .09-12 37.54 37.54 0 0 1 .92-5.5c.42-1.71.94-3.25 1.4-4.62.96-2.66 1.74-4.74 2.12-5.74z"
			}), r.a.createElement("path", {
				d: "m229 74.81c-1 .47-5.78-2.28-11.24-5.44s-11.7-6.6-15.42-7.94c-3.26-1.22-6.62-2.41-10-3.36a43 43 0 0 0 -4.93-1.07 13.89 13.89 0 0 0 -4.19-.08 3.6 3.6 0 0 0 -1.2.4c-.13.08-.17.17-.27.22s-.12.11-.14.24l-1 1.75c-.42.78-.91 1.53-1.29 2.34-.8 1.58-1.62 3.14-2.3 4.75s-1.34 3.2-2 4.78c-4.19 11.17-6.17 23.06-7.52 34.18s-2.05 21.46-3.05 29.85a36 36 0 0 1 -3.83-6.41 58 58 0 0 1 -2.89-7.72c-1.5-5.24-2.06-10.33-1.53-13a266.73 266.73 0 0 1 7.37-29.3 114.2 114.2 0 0 1 10.81-24.11l.39-.67.2-.33.09-.17.16-.2a8.58 8.58 0 0 1 1.33-1.56l.78-.69.86-.53a9.4 9.4 0 0 1 1.8-.83 15.64 15.64 0 0 1 6.86-.52 44.74 44.74 0 0 1 11.26 3.14 87 87 0 0 1 17.63 9.78c4.93 3.27 11.92 10.94 13.26 12.5z"
			}), r.a.createElement("path", {
				d: "m105.63 128c-43.28-20.15-74.18 36.54-30.75 61.74"
			}), r.a.createElement("path", {
				d: "m74.86 189.75c-.5 0-4.4-2-8.31-5.22-.94-.85-2-1.65-2.88-2.59s-1.82-1.86-2.61-2.82-1.51-1.9-2.15-2.77-1.13-1.7-1.57-2.38a32.77 32.77 0 0 1 -5-17.32 36.58 36.58 0 0 1 1.3-9.37c.22-.76.5-1.49.74-2.24l.39-1.1.47-1.07c.33-.7.62-1.42 1-2.11s.76-1.33 1.13-2a34 34 0 0 1 24.86-16.35 36.14 36.14 0 0 1 13.32.9 42.71 42.71 0 0 1 10.39 4.17c-3.08-.41-7.27-1.42-11.25-1.59a81.76 81.76 0 0 0 -9.48-.06 29.42 29.42 0 0 0 -11 2.08 30.48 30.48 0 0 0 -9.21 5.75 31.36 31.36 0 0 0 -8.27 34 38.69 38.69 0 0 0 7.82 12.76 66.35 66.35 0 0 0 5.7 5.64 36 36 0 0 0 2.84 2.34z"
			}), r.a.createElement("path", {
				d: "m254.61 176.52c30.45-26.89-2.76-71.55-39.71-54.67"
			}), r.a.createElement("path", {
				d: "m214.89 121.83a9.6 9.6 0 0 1 2.48-1.41 20.3 20.3 0 0 1 2.51-1l1.47-.51c.5-.18 1.05-.27 1.59-.42a28.32 28.32 0 0 1 3.37-.69 28.71 28.71 0 0 1 3.38-.39 46.61 46.61 0 0 1 5.63 0 34.21 34.21 0 0 1 15.32 4.6l1.79 1.09c.59.37 1.13.81 1.7 1.22a35.6 35.6 0 0 1 8.53 8.92 32.62 32.62 0 0 1 5.34 12.84 30.43 30.43 0 0 1 -.56 13.24 31.13 31.13 0 0 1 -5.33 10.68 36.88 36.88 0 0 1 -7.12 7c1.37-2.44 3.58-5.54 5.05-8.73.43-.76.7-1.59 1-2.31.16-.38.35-.73.49-1.09l.38-1c.24-.68.53-1.28.72-1.84a13.79 13.79 0 0 1 .52-1.42 26.43 26.43 0 0 0 .49-19 31.61 31.61 0 0 0 -4.13-8 35.33 35.33 0 0 0 -5.79-6.19c-.52-.45-1.08-.83-1.62-1.24a15 15 0 0 0 -1.64-1.14l-1.68-1-1.72-.88-.85-.44c-.28-.13-.58-.24-.87-.36l-1.73-.71c-.58-.21-1.17-.37-1.74-.56a17.9 17.9 0 0 0 -1.73-.5 40.08 40.08 0 0 0 -13.23-.93c-.49.06-1 .1-1.6.14l-1.76.27c-.6.09-1.23.15-1.84.26l-1.81.39c-.59.13-1.17.22-1.7.37l-1.46.41z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z"
			}), r.a.createElement("path", {
				d: "m159.25 111.23c-48.61-.37-93.95 27.23-96.18 72.22-1.87 83.41 194.24 83.41 192.37 0 0-48.33-44.72-72.22-96.19-72.22z",
				fill: "none"
			}), r.a.createElement("path", {
				d: "m159.25 111.2a100.82 100.82 0 0 1 14.86.32 130.39 130.39 0 0 1 30.18 6.06 97.07 97.07 0 0 1 16.43 7.17 78.93 78.93 0 0 1 14.49 10.25 63.78 63.78 0 0 1 16.79 23.82 67.61 67.61 0 0 1 4.45 19.57c.13 1.7.15 3.4.22 5.11v3.89l-.11 1.3-.22 2.61-.42 2.6a23.2 23.2 0 0 1 -.54 2.58c-.22.85-.37 1.72-.67 2.56a49.79 49.79 0 0 1 -4.15 9.79 56.7 56.7 0 0 1 -6.2 8.74 68 68 0 0 1 -7.75 7.43 78.42 78.42 0 0 1 -8.81 6.14c-12.32 7.38-26.19 11.74-40.07 14.24a168.29 168.29 0 0 1 -41.54 2.05 148 148 0 0 1 -34.89-6.69c-11.22-3.67-22-9-31-16.58a56.52 56.52 0 0 1 -11.6-13.16 48.93 48.93 0 0 1 -6.51-16.08 50.29 50.29 0 0 1 -.46-17 66.24 66.24 0 0 1 4.18-16 70.76 70.76 0 0 1 18.09-25.69 90.75 90.75 0 0 1 24.8-15.93 101.47 101.47 0 0 1 13.06-4.78 112.2 112.2 0 0 1 12.93-3c2.12-.41 4.24-.65 6.32-1s4.15-.47 6.2-.57c4.08-.33 8.06-.33 11.91-.29a142.44 142.44 0 0 0 -24.22 3.34 117.79 117.79 0 0 0 -26.52 9.42 92.75 92.75 0 0 0 -21.58 14.9 77.13 77.13 0 0 0 -12.25 14.6 62.07 62.07 0 0 0 -9.53 25.39 45.71 45.71 0 0 0 3.46 25.86 53.67 53.67 0 0 0 16.28 19.83 87.52 87.52 0 0 0 22.14 12.14 129.68 129.68 0 0 0 23.75 6.56 160.17 160.17 0 0 0 23.78 2.47 157.94 157.94 0 0 0 45.17-5.1 113.68 113.68 0 0 0 20.3-7.54 86.22 86.22 0 0 0 9.16-5.19 73.68 73.68 0 0 0 8.22-6.24 52.36 52.36 0 0 0 12.26-15.71l.56-1.09.48-1.13c.3-.76.64-1.5.92-2.26a44.84 44.84 0 0 0 1.41-4.63 46.94 46.94 0 0 0 1.37-9.46c0-1.59.08-3.16 0-4.75s-.07-3.17-.26-4.72l-.21-2.34c-.09-.77-.23-1.54-.34-2.3s-.22-1.54-.37-2.3l-.49-2.25a58.73 58.73 0 0 0 -6.56-16.8 63.59 63.59 0 0 0 -10.77-13.72 74.79 74.79 0 0 0 -13.46-10.24 100.84 100.84 0 0 0 -16.3-7.81 122.86 122.86 0 0 0 -19-5.41 160 160 0 0 0 -27.37-2.98z"
			}), r.a.createElement("circle", {
				cx: "238.47",
				cy: "80.13",
				r: "22.93"
			}), r.a.createElement("path", {
				d: "m261.37 80.13a5.12 5.12 0 0 1 -.27-1.29c-.06-.34-.08-.75-.17-1.2s-.19-1-.3-1.5a23.88 23.88 0 0 0 -3.12-7.61 22.56 22.56 0 0 0 -6.59-6.71 20 20 0 0 0 -7.06-2.93 22.12 22.12 0 0 0 -19.67 5.49 21.36 21.36 0 0 0 -5.7 9 20.88 20.88 0 0 0 -.7 10.29 21.16 21.16 0 0 0 9.47 14.18 21.55 21.55 0 0 0 16.06 2.92 21.77 21.77 0 0 0 12.8-8.08 23.8 23.8 0 0 0 3.39-6.16 26 26 0 0 0 1.32-6.35 19.06 19.06 0 0 1 .12 6.81 21.83 21.83 0 0 1 -8.21 13.51 18.67 18.67 0 0 1 -5.13 2.82 24.34 24.34 0 0 1 -8.2 1.31 24.84 24.84 0 0 1 -7.83-1.26 25.86 25.86 0 0 1 -6.77-3.5 25 25 0 0 1 -5.2-5.16 23.4 23.4 0 0 1 -3.35-6.21 25 25 0 0 1 -1-3.32c-.13-.56-.18-1.12-.28-1.68l-.12-.84c0-.28 0-.56-.05-.84 0-.56 0-1.12-.07-1.68s.05-1.11.08-1.66a11.26 11.26 0 0 1 .17-1.64c.09-.54.15-1.09.26-1.62a25.58 25.58 0 0 1 2.15-6 24.56 24.56 0 0 1 5.71-7.24c.37-.34.79-.62 1.18-.93a11.19 11.19 0 0 1 1.21-.87 23.57 23.57 0 0 1 21.4-2.45 23 23 0 0 1 8.39 5.48 22 22 0 0 1 6.08 14.14c.11 1.26 0 2.29 0 2.78z"
			})))
		},
		"./src/reddit/icons/svgs/Tag/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				style: e.style,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", null, r.a.createElement("path", {
				fill: "inherit",
				d: "M5.14293863,3.38188919 C5.75317178,3.99212234 5.75317178,4.98136473 5.14293863,5.59159788 C4.53270548,6.20183104 3.54346309,6.20183104 2.93322994,5.59159788 C2.32299679,4.98136473 2.32299679,3.99212234 2.93322994,3.38188919 C3.54346309,2.77165604 4.53270548,2.77165604 5.14293863,3.38188919 Z M1.01449569,2.94595786 L1,9.03662212 C1.00035355,9.55457784 1.19162594,10.0654625 1.55790725,10.4317438 L9.89929239,18.7731289 C10.6622606,19.5360972 11.8989904,19.5360972 12.661605,18.7734825 L18.7381272,12.6969604 C19.5007418,11.9343457 19.5007418,10.697616 18.7377736,9.93464773 L10.3963885,1.59326259 C10.0301071,1.22698128 9.54786032,1.00707107 9.02955105,1.00707107 L2.96045355,1 C1.8814086,1 1.01414214,1.86726647 1.01449569,2.94595786 Z"
			})))
		},
		"./src/reddit/icons/svgs/Trash/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 40 40"
			}, r.a.createElement("g", null, r.a.createElement("g", {
				fill: "inherit"
			}, r.a.createElement("polygon", {
				points: "10,38.8 30,38.8 31.2,10.9 8.7,10.9"
			}), r.a.createElement("path", {
				d: "M27.5,3.8H25c0-1.4-1.1-2.5-2.5-2.5h-5c-1.4,0-2.5,1.1-2.5,2.5h-2.5c-2.8,0-5,2.2-5,5h25C32.5,6,30.3,3.8,27.5,3.8z"
			}))))
		},
		"./src/reddit/icons/svgs/Trash2/index.m.less": function(e, t, n) {
			e.exports = {
				icon: "_1Fa4RPHlhrfUZuNaXK2-eP"
			}
		},
		"./src/reddit/icons/svgs/Trash2/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			}));
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/lib/classNames/index.ts"),
				i = n("./src/reddit/icons/svgs/Trash2/index.m.less"),
				a = n.n(i);
			const d = e => r.a.createElement("svg", {
				className: Object(o.a)(a.a.icon, e.className),
				viewBox: "0 0 20 20",
				xmlns: "http://www.w3.org/2000/svg",
				onClick: e.onClick
			}, r.a.createElement("path", {
				d: "M16.5,2H12.71l-.85-.85A.5.5,0,0,0,11.5,1h-3a.5.5,0,0,0-.35.15L7.29,2H3.5a.5.5,0,0,0-.5.5v1a.5.5,0,0,0,.5.5h13a.5.5,0,0,0,.5-.5v-1A.5.5,0,0,0,16.5,2Z"
			}), r.a.createElement("path", {
				d: "M16.5,5H3.5a.5.5,0,0,0-.5.5v12A1.5,1.5,0,0,0,4.5,19h11A1.5,1.5,0,0,0,17,17.5V5.5A.5.5,0,0,0,16.5,5ZM6.75,15.5a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Zm4,0a.75.75,0,0,1-1.5,0v-7a.75.75,0,0,1,1.5,0Z"
			}));
			t.b = d
		},
		"./src/reddit/icons/svgs/User/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				xmlns: "http://www.w3.org/2000/svg",
				viewBox: "0 0 20 20"
			}, r.a.createElement("path", {
				d: "M12,11 C15.309,11 18,13.691 18,17 C18,17.553 17.552,18 17,18 L3,18 C2.448,18 2,17.553 2,17 C2,13.691 4.691,11 8,11 L12,11 Z M10,9.7334 C7.868,9.7334 6.133,7.9994 6.133,5.8664 L6.133,4.8664 C6.133,2.7344 7.868,1.0004 10,1.0004 C12.132,1.0004 13.867,2.7344 13.867,4.8664 L13.867,5.8664 C13.867,7.9994 12.132,9.7334 10,9.7334 Z"
			}))
		},
		"./src/reddit/icons/svgs/Wiki/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s);
			t.a = e => r.a.createElement("svg", {
				className: e.className,
				viewBox: "0 0 20 20"
			}, r.a.createElement("g", {
				fill: "inherit",
				fillRule: "evenodd"
			}, r.a.createElement("path", {
				d: "M13.8711,6 L5.8711,6 C5.5951,6 5.3711,5.776 5.3711,5.5 C5.3711,5.224 5.5951,5 5.8711,5 L13.8711,5 C14.1471,5 14.3711,5.224 14.3711,5.5 C14.3711,5.776 14.1471,6 13.8711,6 M13.8711,9 L5.8711,9 C5.5951,9 5.3711,8.776 5.3711,8.5 C5.3711,8.224 5.5951,8 5.8711,8 L13.8711,8 C14.1471,8 14.3711,8.224 14.3711,8.5 C14.3711,8.776 14.1471,9 13.8711,9 M13.8711,12 L5.8711,12 C5.5951,12 5.3711,11.776 5.3711,11.5 C5.3711,11.224 5.5951,11 5.8711,11 L13.8711,11 C14.1471,11 14.3711,11.224 14.3711,11.5 C14.3711,11.776 14.1471,12 13.8711,12 M13.8711,15 L5.8711,15 C5.5951,15 5.3711,14.776 5.3711,14.5 C5.3711,14.224 5.5951,14 5.8711,14 L13.8711,14 C14.1471,14 14.3711,14.224 14.3711,14.5 C14.3711,14.776 14.1471,15 13.8711,15 M16.0001,2 L4.0001,2 C3.4471,2 3.0001,2.448 3.0001,3 L3.0001,17 C3.0001,17.552 3.4471,18 4.0001,18 L16.0001,18 C16.5531,18 17.0001,17.552 17.0001,17 L17.0001,3 C17.0001,2.448 16.5531,2 16.0001,2"
			})))
		},
		"./src/reddit/layout/row/Inline/index.m.less": function(e, t, n) {
			e.exports = {
				inlineRow: "XZK-LTFT5CgGo9MvPQQsy"
			}
		},
		"./src/reddit/layout/row/Inline/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/Inline/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("inlineRow", o.a)
		},
		"./src/reddit/layout/row/InlineButton/index.m.less": function(e, t, n) {
			e.exports = {
				inlineButton: "_10K5i7NW6qcm-UoCtpB3aK"
			}
		},
		"./src/reddit/layout/row/InlineButton/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/InlineButton/index.m.less"),
				o = n.n(r);
			t.a = s.a.button("inlineButton", o.a)
		},
		"./src/reddit/layout/row/RightAlign/index.m.less": function(e, t, n) {
			e.exports = {
				rightAligned: "_1sEFSGIUpFtX1hzGDyWJpr"
			}
		},
		"./src/reddit/layout/row/RightAlign/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./src/lib/lessComponent.tsx"),
				r = n("./src/reddit/layout/row/RightAlign/index.m.less"),
				o = n.n(r);
			t.a = s.a.div("rightAligned", o.a)
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_5gAwSCo7K8G413IoE78Ml",
				right: "_2ghjBMFIsORwdO3oh2Kq6g",
				exapndLeftContainer: "_1zTJo0Ndih4fp__5DjbClN"
			}
		},
		"./src/reddit/layout/twoCol/ExpandLeft/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandLeft/index.m.less"),
				d = n.n(a);
			t.a = Object(o.a)(e => r.a.createElement("div", {
				className: Object(i.a)(d.a.exapndLeftContainer, e.className)
			}, r.a.createElement("div", {
				className: d.a.left
			}, Array.isArray(e.children) && e.children[0]), r.a.createElement("div", {
				className: d.a.right,
				style: {
					flexBasis: e.widthRight
				}
			}, Array.isArray(e.children) && e.children[1])), 2)
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.m.less": function(e, t, n) {
			e.exports = {
				left: "_3YRHtGWABKh4OVO3s5gJwt",
				right: "_1IPWlMFPB_zPPajVPKk5Dy",
				expandRightContainer: "_2CUZHyZpRYmdvLE9tOI-2L"
			}
		},
		"./src/reddit/layout/twoCol/ExpandRight/index.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/higherOrderComponents/warnOnChildrenCount/index.tsx"),
				i = n("./src/lib/classNames/index.ts"),
				a = n("./src/reddit/layout/twoCol/ExpandRight/index.m.less"),
				d = n.n(a);

			function c() {
				return (c = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			t.a = Object(o.a)(e => {
				const {
					className: t,
					children: n,
					heightLeft: s,
					widthLeft: o,
					gutter: a,
					...l
				} = e;
				return r.a.createElement("div", c({
					className: Object(i.a)(d.a.expandRightContainer, t)
				}, l), r.a.createElement("div", {
					className: d.a.left,
					style: {
						flexBasis: o,
						height: s,
						marginRight: a
					}
				}, Array.isArray(n) && n[0]), r.a.createElement("div", {
					className: d.a.right
				}, Array.isArray(n) && n[1]))
			}, 2)
		},
		"./src/reddit/models/ApiRequestState/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return o
			}));
			var s, r = n("./node_modules/uuid/dist/esm-browser/v4.js");
			! function(e) {
				e[e.Pending = 0] = "Pending", e[e.Complete = 1] = "Complete", e[e.Failed = 2] = "Failed"
			}(s || (s = {}));
			const o = () => Object(r.a)()
		},
		"./src/reddit/models/Badge/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r, o, i = n("./src/config.ts");

			function a(e) {
				return "userId" in e
			}

			function d(e) {
				return !(!e.extra || !e.extra.membership) && !!e.extra.membership.included
			}

			function c(e, t, n) {
				const s = n.media[0],
					r = Object.keys(s);
				if (s["0x0"]) return s["0x0"];
				let o = {
					width: 1 / 0,
					height: 1 / 0,
					url: ""
				};
				if (r.forEach(n => {
						const r = s[n],
							[i, a] = n.split("x").map(e => parseInt(e));
						(i < o.width && i >= e || a < o.height && a >= t) && (o = {
							height: a,
							width: i,
							url: r
						})
					}), !o.url && r.length) {
					const e = Object.keys(s)[0],
						t = s[e],
						[n, r] = e.split("x").map(e => parseInt(e));
					o = {
						height: r,
						width: n,
						url: t
					}
				}
				return o.url
			}

			function l(e) {
				return e.startsWith("https") ? e : `${i.a.assetPath}/${e}`
			}

			function u(e, t, n) {
				const s = c(e, t, n),
					r = c(2 * e, 2 * t, n);
				return {
					url: l(s),
					url2x: l(r)
				}
			}! function(e) {
				e.First = "p1", e.Second = "p2"
			}(s || (s = {})),
			function(e) {
				e.ActivityTab = "activityTab", e.ChatTab = "chatTab", e.MessageTab = "messageTab", e.ChatHasNewMessages = "chatHasNewMessages", e.ChatUnreadMessages = "chatUnreadMessages"
			}(r || (r = {})),
			function(e) {
				e.Numbered = "NUMBERED", e.Filled = "FILLED"
			}(o || (o = {}))
		},
		"./src/reddit/models/Badge/managementPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			}));
			var s, r, o = n("./src/reddit/models/Badge/index.ts");
			! function(e) {
				e.Loyalty = "loyalty", e.Achievement = "achievement", e.Cosmetic = "cosmetic"
			}(s || (s = {})),
			function(e) {
				e.Gallery = "gallery", e.MyBadges = "my-badges"
			}(r || (r = {}));
			const i = {
					[s.Loyalty]: o.a.First,
					[s.Achievement]: o.a.Second,
					[s.Cosmetic]: void 0
				},
				a = e => e === o.a.First ? s.Loyalty : e === o.a.Second ? s.Achievement : s.Cosmetic
		},
		"./src/reddit/models/ContentGate.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.CustomFeedDoesNotExist = "CustomFeedDoesNotExist", e.GoldSubreddit = "GoldSubreddit", e.Nsfw = "Nsfw", e.NsfwCustomFeed = "NsfwCustomFeed", e.PrivateSubreddit = "PrivateSubreddit", e.ProfileDoesNotExist = "ProfileDoesNotExist", e.ProfileDeleted = "ProfileDeleted", e.ProfileSuspended = "ProfileSuspended", e.ProfileBlockedForLegalReason = "ProfileBlockedForLegalReason", e.QuarantinedSubreddit = "QuarantinedSubreddit", e.GatedSubreddit = "GatedSubreddit", e.SubredditBanned = "SubredditBanned", e.SubredditBlockedForLegalReason = "SubredditBlockedForLegalReason", e.SubredditDoesNotExist = "SubredditDoesNotExist", e.PostBlockedForLegalReason = "PostBlockedForLegalReason"
				}(s || (s = {}))
		},
		"./src/reddit/models/Duplicates/index.ts": function(e, t, n) {
			"use strict";

			function s(e, t) {
				return `${e}-sort[${t.sort}]-crossposts_only[${t.crossposts_only}]`
			}
			n.d(t, "a", (function() {
				return s
			}))
		},
		"./src/reddit/models/Emoji/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "c", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			}));
			const s = 24,
				r = 64e3,
				o = 128,
				i = 128,
				a = (e, t, n, s) => ({
					name: e,
					url: t,
					subredditId: n,
					...s
				})
		},
		"./src/reddit/models/ExternalAccount/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Twitter = "twitter"
				}(s || (s = {}))
		},
		"./src/reddit/models/HatefulContentFilters/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Off = "OFF", e.Lenient = "LENIENT", e.Moderate = "MODERATE", e.Strict = "STRICT"
				}(s || (s = {}))
		},
		"./src/reddit/models/ModQueueTrigger/index.ts": function(e, t, n) {
			"use strict";
			var s;

			function r(e, t) {
				var n;
				return null === (n = e.modQueueTriggers) || void 0 === n ? void 0 : n.find(e => e.type === t)
			}
			n.d(t, "a", (function() {
					return s
				})), n.d(t, "b", (function() {
					return r
				})),
				function(e) {
					e.USER_REPORTS = "USER_REPORTS", e.AUTOMOD = "AUTOMOD", e.MOD = "MOD", e.ADMIN = "ADMIN", e.SHADOWBANNED_SUBMITTER = "SHADOWBANNED_SUBMITTER", e.HATEFUL_CONTENT = "HATEFUL_CONTENT", e.CROWD_CONTROL = "CROWD_CONTROL", e.BAN_EVASION = "BAN_EVASION"
				}(s || (s = {}))
		},
		"./src/reddit/models/NotificationInbox/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return d
			}));
			var s, r, o, i, a = n("./src/reddit/models/FeedElement/index.ts");

			function d(e) {
				return e.__typename === a.a.InboxNotificationCollection
			}! function(e) {
				e.AwardReceived = "AWARD_RECEIVED", e.CakeDay = "CAKE_DAY", e.ChatMessage = "CHAT_MESSAGE", e.ChatRequest = "CHAT_REQUEST", e.ChatAcceptInvite = "CHAT_ACCEPT_INVITE", e.CommentFollow = "COMMENT_FOLLOW", e.CommentReply = "COMMENT_REPLY", e.HFNSubredditInterestingPost = "SUBREDDIT_UPDATES_INTERESTING_POST", e.LifecyclePostSuggestions = "LIFECYCLE_POST_SUGGESTIONS", e.ModeratedSrViralCommentPost = "MODERATED_SR_VIRAL_COMMENT_POST", e.OneOff = "ONE_OFF", e.PostFollow = "POST_FOLLOW", e.PostReply = "POST_REPLY", e.PrivateMessage = "PRIVATE_MESSAGE", e.RedditLore = "REDDIT_LORE", e.SubredditRecommendation = "SUBREDDIT_RECOMMENDATION", e.TalkLive = "TALK_LIVE", e.ThreadReplies = "THREAD_REPLIES", e.TopLevelComment = "TOP_LEVEL_COMMENT", e.UpvoteComment = "UPVOTE_COMMENT", e.UpvotePost = "UPVOTE_POST", e.UsernameMention = "USERNAME_MENTION", e.UserNewFollower = "USER_NEW_FOLLOWER"
			}(s || (s = {})),
			function(e) {
				e.Award = "AWARD", e.Bell = "BELL", e.Chat = "CHAT", e.Comment = "COMMENT", e.Heart = "HEART", e.Live = "LIVE", e.Lore = "LORE", e.NotifyAll = "NOTIFY_ALL", e.Redditor = "REDDITOR", e.Reply = "REPLY", e.SortLive = "SORT_LIVE", e.SortRising = "SORT_RISING", e.SortTop = "SORT_TOP", e.Trophy = "TROPHY", e.Upvote = "UPVOTE"
			}(r || (r = {})),
			function(e) {
				e.CopyrightTakedown = "COPYRIGHT_TAKEDOWN", e.ContentTakedown = " CONTENT_TAKEDOWN", e.Author = "AUTHOR", e.Moderator = "MODERATOR", e.CommunityOps = "COMMUNITY_OPS", e.AntiEvilOps = "ANTI_EVIL_OPS", e.Reddit = "REDDIT", e.Deleted = "DELETED", e.AutomodFiltered = "AUTOMOD_FILTERED"
			}(o || (o = {})),
			function(e) {
				e.InboxNotification = "InboxNotification", e.InboxNotificationContext = "InboxNotificationContext", e.NotificationIcon = "NotificationIcon", e.AwardReceivedInboxNotificationContext = "AwardReceivedInboxNotificationContext", e.BasicInboxNotificationContext = "BasicInboxNotificationContext", e.CommentInboxNotificationContext = "CommentInboxNotificationContext", e.PostInboxNotificationContext = "PostInboxNotificationContext", e.PostSubredditInboxNotificationContext = "PostSubredditInboxNotificationContext", e.SubredditInboxNotificationContext = "SubredditInboxNotificationContext"
			}(i || (i = {}))
		},
		"./src/reddit/models/NotificationSettingsLayout/index.ts": function(e, t, n) {
			"use strict";
			var s;
			n.d(t, "a", (function() {
					return s
				})),
				function(e) {
					e.Email = "EMAIL", e.Push = "PUSH", e.CommunityAlerts = "COMMUNITY_ALERTS", e.ModCommunityAlerts = "MOD_COMMUNITY_ALERTS"
				}(s || (s = {}))
		},
		"./src/reddit/models/Option/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			const s = e => !e.id,
				r = e => !!e.id,
				o = (e, t) => s(e) && s(t) ? e.displayText.toLowerCase().trim() === t.displayText.toLowerCase().trim() : !(!r(e) || !r(t)) && e.id === t.id
		},
		"./src/reddit/models/RemovalReason/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			}));
			var s = n("./src/reddit/helpers/isPost.ts");
			const r = 50,
				o = 50,
				i = 1e4,
				a = 100;
			var d, c;
			! function(e) {
				e.Private = "private", e.PrivateExposed = "private_exposed", e.Public = "public", e.PublicAsSubreddit = "public_as_subreddit"
			}(d || (d = {})),
			function(e) {
				e.Bulk = "bulk", e.Comment = "comment", e.Post = "link"
			}(c || (c = {}));
			const l = e => 1 === e.length ? Object(s.a)(e[0]) ? c.Post : c.Comment : c.Bulk,
				u = (e, t) => {
					return {
						[t === c.Bulk ? "item_ids" : "item_id"]: e.itemId,
						message: e.message,
						title: e.title,
						type: e.type,
						lock_comment: e.isLocked
					}
				}
		},
		"./src/reddit/models/ScheduledPost/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "s", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "f", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "p", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "c", (function() {
				return f
			})), n.d(t, "r", (function() {
				return _
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "k", (function() {
				return v
			})), n.d(t, "i", (function() {
				return x
			})), n.d(t, "j", (function() {
				return O
			})), n.d(t, "d", (function() {
				return E
			})), n.d(t, "n", (function() {
				return y
			})), n.d(t, "b", (function() {
				return C
			})), n.d(t, "m", (function() {
				return j
			})), n.d(t, "q", (function() {
				return k
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/assertNever.ts"),
				r = n("./src/reddit/models/GqlTopLevelField.ts"),
				o = n("./src/reddit/models/User/index.ts");
			const i = "scheduledposts";
			var a, d, c;
			! function(e) {
				e.LINK = "LINK", e.POLL = "POLL", e.SELF = "SELF"
			}(a || (a = {})),
			function(e) {
				e.RTJSON = "RTJSON", e.TEXT = "TEXT"
			}(d || (d = {})),
			function(e) {
				e.CREATED = "CREATED", e.PROCESSING = "PROCESSING", e.FAILED = "FAILED", e.SUCCESS = "SUCCESS"
			}(c || (c = {}));
			const l = e => {
					return new Set(["links", "text", "polls"]).has(e)
				},
				u = e => e.__typename === o.c.AvailableRedditor,
				m = e => e.__typename === r.a.Subreddit;
			var p, b, f, h;
			! function(e) {
				e.standalonePosts = "standalonePosts", e.recurringPosts = "recurringPosts"
			}(p || (p = {})),
			function(e) {
				e.MONDAY = "MONDAY", e.TUESDAY = "TUESDAY", e.WEDNESDAY = "WEDNESDAY", e.THURSDAY = "THURSDAY", e.FRIDAY = "FRIDAY", e.SATURDAY = "SATURDAY", e.SUNDAY = "SUNDAY"
			}(b || (b = {})),
			function(e) {
				e[e.MONDAY = 0] = "MONDAY", e[e.TUESDAY = 1] = "TUESDAY", e[e.WEDNESDAY = 2] = "WEDNESDAY", e[e.THURSDAY = 3] = "THURSDAY", e[e.FRIDAY = 4] = "FRIDAY", e[e.SATURDAY = 5] = "SATURDAY", e[e.SUNDAY = 6] = "SUNDAY"
			}(f || (f = {})),
			function(e) {
				e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY"
			}(h || (h = {}));
			const _ = e => b[h[e]],
				g = e => h[b[e]],
				v = e => f[b[e]],
				x = e => b[f[e]],
				O = e => h[f[e]];
			var E;
			! function(e) {
				e.Hourly = "HOURLY", e.Daily = "DAILY", e.Weekly = "WEEKLY", e.Monthly = "MONTHLY"
			}(E || (E = {}));
			const y = e => {
					switch (e) {
						case E.Hourly:
						case E.Daily:
						case E.Weekly:
						case E.Monthly:
							return !0
					}
					return !1
				},
				C = "custom",
				j = e => {
					switch (e) {
						case "isNsfw":
							return "mark_as_nsfw";
						case "isOriginalContent":
							return "mark_as_oc";
						case "isSticky":
							return "sticky";
						case "isModDistinguished":
							return "mod_distinguish";
						case "isSpoiler":
							return "mark_as_spoiler";
						case "isContestMode":
							return "mark_as_contest_mode";
						case "isPostAsMetaMod":
							return "post_as_meta_mod";
						default:
							return Object(s.a)(e)
					}
				},
				k = e => "frequency" in e && !!e.frequency
		},
		"./src/reddit/models/SubredditModeration/ModerationLog/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t, n) => `${e}-${((e,t)=>t||e||"1")(n,t)}`
		},
		"./src/reddit/models/SubredditWikiPage/index.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.MayNotView = "MAY_NOT_VIEW", e.PageNotCreated = "PAGE_NOT_CREATED", e.PageNotFound = "PAGE_NOT_FOUND", e.RestrictedPage = "RESTRICTED_PAGE", e.Unknown = "UNKNOWN", e.Valid = "VALID", e.WikiDisabled = "WIKI_DISABLED"
				}(s || (s = {})),
				function(e) {
					e.Inherit = "INHERIT_SUBREDDIT_PERMS", e.Contributors = "CONTRIBUTORS", e.Mods = "MODS"
				}(r || (r = {}))
		},
		"./src/reddit/models/Tags/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			}));
			const s = 25,
				r = 64;
			var o;
			! function(e) {
				e.EVENT = "EVENT", e.COLLECTION = "COLLECTION", e.CLASSIFICATION = "CLASSIFICATION", e.POST_CLASSIFICATION = "POST_CLASSIFICATION", e.SUBREDDIT_CLASSIFICATION = "SUBREDDIT_CLASSIFICATION", e.COMMENT_CLASSIFICATION = "COMMENT_CLASSIFICATION"
			}(o || (o = {}));
			const i = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return {
						id: e.id,
						displayText: e.text,
						selected: t
					}
				},
				a = function(e) {
					let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					return i(e.tag, t)
				};
			var d;
			! function(e) {
				e.TAGGED = "TAGGED", e.NONE = "NONE"
			}(d || (d = {}))
		},
		"./src/reddit/models/TrafficStats/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			}));
			const s = 97,
				r = 57,
				o = 12;
			var i;
			! function(e) {
				e.TOTAL = "total", e.DESKTOP = "desktop", e.OLD_REDDIT = "oldReddit", e.IOS = "apps", e.ANDROID = "apps", e.MOBILE_WEB = "mWeb"
			}(i || (i = {}))
		},
		"./src/reddit/models/inboxBanner/index.ts": function(e, t, n) {
			"use strict";
			var s, r;
			n.d(t, "b", (function() {
					return s
				})), n.d(t, "a", (function() {
					return r
				})),
				function(e) {
					e.IOS = "IOS_APP", e.ANDROID = "ANDROID_APP", e.DESKTOP = "DESKTOP_APP"
				}(s || (s = {})),
				function(e) {
					e.GOTO = "goto", e.DISMISS = "dismiss"
				}(r || (r = {}))
		},
		"./src/reddit/pages/ErrorPages/index.m.less": function(e, t, n) {
			e.exports = {
				primaryRouterLink: "WPSTJCepGLEWZl2fETrUM",
				container: "_3pfk0xbr5atzL7KT8pXEZG",
				title: "_3uo9iClHghoc_hoxzdgipi"
			}
		},
		"./src/reddit/pages/ErrorPages/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/react/index.js"),
				o = n.n(r),
				i = n("./src/reddit/controls/Button/index.tsx"),
				a = n("./src/reddit/pages/ErrorPages/index.m.less"),
				d = n.n(a);
			const c = e => {
					let {
						shouldReloadHome: t
					} = e;
					return t ? o.a.createElement(i.a, {
						kind: i.b.ExternalLink,
						priority: i.c.Primary,
						className: d.a.primaryRouterLink,
						href: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					})) : o.a.createElement(i.a, {
						kind: i.b.InternalLink,
						priority: i.c.Primary,
						className: d.a.primaryRouterLink,
						to: "/"
					}, s.fbt._("Go Home", null, {
						hk: "3E9E1g"
					}))
				},
				l = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return o.a.createElement("div", {
						className: d.a.container
					}, o.a.createElement("h3", {
						className: d.a.title
					}, t || s.fbt._("Sorry, there doesn't seem to be anything here.", null, {
						hk: "3VvHek"
					})), o.a.createElement(c, {
						shouldReloadHome: n
					}))
				},
				u = e => {
					let {
						message: t,
						shouldReloadHome: n
					} = e;
					return o.a.createElement("div", {
						className: d.a.container
					}, o.a.createElement("h3", {
						className: d.a.title
					}, t || s.fbt._("Sorry, You do not have permission to view this page.", null, {
						hk: "4lRbHD"
					})), o.a.createElement(c, {
						shouldReloadHome: n
					}))
				}
		},
		"./src/reddit/pages/ModHub/Header.m.less": function(e, t, n) {
			e.exports = {
				titleFontH1: "_3moWGMnbR8K4S0yEul07nr",
				titleFontH2: "_2oI68wVKNMPkDrFs5iv-mT",
				titleFontH3: "_2SjfolwDVVvPkTR19n53-N",
				titleFontH4: "_2PCswqdAkej43QrI3i2XD6",
				titleFontH5: "_2ClzPN9iMLeouYjBczMuak",
				titleFontH6: "-Ys2BgGuQrEY2uMl3yymz",
				metadataFont: "_13D6uHC3HmU2n303ICkc2Z",
				flairFont: "jd22g-ATlzm80vQJWeapy",
				labelsFont: "_1UxIO379jfzGXKK-UTji0l",
				actionFont: "_33izYXQ9DA6aVnhOiSApGv",
				smallButtonFont: "_3gTmhpwBqqacn2Fbh1nFPi",
				largeButtonFont: "_18NraFj-4C_LqHvfoVPar1",
				strongTextFont: "_3tRumE3gvvS_0BYlnDtcIA",
				tabFont: "_1DLPo8qhiBT00GYX1ng3ad",
				buttonFontXS: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontXs: "_1jy5yDpKOT5-Cv2QAMnE8Z",
				buttonFontS: "_3DmXGTGm5YD5IApa9MyBNq",
				buttonFontM: "_32Yvll-0lWSj_SZKU0TKRR",
				buttonFontL: "_1wDiG7XcGSvunA559KlfGG",
				buttonFontXL: "xpxpmGAZ5HYQvDSsMNvp8",
				buttonFontXl: "xpxpmGAZ5HYQvDSsMNvp8",
				bodyFontH1: "_1ygLn4-Vtd31oQv6zylo5z",
				bodyFontH2: "_1btDxE6K9AP_wtfakdg11l",
				bodyFontH3: "cMjXJNdI0iac3nSCHtBrq",
				bodyFontH4: "_3ZsC5lxE3Dnw9-duolQiN3",
				bodyFontH5: "_3gWD0dGAav6VxMQZ2iY4qc",
				bodyFontH6: "_2yKCC1d-C1qheMkCr5CedW",
				bodyFontH6Small: "_1AyCUR1VQn-opitbpGpNcf",
				bodyFont: "_1RI3wkzuynRc_Bqno__Uom",
				bodyFontSmall: "_2MlCobLFb0alel2wzuIFVK",
				bodyFontMono: "_3RdMKJzgzPT9lgXHEf0XZB",
				landingPageTitleFontH1: "KVO5ZZIscMWGahfHIsr-o",
				landingPageTitleFontH2: "_1Z7_zVV5u4BYuO1gRsLx90",
				landingPageTitleFontH3: "_2yCXZ7SWFT2-XNs-FGlvBs",
				header: "_3u9on6H92JkZNRumczPd67",
				subredditLink: "_3EIUrhztcaaHcqMILEsnBq",
				subredditIcon: "_3uA1he5X3WeG6mpoUWdcXy"
			}
		},
		"./src/reddit/pages/ModHub/Header.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/pages/ModHub/Header.m.less"),
				i = n.n(o),
				a = n("./src/reddit/components/SubredditIcon/index.tsx"),
				d = n("./src/reddit/controls/InternalLink/index.tsx");
			t.a = e => {
				var t, n;
				return r.a.createElement("div", {
					className: i.a.header
				}, r.a.createElement(a.b, {
					className: i.a.subredditIcon,
					subredditOrProfile: e.subredditOrProfile
				}), r.a.createElement(d.default, {
					className: i.a.subredditLink,
					to: (null === (t = e.subredditOrProfile) || void 0 === t ? void 0 : t.url) || "",
					onClick: e.onClick
				}, null === (n = e.subredditOrProfile) || void 0 === n ? void 0 : n.displayText), e.pageName && `/ ${e.pageName}`)
			}
		},
		"./src/reddit/pages/ModHub/index.m.less": function(e, t, n) {
			e.exports = {
				contentWrapper: "_2Z3MiFrgj2rofHXrH1YVKn",
				isModerator: "_1haViLcso0RRPvkDGZgDLJ",
				BackgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				backgroundContainer: "_1XAvW8OS9HO-SVS7BDAIGe",
				Body: "_3hAOyl8ThaUgCBqiNvN_sN",
				body: "_3hAOyl8ThaUgCBqiNvN_sN"
			}
		},
		"./src/reddit/pages/ModHub/index.tsx": function(e, t, n) {
			"use strict";
			n.r(t);
			var s = n("./node_modules/lodash/fromPairs.js"),
				r = n.n(s),
				o = n("./node_modules/react/index.js"),
				i = n.n(o),
				a = n("./node_modules/react-redux/es/index.js"),
				d = n("./node_modules/reselect/es/index.js"),
				c = n("./src/lib/classNames/index.ts"),
				l = n("./src/lib/extractQueryParams/index.ts"),
				u = n("./src/lib/lessComponent.tsx"),
				m = n("./src/reddit/components/ContentGate/index.tsx"),
				p = n("./node_modules/fbt/lib/FbtPublic.js"),
				b = n("./src/lib/assertNever.ts"),
				f = n("./src/lib/constants/index.ts");
			const h = e => {
				switch (e) {
					case f.mc.Awards:
						return p.fbt._("Awards", null, {
							hk: "EiSXW"
						});
					case f.mc.Powerups:
						return p.fbt._("Powerups", null, {
							hk: "3SZBhK"
						});
					case f.mc.Banned:
						return p.fbt._("Banned", null, {
							hk: "35R8OD"
						});
					case f.mc.Muted:
						return p.fbt._("Muted", null, {
							hk: "f2nJu"
						});
					case f.mc.ContentControls:
						return p.fbt._("Content controls", null, {
							hk: "H1yxv"
						});
					case f.mc.Contributors:
						return p.fbt._("Approved", null, {
							hk: "180AS9"
						});
					case f.mc.Moderators:
						return p.fbt._("Moderators", null, {
							hk: "4qdV8t"
						});
					case f.mc.SubredditRules:
						return p.fbt._("Rules", null, {
							hk: "2SNdd8"
						});
					case f.mc.Removal:
						return p.fbt._("Removal reasons", null, {
							hk: "1smDUM"
						});
					case f.mc.Modqueue:
						return p.fbt._("Mod queue", null, {
							hk: "yEBGb"
						});
					case f.mc.Reports:
						return p.fbt._("Reports", null, {
							hk: "4Ctcb1"
						});
					case f.mc.Spam:
						return p.fbt._("Spam", null, {
							hk: "1D73Vp"
						});
					case f.mc.Unmoderated:
						return p.fbt._("Unmoderated", null, {
							hk: "3TOaeD"
						});
					case f.mc.Edited:
						return p.fbt._("Edited", null, {
							hk: "OLtvW"
						});
					case f.mc.Modlog:
						return p.fbt._("Mod log", null, {
							hk: "3uy7LL"
						});
					case f.mc.Flair:
						return p.fbt._("Grant user flair", null, {
							hk: "2B8sTJ"
						});
					case f.mc.CommunitySettings:
						return p.fbt._("Community settings", null, {
							hk: "XbHzi"
						});
					case f.mc.Emojis:
						return p.fbt._("Emojis", null, {
							hk: "3mPnxe"
						});
					case f.mc.UserFlair:
						return p.fbt._("User flair", null, {
							hk: "3kleCv"
						});
					case f.mc.PostFlair:
						return p.fbt._("Post flair", null, {
							hk: "2Y1FKb"
						});
					case f.mc.Badges:
						return p.fbt._("Badges", null, {
							hk: "3vM0lt"
						});
					case f.mc.Emotes:
						return p.fbt._("Emotes", null, {
							hk: "2Ivxxq"
						});
					case f.mc.Wiki:
					case f.mc.WikiContributors:
					case f.mc.WikiBanned:
						return p.fbt._("Wiki pages", null, {
							hk: "WdSXv"
						});
					case f.mc.Traffic:
						return p.fbt._("Traffic stats", null, {
							hk: "3mcw71"
						});
					case f.mc.ScheduledPostContent:
					case f.mc.SubredditContent:
						return p.fbt._("Scheduled posts", null, {
							hk: "19KZjq"
						});
					case f.mc.EventPostContent:
						return p.fbt._("Event posts", null, {
							hk: "3ejc42"
						});
					case f.mc.Streaming:
						return p.fbt._("Broadcasting", null, {
							hk: "1Cz44z"
						});
					case f.mc.Predictions:
						return p.fbt._("Predictions", null, {
							hk: "1yASCC"
						});
					case f.mc.TalkHosts:
						return p.fbt._("Talk hosts", null, {
							hk: "3BAjFt"
						});
					default:
						return Object(b.a)(e)
				}
			};
			var _ = n("./src/reddit/components/TrackingHelper/index.tsx"),
				g = n("./src/reddit/contexts/PageLayer/index.tsx"),
				v = n("./src/reddit/helpers/canAccessModerationPage/index.ts"),
				x = n("./src/reddit/helpers/getSubredditErrorProps/index.ts"),
				O = n("./src/reddit/helpers/trackers/moderationPages.ts"),
				E = n("./src/reddit/helpers/trackers/modHub.ts"),
				y = n("./src/reddit/models/ModQueue/index.ts"),
				C = n("./src/reddit/selectors/experiments/econ/index.ts"),
				j = n("./src/reddit/selectors/experiments/realtimeMQUpdates.ts"),
				k = n("./src/reddit/selectors/moderatorPermissions.ts"),
				I = n("./src/reddit/selectors/postCreations.ts"),
				S = n("./src/reddit/selectors/profile.ts"),
				w = n("./src/reddit/selectors/streamingModSettings.ts"),
				T = n("./src/reddit/selectors/subreddit.ts"),
				N = n("./src/reddit/selectors/user.ts"),
				P = n("./src/reddit/components/ModHub/Content/index.tsx"),
				R = n("./src/reddit/components/ModHub/Content/NoPermissions.tsx"),
				A = n("./src/reddit/icons/svgs/Moderate/index.tsx"),
				M = n("./src/reddit/components/ModHub/Content/WelcomeMessage.m.less"),
				L = n.n(M);
			const D = u.a.wrapped(A.a, "ModerateIcon", L.a),
				F = u.a.div("ModHubWelcomeMessage", L.a);
			var U = e => i.a.createElement(F, null, i.a.createElement(D, null), p.fbt._("Welcome to the mod tools for {subredditName}", [p.fbt._param("subredditName", e.subredditDisplayText)], {
					hk: "7Usff"
				})),
				B = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/config.ts")),
				q = n("./node_modules/react-router-redux/es/index.js"),
				G = n("./src/reddit/components/CrowdControlAdoptionCampaign/useCrowdControlCampaign.tsx"),
				H = n("./src/reddit/components/EmailInvitePaintedDoor/loader.tsx"),
				W = n("./src/reddit/components/ModHub/ContentControls/FormSections/HatefulContentFilters/useHCFAdoptionCampaign.tsx"),
				V = n("./src/reddit/contexts/NavbarExp.ts"),
				z = n("./src/reddit/featureFlags/index.ts"),
				K = n("./src/reddit/helpers/localStorage/index.ts"),
				Q = n("./src/reddit/helpers/trackers/communitySettings.ts"),
				Y = n("./src/reddit/helpers/trackers/emailInvite.ts"),
				J = n("./src/reddit/helpers/trackers/scheduledPosts.ts"),
				X = n("./src/reddit/icons/fonts/index.tsx"),
				Z = n("./src/reddit/routes/moderationPages/index.ts"),
				$ = n("./src/reddit/selectors/communitySettings.ts"),
				ee = n("./src/reddit/selectors/experiments/emailInvite.ts"),
				te = n("./src/reddit/selectors/experiments/eventPosts.ts"),
				ne = n("./src/reddit/selectors/experiments/imageComment.ts"),
				se = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				re = n("./src/reddit/selectors/gold/powerups/index.ts"),
				oe = n("./src/reddit/components/StructuredStyles/Breadcrumbs/index.tsx"),
				ie = n("./src/reddit/components/ModHub/ModHubNav/index.m.less"),
				ae = n.n(ie);

			function de() {
				return (de = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			var ce = e => i.a.createElement("div", de({
					className: Object(c.a)(ae.a.breadcrumb, e.className)
				}, e), i.a.createElement("button", {
					className: ae.a.breadcrumbButton
				}, i.a.createElement(oe.a, null), p.fbt._("Back to mod tools", null, {
					hk: "4udiKO"
				}))),
				le = n("./src/reddit/components/ModHub/ModHubNav/NavItem.tsx"),
				ue = n("./src/reddit/actions/modal.ts"),
				me = n("./src/higherOrderComponents/asModal/index.tsx"),
				pe = n("./src/reddit/components/CharacterCountdown/index.tsx"),
				be = n("./src/reddit/components/ModalStyledComponents/index.tsx"),
				fe = n("./src/reddit/components/StructuredStyles/StyledComponents/inputs.ts"),
				he = n("./src/reddit/constants/wiki.ts"),
				_e = n("./src/reddit/controls/Button/index.tsx"),
				ge = n("./src/reddit/controls/TextButton/index.tsx"),
				ve = n("./src/reddit/helpers/wiki/buildWikiPagesTree.ts"),
				xe = n("./src/reddit/helpers/wiki/validatePageName.ts"),
				Oe = n("./src/reddit/icons/svgs/QuarantineWarning/index.tsx"),
				Ee = n("./src/reddit/layout/twoCol/ExpandLeft/index.tsx"),
				ye = n("./src/reddit/controls/Dropdown/index.tsx"),
				Ce = n("./src/reddit/controls/Dropdown/Row.tsx"),
				je = n("./src/reddit/icons/svgs/Dropdown/index.tsx"),
				ke = n("./src/reddit/components/Wiki/CreateNewWikiPageModal/index.m.less"),
				Ie = n.n(ke);
			class Se extends i.a.Component {
				constructor(e) {
					super(e), this.onToggleDropdown = () => {
						this.setState({
							isDropdownOpen: !this.state.isDropdownOpen
						})
					}, this.onSelectParentPage = e => {
						this.props.onSelectParentPage(e), this.onToggleDropdown()
					}, this.state = {
						isDropdownOpen: !1
					}
				}
				render() {
					const {
						pageTree: e,
						parentPageName: t
					} = this.props, {
						isDropdownOpen: n
					} = this.state, s = p.fbt._("None", null, {
						hk: "3FT0YQ"
					});
					return i.a.createElement("div", {
						className: Ie.a.dropdownContainer
					}, i.a.createElement("button", {
						className: Ie.a.dropdownTarget,
						onClick: this.onToggleDropdown
					}, i.a.createElement("div", {
						className: Ie.a.targetText
					}, t || s), i.a.createElement(je.b, null)), n && i.a.createElement(ye.a, {
						className: Ie.a.dropdown
					}, i.a.createElement(Ce.b, {
						className: Ie.a.dropdownRow,
						displayText: s,
						onClick: () => this.onSelectParentPage(void 0)
					}), e.map(e => e.depth >= he.c ? null : he.f.has(e.path.split("/")[0]) ? null : i.a.createElement(Ce.b, {
						className: Ie.a.dropdownRow,
						displayText: e.path,
						key: e.path,
						onClick: () => this.onSelectParentPage(e.path)
					}))))
				}
			}
			var we = Se;
			const Te = e => {
				switch (e) {
					case xe.a.InvalidPageName:
						return p.fbt._("Invalid page name", null, {
							hk: "1gQvCb"
						});
					case xe.a.MaxLengthExceed:
						return p.fbt._("Name exceeds character limit", null, {
							hk: "RDoIC"
						});
					case xe.a.PageAlreadyExists:
						return p.fbt._("That page already exists", null, {
							hk: "xEyyR"
						});
					case xe.a.RestrictedPageName:
						return p.fbt._("Restricted page name", null, {
							hk: "Bjv5o"
						})
				}
			};
			class Ne extends i.a.Component {
				constructor(e) {
					super(e), this.onChangePageName = e => {
						this.setState({
							partialPageName: e.currentTarget.value
						})
					}, this.onSelectParentPage = e => {
						this.setState({
							parentPageName: e
						})
					}, this.getNewPagePath = () => {
						let e = "";
						return this.state.parentPageName && (e += `${this.state.parentPageName}/`), (e += `${this.state.partialPageName}`).toLowerCase()
					}, this.state = {
						partialPageName: "",
						parentPageName: void 0
					}
				}
				hasError() {
					const {
						pageTree: e
					} = this.props, {
						partialPageName: t
					} = this.state;
					return Object(xe.c)(t) || Object(xe.b)(this.getNewPagePath(), e)
				}
				render() {
					const {
						props: e,
						state: t
					} = this, n = this.hasError();
					return i.a.createElement(be.e, {
						className: Ie.a.modalBody
					}, i.a.createElement(be.i, null, i.a.createElement(Ee.a, null, i.a.createElement(be.q, null, p.fbt._("Create a new wiki page", null, {
						hk: "V7Jnm"
					})), i.a.createElement(ge.a, {
						onClick: e.toggleModal
					}, i.a.createElement(be.b, null)))), i.a.createElement("div", {
						className: Ie.a.notice
					}, i.a.createElement(Oe.a, null), p.fbt._("Parent page and page URL cannot be edited once created", null, {
						hk: "20D6uz"
					})), i.a.createElement(be.l, null, i.a.createElement("div", {
						className: Ie.a.sectionTitle
					}, p.fbt._("Parent page", null, {
						hk: "1FeKiT"
					})), i.a.createElement(we, {
						onSelectParentPage: this.onSelectParentPage,
						pageTree: Object(ve.b)(e.pageTree || []),
						parentPageName: t.parentPageName
					}), i.a.createElement("div", {
						className: Ie.a.sectionTitle
					}, p.fbt._("Page URL", null, {
						hk: "WL8sn"
					})), i.a.createElement(fe.d, {
						placeholder: p.fbt._("ex: rules", null, {
							hk: "J0qH1"
						}),
						onChange: this.onChangePageName,
						value: t.partialPageName
					}), i.a.createElement(pe.a, {
						text: this.getNewPagePath(),
						maxChars: he.d
					}), i.a.createElement("div", {
						className: Ie.a.errorText
					}, t.partialPageName && n ? Te(n) : null)), i.a.createElement(be.g, null, i.a.createElement(be.a, {
						onClick: e.toggleModal
					}, p.fbt._("Cancel", null, {
						hk: "2TSLl5"
					})), i.a.createElement(_e.n, {
						disabled: !t.partialPageName || !!n,
						className: Ie.a.primaryButton,
						to: `${e.subredditUrl}about/wiki/create/${this.getNewPagePath()}`
					}, p.fbt._("Create", null, {
						hk: "2W0PL1"
					}))))
				}
			}
			var Pe = Object(me.a)(Ne),
				Re = n("./src/reddit/selectors/activeModalId.ts"),
				Ae = n("./src/reddit/selectors/subredditWiki.ts"),
				Me = n("./node_modules/lodash/times.js"),
				Le = n.n(Me),
				De = n("./src/reddit/controls/InternalLink/index.tsx"),
				Fe = n("./src/reddit/components/ModHub/ModHubNav/WikiNavPanel/index.m.less"),
				Ue = n.n(Fe);
			class Be extends i.a.PureComponent {
				constructor() {
					super(...arguments), this.containerRef = i.a.createRef()
				}
				componentDidMount() {
					this.scrollToActiveItemIfNeeded()
				}
				scrollToActiveItemIfNeeded() {
					const e = this.containerRef.current,
						t = e && e.getElementsByClassName(Ue.a.mActive)[0];
					if (!e || !t) return;
					const n = e.getBoundingClientRect(),
						s = t.getBoundingClientRect();
					s.top >= n.top && s.bottom <= n.bottom || t.scrollIntoView()
				}
				render() {
					const {
						activePageName: e,
						baseUrl: t,
						directory: n
					} = this.props, s = Object(ve.b)(n && n.pageTree || []);
					return i.a.createElement("div", {
						ref: this.containerRef,
						className: Ue.a.contentTree
					}, s.map(n => {
						const s = n.path === e;
						return i.a.createElement(De.default, {
							key: n.path,
							className: Ue.a.pageNavLink,
							to: `${t}/${n.path}`
						}, i.a.createElement("div", {
							className: Object(c.a)(Ue.a.pageNavItem, {
								[Ue.a.mActive]: s,
								[Ue.a.mExists]: n.isPagePresent
							})
						}, Le()(n.depth, () => i.a.createElement("div", {
							className: Ue.a.indentLine
						})), i.a.createElement("span", {
							className: Ue.a.itemText
						}, `/${n.name}`)))
					}))
				}
			}
			const qe = Object(d.c)({
				directory: (e, t) => Object(Ae.b)(e, {
					subredditName: t.subreddit.name
				}),
				isCreateWikiPageModalOpen: e => "CreateWikiPageModal" === Object(Re.a)(e)
			});
			class Ge extends i.a.Component {
				constructor() {
					super(...arguments), this.onToggleCreateWikiModal = () => {
						this.props.toggleCreateWikiModal()
					}
				}
				render() {
					const {
						directory: e,
						isCreateWikiPageModalOpen: t,
						subreddit: n,
						toggleCreateWikiModal: s,
						pageLayer: r
					} = this.props;
					if (!r) return null;
					const {
						urlParams: o
					} = r, {
						wikiPageName: a,
						wikiSubRoute: d,
						pageName: c
					} = o;
					return i.a.createElement("div", {
						className: Ue.a.wikiNavPanel
					}, i.a.createElement(_e.l, {
						className: Ue.a.primaryButton,
						onClick: this.onToggleCreateWikiModal
					}, p.fbt._("Create new page", null, {
						hk: "35WDuL"
					})), i.a.createElement(Be, {
						activePageName: a,
						baseUrl: `${n.url}about/wiki`,
						directory: e
					}), i.a.createElement("div", {
						className: Ue.a.footer
					}, i.a.createElement(le.b, {
						isActive: d === he.m.Revisions && !a,
						label: p.fbt._("Recent wiki revisions", null, {
							hk: "278VnD"
						}),
						path: `${n.url}about/wiki/revisions`
					}), i.a.createElement(le.b, {
						isActive: c === f.mc.WikiContributors,
						label: p.fbt._("Add wiki contributors", null, {
							hk: "1XHd90"
						}),
						path: `${n.url}about/wikicontributors`
					}), i.a.createElement(le.b, {
						isActive: c === f.mc.WikiBanned,
						label: p.fbt._("Ban wiki contributors", null, {
							hk: "3IVNKp"
						}),
						path: `${n.url}about/wikibanned`
					}), i.a.createElement(le.b, {
						label: p.fbt._("Wiki settings", null, {
							hk: "1Jctxf"
						}),
						path: `${n.url}about/edit?page=wikis`
					})), t && i.a.createElement(Pe, {
						pageTree: e && e.pageTree,
						subredditUrl: n.url,
						toggleModal: s,
						withOverlay: !0
					}))
				}
			}
			var He = Object(g.v)()(Object(a.b)(qe, e => ({
				toggleCreateWikiModal: () => e(Object(ue.i)("CreateWikiPageModal"))
			}))(Ge));
			const We = Object(d.c)({
				isBadgesAndEmotesEnabled: z.d.spCustomBadgesAndEmotes,
				isContentTagEnabled: (e, t) => !!e.subreddits.survey[t.subreddit.id],
				isEligibleForScheduledPosts: z.d.scheduledPosts,
				isEmailInviteExperimentEnabled: ee.a,
				isImageCommentSettingExperimentEnabled: ne.c,
				isMediaInCommentsSettingShown: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object($.a)(e, n.id)
				},
				isBroadcastingEnabled: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(w.c)(e, n.id)
				},
				isTournamentsEnabled: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(T.S)(e, {
						subredditId: n.id
					})
				},
				isPowerupsTabVisible: (e, t) => {
					let {
						subreddit: n
					} = t;
					return Object(re.b)(e, {
						subredditId: n.id
					}) && (!Object(se.b)(e) || !Object(C.d)(e))
				},
				isTalkHostsExperimentEnabled: C.p,
				isEventPostUiHidden: te.a
			});
			class Ve extends i.a.Component {
				constructor(e, t) {
					super(e, t), this.trackClick = e => this.props.sendEvent(E.c(e)), this.trackCommunitySettingsNavItemClick = e => this.props.sendEvent(Object(Q.b)(e)), this.onClickAwards = () => this.trackClick("awards"), this.onClickPowerups = () => this.trackClick("powerups"), this.onClickStreaming = () => this.trackClick("streaming"), this.onClickModQueue = () => this.trackClick("mod_queue"), this.onClickReports = () => this.trackClick("reports"), this.onClickSpam = () => this.trackClick("spam"), this.onClickEdited = () => this.trackClick("edited"), this.onClickUnmoderated = () => this.trackClick("unmoderated"), this.onClickBannedUsers = () => this.trackClick("ban_users"), this.onClickMutedUsers = () => this.trackClick("mute_users"), this.onClickApprovedSubmitters = () => this.trackClick("approved_submitters"), this.onClickApprovedTalkHosts = () => this.trackClick("talk_hosts"), this.onClickEmojis = () => this.trackClick("emoji"), this.onClickModerators = () => this.trackClick("moderators"), this.onClickCommunitySettings = () => this.trackClick("community_settings"), this.onClickCommunityAppearance = () => this.trackClick("community_appearance"), this.onClickModMail = () => this.trackClick("mod_mail"), this.onClickRemovalReasons = () => this.trackClick("removal_reasons"), this.onClickRules = () => this.trackClick("rules"), this.onClickPostRequirements = () => this.trackClick("post_requirements"), this.onClickAutomodConfig = () => this.trackClick("automod_config"), this.onClickWikiPages = () => this.trackClick("wiki"), this.onClickTraffic = () => this.trackClick("traffic"), this.onClickModLog = () => this.trackClick("mod_log"), this.onClickModSupport = () => this.trackClick("r_mod_support"), this.onClickModHelp = () => this.trackClick("mod_help"), this.onClickContactReddit = () => this.trackClick("contact_reddit"), this.onClickModGuidelines = () => this.trackClick("mod_guidelines"), this.onClickModHelpCenter = () => this.trackClick("mod_help_center"), this.onClickPostFlair = () => this.trackClick("post_flair"), this.onClickUserFlair = () => this.trackClick("user_flair"), this.onClickGrantUserFlair = () => this.trackClick("grant_user_flair"), this.onClickBadges = () => this.trackClick("badges"), this.onClickEmotes = () => this.trackClick("emotes"), this.onClickScheduledPosts = () => this.props.sendEvent(Object(J.k)()), this.onClickEventPosts = () => this.props.sendEvent(Object(J.f)()), this.onClickPredictions = () => this.trackClick("predictions"), this.onGoToModHub = () => {
						const e = this.props.moderatorPermissions && this.props.moderatorPermissions.posts,
							t = `${this.props.subreddit.url}about/`,
							n = e ? `${t}modqueue` : t;
						this.props.pushUrl(n)
					}, this.onClickInviteViaEmail = () => {
						const {
							sendEvent: e
						} = this.props;
						e(Object(Y.a)("mod_hub_nav")), this.setState({
							showEmailInvitePaintedDoor: !0
						})
					}, this.onCloseInviteViaEmailModal = () => {
						this.setState({
							showEmailInvitePaintedDoor: !1
						})
					}, this.getFlairSectionName = () => this.props.isBadgesAndEmotesEnabled ? p.fbt._("Badges, flair & emojis", null, {
						hk: "1FuDnm"
					}) : this.props.isPowerupsTabVisible ? p.fbt._("Flair", null, {
						hk: "1fYKUf"
					}) : p.fbt._("Flair & emojis", null, {
						hk: "42b2AJ"
					}), this.state = {
						locationSettingSeen: !0,
						showEmailInvitePaintedDoor: !1
					}
				}
				componentDidMount() {
					this.setState({
						locationSettingSeen: Object(K.G)("location")
					})
				}
				render() {
					const {
						props: e
					} = this, t = e.isEligibleForScheduledPosts && !e.isProfile || e.isTournamentsEnabled, n = e.isMediaInCommentsSettingShown && e.isImageCommentSettingExperimentEnabled;
					switch (e.pageName) {
						case f.mc.CommunitySettings: {
							const t = !e.subpageName || !Object.values(f.nc).includes(e.subpageName);
							return e.isProfile ? null : i.a.createElement(V.a.Consumer, null, s => i.a.createElement("div", {
								className: Object(c.a)(ae.a.navContainer, {
									[ae.a.navContainerExp]: s
								})
							}, i.a.createElement(ce, {
								onClick: this.onGoToModHub
							}), i.a.createElement(le.b, {
								label: p.fbt._("Community", null, {
									hk: "1EIoJe"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Community),
								path: `${e.subreddit.url}about/edit?page=community`,
								isActive: t || e.subpageName === f.nc.Community
							}), i.a.createElement(le.b, {
								label: p.fbt._("Safety and Privacy", null, {
									hk: "3E0TnI"
								}),
								isNew: e.showCrowdControlCampaign,
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Safety),
								path: `${e.subreddit.url}about/edit?page=safety`,
								isActive: e.subpageName === f.nc.Safety
							}), i.a.createElement(le.b, {
								label: p.fbt._("Posts and Comments", null, {
									hk: "2jt4ea"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Posts),
								path: `${e.subreddit.url}about/edit?page=posts`,
								isActive: e.subpageName === f.nc.Posts,
								isNew: n
							}), i.a.createElement(le.b, {
								label: p.fbt._("Wikis", null, {
									hk: "2X1iz1"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Wikis),
								path: `${e.subreddit.url}about/edit?page=wikis`,
								isActive: e.subpageName === f.nc.Wikis
							}), e.isContentTagEnabled && i.a.createElement(le.b, {
								label: p.fbt._("Content Tag", null, {
									hk: "VuxaQ"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.ContentTag),
								path: `${e.subreddit.url}about/edit?page=content_tag`,
								isActive: e.subpageName === f.nc.ContentTag
							}), i.a.createElement(le.b, {
								label: p.fbt._("Notifications", null, {
									hk: "SRNLx"
								}),
								onClick: () => this.trackCommunitySettingsNavItemClick(f.nc.Notifications),
								path: `${e.subreddit.url}about/edit?page=notifications`,
								isActive: e.subpageName === f.nc.Notifications
							})))
						}
						case f.mc.Wiki:
						case f.mc.WikiContributors:
						case f.mc.WikiBanned:
							return e.isProfile ? null : i.a.createElement(V.a.Consumer, null, t => i.a.createElement("div", {
								className: Object(c.a)(ae.a.navContainer, ae.a.wikiNavContainer, {
									[ae.a.navContainerExp]: t
								})
							}, i.a.createElement(ce, {
								onClick: this.onGoToModHub
							}), e.moderatorPermissions.wiki && i.a.createElement(He, {
								subreddit: e.subreddit
							})));
						default:
							return i.a.createElement(V.a.Consumer, null, s => i.a.createElement("div", {
								className: Object(c.a)(ae.a.navContainer, {
									[ae.a.navContainerExp]: s
								})
							}, e.moderatorPermissions.posts && !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "mod_queue",
								className: ae.a.iconStyles
							}), p.fbt._("Queues", null, {
								hk: "2BbIZV"
							})), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Modqueue,
								label: h(f.mc.Modqueue),
								onClick: this.onClickModQueue,
								path: `${e.subreddit.url}about/modqueue`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Reports,
								label: h(f.mc.Reports),
								onClick: this.onClickReports,
								path: `${e.subreddit.url}about/reports`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Spam,
								label: h(f.mc.Spam),
								onClick: this.onClickSpam,
								path: `${e.subreddit.url}about/spam`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Edited,
								label: h(f.mc.Edited),
								onClick: this.onClickEdited,
								path: `${e.subreddit.url}about/edited`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Unmoderated,
								label: h(f.mc.Unmoderated),
								onClick: this.onClickUnmoderated,
								path: `${e.subreddit.url}about/unmoderated`
							})), !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "user",
								className: ae.a.iconStyles
							}), p.fbt._("User management", null, {
								hk: "3G4BgD"
							})), e.moderatorPermissions.access && i.a.createElement(i.a.Fragment, null, i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Banned,
								label: h(f.mc.Banned),
								onClick: this.onClickBannedUsers,
								path: `${e.subreddit.url}about/banned`
							}), e.moderatorPermissions.mail && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Muted,
								label: h(f.mc.Muted),
								onClick: this.onClickMutedUsers,
								path: `${e.subreddit.url}about/muted`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Contributors,
								label: h(f.mc.Contributors),
								onClick: this.onClickApprovedSubmitters,
								path: `${e.subreddit.url}about/contributors`
							}), e.isTalkHostsExperimentEnabled && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.TalkHosts,
								label: h(f.mc.TalkHosts),
								onClick: this.onClickApprovedTalkHosts,
								path: `${e.subreddit.url}about/talkhosts`
							})), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Moderators,
								label: h(f.mc.Moderators),
								onClick: this.onClickModerators,
								path: `${e.subreddit.url}about/moderators`
							}), e.isEmailInviteExperimentEnabled && i.a.createElement(le.b, {
								label: p.fbt._("Bulk Email Invite", null, {
									hk: "3GTIEm"
								}),
								isNew: !0,
								onClick: this.onClickInviteViaEmail
							}), this.state.showEmailInvitePaintedDoor && i.a.createElement(H.a, {
								onClose: this.onCloseInviteViaEmailModal,
								sendEvent: e.sendEvent
							})), (e.moderatorPermissions.flair || e.moderatorPermissions.config) && !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "tag",
								className: ae.a.iconStyles
							}), this.getFlairSectionName()), e.moderatorPermissions.flair && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Flair,
								label: h(f.mc.Flair),
								onClick: this.onClickGrantUserFlair,
								path: `${e.subreddit.url}about/flair`
							}), e.moderatorPermissions.config && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Emojis,
								label: h(f.mc.Emojis),
								onClick: this.onClickEmojis,
								path: `${e.subreddit.url}about/emojis`
							}), e.moderatorPermissions.flair && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.UserFlair,
								label: h(f.mc.UserFlair),
								onClick: this.onClickUserFlair,
								path: `${e.subreddit.url}about/userflair`
							}), e.moderatorPermissions.flair && e.moderatorPermissions.config && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.PostFlair,
								label: h(f.mc.PostFlair),
								onClick: this.onClickPostFlair,
								path: `${e.subreddit.url}about/postflair`
							}), e.isBadgesAndEmotesEnabled && i.a.createElement(i.a.Fragment, null, i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Badges,
								label: h(f.mc.Badges),
								onClick: this.onClickBadges,
								path: `${e.subreddit.url}about/badges`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Emotes,
								label: h(f.mc.Emotes),
								onClick: this.onClickEmotes,
								path: `${e.subreddit.url}about/emotes`
							}))), (e.moderatorPermissions.config || e.moderatorPermissions.posts) && !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "rules",
								className: ae.a.iconStyles
							}), p.fbt._("Rules and regulations", null, {
								hk: "QAksk"
							})), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.SubredditRules,
								label: h(f.mc.SubredditRules),
								onClick: this.onClickRules,
								path: `${e.subreddit.url}about/rules`
							}), e.moderatorPermissions.posts && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Removal,
								label: h(f.mc.Removal),
								onClick: this.onClickRemovalReasons,
								path: `${e.subreddit.url}about/removal`
							}), e.moderatorPermissions.config && i.a.createElement(i.a.Fragment, null, i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.ContentControls,
								label: h(f.mc.ContentControls),
								onClick: this.onClickPostRequirements,
								path: `${e.subreddit.url}about/settings`,
								isNew: e.showHCFNewTagsCampaign
							}), i.a.createElement(le.b, {
								label: p.fbt._("Automod", null, {
									hk: "1IngsO"
								}),
								onClick: this.onClickAutomodConfig,
								path: `${e.subreddit.url}about/wiki/config/automoderator/`
							}))), t && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "list_bulleted",
								className: ae.a.iconStyles
							}), p.fbt._("Content", null, {
								hk: "IAh5R"
							})), e.isEligibleForScheduledPosts && !e.isProfile && i.a.createElement(i.a.Fragment, null, i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.ScheduledPostContent,
								label: p.fbt._("Scheduled posts", null, {
									hk: "11S6dN"
								}),
								onClick: this.onClickScheduledPosts,
								path: Object(Z.e)(e.subreddit.url)
							}), e.isEventPostUiHidden ? null : i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.EventPostContent,
								label: p.fbt._("Event posts", null, {
									hk: "3D98hc"
								}),
								onClick: this.onClickEventPosts,
								path: Object(Z.b)(e.subreddit.url)
							})), e.isTournamentsEnabled && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Predictions,
								label: p.fbt._("Predictions", null, {
									hk: "Serjr"
								}),
								onClick: this.onClickPredictions,
								path: Object(Z.d)(e.subreddit.url),
								isNew: !0
							})), (e.moderatorPermissions.config || e.moderatorPermissions.wiki) && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "settings",
								className: ae.a.iconStyles
							}), p.fbt._("Other", null, {
								hk: "ST5RE"
							})), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Awards,
								label: p.fbt._("Awards", null, {
									hk: "48U4Du"
								}),
								onClick: this.onClickAwards,
								path: `${e.subreddit.url}about/awards`
							}), e.moderatorPermissions.config && e.isPowerupsTabVisible && i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Powerups,
								label: p.fbt._("Powerups", null, {
									hk: "1fgdwA"
								}),
								onClick: this.onClickPowerups,
								path: `${e.subreddit.url}about/powerups`,
								isNew: !0
							}), e.moderatorPermissions.config && !e.isProfile && e.isBroadcastingEnabled && i.a.createElement(le.b, {
								label: h(f.mc.Streaming),
								onClick: this.onClickStreaming,
								path: `${e.subreddit.url}about/broadcasting`,
								isNew: !0
							}), e.moderatorPermissions.wiki && !e.isProfile && i.a.createElement(le.b, {
								label: p.fbt._("Wiki pages", null, {
									hk: "wShFl"
								}),
								onClick: this.onClickWikiPages,
								path: `${B.a.redditUrl}${e.subreddit.url}about/wiki/index/`
							}), e.moderatorPermissions.config && !e.isProfile && i.a.createElement(le.b, {
								label: p.fbt._("Community settings", null, {
									hk: "2xOUK6"
								}),
								onClick: this.onClickCommunitySettings,
								isNew: !this.state.locationSettingSeen || e.showCrowdControlCampaign || n,
								path: `${e.subreddit.url}about/edit?page=community`,
								showInboundArrow: !0
							}), e.moderatorPermissions.config && !e.isProfile && i.a.createElement(le.b, {
								label: p.fbt._("Community appearance", null, {
									hk: "3AHttA"
								}),
								path: `${e.subreddit.url}?styling=true`,
								onClick: this.onClickCommunityAppearance,
								showInboundArrow: !0
							})), e.moderatorPermissions.mail && !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "mod_mail",
								className: ae.a.iconStyles
							}), p.fbt._("Modmail", null, {
								hk: "Eh4Vu"
							})), i.a.createElement(le.b, {
								isExternal: !0,
								label: p.fbt._("Modmail", null, {
									hk: "3Xkgqo"
								}),
								onClick: this.onClickModMail,
								path: "https://mod.reddit.com"
							})), !e.isProfile && i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "statistics",
								className: ae.a.iconStyles
							}), p.fbt._("Community activity", null, {
								hk: "1vGSer"
							})), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Traffic,
								label: p.fbt._("Traffic stats", null, {
									hk: "vw5CU"
								}),
								onClick: this.onClickTraffic,
								path: `${e.subreddit.url}about/traffic`
							}), i.a.createElement(le.b, {
								isActive: e.pageName === f.mc.Modlog,
								label: h(f.mc.Modlog),
								onClick: this.onClickModLog,
								path: `${e.subreddit.url}about/log`
							})), i.a.createElement("div", {
								className: ae.a.navSection
							}, i.a.createElement("div", {
								className: ae.a.sectionHeader
							}, i.a.createElement(X.a, {
								name: "help",
								className: ae.a.iconStyles
							}), p.fbt._("Mod help center", null, {
								hk: "256YE"
							})), i.a.createElement(le.b, {
								isExternal: !0,
								label: p.fbt._("Mod help center", null, {
									hk: "4dCwWU"
								}),
								onClick: this.onClickModHelpCenter,
								path: B.a.redditModHelpUrl
							}), i.a.createElement(le.b, {
								isExternal: !0,
								label: p.fbt._("Moderator code of conduct", null, {
									hk: "fl2JE"
								}),
								onClick: this.onClickModGuidelines,
								path: "https://www.reddit.com/help/healthycommunities/"
							}), i.a.createElement(le.b, {
								isExternal: !0,
								label: "r/ModSupport",
								onClick: this.onClickModSupport,
								path: "/r/ModSupport/"
							}), i.a.createElement(le.b, {
								isExternal: !0,
								label: "r/ModHelp",
								onClick: this.onClickModHelp,
								path: "/r/modhelp/"
							}), i.a.createElement(le.b, {
								isExternal: !0,
								label: p.fbt._("Contact Reddit", null, {
									hk: "2NRBBx"
								}),
								onClick: this.onClickContactReddit,
								path: "https://www.reddithelp.com/hc/en-us/requests/new"
							}))))
					}
				}
			}
			var ze = Object(a.b)(We, e => ({
					pushUrl: t => e(Object(q.b)(t))
				}))(Object(_.c)(Object(G.c)(Object(W.b)(Ve)))),
				Ke = n("./src/reddit/pages/ModHub/Header.tsx"),
				Qe = n("./src/reddit/pages/ModHub/index.m.less"),
				Ye = n.n(Qe);
			const Je = u.a.div("BackgroundContainer", Ye.a),
				Xe = u.a.div("Body", Ye.a),
				Ze = Object(d.c)({
					contentGateInfo: (e, t) => Object(N.g)(e, t.match.params.subredditName)
				}),
				$e = Object(d.c)({
					queryParams: (e, t) => {
						let {
							location: n
						} = t;
						return r()([...Object(l.a)(n.search)])
					}
				}),
				et = Object(d.c)({
					moderatorPermissions: (e, t) => {
						var n;
						const {
							subredditName: s,
							profileName: r
						} = t.match.params, o = s ? Object(T.I)(e, s) : null === (n = Object(S.k)(e, {
							profileName: r
						})) || void 0 === n ? void 0 : n.id;
						if (o) return Object(k.n)(e, {
							subredditId: o
						})
					}
				}),
				tt = Object(d.c)({
					isContributor: (e, t) => {
						const {
							subredditName: n
						} = t.match.params;
						if (n) {
							const t = Object(T.z)(e, {
								subredditName: n
							});
							if (t) return t.userIsContributor
						}
						return !1
					}
				}),
				nt = Object(d.c)({
					subreddit: (e, t) => t.match.params.subredditName ? Object(T.C)(e, {
						subredditName: t.match.params.subredditName
					}) : Object(S.k)(e, {
						profileName: t.match.params.profileName
					})
				}),
				st = Object(a.b)(() => Object(d.a)(Ze, N.O, g.U, et, N.lb, I.mb, nt, tt, $e, j.a, (e, t) => t.match.params.pageName, e => e, (e, t, n, s, r, o, i, a, d, c, l, u) => {
					let {
						contentGateInfo: m
					} = e, {
						moderatorPermissions: p
					} = s, {
						subreddit: b
					} = i, {
						isContributor: f
					} = a, {
						queryParams: h
					} = d;
					const {
						after: _,
						afterEditable: g,
						before: v,
						beforeEditable: x,
						only: O,
						page: E,
						sort: j
					} = h;
					return {
						contentGateInfo: m,
						isBroadcastingEnabled: !!b && Object(w.c)(u, b.id),
						isTalkHostsEnabled: Object(C.p)(u),
						isContributor: f,
						isEmployee: t,
						layout: n,
						moderatorPermissions: p,
						isScheduledPostsEnabled: o,
						subreddit: b,
						renderNSFWContentGate: !!b && b.isNSFW && !r,
						page: `${E||y.b}`,
						pageName: l,
						postTypeFilter: O,
						after: _ || "",
						afterEditable: g,
						before: v,
						postSort: j,
						beforeEditable: x,
						isRealtimeMQUpdatesExperimentEnabled: c
					}
				})),
				rt = Object(g.v)();
			class ot extends i.a.Component {
				constructor() {
					super(...arguments), this.sendEventWithName = e => () => {
						this.props.sendEvent(t => ({
							source: e.includes("modqueue_sort") ? "moderator" : Object(O.b)(this.props.pageName),
							action: "click",
							noun: e,
							...E.b(t)
						}))
					}, this.onClickSubredditLink = () => {
						this.props.sendEvent(E.f())
					}
				}
				componentDidUpdate(e) {
					(this.props.pageName && this.props.pageName !== e.pageName || this.props.page && this.props.page !== e.page) && (document.documentElement.scrollTop = document.body.scrollTop = 0)
				}
				render() {
					const {
						props: e
					} = this;
					if (!e.subreddit) {
						const t = Object(x.a)(e.contentGateInfo, e.renderNSFWContentGate, e.match.params.subredditName);
						return t ? i.a.createElement(m.default, t) : null
					}
					const t = !!e.moderatorPermissions;
					return i.a.createElement(Je, null, i.a.createElement(Ke.a, {
						onClick: this.onClickSubredditLink,
						subredditOrProfile: e.subreddit,
						pageName: e.pageName ? h(e.pageName) : void 0
					}), i.a.createElement(Xe, null, e.moderatorPermissions && i.a.createElement(ze, {
						moderatorPermissions: e.moderatorPermissions,
						pageName: e.pageName,
						subpageName: e.page,
						subreddit: e.subreddit,
						isProfile: !!e.match.params.profileName
					}), i.a.createElement("div", {
						className: Object(c.a)(Ye.a.contentWrapper, t && Ye.a.isModerator)
					}, e.pageName && Object(v.a)({
						pageName: e.pageName,
						moderatorPermissions: e.moderatorPermissions,
						canCreateScheduledPosts: e.isScheduledPostsEnabled,
						isEmployee: e.isEmployee,
						isStreamingEnabled: e.isBroadcastingEnabled,
						isTalkHostsEnabled: e.isTalkHostsEnabled,
						subredditType: e.subreddit.type,
						isContributor: e.isContributor
					}) ? i.a.createElement(P.a, {
						after: e.after,
						afterEditable: e.afterEditable,
						before: e.before,
						beforeEditable: e.beforeEditable,
						isRealtimeMQUpdatesExperimentEnabled: e.isRealtimeMQUpdatesExperimentEnabled,
						layout: e.layout,
						moderatorPermissions: e.moderatorPermissions,
						page: e.page,
						pageName: e.pageName,
						postSort: e.postSort,
						postTypeFilter: e.postTypeFilter,
						sendEventWithName: this.sendEventWithName,
						subpageName: e.page,
						subreddit: e.subreddit
					}) : e.moderatorPermissions ? i.a.createElement(U, {
						subredditDisplayText: e.subreddit.displayText
					}) : i.a.createElement(R.a, {
						isModerator: t,
						subredditDisplayText: e.subreddit.displayText
					}))))
				}
			}
			t.default = rt(st(Object(_.c)(ot)))
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/EmptyStateComponent.tsx": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/react/index.js"),
				r = n.n(s),
				o = n("./src/reddit/helpers/trackers/inbox.ts"),
				i = n("./src/reddit/hooks/useTracking.ts"),
				a = n("./node_modules/fbt/lib/FbtPublic.js"),
				d = n("./src/lib/classNames/index.ts"),
				c = n("./src/config.ts"),
				l = n("./src/reddit/controls/Button/index.tsx"),
				u = n("./src/reddit/controls/InternalLink/index.tsx"),
				m = n("./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less"),
				p = n.n(m);

			function b() {
				return (b = Object.assign || function(e) {
					for (var t = 1; t < arguments.length; t++) {
						var n = arguments[t];
						for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
					}
					return e
				}).apply(this, arguments)
			}
			const f = ["r/somethingimade", "r/CasualConversation", "r/DoesAnybodyElse", "r/Old_Recipes"][Math.floor(100 * Math.random()) % 4];
			var h = e => {
				let {
					inTooltip: t,
					onBtnClick: n
				} = e;
				const s = `/${f}`,
					o = {
						to: s,
						kind: l.b.InternalLink
					},
					i = r.a.createElement(u.default, {
						to: s,
						target: "_blank",
						rel: "noopener noreferrer",
						className: p.a.subredditLinkR,
						onClick: n
					}, f);
				return r.a.createElement("div", {
					className: Object(d.a)(p.a.emptyState, p.a.karmaView, {
						[p.a.inNotificationsPage]: !t
					})
				}, r.a.createElement("img", {
					src: `${c.a.assetPath}/img/wrappedreddit/default_avatar.png`,
					alt: a.fbt._("default user avatar", null, {
						hk: "1VMTKf"
					}),
					className: Object(d.a)(p.a.avatarImage, {
						[p.a.inTooltip]: t
					})
				}), r.a.createElement("h1", {
					className: Object(d.a)(p.a.emptyTitle, {
						[p.a.inTooltip]: t
					})
				}, a.fbt._("You don’t have any activity yet", null, {
					hk: "43tvWW"
				})), r.a.createElement("p", {
					className: p.a.emptyDescription
				}, a.fbt._("That’s ok, maybe you just need the right inspiration. Try posting in {Link: to popular subreddit} , a popular community for discussion.", [a.fbt._param("Link: to popular subreddit", i)], {
					hk: "1WOK4T"
				})), r.a.createElement(l.t, b({
					className: p.a.emptyStateButton,
					onClick: n,
					text: `Visit ${f}`
				}, o)))
			};
			t.a = e => {
				let {
					inTooltip: t
				} = e;
				const n = Object(i.a)();
				return r.a.createElement(h, {
					inTooltip: t,
					onBtnClick: (e => () => n(Object(o.s)({
						actionInfoType: e
					})))(o.a.Karma)
				})
			}
		},
		"./src/reddit/pages/NotificationsInbox/Content/EmptyStateViews/index.m.less": function(e, t, n) {
			e.exports = {
				emptyState: "_3B_EfQMwEiEzc_9vEdVplz",
				emptyStateLoggedOutContainer: "_3AcDG0KjCxs3H1UW_4ajNf",
				emptyStateDivider: "bfJNAfRJ7wvCVMJIHbVa-",
				karmaView: "_3eBLRjkIDT-8Hobfrj_UTz",
				inNotificationsPage: "_2upiES-f8azWSz_UdoeHE7",
				avatarImage: "mGm_bo7f-d7T6Ax_UEs_l",
				inTooltip: "JBKRJW6IC_gf5qQ_mqb4A",
				catsImageWrapper: "odMqhFpc4xkpus4jHz_9f",
				cat: "_13uS-SsNmI2cGGsq2rpP8O",
				top: "_29krHC0w9xxlGw1mBpwNHU",
				bottom: "_3VkvX9EbwQAVQJ3qEl_wzw",
				cloud: "_3yAL94u5AxUY-JhhHIPNuU",
				yummy: "_2TY8uYFieKTHl7jN_vmcYR",
				memesImageWrapper: "jaQ0krPJ6FkjLU-VDMGNq",
				shrek: "_1f1-1KlOtH3uQKPHzkGdDI",
				star: "_2mEU_pG_y9L4CaC7zihby0",
				inBottom: "_1kfecAwlZWu6be_WDfvh-P",
				inCenter: "_4DkJv1On5ORUXrwzznhqE",
				inTop: "_1lJAHwdJYzqn-69JkG-HJQ",
				emptyStateButton: "_1_kVxSQ5_eQNTfI-Y89mu4",
				loggedOutState: "_3uw_OsQCi8zOpS3fha4JEF",
				emptyStateWithBanner: "_1L4nSUqK39ZB-E1-MXtBve",
				emptyTitle: "_36brOzjH6sE_rgnTt-hcL1",
				emptyDescription: "Ae79bDDbZ2U_G-wqwA71z",
				subredditLinkR: "_9DV1fqkU31oi8pfSQxzjw",
				BellOutline: "_23NDu_VaLgaSWVzKHs-Gfa",
				bellOutline: "_23NDu_VaLgaSWVzKHs-Gfa"
			}
		},
		"./src/reddit/reducers/economics/paymentSystems/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			var s, r = n("./src/reddit/actions/economics/paymentSystems/constants.ts");
			! function(e) {
				e[e.Failure = 0] = "Failure", e[e.Fetched = 1] = "Fetched", e[e.NotFetched = 2] = "NotFetched", e[e.Pending = 3] = "Pending"
			}(s || (s = {}));
			const o = {
				status: s.NotFetched
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						if (e.status === s.Fetched && e.data.stripe && e.data.stripe.sources) {
							const n = t.payload.cardId,
								{
									[n]: s,
									...r
								} = e.data.stripe.sources;
							return {
								...e,
								data: {
									...e.data,
									stripe: {
										...e.data.stripe,
										sources: r
									}
								}
							}
						}
						return e;
					case r.e:
						if (e.status === s.Fetched && e.data.braintree && e.data.braintree.sources) {
							const n = t.payload.sourceId,
								{
									[n]: s,
									...r
								} = e.data.braintree.sources;
							return {
								...e,
								data: {
									...e.data,
									braintree: {
										...e.data.braintree,
										sources: r
									}
								}
							}
						}
						return e;
					case r.b:
						return {
							error: t.payload.error, status: s.Failure
						};
					case r.c:
						return {
							data: t.payload, status: s.Fetched
						};
					case r.d:
						return {
							status: s.Pending
						};
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/economics/subredditPremium/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./src/lib/constants/specialMembership.ts"),
				o = n("./src/reddit/actions/economics/subredditPremium/constants.ts"),
				i = n("./src/reddit/helpers/economics/sortBadges.ts"),
				a = n("./src/reddit/models/Badge/index.ts"),
				d = n("./src/reddit/models/Badge/managementPage.ts");
			! function(e) {
				e[e.NotFetched = 0] = "NotFetched", e[e.Fetched = 1] = "Fetched"
			}(s || (s = {}));
			const c = {};

			function l(e) {
				return "userId" in e
			}

			function u(e, t, n, s) {
				e.forEach(e => {
					e.collections && Object.keys(e.collections).forEach(r => {
						let o;
						(o = e.placement ? e.placement === a.a.First ? s[d.a.Loyalty][r] : s[d.a.Achievement][r] : l(e) ? s[d.a.Cosmetic][d.c.MyBadges][r] : s[d.a.Cosmetic][d.c.Gallery][r]) && (l(e) ? n.has(e.id) && o.unlocked.push(e) : t.has(e.id) || o.locked.push(e))
					})
				})
			}

			function m(e) {
				const t = (e, t) => {
					const n = parseInt(e.price || "0"),
						s = parseInt(t.price || "0");
					return n === s ? Object(i.b)(e, t) : n - s
				};
				return e.locked.sort(t), e.unlocked.sort(t), e
			}

			function p(e, t) {
				return Object.keys(e).map(t => e[t]).filter(e => !!e.locked.length || !!e.unlocked.length || e.id === r.a).map(m).sort((e, n) => {
					const s = t[e.id],
						r = t[n.id];
					return Object(i.b)(s, r)
				})
			}

			function b(e) {
				const t = {
					[d.a.Loyalty]: {},
					[d.a.Achievement]: {},
					[d.a.Cosmetic]: {
						[d.c.Gallery]: {},
						[d.c.MyBadges]: {}
					}
				};
				Object.keys(e.collections).forEach(n => {
					const s = e.collections[n],
						r = {
							description: s.description,
							highlight: s.extra && s.extra.style && s.extra.style.color,
							id: s.id,
							locked: [],
							title: s.title,
							unlocked: []
						};
					t[d.a.Loyalty][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Achievement][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.Gallery][n] = {
						...r,
						locked: [],
						unlocked: []
					}, t[d.a.Cosmetic][d.c.MyBadges][n] = {
						...r,
						locked: [],
						unlocked: []
					}
				});
				const n = new Set;
				e.userOwnedBadges.forEach(t => {
					const s = e.badges[t];
					s && n.add(s.type)
				});
				const s = new Set(e.userOwnedBadges);
				return u(Object.keys(e.badges).map(t => e.badges[t]), n, s, t), u(Object.keys(e.products).map(t => e.products[t]), n, s, t), {
					collections: {
						[d.a.Loyalty]: p(t[d.a.Loyalty], e.collections),
						[d.a.Achievement]: p(t[d.a.Achievement], e.collections),
						[d.a.Cosmetic]: {
							[d.c.Gallery]: p(t[d.a.Cosmetic][d.c.Gallery], e.collections),
							[d.c.MyBadges]: p(t[d.a.Cosmetic][d.c.MyBadges], e.collections)
						}
					},
					subscription: e.subscription,
					userOwnedBadges: e.userOwnedBadges.map(t => e.badges[t]).filter(Boolean)
				}
			}
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case o.a: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data
								},
								raw: {
									...r.raw
								}
							}
						} : e
					}
					case o.h: {
						const {
							subredditId: n
						} = t.payload, r = e[n];
						return r && r.status === s.Fetched ? {
							...e,
							[n]: {
								...r,
								data: {
									...r.data,
									subscription: {
										...r.data.subscription || {},
										settings: {
											renew: !1
										}
									}
								},
								raw: {
									...r.raw,
									subscription: {
										...r.raw.subscription || {},
										settings: {
											renew: !1
										}
									}
								}
							}
						} : e
					}
					case o.i: {
						const n = t.payload;
						return {
							...e,
							[n.subredditId]: {
								raw: n,
								data: b(n),
								status: s.Fetched
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/avatar/index.ts": function(e, t, n) {
			"use strict";
			var s, r, o = n("./node_modules/redux/es/redux.js"),
				i = n("./src/reddit/actions/snoovatar.ts");
			! function(e) {
				e.PREMIUM = "PREMIUM"
			}(s || (s = {})),
			function(e) {
				e[e.BACKGROUND = 0] = "BACKGROUND", e[e.ACCESSORY_BACK = 1] = "ACCESSORY_BACK", e[e.HAIR_BACK = 2] = "HAIR_BACK", e[e.BODY_BOTTOM = 3] = "BODY_BOTTOM", e[e.BODY = 4] = "BODY", e[e.ACCESSORY = 5] = "ACCESSORY", e[e.FACE_LOWER = 6] = "FACE_LOWER", e[e.FACE_UPPER = 7] = "FACE_UPPER", e[e.HAIR = 8] = "HAIR", e[e.HEAD_ACCESSORY = 9] = "HEAD_ACCESSORY"
			}(r || (r = {}));
			const a = {
				id: "",
				csrf_token: "",
				snoovatar: null,
				websocketsUrls: {
					renderer: "",
					download: ""
				},
				capabilities: [s.PREMIUM],
				hasActiveClosetSubscription: !1
			};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.b:
						return {
							...t.payload
						};
					default:
						return e
				}
			};
			const c = {
					marketingEvent: {
						active: !1,
						assetUrls: null,
						experimentRequired: null
					},
					quickCreateV1: {
						id: "-1",
						active: !1,
						text: "",
						min_days_on_reddit: 0,
						should_have_avatar: !1,
						max_event_views: 0,
						min_days_since_last_event_interaction: 0,
						webAssetUrls: []
					}
				},
				l = "avatar_quick_create_event",
				u = "avatar_marketing_event",
				m = "avatar_promo_archived",
				p = e => {
					const t = {};
					return e.forEach(e => {
						if (e.startsWith("targeting:")) {
							const n = e.split(":");
							if (!n.length && n.length < 3) return null;
							try {
								t[n[1]] = JSON.parse(n[2])
							} catch {
								t[n[1]] = n[2]
							}
						}
					}), t
				};

			function b(e) {
				if (!e) return c;
				const t = c;
				return e.forEach(e => {
					var n;
					const {
						startsAt: s,
						endsAt: r,
						webAssetUrls: o,
						tags: i
					} = e, a = s && new Date(s) <= new Date, d = !!r && new Date(r) < new Date, c = !!a && !d, b = (i || []).includes(m);
					if (i && i.includes(l) && !b) {
						const {
							text: n,
							id: s
						} = e, r = o || null, a = p(i);
						t && (t.quickCreateV1 = {
							...a,
							id: s,
							text: n,
							active: c && !!r,
							webAssetUrls: r
						})
					}
					if (i && i.includes(u) && !b) {
						const e = o || null,
							s = (null === (n = i.find(e => e.startsWith("feature:") && e.includes("web"))) || void 0 === n ? void 0 : n.split("feature:")[1]) || null;
						t && (t.marketingEvent = {
							active: c && !!e,
							assetUrls: e,
							experimentRequired: s
						})
					}
				}), t
			}
			var f = n("./src/reddit/actions/goldPurchaseModals/constants.ts"),
				h = n("./src/reddit/actions/modal.ts"),
				_ = n("./src/reddit/constants/modals.ts");
			var g = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case f.s:
						const {
							avatarMarketingEvents: s
						} = t.payload;
						return s ? b(s) : c;
					case h.c:
						return (null === (n = t.payload) || void 0 === n ? void 0 : n.id) === _.a.SNOOVATAR_MODAL ? c : e;
					default:
						return e
				}
			};
			var v = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.a: {
						const {
							image: e,
							accessory_ids: n
						} = t.payload;
						return {
							image: e,
							accessoryIds: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(o.c)({
				marketing: g,
				avatarUser: d,
				randomAvatar: v
			})
		},
		"./src/reddit/reducers/features/creatorStats/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/creatorStats/constants.ts");
			const o = {};
			var i = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postOtherDiscussions: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const a = {};
			var d = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							postStats: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			const c = {};
			var l = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : c,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.a:
						const {
							subredditKarma: n
						} = t.payload;
						return {
							...e, ...n
						};
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				postOtherDiscussions: i,
				postStats: d,
				subredditKarma: l
			})
		},
		"./src/reddit/reducers/features/crypto/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/economics/claims/constants.ts")),
				o = n("./src/reddit/actions/economics/me/constants.ts");
			const i = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case o.a: {
							const n = t.payload.claimPoints || {},
								s = Object.keys(n).reduce((t, s) => (t[s] = {
									...e[s],
									availableClaims: n[s]
								}, t), {});
							return Object.keys(e).forEach(t => {
								var n;
								(null === (n = e[t]) || void 0 === n ? void 0 : n.isClaiming) && (s[t] = s[t] || {
									availableClaims: []
								}, s[t].isClaiming = !0)
							}), s
						}
						case r.b:
						case r.a:
							const {
								subredditId: n
							} = t.payload;
							return {
								...e, [n]: {
									...e[n],
									isClaiming: t.type === r.b
								}
							};
						default:
							return e
					}
				},
				d = n("./src/reddit/actions/governance/constants.ts");
			const c = 15e4,
				l = {},
				u = {
					filled: "img/communityPoints/default_filled.png",
					grey: "img/communityPoints/default_grey.png"
				};

			function m(e) {
				var t, n, s, r, o;
				const i = null === (t = e.walletProvider) || void 0 === t ? void 0 : t.extra,
					a = null == i ? void 0 : i.contracts,
					d = null == a ? void 0 : a.unlocked,
					l = null !== (s = null === (n = e.walletProvider) || void 0 === n ? void 0 : n.provider) && void 0 !== s ? s : e.provider,
					m = !!(null === (r = e.walletProvider) || void 0 === r ? void 0 : r.inTransition),
					p = null == i ? void 0 : i.metaTransactions,
					b = (null == p ? void 0 : p.allowedContractMethods) || {},
					f = (null == p ? void 0 : p.gasLimit) || c,
					h = (null == d ? void 0 : d.decimals) || 0,
					_ = "1" + "0".repeat(h);
				return {
					allowedContractMethods: b,
					blockchainProvider: l,
					contractAddress: (null == d ? void 0 : d.address) || "",
					contracts: a,
					decimals: h,
					displayConversion: _,
					gasLimit: f,
					images: e.images || u,
					inTransition: m,
					name: e.name,
					nomenclature: null === (o = e.extra) || void 0 === o ? void 0 : o.nomenclature,
					polls: e.polls,
					symbol: (null == d ? void 0 : d.token) || ""
				}
			}
			var p = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.a: {
						const {
							subredditId: n,
							meta: s
						} = t.payload;
						return {
							...e,
							[n]: m(s)
						}
					}
					default:
						return e
				}
			};
			const b = {};
			var f = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.n: {
						const {
							subredditId: n,
							wallets: s
						} = t.payload, r = Object.keys(s).reduce((t, r) => {
							return {
								...t,
								[r]: {
									...e[r] || {},
									[n]: s[r]
								}
							}
						}, {});
						return {
							...e,
							...r
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				claims: a,
				points: p,
				publicWallets: f
			})
		},
		"./src/reddit/reducers/features/modActivitySummaries/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/reddit/actions/modQueue/constants.ts");
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case s.l: {
						const {
							summary: n,
							subreddit: s
						} = t.payload;
						return {
							...e,
							[s.id]: {
								...e[s.id],
								...n
							}
						}
					}
					case s.i:
					case s.f:
					case s.r:
					case s.u:
					case s.A: {
						const {
							response: n
						} = t.payload;
						return {
							...e,
							...n.modActivitySummaries
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/features/modUserNotes/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U:
						case r.T:
							return null;
						case r.S:
							return t.payload;
						default:
							return e
					}
				},
				i = n("./src/reddit/models/SubredditModeration/index.ts");
			const a = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.U: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(i.d)(n, s, r);
							return {
								...e,
								[o]: !0
							}
						}
						case r.T:
						case r.S: {
							const {
								subredditId: n,
								userId: s,
								filter: r
							} = t.payload, o = Object(i.d)(n, s, r);
							return {
								...e,
								[o]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: n,
								userId: s,
								filter: r,
								fetchedToken: o
							} = t.payload, a = Object(i.d)(n, s, r, o);
							return {
								...e,
								[a]: !0
							}
						}
						default:
							return e
					}
				},
				m = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/redditGQL/types.ts"));
			const p = e => `${e.subredditId}--${e.bannedAtUTC}-usernote`,
				b = e => `${e.subredditId}--${e.bannedAtUTC}-actionnote`,
				f = e => {
					const t = p(e),
						{
							modNote: n
						} = e;
					return n ? {
						__typename: "ModUserNote",
						id: t,
						itemType: m.y.Ban,
						createdAt: new Date(1e3 * e.bannedAtUTC),
						operator: {
							id: e.bannedById,
							displayName: e.bannedBy
						},
						user: {
							id: e.id,
							displayName: e.username
						},
						label: m.F.Ban,
						note: n
					} : null
				},
				h = e => {
					return {
						__typename: "ModActionNote",
						id: b(e),
						itemType: m.y.Ban,
						createdAt: new Date(1e3 * e.bannedAtUTC),
						operator: {
							id: e.bannedById,
							displayName: e.bannedBy
						},
						user: {
							id: e.id,
							displayName: e.username
						},
						description: e.banMessage,
						longDescription: e.banMessage,
						banDays: e.duration,
						isPermanentBan: !e.duration
					}
				},
				_ = {};
			var g = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(i.d)(n, s.user.id, m.x.All);
						return {
							...e,
							[r]: s.id
						}
					}
					case r.H: {
						const {
							subredditId: s,
							lastAuthorModNote: r
						} = t.payload, o = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id, a = Object(i.d)(s, o, m.x.All);
						return {
							...e,
							[a]: r.id
						}
					}
					case r.G: {
						const {
							subredditId: n,
							lastAuthorModNotes: s
						} = t.payload, r = {};
						return s.forEach(e => {
							var t;
							const s = null === (t = null == e ? void 0 : e.user) || void 0 === t ? void 0 : t.id,
								o = Object(i.d)(n, s, m.x.All);
							r[o] = e.id
						}), {
							...e,
							...r
						}
					}
					case r.p: {
						const {
							bannedUsers: n
						} = t.payload, s = Object.values(n)[0], {
							subredditId: r
						} = s, o = s.id;
						if (!s.modNote) return e;
						const a = p(s),
							d = Object(i.d)(r, o, m.x.All);
						return {
							...e,
							[d]: a
						}
					}
					default:
						return e
				}
			};
			const v = {};
			var x = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.T: {
							const {
								subredditId: e,
								userId: n,
								filter: s,
								loadMoreToken: r
							} = t.payload;
							return {
								[Object(i.d)(e, n, s)]: r
							}
						}
						default:
							return e
					}
				},
				O = n("./node_modules/icepick/icepick.js");
			const E = {};
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Q: {
							const {
								newModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.H: {
							const {
								lastAuthorModNote: n
							} = t.payload;
							return {
								...e,
								[n.id]: n
							}
						}
						case r.G: {
							const {
								lastAuthorModNotes: n
							} = t.payload;
							return Object(O.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.T: {
							const {
								notes: n
							} = t.payload;
							return Object(O.merge)(e, n.reduce((e, t) => (e[t.id] = t, e), {}))
						}
						case r.R: {
							const {
								noteId: n
							} = t.payload, s = {
								...e
							};
							return delete s[n], s
						}
						case r.p: {
							const {
								bannedUsers: n
							} = t.payload;
							return Object(O.merge)(e, Object.values(n).reduce((e, t) => {
								const n = b(t),
									s = h(t);
								e[n] = s;
								const r = p(t),
									o = f(t);
								return o ? (e[r] = o, e) : e
							}, {}))
						}
						default:
							return e
					}
				},
				C = n("./node_modules/lodash/uniq.js"),
				j = n.n(C);
			const k = {};
			var I = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: s,
							newModNote: r,
							filter: o
						} = t.payload;
						if (o !== m.x.All && o !== m.x.Note) return e;
						const a = null === (n = null == r ? void 0 : r.user) || void 0 === n ? void 0 : n.id,
							d = Object(i.d)(s, a, o),
							c = o === m.x.All ? m.x.Note : m.x.All,
							l = Object(i.d)(s, a, c);
						return {
							...e,
							[d]: e[d] ? [r.id, ...e[d]] : [r.id],
							[l]: e[l] ? [r.id, ...e[l]] : [r.id]
						}
					}
					case r.T: {
						const {
							notes: n,
							subredditId: s,
							userId: r,
							filter: o
						} = t.payload, a = Object(i.d)(s, r, o), d = n.map(e => e.id);
						return e[a] ? {
							...e,
							[a]: j()([...e[a], ...d])
						} : {
							...e,
							[a]: d
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s,
							noteId: r
						} = t.payload, o = Object(i.d)(n, s, m.x.All), a = Object(i.d)(n, s, m.x.Note), d = e[o] ? e[o].filter(e => e !== r) : [], c = e[a] ? e[a].filter(e => e !== r) : [];
						return {
							...e,
							...e[o] ? {
								[o]: d
							} : null,
							...e[a] ? {
								[a]: c
							} : null
						}
					}
					case r.p: {
						const {
							bannedUsers: n
						} = t.payload, s = Object.values(n)[0], {
							subredditId: r
						} = s, o = s.id, a = Object(i.d)(r, o, m.x.All), d = Object(i.d)(r, o, m.x.Note), c = Object(i.d)(r, o, m.x.Ban), l = b(s), u = p(s), f = e[a] ? [u, l, ...e[a]] : [], h = e[d] ? [u, ...e[d]] : [], _ = e[c] ? [l, ...e[c]] : [];
						return {
							...e,
							...e[a] ? {
								[a]: f
							} : null,
							...e[d] ? {
								[d]: h
							} : null,
							...e[c] ? {
								[c]: _
							} : null
						}
					}
					default:
						return e
				}
			};
			const S = {};
			var w = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : S,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Q: {
						const {
							subredditId: n,
							newModNote: s
						} = t.payload, r = Object(i.d)(n, s.user.id, m.x.All);
						return {
							...e,
							[r]: {
								...e[r],
								[m.x.All]: (e[r][m.x.All] || 0) + 1,
								[m.x.Note]: (e[r][m.x.Note] || 0) + 1
							}
						}
					}
					case r.lb: {
						const {
							subredditId: n,
							userId: s,
							totalCounts: r
						} = t.payload, o = Object(i.d)(n, s, m.x.All);
						return {
							...e,
							[o]: Object.keys(r).reduce((e, t) => (e[t] = r[t].totalCount, e), {})
						}
					}
					case r.R: {
						const {
							subredditId: n,
							userId: s
						} = t.payload, r = Object(i.d)(n, s, m.x.All);
						return {
							...e,
							...void 0 !== e[r] ? {
								[r]: {
									...e[r],
									[m.x.All]: (e[r][m.x.All] || 1) - 1,
									[m.x.Note]: (e[r][m.x.Note] || 1) - 1
								}
							} : null
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: c,
				fetchedTokens: u,
				lastAuthorModNotes: g,
				loadMore: x,
				models: y,
				order: I,
				totalCount: w
			})
		},
		"./src/reddit/reducers/features/realtimeModqueue/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/modQueue/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								targetID: n
							} = t.payload;
							return e.includes(n) ? e : [...e, n]
						}
						case r.p: {
							const {
								targetID: n
							} = t.payload, s = e.indexOf(n);
							return s > -1 && e.splice(s, 1), e
						}
						default:
							return e
					}
				},
				i = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/reddit/actions/comment/constants.ts")),
				a = n("./src/reddit/actions/platform.ts"),
				d = n("./src/reddit/actions/post.ts");
			const c = ["isApproved", "isRemoved", "isSpam"];
			var l = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case i.q:
					case d.k: {
						const n = t.payload;
						return Object.keys(n).map(t => {
							const s = Object.keys(n[t]);
							let r = !1;
							s.map(e => {
								c.includes(e) && (r = !0)
							}), !e.includes(t) && r && (e = [...e, t])
						}), e
					}
					case r.p: {
						const {
							targetID: n
						} = t.payload;
						return e.includes(n) ? e : [...e, n]
					}
					case a.f:
						return [];
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				toUpdate: o,
				updated: l
			})
		},
		"./src/reddit/reducers/features/userFlair/index.ts": function(e, t, n) {
			"use strict";
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/omit.js"),
				r = n.n(s),
				o = n("./src/reddit/actions/grantUserFlair/constants.ts"),
				i = n("./src/reddit/actions/modQueue/constants.ts"),
				a = n("./src/reddit/actions/pages/constants.ts"),
				d = n("./src/reddit/actions/pages/postCreation.ts"),
				c = n("./src/reddit/actions/pages/postDraft.ts"),
				l = n("./src/reddit/actions/pages/subreddit.ts"),
				u = n("./src/reddit/actions/userFlair/constants.ts");
			const m = {};
			t.a = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
					t = arguments.length > 1 ? arguments[1] : void 0;
				var n, s, p, b, f;
				switch (t.type) {
					case l.SUBREDDIT_LOADED:
					case d.PAGE_LOADED:
					case c.PAGE_LOADED:
					case a.b:
					case a.f:
					case u.k:
						return {
							...e, ...t.payload.userFlair
						};
					case i.i:
					case i.f:
					case i.r:
					case i.u:
					case i.A: {
						const {
							response: n
						} = t.payload, {
							userFlair: s
						} = n, r = {
							...e
						};
						return Object.keys(s).forEach(e => {
							r[e] || (r[e] = s[e])
						}), r
					}
					case u.r: {
						const {
							subredditId: n,
							applied: s,
							displaySettings: r
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								...s && {
									applied: s
								},
								displaySettings: r
							}
						}
					}
					case o.h: {
						const {
							subredditId: n,
							applied: s
						} = t.payload;
						return {
							...e,
							[n]: {
								...e[n],
								applied: s
							}
						}
					}
					case u.j: {
						const {
							subredditId: n,
							isEnabled: s
						} = t.payload, r = {
							...e[n].displaySettings,
							isEnabled: s
						};
						return {
							...e,
							[n]: {
								...e[n],
								displaySettings: r
							}
						}
					}
					case u.d: {
						const {
							subredditId: s,
							canAssignOwn: r
						} = t.payload, o = {
							...null === (n = e[s]) || void 0 === n ? void 0 : n.permissions,
							canAssignOwn: r
						};
						return {
							...e,
							[s]: {
								...e[s],
								permissions: o
							}
						}
					}
					case u.q: {
						const n = t.payload,
							r = e[n.subredditId],
							o = null === (s = e[n.subredditId]) || void 0 === s ? void 0 : s.templates,
							i = null === (p = e[n.subredditId]) || void 0 === p ? void 0 : p.templateIds,
							a = (null === (b = n.template) || void 0 === b ? void 0 : b.id) || (null === (f = n.template) || void 0 === f ? void 0 : f.templateId);
						if (!a) return;
						const d = {
								...o,
								[a]: n.template
							},
							c = [...i];
						return c.includes(a) || c.push(a), {
							...e,
							[n.subredditId]: {
								...r,
								templates: d,
								templateIds: c
							}
						}
					}
					case u.g: {
						const n = t.payload,
							s = e[n.subredditId],
							o = e[n.subredditId].templates,
							i = e[n.subredditId].templateIds,
							a = r()(o, n.templateId),
							d = i.filter(e => e !== n.templateId);
						return {
							...e,
							[n.subredditId]: {
								...s,
								templates: {
									...a
								},
								templateIds: d
							}
						}
					}
					case u.m:
					case u.l: {
						const n = t.payload,
							s = e[n.subredditId];
						return {
							...e,
							[n.subredditId]: {
								...s,
								templateIds: n.templateIds
							}
						}
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/pages/comments/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/ads/constants.ts");
			const o = [];
			var i = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.u:
							return t.payload;
						case r.v:
						default:
							return e
					}
				},
				a = n("./src/reddit/actions/pages/constants.ts");
			const d = {};
			var c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : d,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.d:
					case a.b:
					case a.h:
					case a.f: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					case a.a:
					case a.e: {
						const {
							key: n,
							error: s
						} = t.payload;
						return {
							...e,
							[n]: s || {}
						}
					}
					default:
						return e
				}
			};
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.c:
					case a.g: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !0
						}
					}
					case a.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: !1
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.d:
						case a.h:
						case a.i: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !0
							}
						}
						case a.b:
						case a.a:
						case a.f:
						case a.e: {
							const {
								key: n
							} = t.payload;
							return {
								...e,
								[n]: !1
							}
						}
						default:
							return e
					}
				},
				b = Object(s.c)({
					error: c,
					fullyLoaded: u,
					pending: p
				}),
				f = n("./src/reddit/actions/comment/constants.ts");
			const h = [];
			var _ = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case f.I:
							return e.find(e => t.payload.id === e.id) ? [...e.filter(e => t.payload.id !== e.id)] : [...e, t.payload];
						case f.b:
							return [...e.filter(e => e.expiresAt > Date.now())];
						case f.w:
							return [...t.payload.comments];
						default:
							return e
					}
				},
				g = n("./src/reddit/actions/comment/websocket/constants.ts"),
				v = (n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./node_modules/lodash/uniqBy.js")),
				x = n.n(v);

			function O(e) {
				return x()(e, "id").sort((e, t) => e.created - t.created)
			}

			function E(e, t) {
				return O([...t || [], e])
			}

			function y(e, t) {
				return t && t.length > 0 ? t.filter(t => t.id !== e) : []
			}

			function C(e, t) {
				const n = e.isStickied ? t && t.created || Math.round(Date.now() / 1e3) : e.created;
				return {
					id: e.id,
					created: n,
					stickied: e.isStickied,
					authorId: e.authorId
				}
			}

			function j(e, t) {
				return Object.values(e).map(e => C(e, t))
			}
			const k = {};
			var I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case a.f:
						case f.y:
						case a.b: {
							const {
								comments: n,
								key: s
							} = t.payload, r = e[s] ? e[s] : [], o = j(n, r.find(e => e.stickied)), i = O([...r, ...o]);
							return {
								...e,
								[s]: [...i]
							}
						}
						case g.b:
						case g.c:
						case g.d: {
							const {
								comment: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: E(C(n), e[s])
							}
						}
						case f.N:
						case f.M: {
							const {
								draftKey: n,
								comment: s,
								commentsPageKey: r
							} = t.payload;
							return {
								...e,
								[r]: y(n, E(C(s), e[r]))
							}
						}
						case f.L: {
							const {
								optimisticComment: n,
								commentsPageKey: s
							} = t.payload;
							return n ? {
								...e,
								[s]: E(C(n), e[s])
							} : e
						}
						case f.H: {
							const {
								commentId: n,
								commentsPageKey: s
							} = t.payload;
							return {
								...e,
								[s]: y(n, e[s])
							}
						}
						default:
							return e
					}
				},
				S = n("./node_modules/lodash/mapValues.js"),
				w = n.n(S),
				T = n("./src/reddit/helpers/commentList/index.ts"),
				N = n("./src/reddit/models/Comment/index.ts");
			const P = {};

			function R(e) {
				const t = e;
				return w()(t, e => {
					let {
						depth: t,
						next: n,
						prev: s
					} = e;
					return {
						depth: t,
						next: n,
						prev: s
					}
				})
			}
			var A = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case f.y: {
						const {
							comments: n,
							commentLists: s,
							continueThreads: r,
							key: o,
							moreCommentsItem: i,
							moreComments: a
						} = t.payload, d = s[i.postId], c = e[o], l = {}, u = c[i.id];
						if (u && u.prev) {
							const {
								id: e
							} = u.prev;
							l[e] = {
								...c[e],
								next: d.head || u.next
							}
						}
						if (u && u.next) {
							const {
								id: e
							} = u.next;
							l[e] = {
								...c[e],
								prev: d.tail || u.prev
							}
						}
						if (d.head && d.tail) {
							const e = Object(T.c)({
									commentLink: d.head,
									commentsDict: n,
									moreCommentsDict: a,
									continueThreadDict: r
								}),
								t = Object(T.c)({
									commentLink: d.tail,
									commentsDict: n,
									moreCommentsDict: a,
									continueThreadDict: r
								});
							u && (e.prev = u.prev, t.next = u.next)
						}
						return {
							...e,
							[o]: {
								...e[o],
								...R(n),
								...R(r),
								...R(a),
								...l
							}
						}
					}
					case a.b:
					case a.f: {
						const {
							comments: n,
							continueThreads: s,
							key: r,
							moreComments: o
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r],
								...R(n),
								...R(s),
								...R(o)
							}
						}
					}
					case g.b:
					case f.N: {
						const {
							comment: n,
							commentsPageKey: s,
							headCommentId: r
						} = t.payload, o = e[s], i = {};
						let a = null;
						return r && (i[r] = {
							...o[r],
							prev: Object(N.i)(n.id)
						}, a = Object(N.i)(r)), {
							...e,
							[s]: {
								...e[s],
								...i,
								[n.id]: {
									depth: 0,
									next: a,
									prev: null
								}
							}
						}
					}
					case f.M: {
						const {
							comment: n,
							commentsPageKey: s,
							parentCommentId: r,
							depth: o
						} = t.payload, i = e[s], a = {};
						let d = null;
						if (!i[r]) return e;
						const c = i[r].next;
						return c && (a[c.id] = {
							...i[c.id],
							prev: Object(N.i)(n.id)
						}, d = c), a[r] = {
							...i[r],
							next: Object(N.i)(n.id)
						}, {
							...e,
							[s]: {
								...e[s],
								...a,
								[n.id]: {
									depth: o,
									next: d,
									prev: Object(N.i)(r)
								}
							}
						}
					}
					default:
						return e
				}
			};
			const M = {};
			var L = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case g.b:
					case g.c:
					case f.N: {
						const {
							comment: n,
							commentsPageKey: s
						} = t.payload;
						return {
							...e,
							[s]: n.id
						}
					}
					case a.b:
					case a.f: {
						const {
							commentLists: n,
							key: s,
							postId: r
						} = t.payload;
						return {
							...e,
							[s]: n[r] && n[r].head ? n[r].head.id : null
						}
					}
					case a.i: {
						const {
							key: n
						} = t.payload;
						return {
							...e,
							[n]: null
						}
					}
					default:
						return e
				}
			};
			const D = {};
			var F = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : D,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case a.d:
					case a.b:
					case a.c:
					case a.h: {
						const {
							key: n,
							postId: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					case f.N: {
						const {
							parentId: n,
							commentsPageKey: s
						} = t.payload;
						return e[s] ? e : {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			t.a = Object(s.c)({
				api: b,
				followed: _,
				keyToChatCommentLinks: I,
				keyToCommentThreadLinkSets: A,
				keyToHeadCommentId: L,
				keyToPostId: F,
				ads: i
			})
		},
		"./src/reddit/reducers/pages/modHub/index.ts": function(e, t, n) {
			"use strict";
			var s = n("./node_modules/redux/es/redux.js"),
				r = n("./src/reddit/actions/subredditModeration/constants.ts");
			var o = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g:
						case r.f:
							return null;
						case r.e:
							return t.payload;
						default:
							return e
					}
				},
				i = n("./src/reddit/models/SubredditModeration/index.ts");
			const a = {};
			var d = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.g: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.f:
						case r.e: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				c = Object(s.c)({
					error: o,
					pending: d
				});
			const l = {};
			var u = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : l,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.f: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(i.e)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const m = {};
			var p = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: e,
								after: n
							} = t.payload;
							return {
								[e]: n
							}
						}
						default:
							return e
					}
				},
				b = n("./node_modules/icepick/icepick.js");
			const f = {};
			var h = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.d:
					case r.f: {
						const {
							subredditId: n,
							approvedSubmitters: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.k: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var _ = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.j:
					case r.i:
						return null;
					case r.h:
						return t.payload;
					default:
						return e
				}
			};
			var g = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return !0;
						case r.i:
						case r.h:
							return !1;
						default:
							return e
					}
				},
				v = Object(s.c)({
					error: _,
					pending: g
				});
			var x = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.j:
							return null;
						case r.i: {
							const e = t.payload.approvedSubmitterIds[0];
							return e ? t.payload.approvedSubmitters[e] : null
						}
						default:
							return e
					}
				},
				O = Object(s.c)({
					api: v,
					result: x
				});
			const E = {};
			var y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : E,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.f: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.k: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.d: {
							const {
								subredditId: n,
								approvedSubmitterIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				C = Object(s.c)({
					api: c,
					fetchedTokens: u,
					loadMore: p,
					models: h,
					search: O,
					userOrder: y
				});
			var j = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.n:
					case r.m:
						return null;
					case r.l:
						return t.payload;
					default:
						return e
				}
			};
			const k = {};
			var I = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : k,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.n: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.f)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.m:
						case r.l: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.f)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				S = Object(s.c)({
					error: j,
					pending: I
				});
			const w = {};
			var T = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : w,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							fetchedToken: n,
							subredditId: s
						} = t.payload, r = Object(i.f)(s, n);
						return {
							...e,
							[r]: !0
						}
					}
					default:
						return e
				}
			};
			const N = {};
			var P = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.m: {
						const {
							subredditId: e,
							loadMoreToken: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const R = {};
			var A = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : R,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.m: {
							const {
								subredditId: n,
								approvedTalkHosts: s,
								forceRefresh: r
							} = t.payload, o = {
								[n]: [...r ? [] : e[n] || [], ...s]
							};
							return Object(b.merge)(e, o)
						}
						case r.o: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								[n]: e[n].filter(e => e.redditor.id !== s)
							};
							return Object(b.merge)(e, r)
						}
						default:
							return e
					}
				},
				M = Object(s.c)({
					api: S,
					fetchedTokens: T,
					loadMore: P,
					models: A
				}),
				L = n("./src/reddit/actions/grantUserFlair/constants.ts");
			var D = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g:
					case L.i:
						return null;
					case L.f:
						return t.payload;
					default:
						return e
				}
			};
			var F = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.i:
							return !0;
						case L.g:
						case L.f:
							return !1;
						default:
							return e
					}
				},
				U = Object(s.c)({
					error: D,
					pending: F
				}),
				B = n("./node_modules/lodash/merge.js"),
				q = n.n(B),
				G = n("./node_modules/lodash/omit.js"),
				H = n.n(G);
			const W = {};
			var V = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : W,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g:
					case L.k: {
						const {
							subredditId: n,
							flairedUsers: s
						} = t.payload;
						return q()({
							...e
						}, {
							[n]: s
						})
					}
					case L.c: {
						const {
							subredditId: n,
							userName: s
						} = t.payload, r = H()(e[n], s);
						return {
							...e,
							[n]: r
						}
					}
					case L.a:
					case L.b:
					case L.h:
						const {
							subredditId: n, userName: s, applied: r
						} = t.payload;
						return r ? {
							...e,
							[n]: {
								...e[n],
								[s]: r
							}
						} : e;
					default:
						return e
				}
			};
			const z = {};
			var K = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : z,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.g: {
						const {
							key: n,
							pageInfo: s
						} = t.payload;
						return {
							...e,
							[n]: s
						}
					}
					default:
						return e
				}
			};
			var Q = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case L.l:
					case L.k:
						return null;
					case L.j:
						return t.payload;
					default:
						return e
				}
			};
			var Y = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.l:
							return !0;
						case L.k:
						case L.j:
							return !1;
						default:
							return e
					}
				},
				J = Object(s.c)({
					error: Q,
					pending: Y
				});
			var X = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.k: {
							const {
								searchResult: e
							} = t.payload;
							return e
						}
						case L.c: {
							const {
								userName: n
							} = t.payload;
							return e === n ? null : e
						}
						default:
							return e
					}
				},
				Z = Object(s.c)({
					api: J,
					result: X
				});
			const $ = {};
			var ee = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case L.g: {
							const {
								key: n,
								userOrder: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case L.a: {
							const {
								key: n,
								userName: s
							} = t.payload;
							if (!n) return e;
							if (!e[n].includes(s)) {
								const t = [...e[n], s];
								return {
									...e,
									[n]: t
								}
							}
							return e
						}
						case L.c: {
							const {
								userName: n
							} = t.payload, s = {};
							for (const t in e) s[t] = e[t].filter(e => e !== n);
							return s
						}
						default:
							return e
					}
				},
				te = Object(s.c)({
					api: U,
					models: V,
					pageInfo: K,
					search: Z,
					userOrder: ee
				}),
				ne = n("./src/reddit/actions/moderationLog/constants.ts");
			const se = {};
			var re = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : se,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.b: {
						const {
							normalizedCategories: n
						} = t.payload;
						return Object(b.merge)(e, n)
					}
					default:
						return e
				}
			};
			const oe = {};
			var ie = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : oe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							actionIds: n,
							key: s,
							subredditId: r
						} = t.payload;
						return {
							...e,
							[r]: {
								...e[r] || {},
								[s]: n
							}
						}
					}
					default:
						return e
				}
			};
			const ae = {};
			var de = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ae,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								normalizedModerationLog: n,
								subredditId: s
							} = t.payload, r = {};
							n.forEach(e => {
								r[e.id] = e
							});
							const o = {
								[s]: r
							};
							return q()({
								...e
							}, o)
						}
						default:
							return e
					}
				},
				ce = Object(s.c)({
					itemOrder: ie,
					models: de
				});
			var le = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							approximateCount: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			var ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							endCursor: e
						} = t.payload;
						return e
					}
					default:
						return e
				}
			};
			const me = {};
			var pe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : me,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasNextPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			const be = {};
			var fe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : be,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.c: {
						const {
							hasPreviousPage: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			const he = [];
			var _e = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : he,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case ne.a: {
						const {
							normalizedModerators: n,
							subredditId: s
						} = t.payload;
						return {
							...e,
							[s]: n
						}
					}
					default:
						return e
				}
			};
			var ge = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case ne.c: {
							const {
								startCursor: e
							} = t.payload;
							return e
						}
						default:
							return e
					}
				},
				ve = Object(s.c)({
					actionCategories: re,
					actions: ce,
					approximateCount: le,
					endCursor: ue,
					hasNextPage: pe,
					hasPreviousPage: fe,
					moderators: _e,
					startCursor: ge
				});
			const xe = {};
			var Oe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : xe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.O:
					case r.y: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload.response || t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.C: {
						const {
							subredditId: n,
							userId: s,
							permissions: r
						} = t.payload;
						return Object(b.setIn)(e, [n, s, "modPermissions"], r)
					}
					case r.jb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			const Ee = {};
			var ye = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ee,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.z:
					case r.y: {
						const {
							key: n,
							subredditId: s
						} = t.payload;
						return s ? {
							...e,
							[n]: null
						} : e
					}
					case r.x: {
						const {
							error: n,
							key: s,
							subredditId: r
						} = t.payload;
						return r ? {
							...e,
							[s]: n
						} : e
					}
					default:
						return e
				}
			};
			const Ce = {};
			var je = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ce,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.x:
						case r.y: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.z: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				ke = Object(s.c)({
					error: ye,
					pending: je
				});
			const Ie = {};
			var Se = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ie,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.y: {
							const {
								subredditId: n,
								response: s,
								key: r
							} = t.payload;
							return Object(b.setIn)(e, [n, r], s.moderatorIds)
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s,
								key: r
							} = t.payload, o = e[n][r].filter(e => e !== s);
							return Object(b.setIn)(e, [n, r], o)
						}
						default:
							return e
					}
				},
				we = Object(s.c)({
					data: Se,
					api: ke
				});
			var Te = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.F:
					case r.E:
						return null;
					case r.D:
						return t.payload;
					default:
						return e
				}
			};
			var Ne = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E:
						case r.D:
							return !1;
						case r.F:
							return !0;
						default:
							return e
					}
				},
				Pe = Object(s.c)({
					error: Te,
					pending: Ne
				});
			const Re = {};
			var Ae = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Re,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.E: {
						const {
							subredditId: n,
							moderators: s
						} = t.payload;
						return Object(b.set)(e, n, s)
					}
					case r.gb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					case r.c: {
						const n = t.payload,
							{
								subredditId: s,
								moderators: r
							} = n,
							o = {
								[s]: r
							};
						return Object(b.merge)(e, o)
					}
					default:
						return e
				}
			};
			const Me = {};
			var Le = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Me,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.E: {
							const {
								subredditId: n,
								moderatorIds: s
							} = t.payload;
							return {
								...e,
								[n]: s
							}
						}
						case r.gb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = e[n].filter(e => e !== s);
							return {
								...e,
								[n]: r
							}
						}
						case r.c: {
							const n = t.payload,
								{
									subredditId: s,
									moderatorIds: r
								} = n,
								o = [...e[s] || [], ...r];
							return {
								...e,
								[s]: o
							}
						}
						default:
							return e
					}
				},
				De = Object(s.c)({
					api: Pe,
					models: Ae,
					userOrder: Le
				});
			const Fe = {};
			var Ue = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Fe,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							subredditId: n,
							response: s
						} = t.payload, {
							invitePending: r
						} = s, o = {
							[n]: r
						};
						return Object(b.merge)(e, o)
					}
					case r.I:
					case r.J: {
						const {
							subredditId: n
						} = t.payload;
						return Object(b.unset)(e, n)
					}
					default:
						return e
				}
			};
			const Be = {};
			var qe = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Be,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.y: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const Ge = {};
			var He = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ge,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: e
						} = t.payload;
						return {
							[e.subredditId]: {
								after: e.after,
								before: e.before
							}
						}
					}
					default:
						return e
				}
			};
			const We = {};
			var Ve = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : We,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.L: {
						const {
							response: n
						} = t.payload, s = {
							[n.subredditId]: n.moderators
						};
						return Object(b.merge)({
							...e
						}, s)
					}
					case r.C: {
						const n = t.payload,
							{
								subredditId: s,
								userId: r,
								permissions: o
							} = n;
						return e[s] && e[s][r] ? Object(b.setIn)(e, [s, r, "modPermissions"], o) : e
					}
					default:
						return e
				}
			};
			var ze = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.P:
					case r.O:
						return null;
					case r.N:
						return t.payload;
					default:
						return e
				}
			};
			var Ke = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
							return !0;
						case r.O:
						case r.N:
							return !1;
						default:
							return e
					}
				},
				Qe = Object(s.c)({
					error: ze,
					pending: Ke
				}),
				Ye = n("./node_modules/lodash/isEqual.js"),
				Je = n.n(Ye);
			var Xe = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.P:
						case r.N:
						case r.jb:
							return null;
						case r.O: {
							const e = t.payload.moderatorIds[0];
							return e ? t.payload.moderators[e] : null
						}
						case r.C: {
							const {
								userId: n,
								permissions: s
							} = t.payload;
							return e && e.id === n && !Je()(e.modPermissions, s) ? {
								...e,
								modPermissions: s
							} : e
						}
						default:
							return e
					}
				},
				Ze = Object(s.c)({
					api: Qe,
					result: Xe
				});
			const $e = {};
			var et = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $e,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.M:
					case r.L: {
						const {
							subredditId: n,
							key: s
						} = t.payload;
						return n ? {
							...e,
							[s]: null
						} : e
					}
					case r.K: {
						const {
							error: n,
							subredditId: s,
							key: r
						} = t.payload;
						return s ? {
							...e,
							[r]: n
						} : e
					}
					default:
						return e
				}
			};
			const tt = {};
			var nt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.K:
						case r.L: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !1
							} : e
						}
						case r.M: {
							const {
								subredditId: n,
								key: s
							} = t.payload;
							return n ? {
								...e,
								[s]: !0
							} : e
						}
						default:
							return e
					}
				},
				st = Object(s.c)({
					error: et,
					pending: nt
				});
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			const rt = {};
			var ot = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.L: {
							const {
								response: n,
								subredditId: s,
								key: r
							} = t.payload, {
								moderatorIds: o
							} = n;
							return Object(b.merge)(e, {
								[s]: {
									[r]: o
								}
							})
						}
						case r.jb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload, r = {
								...e[n]
							};
							return Object.keys(e[n]).forEach(t => {
								const o = e[n][t].filter(e => e !== s);
								r[t] = o
							}), Object(b.set)(e, n, r)
						}
						default:
							return e
					}
				},
				it = Object(s.c)({
					data: ot,
					api: st
				}),
				at = Object(s.c)({
					editableModerators: Oe,
					editableUserOrder: we,
					invitedModerators: De,
					invitePending: Ue,
					loadMoreModerators: He,
					loadMoreEditableModerators: qe,
					models: Ve,
					search: Ze,
					userOrder: it
				}),
				dt = n("./src/reddit/actions/bulkActions/constants.ts");
			var ct = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.c:
						case dt.b:
							return null;
						case dt.a:
							return t.payload;
						default:
							return e
					}
				},
				lt = n("./src/reddit/actions/modQueue/constants.ts");
			var ut = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.c:
							return !0;
						case dt.b:
						case dt.a:
						case lt.x:
						case lt.w:
							return !1;
						default:
							return e
					}
				},
				mt = Object(s.c)({
					error: ct,
					pending: ut
				});
			const pt = {};
			var bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : pt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.a: {
							const {
								ids: n
							} = t.payload, s = {};
							return n.forEach(e => s[e] = !0), {
								...e,
								...s
							}
						}
						case lt.d: {
							const {
								ids: n
							} = t.payload;
							return H()(e, n)
						}
						case lt.c: {
							const {
								ids: e
							} = t.payload, n = {};
							return e.forEach(e => n[e] = !0), n
						}
						default:
							return e
					}
				},
				ft = n("./src/reddit/models/ModQueue/index.ts");
			const ht = {};
			var _t = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ht,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case dt.b: {
							const {
								operation: e,
								ids: n
							} = t.payload;
							return "approve" === e ? ht : {
								[ft.c[e]]: n
							}
						}
						default:
							return e
					}
				},
				gt = Object(s.c)({
					api: mt,
					selectedItems: bt,
					undoLastAction: _t
				});
			var vt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.g:
					case lt.f:
						return null;
					case lt.e:
						return t.payload;
					default:
						return e
				}
			};
			var xt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.g:
							return !0;
						case lt.f:
						case lt.e:
							return !1;
						default:
							return e
					}
				},
				Ot = Object(s.c)({
					error: vt,
					pending: xt
				});
			const Et = {};
			var yt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Et,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.f: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Ct = {};
			var jt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ct,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.f: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				kt = Object(s.c)({
					api: Ot,
					itemOrder: yt,
					loadMore: jt
				}),
				It = n("./src/reddit/actions/pages/modListing/constants.ts");
			var St = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case It.e: {
						const n = t.payload,
							{
								moderatingSubreddits: s
							} = n;
						return s ? null : e
					}
					case lt.i:
					case lt.f:
					case lt.r:
					case lt.u:
					case lt.A: {
						const {
							response: e
						} = t.payload, {
							moderatedAfter: n
						} = e;
						return n
					}
					case lt.n: {
						const e = t.payload,
							{
								moderatedAfter: n
							} = e;
						return n
					}
					default:
						return e
				}
			};
			const wt = [];
			var Tt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.i:
					case lt.f:
					case lt.r:
					case lt.u:
					case lt.A: {
						const {
							response: e
						} = t.payload, {
							listingOrder: n
						} = e;
						return n
					}
					case lt.n: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return [...e, ...s]
					}
					case It.e: {
						const n = t.payload,
							{
								listingOrder: s
							} = n;
						return s || e
					}
					default:
						return e
				}
			};
			var Nt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.b:
						return !0;
					default:
						return e
				}
			};
			var Pt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.n:
							return !0;
						case lt.b:
							return !1;
						default:
							return e
					}
				},
				Rt = Object(s.c)({
					after: St,
					data: Tt,
					loaded: Nt,
					pending: Pt
				});
			var At = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.j:
					case lt.i:
						return null;
					case lt.h:
						return t.payload;
					default:
						return e
				}
			};
			var Mt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.j:
							return !0;
						case lt.i:
						case lt.h:
							return !1;
						default:
							return e
					}
				},
				Lt = Object(s.c)({
					error: At,
					pending: Mt
				});
			const Dt = {};
			var Ft = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Dt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.i: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Ut = {};
			var Bt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ut,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.i: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				qt = Object(s.c)({
					api: Lt,
					itemOrder: Ft,
					loadMore: Bt
				});
			var Gt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.s:
					case lt.r:
						return null;
					case lt.q:
						return t.payload;
					default:
						return e
				}
			};
			var Ht = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.s:
							return !0;
						case lt.r:
						case lt.q:
							return !1;
						default:
							return e
					}
				},
				Wt = Object(s.c)({
					error: Gt,
					pending: Ht
				});
			const Vt = {};
			var zt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vt,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.r: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const Kt = {};
			var Qt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Kt,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.r: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				Yt = Object(s.c)({
					api: Wt,
					itemOrder: zt,
					loadMore: Qt
				});
			var Jt = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.v:
					case lt.u:
						return null;
					case lt.t:
						return t.payload;
					default:
						return e
				}
			};
			var Xt = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.v:
							return !0;
						case lt.u:
						case lt.t:
							return !1;
						default:
							return e
					}
				},
				Zt = Object(s.c)({
					error: Jt,
					pending: Xt
				});
			const $t = {};
			var en = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $t,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.u: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const tn = {};
			var nn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : tn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.u: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				sn = Object(s.c)({
					api: Zt,
					itemOrder: en,
					loadMore: nn
				});
			var rn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.B:
					case lt.A:
						return null;
					case lt.z:
						return t.payload;
					default:
						return e
				}
			};
			var on = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.B:
							return !0;
						case lt.A:
						case lt.z:
							return !1;
						default:
							return e
					}
				},
				an = Object(s.c)({
					error: rn,
					pending: on
				});
			const dn = {};
			var cn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case lt.A: {
						const {
							listingKey: n,
							page: s,
							response: r
						} = t.payload, {
							modqueue: o
						} = r;
						return {
							...e,
							[n]: {
								...e[n] || {},
								[s]: o
							}
						}
					}
					default:
						return e
				}
			};
			const ln = {};
			var un = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ln,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case lt.A: {
							const {
								listingKey: n,
								response: s
							} = t.payload, {
								modqueue: r
							} = s, o = r[r.length - 1] || null;
							return {
								...e,
								[n]: o
							}
						}
						default:
							return e
					}
				},
				mn = Object(s.c)({
					api: an,
					itemOrder: cn,
					loadMore: un
				}),
				pn = Object(s.c)({
					bulkAction: gt,
					edited: kt,
					moderatedCommunitiesOrder: Rt,
					modqueue: qt,
					reports: Yt,
					spam: sn,
					unmoderated: mn
				});
			var bn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.Y:
					case r.W:
						return null;
					case r.V:
						return t.payload;
					default:
						return e
				}
			};
			const fn = {};
			var hn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.Y: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !0
							}
						}
						case r.W:
						case r.V: {
							const {
								subredditId: n,
								fetchedToken: s
							} = t.payload, r = Object(i.e)(n, s);
							return {
								...e,
								[r]: !1
							}
						}
						default:
							return e
					}
				},
				_n = Object(s.c)({
					error: bn,
					pending: hn
				});
			const gn = {};
			var vn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								fetchedToken: n,
								subredditId: s
							} = t.payload, r = Object(i.e)(s, n);
							return {
								...e,
								[r]: !0
							}
						}
						default:
							return e
					}
				},
				xn = n("./src/reddit/actions/inContextModeration.ts");
			var On = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case xn.b:
						return t.payload;
					default:
						return e
				}
			};
			const En = {};
			var yn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : En,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.W: {
						const {
							subredditId: e,
							after: n
						} = t.payload;
						return {
							[e]: n
						}
					}
					default:
						return e
				}
			};
			const Cn = {};
			var jn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cn,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.X:
					case r.W: {
						const {
							subredditId: n,
							mutedUsers: s
						} = t.payload, r = {
							[n]: s
						};
						return Object(b.merge)(e, r)
					}
					case r.cb: {
						const {
							subredditId: n,
							userId: s
						} = t.payload;
						return Object(b.unsetIn)(e, [n, s])
					}
					default:
						return e
				}
			};
			var kn = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case r.bb:
					case r.ab:
						return null;
					case r.Z:
						return t.payload;
					default:
						return e
				}
			};
			var In = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
							return !0;
						case r.ab:
						case r.Z:
							return !1;
						default:
							return e
					}
				},
				Sn = Object(s.c)({
					error: kn,
					pending: In
				});
			var wn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.bb:
						case r.Z:
							return null;
						case r.ab: {
							const e = t.payload.mutedUserIds[0];
							return e ? t.payload.mutedUsers[e] : null
						}
						default:
							return e
					}
				},
				Tn = Object(s.c)({
					api: Sn,
					result: wn
				});
			const Nn = {};
			var Pn = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nn,
						t = arguments.length > 1 ? arguments[1] : void 0;
					switch (t.type) {
						case r.W: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload;
							return e[n] ? {
								...e,
								[n]: [...e[n], ...s]
							} : {
								...e,
								[n]: s
							}
						}
						case r.cb: {
							const {
								subredditId: n,
								userId: s
							} = t.payload;
							return {
								[n]: e[n].filter(e => e !== s)
							}
						}
						case r.X: {
							const {
								subredditId: n,
								mutedUserIds: s
							} = t.payload, r = s[0];
							return r && e[n] && -1 === e[n].indexOf(r) ? {
								[n]: [r, ...e[n]]
							} : e
						}
						default:
							return e
					}
				},
				Rn = Object(s.c)({
					api: _n,
					fetchedTokens: vn,
					inContext: On,
					loadMore: yn,
					models: jn,
					search: Tn,
					userOrder: Pn
				});
			t.a = Object(s.c)({
				approvedSubmitters: C,
				approvedTalkHosts: M,
				flairedUsers: te,
				moderationLog: ve,
				moderators: at,
				modQueue: pn,
				muted: Rn
			})
		},
		"./src/reddit/reducers/tags/selected/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/uniqWith.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/values.js"),
				a = n.n(i),
				d = n("./src/reddit/actions/tags/constants.ts"),
				c = n("./src/reddit/models/Option/index.ts"),
				l = n("./src/reddit/models/Tags/index.ts");
			! function(e) {
				e.ADD = "ADD", e.REMOVE = "REMOVE"
			}(s || (s = {}));
			const u = {
				selectedPrimaryTagId: {},
				selectedOptions: {},
				selectedSuggestedOptions: {},
				deselectedOptions: {},
				deselectedSuggestedOptions: {},
				inputByItemId: {},
				suggestedInputByItemId: {}
			};
			t.b = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : u,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case d.w:
					case d.r: {
						const {
							subredditId: n,
							itemTags: s,
							suggestedItemTags: r,
							primaryTag: i
						} = t.payload, d = o()([...(e.selectedOptions[n] || []).map(e => {
							if (!e.id) {
								const t = a()(s[n] || {}).find(t => e.displayText.toLowerCase().trim() === t.tag.text.toLowerCase().trim());
								if (t) return {
									...Object(l.e)(t, !0),
									action: null
								}
							}
							return e
						}), ...a()(s[n] || {}).map(e => ({
							...Object(l.e)(e, !0),
							action: null
						}))], c.a);
						let u = e.selectedPrimaryTagId;
						return i && (u = {
							...u,
							[n]: i.tag.id
						}), {
							...e,
							selectedOptions: {
								...e.selectedOptions,
								[n]: d.map(e => ({
									...e,
									action: e.id ? null : e.action
								}))
							},
							selectedSuggestedOptions: {
								...e.selectedSuggestedOptions,
								[n]: a()(r[n] || {}).map(e => ({
									...Object(l.e)(e, !0),
									action: null
								}))
							},
							deselectedOptions: {
								...e.deselectedOptions,
								[n]: []
							},
							selectedPrimaryTagId: u
						}
					}
					case d.D:
					case d.z: {
						const {
							subredditId: n,
							option: r
						} = t.payload, i = t.type === d.z ? "selectedOptions" : "selectedSuggestedOptions", a = t.type === d.z ? "deselectedOptions" : "deselectedSuggestedOptions", l = (e[a][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						let m = s.ADD;
						return u > -1 && (m = null, l.splice(u, 1)), {
							...e,
							[i]: {
								...e[i],
								[n]: o()([...e[i][n] || [], {
									...r,
									action: m
								}], c.a)
							},
							[a]: {
								...e[a],
								[n]: l
							}
						}
					}
					case d.C:
					case d.y: {
						const {
							subredditId: n,
							option: r
						} = t.payload, o = t.type === d.y ? "selectedOptions" : "selectedSuggestedOptions", i = t.type === d.y ? "deselectedOptions" : "deselectedSuggestedOptions", a = (e[i][n] || []).slice(), l = (e[o][n] || []).slice(), u = l.findIndex(e => Object(c.a)(e, r));
						return u > -1 && (null === l[u].action && a.push({
							...l[u],
							action: s.REMOVE
						}), l.splice(u, 1)), {
							...e,
							[o]: {
								...e[o],
								[n]: l
							},
							[i]: {
								...e[i],
								[n]: a
							}
						}
					}
					case d.A: {
						const {
							itemTagsState: n
						} = t.payload, s = Object.keys(n);
						if (!s.length) return e;
						const r = {
								selectedOptions: {},
								deselectedOptions: {},
								inputByItemId: {}
							},
							o = s.reduce((e, t) => (e.selectedOptions[t] = a()(n[t]).map(e => ({
								...Object(l.e)(e, !0),
								action: null
							})), e.deselectedOptions[t] = [], e.inputByItemId[t] = "", e), r);
						return {
							...e,
							inputByItemId: {
								...e.inputByItemId,
								...o.inputByItemId
							},
							selectedOptions: {
								...e.selectedOptions,
								...o.selectedOptions
							},
							deselectedOptions: {
								...e.deselectedOptions,
								...o.deselectedOptions
							}
						}
					}
					case d.B:
					case d.x: {
						const {
							subredditId: n,
							input: s
						} = t.payload, r = t.type === d.x ? "inputByItemId" : "suggestedInputByItemId";
						return {
							...e,
							[r]: {
								...e[r],
								[n]: s
							}
						}
					}
					case d.i:
					case d.h: {
						const {
							subredditId: n,
							primaryTagId: s
						} = t.payload;
						if (!s || !n) return e;
						const r = {
								...e,
								selectedPrimaryTagId: {
									...e.selectedPrimaryTagId,
									[n]: s
								}
							},
							o = e.selectedOptions[n];
						if (o) {
							const t = o.findIndex(e => e.id === s),
								i = [...o];
							return t >= 0 && i.splice(t, 1), {
								...r,
								selectedOptions: {
									...e.selectedOptions,
									[n]: i
								}
							}
						}
						return r
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/reducers/user/prefs/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return G
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s, r = n("./node_modules/lodash/isEqual.js"),
				o = n.n(r),
				i = n("./node_modules/lodash/merge.js"),
				a = n.n(i),
				d = n("./node_modules/lodash/pick.js"),
				c = n.n(d),
				l = n("./src/lib/constants/index.ts"),
				u = n("./src/reddit/actions/comment/constants.ts"),
				m = n("./src/reddit/actions/contentGate.ts"),
				p = n("./src/reddit/actions/frontpage/constants.ts"),
				b = n("./src/reddit/actions/header.ts"),
				f = n("./src/reddit/actions/modQueue/constants.ts"),
				h = n("./src/reddit/actions/pages/constants.ts"),
				_ = n("./src/reddit/actions/pages/modListing/constants.ts"),
				g = n("./src/reddit/actions/pages/multireddit/constants.ts"),
				v = n("./src/reddit/actions/pages/postCreation.ts"),
				x = n("./src/reddit/actions/pages/postDraft.ts"),
				O = n("./src/reddit/actions/pages/profileComments/constants.ts"),
				E = n("./src/reddit/actions/pages/profileOverview/constants.ts"),
				y = n("./src/reddit/actions/pages/profilePosts.ts"),
				C = n("./src/reddit/actions/pages/search/index.ts"),
				j = n("./src/reddit/actions/pages/subreddit.ts"),
				k = n("./src/reddit/actions/pages/topic.ts"),
				I = n("./src/reddit/actions/postCreation/constants.ts"),
				S = n("./src/reddit/actions/postDraft.ts"),
				w = n("./src/reddit/actions/preferences.ts"),
				T = n("./src/reddit/actions/redditEmbed.ts"),
				N = n("./src/reddit/actions/search.ts"),
				P = n("./src/reddit/actions/structuredStyles/constants.ts"),
				R = n("./src/reddit/actions/subreddit.ts"),
				A = n("./src/reddit/actions/users.ts"),
				M = n("./src/reddit/constants/postLayout.ts"),
				L = n("./src/reddit/constants/preferences.ts"),
				D = n("./src/reddit/constants/theme.ts"),
				F = n("./src/reddit/models/PostCreationForm/index.ts"),
				U = n("./src/reddit/models/PostDraft/index.ts"),
				B = n("./src/reddit/models/User/index.ts");
			! function(e) {
				e.Whitelisted = "whitelisted", e.Everyone = "everyone"
			}(s || (s = {}));
			const q = ["acceptPrivateMessages", "allowClickTracking", "autoplayVideo", "collapseReadMessages", "defaultCommentSort", "emailDigests", "emailUnreadMessages", "emailUnsubscribe", "enableFollowers", "feedRecommendationsEnabled", "geopopular", "hideAds", "hideFromRobots", "hideNSFW", "highlightComments", "ignoreSuggestedSort", "inBeta", "labelNSFW", "liveBarRecommendationsEnabled", "markMessagesRead", "nightmode", "over18", "sendWelcomeMessages", "showMessagesInInbox", "showNotifications", "showTwitter", "showUsernameMentionNotifications", "showActiveCommunities", "showPresence", ...L.a, "loginOtpEnabled"],
				G = {
					acceptPrivateMessages: void 0,
					activityRelevantAds: !0,
					allowClickTracking: !1,
					autoplayVideo: !0,
					collapsedTraySections: B.a,
					commentMode: F.i.RICH_TEXT,
					countryCode: "",
					badCommentAutocollapse: l.n.OFF,
					layout: M.d.Card,
					rememberCommunityLayout: !1,
					defaultCommentSort: l.w.CONFIDENCE,
					editorMode: F.i.RICH_TEXT,
					enableFollowers: !0,
					geopopular: void 0,
					globalTheme: D.a,
					hamburgerTray: void 0,
					hasSeenCustomizeFlyout: !0,
					hideNSFW: !0,
					ignoreSuggestedSort: !1,
					labelNSFW: !0,
					liveBarRecommendationsEnabled: !0,
					loginOtpEnabled: !1,
					markMessagesRead: !0,
					nightmode: !1,
					openPostInNewTab: !1,
					over18: !1,
					profileLayout: void 0,
					reduceAnimationsFromAwards: !1,
					rpanDuDismissalTime: void 0,
					showActiveCommunities: !0,
					showPresence: !1,
					showRpanDu: !0,
					showTwitter: !1,
					sort: l.db.Hot,
					stylesEnabled: !0,
					subreddit: {},
					subscriptionsPinned: void 0,
					surveyLastSeenTime: void 0,
					thirdPartyDataPersonalizedAds: !0,
					thirdPartyPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedAds: !0,
					thirdPartySiteDataPersonalizedContent: !0,
					showLocationBasedRecommendations: !0,
					topContentDismissalTime: 0,
					topContentTimesDismissed: 0,
					rememberCommunitySort: !1,
					useMarkdown: !1,
					gatedSubredditOptIn: !1,
					quarantineOptIn: !1
				},
				H = {
					rpanDuDismissalTime: void 0,
					isContributorRequestTimestamp: 0,
					stylesEnabled: !0,
					layout: void 0,
					sort: void 0
				},
				W = (e, t) => {
					if (!t) return e;
					const n = c()({
							...t.account,
							...t
						}, q),
						s = t.subreddit,
						r = {
							...e.subreddit
						};
					Object.keys(s || {}).forEach(e => {
						r[e] = {
							...H,
							...s && s[e]
						}
					});
					const i = {
						...e,
						...n,
						subreddit: r
					};
					if (i.useMarkdown !== e.useMarkdown) {
						const e = i.useMarkdown ? F.i.MARKDOWN : F.i.RICH_TEXT;
						i.editorMode = e, i.commentMode = e
					}
					return o()(i, e) ? e : i
				},
				V = (e, t, n) => W(e, {
					subreddit: {
						[t]: {
							...H,
							...e.subreddit[t],
							...n
						}
					}
				});
			t.c = function() {
				let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : G,
					t = arguments.length > 1 ? arguments[1] : void 0;
				switch (t.type) {
					case u.o:
					case u.v: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							commentMode: n
						}
					}
					case I.s:
					case I.Q: {
						const {
							editorMode: n
						} = t.payload;
						return {
							...e,
							editorMode: n
						}
					}
					case b.d:
						return {
							...e, subscriptionsPinned: !0
						};
					case b.e:
						return {
							...e, subscriptionsPinned: !1
						};
					case S.g: {
						const {
							kind: n
						} = t.payload;
						return {
							...e,
							editorMode: n === U.b.Markdown ? F.i.MARKDOWN : F.i.RICH_TEXT
						}
					}
					case w.h: {
						const {
							layout: n
						} = t.payload;
						return e.layout === n ? e : {
							...e,
							layout: n
						}
					}
					case w.o:
						return void 0 !== t.payload ? {
							...e,
							rpanDuDismissalTime: t.payload
						} : e;
					case w.p: {
						const {
							layout: n,
							subredditId: s
						} = t.payload;
						return V(e, s, {
							layout: n
						})
					}
					case w.f:
						return {
							...e, hasSeenCustomizeFlyout: !0
						};
					case w.m:
						return e.profileLayout === t.payload.profileLayout ? e : {
							...e,
							profileLayout: t.payload.profileLayout
						};
					case m.j:
						return {
							...e, over18: !0
						};
					case w.c:
						return void 0 !== t.payload ? {
							...e,
							autoplayVideo: t.payload.autoplayVideo
						} : e;
					case w.i:
						return void 0 !== t.payload ? {
							...e,
							nightmode: t.payload.nightmode
						} : e;
					case m.i:
						return {
							...e, gatedSubredditOptIn: t.payload
						};
					case m.k:
						return {
							...e, quarantineOptIn: t.payload
						};
					case w.r:
						if (void 0 !== t.payload) {
							const {
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							} = t.payload;
							return {
								...e,
								topContentDismissalTime: n,
								topContentTimesDismissed: s
							}
						}
						return e;
					case P.d:
						return t.payload.isNightmodeOn ? {
							...e,
							nightmode: !1,
							nightmodeTempUpdated: !0
						} : e;
					case P.e:
						return t.payload.nightmodeTempUpdated ? {
							...e,
							nightmode: !0,
							nightmodeTempUpdated: !1
						} : e;
					case w.g:
						return void 0 !== t.payload ? {
							...e,
							hamburgerTray: t.payload.set
						} : {
							...e,
							hamburgerTray: !e.hamburgerTray
						};
					case w.d:
						return void 0 !== t.payload ? {
							...e,
							collapsedTraySections: a()({}, e.collapsedTraySections, t.payload)
						} : e;
					case m.b:
					case m.c:
					case m.l:
					case m.m:
					case m.h:
					case m.a:
					case m.n:
					case _.e:
					case _.h:
					case h.a:
					case h.e:
					case h.b:
					case h.f:
					case h.d:
					case h.h:
					case p.c:
					case j.SUBREDDIT_LOADED:
					case g.b:
					case g.a:
					case O.e:
					case E.e:
					case E.b:
					case y.PROFILE_POSTS_LOADED:
					case p.g:
					case R.i:
					case N.e:
					case T.b:
					case v.PAGE_LOADED:
					case x.PAGE_LOADED:
					case w.j:
					case w.b:
					case C.c:
					case w.a:
					case A.c:
					case k.TOPIC_DATA_LOADED:
						return t.payload && t.payload.preferences ? W(e, t.payload.preferences) : e;
					case w.q: {
						const {
							subredditId: n,
							prefs: s
						} = t.payload;
						return V(e, n, s)
					}
					case O.d:
					case E.d:
					case E.a:
					case y.PROFILE_POSTS_FAILED: {
						let n = e;
						if (t.payload && t.payload.account) {
							const {
								nightmode: s,
								showPresence: r
							} = t.payload.account;
							e.nightmode !== s && (n = {
								...n,
								nightmode: s
							}), e.showPresence !== r && (n = {
								...n,
								showPresence: r
							})
						}
						return n
					}
					case f.h:
					case f.j:
					case f.i:
					case f.g:
					case f.f:
					case f.s:
					case f.r:
					case f.u:
					case f.v:
					case f.B:
					case f.A:
						return t.payload && t.payload.response && t.payload.response.preferences ? W(e, t.payload.preferences) : e;
					case w.n: {
						const n = t.payload,
							{
								enableFollowers: s,
								showActiveCommunities: r
							} = n.additional;
						let o = e;
						return e.enableFollowers !== s && (o = {
							...o,
							enableFollowers: s
						}), e.showActiveCommunities !== r && (o = {
							...o,
							showActiveCommunities: r
						}), o
					}
					default:
						return e
				}
			}
		},
		"./src/reddit/routes/postCreation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			}));
			var s = n("./node_modules/@loadable/component/dist/loadable.esm.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/lib/loadableAction/index.ts"),
				i = n("./src/reddit/routes/postCreation/constants.ts");
			const a = [i.b, i.c, i.a],
				d = Object(s.a)({
					resolved: {},
					chunkName: () => "PostCreation",
					isReady(e) {
						const t = this.resolve(e);
						return !1 !== this.resolved[t] && !!n.m[t]
					},
					importAsync: () => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("vendors~PostCreation"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~1fdd9b9b"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~GovernanceReleaseNotesModal~ModerationPages~Multired~4b0513d5"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/pages/PostCreation/index.tsx")),
					requireAsync(e) {
						const t = this.resolve(e);
						return this.resolved[t] = !1, this.importAsync(e).then(e => (this.resolved[t] = !0, e))
					},
					requireSync(e) {
						const t = this.resolve(e);
						return n(t)
					},
					resolve() {
						return "./src/reddit/pages/PostCreation/index.tsx"
					}
				}),
				c = e => `/${e}/submit`,
				l = (e, t) => {
					return i.c.replace(/:subredditName/, e) + (t ? `?collection=${t}` : "")
				},
				u = e => i.a.replace(/:profileName/, e),
				m = {
					action: Object(o.a)(() => Promise.all([n.e("vendors~CryptoHarbergerTaxManageModal~HarbergerTaxManageModal~ModerationPages~PostCreation~Settings~~f8934a85"), n.e("vendors~ChatMessageInput~CommentRichUnit~FlairEdit~MembershipPaywallPage~PostCreation~PostRichUnit~R~9deab1a0"), n.e("vendors~PostCreation~Subreddit"), n.e("vendors~PostCreation"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~FramedGild~GildModal~GovernanceReleaseNotesModal~Hap~1fdd9b9b"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~GovernanceReleaseNotesModal~ModerationPages~Multired~4b0513d5"), n.e("CollectionCommentsPage~CommentsPage~CountryPage~Frontpage~GovernanceReleaseNotesModal~ModListing~Mod~e3d63e32"), n.e("ChatPost~CollectionCommentsPage~CommentsPage~EconTopAwardersModal~ModQueuePages~ModerationPages~Post~38f39fb8"), n.e("CollectionCommentsPage~CommentsPage~GovernanceReleaseNotesModal~ModerationPages~PostCreation~Profile~9a5d9fab"), n.e("PostCreation")]).then(n.bind(null, "./src/reddit/actions/pages/postCreation.ts")).then(e => e.postCreationPageRequested)),
					component: d,
					chunk: r.u.POST_CREATION,
					exact: !0,
					meta: {
						name: r.Sb.POST_CREATION
					},
					path: a,
					prefetches: [r.u.COMMENTS_PAGE]
				};
			t.a = m
		},
		"./src/reddit/selectors/PublicAccessNetwork/api.ts": function(e, t, n) {
			"use strict";
			n.d(t, "k", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			})), n.d(t, "l", (function() {
				return p
			})), n.d(t, "m", (function() {
				return b
			})), n.d(t, "b", (function() {
				return f
			})), n.d(t, "o", (function() {
				return h
			})), n.d(t, "n", (function() {
				return _
			})), n.d(t, "g", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "h", (function() {
				return O
			})), n.d(t, "j", (function() {
				return y
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/objectSelector/index.ts"),
				o = n("./src/reddit/actions/publicAccessNetwork/constants.ts"),
				i = n("./src/reddit/helpers/publicAccessNetwork/index.ts");
			const a = e => e.publicAccessNetwork.api.config,
				d = (e, t) => !!t && !!e.publicAccessNetwork.api.error[Object(i.g)(t)],
				c = e => d(e, o.b),
				l = (e, t) => !!t && !!e.publicAccessNetwork.api.pending[Object(i.g)(t)] && e.publicAccessNetwork.api.pending[Object(i.g)(t)].isPending,
				u = e => l(e, o.b),
				m = e => e.publicAccessNetwork.api.pending[o.b] && e.publicAccessNetwork.api.pending[o.b].fetchedUtcTimeStamp,
				p = Object(s.a)(a, e => e.global),
				b = Object(s.a)((e, t) => {
					let {
						subreddit: n
					} = t;
					return n
				}, a, (e, t) => {
					const n = e.toLowerCase();
					return t.subreddits[n]
				}),
				f = Object(s.a)(a, e => e.global.rpan_intro_video_url),
				h = Object(s.a)(a, e => e.global.url_to_show_for_unavailable_video),
				_ = Object(s.a)(a, e => !1),
				g = Object(s.a)(a, e => e.isError),
				v = Object(s.a)(a, e => e.global.max_chat_comment_length),
				x = e => e.publicAccessNetwork.api.recommendedViewerSubreddits,
				O = (Object(s.a)(x, e => e.isError), Object(s.a)(x, e => e.isPending)),
				E = Object(r.a)(Object(s.a)(x, e => e.subreddits)),
				y = Object(s.a)(E, e => [{
					name: "All",
					prefixedName: "All",
					path: Object(i.e)()
				}, ...e.map(e => ({
					name: e,
					prefixedName: `r/${e}`,
					path: Object(i.f)(e)
				}))])
		},
		"./src/reddit/selectors/adsSignals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = e => e.adsSignals
		},
		"./src/reddit/selectors/appBadges.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return r
			})), n.d(t, "e", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "i", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js");
			const r = e => e.appBadges.badges,
				o = Object(s.a)(r, e => {
					var t;
					return (null === (t = e.chatUnreadMessages) || void 0 === t ? void 0 : t.count) || 0
				}),
				i = Object(s.a)(r, e => e && e.chatRooms && e.chatRooms.count || 0),
				a = Object(s.a)(r, e => e && e.chatRoomMentions && e.chatRoomMentions.count || 0),
				d = Object(s.a)(o, r, (e, t) => {
					var n;
					return 0 === e && !!(null === (n = t.chatHasNewMessages) || void 0 === n ? void 0 : n.isShowing)
				}),
				c = Object(s.a)(r, e => e && e.activityTab && e.activityTab.count || 0),
				l = Object(s.a)(r, e => e && e.messageTab && e.messageTab.count || 0),
				u = Object(s.a)(c, l, (e, t) => e + t),
				m = Object(s.a)(o, u, (e, t) => e + t)
		},
		"./src/reddit/selectors/authorFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						post: n
					} = t;
					const s = n.belongsTo.id;
					if (!s) return null;
					const r = e.authorFlair.models[s];
					if (!r) return null;
					const o = n.author;
					return o && r[o] || null
				},
				r = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.authorFlair && e.authorFlair.inContext && e.authorFlair.inContext.username;
					if (!s) return null;
					if (!n) return null;
					const r = e.authorFlair.models[n];
					return r ? r[s] : null
				},
				o = e => e.authorFlair.inContext
		},
		"./src/reddit/selectors/avatar.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const o = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser
				},
				i = e => {
					var t, n;
					return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.avatarUser.csrf_token
				},
				a = e => {
					var t, n;
					return (null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.randomAvatar) || null
				}
		},
		"./src/reddit/selectors/avatarMarketing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/avatar/index.ts"),
				o = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			Object(s.a)({
				features: {
					avatar: r.a
				}
			});
			const i = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing)
				},
				a = e => {
					var t, n, s, r;
					const i = null === (s = null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.avatar) || void 0 === n ? void 0 : n.marketing) || void 0 === s ? void 0 : s.marketingEvent;
					if (!(null == i ? void 0 : i.active) || !(null === (r = null == i ? void 0 : i.assetUrls) || void 0 === r ? void 0 : r.length)) return null;
					const a = i.assetUrls[0];
					return !i.experimentRequired || Object(o.a)(i.experimentRequired)(e) ? a : null
				}
		},
		"./src/reddit/selectors/bannedUser.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/components/InboxTooltip/Component.tsx"),
				o = n("./src/reddit/models/SubredditModeration/index.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.models[n]
				},
				d = (e, t) => {
					let {
						subredditId: n,
						username: s
					} = t;
					const r = Object(i.Bb)(e, {
						userName: s
					});
					if (!r) return;
					const o = a(e, {
						subredditId: n
					});
					return o ? o[r.id] : void 0
				},
				c = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.features.banned.userOrder[n];
					return s ? s.map(t => e.features.banned.models[n][t]) : r.a
				}),
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(o.e)(n);
					return e.features.banned.api.pending[s]
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.banned.loadMore[n]
				},
				m = e => e.features.banned.search.api.pending,
				p = e => e.features.banned.search.result,
				b = e => e.features.banned.inContext
		},
		"./src/reddit/selectors/chat.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return r
			})), n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./node_modules/reselect/es/index.js");
			Object(s.a)(e => e.chat.unread.count, e => e.unreadMessages);
			const r = e => !(e.chat.isInited || e.chat.unread.api.pending),
				o = e => e.chat.liveChatTooltipShowState,
				i = Object(s.a)((e, t) => t, e => e.chat.activeUserCountByLiveChatId, (e, t) => t[e])
		},
		"./src/reddit/selectors/comments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return _
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "u", (function() {
				return v
			})), n.d(t, "w", (function() {
				return x
			})), n.d(t, "x", (function() {
				return O
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "J", (function() {
				return j
			})), n.d(t, "n", (function() {
				return k
			})), n.d(t, "o", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "l", (function() {
				return w
			})), n.d(t, "h", (function() {
				return T
			})), n.d(t, "a", (function() {
				return N
			})), n.d(t, "b", (function() {
				return P
			})), n.d(t, "q", (function() {
				return R
			})), n.d(t, "m", (function() {
				return A
			})), n.d(t, "t", (function() {
				return M
			})), n.d(t, "z", (function() {
				return L
			})), n.d(t, "L", (function() {
				return D
			})), n.d(t, "s", (function() {
				return F
			})), n.d(t, "F", (function() {
				return U
			})), n.d(t, "G", (function() {
				return B
			})), n.d(t, "H", (function() {
				return q
			})), n.d(t, "r", (function() {
				return G
			})), n.d(t, "e", (function() {
				return H
			})), n.d(t, "N", (function() {
				return W
			})), n.d(t, "v", (function() {
				return V
			})), n.d(t, "M", (function() {
				return z
			})), n.d(t, "f", (function() {
				return K
			})), n.d(t, "i", (function() {
				return Q
			})), n.d(t, "I", (function() {
				return Y
			})), n.d(t, "E", (function() {
				return J
			})), n.d(t, "K", (function() {
				return X
			})), n.d(t, "p", (function() {
				return Z
			})), n.d(t, "O", (function() {
				return $
			})), n.d(t, "y", (function() {
				return ee
			})), n.d(t, "A", (function() {
				return te
			})), n.d(t, "C", (function() {
				return ne
			})), n.d(t, "D", (function() {
				return se
			})), n.d(t, "B", (function() {
				return re
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./src/lib/constants/index.ts"),
				i = n("./src/lib/objectSelector/index.ts"),
				a = n("./node_modules/reselect/es/index.js"),
				d = n("./src/reddit/constants/comments.ts"),
				c = n("./src/reddit/models/Post/index.ts"),
				l = n("./src/reddit/selectors/experiments/mediaInComments.ts"),
				u = n("./src/reddit/selectors/subreddit.ts"),
				m = n("./src/reddit/selectors/commentSelector.ts"),
				p = n("./src/lib/initializeClient/installReducer.ts"),
				b = n("./src/reddit/reducers/features/comments/index.ts"),
				f = n("./src/reddit/reducers/pages/comments/index.ts"),
				h = n("./src/redditGQL/types.ts");
			Object(p.a)({
				features: {
					comments: b.a
				},
				pages: {
					comments: f.a
				}
			});
			const _ = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.error[n]
				},
				g = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.pending[n]
				},
				v = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.api.fullyLoaded[n]
				},
				x = (e, t) => e.pages.comments.keyToHeadCommentId[t.commentsPageKey],
				O = (e, t) => {
					const n = x(e, t);
					if (n) return Object(m.b)(e, {
						commentId: n
					})
				},
				E = [],
				y = Object(i.a)((e, t) => {
					const n = O(e, t),
						s = n && n.id;
					if (!s) return E;
					const {
						commentsPageKey: r
					} = t, o = e.pages.comments.keyToCommentThreadLinkSets[r], i = [];
					let a = {
						id: s,
						type: d.a.Comment
					};
					do {
						i.push(a), a = o[a.id].next
					} while (a);
					return i
				}),
				C = (e, t) => x(e, t) ? e.pages.comments.keyToChatCommentLinks[t.commentsPageKey] : [],
				j = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					return s ? e.posts.models[s] : null
				},
				k = (e, t) => {
					let {
						commentId: n,
						commentLink: s,
						commentsPageKey: r
					} = t;
					const o = e.pages.comments.keyToCommentThreadLinkSets[r];
					return o ? s ? o[s.id] : n ? o[n] : null : null
				},
				I = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.pages.comments.keyToCommentThreadLinkSets[n]
				},
				S = (e, t) => {
					const n = t.commentsPageKey ? k(e, t) : null;
					return n ? n.depth : null
				},
				w = (e, t) => {
					let {
						commentLink: n
					} = t;
					const {
						id: s,
						type: r
					} = n;
					switch (r) {
						case d.a.Comment:
							return e.features.comments.models[s];
						case d.a.MoreComments:
							return e.moreComments.models[s];
						case d.a.ContinueThread:
							return e.continueThreads.models[s];
						default:
							return null
					}
				},
				T = (e, t) => {
					if (e.platform.currentPage && e.platform.currentPage.urlParams && e.platform.currentPage.urlParams.partialPostId) {
						const {
							partialPostId: t
						} = e.platform.currentPage.urlParams, n = Object(c.z)(t);
						return Array.from(new Set(Object.keys(e.features.comments.models).filter(t => e.features.comments.models[t].postId === n && e.features.comments.models[t].author !== o.H).map(t => e.features.comments.models[t].author)))
					}
					return []
				},
				N = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					return e.features.comments.collapsed[n]
				},
				P = e => e.moreComments.models,
				R = e => e.features.comments.models,
				A = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = Object(m.b)(e, {
						commentId: n
					});
					return s ? Object(m.a)(e, s) : ""
				},
				M = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!(n && e.features.comments.focused && e.features.comments.focused[n])
				},
				L = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.isEditing[s] && e.features.comments.isEditing[s][n])
				},
				D = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					return !!(n && e.features.comments.replyFormOpen[s] && e.features.comments.replyFormOpen[s][n])
				},
				F = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = n && e.features.comments.replyFormOpen[n] || {},
						r = Object.keys(s).find(e => s[e]),
						o = r && Object(m.b)(e, {
							commentId: r
						}),
						i = o && S(e, {
							commentId: o.id,
							commentLink: void 0,
							commentsPageKey: n
						});
					if (o && "number" == typeof i) return {
						...o,
						depth: i
					}
				},
				U = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return e.moreComments.models[n]
				},
				B = (e, t) => {
					let {
						moreCommentsId: n
					} = t;
					return !!e.moreComments.api.pending[n]
				},
				q = (e, t) => {
					let {
						commentsPageKey: n
					} = t;
					const s = e.pages.comments.keyToPostId[n];
					if (s) {
						const t = r()(e.moreComments.models).find(t => t.postId === s && 0 === t.depth && !(void 0 !== e.moreComments.api.pending[t.id]));
						if (t) return {
							moreCommentId: t.id,
							pending: !!e.moreComments.api.pending[t.id]
						}
					}
					return null
				},
				G = (e, t) => {
					let {
						id: n
					} = t;
					return e.continueThreads.models[n]
				},
				H = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.models[n] : void 0;
					if (!s) return null;
					const r = e.authorFlair.models[s.subredditId];
					return r ? r[s.author] : null
				},
				W = (e, t) => {
					let {
						draftKey: n
					} = t;
					var s, r, o;
					return (null === (o = null === (r = null === (s = e.features.comments.submit) || void 0 === s ? void 0 : s.error) || void 0 === r ? void 0 : r[n]) || void 0 === o ? void 0 : o.type) || null
				},
				V = (e, t) => {
					let {
						draftKey: n
					} = t;
					return !!e.features.comments.submit.error[n]
				},
				z = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.submit.error[n];
					return s && s.fields ? s.fields.map(e => e.msg) : []
				},
				K = (e, t) => {
					let {
						draftKey: n
					} = t;
					const s = e.features.comments.drafts[n];
					return !!s && s.autofocusDisabled
				},
				Q = (e, t) => {
					let {
						draftKey: n
					} = t;
					return e.features.comments.drafts[n]
				},
				Y = (e, t) => {
					let {
						commentId: n
					} = t;
					const s = n ? e.features.comments.submit.error[n] : void 0;
					return s && s.fields ? s.fields.map(e => e.msg) : void 0
				},
				J = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.submit.pending[n]
				},
				X = (e, t) => {
					let {
						commentId: n
					} = t;
					return !!n && e.features.comments.models[n].sendReplies
				},
				Z = e => e.features.comments.visitHighlightFilter,
				$ = (e, t) => {
					const n = Object(m.b)(e, t);
					if (n) return Object(u.db)(e, n)
				},
				ee = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					return !!((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n)
				},
				te = (e, t) => {
					let {
						commentId: n
					} = t;
					var s, r;
					const o = ((null === (r = null === (s = e.pages) || void 0 === s ? void 0 : s.comments) || void 0 === r ? void 0 : r.followed) || []).find(e => e.id === n);
					return !!(o && o.expiresAt < Date.now())
				},
				ne = Object(a.a)(l.a, u.y, (e, t) => {
					var n;
					return e && (null === (n = null == t ? void 0 : t.allowedMediaInComments) || void 0 === n ? void 0 : n.includes(h.f.Giphy)) || !1
				}),
				se = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s;
					const r = Object(u.y)(e, {
						subredditId: n
					});
					return (null === (s = null == r ? void 0 : r.allowedMediaInComments) || void 0 === s ? void 0 : s.includes(h.f.Static)) || !1
				},
				re = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s;
					const r = Object(u.y)(e, {
						subredditId: n
					});
					return (null === (s = null == r ? void 0 : r.allowedMediaInComments) || void 0 === s ? void 0 : s.includes(h.f.Animated)) || !1
				}
		},
		"./src/reddit/selectors/communitySettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => {
				const n = t && e.subreddits.about[t];
				return Boolean(n && n.isMediaInCommentsSettingShown)
			}
		},
		"./src/reddit/selectors/creatorStats.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "a", (function() {
				return u
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/creatorStats/index.ts"),
				o = n("./src/reddit/selectors/moderatorPermissions.ts"),
				i = n("./src/reddit/selectors/posts.ts"),
				a = n("./src/reddit/selectors/user.ts");
			Object(s.a)({
				features: {
					creatorStats: r.a
				}
			});
			const d = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postOtherDiscussions[t]
				},
				c = (e, t) => {
					var n, s;
					return null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.postStats[t]
				},
				l = (e, t) => {
					var n, s, r;
					const o = null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.creatorStats) || void 0 === s ? void 0 : s.subredditKarma[t]) || void 0 === r ? void 0 : r.karma;
					if (!o) return;
					const {
						fromComments: i,
						fromPosts: a
					} = o;
					return {
						fromComments: i,
						fromPosts: a
					}
				},
				u = (e, t, n) => {
					const s = Object(i.G)(e, {
						postId: t
					});
					if (!s || s.isSponsored || s.removedByCategory) return !1;
					const r = Object(i.V)(e, {
						postId: t
					});
					if (r && r.isQuarantined) return !1;
					const d = !n && !!Object(o.m)(e, {
						postId: t
					});
					return Object(a.Eb)(e, {
						postId: t
					}) || d
				}
		},
		"./src/reddit/selectors/crypto/points.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/react-redux/es/index.js"),
				r = n("./src/reddit/contexts/PageLayer/index.tsx"),
				o = n("./src/reddit/endpoints/governance/crypto.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/crypto/index.ts");
			Object(i.a)({
				features: {
					crypto: a.a
				}
			});
			const d = (e, t) => {
				var n, s, r;
				return t ? null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.crypto) || void 0 === s ? void 0 : s.points) || void 0 === r ? void 0 : r[t] : void 0
			};

			function c() {
				const e = Object(r.gb)(),
					t = Object(s.e)(t => Object(r.s)(t, {
						pageLayer: e
					})),
					n = Object(s.e)(e => d(e, null == t ? void 0 : t.id));
				return {
					subreddit: t,
					pointsDetails: n
				}
			}
			const l = (e, t) => {
				var n;
				const s = null === (n = d(e, t)) || void 0 === n ? void 0 : n.blockchainProvider;
				return s === o.a.Ethereum || s === o.a.Rinkeby || s === o.a.EthTraderEthereum || s === o.a.EthTraderRinkeby || s === o.a.ArbitrumRinkeby
			}
		},
		"./src/reddit/selectors/discoveryUnit.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "b", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "e", (function() {
				return l
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js"), n("./src/lib/constants/index.ts"), n("./src/lib/makeListingKey/index.ts"), n("./src/lib/objectSelector/index.ts");
			var s = n("./src/reddit/helpers/name/index.ts"),
				r = n("./src/reddit/models/DiscoveryUnit/index.ts");
			n("./src/reddit/selectors/category.ts"), n("./src/reddit/selectors/listings.ts"), n("./src/reddit/selectors/posts.ts"), n("./src/reddit/selectors/subreddit.ts");
			const o = e => e.discoveryUnits.api.list.loaded,
				i = e => e.discoveryUnits.api.list.pending,
				a = (e, t) => {
					let {
						unitName: n
					} = t;
					const r = e.discoveryUnits.nameToId[Object(s.i)(n)];
					return e.discoveryUnits.models[r]
				},
				d = e => a(e, {
					unitName: r.b
				}),
				c = new Set(["sequence"]),
				l = e => {
					const t = e.platform.currentPage;
					if (t) {
						const {
							meta: e,
							urlParams: n
						} = t, s = e && e.name || "", r = n && n.subredditName || "", o = "subreddit" === s, i = c.has(r.toLowerCase());
						return o && i
					}
					return !1
				}
		},
		"./src/reddit/selectors/emojis.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return l
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "e", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "a", (function() {
				return _
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/values.js"),
				r = n.n(s),
				o = n("./node_modules/reselect/es/index.js"),
				i = n("./src/reddit/models/Flair/index.ts"),
				a = n("./src/reddit/selectors/isModeratorOfSubreddit.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.emojis.models,
				u = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => {
					const n = e[t];
					return n ? [...r()(n.emojis), ...r()(n.snoomojis)] : c
				}),
				m = Object(o.a)(u, a.c, (e, t) => t.isFlairModOnly, (e, t) => t.flairTemplateType, (e, t, n, s) => e.filter(e => !(e.modFlairOnly && !t || e.modFlairOnly && !n) && (!(!e.userFlairAllowed && s === i.d.UserFlair) && !(!e.postFlairAllowed && s === i.d.LinkFlair)))),
				p = Object(o.a)(l, (e, t) => t.subredditId, (e, t) => Object.keys(e[t].snoomojis)),
				b = (e, t) => Object(d.z)(e, {
					subredditName: t
				}).emojisEnabled,
				f = {
					emojis: {},
					snoomojis: {}
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return l(e)[n] || f
				},
				_ = (e, t) => !!e.emojis.api.list.pending[t]
		},
		"./src/reddit/selectors/eventPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "f", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			}));
			var s = n("./src/lib/makeListingKey/index.ts"),
				r = n("./src/reddit/selectors/posts.ts");
			const o = (e, t) => {
					let {
						subredditName: n
					} = t;
					return Object(s.a)("ModhubPage-EventPosts", "timeline", {
						subredditName: n
					})
				},
				i = (e, t) => {
					const n = o(e, t);
					return Object(r.N)(e, {
						listingKey: n
					}) || []
				},
				a = (e, t) => {
					const n = o(e, t);
					return !!e.listings.postOrder.api.pending[n]
				},
				d = (e, t) => {
					const n = o(e, t);
					return !!(e.listings.postOrder.ids[n] || []).length
				},
				c = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return !(!s || !s.hasNextPage)
				},
				l = (e, t) => {
					const n = o(e, t),
						s = e.listings.postOrder.pageInfo[n];
					return s && s.endCursor || null
				}
		},
		"./src/reddit/selectors/experiments/antievil/index.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.I
				}) === s.Kd
			}
		},
		"./src/reddit/selectors/experiments/commentSearchPdp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = Object(o.a)(e => Object(r.c)(e, {
				experimentEligibilitySelector: r.a,
				experimentName: s.ub
			}), e => ({
				bucketed: e === s.Rc.ExpandedSearch || e === s.Rc.CollapsedSearch,
				collapsed: e === s.Rc.CollapsedSearch,
				expanded: e === s.Rc.ExpandedSearch
			}))
		},
		"./src/reddit/selectors/experiments/communityDirectoryBacklinks/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return l
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/server/helpers/canonicalUrl.tsx");
			const i = (e, t) => e.find(e => t <= e);

			function a(e, t) {
				return Object(o.c)(`/best/communities/${e}/#${t}`)
			}

			function d(e, t) {
				return e > 50 ? {
					percentile: i([0, 1, 5, 10, 20, 50], t),
					position: e
				} : {
					position: e
				}
			}
			var c = n("./src/reddit/selectors/subreddit.ts");
			const l = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.H,
						expEventOverride: !1
					}) === s.R.Enabled
				},
				u = (e, t) => {
					let {
						subredditId: n,
						subredditAboutInfo: s
					} = t;
					if (l(e) && n && (null == s ? void 0 : s.directoryRankings)) return function(e, t) {
						const n = null === (s = e.rankings) || void 0 === s ? void 0 : s[0];
						var s;
						if (n && n.position > 0 && t) {
							const e = Math.ceil(n.position / n.totalRanked * 100);
							if (e <= 50) return {
								url: a(n.pageNumber, t),
								...d(n.position, e)
							}
						}
					}(s.directoryRankings, n)
				},
				m = (e, t) => {
					const n = Object(c.C)(e, {
							subredditName: t
						}),
						s = Object(c.z)(e, {
							subredditName: t
						});
					return u(e, {
						subredditId: null == n ? void 0 : n.id,
						subredditAboutInfo: s
					})
				},
				p = e => {
					const t = e.platform.currentPage,
						n = t && t.routeMatch,
						s = n ? n.match.params.subredditName : void 0;
					if (!s) return;
					const r = m(e, s);
					return (null == r ? void 0 : r.url) ? {
						internalLinkUrl: null == r ? void 0 : r.url
					} : void 0
				}
		},
		"./src/reddit/selectors/experiments/contributeBeforeSignUp.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/utils.ts");
			const a = ["au", "br", "ca", "de", "fr", "gb", "in", "mx", "us", "row"],
				d = Object(s.a)((e, t) => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: `d2x_start_comment_before_sign_up_${t}`
				}), i.a),
				c = e => a.find(t => !!Object(i.a)(d(e, t))),
				l = Object(s.a)(c, e => !!e),
				u = e => {
					const t = c(e);
					return !!t && d(e, t) === r.V.SkipOnboarding
				},
				m = e => {
					const t = c(e);
					return !!t && d(e, t) === r.V.RegOnboarding
				}
		},
		"./src/reddit/selectors/experiments/crosspostRecommendations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "e", (function() {
				return h
			}));
			var s = n("./src/lib/isUrl/index.ts"),
				r = n("./src/reddit/components/CrosspostRecommendationsModal/constants.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/helpers/isCrosspost.ts"),
				d = n("./src/reddit/models/Media/index.ts"),
				c = n("./src/reddit/selectors/activeModal.ts"),
				l = n("./src/reddit/selectors/experiments/index.ts"),
				u = n("./src/reddit/selectors/posts.ts");
			const m = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: l.e,
						experimentName: o.Qe
					}) === o.Kd
				},
				p = e => !e.media || e.media.type !== d.o.RTJSON && e.media.type !== d.o.TEXT ? "" : e.media.markdownContent,
				b = e => !e.media && e.source && Object(s.a)(e.source.url) ? e.source.displayText : "",
				f = (e, t) => {
					const n = Object(u.G)(e, {
						postId: t
					});
					return n && !n.isSponsored && n.isCrosspostable && !Object(a.a)(n) && Object(c.c)(r.a)(e)
				},
				h = e => {
					var t;
					return !!(null === (t = e.features) || void 0 === t ? void 0 : t.shouldTryToShowCrosspostModal)
				}
		},
		"./src/reddit/selectors/experiments/devPlatform.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/selectors/experiments/econ/simpleExperiment.ts");
			const o = Object(r.a)(s.wb)
		},
		"./src/reddit/selectors/experiments/emailInvite.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				const t = Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Jd
				});
				return !(!t || Object(s.rg)(t))
			}
		},
		"./src/reddit/selectors/experiments/gqlSubredditPage.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Gb
				}) === s.Wc.Enabled,
				i = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Fb
				}) === s.Vc.Enabled
		},
		"./src/reddit/selectors/experiments/imageComment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "d", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/comments.ts");
			const i = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.he
					}) === s.Kd
				},
				a = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.ie
					}) === s.Kd
				},
				d = e => {
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.Td
					}) === s.Kd
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return void 0 !== n && Object(o.D)(e, {
						subredditId: n
					}) && i(e)
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return void 0 !== n && Object(o.B)(e, {
						subredditId: n
					}) && i(e)
				}
		},
		"./src/reddit/selectors/experiments/joinOptimizations.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "d", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts");
			const a = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Qb,
					experimentEligibilitySelector: i.e
				}), e => e === r.X.Enabled),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Rb,
					experimentEligibilitySelector: i.e
				}), e => e === r.Y.Enabled),
				c = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Sb,
					experimentEligibilitySelector: i.e
				}), e => e === r.Z.Enabled),
				l = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Tb,
					experimentEligibilitySelector: i.e
				}), e => e === r.ab.Enabled),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Vb,
					experimentEligibilitySelector: i.e
				}), e => e === r.cb.Enabled),
				m = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Ub,
					experimentEligibilitySelector: i.e
				}), e => e === r.bb.Enabled)
		},
		"./src/reddit/selectors/experiments/loggedOutOneFeed.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return l
			})), n.d(t, "c", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "a", (function() {
				return h
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/countrySites.ts"),
				a = n("./src/reddit/selectors/experiments/index.ts"),
				d = n("./src/reddit/selectors/experiments/utils.ts");
			const c = Object(s.a)(a.f, i.f, (e, t) => e && !t),
				l = e => Object(o.c)(e, {
					experimentEligibilitySelector: c,
					experimentName: r.Zb
				}),
				u = e => !!Object(d.a)(l(e)),
				m = e => l(e) === r.ib.RemovePopularCommunities,
				p = e => l(e) === r.ib.LoggedOutUiOnly || f(e) || h(e),
				b = e => l(e) === r.ib.LoggedOutHomeDefpop,
				f = e => l(e) === r.ib.RemoveRecentCommunities,
				h = e => l(e) === r.ib.FilterOutNSFW
		},
		"./src/reddit/selectors/experiments/mediaInComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.we
				}) === s.Kd,
				i = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.ve
				}) === s.Kd
		},
		"./src/reddit/selectors/experiments/newCommunityProgressV3.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return b
			})), n.d(t, "a", (function() {
				return f
			})), n.d(t, "b", (function() {
				return h
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/lib/constants/index.ts"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/constants/posts.ts"),
				a = n("./src/reddit/helpers/chooseVariant/index.ts"),
				d = n("./src/reddit/selectors/experiments/index.ts"),
				c = n("./src/reddit/selectors/experiments/utils.ts"),
				l = n("./src/reddit/selectors/moderatorPermissions.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/subreddit.ts"),
				p = n("./src/reddit/selectors/user.ts");
			const b = e => e.subreddits.progressModule,
				f = e => {
					const t = Object(u.c)(e);
					if (!t) return;
					if (!Object(l.n)(e, {
							subredditId: t
						})) return;
					if (Object(p.O)(e)) return h(e);
					const n = Object(m.M)(e, {
						identifier: {
							id: t,
							type: i.a.SUBREDDIT
						}
					});
					if (!n || !n.created) return;
					const s = n.created;
					return s ? s * r.Xb < 1639443600180 ? void 0 : h(e) : void 0
				},
				h = Object(s.a)(e => Object(a.c)(e, {
					experimentName: o.Ee,
					experimentEligibilitySelector: d.e
				}), c.a)
		},
		"./src/reddit/selectors/experiments/nsfwBlockingExperiment.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return v
			})), n.d(t, "c", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			})), n.d(t, "g", (function() {
				return w
			})), n.d(t, "f", (function() {
				return T
			})), n.d(t, "e", (function() {
				return N
			})), n.d(t, "d", (function() {
				return P
			}));
			var s, r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/selectors/subreddit.ts"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/contexts/PageLayer/index.tsx"),
				d = n("./src/reddit/helpers/chooseVariant/index.ts"),
				c = n("./src/reddit/selectors/experiments/index.ts"),
				l = n("./src/reddit/selectors/meta.ts"),
				u = n("./src/reddit/selectors/platform.ts"),
				m = n("./src/reddit/selectors/profile.ts");
			! function(e) {
				e.Blurred = "blurred", e.NoPreview = "noPreview"
			}(s || (s = {}));
			const p = Object(r.a)(l.h, l.d, c.e, (e, t, n) => !e && !t && !n);

			function b(e, t) {
				return n => Object(d.c)(n, {
					experimentName: e,
					experimentEligibilitySelector: p,
					expEventOverride: t
				})
			}
			const f = b(i.gc, !0),
				h = b(i.gc, !1),
				_ = b(i.ic, !0),
				g = (b(i.ic, !1), b(i.hc, !0)),
				v = b(i.hc, !1),
				x = b(i.jc, !0),
				O = b(i.jc, !1),
				E = b(i.kc, !0),
				y = b(i.fc, !0),
				C = Object(r.a)(f, _, (e, t) => e === i.Xc.Enabled || t === i.Yc.Enabled),
				j = Object(r.a)(g, x, (e, t) => e === i.kb.BlurredPreview || e === i.kb.NoPreview || t === i.kb.BlurredPreview || t === i.kb.NoPreview),
				k = Object(r.a)(v, O, (e, t) => e === i.kb.BlurredPreview || t === i.kb.BlurredPreview),
				I = Object(r.a)(g, x, E, y, (e, t, n, s) => e === i.kb.NoPreview || t === i.kb.NoPreview || n === i.kb.NoPreview || s === i.jb.Enabled),
				S = Object(r.a)(C, I, k, (e, t, n) => (e || t) && !n),
				w = e => {
					const t = k(e),
						n = S(e);
					return t ? s.Blurred : n ? s.NoPreview : null
				},
				T = Object(r.a)(y, e => e === i.jb.Enabled),
				N = e => {
					const t = k(e),
						n = Object(o.m)(e);
					return t && n
				},
				P = e => {
					var t;
					const n = k(e),
						s = Object(u.b)(e),
						r = null === (t = null == s ? void 0 : s.routeMatch) || void 0 === t ? void 0 : t.match;
					if (r) {
						const t = Object(m.k)(e, {
								profileName: r.params.profileName
							}),
							o = !!(t && (null == t ? void 0 : t.isNSFW)),
							i = Object(a.G)(e, {
								pageLayer: s
							});
						return n && o && !i
					}
					return !1
				}
		},
		"./src/reddit/selectors/experiments/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "i", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "e", (function() {
				return b
			})), n.d(t, "f", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			})), n.d(t, "c", (function() {
				return _
			})), n.d(t, "g", (function() {
				return g
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts"),
				a = n("./src/reddit/selectors/user.ts"),
				d = n("./src/reddit/selectors/experiments/utils.ts");
			const c = Object(s.a)(i.e, a.K, (e, t) => e && !t),
				l = e => Object(o.c)(e, {
					experimentEligibilitySelector: c,
					experimentName: r.Gc
				}),
				u = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.Fc
				}), e => e),
				m = Object(s.a)(e => {
					var t;
					const n = r.Lb;
					for (let s = 0; s < n.length; s++) {
						const i = n[s],
							a = (null === (t = i.split("_").pop()) || void 0 === t ? void 0 : t.toUpperCase()) || "",
							d = Object(o.c)(e, {
								experimentEligibilitySelector: o.a,
								experimentName: i
							});
						if (d && Object.values(r.lb).includes(d)) return {
							countryCode: a,
							experimentName: i,
							variantName: d
						}
					}
					return null
				}, e => e),
				p = Object(s.a)(e => {
					const t = m(e);
					return (null == t ? void 0 : t.variantName) || void 0
				}, d.a),
				b = (Object(s.a)(p, e => e === r.lb.FruitVeg), Object(s.a)(p, e => e === r.lb.Karma)),
				f = Object(s.a)(p, e => e === r.lb.Randomizer),
				h = Object(s.a)(p, e => e === r.lb.Interactive),
				_ = Object(s.a)(p, e => Object.values(r.lb).includes(e)),
				g = e => Object(o.c)(e, {
					experimentEligibilitySelector: o.a,
					experimentName: r.lc
				})
		},
		"./src/reddit/selectors/experiments/popularGqlMigration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/selectors/experiments/index.ts");
			const a = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: i.e,
					experimentName: r.pc
				}), e => e === r.Kd),
				d = Object(s.a)(e => Object(o.c)(e, {
					experimentEligibilitySelector: i.f,
					experimentName: r.qc
				}), e => e === r.Kd)
		},
		"./src/reddit/selectors/experiments/postActionBarAnimation.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "h", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "g", (function() {
				return m
			})), n.d(t, "f", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/experiments/index.ts"),
				i = n("./src/reddit/selectors/experiments/presence.ts"),
				a = n("./src/reddit/selectors/userPrefs.ts");
			const d = 1e4,
				c = e => {
					if (Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.k
					});
					return t === s.o.VoteCountOnly || t === s.o.CommentCountOnly || t === s.o.VoteAndCommentCount
				},
				l = e => {
					if (Object(a.d)(e) || Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.k
					});
					return t === s.o.VoteCountOnly || t === s.o.VoteAndCommentCount
				},
				u = e => {
					if (Object(a.d)(e) || Object(i.a)(e)) return !1;
					const t = Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.k
					});
					return t === s.o.CommentCountOnly || t === s.o.VoteAndCommentCount
				},
				m = (e, t) => {
					let {
						post: n
					} = t;
					return p(e, {
						postId: n.id
					})
				},
				p = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(a.d)(e) || !r || r.isSponsored || r.isScoreHidden || r.score >= d || Object(i.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.k
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.o.VoteCountOnly || l === s.o.VoteAndCommentCount
				},
				b = (e, t) => {
					let {
						postId: n
					} = t;
					const r = e.posts.models[n];
					if (Object(a.d)(e) || !r || r.isSponsored || r.numComments >= d || Object(i.a)(e)) return !1;
					const c = Object(o.d)(e, {
							experimentName: s.k
						}),
						l = null == c ? void 0 : c.variant;
					return l === s.o.CommentCountOnly || l === s.o.VoteAndCommentCount
				},
				f = e => {
					if (Object(i.a)(e)) return !1;
					return Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.yc
					}) === s.bd.Enabled
				}
		},
		"./src/reddit/selectors/experiments/postCreationSubRec.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "g", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "h", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "f", (function() {
				return g
			})), n.d(t, "d", (function() {
				return v
			})), n.d(t, "c", (function() {
				return x
			})), n.d(t, "e", (function() {
				return O
			})), n.d(t, "l", (function() {
				return E
			})), n.d(t, "k", (function() {
				return y
			})), n.d(t, "m", (function() {
				return C
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/components/RichTextEditor/RTEState/index.tsx"),
				o = n("./src/reddit/constants/experiments.ts"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/models/PostCreationForm/index.ts"),
				d = n("./src/reddit/models/SubredditAutocomplete/index.ts"),
				c = n("./src/reddit/selectors/subreddit.ts");
			const l = 3,
				u = e => m(e) ? 1 : (p(e), .5),
				m = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.Pe
					}) === o.Re.ContentMatch
				},
				p = e => {
					return Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.Pe
					}) === o.Re.ConfidenceAndSuccess
				},
				b = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.Pe
					});
					return t === o.Re.ContentMatch || t === o.Re.ConfidenceAndSuccess || t === o.S.Control1 || t === o.S.Control2
				},
				f = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.Pe
					});
					return t === o.S.Control1 || t === o.S.Control2
				},
				h = e => {
					const t = Object(i.c)(e, {
						experimentEligibilitySelector: i.a,
						experimentName: o.Pe
					});
					return t === o.Re.ContentMatch || t === o.Re.ConfidenceAndSuccess
				},
				_ = e => e.creations.subredditRec.api.pending,
				g = e => e.creations.subredditRec.api.error,
				v = e => {
					return e.creations.subredditRec.order.length > 0
				},
				x = e => {
					const t = e.creations.subredditRec.order,
						n = [];
					return t.forEach(t => {
						const s = Object(c.z)(e, {
								subredditName: t
							}),
							r = Object(c.C)(e, {
								subredditName: t
							});
						if (r && s) {
							const e = {
								iconUrl: r.icon.url,
								name: r.name,
								primaryColor: r.primaryColor,
								subscribers: s.subscribers,
								type: d.a.OTHER_SUBREDDIT
							};
							n.push(e)
						}
					}), n
				},
				O = e => e.creations.subredditRec.isInputChanged,
				E = e => {
					if (!(e.creations.formData.submissionType === s.bc.POST)) return "";
					const t = e.creations.formState.editorMode === a.i.RICH_TEXT || null === e.creations.formState.editorMode,
						n = e.creations.formState.editorMode === a.i.MARKDOWN;
					if (t) {
						const t = e.creations.formData.body.rte;
						return r.a.getRawText(t, " ") || ""
					}
					return n && e.creations.formData.body.markdown || ""
				},
				y = e => {
					return e.creations.formData.submissionType === s.bc.LINK_ONLY && e.creations.formData.body.link || ""
				},
				C = e => b(e) && (!g(e) || g(e) && O(e)) && (e => {
					const t = e.creations.formData.title,
						n = y(e),
						s = E(e);
					return !!(t || n || s)
				})(e) && (e.creations.formData.submissionType === s.bc.POST || e.creations.formData.submissionType === s.bc.LINK_ONLY || e.creations.formData.submissionType === s.bc.CROSSPOST)
		},
		"./src/reddit/selectors/experiments/presence.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => {
				return Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.Ye
				}) === s.Kd
			}
		},
		"./src/reddit/selectors/experiments/publicAccessNetwork.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return o
			})), n.d(t, "a", (function() {
				return i
			})), n.d(t, "f", (function() {
				return a
			})), n.d(t, "h", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "e", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts");
			const o = e => s.kf.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.vf
				}),
				i = e => s.kf.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.df
				}),
				a = (e, t, n) => {
					const o = n(e, t);
					return !(!o || !o.meter) && (o.meter.enabled && s.eg.Enabled === Object(r.c)(e, {
						experimentEligibilitySelector: r.a,
						experimentName: s.dg
					}))
				},
				d = e => Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.uf
				}),
				c = e => {
					switch (e) {
						case s.zf.Five:
							return .05;
						case s.zf.Ten:
							return .1;
						case s.zf.Fifty:
							return .5;
						default:
							return .01
					}
				},
				l = e => s.kf.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.wf
				}),
				u = e => s.kf.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.sf
				}),
				m = e => s.kf.Enabled === Object(r.c)(e, {
					experimentEligibilitySelector: r.a,
					experimentName: s.tf
				})
		},
		"./src/reddit/selectors/experiments/realtimeMQUpdates.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts"),
				i = n("./src/reddit/selectors/experiments/modqueueActionBarUXImprovements.ts");
			const a = e => Object(i.a)(e) && Object(r.c)(e, {
				experimentEligibilitySelector: o.R,
				experimentName: s.zc
			}) === s.Kd
		},
		"./src/reddit/selectors/experiments/reportAd.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.Hc,
					experimentEligibilitySelector: o.a
				}), e => e),
				a = Object(s.a)(i, e => e === r.Kd)
		},
		"./src/reddit/selectors/experiments/reportingRevampDesktop.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/runTimeEnvVars.ts"),
				i = n("./src/reddit/selectors/user.ts");
			const a = e => !!Object(o.b)(e) || Object(r.c)(e, {
				experimentEligibilitySelector: i.R,
				experimentName: s.g
			}) === s.d.Enabled
		},
		"./src/reddit/selectors/experiments/supportingLinkAds.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = Object(o.a)(e => Object(r.c)(e, {
				experimentEligibilitySelector: r.a,
				experimentName: s.Jc
			}), e => e === s.Kd)
		},
		"./src/reddit/selectors/experiments/targetedOnboardingSkip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			}));
			var s = n("./src/reddit/constants/experiments.ts"),
				r = n("./src/reddit/helpers/chooseVariant/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => Object(r.c)(e, {
				experimentEligibilitySelector: o.R,
				experimentName: s.Mc
			})
		},
		"./src/reddit/selectors/experiments/topPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/contexts/PageLayer/index.tsx"),
				i = n("./src/reddit/helpers/chooseVariant/index.ts"),
				a = n("./src/reddit/selectors/user.ts");
			const d = Object(s.a)(a.R, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.B)(n)
				}, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(o.Q)(n)
				}, (e, t, n) => !e && !t && n),
				c = Object(s.a)((e, t) => Object(i.c)(e, {
					experimentName: r.hd,
					experimentEligibilitySelector: e => d(e, t)
				}), e => e),
				l = e => e === r.Zf.NoCommunityWidgets,
				u = e => e === r.Zf.NoRulesModerators,
				m = e => e === r.Zf.RelatedPostsDu
		},
		"./src/reddit/selectors/experiments/web2x_cta.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return a
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts");
			const i = Object(s.a)(e => Object(o.c)(e, {
					experimentName: r.fg,
					experimentEligibilitySelector: o.a
				}), e => e),
				a = Object(s.a)(i, e => e === r.Xf)
		},
		"./src/reddit/selectors/externalAccount.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return i
			})), n.d(t, "a", (function() {
				return d
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./src/reddit/models/ExternalAccount/index.ts"),
				r = n("./src/reddit/models/User/index.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = (e, t) => {
					let {
						username: n
					} = t;
					return !!e.externalAccount.api.user.pending[n]
				},
				a = (e, t) => {
					let {
						username: n
					} = t;
					return e.externalAccount.user[n]
				},
				d = e => {
					const t = Object(o.l)(e);
					if (!t) return;
					const n = Object(r.e)(t),
						s = a(e, {
							username: n
						});
					return s ? s.twitter : void 0
				},
				c = e => !!e.externalAccount.api.connect.pending[s.a.Twitter],
				l = (e, t) => {
					let {
						profileName: n
					} = t;
					if (!n) return null;
					const i = a(e, {
						username: n
					});
					if (!i) return null;
					const d = i[s.a.Twitter];
					if (!d) return null;
					const c = Object(o.l)(e);
					if (!(c && Object(r.e)(c).toLowerCase() === n.toLowerCase())) return d;
					const l = Object(o.Bb)(e, {
						userName: n
					});
					return l ? l.prefShowTwitter ? d : null : d
				}
		},
		"./src/reddit/selectors/features/predictions/creation/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts"),
				o = n("./src/reddit/selectors/postCreations.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const i = e => {
					const t = (e => {
						var t, n;
						return null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation
					})(e);
					return (null == t ? void 0 : t.length) ? null == t ? void 0 : t.map(t => {
						const n = Object(o.fb)({
								...e,
								creations: {
									...e.creations,
									formData: t.formData,
									formState: t.formState
								}
							}, {}),
							s = t.formData.polls,
							r = s.options.map(e => ({
								text: e.text
							})),
							i = {};
						return n.document ? i.richText = JSON.stringify({
							document: n.document
						}) : n.markdown && (i.markdown = n.markdown), {
							title: n.title,
							isLiveChat: n.isChatPost,
							isNsfw: n.isNSFW,
							isSpoiler: n.isSpoiler,
							votingEndsAt: s.endDate.toISOString(),
							body: i,
							options: r
						}
					}) : []
				},
				a = e => {
					var t, n;
					return !!(null === (n = null === (t = e.features) || void 0 === t ? void 0 : t.predictions) || void 0 === n ? void 0 : n.creation.length)
				}
		},
		"./src/reddit/selectors/features/predictions/leaderboards/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "h", (function() {
				return c
			})), n.d(t, "g", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			}));
			var s = n("./src/lib/initializeClient/installReducer.ts"),
				r = n("./src/reddit/reducers/features/predictions/index.ts");
			Object(s.a)({
				features: {
					predictions: r.a
				}
			});
			const o = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				i = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				a = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.error) || !1
				},
				d = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.leaderboards[t.subredditId]) || void 0 === r ? void 0 : r.data) || null
				},
				c = (e, t) => {
					var n, s;
					return (null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.tournamentsLeaderboards[t.tournamentId]) || null
				},
				l = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetching) || !1
				},
				u = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.isFetched) || !1
				},
				m = (e, t) => {
					var n, s, r;
					return (null === (r = null === (s = null === (n = e.features) || void 0 === n ? void 0 : n.predictions) || void 0 === s ? void 0 : s.queriedLeaderboards[t.tournamentId]) || void 0 === r ? void 0 : r.error) || !1
				}
		},
		"./src/reddit/selectors/gild.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "g", (function() {
				return i
			})), n.d(t, "c", (function() {
				return a
			})), n.d(t, "e", (function() {
				return d
			})), n.d(t, "a", (function() {
				return c
			}));
			const s = e => e.gild.gildModalThingId,
				r = e => e.gild.correlationId || void 0,
				o = e => e.gild.isAnonymous,
				i = e => e.gild.isIframed,
				a = e => e.gild.message,
				d = e => e.gild.api.pending,
				c = e => e.gild.api.error
		},
		"./src/reddit/selectors/gold/awardIcon.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "a", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Gold/Award.ts"),
				o = n("./src/reddit/selectors/commentSelector.ts"),
				i = n("./src/reddit/selectors/gold/giveAwards.ts"),
				a = n("./src/reddit/selectors/posts.ts"),
				d = n("./src/reddit/selectors/user.ts"),
				c = n("./src/reddit/selectors/userPrefs.ts");
			const l = [32, 48, 64, 128],
				u = (e, t, n) => {
					const s = t ? e[`staticIcon${n}`] : e[`icon${n}`];
					return (null == s ? void 0 : s.url) ? s.url : t ? e.staticIcon.url : e.icon.url
				},
				m = e => {
					let {
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					} = e;
					return t.awardSubType === r.d.Group ? (e => {
						let {
							award: t,
							size: n,
							prefersReducedMotion: s,
							postOrComment: r
						} = e, o = t;
						if ((null == r ? void 0 : r.awardCountsById) && r.awardCountsById[t.id] && t.tiers) {
							const e = r.awardCountsById[t.id];
							o = t.tiers.reduce((t, n) => e >= n.awardingsRequired ? n : t)
						}
						return u(o, s, n)
					})({
						award: t,
						size: n,
						prefersReducedMotion: s,
						postOrComment: o
					}) : u(t, s, n)
				},
				p = Object(s.a)((e, t) => {
					let {
						awards: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					const i = Object(c.d)(e),
						d = l.find(e => e >= s),
						u = r ? Object(a.G)(e, {
							postId: r
						}) || Object(o.b)(e, {
							commentId: r
						}) : void 0;
					return n.reduce((e, t) => (t && (e[t.id] = m({
						award: t,
						size: d,
						prefersReducedMotion: i,
						postOrComment: u
					})), e), {})
				}),
				b = (e, t) => {
					let {
						award: n,
						minSize: s,
						postOrCommentId: r
					} = t;
					return n ? p(e, {
						awards: [n],
						minSize: s,
						postOrCommentId: r
					})[n.id] : void 0
				},
				f = (e, t) => {
					let {
						minSize: n,
						userName: s
					} = t;
					const r = Object(d.Bb)(e, {
						userName: s
					});
					if (r && r.awardedLastMonth && r.awardedLastMonth.topAward) return b(e, {
						award: r.awardedLastMonth.topAward,
						minSize: n
					})
				},
				h = e => {
					const t = Object(i.b)(e),
						n = Object(i.a)(e);
					return b(e, {
						award: t,
						postOrCommentId: n || void 0,
						minSize: 512
					})
				}
		},
		"./src/reddit/selectors/gold/giveAwards.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = e => e.gild.selectedAward,
				r = e => e.gild.gildedThing
		},
		"./src/reddit/selectors/gold/powerups/benefitSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return c
			})), n.d(t, "b", (function() {
				return l
			}));
			var s = n("./src/reddit/models/Gold/Powerups/index.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/actions/gold/constants.ts");
			const i = {};
			var a = function() {
					let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
						t = arguments.length > 1 ? arguments[1] : void 0;
					var n, s;
					switch (t.type) {
						case o.nb:
						case o.ob: {
							const {
								benefitStatuses: s,
								subredditId: r
							} = t.payload;
							if (!s) return e;
							const o = null !== (n = e[r]) && void 0 !== n ? n : {},
								i = {};
							return s.forEach(e => {
								let {
									benefit: t,
									isEnabled: n
								} = e;
								i[t] = n
							}), {
								...e,
								[r]: {
									...o,
									...i
								}
							}
						}
						case o.L: {
							const {
								benefitStatuses: n,
								subredditId: r
							} = t.payload, o = null !== (s = e[r]) && void 0 !== s ? s : {}, i = {};
							return n.forEach(e => {
								let {
									benefit: t,
									isEnabled: n
								} = e;
								i[t] = n
							}), {
								...e,
								[r]: {
									...o,
									...i
								}
							}
						}
						default:
							return e
					}
				},
				d = n("./node_modules/reselect/es/index.js");
			Object(r.a)({
				features: {
					powerupsBenefitSettings: a
				}
			});
			const c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return n ? e.features.powerupsBenefitSettings[n] : null
				},
				l = (e => Object(d.a)(c, t => !!(null == t ? void 0 : t[e])))(s.a.CommentsWithGifs)
		},
		"./src/reddit/selectors/goldPurchaseModals.ts": function(e, t, n) {
			"use strict";
			n.d(t, "r", (function() {
				return i
			})), n.d(t, "t", (function() {
				return a
			})), n.d(t, "s", (function() {
				return d
			})), n.d(t, "v", (function() {
				return c
			})), n.d(t, "u", (function() {
				return l
			})), n.d(t, "b", (function() {
				return u
			})), n.d(t, "q", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "o", (function() {
				return b
			})), n.d(t, "p", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "h", (function() {
				return _
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "x", (function() {
				return v
			})), n.d(t, "y", (function() {
				return x
			})), n.d(t, "w", (function() {
				return O
			})), n.d(t, "z", (function() {
				return E
			})), n.d(t, "f", (function() {
				return y
			})), n.d(t, "g", (function() {
				return C
			})), n.d(t, "i", (function() {
				return j
			})), n.d(t, "k", (function() {
				return k
			})), n.d(t, "m", (function() {
				return I
			})), n.d(t, "j", (function() {
				return S
			})), n.d(t, "n", (function() {
				return w
			})), n.d(t, "e", (function() {
				return T
			})), n.d(t, "d", (function() {
				return N
			}));
			var s = n("./src/reddit/selectors/gold/purchaseCatalog.ts"),
				r = n("./src/lib/initializeClient/installReducer.ts"),
				o = n("./src/reddit/reducers/features/goldPurchase/index.ts");
			Object(r.a)({
				features: {
					goldPurchase: o.a
				}
			});
			const i = e => e.features.goldPurchase.purchaseModal.activePage,
				a = e => e.features.goldPurchase.purchaseModal.gildThingId || void 0,
				d = e => e.features.goldPurchase.purchaseModal.correlationId || void 0,
				c = e => e.features.goldPurchase.purchaseModal.showModal,
				l = e => e.features.goldPurchase.purchaseModal.packageId,
				u = e => e.features.goldPurchase.packageOfferModal.packageId,
				m = e => e.features.goldPurchase.premiumPurchaseModal.renewInterval,
				p = e => {
					const t = Object(s.l)(e),
						n = (e => e.features.goldPurchase.premiumPurchaseModal.packageId)(e);
					return t.length && n && t.find(e => e.mobileId === n) || null
				},
				b = e => e.features.goldPurchase.premiumPurchaseModal.activePage,
				f = e => e.features.goldPurchase.premiumPurchaseModal.showModal,
				h = e => e.features.goldPurchase.payment.paymentMethod,
				_ = e => e.features.goldPurchase.payment.cardName,
				g = e => e.features.goldPurchase.payment.postalCode,
				v = e => e.features.goldPurchase.payment.savedCardsPending,
				x = e => e.features.goldPurchase.payment.savedCards,
				O = e => e.features.goldPurchase.payment.rememberCard,
				E = e => e.features.goldPurchase.payment.useSavedCard,
				y = e => e.features.goldPurchase.payment.cardValidation.cardCvc,
				C = e => e.features.goldPurchase.payment.cardValidation.cardExpiry,
				j = e => e.features.goldPurchase.payment.cardValidation.cardNumber,
				k = e => e.features.goldPurchase.payment.cardValidation.nameOnCard,
				I = e => e.features.goldPurchase.payment.cardValidation.postalCode,
				S = e => e.features.goldPurchase.payment.stripeToken.errorMessage,
				w = e => e.features.goldPurchase.payment.stripeToken.pending,
				T = e => e.features.goldPurchase.payment.paypal.passthrough,
				N = e => e.features.goldPurchase.payment.paypal.errorMessage
		},
		"./src/reddit/selectors/inlineSubredditEditing.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			}));
			var s = n("./src/reddit/featureFlags/index.ts"),
				r = n("./src/reddit/selectors/moderatorPermissions.ts");
			const o = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!s.d.subredditInlineEditing(e)) return !1;
					const o = n ? Object(r.n)(e, {
						subredditId: n
					}) : null;
					return !!o && (e => !!e && e.config)(o)
				},
				i = e => e.subreddits.api.inlineEditing.pending
		},
		"./src/reddit/selectors/modUserNotes.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			})), n.d(t, "d", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			})), n.d(t, "a", (function() {
				return p
			})), n.d(t, "g", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/redditGQL/types.ts"),
				i = n("./src/lib/initializeClient/installReducer.ts"),
				a = n("./src/reddit/reducers/features/modUserNotes/index.ts");
			Object(i.a)({
				features: {
					modUserNotes: a.a
				}
			});
			const d = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o),
						a = e.features.modUserNotes.order[i];
					return a ? a.map(t => e.features.modUserNotes.models[t]) : []
				}),
				c = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o);
					return e.features.modUserNotes.api.pending[i]
				},
				l = e => e.features.modUserNotes.api.error,
				u = (e, t) => {
					let {
						subredditId: n,
						userId: s,
						filter: o
					} = t;
					const i = Object(r.d)(n, s, o);
					return e.features.modUserNotes.loadMore[i]
				},
				m = (e, t, n) => {
					if (!t || !n) return;
					const s = e.features.modUserNotes.lastAuthorModNotes[Object(r.d)(n, t, o.x.All)];
					return s ? e.features.modUserNotes.models[s] : void 0
				},
				p = (e, t, n) => {
					if (!t || !n) return;
					return e.features.modUserNotes.totalCount[Object(r.d)(n, t, o.x.All)]
				},
				b = (e, t, n, s) => {
					if (!s) return;
					const r = p(e, t, n);
					return r && r[s] || 0
				}
		},
		"./src/reddit/selectors/moderatingComments.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return s
			})), n.d(t, "a", (function() {
				return r
			}));
			const s = (e, t) => {
					let {
						commentId: n,
						commentsPageKey: s
					} = t;
					if (!n) return !1;
					if (e.features.comments.collapsed[s] && n in e.features.comments.collapsed[s]) return !!e.features.comments.collapsed[s][n];
					const r = e.features.comments.models[n];
					return !!r && ("computedCollapsed" in r ? !!r.computedCollapsed : r.collapsedBecauseCrowdControl ? !e.modModeEnabled : r.collapsed)
				},
				r = (e, t) => {
					let {
						commentId: n
					} = t;
					if (!n) return !1;
					const s = e.features.comments.models[n];
					return !(!s || !s.collapsedBecauseCrowdControl) && e.modModeEnabled
				}
		},
		"./src/reddit/selectors/moderationLog.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "d", (function() {
				return i
			})), n.d(t, "e", (function() {
				return a
			})), n.d(t, "f", (function() {
				return d
			})), n.d(t, "g", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "h", (function() {
				return u
			})), n.d(t, "b", (function() {
				return m
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/ModerationLog/index.ts");
			const o = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t, s = [];
					const o = a(e),
						i = u(e);
					if (o && i) {
						const t = Object(r.a)(n, o, i),
							a = e.pages.modHub.moderationLog.actions.itemOrder[n] && e.pages.modHub.moderationLog.actions.itemOrder[n][t];
						a && (s = a.map(t => e.pages.modHub.moderationLog.actions.models[n][t]))
					}
					return s
				}),
				i = e => e.pages.modHub.moderationLog.approximateCount,
				a = e => e.pages.modHub.moderationLog.endCursor,
				d = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderationLog.hasNextPage[n]
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderationLog.hasPreviousPage[n]
				},
				l = (e, t) => e.pages.modHub.moderationLog.moderators[t] || [],
				u = e => e.pages.modHub.moderationLog.startCursor,
				m = e => e.pages.modHub.moderationLog.actionCategories || {}
		},
		"./src/reddit/selectors/muted.ts": function(e, t, n) {
			"use strict";
			n.d(t, "g", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts"),
				o = n("./src/lib/initializeClient/installReducer.ts"),
				i = n("./src/reddit/reducers/pages/modHub/index.ts");
			Object(o.a)({
				pages: {
					modHub: i.a
				}
			});
			const a = [],
				d = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.muted.userOrder[n];
					return s ? s.map(t => e.pages.modHub.muted.models[n][t]) : a
				}),
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = Object(r.e)(n);
					return !!e.pages.modHub.muted.api.pending[s]
				},
				l = (e, t, n) => !!e.pages.modHub.muted.models[t] && !!e.pages.modHub.muted.models[t][n],
				u = e => !!e.pages.modHub.muted.search.api.pending,
				m = e => e.pages.modHub.muted.search.result,
				p = e => {
					var t, n, s;
					return null === (s = null === (n = null === (t = e.pages) || void 0 === t ? void 0 : t.modHub) || void 0 === n ? void 0 : n.muted) || void 0 === s ? void 0 : s.inContext
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.muted.loadMore[n]
				}
		},
		"./src/reddit/selectors/notificationPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "f", (function() {
				return o
			})), n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			}));
			const s = e => e.user.notificationPrefs.api.getPreferences.loaded,
				r = e => e.user.notificationPrefs.api.getPreferences.pending,
				o = e => e.user.notificationPrefs.api.setPreferences.pending,
				i = e => e.user.notificationPrefs.preferences,
				a = e => e.user.notificationPrefs.isNotificationPromptVisible,
				d = (e, t) => {
					var n, s;
					const r = (e => e.user.notificationPrefs.pushSettingsLayout)(e),
						o = null === (n = null == r ? void 0 : r.rows) || void 0 === n ? void 0 : n.byId;
					return o && (null === (s = o[t]) || void 0 === s ? void 0 : s.isEnabled)
				}
		},
		"./src/reddit/selectors/notificationsInbox.tsx": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return i
			})), n.d(t, "d", (function() {
				return d
			})), n.d(t, "c", (function() {
				return c
			})), n.d(t, "f", (function() {
				return l
			})), n.d(t, "g", (function() {
				return u
			})), n.d(t, "a", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "h", (function() {
				return f
			}));
			var s = n("./src/lib/notifications/constants.ts"),
				r = n("./src/reddit/actions/notifications/utils.ts"),
				o = n("./node_modules/reselect/es/index.js");
			const i = e => e.notificationsInbox && e.notificationsInbox.api && e.notificationsInbox.api.pending,
				a = e => e.notificationsInbox && e.notificationsInbox.pageInfo,
				d = Object(o.a)(a, e => !(!e || !e.hasNextPage)),
				c = Object(o.a)(a, e => e && e.endCursor),
				l = e => e.notificationsInbox && e.notificationsInbox.notifications,
				u = Object(o.a)(l, e => e.slice(0, 5)),
				m = e => e.notificationsInbox && e.notificationsInbox.earlierDividerIndex,
				p = Object(o.a)(l, m, (e, t) => {
					if (t) {
						const n = parseInt(t);
						return e.slice(0, n)
					}
					return e
				}),
				b = Object(o.a)(l, m, (e, t) => {
					if (t) {
						const n = parseInt(t);
						return e.slice(n)
					}
					return null
				}),
				f = Object(o.a)(r.a, e => e === s.c.NotificationsSupported)
		},
		"./src/reddit/selectors/onboarding.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			})), n.d(t, "e", (function() {
				return O
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./src/lib/safeJSONParse/index.ts"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/lib/isFakeSubreddit/index.ts"),
				i = n("./src/reddit/constants/experiments.ts"),
				a = n("./src/reddit/constants/parameters.ts"),
				d = n("./src/reddit/contexts/PageLayer/selectors.ts"),
				c = n("./src/reddit/helpers/onboarding/reonboarding.ts"),
				l = n("./src/reddit/selectors/activeModal.ts"),
				u = n("./src/reddit/selectors/emailVerification.ts"),
				m = n("./src/reddit/selectors/experiments/onboarding.ts"),
				p = n("./src/reddit/selectors/experiments/targetedOnboardingSkip.ts"),
				b = n("./src/reddit/selectors/platform.ts"),
				f = n("./src/reddit/selectors/user.ts");
			const h = e => {
					const t = Object(b.r)(e);
					return Boolean((null == t ? void 0 : t[a.G]) && Object(s.a)(t[a.G]))
				},
				_ = e => e.onboarding.shouldSkipOnboardingState,
				g = Object(r.a)(f.R, f.Q, h, _, e => {
					var t;
					const n = null === (t = e.platform.currentPage) || void 0 === t ? void 0 : t.urlParams,
						s = n.subredditName;
					return Object(p.a)(e) !== i.Yf.TargetedOnboarding || s && Object(o.a)(s, {
						countryCode: n.countryCode,
						languageCode: n.languageCode
					}) || !Object.keys(n).length
				}, (e, t, n, s, r) => (e || t) && n && !s && r),
				v = e => {
					const {
						genderUpdateState: t
					} = e.onboarding;
					if (t.success || t.failure) return t
				},
				x = Object(r.a)(m.i, e => e.onboarding.interestTopicRecommendationsState, (e, t) => e && !Object(i.rg)(e) ? t : null),
				O = Object(r.a)(m.i, (e, t) => {
					let {
						pageLayer: n
					} = t;
					return Object(d.K)(n) || Object(d.L)(n) || Object(d.z)(n)
				}, l.b, u.a, _, (e, t, n, s, r) => e === i.nb.PopoverFeed15 && t && Object(c.c)() && !n && !s && !r)
		},
		"./src/reddit/selectors/removalReasons.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "a", (function() {
				return o
			}));
			const s = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (e.features.removalReasons.reasonOrder[n]) {
						return e.features.removalReasons.reasonOrder[n].map(t => e.features.removalReasons.models[t])
					}
					return []
				},
				r = e => e.features.removalReasons.removedItemIds && e.features.removalReasons.removedItemIds.itemIds.length ? e.features.removalReasons.removedItemIds : null,
				o = e => e.features.removalReasons.api.pending
		},
		"./src/reddit/selectors/removedPosts.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return m
			})), n.d(t, "c", (function() {
				return p
			})), n.d(t, "b", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "d", (function() {
				return h
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/fbt/lib/FbtPublic.js"),
				r = n("./node_modules/reselect/es/index.js"),
				o = n("./src/reddit/helpers/getPostFromRouteMatch/index.ts"),
				i = n("./src/reddit/helpers/getRichTextContent/index.ts"),
				a = n("./src/reddit/models/Media/index.ts"),
				d = n("./src/reddit/models/Post/index.ts"),
				c = n("./src/reddit/selectors/user.ts");
			const l = new Set([d.g.AntiEvilOps, d.g.AutomodFiltered, d.g.CommunityOps, d.g.ContentTakedown, d.g.CopyrightTakedown, d.g.Moderator, d.g.Reddit]),
				u = new Set([d.g.Author, d.g.AuthorDeleted]),
				m = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return l.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[removed]", null, {
						hk: "2CBRa4"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				p = Object(r.a)(o.a, e => {
					var t;
					if (!e) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					if (e.created > Date.UTC(2019, 0)) return !1;
					const n = s.fbt._("[deleted]", null, {
						hk: "12mOne"
					}).toString();
					let r = Object(i.b)(e);
					return r || (null === (t = e.media) || void 0 === t ? void 0 : t.type) !== a.o.TEXT || (r = e.media.markdownContent), r === n
				}),
				b = Object(r.a)(o.a, e => {
					if (!e) return !1;
					if (e && e.isSpam) return !1;
					if (e.removedByCategory) {
						const t = e.removedByCategory;
						return u.has(t)
					}
					return !(e.created > Date.UTC(2019, 0))
				}),
				f = Object(r.a)(c.l, o.a, (e, t) => !!((null == e ? void 0 : e.id) && (null == t ? void 0 : t.authorId)) && e.id === t.authorId),
				h = Object(r.a)(o.a, e => !(!e || !1 !== e.isRobotIndexable))
		},
		"./src/reddit/selectors/scheduledPosts/index.ts": function(e, t, n) {
			"use strict";
			n.d(t, "h", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "i", (function() {
				return c
			})), n.d(t, "j", (function() {
				return l
			})), n.d(t, "f", (function() {
				return u
			})), n.d(t, "q", (function() {
				return b
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "p", (function() {
				return _
			})), n.d(t, "k", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "r", (function() {
				return x
			})), n.d(t, "m", (function() {
				return O
			})), n.d(t, "n", (function() {
				return E
			})), n.d(t, "d", (function() {
				return y
			})), n.d(t, "e", (function() {
				return C
			})), n.d(t, "o", (function() {
				return j
			})), n.d(t, "b", (function() {
				return k
			}));
			var s = n("./src/reddit/helpers/graphql/normalizeFlairFromGql/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/models/ScheduledPost/index.ts");
			const i = (e, t) => {
					let {
						subredditId: n
					} = t;
					return ((e, t) => {
						let {
							subredditId: n,
							type: s
						} = t;
						return !!e.posts.scheduledPosts[s].models[n]
					})(e, {
						subredditId: n,
						type: o.g.standalonePosts
					})
				},
				a = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return !!e.posts.scheduledPosts[s].pageInfo[n] && e.posts.scheduledPosts[s].pageInfo[n].hasNextPage
				},
				d = (e, t) => {
					let {
						subredditId: n,
						type: s
					} = t;
					return e.posts.scheduledPosts[s].pageInfo[n] ? e.posts.scheduledPosts[s].pageInfo[n].endCursor : null
				},
				c = e => e.posts.scheduledPosts.api.pending,
				l = e => e.posts.scheduledPosts.api.pendingUpdate,
				u = e => e.posts.scheduledPosts.api.error,
				m = {},
				p = [],
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.standalonePosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.standalonePosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.standalonePosts.models[n][t])
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return (e.posts.scheduledPosts.recurringPosts.postOrder[n] || p).filter(t => !!(e.posts.scheduledPosts.recurringPosts.models[n] || m)[t]).map(t => e.posts.scheduledPosts.recurringPosts.models[n][t])
				},
				h = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s,
						type: r
					} = t;
					return (e.posts.scheduledPosts[r].models[n] || m)[s] || void 0
				},
				_ = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return h(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.standalonePosts
					})
				},
				g = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					const r = h(e, {
						subredditId: n,
						scheduledPostId: s,
						type: o.g.recurringPosts
					});
					return r || r
				},
				v = (e, t) => {
					let {
						subredditId: n,
						scheduledPostId: s
					} = t;
					return _(e, {
						subredditId: n,
						scheduledPostId: s
					}) || g(e, {
						subredditId: n,
						scheduledPostId: s
					})
				},
				x = e => e.creations.formData.scheduledPostId,
				O = e => {
					let {
						scheduledPost: t
					} = e;
					return (e => {
						let {
							flair: t,
							isNsfw: n,
							isSpoiler: o,
							isOriginalContent: i
						} = e;
						const a = [];
						return i && a.push({
							text: "OC",
							type: r.f.Oc
						}), t && a.push(...Object(s.c)(t)), o && a.push({
							text: "spoiler",
							type: r.f.Spoiler
						}), n && a.push({
							text: "nsfw",
							type: r.f.Nsfw
						}), a
					})(t)
				},
				E = e => {
					let {
						scheduledPost: t
					} = e;
					const n = O({
							scheduledPost: t
						}),
						s = n.find(e => e.type === r.f.Richtext);
					return s || (n.find(e => e.type === r.f.Text) || null)
				},
				y = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.scheduledPostId,
				C = e => e.posts.scheduledPosts[o.g.recurringPosts].editModal.subredditId,
				j = e => e.posts.scheduledPosts.api.pendingUpdate,
				k = e => e.posts.scheduledPosts.api.creationToken
		},
		"./src/reddit/selectors/seo/linksModule.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return i
			})), n.d(t, "b", (function() {
				return c
			})), n.d(t, "c", (function() {
				return l
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/selectors/experiments/loggedOutOneFeed.ts"),
				o = n("./src/reddit/selectors/user.ts");
			const i = e => {
					const t = Object(r.e)(e);
					return !Object(o.R)(e) && !t && e.seo.linksModule.frontpage || null
				},
				a = e => {
					const t = e.split("/");
					if ("r" === t[1]) return t[2]
				},
				d = Object(s.a)(i, e => e ? e.map(e => ({
					...e,
					links: e.links.map(e => ({
						...e,
						title: a(e.url)
					})).filter(e => e.title)
				})) : null),
				c = Object(s.a)(d, e => e ? e.map(e => ({
					...e,
					links: e.links.filter(e => e.visible)
				})) : null),
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = ((e, t) => {
						let {
							subredditId: n
						} = t;
						return e.seo.linksModule.subreddits && e.seo.linksModule.subreddits[n]
					})(e, {
						subredditId: n
					});
					return s && s.subreddits
				}
		},
		"./src/reddit/selectors/seo/topicLinks.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			}));
			const s = (e, t) => {
				let {
					subredditId: n
				} = t;
				return e.seo.topicLinks.subreddits && e.seo.topicLinks.subreddits[n]
			}
		},
		"./src/reddit/selectors/showPromotedCTA.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			}));
			var s = n("./node_modules/reselect/es/index.js"),
				r = n("./src/reddit/constants/experiments.ts"),
				o = n("./src/reddit/helpers/chooseVariant/index.ts"),
				i = n("./src/reddit/models/Post/index.ts"),
				a = n("./src/reddit/selectors/posts.ts");
			const d = e => Object(o.c)(e, {
					experimentName: r.bf,
					experimentEligibilitySelector: o.a
				}),
				c = (e, t) => (t === r.jf.Enabled && (null == e ? void 0 : e.isCreatedFromAdsUi) || (null == e ? void 0 : e.isSponsored)) && !Object(i.B)(e),
				l = Object(s.a)(a.G, d, (e, t) => c(e, t));
			Object(s.a)((e, t) => t, d, (e, t) => c(e, t))
		},
		"./src/reddit/selectors/streamingModSettings.ts": function(e, t, n) {
			"use strict";
			n.d(t, "e", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "d", (function() {
				return l
			}));
			const s = {
					startTime: "",
					endTime: ""
				},
				r = {
					isLiveStreamingEnabled: !1,
					maxLiveStreams: void 0,
					minKarma: void 0,
					minAccountAgeDays: void 0,
					durationLimitSeconds: void 0,
					schedule: {
						sunday: s,
						monday: s,
						tuesday: s,
						wednesday: s,
						thursday: s,
						friday: s,
						saturday: s
					},
					whitelistedUsers: [],
					broadcasterPrompt: "",
					isDiscoveryUnitShown: !1,
					inSubMinKarma: void 0
				},
				o = (e, t) => {
					const n = e.streaming.modSettings[t.subredditId];
					return n ? {
						isLiveStreamingEnabled: n.isLiveStreamingEnabled,
						maxLiveStreams: n.maxLiveStreams,
						minKarma: n.minKarma,
						minAccountAgeDays: n.minAccountAgeDays,
						durationLimitSeconds: n.durationLimitSeconds,
						schedule: {
							sunday: c(n.weeklySchedule.sunday),
							monday: c(n.weeklySchedule.monday),
							tuesday: c(n.weeklySchedule.tuesday),
							wednesday: c(n.weeklySchedule.wednesday),
							thursday: c(n.weeklySchedule.thursday),
							friday: c(n.weeklySchedule.friday),
							saturday: c(n.weeklySchedule.saturday)
						},
						whitelistedUsers: n.whitelistedRedditors,
						broadcasterPrompt: n.broadcasterPrompt,
						isDiscoveryUnitShown: n.isDiscoveryUnitShown,
						inSubMinKarma: n.inSubMinKarma
					} : r
				},
				i = (e, t) => !!e.streaming.modSettings[t],
				a = e => !!e.streaming.api.pending,
				d = (e, t) => !!e.streaming.modSettings[t] && e.streaming.modSettings[t].isLiveStreamingEnabled,
				c = e => ({
					...s,
					...e[0]
				}),
				l = (e, t) => {
					const n = e.streaming.modSettings[t.subredditId];
					if (!n) return !1;
					const s = new Date;
					return u(s, n.weeklySchedule)
				},
				u = (e, t) => {
					const n = m(e);
					return p(n, t).some(t => b(e, t))
				},
				m = e => {
					return ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"][e.getUTCDay()]
				},
				p = (e, t) => t[e],
				b = (e, t) => {
					const n = e.getUTCHours(),
						s = e.getUTCMinutes(),
						{
							startTime: r,
							endTime: o
						} = t,
						[i, a] = r.split(":").map(Number),
						[d, c] = o.split(":").map(Number);
					let l = 60 * i + a,
						u = 60 * d + c;
					const m = 60 * n + s;
					return 1439 === u && u++, 1439 === l && l++, m >= l && m < u
				}
		},
		"./src/reddit/selectors/subredditModeration.ts": function(e, t, n) {
			"use strict";
			n.d(t, "j", (function() {
				return i
			})), n.d(t, "g", (function() {
				return a
			})), n.d(t, "b", (function() {
				return d
			})), n.d(t, "e", (function() {
				return c
			})), n.d(t, "o", (function() {
				return l
			})), n.d(t, "m", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "h", (function() {
				return p
			})), n.d(t, "k", (function() {
				return b
			})), n.d(t, "l", (function() {
				return f
			})), n.d(t, "c", (function() {
				return h
			})), n.d(t, "d", (function() {
				return _
			})), n.d(t, "i", (function() {
				return g
			})), n.d(t, "a", (function() {
				return v
			})), n.d(t, "f", (function() {
				return x
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/SubredditModeration/index.ts");
			const o = [],
				i = Object(s.a)((e, t) => {
					let {
						subredditId: n,
						before: s,
						after: o
					} = t;
					const i = Object(r.e)(n, o, s),
						a = e.pages.modHub.moderators.userOrder.data[n] && e.pages.modHub.moderators.userOrder.data[n][i];
					return a ? a.map(t => e.pages.modHub.moderators.models[n][t]) : []
				}),
				a = (e, t, n) => !!e.pages.modHub.moderators.models[t] && !!e.pages.modHub.moderators.models[t][n],
				d = (e, t) => {
					let {
						subredditId: n,
						beforeEditable: s,
						afterEditable: o
					} = t;
					const i = Object(r.e)(n, o, s),
						a = e.pages.modHub.moderators.editableUserOrder.data[n] && e.pages.modHub.moderators.editableUserOrder.data[n][i];
					return a ? a.map(t => e.pages.modHub.moderators.editableModerators[n][t]) : []
				},
				c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.editableModerators[n] || null
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.models[n] || null
				},
				u = e => !!e.pages.modHub.moderators.search.api.pending,
				m = e => e.pages.modHub.moderators.search.result,
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					return !!e.pages.modHub.moderators.invitePending[n]
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].after
				},
				f = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreModerators[n] && e.pages.modHub.moderators.loadMoreModerators[n].before
				},
				h = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].after
				},
				_ = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.pages.modHub.moderators.loadMoreEditableModerators[n] && e.pages.modHub.moderators.loadMoreEditableModerators[n].before
				},
				g = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.after, t.before);
					return !!e.pages.modHub.moderators.userOrder.api.pending[n]
				},
				v = (e, t) => {
					const n = Object(r.e)(t.subredditId, t.afterEditable, t.beforeEditable);
					return !!e.pages.modHub.moderators.editableUserOrder.api.pending[n]
				},
				x = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = e.pages.modHub.moderators.invitedModerators.userOrder[n];
					return s ? s.map(t => e.pages.modHub.moderators.invitedModerators.models[n][t]) : o
				})
		},
		"./src/reddit/selectors/subredditWiki.ts": function(e, t, n) {
			"use strict";
			n.d(t, "b", (function() {
				return i
			})), n.d(t, "a", (function() {
				return a
			})), n.d(t, "c", (function() {
				return d
			})), n.d(t, "p", (function() {
				return c
			})), n.d(t, "q", (function() {
				return l
			})), n.d(t, "o", (function() {
				return u
			})), n.d(t, "n", (function() {
				return m
			})), n.d(t, "i", (function() {
				return p
			})), n.d(t, "d", (function() {
				return b
			})), n.d(t, "j", (function() {
				return f
			})), n.d(t, "m", (function() {
				return h
			})), n.d(t, "k", (function() {
				return _
			})), n.d(t, "l", (function() {
				return g
			})), n.d(t, "e", (function() {
				return v
			})), n.d(t, "h", (function() {
				return x
			})), n.d(t, "f", (function() {
				return O
			})), n.d(t, "g", (function() {
				return E
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/helpers/wiki/makeWikiPageKey.ts");
			const o = [],
				i = (e, t) => {
					var n;
					const {
						subredditName: s
					} = t;
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.directory[s.toLowerCase()]
				},
				a = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.subreddits.api.wiki.pending[n.toLowerCase()]
				},
				d = (e, t) => {
					var n;
					const s = Object(r.a)(t);
					if (null === (n = e.pages) || void 0 === n ? void 0 : n.subredditWiki) return e.pages.subredditWiki.pages[s]
				},
				c = (e, t) => {
					let {
						listingKey: n
					} = t;
					return e.pages.subredditWiki.revisions.listings[n]
				},
				l = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.pending[n]
				},
				u = (e, t) => {
					let {
						listingKey: n
					} = t;
					return !!e.pages.subredditWiki.revisions.api.error[n]
				},
				m = (e, t) => {
					return (e => e.pages.subredditWiki.revisions.models)(e)[t.revisionId]
				},
				p = (e, t) => {
					let {
						key: n
					} = t;
					return e.pages.subredditWiki.diff[n]
				},
				b = (e, t) => {
					const n = Object(r.a)(t);
					return e.pages.subredditWiki.pageSettings[n]
				},
				f = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiContributors.listing.api.pending[n.toLowerCase()]
				},
				h = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiContributors.listing,
						i = r.userOrder[s],
						a = r.models[s];
					return i ? i.map(e => a[e]) : o
				}),
				_ = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.listing.afterToken[n.toLowerCase()]
				},
				g = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiContributors.search[n.toLowerCase()]
				},
				v = (e, t) => {
					const {
						subredditName: n
					} = t;
					return !!e.pages.subredditWiki.wikiBannedContributors.listing.api.pending[n.toLowerCase()]
				},
				x = Object(s.a)((e, t) => {
					let {
						subredditName: n
					} = t;
					const s = n.toLowerCase(),
						r = e.pages.subredditWiki.wikiBannedContributors.listing,
						i = r.userOrder[s],
						a = r.models[s];
					return i ? i.map(e => a[e]) : o
				}),
				O = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.listing.afterToken[n.toLowerCase()]
				},
				E = (e, t) => {
					const {
						subredditName: n
					} = t;
					return e.pages.subredditWiki.wikiBannedContributors.search[n.toLowerCase()]
				}
		},
		"./src/reddit/selectors/tags.ts": function(e, t, n) {
			"use strict";
			n.d(t, "f", (function() {
				return u
			})), n.d(t, "e", (function() {
				return m
			})), n.d(t, "g", (function() {
				return p
			})), n.d(t, "n", (function() {
				return b
			})), n.d(t, "A", (function() {
				return f
			})), n.d(t, "B", (function() {
				return h
			})), n.d(t, "i", (function() {
				return _
			})), n.d(t, "j", (function() {
				return g
			})), n.d(t, "l", (function() {
				return x
			})), n.d(t, "r", (function() {
				return O
			})), n.d(t, "t", (function() {
				return E
			})), n.d(t, "p", (function() {
				return k
			})), n.d(t, "b", (function() {
				return I
			})), n.d(t, "d", (function() {
				return w
			})), n.d(t, "c", (function() {
				return T
			})), n.d(t, "o", (function() {
				return N
			})), n.d(t, "k", (function() {
				return P
			})), n.d(t, "z", (function() {
				return R
			})), n.d(t, "y", (function() {
				return A
			})), n.d(t, "u", (function() {
				return M
			})), n.d(t, "a", (function() {
				return L
			})), n.d(t, "q", (function() {
				return D
			})), n.d(t, "C", (function() {
				return F
			})), n.d(t, "w", (function() {
				return U
			})), n.d(t, "s", (function() {
				return q
			})), n.d(t, "x", (function() {
				return G
			})), n.d(t, "h", (function() {
				return H
			})), n.d(t, "v", (function() {
				return W
			})), n.d(t, "D", (function() {
				return V
			})), n.d(t, "m", (function() {
				return z
			}));
			n("./node_modules/core-js/modules/web.dom.iterable.js");
			var s = n("./node_modules/lodash/some.js"),
				r = n.n(s),
				o = n("./node_modules/lodash/values.js"),
				i = n.n(o),
				a = n("./src/lib/objectSelector/index.ts"),
				d = n("./src/reddit/helpers/tags/index.ts"),
				c = n("./src/reddit/models/Tags/index.ts");
			const l = e => e.tags.creation.selectedOptions || [],
				u = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id && t.push(l(e)[n].id);
					return t || []
				},
				m = e => (l(e) || []).filter(e => !!e.displayText).map(e => e.displayText),
				p = e => {
					const t = [];
					for (let n = 0; n < l(e).length; n++) l(e)[n].id || t.push(l(e)[n].displayText);
					return t || []
				},
				b = e => Object.keys(e.tags.models.globalSubredditTags).length > 0,
				f = e => e.tags.api.create.error || e.tags.api.deleteTag.error || e.tags.api.fetch.error || e.tags.api.update.error,
				h = e => e.tags.api.create.pending || e.tags.api.deleteTag.pending || e.tags.api.fetch.pending || e.tags.api.update.pending,
				_ = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.inputByItemId[n] || ""
				},
				g = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.suggestedInputByItemId[n] || ""
				},
				v = [],
				x = (e, t) => {
					let {
						subredditId: n
					} = t;
					return r()(O(e, {
						subredditId: n
					}), e => !!e.action) || r()(y(e, {
						subredditId: n
					}), e => !!e.action)
				},
				O = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedOptions[n] || v
				},
				E = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.selectedSuggestedOptions[n] || v
				},
				y = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.selected.deselectedOptions[n] || v
				},
				C = {},
				j = {},
				k = e => e.tags.availableGlobalTagOrder.recommendedGlobal.map(t => e.tags.models.globalSubredditTags[t]),
				I = e => e.tags.models.globalSubredditTags,
				S = e => e.tags.availableGlobalTagOrder.global.map(t => e.tags.models.globalSubredditTags[t]),
				w = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditScopedTags[n] || j
				},
				T = (e, t) => {
					const n = i()(t);
					for (let s = 0; s < n.length; s++)
						if (n[s].text.toLowerCase().trim() === e.toLowerCase().trim()) return n[s];
					return null
				},
				N = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.itemTags[n] || C
				},
				P = (e, t) => {
					let {
						itemId: n
					} = t;
					return !!e.tags.models.itemTags[n]
				},
				R = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.suggestedItemTags[n] || C
				},
				A = (e, t) => {
					let {
						itemId: n
					} = t;
					return i()(R(e, {
						itemId: n
					})).filter(e => e.isRelevant).map(e => Object(c.e)(e, !0))
				},
				M = (e, t) => {
					let {
						itemId: n
					} = t;
					return e.tags.models.sortedItemTags[n] || []
				},
				L = Object(a.a)((e, t) => {
					let {
						thingId: n,
						suggested: s = !1
					} = t;
					const r = U(e, {
						subredditId: n
					});
					return i()(((e, t) => {
						let {
							thingId: n,
							suggested: s = !1
						} = t;
						const r = (s ? g(e, {
								subredditId: n
							}) : _(e, {
								subredditId: n
							})) ? S(e) : k(e),
							o = s ? E(e, {
								subredditId: n
							}) : O(e, {
								subredditId: n
							}),
							i = r.reduce((e, t) => (e[t.id] = Object(c.f)(t), e), {});
						return o.reduce((e, t) => (t.id && e[t.id] && (e[t.id].selected = !0), e), i)
					})(e, {
						thingId: n,
						suggested: s
					})).filter(e => !e.selected && e.id !== r)
				}),
				D = (e, t) => {
					let {
						subredditId: n
					} = t;
					return O(e, {
						subredditId: n
					}).concat(y(e, {
						subredditId: n
					}))
				},
				F = (e, t) => {
					let {
						subredditId: n
					} = t;
					return O(e, {
						subredditId: n
					}).filter(d.b).map(e => ({
						text: e.displayText,
						type: c.c.CLASSIFICATION
					}))
				},
				U = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.tags.models.subredditPrimaryTagId[n] || null
				},
				B = (e, t) => t && e.tags.models.globalSubredditTags[t] || null,
				q = (e, t) => {
					const n = e.tags.selected.selectedPrimaryTagId[t.subredditId] || null;
					return B(e, n)
				},
				G = (e, t) => {
					const n = U(e, t);
					return B(e, n)
				},
				H = e => e.tags.creation.selectedPrimaryTagId || null,
				W = e => {
					const t = H(e);
					return B(e, t)
				},
				V = e => e.tags.api.updatePrimaryTag.pending,
				z = (e, t) => {
					let {
						subredditId: n
					} = t;
					return Object.keys(N(e, {
						itemId: n
					})).length > 0
				}
		},
		"./src/reddit/selectors/tooltip.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return s
			})), n.d(t, "b", (function() {
				return r
			})), n.d(t, "c", (function() {
				return o
			}));
			const s = e => e.tooltip.tooltipId,
				r = e => t => t.tooltip.tooltipId === e,
				o = e => e.tooltip.params
		},
		"./src/reddit/selectors/userFlair.ts": function(e, t, n) {
			"use strict";
			n.d(t, "d", (function() {
				return c
			})), n.d(t, "a", (function() {
				return l
			})), n.d(t, "e", (function() {
				return u
			})), n.d(t, "f", (function() {
				return m
			})), n.d(t, "b", (function() {
				return p
			})), n.d(t, "c", (function() {
				return b
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/models/Flair/index.ts"),
				o = n("./src/reddit/selectors/gold/powerups/index.ts"),
				i = n("./src/reddit/selectors/moderatorPermissions.ts"),
				a = n("./src/lib/initializeClient/installReducer.ts"),
				d = n("./src/reddit/reducers/features/userFlair/index.ts");
			Object(a.a)({
				features: {
					userFlair: d.a
				}
			});
			const c = (e, t) => {
					let {
						subredditId: n
					} = t;
					return e.features.userFlair[n]
				},
				l = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, r;
					return null === (s = e.features.userFlair[n]) || void 0 === s || !s.displaySettings || !!(null === (r = e.features.userFlair[n].displaySettings) || void 0 === r ? void 0 : r.isEnabled)
				},
				u = (e, t) => {
					let {
						subredditId: n
					} = t;
					var s, o;
					return (null === (s = e.features.userFlair[n]) || void 0 === s ? void 0 : s.displaySettings) ? null === (o = e.features.userFlair[n].displaySettings) || void 0 === o ? void 0 : o.position : r.b.Right
				},
				m = Object(s.a)((e, t) => {
					let {
						subredditId: n
					} = t;
					const s = c(e, {
						subredditId: n
					});
					if (s && s.displaySettings && s.permissions) return {
						type: r.d.UserFlair,
						displaySettings: s.displaySettings,
						permissions: s.permissions
					}
				}),
				p = (e, t) => {
					let {
						subredditId: n
					} = t;
					const s = l(e, {
							subredditId: n
						}),
						r = m(e, {
							subredditId: n
						}),
						o = c(e, {
							subredditId: n
						});
					if (!s || !r || !o) return !1;
					if (o.applied) return !0;
					const a = Object(i.g)(e, {
							subredditId: n
						}),
						{
							canUserChange: d
						} = r.permissions;
					return !!(o.templateIds || []).find(e => {
						return !o.templates[e].modOnly || a
					}) && d
				},
				b = (e, t) => {
					let {
						subredditId: n
					} = t;
					if (!n) return !1;
					const s = p(e, {
							subredditId: n
						}),
						r = Object(o.f)(e, {
							subredditId: n
						});
					return s || r
				}
		},
		"./src/reddit/selectors/userPrefs.ts": function(e, t, n) {
			"use strict";
			n.d(t, "c", (function() {
				return o
			})), n.d(t, "b", (function() {
				return i
			})), n.d(t, "d", (function() {
				return a
			})), n.d(t, "a", (function() {
				return d
			}));
			var s = n("./src/lib/constants/index.ts"),
				r = n("./src/reddit/selectors/experiments/loggedOutOneFeed.ts");
			const o = e => {
					if (i(e)) return !1;
					const {
						subscriptionsPinned: t
					} = e.user.prefs;
					return !(void 0 !== t || !Object(r.c)(e)) || !!t
				},
				i = e => !(!e.platform.currentPage || !e.platform.currentPage.meta || e.platform.currentPage.meta.name !== s.Sb.MODERATION_PAGES),
				a = e => e.user.prefs.reduceAnimationsFromAwards,
				d = e => !!e.user.prefs.over18
		},
		"./src/reddit/selectors/widgets.ts": function(e, t, n) {
			"use strict";
			n.d(t, "a", (function() {
				return l
			})), n.d(t, "k", (function() {
				return u
			})), n.d(t, "c", (function() {
				return m
			})), n.d(t, "d", (function() {
				return p
			})), n.d(t, "i", (function() {
				return b
			})), n.d(t, "e", (function() {
				return f
			})), n.d(t, "f", (function() {
				return h
			})), n.d(t, "j", (function() {
				return _
			})), n.d(t, "h", (function() {
				return g
			})), n.d(t, "g", (function() {
				return v
			})), n.d(t, "b", (function() {
				return x
			}));
			var s = n("./src/lib/objectSelector/index.ts"),
				r = n("./src/reddit/constants/posts.ts"),
				o = n("./src/reddit/helpers/name/index.ts"),
				i = n("./src/reddit/helpers/widgets/index.tsx"),
				a = n("./src/reddit/selectors/profile.ts"),
				d = n("./src/reddit/selectors/subreddit.ts");
			const c = [],
				l = e => e.widgets.models,
				u = Object(s.a)((e, t) => Object(i.l)(t) ? e.widgets.models[t.widgetId] : Object(i.f)(t.widgetKind)),
				m = (e, t) => e.widgets.idCardIds[t.subredditId],
				p = (e, t) => {
					let n = t.subredditId;
					if (!n && t.subredditName && (n = Object(d.I)(e, t.subredditName)), n) {
						const t = m(e, {
							subredditId: n
						});
						if (t) return e.widgets.models[t]
					}
					return null
				},
				b = (e, t) => e.widgets.sidebar[t.subredditId] || [],
				f = (e, t) => e.widgets.menuIds[t.subredditId],
				h = (e, t) => {
					const n = f(e, t);
					return n ? e.widgets.models[n] : null
				},
				_ = (e, t) => {
					const n = e.widgets.sidebar[t.subredditId];
					return Array.isArray(n) ? n.reduce((t, n) => {
						const s = e.widgets.models[n];
						return s && t.push(s.kind), t
					}, []) : c
				},
				g = (e, t) => {
					const n = b(e, t);
					for (const s of n) {
						const t = e.widgets.models[s];
						if ("subreddit-rules" === t.kind) return t
					}
					return null
				},
				v = (e, t) => {
					const n = b(e, t).map(t => e.widgets.models[t]).filter(e => "post-flair" === e.kind);
					return n.length ? n : null
				},
				x = Object(s.a)((e, t) => {
					if (t.type === r.a.PROFILE) {
						const n = Object(a.k)(e, {
							profileName: t.name
						});
						return n ? {
							profile: {
								id: n.id,
								name: Object(o.i)(n.name)
							}
						} : {}
					}
					const n = Object(d.C)(e, {
							subredditName: t.name
						}),
						s = Object(d.z)(e, {
							subredditName: t.name
						});
					return {
						subreddit: {
							categoryName: s ? s.contentCategory : null,
							id: n.id,
							name: Object(o.i)(n.name)
						}
					}
				})
		},
		"./src/reddit/singleton/EventSystem.ts": function(e, t, n) {
			"use strict";
			var s = n("./src/config.ts"),
				r = n("./src/lib/fastdom/index.ts"),
				o = n("./src/reddit/actions/jsApi.ts");
			const i = "JSAPI customEvent.detail.name is deprecated. Please upgrade to <meta>",
				a = "jsapi.consumer",
				d = "/r/redesign/wiki/jsapi";
			var c = n("./src/reddit/constants/jsapiEvents.ts");
			const l = 100;
			const u = new class {
				constructor() {
					if (this.queue = [], this.active = !1, "undefined" == typeof document) return;
					let e;
					this.store = new Promise(t => e = t), this.attachStore = t => e(t);
					const t = document.querySelectorAll(`meta[name="${a}"]`);
					t.length && (t.forEach(e => {
						const t = e.content;
						this.store.then(e => e.dispatch(o.b(t)))
					}), this.store.then(() => this.fireEventsQueue())), document.addEventListener(c.b, e => this.onReadyEvent(e), !0)
				}
				onReadyEvent(e) {
					let t;
					if (this.active = !0, e.target && e.target instanceof HTMLMetaElement && e.target.name === a && (t = e.target.content), !t) try {
						e.detail && (t = e.detail.name, console.warn(i, `${s.a.redditUrl}${d}`, e))
					} catch (n) {
						return void console.error(i, `${s.a.redditUrl}${d}`, n)
					}
					this.store.then(e => {
						e.dispatch(o.b(t || "")), this.fireEventsQueue()
					})
				}
				publish(e, t, n) {
					const s = {
						name: e,
						props: t,
						element: n
					};
					this.queue.push(s), this.queue.length > l && this.queue.shift(), this.active && this.fireEvent(s)
				}
				fireEvent(e) {
					e.element.dispatchEvent(new CustomEvent(e.name, {
						detail: e.props
					}))
				}
				fireEventsQueue() {
					r.a.read(() => {
						for (let e = 0; e < this.queue.length; e++) {
							const t = this.queue[e];
							this.fireEvent(t)
						}
					})
				}
			};
			t.a = u
		},
		"./src/redditGQL/operations/AddApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"84b1688a0244"}')
		},
		"./src/redditGQL/operations/AddPredictionDrafts.json": function(e) {
			e.exports = JSON.parse('{"id":"bed8dda2f5d6"}')
		},
		"./src/redditGQL/operations/AllModerators.json": function(e) {
			e.exports = JSON.parse('{"id":"fcd88a3eea91"}')
		},
		"./src/redditGQL/operations/BadgeIndicators.json": function(e) {
			e.exports = JSON.parse('{"id":"9d105ce5d71a"}')
		},
		"./src/redditGQL/operations/BlockAwarder.json": function(e) {
			e.exports = JSON.parse('{"id":"9769ffbb7031"}')
		},
		"./src/redditGQL/operations/CancelPrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"fac88c91fec8"}')
		},
		"./src/redditGQL/operations/ChangePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"614dbb8a54d2"}')
		},
		"./src/redditGQL/operations/ChangePredictionVote.json": function(e) {
			e.exports = JSON.parse('{"id":"90c7b71fa93f"}')
		},
		"./src/redditGQL/operations/CommentToxicity.json": function(e) {
			e.exports = JSON.parse('{"id":"445164f0825f"}')
		},
		"./src/redditGQL/operations/CommentsPageLastAuthorModNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"1b7d106afc6c"}')
		},
		"./src/redditGQL/operations/CreateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"eeb2e6945769"}')
		},
		"./src/redditGQL/operations/CreateCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"e443629d50b0"}')
		},
		"./src/redditGQL/operations/CreateModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"10ad38be41ae"}')
		},
		"./src/redditGQL/operations/CreatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"96248048973d"}')
		},
		"./src/redditGQL/operations/CreateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"737d59db38fc"}')
		},
		"./src/redditGQL/operations/CreateSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"80c9a3cd96b8"}')
		},
		"./src/redditGQL/operations/DeleteCustomEmoji.json": function(e) {
			e.exports = JSON.parse('{"id":"c13d195ee7ca"}')
		},
		"./src/redditGQL/operations/DeleteInboxNotifications.json": function(e) {
			e.exports = JSON.parse('{"id":"ce2deb9deef7"}')
		},
		"./src/redditGQL/operations/DeleteModUserNote.json": function(e) {
			e.exports = JSON.parse('{"id":"c44e6467c4d7"}')
		},
		"./src/redditGQL/operations/DeleteScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"dea861ad7f0d"}')
		},
		"./src/redditGQL/operations/DeleteSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c518a45f60a5"}')
		},
		"./src/redditGQL/operations/EndPredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"e8df06cf3692"}')
		},
		"./src/redditGQL/operations/EventPostsBySubredditName.json": function(e) {
			e.exports = JSON.parse('{"id":"56f096f0837a"}')
		},
		"./src/redditGQL/operations/FetchContentControls.json": function(e) {
			e.exports = JSON.parse('{"id":"58b71dbd3384"}')
		},
		"./src/redditGQL/operations/FetchGlobalTags.json": function(e) {
			e.exports = JSON.parse('{"id":"f4a581740c21"}')
		},
		"./src/redditGQL/operations/FetchModerationLogActions.json": function(e) {
			e.exports = JSON.parse('{"id":"cf6fe90c07f3"}')
		},
		"./src/redditGQL/operations/FetchModerationLogActionsImproved.json": function(e) {
			e.exports = JSON.parse('{"id":"afb086c5260b"}')
		},
		"./src/redditGQL/operations/FetchSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"df4f7fe92d1f"}')
		},
		"./src/redditGQL/operations/FetchSubredditTags.json": function(e) {
			e.exports = JSON.parse('{"id":"bac623887684"}')
		},
		"./src/redditGQL/operations/FetchSubredditTrafficStats.json": function(e) {
			e.exports = JSON.parse('{"id":"d2b39ab0293a"}')
		},
		"./src/redditGQL/operations/FetchSubredditsNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"5d042135b4c5"}')
		},
		"./src/redditGQL/operations/GenerateCustomEmojiUploadLease.json": function(e) {
			e.exports = JSON.parse('{"id":"cbcafcbff9c6"}')
		},
		"./src/redditGQL/operations/GeoPlaceAutocomplete.json": function(e) {
			e.exports = JSON.parse('{"id":"8a89fd7c7db1"}')
		},
		"./src/redditGQL/operations/GetCommentById.json": function(e) {
			e.exports = JSON.parse('{"id":"37c330929714"}')
		},
		"./src/redditGQL/operations/GetModUserNotes.json": function(e) {
			e.exports = JSON.parse('{"id":"0eb0efc0bf02"}')
		},
		"./src/redditGQL/operations/GetPredictionChipPackages.json": function(e) {
			e.exports = JSON.parse('{"id":"5ce83e513fa5"}')
		},
		"./src/redditGQL/operations/GetPredictionCreationAllowance.json": function(e) {
			e.exports = JSON.parse('{"id":"d9fb5ec5128f"}')
		},
		"./src/redditGQL/operations/GetPredictionToken.json": function(e) {
			e.exports = JSON.parse('{"id":"26b911e67a5f"}')
		},
		"./src/redditGQL/operations/GetSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"abd8b9be540b"}')
		},
		"./src/redditGQL/operations/GetSubredditQuestions.json": function(e) {
			e.exports = JSON.parse('{"id":"15c4ad40a0bc"}')
		},
		"./src/redditGQL/operations/GetSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ba4eb4e2972f"}')
		},
		"./src/redditGQL/operations/GetTotalModNoteCount.json": function(e) {
			e.exports = JSON.parse('{"id":"bb325c103c55"}')
		},
		"./src/redditGQL/operations/GetTournaments.json": function(e) {
			e.exports = JSON.parse('{"id":"7cbb08d82bb0"}')
		},
		"./src/redditGQL/operations/GetTournamentsBaseInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"cebfc8734cec"}')
		},
		"./src/redditGQL/operations/LiveVideoPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"b3343d9362cd"}')
		},
		"./src/redditGQL/operations/MaybeDeleteTagsAndUpdateItemTags.json": function(e) {
			e.exports = JSON.parse('{"id":"023547ccdaf6"}')
		},
		"./src/redditGQL/operations/ModQueueItems.json": function(e) {
			e.exports = JSON.parse('{"id":"1ff9e2dec5fe"}')
		},
		"./src/redditGQL/operations/ModQueueTriggers.json": function(e) {
			e.exports = JSON.parse('{"id":"de8696c3b5fd"}')
		},
		"./src/redditGQL/operations/ModerationActionCategories.json": function(e) {
			e.exports = JSON.parse('{"id":"45bc34defbb5"}')
		},
		"./src/redditGQL/operations/MutedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"c09ff0d041c1"}')
		},
		"./src/redditGQL/operations/NotificationInboxFeed.json": function(e) {
			e.exports = JSON.parse('{"id":"be3e43b15ada"}')
		},
		"./src/redditGQL/operations/NotificationInboxFeedSlimmed.json": function(e) {
			e.exports = JSON.parse('{"id":"916e9e9be5e0"}')
		},
		"./src/redditGQL/operations/NotificationSettingsLayoutByChannel.json": function(e) {
			e.exports = JSON.parse('{"id":"d03522f8a8d4"}')
		},
		"./src/redditGQL/operations/OpenAISubRecWithDetail.json": function(e) {
			e.exports = JSON.parse('{"id":"75d86d72b7b4"}')
		},
		"./src/redditGQL/operations/PollVote.json": function(e) {
			e.exports = JSON.parse('{"id":"a20cc8dd230d"}')
		},
		"./src/redditGQL/operations/PopularFeedElements.json": function(e) {
			e.exports = JSON.parse('{"id":"90c9f649d5c3"}')
		},
		"./src/redditGQL/operations/ProfileFeed.json": function(e) {
			e.exports = JSON.parse('{"id":"50cb3ed75c5e"}')
		},
		"./src/redditGQL/operations/RedditorPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"e2bcd0fbaace"}')
		},
		"./src/redditGQL/operations/RemoveApprovedTalkHost.json": function(e) {
			e.exports = JSON.parse('{"id":"e016564e243a"}')
		},
		"./src/redditGQL/operations/ReportMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"ae01229e1caa"}')
		},
		"./src/redditGQL/operations/ResolvePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"d742e3019cfe"}')
		},
		"./src/redditGQL/operations/SetSubredditGeoPlace.json": function(e) {
			e.exports = JSON.parse('{"id":"ece6b91ed02d"}')
		},
		"./src/redditGQL/operations/SubmitScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"6f9e584d390a"}')
		},
		"./src/redditGQL/operations/SubredditAbout.json": function(e) {
			e.exports = JSON.parse('{"id":"dd7c6e248f77"}')
		},
		"./src/redditGQL/operations/SubredditAchievementFlairs.json": function(e) {
			e.exports = JSON.parse('{"id":"97fec841c778"}')
		},
		"./src/redditGQL/operations/SubredditApprovedTalkHosts.json": function(e) {
			e.exports = JSON.parse('{"id":"86107f5fbae2"}')
		},
		"./src/redditGQL/operations/SubredditCustomEmojis.json": function(e) {
			e.exports = JSON.parse('{"id":"76faa900e33f"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditorByName.json": function(e) {
			e.exports = JSON.parse('{"id":"11aba1560164"}')
		},
		"./src/redditGQL/operations/SubredditFlairedRedditors.json": function(e) {
			e.exports = JSON.parse('{"id":"d343c3cad2d0"}')
		},
		"./src/redditGQL/operations/SubredditInfo.json": function(e) {
			e.exports = JSON.parse('{"id":"29aee4089528"}')
		},
		"./src/redditGQL/operations/SubredditPage.json": function(e) {
			e.exports = JSON.parse('{"id":"451fe5e7040e"}')
		},
		"./src/redditGQL/operations/SubredditPageExtra.json": function(e) {
			e.exports = JSON.parse('{"id":"99a33079240e"}')
		},
		"./src/redditGQL/operations/SubredditPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"8d2145ac1ec5"}')
		},
		"./src/redditGQL/operations/SubredditPowerupsFull.json": function(e) {
			e.exports = JSON.parse('{"id":"59a710ebaf82"}')
		},
		"./src/redditGQL/operations/SubredditRules.json": function(e) {
			e.exports = JSON.parse('{"id":"c398abb500f1"}')
		},
		"./src/redditGQL/operations/SubredditScheduledPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"2289de7a3370"}')
		},
		"./src/redditGQL/operations/SubredditTopPredictors.json": function(e) {
			e.exports = JSON.parse('{"id":"a9f7697930b7"}')
		},
		"./src/redditGQL/operations/SubredditTournamentLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"e14e6d1892e6"}')
		},
		"./src/redditGQL/operations/SubredditWiki.json": function(e) {
			e.exports = JSON.parse('{"id":"5834be60ee7a"}')
		},
		"./src/redditGQL/operations/SubredditWikiBannedContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"9b728f1ed735"}')
		},
		"./src/redditGQL/operations/SubredditWikiContributors.json": function(e) {
			e.exports = JSON.parse('{"id":"6ff60c2af7f1"}')
		},
		"./src/redditGQL/operations/SubredditWikiPageSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"03acb455993d"}')
		},
		"./src/redditGQL/operations/SubscribedSubreddits.json": function(e) {
			e.exports = JSON.parse('{"id":"ca83defc2e15"}')
		},
		"./src/redditGQL/operations/TopAwardedPosts.json": function(e) {
			e.exports = JSON.parse('{"id":"c7d68c8d5c0b"}')
		},
		"./src/redditGQL/operations/TopAwardersLeaderboard.json": function(e) {
			e.exports = JSON.parse('{"id":"750ff4a757de"}')
		},
		"./src/redditGQL/operations/UpdateComment.json": function(e) {
			e.exports = JSON.parse('{"id":"3d83ef4f0375"}')
		},
		"./src/redditGQL/operations/UpdateCommentDistinguishState.json": function(e) {
			e.exports = JSON.parse('{"id":"e1f407c8ceba"}')
		},
		"./src/redditGQL/operations/UpdateCommentFollowState.json": function(e) {
			e.exports = JSON.parse('{"id":"0a2ed51664c5"}')
		},
		"./src/redditGQL/operations/UpdateCommentStickyState.json": function(e) {
			e.exports = JSON.parse('{"id":"236938d65d55"}')
		},
		"./src/redditGQL/operations/UpdateHatefulContentFilters.json": function(e) {
			e.exports = JSON.parse('{"id":"026bf4f1acc7"}')
		},
		"./src/redditGQL/operations/UpdateInboxActivitySeenState.json": function(e) {
			e.exports = JSON.parse('{"id":"85d656894a08"}')
		},
		"./src/redditGQL/operations/UpdateNotificationPreferences.json": function(e) {
			e.exports = JSON.parse('{"id":"129085be0500"}')
		},
		"./src/redditGQL/operations/UpdatePostRequirements.json": function(e) {
			e.exports = JSON.parse('{"id":"8732ab4560ce"}')
		},
		"./src/redditGQL/operations/UpdatePowerupsSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"699ae1616006"}')
		},
		"./src/redditGQL/operations/UpdatePredictionTournament.json": function(e) {
			e.exports = JSON.parse('{"id":"040d9bcf301a"}')
		},
		"./src/redditGQL/operations/UpdateScheduledPost.json": function(e) {
			e.exports = JSON.parse('{"id":"db256acfa640"}')
		},
		"./src/redditGQL/operations/UpdateSubredditCountrySiteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"c21fac68db2d"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteAndNotificationLevelSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"2620d72fd633"}')
		},
		"./src/redditGQL/operations/UpdateSubredditMuteSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"432f6b475ece"}')
		},
		"./src/redditGQL/operations/UpdateSubredditNotificationSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"0af4f630a2e1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditPrimaryTag.json": function(e) {
			e.exports = JSON.parse('{"id":"a2d0aa1efdbc"}')
		},
		"./src/redditGQL/operations/UpdateSubredditStreamingModSettings.json": function(e) {
			e.exports = JSON.parse('{"id":"1f690708b8b1"}')
		},
		"./src/redditGQL/operations/UpdateSubredditTagStatesRelevance.json": function(e) {
			e.exports = JSON.parse('{"id":"ee43ccb6e5eb"}')
		},
		"./src/redditGQL/operations/UpdateSubredditWelcomeMessage.json": function(e) {
			e.exports = JSON.parse('{"id":"1e4c7b58a2a4"}')
		},
		"./src/redditGQL/operations/UserPowerups.json": function(e) {
			e.exports = JSON.parse('{"id":"5460e33eb672"}')
		},
		"./src/redditGQL/operations/UserSubredditsNotificationsLevel.json": function(e) {
			e.exports = JSON.parse('{"id":"775bcf2e4ca3"}')
		},
		"./src/redditGQL/operations/ValidateCreateSubreddit.json": function(e) {
			e.exports = JSON.parse('{"id":"4c43ed06b3c2"}')
		},
		"./src/redditGQL/operations/VotePrediction.json": function(e) {
			e.exports = JSON.parse('{"id":"484780ada6a2"}')
		},
		"./src/redditGQL/operations/WhereToPostSubRec.json": function(e) {
			e.exports = JSON.parse('{"id":"ccdee2f3b85a"}')
		},
		"./src/redditGQL/operations/WikiComparisonDiff.json": function(e) {
			e.exports = JSON.parse('{"id":"37afdc03bbf6"}')
		},
		"./src/redditGQL/operations/WikiRevisions.json": function(e) {
			e.exports = JSON.parse('{"id":"83e11ebf7cbf"}')
		}
	}
]);
//# sourceMappingURL=https://www.redditstatic.com/desktop2x/ModerationPages.1399f664bab18b1d2a17.js.map